<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-commons-de">
  <title>Allgemeine Sprachelemente</title>
  <para>Dieser Abschnitt behandelt die Elemente, die in der SQL-Sprache als allgemeingültig betrachtet
    werden können&mdash;die <firstterm>Ausdrücke</firstterm>, die verwendet werden um Fakten aus Daten
    zu extrahieren, diese zu verarbeiten und die <firstterm>Prädikate</firstterm>, die den
    Wahrheitswert dieser Fakten prüfen.</para>
  <section id="fblangref25-commons-expressions-de">
    <title>Ausdrücke</title>
    <para>SQL-Ausdrücke bieten formelle Methoden zum Auswerten, Transformieren und Vergleichen
    von Werten. SQL-Ausdrücke können Tabellenspalten, Variablen, Konstanten, Literale, andere Statements
    und Prädikate sowie andere Ausdrücke enthalten. Folgend die vollständige Liste möglicher Elemente.</para>

    <table id="fblangref25-dtyp-tbl-exprelements-de">
    <?dbfo keep-together='auto'?>
      <title>Beschreibung der Ausdruck-Elemente</title>
      <tgroup cols="2">
        <colspec colname="colElem" colwidth="2*"></colspec>
        <colspec colname="colDesc" colwidth="5*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Element</entry>
            <entry align="center">Beschreibung</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="left">Spaltenname</entry>
            <entry align="left">Kennung einer Spalte aus einer angegebenen Tabelle, die in Auswertungen 
                oder als Suchbedingung verwendet wird. Eine Spalte des Array-Typs kann kein
                Element innerhalb eines Ausdrucks sein, es sei denn sie wird mit dem 
                <database>IS [NOT] NULL</database>-Prädikat verwendet.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Array-Element</entry>
            <entry align="left">Ein Ausdruck kann einen Verweis auf ein Array-Element enthalten.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Arithmetische Operatoren</entry>
            <entry align="left">Die Zeichen +, -, *, / werden verwendet um Berechnungen durchzuführen.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Verkettungsoperator</entry>
            <entry align="left">Der Operator || (<quote>Doppel-Pipe</quote>) wird verwendet um Strings zu 
            verketten.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Logische Operatoren</entry>
            <entry align="left">Die reservierten Wörter NOT, AND sowie OR werden verwendet um einfache Suchbedingungen
                oder komplexere Behauptungen zu erstellen.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Vergleichsoperatoren</entry>
            <entry align="left">Die Zeichen =, &lt;&gt;, !=, ~=, ^=, &lt;, &lt;=, &gt;, &gt;=, 
            !&lt;, ~&lt;, ^&lt;, !&gt;, ~&gt; und ^&gt;</entry>
          </row>
          <row valign="middle">
            <entry align="left">Vergleichsprädikate</entry>
            <entry align="left"><database>LIKE, STARTING WITH, CONTAINING, SIMILAR TO, BETWEEN,
            IS [NOT] NULL</database> und <database>IS [NOT] DISTINCT FROM</database></entry>
          </row>
          <row valign="middle">
            <entry align="left">Existenzprädikate</entry>
            <entry align="left">Prädikate, die für die Existenzprüfung von Werten Verwendung finden.
                Das Prädikat <database>IN</database> kann sowohl innerhalb von Listen kommagetrennter Konstanten als
                auch mit Unterabfragen, die nur eine Spalte zurückgeben, verwendet werden. Die Prädikate
                <database>EXISTS, SINGULAR, ALL, ANY</database> und <database>SOME</database> können nur mit Unterabfragen
                verwendet werden.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Konstanten</entry>
            <entry align="left">Eine Zahl; oder eine Zeichenkette, die in Apostrophs eingeschlossen wird.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Datum-/Zeitliterale</entry>
            <entry align="left">Ein Ausdruck, ähnlich zu Zeichenketten, eingeschlossen in Apostrophs, der
                als Datum, Zeit oder Zeitstempel interpretiert wird. Datumsliterale können vordefinierte
                Literale ('TODAY', 'NOW', etc.) oder Zeichenketten aus Buchstaben oder Zahlen sein, wie zum Beispiel
                '25.12.2016 15:30:35', die zu einem Datum und/oder einer Zeit aufgelöst werden können.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Kontextvariablen</entry>
            <entry align="left">Eine intern definierte Kontextvariable</entry>
          </row>
          <row valign="middle">
            <entry align="left">Lokale Variablen</entry>
            <entry align="left">Deklarierte lokale Variablen, Über- und Rückgabeparameter eines
                PSQL-Moduls (Stored Procedure, Trigger, unbenannter PSQL-Block in DSQL)</entry>
          </row>
          <row valign="middle">
            <entry align="left">Positionale Parameter</entry>
            <entry align="left">Ein Mitglied innerhalb einer geordneten Gruppe von einem oder 
                mehreren unbenannten Parametern, die an eine gespeicherte Prozedur 
                oder eine vorbereitete Abfrage übergeben wurden.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Unterabfrage</entry>
            <entry align="left">Eine SELECT-Anweisung, die in Klammern eingeschlossen ist, die einen 
                einzelnen (skalaren) Wert zurückgibt oder, wenn er in 
                existenziellen Prädikaten verwendet wird, einen Satz von Werten.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Funktionskennung</entry>
            <entry align="left">Die Kennung einer internen oder externen Funktion in einem 
                Funktionsausdruck</entry>
          </row>
          <row valign="middle">
            <entry align="left">Type-Cast</entry>
            <entry align="left">Ein Ausdruck, der explizit Daten von einem in einen anderen 
                Datentyp unter Verwendung der <database>CAST</database>-Funktion ( <function>CAST (&lt;value&gt;
            AS &lt;datatype&gt;)</function> ) konvertiert. Nur für Datum-/Zeit-Literale ist die Kurzschreibweise 
            &lt;datatype&gt; &lt;value&gt; (<function>DATE '25.12.2016'</function>) möglich.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Bedingter Ausdruck</entry>
            <entry align="left">Ausdrücke mit CASE und verwandten internen Funktionen</entry>
          </row>
          <row valign="middle">
            <entry align="left">Klammern</entry>
            <entry align="left">Klammernpaare (&hellip;) werden verwendet, um Ausdrücke zu gruppieren.
            Operationen innerhalb der Klammern werden vor Operationen außerhalb von ihnen durchgeführt. 
                Wenn eingebettete Klammern verwendet werden, werden die tiefsten eingebetteten Ausdrücke 
                zuerst ausgewertet und dann bewegen sich die Auswertungen von innen nach außen 
                durch die Einbettungsstufen.</entry>
          </row>
          <row valign="middle">
            <entry align="left">COLLATE-Klausel</entry>
            <entry align="left">Klausel, die für CHAR- und VARCHAR-Datentypen angewendet werden kann, um
                die Collation für String-Vergleiche festzulegen.</entry>
          </row>
          <row valign="middle">
            <entry align="left"><database>NEXT VALUE FOR</database> <replaceable>Sequenz</replaceable></entry>
            <entry align="left">Ausdruck zum Ermitteln des nächsten Wertes eines bestimmten Generators (Sequenz).
            Die interne Funktion <database>GEN_ID()</database> tut das Gleiche.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="fblangref25-commons-constants-de">
      <title>Konstanten</title>
      <para>Eine Konstante ist ein Wert der direkt in einem SQL-Statement verwendet wird
          und weder von einem Ausdruck, einem Parameter, einem Spaltenverweis noch einer Variablen
          abgeleitet wird. Dies kann eine Zeichenkette oder eine Zahl sein.</para>

      <section id="fblangref25-commons-string-constant-de">
        <title>Zeichenkonstanten (Literale)</title>
        <para>Eine String-Konstante ist eine Aneinanderreihung von Zeichen, die zwischen einem 
            Paar von Apostrophen (<quote>einfache Anführungszeichen</quote>) eingeschlossen werden.
            Die größtmögliche Länge dieser Zeichenketten ist 32.767 Bytes; die maximale Anzahl der 
            Zeichen wird durch die verwendete Zeichenkodierung bestimmt.</para>
        <note>
          <itemizedlist>
            <listitem>Doppelte Anführungszeichen <emphasis>dürfen nicht</emphasis> für die Kennzeichnung
            von Zeichenketten verwendet werden. SQL sieht hierfür einen anderen Zweck vor.</listitem>
            <listitem>Wird ein Apostroph innerhalb der Zeichenkette benötigt, wird dieses
            durch ein vorangehendes Apostroph <quote>escaped</quote>. Zum Beispiel
            <filename>'Mother O''Reilly's home-made hooch'</filename>.</listitem>
            <listitem>Vorsicht ist geboten bei String-Längen, wenn der Wert
                in ein Feld des Typs <database>VARCHAR</database> geschrieben wird. Hierfür gilt die
                maximale Länge von 32.765 Bytes.</listitem>
          </itemizedlist>
        </note>
        <para>Es wird angenommen, dass der Zeichensatz einer Zeichenkonstanten der gleiche ist wie 
            der Zeichensatz seines Bestimmungsspeichers.</para>


        <section id="fblangref25-commons-hexstrings-de">
          <title>Stringkonstanten in Hexadezimalnotation</title>
          <para>Ab Firebird 2.5 aufwärts, können Stringliterale in hexadezimaler Schreibweise eingegeben werden, 
          die sogenannten <quote>Binary Strings</quote>.  Jedes Paar hexadezimaler Stellen definiert ein Byte der
          Zeichenkette. Zeichenketten die in dieser Form eingegeben werden, besitzen den Zeichensatz
          <database>OCTETS</database> als Standard. Die
          <link linkend="fblangref25-commons-introducer-syntax-de"><firstterm>Introducer-Syntax</firstterm></link> 
          kann auch genutzt werden um zu erzwingen, dass die Zeichenkette als ein anderer Zeichensatz interpretiert 
          wird.</para>
          <formalpara>
            <title>Syntax</title>
            <blockquote>
              <literallayout class="monospaced">
{x|X}'<replaceable>&lt;hexstring&gt;</replaceable>'

  <replaceable>&lt;hexstring&gt;</replaceable>  ::=  eine gerade Anzahl von <replaceable>&lt;hexdigit&gt;</replaceable>
  <replaceable>&lt;hexdigit&gt;</replaceable>   ::=  eines aus 0..9, A..F, a..f
              </literallayout>
            </blockquote>
          </formalpara>
          
          <formalpara>
            <title>Beispiele</title>
            <programlisting>
    select x'4E657276656E' from rdb$database
      -- liefert 4E657276656E, a 6-byte 'binary' string

    select _ascii x'4E657276656E' from rdb$database
      -- liefert 'Nerven' (same string, now interpreted as ASCII text)

    select _iso8859_1 x'53E46765' from rdb$database
      -- liefert 'S&auml;ge' (4 chars, 4 bytes)

    select _utf8 x'53C3A46765' from rdb$database
      -- liefert 'S&auml;ge' (4 chars, 5 bytes)
            </programlisting>
          </formalpara>
          <note>
            <title>Hinweise</title>
            <para>Die Client-Schnittstelle legt fest, wie Binärzeichenfolgen dem Benutzer angezeigt werden.
            Das <emphasis>isql</emphasis>-Werkzeug beispielsweise, nutzt großgeschriebene Buchstaben A-F, während FlameRobin 
            Kleinschreibung verwendet. Andere Client-Applikationen könnten andere Konventionen bevorzugen, zum Beispiel
            Leerzeichen zwischen den Bytepaaren: '4E 65 72 76 65 6E'.</para>
            <para>Mit der hexadezimalen Notation kann jeder Bytewert (einschließlich 00) an beliebiger Stelle 
                im String eingefügt werden. Allerdings, wenn Sie diesen auf etwas anderes als OCTETS erzwingen
                wollen, liegt es in Ihrer Verantwortung, die Bytes in einer Sequenz 
                zu liefern, die für den Zielzeichensatz gültig ist.</para>
          </note>
        </section>

        <section id="fblangref25-commons-introducer-syntax-de">
          <title>Introducer-Syntax für String-Literale</title>
          <para>Bei Bedarf kann ein String-Literal einem Zeichensatznamen 
              vorangestellt werden, dem ein Unterstrich <quote>_</quote>
              vorangestellt ist. Dies wird als <firstterm>Introducer-Syntax</firstterm> bezeichnet. 
              Sein Ziel ist es, die Engine darüber zu informieren, wie man den 
              eingehenden String interpretiert und speichert.</para>
          <para>Beispiel
          <blockquote><programlisting>
INSERT INTO People
VALUES (_ISO8859_1 'Hans-J&ouml;rg Sch&auml;fer')
            </programlisting></blockquote>
          </para>
        </section>
      </section>

      <section id="fblangref25-commons-number-constant-de">
        <title>Zahlenkonstanten</title>
        <para>Eine Zahlkonstante ist eine gültige Zahl in einer unterstützten Notation:
          <itemizedlist>
            <listitem>In SQL wird der Dezimalpunkt, für Zahlen in der 
                Standard-Dezimal-Notation, immer durch das Punkt-Zeichen
                dargestellt. Tausender werden nicht getrennt. 
                Einbeziehung von Komma, Leerzeichen usw. führt zu Fehlern.
            </listitem>
            <listitem>Exponentielle Notation wird unterstützt. Zum Beispiel 
                kann 0.0000234 auch als
            <filename>2.34e-5</filename> geschrieben werden.</listitem>
            <listitem>Hexadezimal-Notation wird von Firebird 2.5 und höheren 
                Versionen unterstützt&mdash;siehe unten.</listitem>
          </itemizedlist>
        </para>
        <section id="fblangref25-commons-hexnumbers-de">
          <title>Hexadezimale Notation für Ziffern</title>
          <para>Von Firebird 2.5 aufwärts können ganzzahlige Werte in hexadezimaler 
              Notation eingegeben werden. Zahlen mit 1-8 Hex-Ziffern werden als 
              Typ INTEGER interpretiert; Zahlen mit 9-16 Hex-Ziffern als 
              Typ BIGINT.
            <formalpara>
            <title>Syntax</title>
            <blockquote><literallayout class="monospaced">
0{x|X}<replaceable>&lt;hexdigits&gt;</replaceable>

  <replaceable>&lt;hexdigits&gt;</replaceable>  ::=  1-16 als <replaceable>&lt;hexdigit&gt;</replaceable>
  <replaceable>&lt;hexdigit&gt;</replaceable>   ::=  eins aus 0..9, A..F, a..f
            </literallayout></blockquote>
          </formalpara>
          <formalpara>
            <title>Beispiele</title>
            <blockquote><programlisting>
select 0x6FAA0D3 from rdb$database           -- liefert 117088467
select 0x4F9 from rdb$database               -- liefert 1273
select 0x6E44F9A8 from rdb$database          -- liefert 1850014120
select 0x9E44F9A8 from rdb$database          -- liefert -1639646808 (an INTEGER)
select 0x09E44F9A8 from rdb$database         -- liefert 2655320488 (a BIGINT)
select 0x28ED678A4C987 from rdb$database     -- liefert 720001751632263
select 0xFFFFFFFFFFFFFFFF from rdb$database  -- liefert -1
            </programlisting></blockquote>
          </formalpara>
          </para>
          <section id="fblangref25-commons-hexranges-de">
            <title>Hexadezimale Wertebereiche</title>
            <itemizedlist>
              <listitem>
              Hex-Nummern im Bereich 0 .. 7FFF FFFF sind positive INTEGER mit Dezimalwerten
              zwischen 0 .. 2147483647. Um eine Zahl als BIGINT zu erzwingen, 
              müssen Sie genügend Nullen voranstellen, um die Gesamtzahl der Hex-Ziffern 
              auf neun oder mehr zu bringen. Das ändert den Typ, aber nicht den Wert.
              </listitem>
              <listitem>
              <para>Hex-Nummern zwischen 8000 0000 .. FFFF FFFF erfordern etwas Aufmerksamkeit:
                <itemizedlist type="circle">
                  <listitem>Bei der Eingabe mit acht Hex-Ziffern, wie in 0x9E44F9A8, 
                      wird ein Wert als 32-Bit-INTEGER interpretiert. Da das erste Bit 
                      (Vorzeichenbit) gesetzt ist, wird es dem negativen Dezimalbereich
                      -2147483648 .. -1 zugeordnet.</listitem>
                  <listitem>Bei einer oder mehreren Nullen, die wie in 0x09E44F9A8 vorangestellt werden, 
                      wird ein Wert als 64-Bit-BIGINT im Bereich 
                      0000 0000 8000 0000 .. 0000 0000 FFFF FFFF interpretiert. Das Zeichen-Bit 
                      ist jetzt nicht gesetzt, also wird der Dezimalwert dem positiven 
                      Bereich 2147483648 .. 4294967295 zugewiesen.
                  </listitem>
                </itemizedlist>
                So ergibt sich in diesem Bereich - und nur in diesem Bereich - anhand einer mathematisch 
                unbedeutenden 0 ein gänzlich anderer Wert. Dies ist zu beachten.
              </para>
              </listitem>
              <listitem>Hex-Zahlen zwischen 1 0000 0000 .. 7FFF FFFF FFFF FFFF sind alle positiv BIGINT.</listitem>
              <listitem>Hex-Zahlen zwischen 8000 0000 0000 0000 .. FFFF FFFF FFFF FFFF sind alle negativ BIGINT.</listitem>
              <listitem>
                <para>Ein SMALLINT kann nicht in Hex geschrieben werden, 
                    streng genommen zumindest, da sogar 0x1 als INTEGER ausgewertet wird. 
                    Wenn Sie jedoch eine positive Ganzzahl innerhalb des 
                    16-Bit-Bereichs 0x0000 (Dezimal-Null) bis 0x7FFF (Dezimalzahl 32767) schreiben, 
                    wird sie transparent in SMALLINT umgewandelt.
                </para>

                <para>Es ist möglich einen negativen SMALLINT in Hex zu schreiben, wobei eine 
                    4-Byte-Hexadezimalzahl im Bereich 0xFFFF8000 (Dezimal -32768) bis 0xFFFFFFFF 
                    (Dezimal -1) verwendet wird.</para>
              </listitem>
            </itemizedlist>
          </section><!-- hexranges -->
        </section><!-- hexnumbers -->
      </section><!-- number constant -->
    </section><!-- constants -->

    <section id="fblangref25-commons-sqloperators-de">
      <title>SQL-Operatoren</title>
      <para>SQL-Operatoren umfassen Operatoren zum Vergleichen, Berechnen, Auswerten und Verknüpfen von Werten.</para>

      <section id="fblangref25-commons-operpreced-de">
        <title>Vorrang der Operatoren</title>
        <para>SQL Operatoren sind in vier Typen unterteilt. Jeder Operator-Typ hat eine 
            <emphasis>Priorität</emphasis>, eine Rangfolge, die die Reihenfolge bestimmt, 
            in der die Operatoren und die mit ihrer Hilfe erhaltenen Werte in einem Ausdruck ausgewertet werden. 
            Je höher der Vorrang des Operator-Typs ist, desto früher wird er ausgewertet.
            Jeder Operator hat seine eigene Priorität innerhalb seines Typs, der die Reihenfolge bestimmt, 
            in der sie in einem Ausdruck ausgewertet werden.</para>
        <para>Operatoren der gleichen Rangfolge werden von links nach rechts ausgewertet.
            Um dieses Verhalten zu beeinflussen, können Gruppen mittels Klammern erstellt 
            werden.</para>

        <table id="fblangref25-dtyp-tbl-operpreced-de">
        <?dbfo keep-together='auto'?>
          <title>Vorrang der Operatortypen</title>
          <tgroup cols="3">
            <colspec colname="col01" colwidth="1*"></colspec>
            <colspec colname="col02" colwidth="1*"></colspec>
            <colspec colname="col03" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Operatortyp</entry>
                <entry align="center">Vorrang</entry>
                <entry align="center">Erläuterung</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">Verkettung</entry>
                <entry align="center">1</entry>
                <entry align="left">Strings werden verkettet, bevor andere Operationen stattfinden</entry>
              </row>
              <row valign="middle">
                <entry align="center">Arithmetik</entry>
                <entry align="center">2</entry>
                <entry align="left">Arithmetische Operationen werden durchgeführt, nachdem Strings verkettet sind, 
                    aber vor Vergleichs- und logischen Operationen</entry>
              </row>
              <row valign="middle">
                <entry align="center">Vergleiche</entry>
                <entry align="center">3</entry>
                <entry align="left">Vergleichsoperationen erfolgen nach String-Verkettung und 
                    arithmetischen Operationen, aber vor logischen Operationen</entry>
              </row>
              <row valign="middle">
                <entry align="center">Logical</entry>
                <entry align="center">4</entry>
                <entry align="left">Logische Operatoren werden nach allen anderen Operatortypen ausgeführt</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <section id="fblangref25-commons-concat-de">
          <title>Verkettungsoperator</title>
          <para>Der Verkettungsoperator, zwei Pipe-Zeichen, auch <quote>Doppel-Pipe</quote>&mdash;
          <command> || </command>&mdash; verkettet (verbindet) zwei Zeichenketten
          zu einer einzigen Zeichenkette. Zeichenketten können dabei Konstante Werte oder abgeleitet von einer
          Spalte oder einem Ausdruck sein.</para>
          <formalpara><title>Beispiel</title>
            <programlisting>
       SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
       FROM EMPLOYEE
            </programlisting>
          </formalpara>
        </section>

        <section id="fblangref25-commons-arith-de">
          <title>Arithmetische Operatoren</title>
          <table id="fblangref25-dtyp-tbl-arithpreced-de">
          <?dbfo keep-together='auto'?>
            <title>Vorrang arithmetischer Operatoren</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Zweick</entry>
                  <entry align="center">Vorrang</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>+ <replaceable>Zahl mit Vorzeichen</replaceable></command></entry>
                  <entry align="center">unäres Plus</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>- <replaceable>Zahl mit Vorzeichen</replaceable></command></entry>
                  <entry align="center">unäres Minus</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>*</command></entry>
                  <entry align="center">Multiplikation</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>/</command></entry>
                  <entry align="center">Division</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>+</command></entry>
                  <entry align="center">Addition</entry>
                  <entry align="center">3</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>-</command></entry>
                  <entry align="center">Subtraktion</entry>
                  <entry align="center">3</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <formalpara>
            <title>Beispiel</title>
            <programlisting>
       UPDATE T
         SET A = 4 + 1/(B-C)*D
            </programlisting>
          </formalpara>
          <note>
            <para>Wenn Operatoren den gleichen Vorrang besitzen, werden diese
                von links nach rechts ausgewertet.</para>
          </note>
        </section><!-- Arithmetic operators -->

        <section id="fblangref25-commons-compar-de">
          <title>Vergleichsoperatoren</title>
          <table id="fblangref25-dtyp-tbl-comparpreced-de">
          <?dbfo keep-together='auto'?>
            <title>Prioritäten der Vergleichsoperatoren</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Zweck</entry>
                  <entry align="center">Priorität</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>=</command></entry>
                  <entry align="center">Ist gleich, ist identisch mit</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;&gt;, !=, ~=, ^=</command></entry>
                  <entry align="center">Ist ungleich zu</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&gt;</command></entry>
                  <entry align="center">Ist größer als</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;</command></entry>
                  <entry align="center">Ist kleiner als</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&gt;=</command></entry>
                  <entry align="center">Ist größer oder gleich als</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;=</command></entry>
                  <entry align="center">Ist kleiner oder gleich als</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>!&gt;, ~&gt;, ^&gt;</command></entry>
                  <entry align="center">Ist nicht gößer als</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>!&lt;, ~&lt;, ^&lt;</command></entry>
                  <entry align="center">Ist nicht kleiner als</entry>
                  <entry align="center">1</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>Diese Gruppe enthält außerdem die Vergleichsprädikate <database>BETWEEN, LIKE,
          CONTAINING, SIMILAR TO, IS</database> und andere.</para>
          <formalpara><title>Beispiel</title>
            <programlisting>
       IF (SALARY &gt; 1400) THEN
       &hellip;
            </programlisting>
          </formalpara>
          <formalpara><title>See also</title>
             <para><link linkend="fblangref25-commons-othercomppreds-de">Andere Vergleichsprädikate</link>.</para>
          </formalpara>
        </section> <!-- Comparison operators -->

        <section id="fblangref25-commons-logical-de">
          <title>Logische Operatoren</title>
          <table id="fblangref25-dtyp-tbl-logical-de">
          <?dbfo keep-together='auto'?>
            <title>Prioritäten logischer Operatoren</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Zweck</entry>
                  <entry align="center">Priorität</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>NOT</command></entry>
                  <entry align="center">Negierung eines Suchkriteriums</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>AND</command></entry>
                  <entry align="center">Kombiniert zwei oder mehr Prädikate, wobei jedes als wahr angesehen
                      werden muss, damit der Gesamtausdruck ebenfalls als wahr aufgelöst wird</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>OR</command></entry>
                  <entry align="center">Kombiniert zwei oder mehr Prädikate, wobei mindestens eines als wahr angesehen
                      werden muss, damit der Gesamtausdruck ebenfalls als wahr aufgelöst wird</entry>
                  <entry align="center">3</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <formalpara>
            <title>Beispiel</title>
            <programlisting>
       IF (A &lt; B OR (A &gt; C AND A &gt; D) AND NOT (C = D)) THEN &hellip;
            </programlisting>
          </formalpara>
        </section> <!-- Logical operators -->
      </section> <!-- Operator precedence -->

      <section id="fblangref25-commons-conditional-nxtvlufor-de">
        <title><database>NEXT VALUE FOR</database></title>
        <formalpara><title>Verfügbar</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <para><database>NEXT VALUE FOR</database> gibt den nächsten Wert einer Sequenz zurück.
        <database>SEQUENCE</database> ist ein SQL-konformer Begriff für Generatoren in Firebird
        und dessen Vorgänger, InterBase. Der Operator <database>NEXT VALUE FOR</database> ist
        equivalent zur ursprünglichen Funktion <database>GEN_ID (..., 1)</database> und ist die 
        empfohlene Syntax zum Holen des nächsten Wertes.</para>
        <formalpara>
          <title>Syntax für NEXT VALUE FOR</title>
          <programlisting>
       NEXT VALUE FOR <replaceable>Sequenzname</replaceable>
          </programlisting>
        </formalpara>

        <formalpara>
          <title>Beispiel</title>
          <programlisting>
       NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
          </programlisting>
        </formalpara>

        <note>
          <para>Anders als <database>GEN_ID (..., 1)</database> verwendet <database>NEXT VALUE FOR</database>
          keine Parameter, wodurch es nicht möglich ist den
          <emphasis>aktuellen Wert</emphasis> einer Sequenz zu ermitteln sowie eine andere Schrittweite als 1
          zu nutzen. <database>GEN_ID (..., &lt;step value&gt;)</database> wird noch immer für diesen Zweck verwendet.
          Eine &lt;Schrittweite&gt; von 0 gibt den aktuellen Sequenzwert zurück.</para>
        </note>

        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-ddl-sequence-de">SEQUENCE (GENERATOR)</link>,
          <link linkend="fblangref25-functions-scalarfuncs-gen_id"><database>GEN_ID()</database></link>
          </para>
        </formalpara>
      </section><!-- NEXT VALUE FOR -->
    </section> <!-- Operators -->

    <section id="fblangref25-commons-conditional-de">
      <title>Bedingte Ausdrücke</title>
      <para>Ein bedingter Ausdruck ist einer der verschiedene Werte zurückgibt, je nach verwendeter 
          Bedingung. Es besteht aus einem bedingten Funktionskonstrukt, wovon Firebird mehrere unterstützt.
          Dieser Abschnitt beschreibt nur ein bedingtes Ausdruckskonstrukt: 
          <database>CASE</database>. Alle anderen bedingten Ausdrücke sind interne Funktionen
            und leiten sich von <database>CASE</database> ab und werden in 
      <link linkend="fblangref25-functions-conditional">Bedingte Funktionen</link> beschrieben.</para>

      <section id="fblangref25-commons-conditional-case-de">
        <title><database>CASE</database></title>
        <formalpara>
          <title>Verfügbar</title><para> DSQL, PSQL</para>
        </formalpara>
        <para>Das <database>CASE</database>-Konstrukt gibt einen einzigen Wert aus einer Reihe von Werten zurück.
        Zwei syntaktische Varianten werden unterstützt:
          <itemizedlist>
            <listitem>Das <emphasis>einfache</emphasis>&nbsp;<database>CASE</database>, vergleichbar zu einem
            <firstterm>CASE-Konstrukt</firstterm> in Pascal oder einem <firstterm>Switch</firstterm> in C</listitem>
            <listitem>Das <emphasis>gesuchte</emphasis>&nbsp;<database>CASE</database>, welches wie eine Reihe
            aus &nbsp;<quote><function>if ... else if ... else if</function></quote> &nbsp;-Klauseln funktioniert.</listitem>
          </itemizedlist>
        </para>

        <section id="fblangref25-commons-conditional-case-simple-de">
          <title>Einfaches <database>CASE</database></title>
          <formalpara><title>Syntax</title>
            <programlisting>
       &hellip;
       CASE &lt;test-expr&gt;
         WHEN &lt;expr> THEN &lt;result&gt;
         [WHEN &lt;expr> THEN &lt;result&gt; ...]
         [ELSE &lt;defaultresult&gt;]
       END
       &hellip;
            </programlisting>
          </formalpara>
          <para>Wenn diese Variante verwendet wird, wird <function> &lt;test-expr&gt; </function> 
          mit &lt;expr&gt; 1, &lt;exp&gt; 2 etc. verglichen, bis ein Treffer gefunden und das
          passende Ergebnis zurückgegeben wird. Wenn kein passender Treffer vorhanden ist, wird &lt;defaultresult&gt; 
          aus der optionalen <database>ELSE</database>-Klausel zurückgegeben, 
          andernfalls <database>NULL</database>.</para>
          <para>Der Trefferwahl funktioniert identisch zum &quot;=&quot;-Operator. Daher gilt,
          wenn &lt;test-expr&gt; gleich <database>NULL</database> ist, wird kein Treffer für
          &lt;expr&gt; ermittelt, nicht einmal wenn dieser zu <database>NULL</database> aufgelöst wird.</para>
          <para>Das zurückgegebene Ergebnis muss kein literaler Wert sein: Es kann ein Feld oder ein Variablenname,
              ein Ausdruck oder <database>NULL</database>-Literal sein.</para>
            <formalpara>
              <title>Beispiel</title>
              <programlisting>
       SELECT
         NAME,
         AGE,
         CASE UPPER(SEX)
           WHEN 'M' THEN 'Male'
           WHEN 'F' THEN 'Female'
           ELSE 'Unknown'
         END GENDER,
	RELIGION
      FROM PEOPLE
              </programlisting>
            </formalpara>
          <para>Eine Kurzform des einfachen <database>CASE</database>-Konstrukts wird auch in der
          <link linkend="fblangref25-functions-scalarfuncs-decode"><database>DECODE</database></link> 
          -Funktion verwendet.</para>
        </section> <!-- Simple CASE -->

        <section id="fblangref25-commons-conditional-case-srched-de">
          <title>Gesuchtes <database>CASE</database></title>
          <formalpara>
            <title>Syntax</title>
            <programlisting>
       CASE
         WHEN &lt;bool_expr&gt; THEN &lt;result&gt;
         [WHEN &lt;bool_expr&gt; THEN &lt;result&gt; &hellip;]
         [ELSE &lt;defaultresult&gt;]
         END
            </programlisting>
          </formalpara>
          <para>Der &lt;bool_expr&gt;-Ausdruck gibt ein ternäres logisches Ergebnis zurück:
          <database>TRUE, FALSE</database> oder <database>NULL</database>. Der erste Ausdruck, der 
          <database>TRUE</database> ermittelt, wird als Ergebnis verwendet. Gibt kein Ausdruck
          <database>TRUE</database> zurück, kommt &lt;defaultresult&gt; aus der optionalen <database>ELSE</database>-Klausel
          zum Einsatz. Gibt kein Ausdruck <database>TRUE</database> zurück
          und gibt es keine <database>ELSE</database>-Klausel, ist der Rückgabewert
          <database>NULL</database>.</para>
          <para>So wie im einfachen <database>CASE</database>-Konstrukt, muss das Ergebnis nicht 
          zwangsläufig ein Literal sein: es kann ein Feld- oder Variablenname, ein zusammengesetzter Ausdruck oder 
          <database>NULL</database> sein.</para>
          <formalpara>
            <title>Beispiel</title>
            <programlisting>
       CANVOTE = CASE
         WHEN AGE &gt;= 18 THEN 'Yes'
         WHEN AGE &lt; 18 THEN 'No'
         ELSE 'Unsure'
         END
            </programlisting>
          </formalpara>
        </section> <!-- Searched CASE -->
      </section><!-- CASE -->
    </section> <!-- Conditional Expressions -->

    <section id="fblangref25-commons-null-in-expr-de">
      <title><database>NULL</database> in Ausdrücken</title>
      <para><database>NULL</database> kein Wert in SQL, sondern ein <emphasis>Status</emphasis>
      der anzeigt, dass der Wert des Elements entweder <emphasis>unbekannt</emphasis> (engl. unknown) ist oder 
      nicht existiert. Es ist weder null, noch void, noch ein <quote>leerer String</quote>, und es
      verhält sich auch nicht wie ein anderer Wert.</para>
      <para>Wenn Sie <database>NULL</database> in numerischen, String- oder Datums/Zeit-Ausdrücken 
      verwenden, wird das Ergebnis immer <database>NULL</database> sein. Verwenden Sie <database>NULL</database>
      in logischen (Boolean) Ausdrücken, hängt das Ergebnis von der Art der Operation ab und anderen
      partizipierenden Werten. Wenn Sie einen Wert mit <database>NULL</database> vergleichen, wird das Ergebnis
      <emphasis>unknown</emphasis> sein.</para>
      <important>
        <title>Zu beachten</title>
        <para><database>NULL</database> heißt <database>NULL</database>, jedoch gilt
        in Firebird, dass das logische Ergebnis <emphasis>unknown</emphasis> ebenfalls
        durch <database>NULL</database> <emphasis>repräsentiert</emphasis> wird.</para>
      </important>

      <section id="fblangref25-commons-returningnull-de">
        <title>Ausdrücke die <database>NULL</database> zurückgeben</title>
        <para>Ausdrücke in dieser Liste werden immer <database>NULL</database> zurückgeben:
          <literallayout class="monospaced">
       1 + 2 + 3 + NULL
       'Home ' || 'sweet ' || NULL
       MyField = NULL
       MyField &lt;&gt; NULL
       NULL = NULL
       not (NULL)
          </literallayout>
        Wenn es Ihnen schwerfällt dies zu verstehen, beachten Sie, dass NULL ein Status ist, der für
        <quote>unknown</quote> (unbekannt) steht.
        </para>
      </section>

      <section id="fblangref25-commons-nullinlogical-de">
        <title><database>NULL</database> in logischen Ausdrücken</title>
        <para>Es wurde bereits gezeigt, dass <function> not (NULL) </function> in
        <database>NULL</database> aufgeht. Dieser Effekt ist etwas komplizierter für logische
        <database>AND</database>- sowie logische <database>OR</database>-Operatoren:
          <literallayout class="monospaced">
       NULL or false = NULL
       NULL or true = true
       NULL or NULL = NULL
       NULL and false = false
       NULL and true = NULL
       NULL and NULL = NULL
          </literallayout>
        </para>
        <para>Bis einschließlich Firebird 2.5.x existiert keine Implementierung für logische (Boolean)
        Datentypen&mdash;diese gibt es erst seit Firebird 3. Jedoch gibt es logische Ausdrücke (Prädikate),
        die true, false oder unknown zurückgeben können.
          <formalpara>
            <title>Beispiele</title>
            <literallayout class="monospaced">
       (1 = NULL) or (1 &lt;&gt; 1) -- liefert NULL
       (1 = NULL) or (1 = 1) -- liefert TRUE
       (1 = NULL) or (1 = NULL) -- liefert NULL
       (1 = NULL) and (1 &lt;&gt; 1) -- liefert FALSE
       (1 = NULL) and (1 = 1) -- liefert NULL
       (1 = NULL) and (1 = NULL) -- liefert NULL
            </literallayout>
          </formalpara>
        </para>
      </section>
    </section> <!-- NULL in expressions -->

    <section id="fblangref25-commons-subqueries-de">
      <title>Unterabfragen</title>
      <para>Eine Unterabfrage ist eine spezielle Form eines Ausdrucks, die 
          innerhalb einer anderen Abfrage eingebettet wird. Unterabfragen werden in der gleichen
          Weise geschrieben wie reguläre <database>SELECT</database>-Abfragen, werden jedoch von Klammern
          umschlossen. Unterabfrage-Ausdrücke können in folgender Art und Weise verwendet werden:
        <itemizedlist>
          <listitem>Um eine Ausgabespalte in der SELECT-Liste anzugeben</listitem>
          <listitem>Um Werte zu holen oder als Kriterium für Suchprädikate (die
          <database>WHERE</database>- und <database>HAVING</database>-Klauseln)</listitem>
          <listitem>Um ein Set zu erstellen, das die Eltern-Abfrage verwenden kann,
              so als wäre dies eine reguläre Tabelle oder View. Unterabfragen wie diese
              erscheinen in der FROM-Klausel (Derived Tables) oder in einer 
              Common Table Expression (CTE)</listitem>
        </itemizedlist>
      </para>
      <section id="fblangref25-commons-correlatedsq-de">
        <title>Korrelierte Unterabfragen</title>
        <para>Eine Unterabfrage kann <emphasis>korrelierend</emphasis> sein. Sie ist korellierend, wenn
        die Hauptafrage und die Unterabfrage voneinander abhängig sind. Um einen Datensatz in der Unterabfrage
        zu verarbeiten, ist es notwendig einen Datensatz in der Hauptabfrage zu holen; beispielsweise hängt 
        die Unterabfrage vollständig von der Hauptabfrage ab.</para>
        <formalpara>
          <title>Beispiel einer korrelierenden Unterabfrage</title>
          <programlisting>
       SELECT *
       FROM Customers C
       WHERE EXISTS
             (SELECT *
              FROM Orders O
              WHERE C.cnum = O.cnum
                AND O.adate = DATE '10.03.1990');
          </programlisting>
        </formalpara>

        <para>Werden Unterabfragen verwendet um Werte einer Ausgabespalte aus einer SELECT-Liste zu holen,
            muss die Unterabfrage ein <emphasis>skalares</emphasis> Ergebnis zurückliefern.</para>
      </section>

      <section id="fblangref25-commons-scalarsq-de">
        <title>Skalare Ergebnisse</title>
        <para>Unterabfragen, die in Suchprädikaten verwendet werden, 
            mit Ausnahme von existenziellen und quantifizierten Prädikaten, 
            müssen ein <emphasis>skalares</emphasis> Ergebnis zurückgeben; Das heißt, nicht mehr als eine Spalte von 
            nicht mehr als einer passenden Zeile oder Aggregation. Sollte mehr zurückgegeben werden,
            wird es zu einem Laufzeitfehler kommen (<quote>Multiple rows in a singleton select...</quote>).</para>
        <note>
          <para>Obwohl es einen echten Fehler berichtet, kann die Nachricht etwas irreführend sein.
          Ein <quote>singleton SELECT</quote> ist eine Abfrage, die nicht mehr als eine Zeile zurückgeben kann.
          Jedoch sind <quote>singleton</quote> und <quote>skalar</quote> nicht gleichzusetzen: nicht alle singleton
          SELECTs müssen zwangsläufig skalar sein; und Einspalten-SELECTs können mehrere Zeilen für 
          existenzielle und quantifizierte Prädikate zurückgeben.</para>
        </note>

        <formalpara>
          <title>Unterabfrage-Beispiele</title>
          <orderedlist>
            <listitem>Eine Unterabfrage als Ausgabespalte in einer <database>SELECT</database>-Liste:
              <programlisting>
       SELECT
           e.first_name,
           e.last_name,
           (SELECT
                sh.new_salary
            FROM
                salary_history sh
            WHERE
                sh.emp_no = e.emp_no
            ORDER BY sh.change_date DESC ROWS 1) AS last_salary
       FROM
            employee e
              </programlisting>
            </listitem>
            <listitem>eine Unterabfrage in der <database>WHERE</database>-Klausel, um 
            das höchste Gehalt eines Mitarbeiters zu ermitteln und hierauf zu filtern:
              <programlisting>
       SELECT
           e.first_name,
           e.last_name,
           e.salary
       FROM
           employee e
       WHERE
           e.salary = (
                       SELECT MAX(ie.salary)
                       FROM employee ie
                       )
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
      </section>
    </section> <!-- Subqueries -->
  </section> <!-- Expressions -->

<!-- ============================================================== -->
  <section id="fblangref25-commons-predicates-de">
    <title>Prädikate</title>
    <para>Ein Prädikat ist ein einfacher Ausdruck, der eine Behauptung aufstellt, wir nennen sie <varname>P</varname>. 
    Wenn <varname>P</varname> zu TRUE (wahr) aufgelöst wird, ist die Behauptung erfolgreich. Wird sie zu FALSE (unwahr, falsch) 
    oder NULL (UNKNOWN) aufgelöst, ist die Behauptung falsch. Hier gibt es einen Fallstrick: 
    Nehmen wir an, das Prädikat <varname>P</varname> gibt FALSE zurück. In diesem Falle gilt, dass
    NOT(<varname>P</varname>) TRUE zurückgeben wird. Andererseits gilt, falls <varname>P</varname> 
    NULL (unknown) zurückgibt, dann gibt NOT(<varname>P</varname>) ebenfalls NULL zurück.</para>

    <para>In SQL können Prädikate in <database>CHECK</database>-Constraints auftreten, <database>WHERE</database>- 
    und <database>HAVING</database>-Klauseln, <database>CASE</database>-Ausdrücken, der <database>IIF()</database>-Funktion 
    und in der <database>ON</database>-Bedingung der <database>JOIN</database>-Klausel.</para>

    <section id="fblangref25-commons-assertions-de">
      <title>Behauptungen</title>
      <para>Eine Behauptung ist ein Statement über Daten, die, wie ein Prädikat, zu TRUE, FALSE oder
          NULL aufgelöst werden können. Behauptungen bestehen aus einem oder mehr Prädikaten, möglicherweise
          mittels NOT negiert und verbunden durch AND- sowie ODER-Operatoren. Klammern können verwendet 
          werden um Prädikate zu gruppieren und die Ausführungsreihenfolge festzulegen.</para>

      <para>Ein Prädikat kann andere Prädikate einbetten. Die Ausführung ist nach außen gerichtet,
          das heißt, das innenliegendste Prädikat wird zuerst ausgeführt. Jede <quote>Ebene</quote>
          wird in ihrer Rangfolge ausgewertet bis der Wahrheitsgehalt der endgültigen Behauptung aufgelöst 
          wird.</para>
    </section>

    <section id="fblangref25-commons-comppreds-de">
      <title>Vergleichs-Prädikate</title>
      <para>Ein Vergleichsprädikat besteht aus zwei Ausdrücken, die mit einem Vergelichsoperator verbunden sind.
      Es existieren traditionel sechs Vergleichsoperatoren:
        <literallayout>
       <command>=</command>, <command>&gt;</command>, <command>&lt;</command>, <command>&gt;=</command>, <command>&lt;=</command>, <command>&lt;&gt;</command>
        </literallayout>
      (Für die vollständige Liste der Vergleichsoperatoren mit ihren Variantenformen siehe
      <link linkend= "fblangref25-commons-compar-de">Vergleichsoperatoren</link>.)
      </para>

      <para>Wenn eine der Seiten (links oder rechts) eines Vergleichsprädikats <database>NULL</database> darin hat, 
          wird der Wert des Prädikats UNKNOWN.
      </para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Abrufen von Informationen über Computer mit der CPU-Frequenz nicht weniger 
              als 500 MHz und der Preis niedriger als $800:
            <programlisting>
       SELECT *
       FROM Pc
       WHERE speed &gt;= 500 AND price &lt; 800;
            </programlisting>
          </listitem>
          <listitem>Abrufen von Informationen über alle Punktmatrixdrucker, die weniger als $300 kosten:
             <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype = 'matrix' AND price &lt; 300;
            </programlisting>
          </listitem>
          <listitem>Die folgende Abfrage gibt keine Daten zurück,
              auch nicht wenn es Drucker ohne zugewiesenen Typ gibt, da ein Prädikat,
              das <database>NULL</database> mit
          <database>NULL</database> vergleicht,  <database>NULL</database> zurückgibt:
            <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype = NULL AND price &lt; 300;
            </programlisting>
          Auf der anderen Seite kann <replaceable>ptrtype</replaceable> auf <database>NULL</database>
          getestet werden; mit dem Ergebnis, dass die kein <emphasis>Vergleichs</emphasis>test ist:
            <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype IS NULL AND price &lt; 300;
            </programlisting>
          &mdash;siehe <link linkend="fblangref25-commons-isnotnull-de"><database>IS [NOT] NULL</database></link>.
          </listitem>
        </orderedlist>
      </formalpara>
      
      <note>
        <title>Hinweis zu String-Vergleichen</title>
        <para>Werden <database>CHAR</database>- und <database>VARCHAR</database>-Felder auf Gleichheit verglichen,
        werden nachfolgende Leerzeichen in allen Fällen ignoriert.</para>
      </note>

      <section id="fblangref25-commons-othercomppreds-de">
        <title>Andere Vergleichsprädikate</title>
        <para>Andere Vergleichsprädikate werden durch Schlüsselwörter gekennzeichnet.</para>
        <section id="fblangref25-commons-predbetween-de">
          <title><database>BETWEEN</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; [NOT] BETWEEN &lt;value_1&gt; AND &lt;value_2&gt;
            </programlisting>
          </formalpara>
          <para>Das <database>BETWEEN</database>-Prädikat prüft, ob ein Wert innerhalb eines 
          angegebenen Bereichs zweier Werte liegt. (<database>NOT BETWEEN</database> prüft, ob dieser Wert außerhalb
          der beiden Grenzen liegt.)</para>
          <para>Die Operanden des <database>BETWEEN</database>-Prädikates sind zwei Argumente kompatibler
            Datentypen. Anders als in anderen DBMS ist das <database>BETWEEN</database>-Prädikat
            nicht symmetrisch&mdash; ist der kleinere Wert nicht das erste Argument, wird immer FALSE zurückgegeben.
            Die Suche ist inkludiert (die Werte beider Argumente werden in die Suche eingebunden). Anders ausgedrückt bedeutet dies,
            dass das <database>BETWEEN</database>-Prädikat auch anders geschrieben werden kann:
            <literallayout class="monospaced">
       &lt;value&gt; &gt;= &lt;value_1&gt; AND &lt;value&gt; &lt;= &lt;value_2&gt;
            </literallayout>
          </para>
          <para>Wird <database>BETWEEN</database> in Suchkriterien für DML-Abfragen verwendet, kann der
          Firebird-Optimizer einen Index auf der Suchspalte nutzen, sofern verfügbar.</para>
          <formalpara><title>Beispiel</title>
            <programlisting>
       SELECT *
       FROM EMPLOYEE
       WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
            </programlisting>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predlike-de">
          <title><database>LIKE</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;match value&gt; [NOT] LIKE &lt;pattern&gt;
          [ESCAPE &lt;escape character&gt;]

       &lt;match value&gt; ::= <replaceable>character-type expression</replaceable>

       &lt;pattern&gt; ::= <replaceable>search pattern</replaceable>

       &lt;escape character&gt; ::= <replaceable>escape character</replaceable>
            </programlisting>
          </formalpara>
          <para>Das <database>LIKE</database>-Prädikat vergleicht zeichenbasierte Ausdrücke mit 
                dem im zweiten Ausdruck definierten Muster. Groß- und Kleinschreibung bzw. Akzent-Sensitivität
          für den Vergleich wird durch die zugrunde liegende Collation bestimmt. Eine Collation kann für jeden 
          Operanden angegeben werden, wenn erforderlich.</para>

          <section id="fblangref25-commons-wildcards-de">
          <title>Wildcards</title>
          <para>Zwei Wildcard-Zeichen sind für die Suche verfügbar:
            <itemizedlist>
              <listitem>Das Prozentzeichen (%) berücksichtigt alle Sequenzen von null oder mehr
              Zeichen im getesteten Wert</listitem>
              <listitem>Das Unterstrichzeichen (_) berücksichtigt jedes beliebige Einzelzeichen im getesteten Wert
              </listitem>
            </itemizedlist>
          </para>
          <para>Wenn der getestete Wert dem Muster entspricht, unter Berücksichtigung von Wildcard-Zeichen
              ist das Prädikat TRUE.</para>
        </section>

        <section id="fblangref25-commons-escapechar-de">
          <title>Verwendung der <database>ESCAPE</database>-Zeichen-Option</title>
          <para>Wenn der Such-String eines der Wildcard-Zeichen beinhaltet, kann die 
              <database>ESCAPE</database>-Klausel verwendet werden, um ein Escape-Zeichen zu definieren.
              Das Escape-Zeichen muss dem '%' oder '_' 
              Symbol im Suchstring vorangestellt werden, um anzuzeigen, 
              dass das Symbol als wörtliches Zeichen interpretiert werden soll.</para>
        </section>

        <formalpara>
          <title>Beispiele für <database>LIKE</database></title>
            <orderedlist>
              <listitem>Finde die Nummern der Abteilung, deren Namen mit dem Wort
              <quote>Software</quote> starten:
                <programlisting>
       SELECT DEPT_NO
       FROM DEPT
       WHERE DEPT_NAME LIKE 'Software%';
                </programlisting>
                <para>Es ist möglich einen Index für das Feld DEPT_NAME zu verwenden, sofern dieser existiert.</para>
                <note>
                  <title>Über <database>LIKE</database> und den Optimizer</title>
                  <para>Eigentlich verwendet das <database>LIKE</database>-Prädikat keinen Index. Wird das Prädikat 
                  jedoch in Form von <function> LIKE 'string%' </function> verwendet, wird dieses zum Prädikat 
                  <database>STARTING WITH</database> konvertiert, welches einen Index verwendet.</para>
                  <para>Somit gilt&mdash;wenn Sie nach einem Wortanfang suchen, sollten Sie das Prädikat
                  STARTING WITH anstelle von LIKE verwenden.</para>
                </note>
              </listitem>
              <listitem>Suche nach Mitarbeitern deren Namen aus 5 Buchstaben bestehen, die mit <quote>Sm</quote> beginnen
              und mit <quote>th</quote> enden. Das Prädikat wird wahr für die Namen wie <quote>Smith</quote> und
              <quote>Smyth</quote>.
                <programlisting>
       SELECT
           first_name
       FROM
           employee
       WHERE first_name LIKE 'Sm_th'
                </programlisting>
              </listitem>
              <listitem>Suche nach allen Mandanten, deren Adresse den String <quote>Rostov</quote> enthält:
                <programlisting>
       SELECT *
       FROM CUSTOMER
       WHERE ADDRESS LIKE '%Rostov%'
                </programlisting>
                <note>
                  <para>Benötigen Sie eine Suche, die Groß- und Kleinschreibung <emphasis>innerhalb</emphasis> einer Zeichenkette
                  ignoriert (<function> LIKE '%Abc%' </function>), sollten Sie das
                  <database>CONTAINING</database>-Prädikat, anstelle des
                  <database>LIKE</database>-Prädikates, verwenden.</para>
                </note>
              </listitem>
              <listitem>Suche nach Tabellen, die das Unterstrich-Zeichen im Namen besitzen. Das Zeichen <quote>#</quote>
              wird als Escape-Zeichen definiert:
                <programlisting>
       SELECT
         RDB$RELATION_NAME
       FROM RDB$RELATIONS
       WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
                </programlisting>
              </listitem>
            </orderedlist>
          </formalpara>
          <formalpara><title>Siehe auch</title>
            <para><link linkend="fblangref25-commons-predstartwith-de"><database>STARTING WITH</database></link>,
            <link linkend="fblangref25-commons-predcontaining-de"><database>CONTAINING</database></link>,
            <link linkend="fblangref25-commons-predsiimilarto-de"><database>SIMILAR TO</database></link>
            </para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predstartwith-de">
          <title><database>STARTING WITH</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; [NOT] STARTING WITH &lt;value&gt;
            </programlisting>
          </formalpara>
          <para>Das Prädikat <database>STARTING WITH</database> sucht nach einer Zeichenkette oder einem
            zeichenkettenähnlichen Datentyp, die mit den Zeichen des Argumentes &lt;value&gt; beginnt.
           Die Suche unterscheidet zwischen Groß- und Kleinschreibung.</para>
          <para>Wenn <database>STARTING WITH</database> als Suchkriterium in
          DML-Abfragen verwendet wird, nutzt der Firebird-Optimizer einen Index auf der Suchspalte, sofern 
          vorhanden.</para>
          <formalpara><title>Beispiel</title>
            <para>Suche nach Mitarbeitern deren Namen mit <quote>Jo</quote> beginnen:
              <programlisting>
       SELECT LAST_NAME, FIRST_NAME
       FROM EMPLOYEE
       WHERE LAST_NAME STARTING WITH 'Jo'
              </programlisting>
            </para>
          </formalpara>
          <formalpara><title>Siehe auch</title>
            <para><link linkend="fblangref25-commons-predlike-de"><database>LIKE</database></link></para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predcontaining-de">
          <title><database>CONTAINING</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; [NOT] CONTAINING &lt;value&gt;
            </programlisting>
          </formalpara>
          <para>Das Prädikat <database>CONTAINING</database> sucht innerhalb von Zeichenketten oder zeichenkettenähnlichen Datentypen
          nach der Buchstabenfolge, die im Argument angegeben wurde. Es kann für alphanumerische (zeichenkettenähnliche) Suchen auf Zahlen
          und Daten genutzt werden. Eine Suche mit <database>CONTAINING</database> unterscheidet nicht nach Groß- und Kleinschreibung.
          Wird jedoch eine akzentsensitive Collation verwendet, ist auch die Suche akzentsensitiv.</para>
          <para>Wenn <database>CONTAINING</database> als Suchkriterium in DML-Abfragen verwendet wird,
          kann der Firebird-Optimizer einen Index der Suchspalte nutzen, sofern ein passender existiert.</para>
          <formalpara><title>Beispiele</title>
            <orderedlist>
              <listitem>Suche nach Projekten, deren Namen die Zeichenkette <quote>Map</quote> enhalten:
                <programlisting>
       SELECT *
       FROM PROJECT
       WHERE PROJ_NAME CONTAINING 'Map';
                </programlisting>
              Zwei Zeilen mit den Namen <quote>AutoMap</quote> und <quote>MapBrowser port</quote> werden 
              zurückgegeben.</listitem>
              <listitem>Suche nach Änderungen in den Gehältern, die die Zahl 84 im Datum enthalten (in diesem Falle heißt
                  dies, Änderungen im Jahr 1984):
                <programlisting>
       SELECT *
       FROM SALARY_HISTORY
       WHERE CHANGE_DATE CONTAINING 84;
                </programlisting>
              </listitem>
             </orderedlist>
          </formalpara>
          <formalpara><title>Siehe auch</title>
            <para><link linkend="fblangref25-commons-predlike-de"><database>LIKE</database></link></para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predsiimilarto-de">
          <title><database>SIMILAR TO</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       <replaceable>string-expression</replaceable> [NOT] SIMILAR TO &lt;pattern&gt; [ESCAPE &lt;escape-char&gt;]
       &lt;pattern&gt; ::= an SQL regular expression
       &lt;escape-char&gt; ::= a single character
            </programlisting>
          </formalpara>
          <para>SIMILAR TO findet eine Zeichenkette anhand eines Regulären Ausdruck-Musters in SQL (engl. SQL Regular Expression Pattern).
          Anders als in einigen anderen Sprachen muss das Muster mit der gesamten Zeichenkette 
              übereinstimmen, um erfolgreich zu sein - die Übereinstimmung eines Teilstrings reicht nicht aus.
              Ist ein Operand
          <database>NULL</database>, ist auch das Ergebnis <database>NULL</database>. Andernfalls ist das Ergebnis
          <database>TRUE</database> oder <database>FALSE</database>.</para>

          <section id="fblangref25-commons-syntaxregex-de">
            <title>Syntax: SQL Reguläre Ausdrücke</title>
            <para>
                Die folgende Syntax definiert das SQL-Standardausdruckformat. 
                Es ist eine komplette und korrekte Top-down-Definition. 
                Es ist auch sehr formell, ziemlich lang und vermutlich perfekt geeignet, 
                jeden zu entmutigen, der nicht schon Erfahrungen mit Regulären Ausdrücken 
                (oder mit sehr formalen, eher langen Top-down-Definitionen) gesammelt hat. 
                Fühlen Sie sich frei, dies zu überspringen und den nächsten Abschnitt, 
                <link linkend="fblangref25-commons-buildregex-de">Aufbau Regulärer Ausdrücke</link>, zu lesen, 
                der einen Bottom-up-Ansatz verfolgt und sich an den Rest von uns richtet.</para>
            <programlisting>
  &lt;regular expression&gt; ::= &lt;regular term&gt; ['|' &lt;regular term&gt; ...]

  &lt;regular term&gt; ::= &lt;regular factor&gt; ...

  &lt;regular factor&gt; ::= &lt;regular primary&gt; [&lt;quantifier&gt;]

  &lt;quantifier&gt; ::= ?
               | *
               | +
               | '{' &lt;m&gt; [,[&lt;n&gt;]] '}'

  &lt;m&gt;, &lt;n&gt; ::= unsigned int, mit &lt;m&gt; &lt;= &lt;n&gt; wenn beide vorhanden

  &lt;regular primary&gt; ::= &lt;character&gt;
                    | &lt;character class&gt;
                    | %
                    | (&lt;regular expression&gt;)

  &lt;character&gt; ::= &lt;escaped character&gt;
              | &lt;non-escaped character&gt;

  &lt;escaped character&gt; ::= &lt;escape-char&gt; &lt;special character&gt;
                      | &lt;escape-char&gt; &lt;escape-char&gt;

  &lt;special character&gt; ::= eines der Zeichen []()|^-+*%_?{

  &lt;non-escaped character&gt; ::= ein Zeichen, das nicht ein &lt;special character&gt; ist
                            und nicht gleich &lt;escape-char&gt; (wenn definiert)
  &lt;character class&gt; ::= '_'
                    | '[' &lt;member&gt; ... ']'
                    | '[^' &lt;non-member&gt; ... ']'
                    | '[' &lt;member&gt; ... '^' &lt;non-member&gt; ... ']'

  &lt;member&gt;, &lt;non-member&gt; ::= &lt;character&gt;
                         | &lt;range&gt;
                         | &lt;predefined class&gt;

  &lt;range&gt; ::= &lt;character&gt;-&lt;character&gt;

  &lt;predefined class&gt; ::= '[:' &lt;predefined class name&gt; ':]'

  &lt;predefined class name&gt; ::= ALPHA | UPPER | LOWER | DIGIT
                             | ALNUM | SPACE | WHITESPACE

            </programlisting>
          </section>
          <section id="fblangref25-commons-buildregex-de">
            <title>Aufbau Regulärer Ausdrücke</title>
            <para>Dieser Abschnitt behandelt die Elemente und Regeln zum Aufbau
                Regulärer Ausdrücke in SQL.</para>
            <section id="fblangref25-commons-regexchar-de">
              <title>Zeichen</title>
              <para>Innerhalb Regulärer Ausdrücke repräsentieren die meisten Zeichen sich selbst.
              Die einzige Ausnahme bilden die folgenden Zeichen:
                <literallayout><command>
       [ ] ( ) | ^ - + * % _ ? { }
                </command></literallayout>
              ...und das Escape-Zeichen, sofern definiert.</para>
              <para>Ein Regulärer Ausdruck, der keine Sonderzeichen oder Escape-Zeichen beinhaltet,
                  findet nur Strings, die identisch zu sich selbst sind (abhängig von der verwendeten
                  Collation). Das heißt, es agiert wie der <quote><command>=</command></quote>-Operator:
                <programlisting>
       'Apple' similar to 'Apple'  -- true
       'Apples' similar to 'Apple' -- false
       'Apple' similar to 'Apples' -- false
       'APPLE' similar to 'Apple'  -- abhängig von der Collation
                </programlisting>
              </para>
            </section><!-- regex characters -->

            <section id="fblangref25-commons-regexwildcards-de">
              <title>Wildcards</title>
              <para>Die bekannten SQL-Wildcards <command>_</command> und <command>%</command> finden
              beliebige Einzelzeichen und Strings beliebiger Länge:
                <programlisting>
       'Birne' similar to 'B_rne'   -- true
       'Birne' similar to 'B_ne'    -- false
       'Birne' similar to 'B%ne'    -- true
       'Birne' similar to 'Bir%ne%' -- true
       'Birne' similar to 'Birr%ne' -- false
                </programlisting>
              Beachten Sie, wie % auch den leeren String berücksichtigt.</para>
            </section> <!-- regex wildcards -->

            <section id="fblangref25-commons-regexcharclass-de">
              <title>Zeichenklassen</title>
              <para>Ein Bündel von Zeichen, die in Klammern eingeschlossen sind, definiert eine Zeichenklasse. 
                  Ein Zeichen in der Zeichenfolge entspricht einer Klasse im Muster, wenn das Zeichen Mitglied der Klasse ist:
                <programlisting>
       'Citroen' similar to 'Cit[arju]oen'     -- true
       'Citroen' similar to 'Ci[tr]oen'        -- false
       'Citroen' similar to 'Ci[tr][tr]oen'    -- true
                </programlisting>
              Wie aus der zweiten Zeile ersichtlich ist, entspricht die Klasse nur einem einzigen Zeichen, 
                nicht einer Sequenz.</para>
              <para>Innerhalb einer Klassendefinition definieren zwei Zeichen, die durch einen 
                  Bindestrich verbunden sind, einen Bereich. Ein Bereich umfasst die beiden Endpunkte und alle 
                  Zeichen, die zwischen ihnen in der aktiven Sortierung liegen. Bereiche können überall in der 
                  Klassendefinition ohne spezielle Begrenzer platziert werden, um sie von den anderen Elementen zu trennen.
                <programlisting>
       'Datte' similar to 'Dat[q-u]e'          -- true
       'Datte' similar to 'Dat[abq-uy]e'       -- true
       'Datte' similar to 'Dat[bcg-km-pwz]e'   -- false
                </programlisting>
              </para>

              <section id="fblangref25-commons-regexpredefclass-de">
                <title>Vordefinierte Zeichenklassen</title>
                <para>Die folgenden vordefinierten Zeichenklassen können auch in einer Klassendefinition verwendet werden:
                  <formalpara><title>[:ALPHA:]</title>
                    <para>Lateinische Buchstaben a..z und A..Z. Mit einer akzentunempfindlichen Sortierung 
                        stimmt diese Klasse auch mit akzentuierten Formen dieser Zeichen überein.</para>
                  </formalpara>

                  <formalpara><title>[:DIGIT:]</title>
                    <para>Dezimalziffern 0..9.</para>
                  </formalpara>

                  <formalpara><title>[:ALNUM:]</title>
                    <para>Gesamtheit aus [:ALPHA:] und [:DIGIT:].</para>
                  </formalpara>

                  <formalpara><title>[:UPPER:]</title>
                    <para>Großgeschriebene Form der lateinischen Buchstaben A..Z. Findet auch kleingeschriebene Strings mit 
                        groß- und kleinschreibunempfindlicher Collation sowie akzentunempfindlicher Collation.</para>
                  </formalpara>

                  <formalpara><title>[:LOWER:]</title>
                    <para>Kleingeschriebene Form der lateinischen Buchstaben A..Z. Findet auch großgeschriebene Strings mit 
                        groß- und kleinschreibunempfindlicher Collation sowie akzentunempfindlicher Collation.</para>
                  </formalpara>

                  <formalpara><title>[:SPACE:]</title>
                    <para>Findet das Leerzeichen (ASCII 32).</para>
                  </formalpara>

                  <formalpara><title>[:WHITESPACE:]</title>
                    <para>Findet vertikalen Tabulator (ASCII 9), Zeilenvorschub (ASCII 10), horizontalen
                    Tabulator (ASCII 11), Seitenvorschub (ASCII 12), Wagenrücklauf (ASCII 13) und Leerzeichen (ASCII 32).</para>
                  </formalpara>
                </para>
                <para>Das Einbinden einer vordefinierten Klasse hat den gleichen Effekt wie das Einbinden all seiner Mitglieder.
                    Vordefinierte Klassen sind nur in Klassendefinitionen erlaubt. Wenn Sie gegen eine vordefinierte Klasse 
                    prüfen und gegen nichts sonst, platzieren Sie ein zusätzliches Paar von Klammern um sie herum.
                  <programlisting>
       'Erdbeere' similar to 'Erd[[:ALNUM:]]eere'     -- true
       'Erdbeere' similar to 'Erd[[:DIGIT:]]eere'     -- false
       'Erdbeere' similar to 'Erd[a[:SPACE:]b]eere'   -- true
       'Erdbeere' similar to [[:ALPHA:]]              -- false
       'E'        similar to [[:ALPHA:]]              -- true
                  </programlisting>
              Wenn eine Klassendefinition mit einer eckigen Klammer beginnt, wird alles, was folgt, von der Klasse ausgeschlossen. Alle anderen Zeichen entsprechen:
                  <programlisting>
       'Framboise' similar to 'Fra[^ck-p]boise'       -- false
       'Framboise' similar to 'Fr[^a][^a]boise'       -- false
       'Framboise' similar to 'Fra[^[:DIGIT:]]boise'  -- true
                  </programlisting>
              Wird die eckige Klammer nicht am Anfang der Reihe platziert, enthält die Klasse
                  alles vor dieser, mit Ausnahme der Elemente die nach der Klammer vorkommen:
                  <programlisting>
       'Grapefruit' similar to 'Grap[a-m^f-i]fruit'   -- true
       'Grapefruit' similar to 'Grap[abc^xyz]fruit'   -- false
       'Grapefruit' similar to 'Grap[abc^de]fruit'    -- false
       'Grapefruit' similar to 'Grap[abe^de]fruit'    -- false

       '3' similar to '[[:DIGIT:]^4-8]'               -- true
       '6' similar to '[[:DIGIT:]^4-8]'               -- false
                  </programlisting>
              Zuletzt sei noch erwähnt, dass die Wildcard-Zeichen <quote>_</quote> eine eigene Zeichenklasse sind,
              die einem beliebigen einzelnen Zeichen entspricht.
                </para>
              </section>
            </section> <!-- regex character classes -->

            <section id="fblangref25-commons-regexquantifiers">
              <title>Bezeichner</title>
              <para>Ein Fragezeichen, direkt von einem weiteren Zeichen oder Klasse gefolgt, gibt an, dass 
                  das folgende Element gar nicht oder einmalig vorkommen darf:
                <programlisting>
       'Hallon' similar to 'Hal?on'                   -- false
       'Hallon' similar to 'Hal?lon'                  -- true
       'Hallon' similar to 'Halll?on'                 -- true
       'Hallon' similar to 'Hallll?on'                -- false
       'Hallon' similar to 'Halx?lon'                 -- true
       'Hallon' similar to 'H[a-c]?llon[x-z]?'        -- true
                </programlisting>
              Ein Sternchen, direkt von einem weiteren Zeichen oder Klasse gefolgt, gibt an, dass
                das folgende Element gar nicht oder mehrmals vorkommen darf:
                <programlisting>
       'Icaque' similar to 'Ica*que'                  -- true
       'Icaque' similar to 'Icar*que'                 -- true
       'Icaque' similar to 'I[a-c]*que'               -- true
       'Icaque' similar to '_*'                       -- true
       'Icaque' similar to '[[:ALPHA:]]*'             -- true
       'Icaque' similar to 'Ica[xyz]*e'               -- false
                </programlisting>
              Ein Plus-Zeichen, direkt von einem weiteren Zeichen oder Klasse gefolgt, gibt an, dass
              das folgende Element einmalig oder mehrmals vorkommen darf:
                <programlisting>
       'Jujube' similar to 'Ju_+'                     -- true
       'Jujube' similar to 'Ju+jube'                  -- true
       'Jujube' similar to 'Jujuber+'                 -- false
       'Jujube' similar to 'J[jux]+be'                -- true
       'Jujube' sililar to 'J[[:DIGIT:]]+ujube'       -- false
                </programlisting>
              Folgt eine Zahl in Klammern auf ein Zeichen oder eine Klasse, muss letzteres genau
                so oft wie angegeben vorkommen:
                <programlisting>
       'Kiwi' similar to 'Ki{2}wi'                    -- false
       'Kiwi' similar to 'K[ipw]{2}i'                 -- true
       'Kiwi' similar to 'K[ipw]{2}'                  -- false
       'Kiwi' similar to 'K[ipw]{3}'                  -- true
                </programlisting>
              Wird eine Zahl von einem Komma gefolgt, bedeutet dies, dass das Element mindestens so oft
                wie angegeben vorkommen muss:
                <programlisting>
       'Limone' similar to 'Li{2,}mone'               -- false
       'Limone' similar to 'Li{1,}mone'               -- true
       'Limone' similar to 'Li[nezom]{2,}'            -- true
                </programlisting>
              Wenn die Klammern zwei Zahlen enthalten, die mittels Komma getrennt sind, die zweite 
                Zahl nicht kleiner als die erste ist, muss das Element mindestens so oft wie die erste 
                Zahl vorkommen und maximal so oft wie in der zweiten Zahl angegeben:
                <programlisting>
       'Mandarijn' similar to 'M[a-p]{2,5}rijn'       -- true
       'Mandarijn' similar to 'M[a-p]{2,3}rijn'       -- false
       'Mandarijn' similar to 'M[a-p]{2,3}arijn'      -- true
                </programlisting>
              Die Bezeichner ?, * und + sind Kurzschreibweisen für {0,1}, {0,} und {1,}.
              </para>
            </section> <!-- regex quantifiers -->

            <section id="fblangref25-commons-regexoring-de">
              <title>Oder-verknüpfte Terme</title>
              <para>Reguläre Ausdrücke können Oder-verknüpft werden mittels |-Operator. Eine Gesamtübereinstimmung tritt auf,
                  wenn die Argumentzeichenkette mit mindestens einem Term übereinstimmt.
                <programlisting>
       'Nektarin' similar to 'Nek|tarin'              -- false
       'Nektarin' similar to 'Nektarin|Persika'       -- true
       'Nektarin' similar to 'M_+|N_+|P_+'            -- true
                </programlisting>
              </para>
            </section> <!-- OR-ing terms -->

            <section id="fblangref25-commons-regexsubexpr-de">
              <title>Unterausdrücke</title>
              <para>Ein oder mehrere Teile der regulären Ausdrücke können in Unterausdrücke gruppiert werden
                  (auch Untermuster genannt), indem diese in runde Klammern eingeschlossen werden. Ein
                  Unterausdruck ist ein eigener regulärer Ausdruck. Dieser kann alle erlaubten Elemente eines 
                  regulären Ausdrucks enthalten, und auch eigene Bezeichner.
                <programlisting>
       'Orange' similar to 'O(ra|ri|ro)nge'           -- true
       'Orange' similar to 'O(r[a-e])+nge'            -- true
       'Orange' similar to 'O(ra){2,4}nge'            -- false
       'Orange' similar to 'O(r(an|in)g|rong)?e'      -- true
                </programlisting>
              </para>
            </section> <!-- subexpressions -->
            <section id="fblangref25-commons-regexescap-de">
              <title>Sonderzeichen escapen</title>
              <para>Soll eine Übereinstimmung auf Sonderzeichen innerhalb eines regulären Ausdrucks geprüft werden,
                  muss dieses Zeichen escaped werden. Es gibt kein Standard-Escape-Zeichen; stattdessen 
                  definiert der Benutzer eines, wenn dies benötigt wird:
                <programlisting>
'Peer (Poire)' similar to 'P[^ ]+ \(P[^ ]+\)' escape '\'    -- true
'Pera [Pear]'  similar to 'P[^ ]+ #[P[^ ]+#]' escape '#'    -- true
'P&auml;ron-&Auml;ppledryck' similar to 'P%$-&Auml;%' escape '$'           -- true
'P&auml;rondryck' similar to 'P%--&Auml;%' escape '-'                 -- false
                </programlisting>
              Die letzte Zeile demonstriert, dass das Escape-Zeichen auch sich selbst escapen kann, wenn notwendig.
              </para>
            </section> <!-- escaping special chars -->
          </section> <!-- Building regex expr -->
        </section><!-- Similar To -->

        <section id="fblangref25-commons-isnotdistinct-de">
          <title><database>IS [NOT] DISTINCT FROM</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       <replaceable>operand1</replaceable> IS [NOT] DISTINCT FROM <replaceable>operand2</replaceable>
            </programlisting>
          </formalpara>
          <para>Zwei Operanden werden als DISTINCT angesehen, wenn sie unterschiedliche Werte besitzen oder wenn einer NULL ist
              und der andere nicht-NULL. Sie werden als NOT DISTINCT angesehen, wenn sie den gleichen Wert besitzen oder beide 
              Operanden NULL sind.</para>
          <formalpara><title>Siehe auch</title>
            <para><link linkend="fblangref25-commons-isnotnull-de"><database>IS [NOT] NULL</database></link></para>
          </formalpara>
        </section> <!-- is not distinct from -->

        <section id="fblangref25-commons-isnotnull-de">
          <title><database>IS [NOT] NULL</database></title>
          <formalpara><title>Verfügbar</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; IS [NOT] NULL
            </programlisting>
          </formalpara>
          <para>Da NULL kein Wert ist, sind diese Operatoren keine Vergleichsoperatoren. Das Prädikat
          <database>IS [NOT] NULL</database> prüft die Behauptung, dass der Ausdruck auf der linken Seite
          einen Wert (IS NOT NULL) oder keinen Wert hat (IS NULL).</para>
          <formalpara><title>Beispiel</title>
            <para>&nbsp;Suche nach Verkäufen, die kein Versanddatum besitzen:
              <programlisting>
       SELECT * FROM SALES
         WHERE SHIP_DATE IS NULL;
              </programlisting>
            </para>
          </formalpara>
        </section> <!-- is not null -->
        <note>
          <title>Hinweis bezüglich des IS-Prädikates</title>
          <para>Bis einschließlich Firebird 2.5, hat das Prädikat <database>IS</database>, wie
            andere Vergleichsprädikate, keinen Vorrang gegenüber anderer. Ab Firebird 3.0
            hat dieses Prädikat Vorrang gegenüber den anderen.</para>
        </note>
      </section><!-- Other comparison predicates -->
    </section><!-- Comparison predicates -->

    <section id="fblangref25-commons-existential-de">
      <title>Existenzprädikate</title>
      <para>Diese Gruppe von Prädikaten beinhaltet die, die Unterabfragen nutzen um Werte für alle möglichen Arten 
          von Behauptungen zu prüfen. Existenzprädikate werden so genannt, da sie verschiedene Methoden verwenden,
          um auf die <firstterm>Exiszenz</firstterm> oder <firstterm>nicht-Existenz</firstterm>
      von Behauptungen zu prüfen. Die Prädikate geben <database>TRUE</database> zurück, wenn die Existenz oder nicht-Existenz
        bestätigt wurde, andernfalls <database>FALSE</database>.</para>

      <section id="fblangref25-commons-exists-de">
        <title><database>EXISTS</database></title>
        <formalpara><title>Verfügbar</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       [NOT] EXISTS(&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>Das Prädikat <database>EXISTS</database> nutzt einen Unterabfrage-Ausdruck als Argument.
        Es gibt <database>TRUE</database> zurück, wenn die Unterabfrage mindestens einen Datensatz zurückgibt;
        andernfalls gibt es <database>FALSE</database> zurück.</para>
        <para><database>NOT EXISTS</database> gibt <database>FALSE</database> zurück, wenn die Unterabfrage mindestens eine
        Datenzeile zurückgibt; es gibt andernfalls <database>TRUE</database> zurück.</para>
        <note>
          <para>Die Unterabfrage kann mehrere Spalten enthalten, oder <database>SELECT *</database>, da die Prüfung
          anhand der zurückgegebenen Datenzeilen vorgenommen wird, die die Bedingungen erfüllen.</para>
        </note>
        <formalpara><title>Beispiele</title>
          <orderedlist>
            <listitem>Finde die Mitarbeiter, die Projekte haben.
              <programlisting>
       SELECT *
       FROM employee
       WHERE EXISTS(SELECT *
                    FROM  employee_project ep
                    WHERE ep.emp_no = employee.emp_no)
              </programlisting>
            </listitem>
            <listitem>Finde die Mitarbeiter, die keine Projekte haben.
              <programlisting>
       SELECT *
       FROM employee
       WHERE NOT EXISTS(SELECT *
                        FROM employee_project ep
                        WHERE ep.emp_no = employee.emp_no)
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
      </section>

      <section id="fblangref25-commons-in-de">
        <title><database>IN</database></title>
        <formalpara><title>Verfügbar</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       &lt;value&gt; [NOT] IN(&lt;select_stmt&gt; | &lt;value_list&gt;)

       &lt;value_list&gt; ::= &lt;value_1&gt; [, &lt;value_2&gt; &hellip;]
          </programlisting>
        </formalpara>
        <para>Das Prädikat <database>IN</database> prüft, ob der Wert des Ausdrucks auf der linken Seite
        im Wertesatz der rechten Seite vorkommt. Der Wertesatz darf nicht mehr als 1500 Elemente enthalten.
        Das <database>IN</database>-Prädikat kann mit folgender äquivalenter Form ersetzt werden:
          <programlisting>
       (&lt;value&gt; = &lt;value_1&gt; [OR &lt;value&gt; = &lt;value_2&gt; &hellip;])
          </programlisting>
        Wenn das Prädikat <database>IN</database> als Suchbedingung in DML-Abfragen verwendet wird,
        kann der Firebird-Optimizer einen Index auf die Suchspalte nutzen, sofern einer vorhanden ist.</para>

        <para>In seiner zweiten Form prüft das Prädikat <database>IN</database>, ob der linke Ausdruckswert 
        im Ergebnis der Unterabfrage vorhanden ist (oder nicht vorhanden, wenn <database>NOT IN</database> 
        verwendet wird).</para>
        <para>Die Unterabfrage darf nur eine Spalte abfragen, andernfalls wird es zum Fehler
        <quote>count of column list and variable list do not match</quote> kommen.</para>

        <para>Abfragen, die das Prädikat <database>IN</database> mit einer Unterabfrage verwenden,
        können durch eine ähnliche Abfrage mittels des <database>EXISTS</database>-Prädikates ersetzt werden.
        Zum Beispiel folgende Abfrage:
          <programlisting>
       SELECT
         model, speed, hd
       FROM PC
       WHERE
       model IN (SELECT model
                   FROM product
                   WHERE maker = 'A');
          </programlisting>
        kann ersetzt werden mittels EXISTS-Prädikat
          <programlisting>
       SELECT
         model, speed, hd
       FROM PC
       WHERE
         EXISTS (SELECT *
                 FROM product
                   WHERE maker = 'A'
                   AND product.model = PC.model);
          </programlisting>

        Jedoch gilt zu beachten, dass eine Abfrage mittels <database>NOT IN</database> und einer
        Unterabfrage nicht immer das gleiche Ergebnis zurückliefert wie
        sein Gegenpart mit <database>NOT EXISTS</database>.
        Dies liegt daran, dass <database>EXISTS</database> immer TRUE oder FALSE zurückgibt, wohingegen
        <database>IN</database> <database>NULL</database> in diesen beiden Fällen zurückliefert:
        <orderedlist spacing="compact" type="alpha">
          <listitem>wenn der geprüfte Wert <database>NULL</database> ist und die <database>IN ()</database>-Liste
          nicht leer ist</listitem>
          <listitem>wenn der geprüfte Wert keinen Treffer in der <database>IN ()</database>-Liste enthält
            und mindestens ein Element <database>NULL</database> ist.</listitem>
        </orderedlist>
        Nur in diesen beiden Fällen wird <database>IN ()</database> <database>NULL</database> zurückgeben,
        während das <database>EXISTS</database>-Prädikat <database>FALSE</database> zurückgibt
        ('keine passende Zeile gefunden', engl. 'no matching row found'). In einer Suche oder, zum Beispiel 
        in einem <database>IF (...)</database>-Statement, bedeuten beide Ergebnisse einen
        <quote>Fehler</quote> und es macht damit keinen Unterschied.</para>
        <para>Aber für die gleichen Daten gibt <database>NOT IN ()</database> <database>NULL</database> zurück,
        während <database>NOT EXISTS</database> <database>TRUE</database> zurückgibt, was das Gegenteilige Ergebnis ist.</para>
        <para>Schauen wir uns das folgendes Beispiel an:
          <programlisting>
       -- Suche nach Bürgern die nicht am gleichen Tag wie eine
       -- berühmte New Yorker Persönlichkeit geboren wurden
       SELECT P1.name AS NAME
       FROM Personnel P1
       WHERE P1.birthday NOT IN (SELECT C1.birthday
                                 FROM Celebrities C1
                                 WHERE C1.birthcity = 'New York');
          </programlisting>
        Nehmen wir nun an, dass die Liste der New Yorker Berühmtheiten nicht leer ist und mindestens
          einen NULL-Geburtstag aufweist. Dann gilt für alle Bürger, die nicht am gleichen Tag
          mit einer Berühmtheit Geburtstag haben, dass <database>NOT IN</database> <database>NULL</database> zurückgibt,
        da dies genau das ist was <database>IN</database> tut. Die Suchbedingung wurde nicht erfüllt
        und die Bürger werden nicht im Ergebnis des <database>SELECT</database> berücksichtigt, da
        die Aussage falsch ist.</para>
        <para>Bürger, die am gleichen Tag wie eine Berühmtheit Geburtstag feiern,
        wird <database>NOT IN</database> korrekterweise <database>FALSE</database> zurückgeben, womit diese 
        ebenfalls aussortiert werden, und damit keine Zeile zurückgegeben wird.</para>
        <para>Wird die Form <database>NOT EXISTS</database> verwendet:
          <programlisting>
       -- Suche nach Bürgern, die nicht am gleichen Tag wie eine
       -- berühmte New Yorker Persönlichkeit geboren wurden
       SELECT P1.name AS NAME
       FROM Personnel P1
       WHERE NOT EXISTS (SELECT *
                         FROM Celebrities C1
                         WHERE C1.birthcity = 'New York'
                           AND C1.birthday = P1.birthday);
          </programlisting>
       nicht-Übereinstimmungen werden im <database>NOT EXISTS</database>-Ergebnis <database>TRUE</database> erhalten
       und ihre Datensätze landen im Rückgabesatz.
         <caution>
           <title>Hinweis</title>
           <para>Wenn es im Bereich des Möglichen liegt, dass NULL innerhalb der Suche für eine nicht-Prüfung vorhanden sein kann,
               sollten Sie <database>NOT EXISTS</database> verwenden.</para>
         </caution>
        </para>
        <formalpara><title>Beispiele für die Verwendung</title>
          <orderedlist>
            <listitem>Finde Mitarbeiter mit den Namen <quote>Pete</quote>, <quote>Ann</quote>
            und <quote>Roger</quote>:
              <programlisting>
       SELECT *
       FROM EMPLOYEE
       WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
              </programlisting>
            </listitem>
            <listitem>Finde alle Computer, die deren Hersteller mit
            dem Buchstaben <quote>A</quote> beginnt:
              <programlisting>
       SELECT
          model, speed, hd
       FROM PC
       WHERE
         model IN (SELECT model
                   FROM product
                   WHERE maker STARTING WITH 'A');
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
        <formalpara><title>Siehe auch</title>
          <para><link linkend="fblangref25-commons-exists-de">EXISTS</link></para>
        </formalpara>
      </section>

      <section id="fblangref25-commons-singular-de">
        <title><database>SINGULAR</database></title>
        <formalpara><title>Verfügbar</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting> 
       [NOT] SINGULAR(&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>Das <database>SINGULAR</database>-Prädikat verwendet eine Unterabfrage als Argument
        und gibt True zurück, wenn diese exakt eine Datenzeile zurückgibt; andernfalls
        wird das Prädikat zu False aufgelöst. Die Unterabfrage kann mehrere Ausgabespalten
        beinhalten, da die Zeilen ja nicht wirklich ausgegeben werden. Sie werden nur auf 
        (einzigartige) Existenz geprüft. Der Kürze halbe, wird häufig nur '<database>SELECT *</database>' 
        verwendet. Das Prädikat <database>SINGULAR</database> kann nur zwei Werte zurückgeben: 
        <database>TRUE</database> oder <database>FALSE</database>.</para>
        <formalpara><title>Beispiel</title>
          <para>&nbsp;Finde die Mitarbeiter, die nur ein Projekt haben.
            <programlisting>
       SELECT *
       FROM employee
       WHERE SINGULAR(SELECT *
                      FROM
                        employee_project ep
                      WHERE
                        ep.emp_no = employee.emp_no)
            </programlisting>
          </para>
        </formalpara>
      </section>
    </section> <!-- Existential Predicates -->

    <section id="fblangref25-commons-quantifiedsq-de">
      <title><database>Quantifizierte Unterabfrage-Prädikate</database></title>
      <para>Ein Quantifizierer ist ein logischer Operator, der die Anzahl der Objekte 
          festlegt, für die diese Behauptung wahr ist. Es ist keine numerische Größe, 
          sondern eine logische, die die Behauptung mit dem vollen Satz möglicher Objekte verbindet. 
          Solche Prädikate basieren auf logischen universellen und existentiellen Quantifizierern, 
          die in der formalen Logik erkannt werden.</para>
      <para>In Unterabfrage-Ausdrücken machen es Quantifizierer-Prädikate möglich einzelne Werte
          mit den Ergebnissen von Unterabfragen zu vergleichen; sie besitzen die folgende gemeinsame Form:
        <programlisting>
       &lt;value expression&gt; &lt;comparison operator&gt; &lt;quantifier&gt; &lt;subquery&gt;
        </programlisting>
      </para>

      <section id="fblangref25-commons-quant-all-de">
        <title><database>ALL</database></title>
        <formalpara><title>Verfügbar</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       &lt;value&gt; &lt;op&gt; ALL(&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>Wenn der <database>ALL</database>-Quantifizierer verwendet wird, ist das
        Prädikat TRUE, wenn jeder Wert, der von der Unterabfrage zurückgegeben wird,
        die Bedingung des Prädikates in der Hauptabfrage erfüllt ist.</para>
        <formalpara><title>Beispiel</title>
          <para>&nbsp;Zeige nur jene Kunden an, deren Bewertungen höher sind als 
              die Bewertung jedes Kunden in Paris.
            <programlisting>
       SELECT c1.*
       FROM Customers c1
       WHERE c1.rating &gt; ALL
             (SELECT c2.rating
              FROM Customers c2
              WHERE c2.city = 'Paris')
            </programlisting>
          </para>
        </formalpara>
        <important>
          <para>Wenn die Unterabfrage einen leeren Satz zurückgibt, ist das Prädikat
              TRUE für jeden linken Wert, unabhängig vom Operator. Dies mag widersprüchlich 
              erscheinen, denn jeder linke Wert wird gegenüber dem rechten betrachtet als:
              kleiner als, größer als, gleich sowie ungleich.</para>
          <para>Dennoch passt dies perfekt in die formale Logik: Wenn der Satz leer ist, 
              ist das Prädikat 0 mal wahr, d.h. für jede Zeile im Satz.</para>
        </important>  
      </section>

      <section id="fblangref25-commons-quant-anysome-de">
        <title><database>ANY</database> and <database>SOME</database></title>
        <formalpara><title>Verfügbar</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       &lt;value&gt; &lt;op&gt; {ANY | SOME} (&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>Die Quantifizierer <database>ANY</database> und <database>SOME</database> sind
        in ihrem Verhalten identisch. Offensichtlich sind beide im SQL-Standard vorhanden, 
        so dass sie austauschbar verwendet werden können, um die Lesbarkeit der Operatoren zu verbessern. 
        Wird der <database>ANY</database>- oder <database>SOME</database>-Quantifizierer
        verwendet, ist das Prädikat TRUE, wenn einer der zurückgegebenen Werte der Unterabfrage
        die Suchbedingung der Hauptabfrage erfüllt. Gibt die Unterabfrage keine Zeile zurück,
        wird das Prädikat automtisch als FALSE angesehen.</para>
        <formalpara><title>Beispiel</title>
          <para>&nbsp;Zeige nur die Kunden, deren Bewertungen höher sind 
              als die eines oder mehrerer Kunden in Rom.
            <programlisting>
       SELECT *
       FROM Customers
       WHERE rating &gt; ANY
             (SELECT rating
              FROM Customers
              WHERE city = 'Rome')
            </programlisting>
          </para>
        </formalpara>
      </section>
    </section><!-- quantified subquery predicates -->
  </section> <!-- Predicates  -->

</chapter>
