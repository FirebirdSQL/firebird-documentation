<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-datatypes-de">
  <title>Datentypen und Unterdatentypen</title>
  <para>Daten unterschiedlicher Typen werden verwendet für:
  <itemizedlist>
    <listitem>
      <para>die Spaltendefinition in Datenbanktabellen mittels
	  <database>CREATE TABLE</database>-Statement oder 
      zum Ändern der Spalten mittels <database>ALTER TABLE</database></para>
    </listitem>
    <listitem>
      <para>die Deklaration oder Änderung einer <emphasis>Domain</emphasis> unter 
	  Verwendung der Statements <database>CREATE DOMAIN</database> oder <database>ALTER DOMAIN</database></para>
    </listitem>
    <listitem>
      <para>die Deklaration lokaler Variablen in gespeicherten Prozeduren, PSQL-Blöcken und Triggern sowie 
	  spezifizierter Parameter in gespeicherten Prozeduren</para>
    </listitem>
    <listitem>
      <para>die indirekte Spezifikation von Argumenten und Rückgabewerten
	  bei der Deklaration externer Funktionen (UDFs&mdash;user-defined functions)</para>
    </listitem>
    <listitem>
      <para>die zur Verfügungstellung von Argumenten für die Funktion CAST() um Daten von einem Typ zu
	  einem anderen zu konvertieren</para>
    </listitem>
  </itemizedlist>
  </para>

  <table id="fblangref25-dtyp-tbl-dtypinfo-de">
    <?dbfo keep-together='auto'?>
    <title>Übersicht der Datentypen</title>
    <tgroup cols="4">
      <colspec colname="colName" colwidth="1*"></colspec>
      <colspec colname="colSize" colwidth="1*"></colspec>
      <colspec colname="colPrecision" colwidth="1*"></colspec>
      <colspec colname="colDesc" colwidth="2*"></colspec>
      <thead>
        <row valign="middle">
          <entry align="center">Name</entry>
          <entry align="center">Größe</entry>
          <entry align="center">Präzision &amp; Grenzen</entry>
          <entry align="center">Beschreibung</entry>
        </row>
      </thead>
      <tbody>
          <row valign="top">
            <entry>BIGINT</entry>
            <entry>64 Bits</entry>
            <entry>Von -2<superscript>63</superscript> bis (2<superscript>63</superscript> - 1)</entry>
            <entry>Nur in Dialekt 3 verfügbar</entry>
          </row>

          <row valign="top">
            <entry>BLOB</entry>
            <entry>unterschiedlich</entry>
            <entry>Die Größe eines BLOB-Segments ist auf 64K begrenzt. Die maximale Größe eines
			BLOB-Feldes sind 4GB.</entry>
            <entry>Ein Datentyp mit dynamisch unterschiedlicher Größe für die Ablage von großen Datenmengen,
			wie z.B. Bilder, Texte, Audiodaten. Die strukturelle Basiseinheit is das Segment. Der
			BLOB-Untertyp definiert dessen Inhalt.</entry>
          </row>

          <row valign="top">
            <entry>CHAR(n), CHARACTER(n)</entry>
            <entry>n Zeichen. Größe in Bytes abhängig von der Encodierung, der Anzahl Bytes pro Zeichen</entry>
            <entry>von 1 bis 32,767 Bytes</entry>
            <entry>Ein Datentyp mit fester Länge. Bei Anzeige der Daten werden Leerzeichen an das Ende der Zeichenkette 
			bis zur angegebenen Länge angefügt. Die Leerzeichen werden nicht in der Datenbank gespeichert, jedoch 
			wiederhergestellt, um die definierte Länge bei Anzeige am Client zu erreichen. Die Leerzeichen werden 
			nicht über das Netzwerk versendet, was den Datenverkehr reduziert. Wurde kein Zeichenlänge angegeben,
			wird 1 als Standardwert verwendet.</entry>
          </row>

          <row valign="top">
            <entry>DATE</entry>
            <entry>32 Bits</entry>
            <entry>von 01.01.0001 AD bis 31.12.9999 AD</entry>
            <entry>ISC_DATE. Nur Datum, kein Zeitelement</entry>
          </row>

          <row valign="top">
            <entry>DECIMAL (<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)</entry>
            <entry>Varying (16, 32 or 64 bits)</entry>
            <entry><replaceable>precision</replaceable> = von 1 bis 18, legt die mindestmögliche Anzahl
			zu speichernder Ziffern fest; <replaceable>scale</replaceable> = von 0 bis 18,
            gibt die Anzahl der Nachkommastellen an.</entry>
            <entry>Eine Fließkommazahl, die <replaceable>scale</replaceable> Nachkommastellen besitzt.
			<replaceable>scale</replaceable> muss kleiner oder gleich dem Wert von
            <replaceable>precision</replaceable> sein. Beispiel: DECIMAL(10,3) speichert eine Zahl 
			im folgenden Format: ppppppp.sss</entry>
          </row>

          <row valign="top">
            <entry>DOUBLE PRECISION</entry>
            <entry>64 Bits</entry>
            <entry>2.225 * 10<superscript>-308</superscript> bis 1.797 * 10<superscript>308</superscript></entry>
            <entry>Doppelte Präzision nach IEEE, ~15 Stellen, zuverlässige Größe hängt von der Plattform ab.</entry>
          </row>

          <row valign="top">
            <entry>FLOAT</entry>
            <entry>32 bits</entry>
            <entry>1.175 * 10<superscript>-38</superscript> bis 3.402 * 10<superscript>38</superscript></entry>
            <entry>Einfache Präzision nach IEEE, ~7 Stellen</entry>
          </row>

          <row valign="top">
            <entry>INTEGER, INT</entry>
            <entry>32 Bits</entry>
            <entry>-2.147.483.648 up to 2.147.483.647</entry>
            <entry>Ganzzahlen mit Vorzeichen</entry>
          </row>

          <row valign="top">
            <entry>NUMERIC (<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)</entry>
            <entry>Unterschiedlich (16, 32 oder 64 Bits)</entry>
            <entry><replaceable>precision</replaceable> = von 1 bis 18, legt die genaue Anzahl zu speichernder
			Stellen fest; <replaceable>scale</replaceable> = von 0 bis 18,
			legt die Anzahl der Nachkommastellen fest.</entry>
            <entry>Eine Kommazahl mit <replaceable>scale</replaceable> Nachkommastellen.
            point. <replaceable>scale</replaceable> muss kleiner oder gleich
            <replaceable>precision</replaceable> sein. Beispiel: NUMERIC(10,3) ist eine Zahl im 
			Format: ppppppp.sss</entry>
          </row>

          <row valign="top">
            <entry>SMALLINT</entry>
            <entry>16 Bits</entry>
            <entry>-32.768 bis 32.767</entry>
            <entry>Ganzzahlen mit Vorzeichen (word)</entry>
          </row>

          <row valign="top">
            <entry>TIME</entry>
            <entry>32 Bits</entry>
            <entry>0:00 to 23:59:59.9999</entry>
            <entry>ISC_TIME. Tageszeit. Kann nicht zum Spiechern von Zeitintervallen verwendet werden.</entry>
          </row>

          <row valign="top">
            <entry>TIMESTAMP</entry>
            <entry>64 Bits (2 X 32 Bits)</entry>
            <entry>Von Anfang des Tages 01.01.0001 AD bis Ende des Tages 31.12.9999 AD</entry>
            <entry>Datum und Uhrzeit eines Tages</entry>
          </row>

          <row valign="top">
            <entry>VARCHAR(n), CHAR VARYING, CHARACTER VARYING</entry>
            <entry>n Zeichen. Größe in Bytes, abhängig von der Enkodierung, der Anzahl von Bytes für ein Zeichen</entry>
            <entry>von 1 bis 32,765 Bytes</entry>
            <entry>Zeichenkette mit variabler Länge. Die Gesamtgröße der Zeichen darf (32KB-3) nicht übersteigen. Dies berücksichtigt
			auch die hinterlegte Enkodierung. Die beiden hinteren Bytes speichern die deklarierte Länge. Es gibt keine Standardgröße.
			Das Argument <replaceable>n</replaceable> ist erforderlich. Führende und abschließende Leerzeichen werden
			gespeichert und nicht abgeschnitten, außer den Leerzeichen, die hinter der definierten Länge liegen.</entry>
          </row>
      </tbody>
    </tgroup>
  </table>

  <note>
    <title>Hinweis zu Daten</title>
    <para>Beachten Sie, dass eine Zeitreihe, bestehend aus Daten der letzten Jahrhunderte,
	verarbeitet wird, ohne auf historische Gegebenheiten Rücksicht zu nehmen. Dennoch 
	ist der Gregorianische Kalender komplett anwendbar.</para>
  </note>

  <section id="fblangref25-datatypes-inttypes-de">
    <title><database>Integer-Datentypen</database></title>
    <para>Die Datentypen SMALLINT, INTEGER und BIGINT werden für Ganzzahlen
	verschiedener Präzisionen in Dialekt 3 verwendet. Firebird unterstützt
	keine vorzeichenlosen (unsigned) Integer.</para>
    <section id="fblangref25-datatypes-smallint">
      <title><database>SMALLINT</database></title>
      <para>Der Datentyp SMALLINT dient dem Speichern von Kleinstzahlen mit einem Bereich
      -2<superscript>16</superscript> bis 2<superscript>16</superscript> - 1,
      also von -32.768 bis 32.767.</para>
      <formalpara>
        <title>SMALLINT-Beispiel</title>
        <programlisting>
      CREATE DOMAIN DFLAG AS SMALLINT DEFAULT 0 NOT NULL
        CHECK (VALUE=-1 OR VALUE=0 OR VALUE=1);

      CREATE DOMAIN RGB_VALUE AS SMALLINT;
        </programlisting>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-int-de">
      <title><database>INTEGER</database></title>
      <para>Daten vom Typ INTEGER werden als 4-Byte-Integer repräsentiert. Der Kurzname dieses Datentyps
	  ist INT. Der gültige Bereich des Datentyps <database>INTEGER</database>
      reicht von -2<superscript>32</superscript> bis 2<superscript>32</superscript> - 1,
      also von -2.147.483.648 bis 2.147.483.647.</para>
      <formalpara>
        <title>INTEGER_Beispiel</title>
        <blockquote><programlisting>
CREATE TABLE CUSTOMER (
  CUST_NO INTEGER NOT NULL, 
  CUSTOMER VARCHAR(25) NOT NULL, 
  CONTACT_FIRST VARCHAR(15), 
  CONTACT_LAST VARCHAR(20),
  CONSTRAINT INTEG_60,
  ...
    PRIMARY KEY (CUST_NO) )
        </programlisting></blockquote>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-bigint-de">
      <title><database>BIGINT</database></title>
      <para><database>BIGINT</database> ist ein SQL:99-konformer, 64-Bit langer Integer-Datentyp, der nur
      in Dialekt 3 zur Verfügung steht. Wenn der Client Dialekt 1 verwendet, sendet der Server den auf 
	  32 Bit (Integer) reduzierten Generatorwert. Bei Dialekt 3 wird der Datentyp BIGINT verwendet.</para>
      <para>Der Zahlenraum des Datentyps BIGINT liegt im Bereich zwischen -2<superscript>63</superscript>
      und 2<superscript>63</superscript> - 1, also von -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807.</para>
      <formalpara>
        <title>Hexadezimales Format für BIGINT-Zahlen</title>
        <para>Seit Firebird 2.5 können Zahlen vom Datentyp BIGINT auch im Hexadezimalen Format geschrieben werden.
		Dabei können 9 bis 16 Stellen angegeben werden. Kürzere Hexadezimalzahlen werden als 
		INTEGER interpretiert.</para>
       </formalpara>
       <formalpara>
         <title>BIGINT-Beispiel</title>
        <programlisting>
       CREATE TABLE WHOLELOTTARECORDS (
         ID BIGINT NOT NULL PRIMARY KEY,
         DESCRIPTION VARCHAR(32)
        );

       INSERT INTO MYBIGINTS VALUES (
         -236453287458723,
         328832607832,
         22,
         -56786237632476,
         0X6F55A09D42, -- 478177959234
         0X7FFFFFFFFFFFFFFF, -- 9223372036854775807
         0XFFFFFFFFFFFFFFFF, -- -1
         0X80000000, -- -2147483648, ein INTEGER
         0X080000000, -- 2147483648, ein BIGINT
         0XFFFFFFFF, -- -1, ein INTEGER
         0X0FFFFFFFF -- 4294967295, ein BIGINT
        );
        </programlisting>
        <para>Die hexadezimalen INTEGER im obigen Beispiel werden automatisch in den BIGINT-Datentyp 
		gewandelt, bevor sie in die Tabelle eingefügt werden. Jedoch passiert dies
		<emphasis>nachdem</emphasis> der numerische Wert bestimmt wurde, wodurch
		0x80000000 (8 Stellen) und 0x080000000 (9 Stellen) als unterschiedliche BIGINT-Werte 
		gespeichert werden.</para>
      </formalpara>
    </section>

  </section><!-- Integer Data Types -->

  <section id="fblangref25-datatypes-floattypes-de">
    <title><database>Fließkomma-Datentypen</database></title>
    <para>Fließkomma-Datentypen werden nach dem IEEE 754-Standard binär gespeichert und 
    enthalten Vorzeichen, Exponent und Mantisse. Die Genauigkeit ist dynamisch, je nach verwendetem 
    Speicherformat, welches 4 Bytes für <database>FLOAT</database> oder 8 Bytes für
    <database>DOUBLE PRECISION</database> im Speicher belegt.</para>
    <para>Angesichts der Besonderheiten bei der Speicherung von Fließkommazahlen in einer Datenbank, werden diese
	Datentypen nicht zum Speichern von monetären Daten empfohlen. Aus den gleichen Gründen sollte die Verwendung
	dieser Felder für Schlüssel und Eindeutigkeiten vermieden werden.</para>
    <para>Für die Prüfung von Daten in Spalten mit Fließkomma-Datentypen sollten Ausdrücke auf bestimmte Bereiche,
	statt auf Übereinstimmungen geprüft werden.</para>
    <para>Wenn diese Datentypen in Ausdrücken Verwendung finden, ist äußerste Sorgfalt in Bezug auf die Rundung der
    Ergebnisse zu legen.</para>

    <section id="fblangref25-datatypes-float-de">
      <title><database>FLOAT</database></title>
      <para>Dieser Datentyp hat eine ungefähre Genauigkeit von 7 Stellen nach dem Komma.
      Um die korrekte Sicherung der Daten zu gewährleisten, verwenden Sie nur 6 Stellen.</para>
    </section>
    <section id="fblangref25-datatypes-double">
      <title><database>DOUBLE PRECISION</database></title>
      <para>Dieser Datentyp besitzt eine ungefähre Genauigkeit von 15 Stellen.</para>
    </section>
  </section><!-- Floating Point Data Types -->

  <section id="fblangref25-datatypes-fixedtypes">
    <title><database>Festkomma-Datentypen</database></title>
    <para>Festkomma-Datentypen sorgen für die Vorhersehbarkeit bei Multiplikations- und Divisionoperationen.
	Somit sind sie die erste Wahl zum Speichern monetärer Daten. Firebird implementiert zwei 
	Festkomma-Datentypen:
    <database>NUMERIC</database> und <database>DECIMAL</database>. Gemäß dem Standard,
	werden beide Datentypen mit der Anzahl zu speichernder Stellen (Stellen nach dem Komma) begrenzt.</para>
    <para>Verschiedene Behandlungen beschränken die Genauigkeit für jeden Typ: Die Genauigkeit für NUMERIC-Felder
    ist genau <quote>wie deklariert</quote>, wohingegen DECIMAL-Felder Zahlen akzeptieren, deren Genauigkeit 
	mindestens der Deklaration entspricht.</para>
    <para>Beispielsweise definiert NUMERIC(4, 2) eine Zahl mit insgesamt 4 Stellen und 2 Nachkommastellen; 
	das heißt, es können bis zu zwei Stellen vor dem Komma und maximal 2 Stellen nach dem Komma 
	verwendet werden. Wird die Zahl 3,1415 in ein Feld dieses Datentyps geschrieben, wird der Wert
	3,14 gespeichert.</para>
    <para>Die Art der Deklaration für Festkomma-Datentypen, zum Beispiel
    NUMERIC(<replaceable>p</replaceable>, <replaceable>s</replaceable>), ist beiden Typen gleich. 
	Zu beachten ist, dass die Skalierung mittels des Arguments <replaceable>s</replaceable>, vielmehr
	die Bedeutung <quote>Anzahl der Stellen nach dem Dezimalkomma</quote> hat. 
	Das Verständnis wie Festkomma-Datentypen ihre Daten speichern und abrufen zeigt auch, warum dies
	so ist: beim Speichern wird die Zahl mit 10<superscript>s</superscript> multipliziert 
	(10 hoch <replaceable>s</replaceable>) und als Integer gespeichert; beim Lesen wird der Integer 
	wieder zurückkonvertiert.</para>

    <para>Die Art und Weise wie Festkomma-Daten im DBMS abgelegt werden, hängt von diversen
	Faktoren ab: Genauigkeit, Datenbankdialekt, Deklartionstyp.</para>

    <table id="fblangref25-dtyp-tbl-realnums-de">
      <title>Verfahren zum Speichern von reellen Zahlen</title>
      <tgroup cols="4">
        <colspec colname="colScale" colwidth="2*"></colspec>
        <colspec colname="colType" colwidth="3*"></colspec>
        <colspec colname="colDial01" colwidth="3*"></colspec>
        <colspec colname="colDial03" colwidth="3*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Skalierung</entry>
            <entry align="center">Datentyp</entry>
            <entry align="center">Dialekt 1</entry>
            <entry align="center">Dialekt 3</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry>1 - 4</entry>
            <entry>NUMERIC</entry>
            <entry>SMALLINT</entry>
            <entry>SMALLINT</entry>
          </row>
          <row valign="middle">
            <entry>1 - 4</entry>
            <entry>DECIMAL</entry>
            <entry>INTEGER</entry>
            <entry>INTEGER</entry>
          </row>
          <row valign="middle">
            <entry>5 - 9</entry>
            <entry>NUMERIC ODER DECIMAL</entry>
            <entry>INTEGER</entry>
            <entry>INTEGER</entry>
          </row>
          <row valign="middle">
            <entry>10 - 18</entry>
            <entry>NUMERIC ODER DECIMAL</entry>
            <entry>DOUBLE PRECISION</entry>
            <entry>BIGINT</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="fblangref25-datatypes-numeric-de">
      <title><database>NUMERIC</database></title>
      <formalpara>
        <title>Datenformat für die Deklaration</title>
        <literallayout class="monospaced">
       NUMERIC(<replaceable>p</replaceable>, <replaceable>s</replaceable>)
        </literallayout>
      </formalpara>
      <formalpara>
        <title>Beispiel der Speicherung</title>
        <para>In Bezug auf das obige Beispiel, wird das DBMS NUMERIC-Daten in 
		Abhängigkeit von der angegebenen Genauigkeit (<replaceable>p</replaceable>) und
        der Skalierung (<replaceable>s</replaceable>) speichern. Weitere Beispiele:</para>
        <literallayout class="monospaced">
       NUMERIC(4) wird gespeichert als      SMALLINT (exakte Daten)
       NUMERIC(4,2)                         SMALLINT (Daten * 10<superscript>2</superscript>)
       NUMERIC(10,4) (Dialekt 1)            DOUBLE PRECISION
                     (Dialekt 3)            BIGINT (Daten * 10<superscript>4</superscript>)
        </literallayout>
      </formalpara>
      <caution>
        <para>Beachten Sie, dass das Speicherformat von der Genauigkeit abhängt.
		So können Sie zum Beispiel die Spalte als NUMERIC(2,2) definieren, vorausgesetzt
		ihr Wertebereich liegt zwischen -0.99...0.99. Dennoch liegt der reale Wertebereich
		zwischen -327.68..327.67, wodurch deutlich wird, dass der NUMERIC(2,2)-Datentyp 
		im SMALLINT-Format abgelegt wird. Gleiches gilt für NUMERIC(4,2) und NUMERIC(3,2). 
		Das heißt, wenn Sie den Wertebereich auf -0.99...0.99 beschränken wollen, müssen Sie
		einen Constraint hierfür erstellen.
		</para>
      </caution>
    </section>
    <section id="fblangref25-datatypes-decimal">
      <title><database>DECIMAL</database></title>
      <formalpara>
        <title>Datenformat für die Deklaration</title>
        <literallayout class="monospaced">
       DECIMAL(<replaceable>p</replaceable>, <replaceable>s</replaceable>)
        </literallayout>
      </formalpara>
      <formalpara>
        <title>Beispiel der Speicherung</title>
        <para>Das Speicherformat in der Datenbank für DECIMAL-Felder ist ähnlich dem von NUMERIC,
		mit dem Unterschied, dass es leichter zu verstehen ist, mit ein paar Beispielen:</para>
        <literallayout class="monospaced">
       DECIMAL(4) gespeichert als  INTEGER (exakte Daten)
       DECIMAL(4,2)                INTEGER (Daten * 10<superscript>2</superscript>)
       DECIMAL(10,4) (Dialekt 1)   DOUBLE PRECISION
                     (Dialekt 3)   BIGINT (Daten * 10<superscript>4</superscript>)
        </literallayout>
      </formalpara>
    </section>
  </section><!-- Fixed Point Data Types -->

  <section id="fblangref25-datatypes-datetime-de">
    <title>Datentypen für Datum und Zeit</title>
    <para>Die Datentypen <database>DATE</database>, <database>TIME</database> und <database>TIMESTAMP</database>
    werden zur Arbeit mit Daten verwendet, die Daten und Zeiten beinhalten.
    Dialekt 3 unterstützt alle drei Typen, während Dialekt 1 nur <database>DATE</database> kennt. Der Datentyp
    <database>DATE</database> in Dialekt 3 ist <quote>nur Datum</quote>, wohingegen der Datentyp
    <database>DATE</database> in Dialekt 1 Datum und Tageszeit speichert. Somit ist dieser equivalent zu
    <database>TIMESTAMP</database> in Dialekt 3.  Dialekt 1 kennt keinen <quote>nur Datum</quote>-Typ.</para>
    <note>
      <para>In Dialekt 1 können <database>DATE</database>-Daten alternativ als 
	  <database>TIMESTAMP</database> definiert werden. Dies ist die empfohlene Anwendung für neue Definitionen 
	  in Dialekt 1-Datenbanken.</para>
    </note>
    <formalpara>
      <title>Sekundenbruchteile</title>
      <para>Werden Sekundenbruchteile in Datums- und Zeitfeldern benötigt, speichert Firebird diese
	  in zehntausendstel Sekunden. Wird eine geringere Genauigkeit bevorzugt, kann diese explizit
	  als tausendstel, hundertstel oder zehntel Sekunde in Dialekt 3-Datenbanken ab ODS 11 spezifiziert
	  werden.</para>
    </formalpara>
    <note>
      <title>Einige nützliche Informationen zur Genauigkeit von Sekundenbruchteilen:</title>
      <para>Der Zeitanteil eines <database>TIME</database>- oder <database>TIMESTAMP</database>-Datentyps
	  ist ein 4-Byte WORD, mit Raum für Dezimalsekunden-Genauigkeit. Die Zeitwerte werden als Dezimalmillisekunden
	  ab Mitternacht gespeichert. Die derzeitige Genauigkeit dieser Werte, die mittels Zeit(stempel)-Funktionen
	  oder -Variablen gelesen oder geschrieben werden ist:
        <itemizedlist>
          <listitem><emphasis>CURRENT_TIME</emphasis> nutzt standardmäßig Sekundengenauigkeit und kann 
		  bis zu Millisekundengenauigkeit definiert werden: &nbsp;<function>CURRENT_TIME (0|1|2|3)</function>&nbsp;</listitem>
          <listitem><emphasis>CURRENT_TIMESTAMP</emphasis> Millisekundengenauigkeit.  Genauigkeit von Sekunden bis zu
          Millisekunden kann mit &nbsp;<function>CURRENT_TIMESTAMP (0|1|2|3)</function>&nbsp; definiert werden.</listitem>
          <listitem>Literal <emphasis>'NOW'</emphasis>: Millisekundengenauigkeit</listitem>
          <listitem>Die Funktionen <emphasis>DATEADD()</emphasis> und <emphasis>DATEDIFF()</emphasis> unterstützen
		  die Genauigkeit bis zu Millisekunden. Dezimalmillisekunden können definiert werden, diese werden jedoch 
		  auf die nächste Ganzzahl gerundet, bevor weitere Operationen durchgeführt werden.</listitem>
          <listitem>Die Funktion <emphasis>EXTRACT()</emphasis> gibt die Genauigkeit bis auf Dezimalmillisekunden
		  zurück, wenn die Argumente <database>SECOND</database> und <database>MILLISECOND</database> verwendet werden.</listitem>
          <listitem>Für die Literale <emphasis>TIME und TIMESTAMP</emphasis> akzeptiert Firebird glücklicherweise 
		  Genauigkeiten bis zu Dezimalmillisekunden, schneidet (nicht rundet) den Zeitteil jedoch auf die nächste, untere oder gleiche
		  Millisekunde ab. Versuchen Sie beispielsweise 
          &nbsp;<function>SELECT TIME '14:37:54.1249' FROM rdb$database</function></listitem>
          <listitem> werden Sie feststellen, dass die Operatoren '+' und '-' mit Dezimalmillisekunden-Genauigkeit
		  arbeiten, jedoch nur <emphasis>innerhalb</emphasis> des Ausdrucks. Sobald irgendwas gespeichert oder nur
		  von RDB$DATABASE abgefragt (SELECTed) wird, wandelt sich die Genauigkeit zu Millisekunden.</listitem>
        </itemizedlist>
      Die Genauigkeit auf Basis von Dezimalmillisekunden ist selten und wird derzeit nicht in Spalten oder Variablen gespeichert.
	  Obwohl Firebird die Werte von <database>TIME</database> und den Zeitteil von <database>TIMESTAMP</database>
	  als Dezimalmillisekunden (10<superscript>-4</superscript> Sekunden) seit Mitternacht speichert, kann die 
	  Genauigkeit von Sekunden zu Millisekunden variieren.</para>
    </note>

    <section id="fblangref25-datatypes-date-de">
      <title><database>DATE</database></title>
      <para>Der Datentyp <database>DATE</database> in Dialekt 3 speichert nur das Datum ohne Zeitangabe.
	  Der verfügbare Bereich reicht vom 1. Januar 0001 bis zum 31. Dezember 9999.</para>
      <para>In Dialekt 1 gibt es keinen <quote>nur Datum</quote>-Datentyp.
        <tip>
          <para>In Dialekt 1, erhalten Datums-Literale ohne Zeitangabe, genauso wie
          <database>'TODAY'</database>, <database>'YESTERDAY'</database> und
          <database>'TOMORROW'</database> automatisch einen Null-Zeitteil.</para>
          <para>Sollte es für Sie wichtig sein, aus welchem Grund auch immer, einen 
		  Zeitstempel-Literal mit einem expliziten Null-Zeitteil in Dialekt 1 zu speichern,
		  wird die Datenbank ein Literal wie 
          <function>'25.12.2016 00:00:00.0000'</function> akzeptieren. Der Wert <function>'25.12.2016'</function>
          hätte jedoch den gleichen Effekt, mit weniger Tastenschlägen!</para>
        </tip>
      </para>
    </section>

    <section id="fblangref25-datatypes-time-de">
      <title><database>TIME</database></title>
      <para>Der Datentyp <database>TIME</database> ist nur in Dialekt 3 verfügbar. Er speichert die Tageszeit
	  im Bereich von 00:00:00.0000 bis 23:59:59.9999.</para>
	  <para>Sollten Sie den Zeitteil eines <database>DATE</database> in Dialekt 1 benötigen, können Sie die 
	  Funktion <database>EXTRACT</database> verwenden.</para>
      <formalpara>
        <title>Beispielverwendung von <database>EXTRACT</database></title>
        <programlisting>
       EXTRACT (HOUR FROM DATE_FIELD)
       EXTRACT (MINUTE FROM DATE_FIELD)
       EXTRACT (SECOND FROM DATE_FIELD)
        </programlisting>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-timestamp-de">
      <title><database>TIMESTAMP</database></title>
      <para>Der Datentyp <database>TIMESTAMP</database> ist in Dialekt 1 und 3 verfügbar.
	  Er besteht aus zwei 32-Bit-Teilen&mdash;einem Datums- und einem Zeitteil&mdash;womit eine Struktur
	  gebildet wird, die sowohl Datum wie auch Tageszeit aufnimmt. Der Datentyp ist identisch mit DATE
	  in Dialekt 1.</para>
	  <para>Die Funktion <database>EXTRACT</database> arbeitet für <database>TIMESTAMP</database>
	  genauso wie für <database>DATE</database> in Dialekt 1.</para>
    </section>

    <section id="fblangref25-datatypes-datetimeops-de">
      <title>Operationen, die Datums- und Zeitwerte verwenden</title>
      <para>Das Verfahren zum Speichern der Datums- und Zeitwerte macht es möglich,
	  diese als Operanden in arithmetischen Operationen zu verwenden. Gespeichert, wird ein Datumswert
	  als Zahl seit dem <quote>Datum Null</quote>&mdash;17. November 1898&mdash; repräsentiert,
	  ein Zeitwert als Anzahl der Sekunden (unter Berücksichtigung der Sekundenbruchteile) seit Mitternacht.</para>
	  <para>Ein Beispiel ist das Subtrahieren eines früheren Datum, einer Zeit oder eines Zeitstempels von einem späteren,
	  was in einm Zeitintervall, in Tagen und Bruchteilen von Tagen resultiert.</para>

      <table id="fblangref25-dtyp-tbl-dateops-de">
      <?dbfo keep-together='auto'?>
        <title>Arithmetische Operationen für Datums- und Zeitdatentypen</title>
        <tgroup cols="4">
          <colspec colname="colOp01" colwidth="1*"></colspec>
          <colspec colname="colOp" colwidth="1*"></colspec>
          <colspec colname="colOp02" colwidth="*1"></colspec>
          <colspec colname="colResult" colwidth="2*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Operand 1</entry>
              <entry align="center">Operation</entry>
              <entry align="center">Operand 2</entry>
              <entry align="center">Ergebnis</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">+</entry>
              <entry>TIME</entry>
              <entry>TIMESTAMP</entry>
            </row>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">+</entry>
              <entry>Numerischer Wert <replaceable>n</replaceable></entry>
              <entry>DATE um <replaceable>n</replaceable> ganze Tage erhöht. Gebrochene Werte werden 
			  auf die nächste Ganzzahl gerundet (nicht abgeschnitten).</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">+</entry>
              <entry>DATE</entry>
              <entry>TIMESTAMP</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">+</entry>
              <entry>Numerischer Wert <replaceable>n</replaceable></entry>
              <entry>TIME um <replaceable>n</replaceable> Sekunden erhöht. Bruchteile werden berücksichtigt.</entry>
            </row>
            <row valign="middle">
              <entry>TIMESTAMP</entry>
              <entry align="center">+</entry>
              <entry>Numerischer Wert <replaceable>n</replaceable></entry>
              <entry>TIMESTAMP, wobei das Datum um die Anzahl der Tage 
			  und der Teil eines Tages durch die Zahl <replaceable>n</replaceable>repräsentiert wird&mdash;
			  somit wird <quote>+ 2.75</quote> das Datum um 2 Tage und 18 Stunden weiterstellen wird</entry>
            </row>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">-</entry>
              <entry>DATE</entry>
              <entry>Anzahl der vergangenen Tage innerhalb des Bereichs DECIMAL(9, 0)</entry>
            </row>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">-</entry>
              <entry>Numerischer Wert <replaceable>n</replaceable></entry>
              <entry>DATE um <replaceable>n</replaceable> ganze Tage reduziert. Gebrochene Werte werden 
			  auf die nächste Ganzzahl gerundet (nicht abgeschnitten).</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">-</entry>
              <entry>TIME</entry>
              <entry>Anzahl der vergangenen Sekunden, innerhalb des Bereichs DECIMAL(9, 4)</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">-</entry>
              <entry>Numerischer Wert <replaceable>n</replaceable></entry>
              <entry>TIME um <replaceable>n</replaceable> Sekunden reduziert. Bruchteile werden berücksichtigt.</entry>
            </row>
            <row valign="middle">
              <entry>TIMESTAMP</entry>
              <entry align="center">-</entry>
              <entry>TIMESTAMP</entry>
              <entry>Anzahl der Tage und der Tageszeit, innerhalb des Bereichs DECIMAL(18, 9)</entry>
            </row>
            <row valign="middle">
              <entry>TIMESTAMP</entry>
              <entry align="center">-</entry>
              <entry>Numerischer Wert <replaceable>n</replaceable></entry>
              <entry>TIMESTAMP wobei das Datum sich auf der Anzahl der Tage und der Tageszeit beruht,
			  die durch die Zahl <replaceable>n</replaceable> repräsentiert wird&mdash;somit wird <quote>- 2.25</quote>
              das Datum um 2 Tage und 6 Stunden reduzieren.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note><title>Hinweise</title>
        <para>Der Datentyp DATE ist als TIMESTAMP in Dialekt 1 zu betrachten.</para>
      </note>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-dateadd"><database>DATEADD</database></link>,
        <link linkend="fblangref25-functions-scalarfuncs-datediff"><database>DATEADD</database></link></para>
      </formalpara>
    </section>
  </section><!-- Date and Time Data Types -->

  <section id="fblangref25-datatypes-chartypes-de">
    <title>Zeichendatentypen</title>
    <para>Für die Arbeit mit Zeichendaten bietet Firebird die Datentypen <database>CHAR</database>
	mit Festlänge und <database>VARCHAR</database> mit variabler Zeichenlänge. Die Maximalgröße der hiermit
	speicherbaren Daten beträgt 32.767 Bytes für <database>CHAR</database> und 32.765 Bytes für
    <database>VARCHAR</database>. Das Maximum der möglichen <emphasis>Zeichen</emphasis>, das
	in diese Grenzen passt, hängt vom verwendeten Zeichensatz (<database>CHARACTER SET</database>) ab.
        Die Sortiermethode <database>COLLATE</database> wirkt sich nicht auf die Maximalgrenze aus, wohingegen sie 
	durchaus die maximale Größe eines Indexes auf dieser Spalte beeinflussen kann.</para>

    <para>Wurde während der Definition eines Zeichenobjektes kein expliziter Zeichensatz festgelegt,
	wird der Standardzeichensatz der Datenbank verwendet. Wurde für die Datenbank kein Standardzeichensatz
	festgelegt, erhält das Feld den Zeichensatz NONE.</para>

    <!-- The following passage is specifically for readers who work with Cyrillic alphabets.

    <para>If the database contains strings with only the Russian alphabet in it, the WIN1251 encoding is
    recommended to be used. If you use it, one character occupies 1 byte, therefore the maximum size of
    text fields for this encoding will be 32,767 characters. It is not necessary to specify the collation
    sequence (COLLATE) for the standard collation operations in case WIN1251 is used.</para>

    <para>Most current development tools support Unicode. In case you need to use Western European texts
    or alphabets that are more exotic in string fields of your database, it is recommended to work with
    the UTF8 character set. In this case, you should bear in mind that one character in this set occupies
    up to 4 bytes. Therefore, the maximum size of character fields will be 32,676/4 (8,192) characters. </para>

    -->

    <section id="fblangref25-datatypes-chartypes-unicode-de">
      <title>Unicode</title>
      <para>Die meisten aktuellen Entwicklertools unterstützen Unicode, welches in Firebird mit den Zeichensätzen
      <database>UTF8</database> und <database>UNICODE_FSS</database> integriert ist. <database>UTF8</database> bietet
	  Sortierungen für viele Sprachen.  <database>UNICODE_FSS</database> ist deutlich begrenzter und wird hauptsächlich
	  intern durch Firebird für das Speichern von Metadaten verwendet. Beachten Sie, dass ein
	  <database>UTF8</database>-Zeichen bis zu 4 Bytes beanspruchen kann, wodurch die Größe von 
	  <database>CHAR</database>-Feldern auf 8.191 Zeichen reduziert werden kann (32.767/4).</para>
      <note>
        <para>Der genaue Wert der <quote>Bytes pro Zeichen</quote> hängt vom Bereich des Zeichens ab.
		Nicht-akzentuierte Latin-Buchstaben beanspruchen 1 Byte, kyrillische Zeichen mit WIN1251-Enkodierung 
		beanspruchen 2 Bytes, andere Zeichenenkodierungen können bis zu 4 Bytes beanspruchen.
		</para>
      </note>
      <para>Der in Firebird implementierte <database>UTF8</database>-Zeichensatz, unterstützt die aktuellste 
	  Version des Unicode-Standards. Somit ist dieser für internationale Datenbanken empfohlen.</para>
    </section>

    <section id="fblangref25-datatypes-chartypes-client-de">
      <title>Client-Zeichensatz</title>
      <para>Während der Arbeit mit Zeichenketten, ist es notwendig, den Zeichensatz des Clients
	  zu berücksichtigen. Sollte eine Diskrepanz zwischen den Zeichensätzen der gespeicherten Daten und
	  der Clientverbindung existieren, werden Ausgaben für Textfelder automatisch neu enkodiert. Dies gilt
	  für Daten, die vom Client zum Server gesendet werden und anders herum.
      Wurde die Datenbank beispielsweise mit <database>WIN1251</database> enkodiert, der Client verwendet 
	  jedoch <database>KOI8R</database> oder <database>UTF8</database>, stellt sich die Diskrepanz transparent
	  dar.</para> 
    </section>

    <section id="fblangref25-datatypes-chartypes-special-de">
      <title>Spezielle Zeichensätze</title>
      <formalpara><title>Zeichensatz <database>NONE</database></title>
        <para>Der Zeichensatz <database>NONE</database> ist ein <emphasis>Spezialzeichensatz</emphasis>
        in Firebird. Er kann so beschrieben werden, als wäre jedes Byte Teil einer Zeichenkette,
		die jedoch keine Angaben zur Beschreibung eines Zeichens macht:
        Zeichenenkodierung, Sortierung, Klein- und Großschreibung, etc. sind einfach unbekannt. </para>

        <para>Es liegt in der Verantwortung der Client-Anwendung mit den Daten umzugehen und
         die richtigen Mittel bereitzustellen, um die Folge von Bytes in irgendeiner Weise interpretieren
		 zu können, die für die Anwendung sinnvoll sind und für den Menschen lesbar.</para>
      </formalpara>
      <formalpara><title>Zeichensatz <database>OCTETS</database></title>
        <para>Daten der <database>OCTETS</database>-Enkodierung werden als Bytes behandelt, die nicht direkt als
		Zeichen interpretiert werden. <database>OCTETS</database> bieten einen Weg um Binärdaten zu speichern,
		was die Ergebnisse einiger Firebird-Funktionen sein könnten.
        </para>        
        <para>Die Datenbank weiß nicht was mit einer Zeichenkette aus Bits in <database>OCTETS</database> zu tun ist,
		außer diese zu speichern und abzufragen. Auch hier ist wieder der Client verantwortlich für die Validierung 
		der Daten und diese sowohl der Anwendung wie auch dem Benutzer in verständlicher Form anzuzeigen.
		Dies gilt auch für Ausnahmen, die durch die Enkodierung und Dekodierung verursacht werden.</para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-chartypes-collation-de">
      <title>COLLATION</title>
      <para>Jeder Zeichensatz hat eine Standardsortiermethode (<database>COLLATE</database>).
	  Üblicherweise stellt diese nicht mehr bereit als die Reihenfolge basierend auf einem numerischen
	  Code der Zeichen und einer Basiszuordnung der Klein- und Großbuchstaben. Wird ein Verhalten außerhalb
	  der Collation benötigt und eine alternative Methode für den Zeichensatz unterstützt,
	  kann eine <database>COLLATE</database> <replaceable>Sortier</replaceable>-Klausel in der Felddefinition 
	  verwendet werden.</para>
      <para>Eine <database>COLLATE</database> <replaceable>Sortier</replaceable>-Klausel kann auch in anderen
	  Zusammenhängen neben der Spaltendefinition angewandt werden. Für größer-als-/kleiner-als-Vergleiche,
	  kann sie in die <database>WHERE</database>-Klausel des <database>SELECT</database>-Statements
	  aufgenommen werden. Wird eine speziell alphabetisch geordnete oder Groß- und Kleinschreibungsinsensitive
	  Ausgabe benötigt, und sollte eine passende Collation existieren, dann kann die
	  <database>COLLATE</database>-Klausel auch in der <database>ORDER BY</database>-Klausel verwendet werden.</para>

      <section id="fblangref25-datatypes-chartypes-caseinsenstv">
        <title>Groß- und Kleinschreibungsinsensitive Suche</title>
        <para>Für die Groß- und Kleinschreibungsinsensitive Suche, kann die Funktion UPPER verwendet werden,
		damit das Suchargument und der die gesuchte Zeichenkette in Großbuchstaben gewandelt werden, bevor 
		der Vergleich stattfindet:
          <literallayout class="monospaced">
         &hellip;
         where upper(name) = upper(:flt_name)
          </literallayout>
        </para>
        <para>Für Zeichenketten eines Zeichensatzes, der keine Groß- und Kleinschreibungsinsensitive Sortierung 
		bereitstellt, können sie die Sortierung anwenden, um das Suchargument und die gesuchte Zeichenkette 
		direkt miteinander zu vergleichen. Beispielsweise ist unter dem Zeichensatz <database>WIN1251</database>
		die Sortierung <database>PXW_CYRL</database> Groß- und Kleinschreibungsinsensitiv. Somit gilt:
          <literallayout class="monospaced">
         &hellip;
         WHERE FIRST_NAME COLLATE PXW_CYRL &gt;= :FLT_NAME
         &hellip;
         ORDER BY NAME COLLATE PXW_CYRL
          </literallayout>
        </para>
        <formalpara><title>Vgl. auch</title>
          <para><link linkend="fblangref25-commons-predcontaining"><database>CONTAINING</database></link></para>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-chartypes-utf8collations-de">
        <title><database>UTF8</database>-Collation</title>
        <para>Die folgende Tabelle zeigt mögliche Sortiermethoden für den
        <database>UTF8</database>-Zeichensatz.</para>
        <table id="fblangref25-dtyp-tbl-utfcollats-de">
          <title>Collation für den Zeichensatz UTF8</title>
          <tgroup cols="2">
          <colspec colname="colColl" colwidth="1*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Sortierung</entry>
                <entry align="center">Merkmale</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center"><database>UCS_BASIC</database></entry>
                <entry>Sortierung arbeitet abhängig von der Position des Zeichens in der Tabelle (binär).
				Hinzugefügt in Firebird 2.0</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UNICODE</database></entry>
                <entry>Sortierung arbeitet abhängig vom UCA-Algorithmus (Unicode Collation
                Algorithm) (alphabetisch). Hinzugefügt in Firebird 2.0</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UTF8</database></entry>
                <entry>Die Standard-Sortierung, binär, identisch zu <database>UCS_BASIC</database>,
                welche im Rahmen der SQL-Kompatibilität hinzugefügt wurde.</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UNICODE_CI</database></entry>
                <entry>Groß- und Kleinschreibungsinsensitive Sortierung, arbeitet ohne Groß- und Kleinschreibung zu 
				berücksichtigen. Hinzugefügt in Firebird 2.1</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UNICODE_CI_AI</database></entry>
                <entry>Groß- und Kleinschreibungsunabhängige, akzentunabhängige Sortierung, die weder 
				Groß- und Kleinschreibung noch Akzentuierung von Zeichen berücksichtigt. Arbeitet alphabetisch. Hinzugefügt in Firebird 2.5</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <formalpara><title>Beispiel</title>
          <para>Ein Beispiel einer Sortierung für den UTF8-Zeichensatz ohne Berücksichtigung 
		  der Groß- und Kleinschreibung oder Akzentuierung der Zeichen (ähnlich zu <database>COLLATE PXW_CYRL</database>).
            <programlisting>
       ...
       ORDER BY NAME COLLATE UNICODE_CI_AI
            </programlisting>
          </para>
        </formalpara>
      </section>

    </section>

    <section id="fblangref25-datatypes-chartypes-charindxs-de">
      <title>Zeichenindizes</title>
      <para>In Firebird-Versionen vor 2.0 kann es zu Problemen beim Erstellen eines Index
	  für Zeichenspalten kommen, die eine außergewöhnliche Collation nutzen:
	  die Länge eines indizierten Feldes ist auf 252 Bytes beschränkt, sofern
	  kein <database>COLLATE</database> spezifiziert wurde, andernfalls sind es 84 Bytes.
	  Multi-Byte-Zeichensätze schränken die Indizes weiter ein.</para>
      <para>Ab Firebird 2.0 beschränkt sich die Indexlänge auf ein Viertel der Seitengröße (page size),
	  z.B. von 1.024 bis 4.096 Bytes. Die größtmögliche Länge einer indizierten Zeichenkette liegt bei
	  9 Bytes weniger als die Viertel-Seiten-Grenze.</para>

      <formalpara>
        <title>Berechnung der maximalen Länge eines indizierten Zeichenfeldes</title>
        <para>Die folgende Formel berechnet der maximale Länge eines indizierten Zeichenfeldes
		(in Zeichen):
        <programlisting>
       max_char_length = FLOOR((page_size / 4 - 9) / N)
        </programlisting>
         wobei N die Anzahl der Bytes pro Zeichen im Zeichensatz darstellt.
        </para>
      </formalpara>
      <para>Die folgende Tabelle zeigt die Maximallänge einer indizierten Zeichenkette (in Zeichen), 
	  abhängig von der Seitengröße und Zeichensatz. Die Maximallänge wurde mittels der o.a. Formel 
	  berechnet.</para>

      <table id="fblangref25-dtyp-tbl-charindxsz-de">
        <title>Maximale Indexlänge nach Seitengröße und Zeichengröße</title>
        <tgroup cols="6">
          <colspec colname="colPgsz" colwidth="1*"></colspec>
          <colspec colname="col1B" colwidth="1*"></colspec>
          <colspec colname="col2B" colwidth="1*"></colspec>
          <colspec colname="col3B" colwidth="1*"></colspec>
          <colspec colname="col4B" colwidth="1*"></colspec>
          <colspec colname="col6B" colwidth="1*"></colspec>
          <spanspec spanname="span5" nameend="col6B" namest="col1B"/>
          <thead>
            <row valign="middle">
              <entry align="center" morerows="1">Seitengröße (Page Size)</entry>
              <entry align="center" nameend="col6B" namest="col1B">Maximale Länge 
			  einer indizierten Zeichenkette für ein Zeichen, Bytes / Zeichen</entry>
            </row>
            <row>
              <entry align="center">1</entry>
              <entry align="center">2</entry>
              <entry align="center">3</entry>
              <entry align="center">4</entry>
              <entry align="center">6</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">4.096</entry>
              <entry align="center">1.015</entry>
              <entry align="center">507</entry>
              <entry align="center">338</entry>
              <entry align="center">253</entry>
              <entry align="center">169</entry>
            </row>
            <row valign="middle">
              <entry align="center">8.192</entry>
              <entry align="center">2.039</entry>
              <entry align="center">1.019</entry>
              <entry align="center">679</entry>
              <entry align="center">509</entry>
              <entry align="center">339</entry>
            </row>
            <row valign="middle">
              <entry align="center">16.384</entry>
              <entry align="center">4.087</entry>
              <entry align="center">2.043</entry>
              <entry align="center">1.362</entry>
              <entry align="center">1.021</entry>
              <entry align="center">682</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note>
        <para>Mit Collations (<quote>_CI</quote>), die Groß- und Kleinschreibungsinsensitiv sind,
		wird ein Zeichen im <command>Index</command> nicht 4, sondern 6 Bytes, beanspruchen. Hierdurch wird
		die maximale Schlüssellänge für eine Seitengröße von zum Beispiel 4.096 Bytes auf 169 Zeichen begrenzt.
		</para>
      </note>
      <formalpara><title>Vergleichen Sie auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-db-create"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-datatypes-chartypes-collation-de">COLLATION</link>,
        <link linkend="fblangref25-dml-select"><database>SELECT</database></link>,
        <link linkend="fblangref25-dml-select-where"><database>WHERE</database></link>,
        <link linkend="fblangref25-dml-select-groupby"><database>GROUP BY</database></link>,
        <link linkend="fblangref25-dml-select-orderby"><database>ORDER BY</database></link>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-chartypes-detail-de">
      <title>Zeichendatentypen im Detail</title>
      <section id="fblangref25-datatypes-chartypes-char-de">
        <title><database>CHAR</database></title>
        <para><database>CHAR</database> ist ein Festlängen-Datentyp. Ist die eingegebene Anzahl 
		der Zeichen kleiner als die definierte Länge, werden Leerzeichen zu dem Feld hinzugefügt.
		Grundsätzlich muss das Füllzeichen kein Leerzeichen sein: dies hängt vom Zeichensatz ab.
		So ist das Füllzeichen für den <database>OCTETS</database>-Zeichensatz beispielsweise
		die Null.</para>
        <para>Der volle Name dieses Datentyps ist <database>CHARACTER</database>, es ist jedoch
		nicht erforderlich volle Namen zu verwenden und die Leute tun dies auch sehr selten.</para>
        <para>Daten für Festlängen-Zeichen können verwendet werden, um Codes zu speichern, deren 
		Länge standardisiert ist und die eine definierte <quote>Breite</quote> besitzen. Ein Beispiel 
		hierfür ist ein EAN13-Barcode&mdash;13 Zeiche, alle gefüllt.</para>
        <formalpara>
          <title>Syntax für die Deklaration</title>
          <programlisting>
       CHAR [(<replaceable>length</replaceable>)] [CHARACTER SET &lt;set&gt;] [COLLATE &lt;name&gt;]
          </programlisting>
          <note>
            <para>Wurde keine Länge (<replaceable>length</replaceable>) angegeben, wird 1 verwendet.</para>
            <para>Eine gültige Länge (<replaceable>length</replaceable>) befindet sich im Bereich von 1 
			bis maximal so vielen Zeichen, die in 32,767 Bytes passen.</para>
          </note>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-chartypes-varchar-de">
        <title><database>VARCHAR</database></title>
        <para><database>VARCHAR</database> ist der Standarddatentyp zum Speichern von Texten
		variabler Länge. Die Zeichen müssen in 32.765 Bytes passen.
		Die Speicherstruktur ist identisch mit der aktuellen Datengröße plus 2 Bytes.</para>
        <para>Alle Zeichen, die von der Client-Anwendung an die Datenbank gesendet werden,
		werden als sinnvoll erachtet, was auch für führende und nachrangige Leerzeichen gilt. Jedoch werden
		angestellte Leerzeichen nicht gespeichert: Sie werden wiederhergestellt, sobald die Daten abgerufen werden.
		Die Zeichenkette wird dann bis zu der gespeicherten Länge mit dem Leerzeichen aufgefüllt.</para>
        <para>Der volle Name dieses Datentyps ist <database>CHARACTER VARYING</database>. Eine weitere 
		Variante dieses Namens wird auch mit <database>CHAR VARYING</database> bezeichnet.</para>
        <formalpara>
          <title>Syntax</title>
          <programlisting>
       VARCHAR (<replaceable>length</replaceable>) [CHARACTER SET &lt;set&gt;] [COLLATE &lt;name&gt;]
          </programlisting>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-chartypes-nchar-de">
        <title><database>NCHAR</database></title>
        <para><database>NCHAR</database> ist ein Festlängen-Datentyp. Der
        <database>ISO8859_1</database>-Zeichensatz ist vordefiniert. In allen anderen Bezügen verhält 
		sich dieser Datentyp identisch zu <database>CHAR</database>.</para>
        <formalpara>
          <title>Syntax</title>
          <programlisting>
       NCHAR (<replaceable>length</replaceable>)
          </programlisting>
          <para>Das Synonym hierfür ist <database>NATIONAL CHAR</database>. Für variable Längen
		  gibt es einen ähnlichen Datentyp: <database>NATIONAL 
          CHARACTER VARYING</database>.</para>
        </formalpara>
      </section>
    </section>
  </section><!-- Character data types -->

  <section id="fblangref25-datatypes-bnrytypes">
    <title>Binärdatentypen</title>
    <para><database>BLOB</database>s (Binary Large Objects) nutzen komplexe Strukturen, um
	Texte und binäre Daten beliebiger Länge zu speichern. Diese Daten sind häufig 
	sehr groß.</para>
    <formalpara>
      <title>Syntax</title>
      <programlisting>
     BLOB [SUB_TYPE &lt;subtype&gt;]
         [SEGMENT SIZE &lt;segment size&gt;]
         [CHARACTER SET &lt;character set&gt;]
      </programlisting>
    </formalpara>
    <formalpara>
      <title>Gekürzte Syntax</title>
      <programlisting>
     BLOB (&lt;segment size&gt;)
     BLOB (&lt;segment size&gt;, &lt;subtype&gt;)
     BLOB (, &lt;subtype&gt;)
      </programlisting>
    </formalpara>
    <formalpara>
      <title>Segmentgröße</title>
      <para>
	  Das Spezifizieren von BLOB-Segmenten ist ein Rückschritt in vergangene Zeiten, als 
	  die Programme zur Verarbeitung von BLOB-Daten noch mit Hilfe des
	  <emphasis>gpre</emphasis>-Pre-Compilers in C (Embedded SQL) geschrieben wurden.
	  Heutzutage ist dies irrelevant. Die Segmentgröße für BLOB-Daten wird auf
	  Client-Seite festgelegt und ist üblicherweise größer als die Größe der Datenseite.</para>
    </formalpara>

    <section id="fblangref25-datatypes-bnrytypes-sub-de">
      <title>BLOB Untertypen</title>
      <para>Der optionale Parameter <database>SUB_TYPE</database> gibt die Art der 
	  zu schreibenden Felddaten an. Firebird unterstützt zwei vordefinierte 
	  Untertypen für die Datenspeicherung:</para>
      <formalpara>
        <title>Untertyp 0: <database>BINARY</database></title>
        <para>Wurde kein Untertyp angegeben, wird von einem unspezifizierten 
		Datentyp ausgegangen und somit als Standard <database>SUB_TYPE 0</database>
		verwendet. Der Alias für diesen Untertyp ist BINARY. Dies ist der Untertyp, der
		bei der Arbeit mit jeglichen Binärdaten Verwendung findet: Bilder, Audio, 
		Textdokumente, PDFs usw.</para>
      </formalpara>
      <formalpara>
        <title>Untertyp 1: <database>TEXT</database></title>
        <para>Untertyp 1 besitzt den Alias <database>TEXT</database>, welcher in Deklarationen und Definitionen 
		verwendet werden kann. Zum Beispiel &nbsp;<function>BLOB SUB_TYPE TEXT</function>.&nbsp; 
		Dies ist ein spezieller Untertyp zum Speichern von Textdaten, die zu lang für die üblichen 
		Zeichenketten sind. Ein Zeichensatz (<database>CHARACTER SET</database>) kann definiert werden,
		sofern dieser vom Standard der Datenbank abweicht. Seit Firebird 2.0 ist die Angabe der 
		<database>COLLATE</database>-Klausel ebenfalls gültig.</para>
      </formalpara>
      <formalpara>
        <title>Benutzerdefinierte Untertypen</title>
        <para>Weiterhin ist es möglich eigene Untertypen zu definieren, 
		wofür der Zahlenbereich von -1 bis -32.768 reserviert ist. Selbstdefinierte Untertypen 
		im positiven Zahlenbereich werden nicht unterstützt, da Firebird diese, von 2 aufwärts, für 
		interne Untertypen in den Metadaten verwendet.</para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-bnrytypes-more-de">
      <title><database>BLOB</database> Specifics</title>
      <formalpara>
        <title>Größe</title>
        <para>Die Maximalgröße eines <database>BLOB</database>-Feldes ist auf 4GB begrenzt, unanhängig vom
		darunterliegenden 32- oder 64-Bit-Server. (Die internen Strukturen im Zusammenhang mit
		<database>BLOB</database>s nutzen ihre eigenen 4-Byte-Zähler.)  Für Seitengrößen (page size) 
		von 4 KB (4096 Bytes) ist die Maximalgröße geringer &mdash; etwas weniger als 2 GB.</para>
      </formalpara>

      <formalpara>
        <title>Operationen und Ausdrücke</title>
        <para>Text-BLOBs beliebiger Länge und jeder Zeichensatz&mdash;inklusive Multi-Byte&mdash;
		können Operanden für praktisch jede Art von Statement oder interne Funktionen sein.
		Die folgenden Operatoren werden vollständig unterstützt:
        <simplelist type="horiz" columns="2">
          <member>=</member>
          <member>(Zuweisung)</member>

          <member>=, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=</member>
          <member>(Vergleich)</member>

          <member>||</member>
          <member>(Verkettung)</member>

          <member>BETWEEN,<database></database></member>
          <member><database>IS [NOT] DISTINCT FROM,</database></member>

          <member><database>IN,</database></member>
          <member><database>ANY|SOME,</database></member>

          <member><database>ALL</database></member>
          <member>&nbsp;</member>
        </simplelist></para>
        <para>Teilunterstützt:
          <itemizedlist>
            <listitem>
              <para>Ein Fehler wird ausgeworfen, wenn das Suchkritierium größer als 32 KB ist:
                <simplelist type="horiz" columns="2">
                  <member><database>STARTING [WITH],</database></member>
                  <member><database>LIKE,</database></member>

                  <member><database>CONTAINING</database></member>
                  <member>&nbsp;</member>
                </simplelist>
              </para>
            </listitem>
            <listitem>
              <para>Aggregations-Klauseln funktionieren nicht auf Basis der eigentlichen Feldwerte,
					jedoch mit den BLOB-IDs. Dementsprechend gibt es ein paar Macken:
              <simplelist type="horiz" columns="2">
                <member><database>SELECT DISTINCT</database></member>
                <member>Gibt fälschlicherweise mehrere NULL-Werte zurück, sofern diese vorhanden sind.</member>

                <member><database>ORDER BY</database></member>
                <member>&mdash;</member>

                <member><database>GROUP BY</database></member>
                <member>Verkettet die gleichen Zeichenketten, wenn sie aufeinanderfolgen, 
				jedoch nicht, wenn sie voneinader entfernt liegen.</member>
              </simplelist>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </formalpara>

      <formalpara>
        <title><database>BLOB</database>-Speicherung</title>
        <itemizedlist>
          <listitem>
            <para>Standardmäßig wird ein regulärer Datensatz für jeden BLOB erstellt und 
			in der Datenseite (data page), die hierfür zugewiesen wurde, gespeichert.
			Passt das gesamte BLOB in diese Seite, spricht man auch von einem 
			<emphasis>Level 0 BLOB</emphasis>. Die Seitenzahl dieses speziellen Datensatzes 
			wird im Tabellendatensatz gespeichert und belegt 8 Bytes.</para>
          </listitem>
          <listitem>
            <para>Passt das BLOB hingegen nicht in die Datenseite, wird der Inhalt 
			auf separate Seiten verteilt, die exklusive hierfür belegt werden (BLOB-Seiten). Die 
			Seitennummern werden in den BLOB-Datensatz geschrieben. Hierbei spricht man von einem
			<emphasis>Level 1 BLOB</emphasis>.</para>
          </listitem>
          <listitem>
            <para>Falls das Array der Seitenzahlen, die die BLOB-Daten enthalten nicht in 
			die Datenseite passen, wird diese Array auf separate BLOB-Seiten verteilt, während 
			die Seitenzahlen dieser Seiten in den BLOB-Datensatz geschrieben werden.
			Hierbei spricht man von einem <emphasis>Level 2 BLOB</emphasis>.</para>
          </listitem>
          <listitem>
            <para>Level größer als 2 werden nicht unterstützt.</para>
          </listitem>
        </itemizedlist>
      </formalpara>

      <formalpara>
        <title>Vergleichen Sie auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-filter"><database>FILTER</database></link>,
        <link linkend="fblangref25-ddl-filter-declare"><database>DECLARE FILTER</database></link></para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-array-de">
      <title><database>ARRAY</database> Type</title>
      <para>Die Unterstützung von Arrays im Firebird DBMS ist eine Abkehr vom traditionellen relationalen
       Modell. Unterstützung von Arrays im DBMS könnte es einfacher machen, Datenverarbeitungsaufgaben
       mit großen Mengen von ähnlichen Daten zu lösen.</para>
      <para>Array werden in Firebird mittels speziellen  <database>BLOB</database>-Typen gespeichert.
      Arrays können ein- und multidimensional sein. Sie dürfen aus beliebigen Datentypen, außer 
	  <database>BLOB</database> und <database>ARRAY</database> bestehen.</para>
      <formalpara>
        <title>Beispiel</title>
        <programlisting>
       CREATE TABLE SAMPLE_ARR (
           ID INTEGER NOT NULL PRIMARY KEY,
           ARR_INT INTEGER [4]);
        </programlisting>
        <para>Dieses Beispiel erstellt eine Tabelle mit einem Array-Feld, welches 4 Ganzzahlenelemente (Integer) enthält.
		Die Indizes werden von 1 bis 4 gezählt.</para>
      </formalpara>

      <section id="fblangref25-datatypes-array-bounds-de">
        <title>Festlegen expliziter Dimensionsgrenzen</title>
        <para>Standardmäßig sind die Indizes 1-basierend&mdash;Zählung begind bei 1. Um die 
		Ober- und Untergrenzen explizit festzulegen, nutzen Sie folgende Syntax:
          <programlisting>
       [&lt;lower&gt;:&lt;upper&gt;]
          </programlisting>
        </para>
      </section>

      <section id="fblangref25-datatypes-array-adddim-de">
        <title>Weitere Dimensionen hinzufügen</title>
        <para>Eine neue Dimension wird nach dem Komma in der Syntax hinzugefügt. In diesem
		Beispiel erstellen wir eine Tabelle mit einem zweidimensionalen Array, mit der unteren 
		Indizegrenze von 0 beginnend:
          <programlisting>
       CREATE TABLE SAMPLE_ARR2 (
           ID INTEGER NOT NULL PRIMARY KEY,
           ARR_INT INTEGER [0:3, 0:3]);
          </programlisting>
        </para>
      </section>

      <para>Das DBMS bietet, im Vergleich mit anderen Sprachen oder Werkzeugen, 
	  nicht viele Möglichkeiten zur Arbeit mit Array-Inhalten. Die Datenbank
	  <filename>employee.fdb</filename>, die im Unterverzeichnis
      <filename>../examples/empbuild</filename> jedes Firebird-Pakets gefunden werden kann,
	  beinhaltet eine beispielhafte Gespeicherte Prozedur (stored procedure), die 
	  einfache Routinen im Umgang mit Arrays zeigt:</para>
      <formalpara>
        <title>PSQL Quelltext für <database>SHOW_LANGS</database>, eine Prozedur zur Arbeit mit Arrays</title>
        <programlisting>
    CREATE OR ALTER PROCEDURE SHOW_LANGS (
        CODE VARCHAR(5),
        GRADE SMALLINT,
        CTY VARCHAR(15))
      RETURNS (LANGUAGES VARCHAR(15))
      AS
        DECLARE VARIABLE I INTEGER;
      BEGIN
         I = 1;
         WHILE (I &lt;= 5) DO
         BEGIN
            SELECT LANGUAGE_REQ[:I]
            FROM JOB
            WHERE (JOB_CODE = :CODE)
              AND (JOB_GRADE = :GRADE)
              AND (JOB_COUNTRY = :CTY)
              AND (LANGUAGE_REQ IS NOT NULL))
            INTO :LANGUAGES;

            IF (LANGUAGES = '') THEN
            /* 'NULL' anstelle von Leerzeichen ausgeben */
              LANGUAGES = 'NULL';
            I = I +1;
            SUSPEND;
         END
      END
        </programlisting>
      </formalpara>
      <para>Reichen die beschriebenen Features für Ihre Aufgaben aus, können Sie darüber nachdenken,
	  Arrays in Ihrem Projekt zu verwenden. Derzeit planen die Firebird-Entwickler keine Verbesserungen im 
	  Bereich Arrays.</para>
    </section>
  </section><!-- Binary data types -->

  <section id="fblangref25-datatypes-special-de">
    <title>Spezialdatentypen</title>
    <para><quote>Spezial</quote>-Datentypen ...</para>

    <section id="fblangref25-datatypes-special-sqlnull-de">
      <title><database>SQL_NULL</database>-Datentyp</title>
      <para>Der Datentyp <database>SQL_NULL</database> besitzt keinen Wert, sondern nur einen Status:
      null (<database>NULL</database>) oder nicht null (<database>NOT NULL</database>). 
	  Er ist nicht verfügbar als Datentyp zur Deklaration von Tabellenfeldern, PSQL-Variablen oder 
	  als Parameterbeschreibung. Dieser Datentyp wurde eingeführt, um untypiserte Parameter in Ausdrücken 
	  mit dem <database>IS NULL</database>-Prädikat zu verwenden.</para>
      <para>Ein Auswertungsproblem tritt auf, wenn optionale Filter verwendet werden, um
	  Abfragen der folgenden Art zu erstellen:
        <literallayout class="monospaced">
       WHERE col1 = :param1 OR :param1 IS NULL
        </literallayout>
      Nach der Verarbeitung auf API-Ebene, sieht die Abfrage folgendermaßen aus:
        <literallayout class="monospaced">
       WHERE col1 = ? OR ? IS NULL
        </literallayout>
      </para>

      <para>Dies ist der Fall, wenn ein Entwickler eine SQL-Abfrage schreibt und 
	   der Auffassung ist, dass sich
      <function>:param1</function> wie eine <emphasis>Variable</emphasis> verhält, sodass er 
	  diese auf zwei Arten verwenden kann. Jedoch erhält sich die Abfrage auf der API-Ebene 
	  zwei unabhängige <emphasis>Parameter</emphasis>. Der Server kann den Typen des zweiten 
	  Parameters nicht ermitteln, da dieser in Verbindung mit <database>IS NULL</database> 
	  steht.</para>

      <para>Der Datentyp <database>SQL_NULL</database> löst dieses Problem. Wannimmer die Datenbank auf das 
	  <function>'? IS NULL' </function>-Prädikat in einer Abfrage stößt, weist sie dem Parameter den Typ 
	  <database>SQL_NULL</database> zu, was wiederum dazu führt, dass dieser Parameter nur auf <quote>Nullbarkeit</quote>
	  geprüft werden muss und der Datentyp bzw. der Wert nicht wichtig ist.</para>
      <para>Das folgende Beispiel demonstriert die praktische Verwendung. Es verwendet 2 benannte Parameter
	  &mdash;sagen wir,
      <function>:size</function> und <function>:colour</function>&mdash;welche, im Beispiel,
      zwei Werte vom Bildschirmtext oder Drop-Down-Listen erhalten. Jeder dieser Parameter korrospondiert
	  mit zwei Parametern in der Abfrage.
        <programlisting>
       SELECT
         SH.SIZE, SH.COLOUR, SH.PRICE
       FROM SHIRTS SH
       WHERE (SH.SIZE = ? OR ? IS NULL)
         AND (SH.COLOUR = ? OR ? IS NULL)
        </programlisting>
       </para>
       <para>Um zu verstehen was hier passiert, muss der Leser mit der Firebird-API sowie der Übergabe
	   von Parametern in der XSQLVAR-Struktur vertraut sein&mdash;was unter der Haube passiert, ist 
	   nicht von Belang, sofern keine Treiber oder Anwendungen geschrieben werden, die die <quote>nackte</quote>
	   API verwenden.</para>

       <para>Die Anwendung übergibt die parameteresierte Abfrage an den Server in der üblichen ?-Form. 
	   Paare <quote>identischer</quote> Parameter können nicht in einem zusammengeführt werden, somit 
	   werden für zwei optionale Filter, beispielsweise, 4 Parameter benötigt: einer für jede ? in unserem 
	   Beispiel.</para>
       <para>Nach dem Aufruf von <function>isc_dsql_describe_bind()</function>, wird der SQLTYPE des zweiten und
	   vierten Parameters auf SQL_NULL gesetzt. Firebird hat keine Kenntnis ihrer speziellen Verbindung zu dem ersten bzw. 
	   dritten Parameter: hierfür ist allein die Anwendung verantwortlich.</para>
       <para>Sobald die Werte für Größe (size) und Farbe (colour) festgelegt wurden (oder auch nicht), 
	   und die Abfrage ausgeführt wurde, wird jedes Paar der XSQLVARs folgendermaßen ausgefüllt:
         <variablelist>
           <varlistentry>
             <term>Benutzer hat einen Wert angegeben</term>
             <listitem>
               <para>Erster Parameter (vergleiche Werte): Lege *sqldata auf den übergebenen Wert fest und *sqlind auf 0
               (für NOT NULL)</para>
               <para>Zweiter Parameter (teste auf NULL): Lege *sqldata auf null fest (null-Zeiger, nicht SQL
               NULL) und *sqlind auf 0 (für NOT NULL)</para>
             </listitem>
           </varlistentry>
           <varlistentry>
             <term>Benutzer hat das Feld leer gelassen</term>
             <listitem>
               <para>Beide Parameter: Setze sqldata auf null (null-Zeiger, nicht SQL NULL) und *sqlind
               auf -1 (repräsentiert NULL)</para>
             </listitem>
           </varlistentry>
         </variablelist>
       In anderen Worten: Der Parameter zum Vergleich des Wertes wird wie üblich gesetzt. Der SQL_NULL-Parameter 
	   wird genauso verwendet, mit dem Unterschied, dass sqldata über die gesamte Zeit hinweg null bleibt.</para>
    </section>
  </section><!-- Special data types -->

  <section id="fblangref25-datatypes-conversion-de">
    <title>Datentyp-Konvertierungen</title>
    <para>Wenn Sie einen Ausdruck erstellen oder eine Operation spezifizieren,
	sollte das Ziel sein, kompatible Datentypen als Operanden zu verwenden.
	Wenn die Notwendigkeit besteht, verschiedene Datentypen zu verwenden, müssen Sie einen
	Weg finden, diese inkompatiblen Typen vor der eigentlichen Operation zu konvertieren.
	Wenn Sie mit Dialekt 1 arbeiten, kann dies zum Problem werden.</para>

    <section id="fblangref25-datatypes-convert-explicit-de">
      <title>Explizite Datentyp-Konvertierung</title>
      <para>Die <database>CAST</database>-Funktion ermöglicht die explizite Konvertierung 
	  zwischen diversen Datentypen.</para>
      <formalpara>
        <title>Syntax</title>
        <programlisting>
       CAST ( { &lt;value&gt; | NULL } AS &lt;data_type&gt;)

       &lt;data_type&gt; ::= sql_datatype |
                        [TYPE OF] <replaceable>domain</replaceable> |
                        TYPE OF COLUMN relname.colname
        </programlisting>
      </formalpara>
      <section id="fblangref25-datatypes-convert-domain-de">
        <title>Casting zu einer Domain</title>
        <para>Beim Ausführen eines Cast zu einer Domain, werden alle Constraints berücksichtigt, die 
		hierfür deklariert wurden, z.B. NOT NULL- oder CHECK-Constraints. Wenn der Wert (&lt;value&gt;) 
		diese Prüfung nicht besteht, schlägt der Cast fehl.</para>
        <para>Wird <database>TYPE OF</database> zusätzlich angegeben &mdash;Umwandlung auf den Basistyp&mdash;,
		werden alle Domain-Contraints während des Cast ignoriert. Wird 
        <database>TYPE OF</database> mit einem Zeichentyp (<database>CHAR/VARCHAR</database>) verwendet,
        werden der Zeichensatz und die Collation beibehalten.</para>
      </section>
      <section id="fblangref25-datatypes-convert-typeof-de">
        <title>Casting zu <database>TYPE OF COLUMN</database></title>
        <para>Werden Operanden auf den Datentyp einer Spalte konvertiert, 
		kann die angegebene Spalte aus einer Tabelle oder View stammen.</para>
        <para>Nur der Typ der Spalte selbst wird verwendet. Für Zeichentypen wird der Zeichensatz
		bei der Konvertierung inkludiert, jedoch nicht die Collation. Die Constraints und 
		Vorgabewerte der Quellspalte werden nicht angewandt.</para>
        <formalpara>
          <title>Beispiel</title>
          <programlisting>
       CREATE TABLE TTT (
           S VARCHAR (40)
           CHARACTER SET UTF8 COLLATE UNICODE_CI_AI);
       COMMIT;

       SELECT
         CAST ('I have many friends' AS TYPE OF COLUMN TTT.S)
       FROM RDB$DATABASE;
          </programlisting>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-convert-conversions-de">
        <title>Mögliche konvertierungen für die <database>CAST</database>-Funktion</title>
        <table id="fblangref25-dtyp-tbl-conversions-de">
        <?dbfo keep-together='auto'?>
          <title>Konvertierungen mit CAST</title>
          <tgroup cols="2">
            <colspec colname="colFrom" colwidth="1*"></colspec>
            <colspec colname="colTo" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">von Datentyp</entry>
                <entry align="left">zu Datentyp</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">Numerische Typen</entry>
                <entry align="left">Numerische Typen, [VAR]CHAR, BLOB</entry>
              </row>

              <row valign="middle">
                <entry align="center">[VAR]CHAR</entry>
                <entry align="left">[VAR]CHAR, BLOB, Numerische Typen, DATE, TIME, TIMESTAMP</entry>
              </row>

              <row valign="middle">
                <entry align="center">BLOB</entry>
                <entry align="left">[VAR]CHAR, BLOB, Numerische Typen, DATE, TIME, TIMESTAMP</entry>
              </row>

              <row valign="middle">
                <entry align="center">DATE, TIME</entry>
                <entry align="left">[VAR]CHAR, BLOB, TIMESTAMP</entry>
              </row>

              <row valign="middle">
                <entry align="center">TIMESTAMP</entry>
                <entry align="left">[VAR]CHAR, BLOB, DATE, TIME</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <important>
          <para>Beachten Sie, dass Informationsteile möglicherweise verloren gehen. Zum Beispiel geht der 
		  Zeitteil bei der Konvertierung eines TIMESTAMP zu einem DATE verloren.</para>
        </important>
      </section>
      <section id="fblangref25-datatypes-convert-literalformats-de">
        <title>Literalformate</title>
        <para>Für den Cast von String-Datentypen zu DATE-, TIME- oder TIMESTAMP-Datentypen, müssen 
		Sie eines der vordefinierten Datum- bzw. Zeit-Literale (vgl. Tabelle 3.7) oder ein gültiges 
		<emphasis>Datum-Zeit-Literal</emphasis>-Format verwenden:
          <programlisting>
       &lt;datetime_literal> ::= {
         [YYYY&lt;p&gt;]MM&lt;p&gt;DD[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]] |
         MM&lt;p&gt;DD[&lt;p&gt;YYYY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         DD&lt;p&gt;MM[&lt;p&gt;YYYY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         MM&lt;p&gt;DD[&lt;p&gt;YY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         DD&lt;p&gt;MM[&lt;p&gt;YY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         NOW |
         TODAY |
         TOMORROW |
         YESTERDAY
       }

       &lt;date_literal&gt; ::= {
         [YYYY&lt;p&gt;]MM&lt;p&gt;DD |
         MM&lt;p&gt;DD[&lt;p&gt;YYYY] |
         DD&lt;p&gt;MM[&lt;p&gt;YYYY] |
         MM&lt;p&gt;DD[&lt;p&gt;YY] |
         DD&lt;p&gt;MM[&lt;p&gt;YY] |
         TODAY |
         TOMORROW |
         YESTERDAY
       }

       &lt;time_literal&gt; := HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]

       &lt;p&gt; ::= whitespace | . | : | , | - | /

          </programlisting>
        </para>
        <table id="fblangref25-dtyp-tbl-keydesc">
        <?dbfo keep-together='auto'?>
          <title>Formatierungsargumente für Datum- und Zeit-LiteraleDate and Time Literal</title>
          <tgroup cols="2">
            <colspec colname="colArg" colwidth="2*"></colspec>
            <colspec colname="colDesc" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Argument</entry>
                <entry align="center">Beschreibung</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">datetime_literal</entry>
                <entry align="left">Datum- und Zeit-Literal</entry>
              </row>
              <row valign="middle">
                <entry align="center">time_literal</entry>
                <entry align="left">Zeit-Literal</entry>
              </row>
              <row valign="middle">
                <entry align="center">date_literal</entry>
                <entry align="left">Datum-Literal</entry>
              </row>
              <row valign="middle">
                <entry align="center">YYYY</entry>
                <entry align="left">vierstelliges Jahr</entry>
              </row>
              <row valign="middle">
                <entry align="center">YY</entry>
                <entry align="left">zweistelliges Jahr</entry>
              </row>
              <row valign="middle">
                <entry align="center">MM</entry>
                <entry align="left">Monat. Dieser kann aus 1 oder 2 Stellen bestehen (1-12 oder 01-12). 
				Sie können auch die mit drei Buchstaben abgekürzte Form oder den vollen Monatsnamen in 
				englisch angeben. Dies berücksichtigt keine Groß- und Kleinschreibung.
				</entry>
              </row>
              <row valign="middle">
                <entry align="center">DD</entry>
                <entry align="left">Tag. Kann aus 1 oder 2 Stellen bestehen (1-31 oder 01-31)</entry>
              </row>
              <row valign="middle">
                <entry align="center">HH</entry>
                <entry align="left">Stunde. Kann aus 1 oder 2 Stellen bestehen (0-23 oder 00-23)</entry>
              </row>
              <row valign="middle">
                <entry align="center">mm</entry>
                <entry align="left">Minute. Kann aus 1 oder 2 Stellen bestehen (0-59 oder 00-59)</entry>
              </row>
              <row valign="middle">
                <entry align="center">SS</entry>
                <entry align="left">Sekunde. Kann aus 1 oder 2 Stellen bestehen (0-59 oder 00-59)</entry>
              </row>
              <row valign="middle">
                <entry align="center">NNNN</entry>
                <entry align="left">Zehntausendstel Sekunde. Kann aus 1 bis 4 Stellen bestehen (0-9999)</entry>
              </row>
              <row valign="middle">
                <entry align="center">p</entry>
                <entry align="left">Separator, jedes gültige Zeichen. Führende und nachgestellte Leerzeichen werden ignoriert.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id="fblangref25-dtyp-tbl-predliterals-de">
        <?dbfo keep-together='auto'?>
          <title>Literale mit vordefinierten Datums- und Zeitwerten</title>
          <tgroup cols="4">
            <colspec colname="colLit" colwidth="2*"></colspec>
            <colspec colname="colValue" colwidth="3*"></colspec>
            <colspec colname="colDlct01" colwidth="3*"></colspec>
            <colspec colname="colDlct03" colwidth="2*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center" morerows="1">Literal</entry>
                <entry align="center" morerows="1">Beschreibung</entry>
                <entry align="center" nameend="colDlct03" namest="ColDlct01">Datentyp</entry>
              </row>
              <row valign="middle">
                <entry align="center">Dialekt 1</entry>
                <entry align="center">Dialekt 3</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">'NOW'</entry>
                <entry align="center">Aktuelles Datum und Zeit</entry>
                <entry align="center">DATE</entry>
                <entry align="center">TIMESTAMP</entry>
              </row>
              <row valign="middle">
                <entry align="center">'TODAY'</entry>
                <entry align="center">Aktuelle Datum</entry>
                <entry align="center">DATE mit Nullzeit</entry>
                <entry align="center">DATE</entry>
              </row>
              <row valign="middle">
                <entry align="center">'TOMORROW'</entry>
                <entry align="center">Heutiges Datum + 1 (Tag)</entry>
                <entry align="center">DATE mit Nullzeit</entry>
                <entry align="center">DATE</entry>
              </row>
              <row valign="middle">
                <entry align="center">'YESTERDAY'</entry>
                <entry align="center">Heutiges Datum - 1 (Tag)</entry>
                <entry align="center">DATE mit Nullzeit</entry>
                <entry align="center">DATE</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <important>
          <para>Die Nutzung des Jahres in vierstelliger Schreibweise
          &mdash;<database>YYYY</database>&mdash;wird dringend empfohlen, um 
		  Verwirrungen bei der Datumsberechnung und bei Aggregationen zu vermeiden.</para>
        </important>
        <formalpara>
          <title>Beispiele für die Interpretation von Datum-Literalen</title>
          <programlisting>
       select
         cast('04.12.2014' as date) as d1, -- DD.MM.YYYY
         cast('04 12 2014' as date) as d2, -- MM DD YYYY
         cast('4-12-2014' as date) as d3,  -- MM-DD-YYYY
         cast('04/12/2014' as date) as d4, -- MM/DD/YYYY
         cast('04,12,2014' as date) as d5, -- MM,DD,YYYY
         cast('04.12.14' as date) as d6,   -- DD.MM.YY
         -- DD.MM with current year
         cast('04.12' as date) as d7,
         -- MM/DD with current year
         cast('04/12' as date) as d8,
         cast('2014/12/04' as date) as d9, -- YYYY/MM/DD
         cast('2014 12 04' as date) as d10, -- YYYY MM DD
         cast('2014.12.04' as date) as d11, -- YYYY.MM.DD
         cast('2014-12-04' as date) as d12, -- YYYY-MM-DD
         cast('4 Jan 2014' as date) as d13, -- DD MM YYYY
         cast('2014 Jan 4' as date) as dt14, -- YYYY MM DD
         cast('Jan 4, 2014' as date) as dt15, -- MM DD, YYYY
         cast('11:37' as time) as t1, -- HH:mm
         cast('11:37:12' as time) as t2, -- HH:mm:ss
         cast('11:31:12.1234' as time) as t3, -- HH:mm:ss.nnnn
         cast('11.37.12' as time) as t4, -- HH.mm.ss
         -- DD.MM.YYYY HH:mm
         cast('04.12.2014 11:37' as timestamp) as dt1,
         -- MM/DD/YYYY HH:mm:ss
         cast('04/12/2014 11:37:12' as timestamp) as dt2,
         -- DD.MM.YYYY HH:mm:ss.nnnn
         cast('04.12.2014 11:31:12.1234' as timestamp) as dt3,
         -- MM/DD/YYYY HH.mm.ss
         cast('04/12/2014 11.37.12' as timestamp) as dt4
       from rdb$database
          </programlisting>
        </formalpara>
      </section>
      <section id="fblangref25-datatypes-convert-shortcasts-de">
        <title>Kurzschreibweisen für Casts von Datums- und Zeit-Datentypen</title>
        <para>Firebird erlaubt die Verwendung von Kurzschreibweisen (<quote>C-Stil</quote>)
		für die Konvertierung von Strings zu <database>DATE</database>-, <database>TIME</database>-
        und <database>TIMESTAMP</database>-Typen.</para>
        <formalpara>
          <title>Syntax</title>
          <literallayout class="monospaced">
       data_type 'date_literal_string'
          </literallayout>
        </formalpara>
        <formalpara>
          <title>Beispel</title>
          <programlisting>
-- 1
       UPDATE PEOPLE
       SET AGECAT = 'SENIOR'
       WHERE BIRTHDATE &lt; DATE '1-Jan-1943';
-- 2
       INSERT INTO APPOINTMENTS
       (EMPLOYEE_ID, CLIENT_ID, APP_DATE, APP_TIME)
       VALUES (973, 8804, DATE 'today' + 2, TIME '16:00');
-- 3
       NEW.LASTMOD = TIMESTAMP 'now';
          </programlisting>
          <note>
            <para>Diese Kurzschreibweisen werden direkt während des Parsens ausgewertet,
			so als ob das Statement bereits für die Ausführung vorbereitet wäre. Dadurch
			hat beispielsweise <function> timestamp 'now' </function> immer den gleichen Wert,
			egal wie viel Zeit verstrichen ist.</para>
            <para>Benötigen Sie hingegen eine Möglichkeit, die die Zeit bei jeder Ausführung neu 
			ermittelt, müssen Sie die vollständige CAST-Syntax verwenden. 
			Eine beispielhafte Verwendung eines solchen Ausdrucks in einem Trigger:
              <literallayout class="monospaced">
       NEW.CHANGE_DATE = CAST('now' AS TIMESTAMP);
              </literallayout>
            </para>
          </note>
        </formalpara>
      </section>
    </section><!-- Explicit casts -->

    <section id="fblangref25-datatypes-convert-implicit">
      <title>Implizite Datentyp-Konvertierung</title>
      <para>Implizite Datenkonvertierung ist in Dialekt 3 nicht möglich &mdash; die 
	  <database>CAST</database>-Funktion wird fast immer benötigt, um Datentyp-Probleme 
	  zu vermeiden.</para>

      <para>In Dialekt 1 wird in vielen Fällen ein Datentyp implizit in einen anderen gewandelt, ohne 
	  die CAST-Funktion verwenden zu müssen. Beispielsweise ist die folgende Klausel in einem
	  <database>SELECT</database>-Statement in Dialekt 1 gültig:
        <programlisting>
       WHERE DOC_DATE &lt; '31.08.2014'
        </programlisting>
      und der String-Typ wird implizit in den Datums-Datentyp gewandelt.</para>
      <para>In Dialekt 1 ist das Vermischen von Ganzzahlendaten und numerischen Zeichenketten 
	  grundsätzlich möglich, da der Parser versuchen wird, die Zeichenketten implizit zu konvertieren.
	  Beispielsweise wird 
        <programlisting>
       2 + '1'
        </programlisting>
       korrekt ausgeführt.</para>
       <para>In Dialekt 3 wird dieser Ausdruck einen Fehler ausgeben. Somit sind Sie gezwungen, einen
       <database>CAST</database>-Ausdruck zu erstellen:
        <programlisting>
       2 + CAST('1' AS SMALLINT)
        </programlisting>
      Die Ausnahme bildet hier die <emphasis>String-Verkettung</emphasis>.
      </para>
      <section id="fblangref25-datatypes-convert-implicit-concat-de">
        <title>Implizite Konvertierung während der String-Verkettung</title>
        <para>Werden mehrere Elemente miteinander verkettet, werden alle nicht-Zeichen-Daten
		unter der Hand zu einer Zeichenkette konvertiert, sofern möglich.</para>
        <formalpara><title>Beispiel</title>
          <programlisting>
       SELECT 30||' days hath September, April, June and November' CONCAT$
         FROM RDB$DATABASE

       CONCAT$
       ------------------------------------------------
       30 days hath September, April, June and November
          </programlisting>
        </formalpara>
      </section> <!-- ... during concatenation -->
    </section> <!-- Implicit casts -->
  </section><!-- Conversion of data types -->

  <section id="fblangref25-datatypes-custom-de">
    <title>Benutzerdefinierte Datentypen&mdash;Domains</title>
    <para>In Firebird wurde das Konzept <quote>benutzerdefinierter Datentypen</quote> in Form von
    <emphasis>Domain</emphasis>s implementiert. Beim Erstellen einer Domain wird nicht wirklich ein neuer Datentyp
	generiert. Eine Domain kapselt vielmehr einen bestehenden Datentyp mit diversen Attributen und 
	macht diese <quote>Kaspel</quote> für verschiedene Anwendungsbereiche in der Datenbank verfügbar.
	Wenn mehrere Tabellen Spalten benötigen, die die gleichen oder nahezu gleichen Eigenschaften 
	haben sollen, macht die Verwendung von Domains Sinn.</para>
	<para>Die Verwendung von Domains ist nicht auf die Spaltendefinition in Tabellen oder Views begrenzt. 
	Sie können auch als Übergabe- und Rückgabeparameter sowie Variablen in PSQL-Code verwendet werden.</para>

    <section id="fblangref25-datatypes-domainattribs-de">
      <title>Domain-Eigenschaften</title>
      <para>Eine Domain-Definition beinhaltet benötigte sowie optionale Eigenschaften. Der <emphasis>Datentyp</emphasis>
	  ist ein benötigtes Attribut. Optionale Eigenschaften sind:
        <itemizedlist>
          <listitem>ein Vorgabewert</listitem>
          <listitem>erlauben oder verbieten von NULL</listitem>
          <listitem>CHECK Constraints</listitem>
          <listitem>Zeichensatz (für Textdatentypen und Text-BLOB-Felder)</listitem>
          <listitem>Collation (für Textdatentypen)</listitem>

        </itemizedlist>
      </para>
      <formalpara>
	<title>Beispielhafte Domain-Definition</title>
	<programlisting>
       CREATE DOMAIN BOOL3 AS SMALLINT
         CHECK (VALUE IS NULL OR VALUE IN (0, 1));
	</programlisting>
      </formalpara>

      <formalpara>
        <title>vgl. auch</title>
        <para><link linkend="fblangref25-datatypes-convert-typeof-de">Explicite Datentyp-Konvertierung</link>
        für die Beschreibung der Unterschiede im Mechanismus der Datenkonvertierung, wenn Domains für
        die <database>TYPE OF</database> und <database>TYPE OF COLUMN</database>-Modifizierer verwendet werden.</para>
      </formalpara>
    </section>
    <section id="fblangref25-datatypes-domainoverride-de">
      <title>Domain-Überschreibung</title>
      <para>Während des Festlegens der Domain-Definitionen, ist es möglich einige geerbte Eigenschaften zu überschreiben.
	  Tabelle 3.9 fasst die Regeln hierfür zusammen.</para>

      <table id="fblangref25-dtyp-tbl-domoverride-de">
      <?dbfo keep-together='auto'?>
        <title>Regeln zum Überschreiben von Domain-Eigenschaften in Spaltendefinitionen</title>
        <tgroup cols="3">
          <colspec colname="colAtt" colwidth="2*"></colspec>
          <colspec colname="colYesNo" colwidth="1*"></colspec>
          <colspec colname="colComment" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Eigenschaft</entry>
              <entry align="center">Überschreiben?</entry>
              <entry align="center">Hinweis</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">Datentyp</entry>
              <entry align="center">Nein</entry>
              <entry align="left"> </entry>
            </row>
            <row valign="middle">
              <entry align="center">Vorgabewert</entry>
              <entry align="center">Ja</entry>
              <entry align="left"> </entry>
            </row>
            <row valign="middle">
              <entry align="center">Zeichensatz</entry>
              <entry align="center">Ja</entry>
              <entry align="left">Dies kann auch verwendet werden, um die Vorgabewerte der Datenbank für die Spalte wiederherzustellen.</entry>
            </row>
            <row valign="middle">
              <entry align="center">Sortiermethode</entry>
              <entry align="center">Ja</entry>
              <entry align="left"> </entry>
            </row>
            <row valign="middle">
              <entry align="center">CHECK-Constraints</entry>
              <entry align="center">Ja</entry>
              <entry align="left">Zum Hinzufügen von neuen Kriterien, können Sie die korrospondierenden 
              <database>CHECK</database>-Klauseln der CREATE- und ALTER-Anweisungen auf Tabellenebene verwenden.</entry>
            </row>
            <row valign="middle">
              <entry align="center">NOT NULL</entry>
              <entry align="center">Nein</entry>
              <entry align="left">Häufig ist es besser Domains nullbar in ihren Definitionen zu lassen 
			  und erst beim Erstellen der Spaltedefinition über NOT NULL zu entscheiden.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="fblangref25-datatypes-domaincreate-de">
      <title>Domains erstellen und verwalten</title>
      <para>Eine Domain wird mit der DDL-Anweisung <database>CREATE DOMAIN</database> erstellt.</para>
      <formalpara><title>Kurz-Syntax</title>
        <programlisting>
       CREATE DOMAIN &lt;name&gt; [AS] &lt;type&gt;
       [DEFAULT {&lt;const&gt; | &lt;literal&gt; | NULL | &lt;context_var&gt;}]
       [NOT NULL] [CHECK (&lt;condition&gt;)]
       [COLLATE collation];
        </programlisting>
      </formalpara>
      <formalpara><title>vgl. auch</title>
          <para><link linkend="fblangref25-ddl-domn-create"><database>CREATE DOMAIN</database></link>
          im Abschnitt Data Definition Language (DDL).</para>
      </formalpara>

      <section id="fblangref25-datatypes-domainalter-de">
        <title>Ändern einer Domain</title>
        <para>Zum Ändern der Domain-Eigenschaften, nutzen Sie die Anweisung <database>ALTER DOMAIN</database>.
        Mit dieser Anweisung können Sie
          <itemizedlist>
            <listitem>die Domain umbenennen</listitem>
            <listitem>den Datentyp ändern</listitem>
            <listitem>den derzeitigen Vorgabewert ändern</listitem>
            <listitem>einen neuen Vorgabewert festlegen</listitem>
            <listitem>einen vorhandenen <database>CHECK</database>-Constraint löschen</listitem>
            <listitem>einen neuen <database>CHECK</database>-Constraint hinzufügen</listitem>
          </itemizedlist>
        </para>
        <formalpara>
          <title>Kurz-Syntax</title>
          <programlisting>
       ALTER DOMAIN <replaceable>name</replaceable>
       [{TO <replaceable>new_name</replaceable>}]
       [{SET DEFAULT {<replaceable>literal</replaceable> | NULL | &lt;context_var&gt;} |
        DROP DEFAULT}]
       [{ADD [CONSTRAINT] CHECK (&lt;dom_condition&gt;) |
         DROP CONSTRAINT}]
       [{TYPE &lt;datatype&gt;}];
          </programlisting>
        </formalpara>
        <para>Wenn Sie vorhaben eine Domain zu ändern, müssen Sie die vorhandenen Abhängigkeiten
		berücksichtigen: wurden Tabellenspalten, Variablen, Übergabe- und/oder Rückgabeparameter
		mit dieser Domain in PSQL deklariert? Wenn Sie Domains voreilig ändern, ohne diese 
		eingehend zu überprüfen, kann es passieren, dass Ihr Code anschließend nicht mehr 
		läuft!</para>
        <important>
          <para>Wenn Sie Datentypen einer Domain ändern, dürfen Sie keine Konvertierungen durchführen,
		  die zu Datenverlust führen können. Zum Beispiel sollten Sie vorab prüfen, ob das Konvertieren 
		  von <database>VARCHAR</database> zu <database>INTEGER</database> für alle Daten erfolgreich
		  durchgeführt werden kann.</para>
        </important>
        <formalpara><title>vgl. auch</title>
          <para><link linkend="fblangref25-ddl-domn-alter-de"><database>ALTER DOMAIN</database></link>
          im Abschnitt Data Definition Language (DDL).</para>
        </formalpara>
      </section>
      <section id="fblangref25-datatypes-domaindrop-de">
        <title>Löschen einer Domain</title>
        <para>Die Anweisung <database>DROP DOMAIN</database> löscht eine Domain aus der 
		Datenbank, sofern diese nicht von anderen Datenbankobjekten verwendet wird.</para>
        <formalpara>
          <title>Syntax</title>
          <programlisting>
       DROP DOMAIN <replaceable>name</replaceable>
          </programlisting>
        </formalpara>
        <important>
          <para>Jeder mit der Datenbank verbundene Benutzer kann eine Domain löschen.</para>
        </important>
        <formalpara><title>Beispiel</title>
          <programlisting>
       DROP DOMAIN Test_Domain
          </programlisting>
        </formalpara>
        <formalpara><title>vgl. auch</title>
          <para><link linkend="fblangref25-ddl-domn-drop"><database>DROP DOMAIN</database></link>
          im Abschnitt Data Definition Language (DDL).</para>
        </formalpara>
      </section>
    </section>
  </section><!-- Custom data types -->

  </chapter>
