<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-dml-de">
  <title>Statements der Data Manipulation Language (DML)</title>

  <!-- Review status notice -->
  <important>
    <title>ÜBERPRÜFUNGSSTATUS</title>
    <para>Alle Abschnitte von diesem Punkt bis zum Ende des Kapitels warten auf 
        technische und redaktionelle Überprüfung.</para>
  </important>

  <para>DML &mdash; Datenbearbeitungssprache &mdash; ist die Teilmenge von SQL, die von 
      Anwendungen und prozeduralen Modulen zum Extrahieren und Ändern von Daten verwendet wird. 
      Die Extraktion zum Lesen sowohl roher als auch manipulierter Daten wird mit der Anweisung 
    <database>SELECT</database> erreicht. <database>INSERT</database> dient zum Hinzufügen neuer 
    Daten und <database>DELETE</database> dient zum Löschen von Daten, die nicht mehr benötigt 
    werden. <database>UPDATE</database>, <database>MERGE</database> und <database>UPDATE OR INSERT</database> 
    ändern alle Daten auf verschiedene Arten.</para>
<!-- ========================================================================================
                   S E L E C T
     ======================================================================================== -->

  <section id="fblangref25-dml-select-de">
    <title><database>SELECT</database></title>
    <formalpara>
      <title>Verwendet für</title>
      <para>Retrieving data</para>
    </formalpara>
    <formalpara>
      <title>Verfügbar in</title>
      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Globale Syntax</title>

      <para><blockquote>
          <programlisting>SELECT
[WITH [RECURSIVE] &lt;cte&gt; [, &lt;cte&gt; ...]]
SELECT
  [FIRST m] [SKIP n]
  [DISTINCT | ALL] &lt;columns&gt;
FROM
  source [[AS] alias]
  [&lt;joins&gt;]
[WHERE &lt;condition&gt;]
[GROUP BY &lt;grouping-list&gt;
[HAVING &lt;aggregate-condition&gt;]]
[PLAN &lt;plan-expr&gt;]
[UNION [DISTINCT | ALL] &lt;other-select&gt;]
[ORDER BY &lt;ordering-list&gt;]
[ROWS m [TO n]]
[FOR UPDATE [OF &lt;columns&gt;]]
[WITH LOCK]
[INTO &lt;variables&gt;]

&lt;variables&gt; ::= [:]varname [, [:]varname ...]</programlisting>
        </blockquote></para>
    </formalpara>
    <bridgehead id="select" renderas="sect4">Beschreibung</bridgehead>
    <para>Die Anweisung <database>SELECT</database> ruft Daten aus der 
    Datenbank ab und übergibt sie an die Anwendung oder die umschließende 
    SQL-Anweisung. Daten werden in null oder mehr <firstterm>Zeilen</firstterm> 
    zurückgegeben, die jeweils eine oder mehrere <firstterm>Spalten</firstterm> 
    oder <firstterm>Felder</firstterm> enthalten. Die Summe der zurückgegebenen 
    Zeilen ist die <firstterm>Ergebnismenge</firstterm> der Anweisung.</para>

    <para>Die einzigen obligatorischen Teile der Anweisung 
        <database>SELECT</database> sind:</para>

    <itemizedlist>
      <listitem>
        <para>Das Schlüsselwort SELECT gefolgt von einer Spaltenliste. Dieser 
            Teil spezifiziert <emphasis>was</emphasis> Sie abrufen möchten.</para>
      </listitem>

      <listitem>
        <para>Das Schlüsselwort <database>FROM</database> gefolgt von einem 
        auswählbaren Objekt. Dies sagt der Engine <emphasis>von wo</emphasis> Sie 
        Daten erhalten möchten.</para>
      </listitem>
    </itemizedlist>

    <para>In der einfachsten Form ruft <database>SELECT</database> eine Anzahl 
    von Spalten aus einer einzelnen Tabelle oder Sicht ab, wie folgt:</para>

    <blockquote>
      <programlisting>select id, name, address
  from contacts</programlisting>
    </blockquote>

    <para>Oder, um alle Spalten abzurufen:</para>

    <blockquote>
      <programlisting>select * from sales</programlisting>
    </blockquote>

    <para>In der Praxis werden die abgerufenen Zeilen oft durch eine Klausel <database>WHERE</database> 
    begrenzt. Die Ergebnismenge kann nach einer <database>ORDER BY</database>-Klausel sortiert werden. 
    <database>FIRST</database>, <database>SKIP</database> oder <database>ROWS</database> können 
    die Anzahl der Ausgabezeilen eingrenzen. Die Spaltenliste kann alle Arten von Ausdrücken anstelle von nur 
    Spaltennamen enthalten, und die Quelle muss keine Tabelle oder Sicht sein; sie kann auch eine 
    abgeleitete Tabelle, ein allgemeiner Tabellenausdruck (CTE) oder eine auswählbare gespeicherte 
    Prozedur (SP) sein. Mehrere Quellen können in einer <database>JOIN</database> kombiniert 
    werden, und mehrere Ergebnismengen können in einer <database>UNION</database> kombiniert 
    werden.</para>

    <para>In den folgenden Abschnitten werden die verfügbaren <database>SELECT</database> Unterklauseln 
    und ihre Verwendung im Detail erläutert.</para>

    <section id="fblangref25-dml-select-first-skip-de">
      <title><database>FIRST</database>, <database>SKIP</database></title>
      <formalpara>
        <title>Verwendet für</title>
        <para>&nbsp;Abrufen eines Teiles von Zeilen aus einer geordneten Menge</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SELECT
   [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
   FROM ...
   ...

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  <replaceable>integer-literal</replaceable> | <replaceable>query-parameter</replaceable> | (<replaceable>integer-expression</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <table id="fblangref25-dml-tbl-firstskip-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente für die FIRST- und SKIP-Klauseln</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">integer literal</entry>
              <entry align="left">Ganzzahliges Literal</entry>
            </row>
            <row valign="middle">
              <entry align="center">query parameter</entry>
              <entry align="left">Abfrageparameter-Platzhalter. ? in DSQL und :paramname in PSQL</entry>
            </row>
            <row valign="middle">
              <entry align="center">integer-expression</entry>
              <entry align="left">Ausdruck, der einen Ganzzahlwert zurückgibt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

     <note>
       <title>FIRST und SKIP sind keine Standardsyntax</title>
        <para><database>FIRST</database> und <database>SKIP</database> sind
        Firebird-spezifische, nicht-SQL-konforme Schlüsselwörter. Es wird dringend empfohlen
        die <link linkend="fblangref25-dml-select-rows-de"><database>ROWS</database></link>-Syntax
        zu verwenden.</para>
      </note>

      <bridgehead id="firstskip" renderas="sect4">Beschreibung</bridgehead>
      <para><database>FIRST</database> begrenz die Ausgabe der Abfrage auf die ersten
      <replaceable>m</replaceable> Zeilen. <database>SKIP</database> übergeht die ersten 
      <replaceable>n</replaceable> Zeilen, bevor mit der Ausgabe begonnen wird.</para>

      <para><database>FIRST</database> und <database>SKIP</database> sind optional.
        Bei Verwendung in <quote><database>FIRST</database> <replaceable>m</replaceable> 
        <database>SKIP</database> <replaceable>n</replaceable></quote> werden die
        obersten <replaceable>n</replaceable> Zeilen der Ausgabe verworfen und die 
        ersten <replaceable> m </replaceable> Zeilen des Rests der Menge zurückgegeben.</para>

      <section id="fblangref25-dml-select-first-skip01-de">
        <title>Eigenschaften von <database>FIRST</database> und <database>SKIP</database></title>
        <itemizedlist>
          <listitem>Jedes Argument für <database>FIRST</database> und <database>SKIP</database>, 
          das kein Integer-Literal oder ein SQL-Parameter ist, muss in Klammern stehen. Dies bedeutet, 
          dass ein Unterabfrageausdruck in <emphasis>zwei</emphasis> Klammern eingeschlossen 
          sein muss.</listitem>
          <listitem><database>SKIP</database> 0 ist erlaubt, jedoch vollkommen sinnlos.</listitem>
          <listitem><database>FIRST</database> 0 ist ebenfalls erlaubt und gibt eine leere Ergebnismenge 
          zurück.</listitem>
          <listitem>Negative Werte für <database>SKIP</database> und/oder <database>FIRST</database>
          resultieren in einem Fehler.</listitem>
          <listitem>Wenn eine <database>SKIP</database> hinter dem Ende des Datensatzes landet, 
          wird ein leerer Satz zurückgegeben.</listitem>
          <listitem>Wenn die Anzahl der Zeilen im Datensatz (oder der Rest nach einem <database>SKIP</database>) 
          kleiner als der Wert des <replaceable>m</replaceable>-Arguments für <database>FIRST</database> ist, 
          wird die kleinere Anzahl von Zeilen zurückgegeben. Dies sind gültige Ergebnisse, keine 
          Fehler.</listitem>
        </itemizedlist>
        <caution>
          <para>Wenn Sie FIRST in Unterabfragen verwenden, tritt ein Fehler auf. Diese Abfrage
            <literallayout class="monospaced">
DELETE FROM MYTABLE
  WHERE ID IN (SELECT FIRST 10 ID FROM MYTABLE)
            </literallayout>
          löscht ALLE Datensätze aus der Tabelle. Die Unterabfrage ruft jedesmal 10 Zeilen ab, 
            löscht sie und die Operation wird wiederholt, bis die Tabelle leer ist. Beachten Sie dies! 
            Oder, besser, verwenden Sie die Klausel <link linkend="fblangref25-dml-select-rows-de">ROWS</link> 
            in der DELETE-Anweisung.</para>
        </caution>
      </section>

      <bridgehead id="firstskipexamples-de" renderas="sect4">Beispiele</bridgehead>

      <para>Die folgende Abfrage gibt die ersten 10 Namen aus der People-Tabelle zurück:</para>

      <blockquote>
        <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>Die folgende Abfrage gibt alles zurück
      <emphasis>but</emphasis> the first 10 names:</para>

      <blockquote>
        <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>Und dieser gibt die letzten 10 Zeilen zurück. Beachten Sie die doppelten 
          Klammern:</para>

      <blockquote>
        <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>Diese Abfrage gibt die Zeilen 81 bis 100 der People-Tabelle zurück:</para>

      <blockquote>
        <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-dml-select-rows-de"><database>ROWS</database></link>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-select-column-list-de">
      <title>Die <database>SELECT</database>-Spaltenliste</title>

      <para>Die Spaltenliste enthält einen oder mehrere durch Kommas getrennte Wertausdrücke. 
          Jeder Ausdruck liefert einen Wert für eine Ausgabespalte. Alternativ kann <literal>*</literal> 
          (<quote>select star</quote>) verwendet werden, um für alle Spalten in einer Beziehung 
          zu stehen (d. H. Für eine Tabelle, eine Ansicht oder eine auswählbare gespeicherte Prozedur).
      </para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   [...]
   [DISTINCT | ALL] <replaceable>&lt;output-column&gt;</replaceable> [, <replaceable>&lt;output-column&gt;</replaceable> ...]
   [...]
   FROM ...

<replaceable>&lt;output-column&gt;</replaceable>     ::=  [<replaceable>qualifier</replaceable>.]*
                           | <replaceable>&lt;value-expression&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;value-expression&gt;</replaceable>  ::=  [<replaceable>qualifier</replaceable>.]<replaceable>table-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>view-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>selectable-SP-outparm</replaceable>
                           | <replaceable>constant</replaceable>
                           | <replaceable>context-variable</replaceable>
                           | <replaceable>function-call</replaceable>
                           | <replaceable>single-value-subselect</replaceable>
                           | <emphasis><database>CASE</database>-construct</emphasis>
                           | <quote>jeder andere Ausdruck, der einen einzelnen Wert eines Firebird-Datentyps 
                               oder <database>NULL</database> zurückgibt
                           </quote>

<replaceable>qualifier</replaceable>           ::=  ein Beziehungsname oder ein Alias
<replaceable>collation</replaceable>           ::=  ein gültiger Collations-Name (nur für Zeichentypspalten)</programlisting>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-dml-tbl-columnslist-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente der SELECT-Spaltenliste</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">qualifier</entry>
              <entry align="left">Name der Beziehung (Sicht, gespeicherte Prozedur, abgeleitete Tabelle); 
                  oder ein Alias dafür</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Nur für zeichenartige Spalten: Ein Collations-Name
                  der für den Zeichensatz der Daten existiert und gültig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Spalten- oder Feldalias</entry>
            </row>
            <row valign="middle">
              <entry align="center">table-column</entry>
              <entry align="left">Name einer Tabellenspalte</entry>
            </row>
            <row valign="middle">
              <entry align="center">view-column</entry>
              <entry align="left">Name einer Ansichtsspalte</entry>
            </row>
            <row valign="middle">
              <entry align="center">selectable-SP-outparm</entry>
              <entry align="left">Deklarierter Name eines Ausgabeparameters einer 
                  auswählbaren gespeicherten Prozedur</entry>
            </row>
            <row valign="middle">
              <entry align="center">constant</entry>
              <entry align="left">Eine Konstante</entry>
            </row>
            <row valign="middle">
              <entry align="center">context-variable</entry>
              <entry align="left">Kontextvariable</entry>
            </row>
            <row valign="middle">
              <entry align="center">function-call</entry>
              <entry align="left">Skalarer oder Aggregatfunktionsaufrufausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">single-value-subselect</entry>
              <entry align="left">Eine Unterabfrage, die einen Skalarwert zurückgibt (Singleton)</entry>
            </row>
            <row valign="middle">
              <entry align="center">CASE-construct</entry>
              <entry align="left">CASE-Konstrukt, dass Bedingungen für einen Rückgabewert definiert</entry>
            </row>
            <row valign="middle">
              <entry align="center">other-single-value-expr </entry>
              <entry align="left">Jeder andere Ausdruck, der einen einzelnen Wert eines Firebird-Datentyps 
                  zurückgibt; oder NULL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <bridgehead renderas="sect4">Beschreibung</bridgehead>

      <para>Es ist immer gültig, einen Spaltennamen zu qualifizieren (oder
      <quote><literal>*</literal></quote>). Dies geschieht mit dem Namen oder Alias
      der Tabelle, Ansicht oder abfragbaren gespeicherten Prozedur, gefolgt von einem Punkt, z.B.
      <function>relationname.columnname</function>, <function>relationname.*</function>,
      <function>alias.columnname</function>, <function>alias.*</function>.
      Qualifizierend ist <command>required</command>, wenn der Spaltenname in mehr als einer 
      Relation auftritt, die an einem Join beteiligt ist. Qualifizierendes 
      <quote>
          <literal>*</literal>
      </quote> ist immer obligatorisch, wenn es nicht das einzige Element in der Spaltenliste ist.</para>
      <important>
        <para>Aliase verschleiern den ursprünglichen Beziehungsnamen: Sobald eine Tabelle, eine Sicht oder 
            eine Prozedur mit einem Alias versehen wurde, kann nur der Alias als Qualifikationsmerkmal für die 
            gesamte Abfrage verwendet werden. Der Beziehungsname selbst ist nicht mehr verfügbar.</para>
      </important>

      <para>Der Spaltenliste kann optional eines der Schlüsselwörter
      <database>DISTINCT</database> or <database>ALL</database> vorangestellt werden:
        <itemizedlist spacing="compact">
          <listitem><database>DISTINCT</database> filtert alle doppelten Zeilen aus. Das heißt, 
          wenn zwei oder mehr Zeilen die gleichen Werte in jeder entsprechenden Spalte haben, 
          ist nur einer von ihnen in der Ergebnismenge enthalten</listitem>
        <listitem><database>ALL</database> ist der Standard: es gibt alle Zeilen zurück, 
        einschließlich Duplikate. <database>ALL</database> wird selten verwendet; Es wird 
        für die Einhaltung des SQL-Standards unterstützt.</listitem>
        </itemizedlist>
      </para>

      <para>Eine Klausel <database>COLLATE</database> ändert das Erscheinungsbild der Spalte als 
      solche nicht. Wenn die angegebene Sortierung jedoch die Groß- / Kleinschreibung der 
      Spalte ändert, kann dies folgende Auswirkungen haben:
      <itemizedlist spacing="compact">
        <listitem>
          <para>Die Reihenfolge, wenn eine Klausel <database>ORDER BY</database> ebenfalls 
          vorhanden ist und diese Spalte umfasst</para>
        </listitem>

        <listitem>
          <para>Gruppierung, wenn die Spalte Teil einer Klausel <database>GROUP BY</database> ist</para>
        </listitem>

        <listitem>
          <para>Die abgerufenen Zeilen (und damit die Gesamtzahl der Zeilen in der Ergebnismenge), 
              wenn <database>DISTINCT</database> verwendet wird</para>
        </listitem>
      </itemizedlist>
      </para>

      <bridgehead renderas="sect4">Beispiele für <database>SELECT</database>-Abfragen mit verschiedenen 
      Arten von Spaltenlisten</bridgehead>

      <para>Ein einfaches <database>SELECT</database>, das nur Spaltennamen verwendet:</para>

      <blockquote>
        <programlisting>select cust_id, cust_name, phone
  from customers
  where city = 'London'</programlisting>
      </blockquote>

      <para>Eine Abfrage mit einem Verkettungsausdruck und einem Funktionsaufruf
          in der Spaltenliste:</para>

      <blockquote>
        <programlisting>select 'Mr./Mrs. ' || lastname, street, zip, upper(city)
  from contacts
  where date_last_purchase(id) = current_date</programlisting>
      </blockquote>

      <para>Eine Abfrage mit zwei Unterabfragen</para>

      <blockquote>
        <programlisting>select p.fullname,
       (select name from classes c where c.id = p.class) as class,
       (select name from mentors m where m.id = p.mentor) as mentor
from pupils p</programlisting>
      </blockquote>

      <para>Die folgende Abfrage führt dasselbe wie das vorherige 
          mit Joins statt Unterabfragen durch:</para>

      <blockquote>
        <programlisting>select p.fullname,
       c.name as class,
       m.name as mentor
from pupils p
  join classes c on c.id = p.class
  join mentors m on m.id = p.mentor</programlisting>
      </blockquote>

      <para>Diese Abfrage verwendet ein <database>CASE</database>-Konstrukt, um die 
      korrekte Anrede zu ermitteln, z.B. für das Senden von E-Mails an eine Person:</para>

      <blockquote>
        <programlisting>select <emphasis role="bold">case upper(sex)
         when 'F' then 'Mrs.'
         when 'M' then 'Mr.'
         else ''
       end</emphasis> as title,
       lastname,
       address
from employees</programlisting>
      </blockquote>

      <para>Abfrage einer auswählbaren gespeicherten Prozedur:</para>

      <blockquote>
        <programlisting>select * from interesting_transactions(2010, 3, 'S')
  order by amount</programlisting>
      </blockquote>

      <para>Auswahl aus Spalten einer abgeleiteten Tabelle. Eine abgeleitete Tabelle ist eine 
          eingeklammerte <database>SELECT</database>-Anweisung, deren Ergebnismenge in einer 
          einschließenden Abfrage so verwendet wird, als wäre sie eine reguläre 
          Tabelle oder Sicht. Die abgeleitete Tabelle ist hier fett dargestellt:
      </para>

      <blockquote>
        <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>
      </blockquote>

      <para>Die Zeit durch eine Kontextvariable abfragen
      (<database>CURRENT_TIME</database>):</para>

      <blockquote>
        <programlisting>select current_time from rdb$database</programlisting>
      </blockquote>

      <para>Für diejenigen, die mit <database>RDB$DATABASE</database> nicht vertraut sind: 
        Dies ist eine Systemtabelle, die in allen Firebird-Datenbanken vorhanden ist und 
        nur genau eine Zeile enthält. Obwohl es für diesen Zweck nicht erstellt wurde, 
        ist es unter Firebird-Programmierern Standard geworden, diese Tabelle abzufragen, 
        wenn Sie <quote>aus nichts</quote> abfragen möchten, d.h. wenn Sie Daten benötigen, 
        die nicht an eine Tabelle oder Ansicht gebunden sind, diese aber über
        Ausdrücke in den Ausgabespalten abgeleitet werden können. Ein anderes Beispiel ist:
      </para>

      <blockquote>
        <programlisting>select power(12, 2) as twelve_squared, power(12, 3) as twelve_cubed
  from rdb$database</programlisting>
      </blockquote>

      <para>Zum Schluss ein Beispiel, in dem Sie aussagekräftige Informationen 
          aus <database>RDB$DATABASE</database> selbst ermitteln:</para>

      <blockquote>
        <programlisting>select rdb$character_set_name from rdb$database</programlisting>
      </blockquote>

      <para>Wie Sie vielleicht schon vermutet haben, erhalten Sie den Standardzeichensatz der Datenbank.</para>
      
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-de">Skalarfunktionen</link>,
        <link linkend="fblangref25-functions-aggfuncs-de">Aggregatfunktionen</link>,
        <link linkend="fblangref25-functions-contextvars-de">Kontextvariablen</link>,
        <link linkend="fblangref25-commons-conditional-case-de"><database>CASE</database></link>,
        <link linkend="fblangref25-commons-subqueries-de">Unterabfragen</link>
        </para>
      </formalpara>

    </section> <!-- columns list -->


    <section id="fblangref25-dml-select-from-de">
      <title>Die <database>FROM</database>-Klausel</title>

      <para>Die Klausel <database>FROM</database> gibt die Quelle (n) an, aus der die 
      Daten abgerufen werden sollen. In seiner einfachsten Form ist dies nur eine einzelne 
      Tabelle oder Ansicht. Die Quelle kann jedoch auch eine auswählbare gespeicherte Prozedur, 
      eine abgeleitete Tabelle oder ein allgemeiner Tabellenausdruck sein. Mehrere Quellen können 
      mit verschiedenen Arten von Joins kombiniert werden.</para>

      <para>Dieser Abschnitt konzentriert sich auf Single-Source-Selects. 
      <link linkend="fblangref25-dml-select-joins-de">Joins</link> werden in einem der folgenden Abschnitte 
      behandelt.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>&lt;derived-table&gt;</replaceable>
                          | <replaceable>&lt;common-table-expression&gt;</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;derived-table&gt;</replaceable>   ::=  (<replaceable>select-statement</replaceable>) [[AS] <replaceable>alias</replaceable>]
                         [(<replaceable>&lt;column-aliases&gt;</replaceable>)]

<replaceable>&lt;common-table-expression&gt;</replaceable>
                  ::=  WITH [RECURSIVE] <replaceable>&lt;cte-def&gt;</replaceable> [, <replaceable>&lt;cte-def&gt;</replaceable> ...]
                       <replaceable>select-statement</replaceable>

<replaceable>&lt;cte-def&gt;</replaceable>         ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-aliases&gt;</replaceable>)] AS (<replaceable>select-statement</replaceable>)

<replaceable>&lt;column-aliases&gt;</replaceable>  ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
          </blockquote></para>
      </formalpara>
      
      <table id="fblangref25-dml-tbl-from-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente der FROM-Klausel</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">table</entry>
              <entry align="left">Name einer Tabelle</entry>
            </row>
            <row valign="middle">
              <entry align="center">view</entry>
              <entry align="left">Name einer Ansicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">selectable-stored-procedure</entry>
              <entry align="left">Name einer auswählbaren gespeicherten Prozedur</entry>
            </row>
            <row valign="middle">
              <entry align="center">args</entry>
              <entry align="left">Auswählbare Argumente für gespeicherte Prozeduren</entry>
            </row>
            <row valign="middle">
              <entry align="center">derived table</entry>
              <entry align="left">Abgeleiteter Tabellenabfrageausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">cte-def</entry>
              <entry align="left">Definition des gemeinsamen Tabellenausdrucks (Common Table Expression, CTE), 
                  einschließlich eines <quote>ad hoc</quote>-Namens</entry>
            </row>
            <row valign="middle">
              <entry align="center">select-statement</entry>
              <entry align="left">Beliebige SELECT-Anweisung</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-aliases</entry>
              <entry align="left">Alias für eine Spalte in einer Relation, CTE oder abgeleitete Tabelle</entry>
            </row>
            <row valign="middle">
              <entry align="center">name</entry>
              <entry align="left">Der <quote>ad hoc</quote>-Name für eine CTE</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Der Alias einer Datenquelle (Tabelle, View, Prozedur, CTE, abgeleitete Tabelle)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section id="fblangref25-dml-select-from-table-view-de">
        <title>Abfragen einer Tabelle oder Ansicht mit <database>FROM</database></title>

        <para>Bei der Auswahl aus einer einzelnen Tabelle oder Sicht muss die 
            <database>FROM</database>-Klausel nichts mehr als den Namen enthalten. 
            Ein Alias kann nützlich oder sogar notwendig sein, wenn es Unterabfragen gibt, 
            die auf die Haupt-Select-Anweisung verweisen (wie sie es sooft tun &mdash; Unterabfragen wie 
            diese werden auch <firstterm>korrelierte Unterabfragen</firstterm> genannt).</para>

        <bridgehead renderas="sect4">Beispiele</bridgehead>

        <blockquote>
          <programlisting>select id, name, sex, age from actors
  where state = 'Ohio'</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from birds
  where type = 'flightless'
  order by family, genus, species</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select firstname,
       middlename,
       lastname,
       date_of_birth,
       (select name from schools s where p.school = s.id) schoolname
from pupils p
where year_started = '2012'
order by schoolname, date_of_birth</programlisting>
        </blockquote>
        <important>
          <title>Mischen Sie niemals Spaltennamen mit Spaltenaliasnamen!</title>
          <para>Wenn Sie einen Alias für eine Tabelle oder eine Sicht angeben, müssen Sie diesen 
              Alias anstelle des Tabellennamens immer verwenden, wenn Sie die Spalten der Relation 
              abfragen (und wo auch immer Sie auf Spalten verweisen, z. B. ORDER BY, GROUP BY) 
              und WHERE-Klauseln.</para>
          <para>Richtige Verwendung:
            <blockquote><programlisting>
SELECT PEARS
FROM FRUIT

SELECT FRUIT.PEARS
FROM FRUIT

SELECT PEARS
FROM FRUIT F

SELECT F.PEARS
FROM FRUIT F
            </programlisting></blockquote>
        Falsche Verwendung:
            <blockquote><programlisting>
SELECT FRUIT.PEARS
FROM FRUIT F
            </programlisting></blockquote>
          </para>
        </important>
      </section>

      <section id="fblangref25-dml-select-sp-de">
        <title>Abfragen einer gespeicherten Prozedur mit <database>FROM</database></title>

        <para>Eine <firstterm>auswählbare gespeicherte Prozedur</firstterm> ist eine Prozedur, 
        die:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>enthält mindestens einen Ausgabeparameter und</para>
          </listitem>

          <listitem>
            <para>das Schlüsselwort <database>SUSPEND</database> verwendet, damit der Aufrufer 
            die Ausgabezeilen nacheinander abrufen kann, genau so wie bei der Auswahl aus 
            einer Tabelle oder Ansicht.</para>
          </listitem>
        </itemizedlist>

        <para>Die Ausgabeparameter einer auswählbaren gespeicherten Prozedur entsprechen den Spalten 
            einer regulären Tabelle.</para>

        <para>Die Abfrage aus einer gespeicherten Prozedur ohne Eingabeparameter entspricht der 
            Abfrage aus einer Tabelle oder Ansicht:</para>

        <blockquote>
          <programlisting>select * from suspicious_transactions
  where assignee = 'John'</programlisting>
        </blockquote>

        <para>Alle erforderlichen Eingabeparameter müssen nach dem in Klammern angegebenen 
            Prozedurnamen angegeben werden:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
  where alt &gt;= 20
  order by az, alt</programlisting>
        </blockquote>

        <para>Werte für optionale Parameter (d.h. Parameter, für die Standardwerte definiert wurden) 
            können weggelassen oder bereitgestellt werden. Wenn Sie diese jedoch nur teilweise angeben, 
            müssen die Parameter, die Sie weglassen, alle am Ende stehen.</para>

        <para>Angenommen, die Prozedur <systemitem>visible_stars</systemitem> aus dem vorherigen 
        Beispiel hat zwei optionale Parameter: <parameter>min_magn</parameter> (numerisch (3,1)) 
        und <parameter>spectral_class</parameter> (varchar (12 )). Die folgenden Abfragen sind alle gültig:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0)
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0, 'G')</programlisting>
        </blockquote>

        <para>Diese jedoch nicht, da es ein <quote>Loch</quote> in der Parameterliste
        gibt:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30', 'G')</programlisting>
        </blockquote>

        <para>Ein Alias für eine auswählbare gespeicherte Prozedur wird <emphasis>nach</emphasis> der Parameterliste angegeben:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = gw.number)
from get_winners('#34517', 'AMS') gw</programlisting>
        </blockquote>

        <para>Wenn Sie auf einen Ausgabeparameter (<quote>column</quote>) verweisen, indem Sie ihn 
        mit dem vollständigen Prozedurnamen qualifizieren, sollte die Parameterliste weggelassen werden:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = <emphasis role="bold">get_winners.number</emphasis>)
from get_winners('#34517', 'AMS')</programlisting>
        </blockquote>
        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-psql-storedprocs-de">Gespeicherte Prozeduren</link>,
          <link linkend="fblangref25-ddl-proc-create-de"><database>CREATE PROCEDURE</database></link>
          </para>
        </formalpara>
      </section>

      <section id="fblangref25-dml-select-from-dt-de">
        <title>Abfragen aus einer abgeleiteten Tabelle mittels <database>FROM</database></title>

        <para>Eine abgeleitete Tabelle ist eine gültige <database>SELECT</database>-Anweisung, 
        die in Klammern eingeschlossen ist, optional gefolgt von einem Tabellenalias und / oder 
        Spaltenaliasnamen. Die Ergebnismenge der Anweisung fungiert als virtuelle Tabelle, die 
        die umschließende Anweisung abfragen kann.</para>
        <formalpara>
          <title>Syntax</title>
          <blockquote><programlisting>
(select-query)
  [[AS] <replaceable>derived-table-alias</replaceable>]
  [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

&lt;derived-column-aliases&gt; := <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]
          </programlisting></blockquote>
        </formalpara>
        <para>Die von diesem <quote><database>SELECT FROM(SELECT FROM ...)</database></quote>-Stil der 
        Anweisung zurückgegebene Datenmenge ist eine virtuelle Tabelle, die innerhalb der 
        umschließenden Anweisung abgefragt werden kann, als wäre sie eine normale Tabelle 
        oder Ansicht.</para>
        <bridgehead renderas="sect4">Beispiel mit einer abgeleiteten Tabelle</bridgehead>
        <para>Die abgeleitete Tabelle in der folgenden Abfrage gibt die Liste der 
            Tabellennamen in der Datenbank und die Anzahl der Spalten in jeder Datenbank zurück. 
            Eine <quote>Drill-Down</quote>-Abfrage für die abgeleitete Tabelle gibt die Anzahl 
            der Felder und die Anzahl der Tabellen mit jeder Feldanzahl zurück:
          <blockquote><programlisting>
SELECT
    FIELDCOUNT,
    COUNT(RELATION) AS NUM_TABLES
FROM (SELECT
           R.RDB$RELATION_NAME RELATION,
           COUNT(*) AS FIELDCOUNT
      FROM RDB$RELATIONS R
           JOIN RDB$RELATION_FIELDS RF
           ON RF.RDB$RELATION_NAME = R.RDB$RELATION_NAME
           GROUP BY RELATION)
GROUP BY FIELDCOUNT
          </programlisting></blockquote>
        </para>
        <para>Ein triviales Beispiel, das demonstriert, wie der Alias einer abgeleiteten 
            Tabelle und die Liste der Spaltenaliase (beide optional) verwendet werden können:
          <blockquote><programlisting>
SELECT
  DBINFO.DESCR, DBINFO.DEF_CHARSET
FROM (SELECT *
      FROM RDB$DATABASE) DBINFO
        (DESCR, REL_ID, SEC_CLASS, DEF_CHARSET)
          </programlisting></blockquote>
        </para>
        <note>
          <title>Mehr über abgeleitete Tabellen</title>
          <para>Abgeleitete Tabellen können
            <itemizedlist>
              <listitem>verschachtelt werden</listitem>
              <listitem>Unions sein und in Unions verwendet werden</listitem>
              <listitem>Aggregatfunktionen, Unterabfragen und Joins enthalten</listitem>
              <listitem>in Aggregatfunktionen, Unterabfragen und Joins verwendet werden</listitem>
              <listitem>Aufrufe an abfragbare gespeicherte Prozeduren oder Abfragen auf diese sein</listitem>
              <listitem><database>WHERE</database>-, <database>ORDER BY</database>- und
              <database>GROUP BY</database>-Klauseln, <database>FIRST, SKIP</database>- oder
              <database>ROWS</database>-Direktiven, usw enthalten.</listitem>
            </itemizedlist>
          </para>
          <para>Weiter gilt:
            <itemizedlist>
              <listitem>Jede Spalte in einer abgeleiteten Tabelle muss einen Namen haben. Wenn sie keinen Namen hat, 
                  z. B. wenn es sich um einen Konstanten- oder einen Laufzeitausdruck handelt, sollte ihr ein Alias 
                  zugewiesen werden, entweder auf reguläre Weise oder durch einfügen in die Liste der Spaltenaliase 
                  in der Spezifikation der abgeleiteten Tabelle.
                <itemizedlist>
                  <listitem><emphasis>Die Liste der Spaltenaliase ist optional, aber falls vorhanden, muss sie einen 
                      Alias für jede Spalte in der abgeleiteten Tabelle enthalten</emphasis>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>Der Optimierer kann abgeleitete Tabellen sehr effektiv verarbeiten. Wenn eine abgeleitete 
                  Tabelle jedoch in einem Inner Join enthalten ist und eine Unterabfrage enthält, kann der Optimierer 
                  keine Join-Reihenfolge verwenden.</listitem>
            </itemizedlist>
          </para>
        </note>
        <bridgehead renderas="sect4">Ein nützlicheres Beispiel</bridgehead>
        <para>Angenommen, wir haben eine Tabelle <database>COEFFS</database>, die die Koeffizienten einer Anzahl von 
        quadratischen Gleichungen enthält, die wir lösen müssen. Diese wurde folgendermaßen definiert:</para>

        <blockquote>
          <programlisting>create table coeffs (
  a double precision not null,
  b double precision not null,
  c double precision not null,
  constraint chk_a_not_zero check (a &lt;&gt; 0)
)</programlisting>
        </blockquote>

        <para>Abhängig von den Werten für <replaceable>a</replaceable>, <replaceable>b</replaceable> und <replaceable>c</replaceable> 
        kann jede Gleichung null, eine oder zwei Lösungen haben. Es ist möglich, diese Lösungen mit einer einstufigen Abfrage für 
        die Tabelle <database>COEFFS</database> zu finden, aber der Code sieht ziemlich unordentlich aus und mehrere Werte 
        (wie die Diskriminante) müssen mehrmals pro Zeile berechnet werden. Eine abgeleitete Tabelle kann dabei helfen, 
        die Dinge sauber zu halten:</para>

        <blockquote>
          <programlisting>select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select b, b*b - 4*a*c, 2*a from coeffs) (b, D, denom)</programlisting>
        </blockquote>

        <para>Wenn wir die Koeffizienten neben den Lösungen anzeigen möchten (was keine schlechte Idee ist), können wir die 
            Abfrage folgendermaßen ändern:</para>

        <blockquote>
          <programlisting>select
  a, b, c,
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select a, b, c, b*b - 4*a*c as D, 2*a as denom
     from coeffs)</programlisting>
        </blockquote>

        <para>Beachten Sie, dass, während die erste Abfrage eine Liste mit Spaltenaliasen für die abgeleitete Tabelle verwendet, 
            nutzt die zweite Abfrage intern hinzugefügte Alias, wo diese benötigt werden. Beide Methoden funktionieren, solange jede Spalte 
            einen Namen hat.</para>
      </section>

      <section id="fblangref25-dml-select-from-cte-de">
        <title>Abfragen einer CTE mittels <database>FROM</database></title>

        <para>Ein allgemeiner Tabellenausdruck (Common Table Expression) oder <database>CTE</database> ist eine komplexere 
        Variante der abgeleiteten Tabelle, aber auch leistungsfähiger. Eine Präambel, beginnend mit dem Schlüsselwort 
        <database>WITH</database>, definiert einen oder mehrere benannte <database>CTE</database> mit jeweils einer optionalen 
        Spalten-Alias-Liste. Die Hauptabfrage, die der Präambel folgt, kann dann auf diese <database>CTE</database> wie normale 
        Tabellen oder Ansichten zugreifen. Sobald die Hauptabfrage ausgeführt wurde, werden die <database>CTE</database>s nicht mehr 
        betrachtet.</para>

        <para>Für eine vollständige Beschreibung der <database>CTE</database>s, beachten Sie bitte
        den Abschnitt <link
        linkend="fblangref25-dml-select-cte-de"><citetitle>Common Table Expressions
        (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</citetitle></link>.</para>

        <para>Das folgende ist eine andere Variante unseres abgeleiteten Tabellenbeispiels als
        <database>CTE</database>:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
)
select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
from vars</programlisting>
        </blockquote>

        <para>Abgesehen von der Tatsache, dass die Berechnungen, die zuerst gemacht werden müssen, 
            jetzt am Anfang stehen, ist dies keine große Verbesserung gegenüber der abgeleiteten Tabellenversion. 
            Aber wir können jetzt auch die doppelte Berechnung von sqrt (D) für jede Zeile eliminieren:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
),
vars2 (b, D, denom, sqrtD) as (
  select b, D, denom, iif (D &gt;= 0, sqrt(D), null) from vars
)
select
  iif (D &gt;= 0, (-b - sqrtD) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrtD) / denom, null) sol_2
from vars2</programlisting>
        </blockquote>

        <para>Der Code ist jetzt etwas komplizierter, könnte aber effizienter ausgeführt werden
            (abhängig davon, was mehr Zeit benötigt: die Ausführung der Funktion
        <database>SQRT</database> oder die Übergabe der Werte von
        <replaceable>b</replaceable>, <replaceable>D</replaceable> und
        <replaceable>denom</replaceable> durch eine weitere 
        <database>CTE</database>). Übrigens hätten wir das Gleiche mit abgeleiteten Tabellen tun können, 
        aber das würde Verschachtelung bedeuten.</para>
      </section>
      <formalpara>
        <title>Siehe auch</title> 
        <para><link
        linkend="fblangref25-dml-select-cte-de"><citetitle>Common Table Expressions
        (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</citetitle></link>.
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-select-joins-de">
      <title>Joins</title>

      <para>Joins kombinieren Daten aus zwei Quellen zu einem einzelnen Satz. Dies 
        wird durch einen Zeile-für-Zeilen-Vergleich durchgeführt und beinhaltet üblicherweise
        eine <firstterm>Join-Bedingung</firstterm>, um festzulegen welche Zeilen zusammengeführt werden
        sollen und im Ergebnisdatensatz erscheinen sollen. Es gibt unterschiedliche Arten
       (<database>INNER</database>, <database>OUTER</database>) und
      Klassen (qualifiziert, natürlich, etc.), jede mit eigener Syntax und Regeln.</para>

      <para>Da Joins verkettet werden können, können die an einem Join beteiligten 
          Datensätze selbst verbundene Sets sein.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>derived-table</replaceable>
                          | <replaceable>common-table-expression</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;joins&gt;      </replaceable>     ::=  <replaceable>&lt;join&gt;</replaceable> [<replaceable>&lt;join&gt;</replaceable> ...]

<replaceable>&lt;join&gt;</replaceable>            ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>
                         | NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>
                         | {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-dml-tbl-join-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente für JOIN-Klauseln</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">table</entry>
              <entry align="left">Name einer Tabelle</entry>
            </row>
            <row valign="middle">
              <entry align="center">view</entry>
              <entry align="left">Name einer Ansicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">selectable-stored-procedure</entry>
              <entry align="left">Name einer auswählbaren gespeicherten Prozedur</entry>
            </row>
            <row valign="middle">
              <entry align="center">args</entry>
              <entry align="left">Wählbare gespeicherte Prozedur-Eingangsparameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">derived-table</entry>
              <entry align="left">Referenz, namentlich, auf eine abgeleitete Tabelle</entry>
            </row>
            <row valign="middle">
              <entry align="center">common-table-expression</entry>
              <entry align="left">Verweis auf einen gemeinsamen Tabellenausdruck (CTE)</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Ein Alias für eine Datenquelle (Tabelle, View, Prozedur, CTE, abgeleitete Tabelle)</entry>
            </row>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">Join-Bedingung (Kriterium)</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-list</entry>
              <entry align="left">Die Liste der Spalten, die für einen Equi-Join verwendet werden</entry>
            </row>
          </tbody>
        </tgroup>
      </table>


      <section id="fblangref25-dml-select-joins-types-de">
        <title>Inner vs. Outer Joins</title>

        <para>Ein Join kombiniert immer Datenzeilen aus zwei Mengen (normalerweise als die linke Menge und die 
            rechte Menge bezeichnet). Standardmäßig werden nur Zeilen in die Ergebnismenge aufgenommen, die die 
            Join-Bedingung erfüllen (d.h. wenn bei der Join-Bedingung mindestens eine Zeile in der anderen Gruppe 
            übereinstimmt). Dieser Standardtyp von Join wird als <firstterm>Inner Join</firstterm> bezeichnet. 
            Angenommen, wir haben die folgenden zwei Tabellen:</para>

        <blockquote>
          <para>Tabelle A:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Tabelle B:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>Wenn wir diese Tabellen wie folgt verbinden:</para>

        <blockquote>
          <programlisting>select *
  from A
  join B on A.id = B.code</programlisting>
        </blockquote>

        <para>then the result set will be:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>Die erste Zeile von A wurde mit der zweiten Zeile von B verbunden, weil sie zusammen 
            die Bedingung <quote>A.id = B.code</quote> erfüllten. Die anderen Zeilen aus den 
            Quellentabellen haben keine Übereinstimmung in der entgegengesetzten Menge und sind daher 
            nicht in der Verknüpfung enthalten. Denken Sie daran, dies ist ein <database>INNER</database> 
            Join. Wir können diese Tatsache explizit machen, indem wir schreiben:</para>

        <blockquote>
          <programlisting>select *
  from A
  inner join B on A.id = B.code</programlisting>
        </blockquote>

        <para>Da jedoch <datenbank>INNER</datenbank> die Standardeinstellung ist, wird dies 
        selten durchgeführt.</para>

        <para>Es ist durchaus möglich, dass eine Zeile im linken Satz mit mehreren Zeilen vom rechten Satz 
            übereinstimmt oder umgekehrt. In diesem Fall sind alle diese Kombinationen enthalten und wir 
            können Ergebnisse erhalten wie:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>-1.0</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Still don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>I give up</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>Manchmal möchten (oder brauchen) <emphasis>alle</emphasis> die Zeilen einer oder beider 
        Quellen in der verbundenen Menge erscheinen, unabhängig davon, ob sie mit einem Datensatz in 
        der anderen Quelle übereinstimmen. An dieser Stelle kommen Outer Joins ins Spiel. Ein Outer Join 
        <database>LEFT</database> enthält alle Datensätze aus dem linken Satz, aber nur übereinstimmende 
        Datensätze aus dem richtigen Satz. In einem <database>RIGHT</database> Outer Join ist es umgekehrt. 
        <database>FULL</database> Outer Joins umfassen alle Datensätze aus beiden Sets. In allen äußeren 
        Joins sind die <quote>Löcher</quote> (die Stellen, an denen ein eingeschlossener Quelldatensatz 
        keine Übereinstimmung in der anderen Menge hat) mit <database>NULL</database> gefüllt.</para>

        <para>Um einen Outer Join zu erstellen, müssen Sie
        <database>LEFT</database>, <database>RIGHT</database> oder
        <database>FULL</database> angeben, optional vom Schlüsselwort
        <database>OUTER</database> gefolgt.</para>

        <para>Im Folgenden sind die Ergebnisse der verschiedenen äußeren Joins aufgeführt, wenn sie auf 
            unsere ursprünglichen Tabellen <database>A</database> und
        <database>B</database> angewendet werden:</para>

        <blockquote>
          <programlisting>select *
  from A
  left [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  right [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  full [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>
      </section>

      <section id="fblangref25-dml-select-joins-qualified-de">
        <title>Qualifizierte Joins</title>

        <para>Qualifizierte Joins geben Bedingungen für das Kombinieren von Zeilen an. 
            Dies geschieht entweder explizit in einer <database>ON</database>-Klausel oder 
            implizit in einer <database>USING</database>-Klausel.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;qualified-join&gt;</replaceable>  ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
            </blockquote></para>
        </formalpara>

        <section>
          <title>Joins mit expliziter Bedingung</title>

          <para>Die meisten qualifizierten Joins haben eine Klausel <database>ON</database> mit einer expliziten 
          Bedingung, bei der es sich um einen beliebigen gültigen booleschen Ausdruck handeln kann, der jedoch 
          normalerweise einen Vergleich zwischen den beiden beteiligten Quellen beinhaltet.</para>

          <para>Häufig ist die Bedingung ein Gleichheitstest (oder eine Anzahl von <database>AND</database>-verknüpften
          Gleichheitstests) unter Verwendung des Operators <quote><literal>=</literal></quote>. Joins wie diese 
          heißen <firstterm>Equi-Joins </firstterm>. (Die Beispiele im Abschnitt über innere und äußere Verknüpfung waren Equi-Joins.)</para>

          <para>Beispiele für Joins mit expliziter Bedingung:</para>

          <blockquote>
            <programlisting>/* Wählen Sie alle Detroit-Kunden aus, die 2013 einen 
                Kauf getätigt haben, zusammen mit den Kaufdetails: */
select * from customers c
  join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>
          </blockquote>

          <blockquote>
            <programlisting>/* Dasselbe wie oben, aber auch nicht kaufende Kunden: */
select * from customers c
  left join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>

            <programlisting>/* Wähle für jeden Mann die Frauen aus, die größer sind als er. 
                Männer, für die keine solche Frau existiert, sind nicht enthalten. */
select m.fullname as man, f.fullname as woman
  from males m
  join females f on f.height &gt; m.height</programlisting>

            <programlisting>/* Wähle alle Schüler mit ihrer Klasse und ihrem Mentor aus. 
                Schüler ohne Mentor sind ebenfalls enthalten. Schüler ohne 
                Klasse sind nicht enthalten. */
select p.firstname, p.middlename, p.lastname,
       c.name, m.name
  from pupils p
  join classes c on c.id = p.class
  left join mentors m on m.id = p.mentor</programlisting>
          </blockquote>
        </section>

        <section id="fblangref25-dml-select-joins-named-columns-de">
          <title>Joins für benannte Spalten</title>

          <para>Equi-Joins vergleichen häufig Spalten, die in beiden Tabellen denselben 
              Namen haben. Wenn dies der Fall ist, können wir auch den zweiten Typ von 
              qualifiziertem Join verwenden: die <firstterm>Joins für benannte Spalten</firstterm>.
          <note>
            <para>Joins für benannte Spalten werden in Dialekt 1 nicht unterstützt.</para>
          </note>
          Joins für benannte Spalten besitzen eine <database>USING</database>-Klausel,
          welche nur die Spaltennamen enthält. Anstelle dieser Variante:</para>

          <blockquote>
            <programlisting>select * from flotsam f
  join jetsam j
  on f.sea = j.sea
  and f.ship = j.ship</programlisting>
          </blockquote>

          <para>können wir auch diese schreiben:</para>

          <blockquote>
            <programlisting>select * from flotsam
  join jetsam using (sea, ship)</programlisting>
          </blockquote>

          <para>welche deutlich kürzer ist. Der Ergebnissatz ist etwas andersThe result set 
              is a little&mdash;zumindest bei der Verwendung von
          <quote><database>SELECT</database> *</quote>:</para>

          <itemizedlist>
            <listitem>
              <para>Der Join mit expliziter Bedingung&mdash;mit der 
              <database>ON</database>-Klausel&mdash; wird jede der Spalten
              <database>SEA</database> und <database>SHIP</database>
              zweimal enthalten: einmal für Tabelle <database>FLOTSAM</database> und einmal
              für Tabelle <database>JETSAM</database>. Offensichtlich werden sie 
              die gleichen Werte haben.</para>
            </listitem>

            <listitem>
              <para>Der Join für benannte Spalten&mdash;mit der 
              <database>USING</database>-Klausel&mdash;enthält diese Spalten nur 
              einmal.</para>
            </listitem>
          </itemizedlist>

          <para>Wenn Sie alle Spalten in der Ergebnismenge der benannten Spalten 
              verknüpfen möchten, richten Sie Ihre Abfrage wie folgt ein:</para>

          <blockquote>
            <programlisting>select f.*, j.*
  from flotsam f
  join jetsam j using (sea, ship)</programlisting>
          </blockquote>

          <para>Dadurch erhalten Sie genau das gleiche Ergebnis wie beim Join 
              der expliziten Bedingung.</para>

          <para>Für einen Join mit benannten Spalte vom Typ <database>OUTER</database>
          gibt es eine zusätzliche Wendung, wenn <quote><database>SELECT</database> * </quote>
          oder ein nicht qualifizierter Spaltenname aus der <database>USING</database>-Liste 
          verwendet wird:</para>

          <para>Wenn eine Zeile aus einer Quellgruppe keine Übereinstimmung in der anderen enthält, 
              muss sie dennoch aufgrund der <database>LEFT</database>-, <database>RIGHT</database>- 
              oder <database>FULL</database>-Direktive enthalten sein.
              Die zusammengeführte Spalte im zusammengeführten Satz erhält den Wert nicht-<database>NULL</database>. 
              Das ist soweit gut, aber jetzt können Sie nicht sagen, ob dieser Wert aus der linken, rechten oder 
              beiden Mengen stammt. Dies kann besonders trügerisch sein, wenn der Wert von der rechten Seite
              stammt, weil <quote><literal>*</literal></quote> immer kombinierte Spalten im linken Teil 
              zeigt&mdash;selbst im Falle eines <database>RIGHT</database> Join.</para>

          <para>Ob dies ein Problem ist oder nicht, hängt von der Situation ab. 
              Wenn ja, benutzen Sie die <quote>
                  <literal>a</literal>.<literal>*</literal>-,
          <literal>b</literal>.<literal>*</literal></quote>-Ansatz wie oben gezeigt, 
          mit <literal>a</literal> und <literal>b</literal> als Namen oder Alias
          der beiden Quellen. Oder noch besser, vermeiden Sie <quote><literal>*</literal></quote> 
          insgesamt in Ihren seriösen Abfragen und qualifizieren Sie alle Spaltennamen in verbundenen 
          Mengen. Dies hat den zusätzlichen Vorteil, dass Sie gezwungen sind, darüber nachzudenken, 
          welche Daten Sie abrufen möchten und woher.</para>

          <para>Es liegt in Ihrer Verantwortung sicherzustellen, dass die Spaltennamen in der <database>USING</database>-Liste 
          kompatible Typen zwischen den beiden Quellen sind. Wenn die Typen kompatibel aber nicht gleich sind, konvertiert die 
          Engine sie in den Typ mit dem breitesten Wertebereich, bevor sie die Werte vergleicht. Dies ist auch der Datentyp der
          zusammengeführten Spalte, die in der Ergebnismenge angezeigt wird, wenn <quote><database>SELECT</database> * </quote> 
          oder der nicht qualifizierte Spaltenname verwendet wird. Qualifizierte Spalten behalten ihren ursprünglichen 
          Datentyp immer bei.</para>
        </section>
      </section> <!-- Qualified joins -->

      <section id="fblangref25-dml-select-joins-natural-de">
        <title>Natürliche Joins</title>

        <para>Greift man die Idee der benannten Spalten auf und geht noch einen Schritt weiter, führt ein <firstterm>natürlicher Join</firstterm> 
        einen automatischen Equi-Join für alle Spalten durch, die in der linken und rechten Tabelle den gleichen Namen haben. Die 
        Datentypen dieser Spalten müssen kompatibel sein.
          <note>
            <para>Natürliche Joins werden in Dialekt 1-Datenbanken nicht unterstützt.</para>
          </note>
        </para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;natural-join&gt;</replaceable>  ::=  NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>     ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Gegeben sind diese beiden Tabellen</para>

        <blockquote>
          <programlisting>create table TA (
  a bigint,
  s varchar(12),
  ins_date date
)</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>create table TB (
  a bigint,
  descr varchar(12),
  x float,
  ins_date date
)</programlisting>
        </blockquote>

        <para>Ein natürlicher Join auf <database>TA</database> und
        <database>TB</database> würde die Spalten 
        <replaceable>a</replaceable> und <replaceable>ins_date</replaceable> einbeziehen,
        und die folgenden zwei Anweisungen würden die gleiche Wirkung haben:</para>

        <blockquote>
          <programlisting>select * from TA
  natural join TB</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from TA
  join TB using (a, ins_date)</programlisting>
        </blockquote>

        <para>Wie alle Joins sind natürliche Joins standardmäßig innere Joins, 
            die Sie jedoch durch Angabe von
        <database>LEFT</database>, <database>RIGHT</database> oder
        <database>FULL</database> vor dem Schlüsselwort <database>JOIN</database> in
        äußere Joins umwandeln können.</para>

        <para>Vorsicht: Wenn in den beiden Quellbeziehungen keine Spalten mit demselben 
            Namen vorhanden sind, wird ein <database>CROSS JOIN</database> ausgeführt. 
            Wir kommen in einer Minute zu dieser Art von Join.</para>
      </section>

      <section id="fblangref25-dml-select-joins-equality-de">
        <title>Eine Anmerkung zur Gleichheit</title>
        <important>
          <para>Diese Notiz über Gleichheits- und Ungleichheitsoperatoren gilt überall in der Firebird 
              SQL-Sprache, nicht nur unter JOIN-Bedingungen.</para>
        </important>
        <para>Der Operator <quote><literal>=</literal></quote>, welcher explizit für 
        diverse bedingte Joins und imlizit in Joins mit benannten Spalten und natürlichen Joins
        verwendet wird, vergleicht nur Werte mit Werten.
        Nach dem SQL-Standard gilt, dass <database>NULL</database> kein Wert ist
        und somit zwei <database>NULL</database>en wedet identisch noch unidentisch 
        zueinander sind. Wenn Sie <database>NULL</database> benötigen, um in einem Join 
        übereinzustimmen, verwenden Sie den Operator <database>IS NOT DISTINCT FROM</database>. 
        Dieser Operator gibt "true" zurück, wenn die Operanden denselben Wert haben <emphasis>oder</emphasis> 
        wenn sie beide <database>NULL</database> sind.</para>

        <blockquote>
          <programlisting>select *
  from A join B
  on A.id is not distinct from B.code</programlisting>
        </blockquote>

        <para>In den &mdash;extrem seltenen&mdash;Fällen, in denen Sie im Join auf
        die <emphasis>in</emphasis>-Gleichheit prüfen möchsten, verwenden Sie <database>IS DISTINCT
        FROM</database>, nicht <quote><literal>&lt;&gt;</literal></quote>, falls
        Sie <database>NULL</database> von anderen Werten unterscheiden müssen und 
        zwei <database>NULL</database>en als gleich betrachtet werden sollen:</para>

        <blockquote>
          <programlisting>select *
  from A join B
  on A.id is distinct from B.code</programlisting>
        </blockquote>
      </section>

      <section id="fblangref25-dml-select-joins-cross-de">
        <title>Cross Joins</title>

        <para>Ein Cross Join erzeugt das vollständige Set-Produkt der beiden Datenquellen. 
            Dies bedeutet, dass jede Zeile in der linken Quelle mit jeder Zeile in der 
            rechten Quelle übereinstimmt.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;cross-join&gt;</replaceable>  ::=  {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <para>Bitte beachten Sie, dass die Kommasyntax veraltet ist! Es wird nur 
            unterstützt, um Legacy-Code zu erhalten, und wird möglicherweise in 
            einer zukünftigen Version verschwinden.</para>

        <para>Das Zusammenführen von zwei Sätzen ist gleichbedeutend damit, dass sie 
            sich einer Tautologie anschließen (eine Bedingung, die immer wahr ist). 
            Die folgenden beiden Aussagen haben den gleichen Effekt:</para>

        <blockquote>
          <programlisting>select * from TA
  cross join TB</programlisting>

          <programlisting>select * from TA
  join TB on 1 = 1</programlisting>
        </blockquote>

        <para>Cross Joins sind innere Joins, da sie nur übereinstimmende Datensätze enthalten - 
            dies ergibt sich daraus, dass <emphasis>jeder</emphasis>-Eintrag übereinstimmt! Ein 
            äußerer Cross Join würde, falls vorhanden, dem Ergebnis nichts hinzufügen, weil die 
            äußeren Joins keine übereinstimmenden Datensätze sind und diese nicht in Cross Joins
            existieren.</para>

        <para>Cross Joins sind selten nützlich, außer wenn Sie alle möglichen Kombinationen von 
            zwei oder mehr Variablen auflisten möchten. Angenommen, Sie verkaufen ein Produkt in 
            verschiedenen Größen, Farben und Materialien. Wenn diese Variablen jeweils in einer 
            eigenen Tabelle aufgeführt sind, gibt diese Abfrage alle Kombinationen zurück:</para>

        <blockquote>
          <programlisting>select m.name, s.size, c.name
  from materials m
  cross join sizes s
  cross join colors c</programlisting>
        </blockquote>
      </section>

      <section id="fblangref25-dml-select-joins-ambiguity-de">
        <title>Mehrdeutige Feldnamen in Joins</title>

        <para>Firebird weist unqualifizierte Feldnamen in einer Abfrage zurück, wenn 
            diese Feldnamen in mehr als einem Datensatz vorhanden sind, der an einem 
            Join beteiligt ist. Dies gilt sogar für innere Equi-Joins, bei denen der 
            Feldname in der <database>ON</database>-Klausel so aussieht:</para>

        <blockquote>
          <programlisting>select a, b, c
  from TA
  join TB on TA.a = TB.a</programlisting>
        </blockquote>

        <para>Es gibt eine Ausnahme zu dieser Regel: Bei Joins mit benannten Spalten und 
            natürlichen Joins kann der nicht qualifizierte Feldname einer Spalte, die am 
            Matching-Prozess teilnimmt, legal verwendet werden und verweist auf die 
            zusammengeführte Spalte mit demselben Namen.
            Für Joins mit benannten Spalten sind dies die in der <database>USING</database>-Klausel 
            aufgelisteten Spalten. Bei natürlichen Joins sind dies die Spalten, die in beiden 
            Relationen denselben Namen haben.
            Aber bitte beachten Sie noch einmal, dass insbesondere in Outer Joins der reine 
            <replaceable>Spaltenname</replaceable> nicht immer dasselbe ist wie 
            <replaceable>links</replaceable>.<replaceable>Spaltenname</replaceable> oder 
            <replaceable>rechts</replaceable>.<replaceable>Spaltenname</replaceable>.
            Die Typen können sich unterscheiden, und eine der qualifizierten Spalten kann 
            <database>NULL</database> sein, während die andere nicht. In diesem Fall kann der Wert 
            in der zusammengeführten, nicht qualifizierten Spalte die Tatsache maskieren, dass einer 
            der Quellwerte nicht vorhanden ist.</para>
      </section>

      <section id="fblangref25-dml-select-joins-storedprocs-de">
        <title>Joins mit gespeicherten Prozeduren</title>
        <para>Wenn eine Verknüpfung mit einer gespeicherten Prozedur durchgeführt wird, die nicht über 
            Eingabeparameter mit anderen Datenströmen korreliert, gibt es keine Kuriositäten. Wenn 
            es Korrelationen <emphasis>gibt</emphasis>, zeigt sich eine unangenehme Eigenart. Das Problem ist, 
            dass der Optimierer sich selbst jede Möglichkeit nimmt, die Beziehungen der Eingabeparameter 
            der Prozedur zu den Feldern in den anderen Datenströmen zu bestimmen:
          <blockquote><programlisting>
SELECT *
FROM MY_TAB
JOIN MY_PROC(MY_TAB.F) ON 1 = 1
          </programlisting></blockquote>
        </para>
        <para>Hier wird die Prozedur ausgeführt, bevor ein einzelner Datensatz aus der Tabelle MY_TAB abgerufen 
            wurde. Der Fehler <function>isc_no_cur_rec error</function> (<emphasis>kein aktueller Datensatz für 
                die Abrufoperation</emphasis>) wird ausgelöst, wodurch die Ausführung unterbrochen wird.</para>
        <para>Die Lösung besteht darin, eine Syntax zu verwenden, die die Join-Reihenfolge <emphasis>explizit</emphasis> 
        angibt:
          <blockquote><programlisting>
SELECT *
FROM MY_TAB
LEFT JOIN MY_PROC(MY_TAB.F) ON 1 = 1
          </programlisting></blockquote>
        Dies erzwingt, dass die Tabelle vor der Prozedur gelesen wird und alles ordnungsgemäß funktioniert.</para>
        <tip>
          <para>Diese Eigenart wurde als Fehler im Optimierer erkannt und wird in der nächsten Version von Firebird behoben.</para>
        </tip>
      </section>
    </section> <!-- JOINS -->

    <section id="fblangref25-dml-select-where-de">
      <title>Die <database>WHERE</database>-Klausel</title>

      <para>Die <database>WHERE</database>-Klausel dient dazu, die zurückgegebenen 
      Zeilen auf diejenigen zu beschränken, an denen der Aufrufer interessiert ist. 
      Die Bedingung nach dem Schlüsselwort <database>WHERE</database> kann so einfach sein 
      wie <quote><database>Anzahl</database> = 3 </quote> oder ein mehrschichtiger, 
      geschachtelter Ausdruck, der Unterabfragen, Prädikate, Funktionsaufrufe, mathematische 
      und logische Operatoren, Kontextvariablen und mehr enthält.</para>

      <para>Die Bedingung in der <database>WHERE</database>-Klausel wird häufig
      als die <firstterm>Suchbedingung</firstterm>, der
      <firstterm>Suchausdruck</firstterm> oder einfach die
      <firstterm>Suche</firstterm> bezeichnet.</para>

      <para>In DSQL und ESQL kann der Suchausdruck Parameter enthalten. Dies ist nützlich, wenn 
          eine Abfrage mehrmals mit unterschiedlichen Eingabewerten wiederholt werden muss. In der 
          SQL-Zeichenfolge, die an den Server übergeben wird, werden Fragezeichen als Platzhalter 
          für die Parameter verwendet. Sie heißen <firstterm>Positionsparameter</firstterm>, 
          weil sie nur durch ihre Position in der Zeichenfolge voneinander getrennt werden können. 
          Konnektivitätsbibliotheken unterstützen oft <firstterm>benannte Parameter</firstterm> 
          der Form <parameter>:id</parameter>, <parameter>:amount</parameter>, <parameter>:a</parameter> 
          usw. Diese sind benutzerfreundlicher; Die Bibliothek sorgt dafür, dass die benannten Parameter 
          in Positionsparameter übersetzt werden, bevor die Anweisung an den Server übergeben wird.</para>

      <para>Die Suchbedingung kann auch lokale (PSQL) oder Host (ESQL)-Variablennamen enthalten, 
          denen ein Doppelpunkt vorangestellt ist.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ...
   FROM ...
   [...]
   WHERE <replaceable>&lt;search-condition&gt;</replaceable>
   [...]

<replaceable>&lt;search-condition&gt;</replaceable>  ::=  Ein boolescher Ausdruck, der
                         <constant>TRUE</constant>, <constant>FALSE</constant> oder möglicherweise <constant>UNKNOWN</constant> (<constant>NULL</constant>)
            zurückgibt</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Nur die Zeilen, für die die Suchbedingung <constant>TRUE</constant> ergibt, sind in der Ergebnismenge 
      enthalten. Seien Sie vorsichtig mit möglichen <constant>NULL</constant>-Ergebnissen: Wenn Sie einen <constant>NULL</constant>-Ausdruck 
      mit <database>NOT</database> negieren, ist das Ergebnis immer <constant>NULL</constant> und die Zeile wird nicht berücksichtigt. 
      Dies wird in einem der folgenden Beispiele demonstriert.</para>

      <bridgehead renderas="sect4">Beispiele</bridgehead>

      <blockquote>
        <programlisting>select genus, species from mammals
  where family = 'Felidae'
  order by genus</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from persons
  where birthyear in (1880, 1881) 
     or birthyear between 1891 and 1898</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select name, street, borough, phone
  from schools s
  where exists (select * from pupils p where p.school = s.id)
  order by borough, street</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from employees
  where salary &gt;= 10000 and position &lt;&gt; 'Manager'</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select name from wrestlers
  where region = 'Europe'
    and weight &gt; all (select weight from shot_putters
                      where region = 'Africa')</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from players
  where team_id = (select id from teams where name = 'Buffaloes')</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select sum (population) from towns
  where name like '%dam'
  and province containing 'land'</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select password from usertable
  where username = current_user</programlisting>
      </blockquote>

      <para>Das folgende Beispiel zeigt, was passieren kann, wenn die Suchbedingung 
          auf <constant>NULL</constant> ausgewertet wird.</para>

      <para>Angenommen, Sie haben eine Tabelle mit den Namen einiger Kinder und der Anzahl der 
          Murmeln, die sie besitzen. Zu einem bestimmten Zeitpunkt enthält die Tabelle diese Daten:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>CHILD</entry>

                <entry>MARBLES</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Anita</entry>

                <entry>23</entry>
              </row>

              <row>
                <entry>Bob E.</entry>

                <entry>12</entry>
              </row>

              <row>
                <entry>Chris</entry>

                <entry><emphasis>&lt;null&gt;</emphasis></entry>
              </row>

              <row>
                <entry>Deirdre</entry>

                <entry>1</entry>
              </row>

              <row>
                <entry>Eve</entry>

                <entry>17</entry>
              </row>

              <row>
                <entry>Fritz</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>Gerry</entry>

                <entry>21</entry>
              </row>

              <row>
                <entry>Hadassah</entry>

                <entry><emphasis>&lt;null&gt;</emphasis></entry>
              </row>

              <row>
                <entry>Isaac</entry>

                <entry>6</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>Zuerst beachten Sie bitte den Unterschied zwischen <constant>NULL</constant> und 0: 
      Fritz ist <emphasis>bekannt</emphasis> dafür überhaupt keine Murmeln zu haben, Chris' und Hadassahs 
      Murmelanzahlen unbekannt.</para>

      <para>Nun, wenn Sie diese SQL-Anweisung ausgeben:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &gt; 10</programlisting>
      </blockquote>

      <para>Sie werden die Namen Anita, Bob E., Eve und Gerry bekommen. Diese Kinder haben alle mehr als 10 Murmeln.</para>

      <para>Wenn Sie den Ausdruck negieren:<blockquote>
          <programlisting>select list(child) from marbletable where not marbles &gt; 10</programlisting>
        </blockquote></para>

      <para>Deirdre, Fritz und Isaac sind an der Reihe. Chris und Hadassah sind nicht enthalten, 
          weil nicht <emphasis>bekannt</emphasis> ist, dass sie zehn oder weniger Murmeln besitzen. 
          Sollten Sie diese letzte Abfrage ändern in:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &lt;= 10</programlisting>
      </blockquote>

      <para>wird das Ergebnis immer noch dasselbe sein, weil der Ausdruck
      <constant>NULL</constant> <literal>&lt;=</literal> <literal>10</literal>
      nun <constant>UNKNOWN</constant> ergibt. Das ist nicht dasselbe wie <constant>TRUE</constant>,
      also sind Chris und Hadassah nicht aufgelistet. Wenn Sie sie mit den 
      <quote>armen</quote>-Kindern anzeigen möchten, ändern Sie die Abfrage in:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &lt;= 10 or marbles is null</programlisting>
      </blockquote>

      <para>Jetzt wird die Suchbedingung für Chris und Hadassah wahr, weil 
          <quote>
              <literal>marbles is null</literal>
          </quote> gibt in diesem Fall offensichtlich <constant>TRUE</constant> 
          zurück. Tatsächlich kann die Suchbedingung jetzt für niemanden 
          <konstant>NULL</konstant> sein.</para>

      <para>Zuletzt zwei Beispiele für <database>SELECT</database>-Abfragen mit Parametern in der Suche. 
      Es hängt von der Anwendung ab, wie Sie Abfrageparameter definieren sollten und selbst wenn es überhaupt 
      möglich ist. Beachten Sie, dass Abfragen wie diese nicht sofort ausgeführt werden können: Sie müssen 
      zuerst <emphasis>vorbereitet</emphasis> (prepared) sein. Nachdem eine parametrisierte Abfrage vorbereitet 
      wurde, kann der Benutzer (oder der Aufrufcode) Werte für die Parameter bereitstellen und sie mehrmals ausführen 
      lassen, wobei vor jedem Aufruf neue Werte eingegeben werden. Wie die Werte eingegeben werden und die Ausführung 
      gestartet wird, ist Sache der Anwendung. In einer GUI-Umgebung gibt der Benutzer die Parameterwerte in der Regel 
      in ein oder mehrere Textfelder ein und klickt dann auf die Schaltfläche <quote>Ausführen</quote> oder 
      <quote>Aktualisieren</quote>.</para>

      <blockquote>
        <programlisting>select name, address, phone frome stores
  where city = ? and class = ?</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from pants
  where model = :model and size = :size and color = :col</programlisting>
      </blockquote>

      <para>Die letzte Abfrage kann nicht direkt an die Engine übergeben werden. 
          Die Anwendung muss sie zuerst in das andere Format konvertieren und 
          benannte Parameter den Positionsparametern zuordnen.</para>
    </section>

    <section id="fblangref25-dml-select-groupby-de">
      <title>Die <database>GROUP BY</database>-Klausel</title>

      <para><database>GROUP BY</database> führt Ausgangszeilen mit derselben 
      Kombination von Werten in der Elementliste in eine einzelne Zeile zusammen. 
      Aggregatfunktionen in der Auswahlliste werden für jede Gruppe einzeln und 
      nicht für das gesamte Dataset angewendet.</para>

      <para>Wenn die Auswahlliste nur Aggregatspalten oder allgemeiner Spalten enthält, 
          deren Werte nicht von einzelnen Zeilen in der zugrunde liegenden Menge abhängen, 
          ist <database>GROUP BY</database> optional. Wenn sie weggelassen wird, besteht 
          die endgültige Ergebnismenge aus einer einzelnen Zeile (vorausgesetzt, dass mindestens 
          eine aggregierte Spalte vorhanden ist).</para>

      <para>Wenn die Auswahlliste sowohl Aggregatspalten als auch Spalten enthält, deren Werte 
          je Zeile variieren können, wird die Klausel <database>GROUP BY</database> obligatorisch.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;grouping-item&gt;</replaceable> [, <replaceable>&lt;grouping-item&gt;</replaceable> ...]
   [HAVING <replaceable>&lt;grouped-row-condition&gt;</replaceable>]
   ...

<replaceable>&lt;grouping-item&gt;</replaceable>         ::=  <replaceable>&lt;non-aggr-select-item&gt;</replaceable>
                               | <replaceable>&lt;non-aggr-expression&gt;</replaceable>

<replaceable>&lt;non-aggr-select-item&gt;</replaceable>  ::=  <replaceable>column-copy</replaceable>
                               | <replaceable>column-alias</replaceable>
                               | <replaceable>column-position</replaceable>
          </programlisting>
          </blockquote></para>
      </formalpara>
      <table id="fblangref25-dml-tbl-groupby-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente der GROUP BY-Klausel</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">non-aggr-expression</entry>
              <entry align="left">Jeder nicht aggregierende Ausdruck, der nicht in der SELECT-Liste 
                  enthalten ist, d.h. nicht ausgewählte Spalten aus der Quellenmenge oder Ausdrücke, 
                  die überhaupt nicht von den Daten in der Menge abhängen</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-copy</entry>
              <entry align="left">Eine Literalkopie aus der SELECT-Liste eines Ausdrucks, 
                  der keine Aggregatfunktion enthält</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-alias</entry>
              <entry align="left">Der Alias aus der SELECT-Liste eines Ausdrucks (Spalte), der keine Aggregatfunktion enthält</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-position</entry>
              <entry align="left">Die Positionsnummer in der SELECT-Liste eines Ausdrucks (Spalte), der keine Aggregatfunktion enthält</entry>
            </row>
          </tbody>
        </tgroup>
      </table>


      <para>Eine allgemeine Faustregel besagt, dass jedes nicht aggregierte Element in der <database>SELECT</database>-Liste
          ebenfalls in der <database>GROUP BY</database>-Liste enthalten sein muss. Sie können dies auf drei Arten tun:</para>

      <orderedlist>
        <listitem>
          <para>Indem der Gegenstand wörtlich aus der Auswahlliste kopiert wird, z.B.
          <quote><literal>class</literal></quote> oder
          <quote><literal>'D:'</literal> <literal>||</literal>
          <literal>upper(doccode)</literal></quote>.</para>
        </listitem>

        <listitem>
          <para>Durch Angabe des Spaltenalias, falls vorhanden.</para>
        </listitem>

        <listitem>
          <para>Durch Angabe der Spaltenposition als Ganzzahl <emphasis>literal</emphasis> zwischen 1
          und der Anzahl der Spalten. Ganzzahlwerte, die sich aus Ausdrücken oder Parametersubstitutionen 
          ergeben, sind einfach unveränderlich und werden als solche in der Gruppierung verwendet. Sie 
          werden jedoch keinen Effekt haben, da ihr Wert für jede Zeile gleich ist.</para>
        </listitem>
      </orderedlist>

      <note>
        <para>Wenn Sie nach einer Spaltenposition gruppieren, wird der Ausdruck an dieser Position 
            intern aus der Auswahlliste kopiert. Wenn es sich um eine Unterabfrage handelt, wird diese 
            Unterabfrage in der Gruppierungsphase erneut ausgeführt. Das bedeutet, dass die Gruppierung 
            nach der Spaltenposition, anstatt den Unterabfrageausdruck in der Gruppierungsklausel zu duplizieren, 
            Tastenanschläge und Bytes speichert, dies ist jedoch keine Möglichkeit, Verarbeitungszyklen zu speichern!</para>
      </note>

      <para>Zusätzlich zu den erforderlichen Elementen kann die Gruppierungsliste auch Folgendes enthalten:</para>

      <itemizedlist>
        <listitem>
          <para>Spalten aus der Quelltabelle, die nicht in der Auswahlliste enthalten sind, oder Nicht-Aggregat-Ausdrücke, 
              die auf solchen Spalten basieren. Das Hinzufügen solcher Spalten kann die Gruppen weiter unterteilen. 
              Da diese Spalten jedoch nicht in der Auswahlliste enthalten sind, können Sie nicht feststellen, 
              welche aggregierte Zeile mit welchem Wert in der Spalte übereinstimmt. Wenn Sie also an diesen 
              Informationen interessiert sind, fügen Sie auch die Spalte oder den Ausdruck in die 
              Auswahlliste&mdash;ein, die Sie wieder zur Regel führt: <quote>Jede Nicht-Aggregat-Spalte in der Auswahlliste 
                  muss ebenfalls in der Gruppierungsliste sein</quote>.</para>
        </listitem>

        <listitem>
          <para>Ausdrücke, die nicht von den Daten in dem zugrunde liegenden Satz abhängen, z. Konstanten, Kontextvariablen, 
              einwertige nicht-korrelierte Subselects usw. Dies wird nur der Vollständigkeit halber erwähnt, da das Hinzufügen 
              solcher Elemente völlig sinnlos ist: Sie beeinflussen die Gruppierung überhaupt nicht. <quote>Harmlose, aber nutzlose</quote> 
              Elemente wie diese können auch in der Auswahlliste erscheinen, ohne in die Gruppierungsliste kopiert zu werden.</para>
        </listitem>
      </itemizedlist>

      <bridgehead renderas="sect4">Beispiele</bridgehead>

      <para>Wenn die Auswahlliste nur Aggregatspalten enthält, ist 
          <database>GROUP BY</database> nicht obligatorisch:
      <blockquote>
        <programlisting>select count(*), avg(age) from students
  where sex = 'M'</programlisting>
      </blockquote>
       </para>

      <para>Dies wird eine einzelne Zeile zurückgeben, die die Anzahl der männlichen Studenten und deren 
          Durchschnittsalter auflistet. Das Hinzufügen von Ausdrücken, die nicht von Werten in einzelnen 
          Zeilen der Tabelle <database>STUDENTS</database> abhängen, ändert das nicht:
      <blockquote>
        <programlisting>select count(*), avg(age), current_date from students
  where sex = 'M'</programlisting>
      </blockquote>
      Die Zeile wird jetzt eine zusätzliche Spalte haben, die das aktuelle Datum anzeigt, aber ansonsten 
      hat sich nichts Grundlegendes geändert. Eine Klausel <database>GROUP BY</database> ist weiterhin 
      nicht erforderlich.</para>

      <para>In beiden obigen Beispielen ist dies jedoch 
      <emphasis>erlaubt</emphasis>. Dies ist absolut gültig:
      <blockquote>
        <programlisting>select count(*), avg(age) from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      und gibt eine Reihe für jede Klasse zurück, in der sich Jungen befinden, die die Anzahl der Jungen 
      und ihr Durchschnittsalter in dieser bestimmten Klasse auflistet. (Wenn Sie auch das Feld 
      <literal>current_date</literal> beibehalten, wird dieser Wert in jeder Zeile wiederholt, 
      was nicht besonders aufregend ist.)</para>

      <para>Die obige Abfrage hat jedoch einen großen Nachteil: Sie gibt Ihnen Informationen über die verschiedenen 
          Klassen, aber Sie erfahren nicht, welche Zeile für welche Klasse gilt. Um diese zusätzlichen Informationen 
          zu erhalten, muss die nicht aggregierte Spalte <database>CLASS</database> zur Auswahlliste hinzugefügt 
          werden:</para>

      <blockquote>
        <programlisting>select class, count(*), avg(age) from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>Jetzt haben wir eine nützliche Abfrage. Beachten Sie, dass durch das Hinzufügen der Spalte 
          <database>CLASS</database> auch die Klausel <database>GROUP BY</database> obligatorisch wird. 
          Wir können diese Klausel nicht mehr löschen, es sei denn, wir entfernen auch <database>CLASS</database> 
          aus der Spaltenliste.</para>

      <para>Die Ausgabe unserer letzten Abfrage könnte etwa so aussehen:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>CLASS</entry>

                <entry>COUNT</entry>

                <entry>AVG</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2A</entry>

                <entry>12</entry>

                <entry>13.5</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>9</entry>

                <entry>13.9</entry>
              </row>

              <row>
                <entry>3A</entry>

                <entry>11</entry>

                <entry>14.6</entry>
              </row>

              <row>
                <entry>3B</entry>

                <entry>12</entry>

                <entry>14.4</entry>
              </row>

              <row>
                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>Die Überschriften <quote>COUNT</quote> und <quote>AVG</quote> sind nicht sehr 
      informativ. In einem einfachen Fall wie diesem, könnten Sie damit durchkommen, aber 
      im Allgemeinen sollten Sie aggregierten Spalten einen aussagekräftigen Namen geben, 
      indem wir je einen Alias nutzen:</para>

      <blockquote>
        <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>Wie Sie aus der formalen Syntax der Spaltenliste entnehmen können, ist das 
          Schlüsselwort <database>AS</database> optional.</para>

      <para>Wenn Sie weitere nicht aggregierte (oder besser: zeilenabhängige) Spalten hinzufügen, 
          müssen Sie sie auch der Klausel <database>GROUP BY</database> hinzufügen. Zum Beispiel 
          möchten Sie vielleicht die oben genannten Informationen auch für Mädchen sehen; und Sie 
          möchten vielleicht auch zwischen Internats- und Tagesschülern unterscheiden:</para>

      <blockquote>
        <programlisting>select class,
       sex,
       boarding_type,
       count(*) as number,
       avg(age) as avg_age
  from students
  group by class, sex, boarding_type</programlisting>
      </blockquote>

      <para>Dies kann zu folgendem Ergebnis führen:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="5">
            <thead>
              <row>
                <entry>CLASS</entry>

                <entry>SEX</entry>

                <entry>BOARDING_TYPE</entry>

                <entry>NUMBER</entry>

                <entry>AVG_AGE</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2A</entry>

                <entry>F</entry>

                <entry>BOARDING</entry>

                <entry>9</entry>

                <entry>13.3</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>F</entry>

                <entry>DAY</entry>

                <entry>6</entry>

                <entry>13.5</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>M</entry>

                <entry>BOARDING</entry>

                <entry>7</entry>

                <entry>13.6</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>M</entry>

                <entry>DAY</entry>

                <entry>5</entry>

                <entry>13.4</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>F</entry>

                <entry>BOARDING</entry>

                <entry>11</entry>

                <entry>13.7</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>F</entry>

                <entry>DAY</entry>

                <entry>5</entry>

                <entry>13.7</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>M</entry>

                <entry>BOARDING</entry>

                <entry>6</entry>

                <entry>13.8</entry>
              </row>

              <row>
                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>Jede Zeile in der Ergebnismenge entspricht einer bestimmten Kombination der Variablen class, 
          sex und boarding type. Die zusammengefassten Ergebnisse&mdash;Anzahl und durchschnittliches 
          Alter&mdash;sind für jede dieser eher spezifischen Gruppen einzeln angegeben. In einer Abfrage 
          wie dieser sehen Sie keine Gesamtzahl für Jungen als Ganzes oder Tagesschüler als Ganzes. 
          Das ist der Nachteil: Je mehr Nicht-Aggregat-Spalten Sie hinzufügen, desto mehr können Sie 
          sehr spezifische Gruppen bestimmen, aber desto mehr verlieren Sie auch das allgemeine Bild aus 
          den Augen. Natürlich können Sie die <quote>gröberen</quote> Aggregate auch über separate 
          Abfragen erhalten.</para>

      <section id="fblangref25-dml-select-groupby-having-de">
        <title><database>HAVING</database></title>

        <para>Genau wie eine <database>WHERE</database>-Klausel die Zeilen in einer Datenmenge auf solche 
        begrenzt, die die Suchbedingung erfüllen, so beschränkt die Unterklasse <database>HAVING</database> 
        die aggregierten Zeilen in einer gruppierten Gruppe. <database>HAVING</database> ist optional 
        und kann nur in Verbindung mit <database>GROUP BY</database> verwendet werden.</para>

        <para>Die Bedingung(en) in der <database>HAVING</database>-Klausel können sich beziehen auf:</para>

        <itemizedlist>
          <listitem>
            <para>Jede aggregierte Spalte in der Auswahlliste. Dies ist die am häufigsten verwendete Alternative.</para>
          </listitem>

          <listitem>
            <para>Jeder aggregierte Ausdruck, der nicht in der Auswahlliste enthalten ist, aber im Kontext der Abfrage 
                zulässig ist. Dies ist manchmal auch nützlich.</para>
          </listitem>

          <listitem>
            <para>Eine beliebige Spalte in der Liste <database>GROUP BY</database>. Obwohl dies legal ist, ist es effizienter, 
            diese nicht aggregierten Daten zu einem früheren Zeitpunkt zu filtern: in der Klausel <database>WHERE</database>.</para>
          </listitem>

          <listitem>
            <para>Ein beliebiger Ausdruck, dessen Wert nicht vom Inhalt des Datasets abhängt (wie eine Konstante oder eine Kontextvariable). 
                Das ist zwar stichhaltig, aber völlig sinnlos, weil es entweder die gesamte Menge unterdrückt oder sie unberührt lässt, 
                basierend auf Bedingungen, die nichts mit der Menge selbst zu tun haben.</para>
          </listitem>
        </itemizedlist>

        <para>Eine <database>HAVING</database>-Klausel kann
        <emphasis>nicht</emphasis> enthalten:</para>

        <itemizedlist>
          <listitem>
            <para>Nicht aggregierte Spaltenausdrücke, die nicht in der <database>GROUP BY</database>-Liste 
                enthalten sind.</para>
          </listitem>

          <listitem>
            <para>Spaltenpositionen. Eine Ganzzahl in der <database>HAVING</database>-Klausel ist nur eine Ganzzahl.</para>
          </listitem>

          <listitem>
            <para>Spaltenaliase - nicht einmal wenn sie in der
            <database>GROUP BY</database>-Klausel vorkommen!<!--Is that by design? Test also in 2.5--></para>
          </listitem>
        </itemizedlist>

        <bridgehead renderas="sect4">Beispiele</bridgehead>

        <para>Aufbauend auf unseren früheren Beispielen könnte dies verwendet werden, um kleine Gruppen von Schülern zu überspringen:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having count(*) &gt;= 5</programlisting>
        </blockquote>

        <para>So wählen Sie nur Gruppen mit einem Mindestalter aus:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having max(age) - min(age) &gt; 1.2</programlisting>
        </blockquote>

        <para>Beachten Sie, dass Sie, wenn Sie wirklich an diesen Informationen interessiert sind, 
            diese normalerweise einschließen würden mittels <literal>min(age)</literal> und
        <literal>max(age)</literal> – oder dem Ausdruck
        <quote><literal>max(age)</literal> <literal>-</literal>
        <literal>min(age)</literal></quote> – auch in der Select-Liste!</para>

        <para>Um nur die 3. Klassen einzuschließen:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having class starting with '3'</programlisting>
        </blockquote>

        <para>Besser wäre es, diese Bedingung in die <database>WHERE</database>-Klausel 
        zu verschieben:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M' and class starting with '3'
  group by class</programlisting>
        </blockquote>
      </section> <!-- HAVING -->
    </section> <!-- GROUP BY -->

    <section id="fblangref25-dml-select-plan-de">
      <title>Die <database>PLAN</database>-Klausel</title>

      <para>Die <database>PLAN</database>-Klausel ermöglicht es dem Benutzer, einen Datenabrufplan 
      einzureichen, wodurch der Plan überschrieben wird, den der Optimierer automatisch erstellt hätte.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>PLAN <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;plan-expr&gt;</replaceable>    ::=  (<replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])
                    | <replaceable>&lt;sorted-item&gt;</replaceable>
                    | <replaceable>&lt;joined-item&gt;</replaceable>
                    | <replaceable>&lt;merged-item&gt;</replaceable>

<replaceable>&lt;sorted-item&gt;</replaceable>  ::=  SORT (<replaceable>&lt;plan-item&gt;</replaceable>)

<replaceable>&lt;joined-item&gt;</replaceable>  ::=  JOIN (<replaceable>&lt;plan-item&gt;</replaceable>, <replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])

<replaceable>&lt;merged-item&gt;</replaceable>  ::=  [SORT] MERGE (<replaceable>&lt;sorted-item&gt;</replaceable>, <replaceable>&lt;sorted-item&gt;</replaceable> [, <replaceable>&lt;sorted-item&gt;</replaceable> ...])

<replaceable>&lt;plan-item&gt;</replaceable>    ::=  <replaceable>&lt;basic-item&gt;</replaceable> | <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;basic-item&gt;</replaceable>   ::=  <replaceable>&lt;relation&gt;</replaceable>
                    {NATURAL
                     | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)
                     | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;relation&gt;</replaceable>     ::=  <replaceable>table</replaceable>
                    | <replaceable>view</replaceable> [<replaceable>table</replaceable>]

<replaceable>&lt;indexlist&gt;</replaceable>    ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]
          </programlisting>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-dml-tbl-plan-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente der PLAN-Klausel</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">table</entry>
              <entry align="left">Tabellenname oder sein Alias</entry>
            </row>
            <row valign="middle">
              <entry align="center">view</entry>
              <entry align="left">Ansichtname</entry>
            </row>
            <row valign="middle">
              <entry align="center">index</entry>
              <entry align="left">Indexname</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Jedes Mal, wenn ein Benutzer eine Abfrage an die Firebird-Engine sendet, berechnet 
          der Optimierer eine Datenabrufstrategie. Die meisten Firebird Clients können diesen 
          Abrufplan für den Benutzer sichtbar machen. In Firebirds eigenem 
          <application>isql</application>-Dienstprogramm geschieht dies mit dem Befehl 
          <database>SET PLAN ON</database>. Wenn Sie Abfragepläne analysieren und keine Abfragen 
          ausführen, zeigt <database>SET PLANONLY ON</database> den Plan an, ohne die Abfrage 
          auszuführen.</para>

      <para>In den meisten Situationen können Sie darauf vertrauen, dass Firebird den optimalen 
          Abfrageplan für Sie auswählt. Wenn Sie jedoch komplizierte Abfragen haben, die nicht 
          leistungsfähig sind, lohnt es sich möglicherweise, den Plan zu prüfen und zu prüfen, 
          ob Sie ihn verbessern können.</para>

      <section id="fblangref25-dml-select-plan-simple-de">
        <title>Einfache Pläne</title>

        <para>Die einfachsten Pläne bestehen nur aus einem Beziehungsnamen gefolgt von einer Abrufmethode. 
            Z. B. für eine unsortierte Ein-Tabellen-Auswahl ohne eine <database>WHERE</database>-Klausel:</para>

        <blockquote>
          <programlisting>select * from students
  plan (students natural)</programlisting>
        </blockquote>

        <para>Wenn eine <database>WHERE</database>- oder eine <database>HAVING</database>-Klausel 
        vorhanden ist, können Sie den Index angeben, der zum Auffinden von Übereinstimmungen verwendet 
        werden soll:</para>

        <blockquote>
          <programlisting>select * from students
  where class = '3C'
  plan (students index (ix_stud_class))</programlisting>
        </blockquote>

        <para>Die Anweisung <database>INDEX</database> wird auch für Join-Bedingungen 
        verwendet (etwas später diskutiert). Es kann eine Liste von Indizes enthalten, 
        die durch Kommata getrennt sind.</para>

        <para><database>ORDER</database> gibt den Index zum Sortieren des Satzes an, wenn 
        eine Klausel <database>ORDER BY</database> oder <database>GROUP BY</database> vorhanden ist:</para>

        <blockquote>
          <programlisting>select * from students
  plan (students order pk_students)
  order by id</programlisting>
        </blockquote>

        <para><database>ORDER</database> und <database>INDEX</database> können kombiniert
        werden:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan (students order pk_students index (ix_stud_class))
  order by id</programlisting>
        </blockquote>

        <para>Es ist völlig in Ordnung, wenn <database>ORDER</database> und <database>INDEX</database> 
        denselben Index angeben:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan (students order ix_stud_class index (ix_stud_class))
  order by class</programlisting>
        </blockquote>

        <para>Wenn Sie einen Sortiersatz verwenden möchten, wenn kein verwendbarer Index verfügbar ist 
            (oder wenn Sie die Verwendung des Index unterdrücken möchten), lassen Sie <database>ORDER</database> 
            aus und stellen Sie dem Planausdruck <database>SORT</database> voran:</para>

        <blockquote>
          <programlisting>select * from students
  plan sort (students natural)
  order by name</programlisting>
        </blockquote>

        <para>Oder wenn ein Index für die Suche verwendet wird:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan sort (students index (ix_stud_class))
  order by name</programlisting>
        </blockquote>

        <para>Beachten Sie, dass sich <database>SORT</database> im Gegensatz zu 
        <database>ORDER</database> außerhalb der Klammern befindet. Dies spiegelt 
        die Tatsache wider, dass die Datenzeilen ungeordnet abgerufen und anschließend 
        von der Engine sortiert werden.</para>

        <para>Geben Sie bei der Auswahl aus einer Ansicht die Ansicht und die betreffende 
            Tabelle an. Zum Beispiel, wenn Sie eine Ansicht <database>FRESHMEN</database> 
            haben, die nur die Erstsemester auswählt:</para>

        <blockquote>
          <programlisting>select * from freshmen
  plan (freshmen students natural)</programlisting>
        </blockquote>

        <para>Oder zum Beispiel:</para>

        <blockquote>
          <programlisting>select * from freshmen
  where id &gt; 10
  plan sort (freshmen students index (pk_students))
  order by name desc</programlisting>
        </blockquote>
        <important>
          <para>Wenn eine Tabelle oder Sicht mit einem Alias versehen wurde, muss der 
              Alias und nicht der ursprüngliche Name in der Klausel <database>PLAN</database> 
              verwendet werden.</para>
        </important>
      </section>

      <section id="fblangref25-dml-select-plan-composite-de">
        <title>Zusammengesetzte Pläne</title>

        <para>Wenn ein Join erstellt wird, können Sie den Index angeben, 
            der für den Abgleich verwendet werden soll. Sie müssen auch die 
            Anweisung <database>JOIN</database> für die beiden Streams im Plan verwenden:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan join (s natural, c index (pk_classes))</programlisting>
        </blockquote>

        <para>Derselbe Join, sortiert nach einer indizierten Spalte:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan join (s order pk_students, c index (pk_classes))
  order by s.id</programlisting>
        </blockquote>

        <para>Und auf einer nicht indizierten Spalte:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan sort (join (s natural, c index (pk_classes)))
  order by s.name</programlisting>
        </blockquote>

        <para>Mit einer Suche hinzugefügt:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  where s.class &lt;= '2'
  plan sort (join (s index (fk_student_class), c index (pk_classes)))
  order by s.name</programlisting>
        </blockquote>

        <para>Als linker Outer Join:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from classes c
  left join students s on c.name = s.class
  where s.class &lt;= '2'
  plan sort (join (c natural, s index (fk_student_class)))
  order by s.name</programlisting>
        </blockquote>

        <para>Wenn für die Join-Kriterien kein Index verfügbar ist 
            (oder wenn Sie ihn nicht verwenden möchten), muss der 
            Plan zuerst beide Streams in ihren Join-Spalten sortieren 
            und dann zusammenführen. Dies wird mit der Anweisung <database>SORT</database> 
            (die wir bereits erreicht haben) und <database>MERGE</database> anstelle von 
            <database>JOIN</database> erreicht:
        </para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  plan merge (sort (c natural), sort (s natural))</programlisting>
        </blockquote>

        <para>Durch das Hinzufügen einer <database>ORDER BY</database>-Klausel
        muss das Ergebnis der Zusammenführung ebenfalls sortiert werden:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  plan sort (merge (sort (c natural), sort (s natural)))
  order by c.name, s.id</programlisting>
        </blockquote>

        <para>Schließlich fügen wir eine Suchbedingung für zwei indexierbare Spalten 
            der Tabelle <database>STUDENTS</database> hinzu:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  where s.id &lt; 10 and s.class &lt;= '2'
  plan sort (merge (sort (c natural),
                    sort (s index (pk_students, fk_student_class))))
  order by c.name, s.id</programlisting>
        </blockquote>

        <para>Wie aus der formalen Syntaxdefinition hervorgeht, können 
            <database>JOIN</database>s und <database>MERGE</database>s im Plan mehr 
            als zwei Datenströme kombinieren. Außerdem kann jeder Planausdruck als 
            Planposten in einem umfassenden Plan verwendet werden. Dies bedeutet, 
            dass Pläne bestimmter komplizierter Abfragen verschiedene 
            Verschachtelungsebenen haben können.</para>

        <para>Schließlich können Sie anstelle von <database>MERGE</database> auch 
        <database>SORT MERGE</database> schreiben. Da dies absolut keinen Unterschied
        macht und zu Verwechslungen mit <quote>real</quote> 
        <database>SORT</database>-Direktiven führen kann (diejenigen, die etwas
        <emphasis>tun</emphasis> machen einen Unterschied), ist es wahrscheinlich 
        am besten zu bleiben zu einfach <database>MERGE</database>.</para>

        <warning>
          <para>Gelegentlich akzeptiert der Optimierer einen Plan und folgt ihm dann 
              nicht, obwohl er ihn nicht als ungültig zurückweist. Ein solches Beispiel war
          <blockquote><literallayout class="monospaced">MERGE (unsortierter Stream, unsortierter Stream)
          </literallayout></blockquote>
          Es ist ratsam, einen solchen Plan als <quote>veraltet</quote> zu behandeln .
          </para>
        </warning>
      </section>
    </section>

    <section id="fblangref25-dml-select-union-de">
      <title><database>UNION</database></title>

      <para>Ein <database>UNION</database> verkettet zwei oder mehr Datasets 
      und erhöht so die Anzahl der Zeilen, nicht aber die Anzahl der Spalten. 
      Datasets, die an einer <database>UNION</database> teilnehmen, müssen 
          die gleiche Anzahl von Spalten haben, und Spalten an entsprechenden 
          Positionen müssen vom selben Typ sein. Abgesehen davon können sie 
          völlig unabhängig sein.</para>

      <para>Standardmäßig unterdrückt eine Union doppelte Zeilen. <database>UNION ALL</database> 
      zeigt alle Zeilen einschließlich aller Duplikate an. Das optionale Schlüsselwort 
      <database>DISTINCT</database> macht das Standardverhalten explizit.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting><replaceable>&lt;union&gt;</replaceable>               ::=  <replaceable>&lt;individual-select&gt;</replaceable>
                           UNION [DISTINCT | ALL]
                           <replaceable>&lt;individual-select&gt;</replaceable>
                           [UNION [DISTINCT | ALL]
                            <replaceable>&lt;individual-select&gt;</replaceable>
                            ...]
                           [<replaceable>&lt;union-wide-clauses&gt;</replaceable>]

<replaceable>&lt;individual-select&gt;</replaceable>   ::=  SELECT
                           [TRANSACTION <replaceable>name</replaceable>]
                           [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
                           [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>
                           [INTO <replaceable>&lt;host-varlist&gt;</replaceable>]
                           FROM <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>]
                           [<replaceable>&lt;joins&gt;</replaceable>]
                           [WHERE <replaceable>&lt;condition&gt;</replaceable>]
                           [GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>
                           [HAVING <replaceable>&lt;aggregate-condition&gt;</replaceable>]]
                           [PLAN <replaceable>&lt;plan-expr&gt;</replaceable>]

<replaceable>&lt;union-wide-clauses&gt;</replaceable>  ::=  [ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>]
                           [ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]
                           [FOR UPDATE [OF <replaceable>&lt;columns&gt;</replaceable>]]
                           [WITH LOCK]
                           [INTO <replaceable>&lt;PSQL-varlist&gt;</replaceable>]</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Unions ermitteln ihre Spaltennamen aus der <emphasis>ersten</emphasis> Abfrage. 
      Wenn Sie einen Alias für Vereinigungsspalten verwenden möchten, tun Sie dies in der 
      Spaltenliste des obersten <database>SELECT</database>. Aliasnamen in anderen 
      teilnehmenden Selects sind zulässig und können sogar nützlich sein, werden jedoch 
      nicht auf Unionsebene weitergegeben.</para>

      <para>Wenn eine Union eine <database>ORDER BY</database>-Klausel hat, sind die einzigen 
      zulässigen Sortierelemente Integerliterale, die 1-basierte Spaltenpositionen angeben, 
      optional gefolgt von einem
      <database>ASC</database>/<database>DESC</database> und/oder einer
      <database>NULLS</database>
      <database>FIRST</database>/<database>LAST</database>-Direktive. Dies bedeutet auch, 
      dass Sie eine Union nicht nach etwas sortieren können, die keine Spalte in der 
      Union ist. (Sie können jedoch eine abgeleitete Tabelle einfügen, die Ihnen alle 
      üblichen Sortieroptionen zurückgibt.)</para>

      <para>Unions sind in Unterabfragen jeglicher Art erlaubt und können selbst Unterabfragen 
          enthalten. Sie können auch Joins enthalten und an einem Join teilnehmen, wenn sie in 
          eine abgeleitete Tabelle eingebunden werden.</para>

      <bridgehead renderas="sect4">Beispiele</bridgehead>

      <para>Diese Abfrage präsentiert Informationen aus verschiedenen Musiksammlungen in 
          einem Datensatz mithilfe von Unionen:
      <blockquote>
        <programlisting>select id, title, artist, length, 'CD' as medium
  from cds
union
select id, title, artist, length, 'LP'
  from records
union
select id, title, artist, length, 'MC'
  from cassettes
order by 3, 2  -- artist, title</programlisting>
      </blockquote>

      Wenn <literal>id</literal>, <literal>title</literal>,
      <literal>artist</literal> und <literal>length</literal> die einzigen
      Felder in den involvierten Tabellen sind, kann die Abfrage auch so geschrieben
      werden:
      <blockquote>
        <programlisting>select c.*, 'CD' as medium
  from cds c
union
select r.*, 'LP'
  from records r
union
select c.*, 'MC'
  from cassettes c
order by 3, 2  -- artist, title</programlisting>
      </blockquote>
      </para>
      <para>Das Qualifizieren der <quote>Sternchen</quote> ist hier notwendig, da 
      sie nicht das einzige Element in der Spaltenliste sind. Beachten Sie, 
      dass die Aliase von <quote>c</quote> in der ersten und dritten Auswahl 
      nicht miteinander in Konflikt stehen: ihre Gültigkeitsbereiche sind 
      nicht unionsweit, sondern gelten nur für ihre jeweiligen Auswahlabfragen.</para>

      <para>Die nächste Abfrage ruft Namen und Telefonnummern von Übersetzern und Korrektoren 
          ab. Übersetzer, die auch als Korrekturleser arbeiten, werden nur einmal im Ergebnis 
          angezeigt, sofern ihre Telefonnummer in beiden Tabellen identisch ist. Das gleiche 
          Ergebnis kann ohne <database>DISTINCT</database> erzielt werden. Mit 
          <database>ALL</database> würden diese Personen zweimal angezeigt.
      <blockquote>
        <programlisting>select name, phone from translators
  union distinct
select name, telephone from proofreaders</programlisting>
      </blockquote>
      </para>
      <para>Ein <database>UNION</database> innerhalb einer Unterabfrage:
      <blockquote>
        <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
      </blockquote></para>
    </section>

    <section id="fblangref25-dml-select-orderby-de">
      <title><database>ORDER BY</database></title>
      <para>Wenn eine <database>SELECT</database>-Anweisung ausgeführt wird, 
      ist die Ergebnismenge in keiner Weise sortiert. Es kommt häufig vor,
      dass Zeilen chronologisch sortiert angezeigt werden, weil sie in derselben 
      Reihenfolge zurückgegeben werden, in der sie von 
      <database>INSERT</database>-Anweisungen zur Tabelle hinzugefügt wurden. 
      Um eine Sortierreihenfolge für die Mengenspezifikation anzugeben, wird eine 
      <database>ORDER BY</database>-Klausel verwendet.</para>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
SELECT ... FROM ...
...
ORDER BY &lt;ordering-item&gt; [, &lt;ordering-item&gt; &hellip;]

&lt;ordering-item&gt; ::=
  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
  [COLLATE <replaceable>collation-name</replaceable>]
  [ASC[ENDING] | DESC[ENDING]]
  [NULLS {FIRST|LAST}]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-dml-tbl-orderby-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente für die ORDER BY-Klausel</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">col-name</entry>
              <entry align="left">Vollständiger Spaltenname</entry>
            </row>
            <row valign="middle">
              <entry align="center">col-alias</entry>
              <entry align="left">Spaltenalias</entry>
            </row>
            <row valign="middle">
              <entry align="center">col-position</entry>
              <entry align="left">Spaltenposition in der SELECT-Liste</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Jeder Ausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation-name</entry>
              <entry align="left">Collations-Name (Sortierreihenfolge für String-Typen)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <bridgehead renderas="sect4">Beschreibung</bridgehead>
      <para>Die <database>ORDER BY</database>-Klausel besteht aus einer durch Komma getrennten 
      Liste der Spalten, auf denen der Ergebnisdatensatz sortiert werden soll. Die 
      Sortierreihenfolge kann durch den Namen der Spalte&mdash;angegeben werden, 
      jedoch nur, wenn die Spalte zuvor in der Spaltenliste <database>SELECT</database> 
      nicht mit einem Alias versehen war. Der Alias muss verwendet werden, wenn er dort 
      verwendet wurde. Die Ordnungsnummer der Spalte, des Alias, der der 
      Spalte in der SELECT-Liste mit Hilfe des Schlüsselworts AS zugewiesen wurde, oder 
      die Nummer der Spalte in der Liste <database>SELECT</database> können uneingeschränkt 
      verwendet werden.</para>
      <para>Die drei Arten, die Spalten für die Sortierreihenfolge auszudrücken, können in der 
          gleichen <database>ORDER BY</database>-Klausel gemischt werden. Zum Beispiel kann 
          eine Spalte in der Liste durch ihren Namen spezifiziert werden und eine andere 
          Spalte kann durch ihre Nummer spezifiziert werden.</para>
      <note>
        <para>Wenn Sie die Spaltenposition verwenden, um die Sortierreihenfolge für eine Abfrage des 
            <constant>SELECT * </constant>-Stils anzugeben, erweitert der Server das Sternchen auf 
            die vollständige Spaltenliste, um die Spalten für die Sortierung zu bestimmen. Es wird 
            jedoch als <quote>schlampige Praxis</quote> angesehen, um auf diese Weise geordnete 
            Mengen zu entwerfen.</para>
      </note>
      <section id="fblangref25-dml-select-orderby-direction-de">
        <title>Sortierrichtung</title>
        <para>Das Schlüsselwort <database>ASCENDING</database>, normalerweise abgekürzt als 
        <database>ASC</database>, gibt eine Sortierrichtung vom niedrigsten zum höchsten an. 
        <database>ASCENDING</database> ist die Standardsortierrichtung.</para>
        <para>Das Schlüsselwort <database>DESCENDING</database>, normalerweise abgekürzt als 
        <database>DESC</database>, gibt eine Sortierrichtung vom höchsten zum niedrigsten an.</para>
        <para>Angeben der aufsteigenden Reihenfolge für eine Spalte und der absteigenden Reihenfolge 
            für eine andere Spalte ist zulässig.</para>
      </section>

      <section id="fblangref25-dml-select-orderby-collation-de">
        <title>Collations-Reihenfolge</title>
        <para>Das Schlüsselwort <database>COLLATE</database> gibt die Sortierreihenfolge für eine 
        Zeichenfolgespalte an, wenn Sie eine Sortierung benötigen, die sich von der normalen 
        Sortierung für diese Spalte unterscheidet. Die normale Sortierreihenfolge ist entweder 
        die Standardreihenfolge für den Datenbankzeichensatz oder eine, die explizit in der 
        Definition der Spalte festgelegt wurde.</para>
      </section>

      <section id="fblangref25-dml-select-orderby-nullsposition-de">
        <title>NULLen positionieren</title>
        <para>Das Schlüsselwort <database>NULLS</database> gibt an, wo NULL in der betroffenen Spalte
        in der Sortierung stehen wird:<database>NULLS FIRST</database> platziert die Zeilen mit der
        <database>NULL</database>-Spalte <emphasis>oberhalb</emphasis> der Zeilen mit den Spaltenwerten;
        <database>NULLS LAST</database> platziert diese Zeilen <emphasis>hinter</emphasis> den
        Spaltenwerten.</para>
        <para><database>NULLS FIRST</database> ist der Standard.</para>
      </section>

      <section id="fblangref25-dml-select-orderby-unions-de">
        <title>Sortieren von <database>UNION</database>-Sätzen</title>
        <para>Die einzelnen Abfragen, die zu einer <database>UNION</database> beitragen, 
        können keine <database>ORDER BY</database>-Klausel verwenden. Die einzige Option 
        besteht darin, die gesamte Ausgabe mit einer <database>ORDER BY</database>-Klausel 
        am Ende der gesamten Abfrage zu sortieren.</para>
        <para>Das einfachste&mdash;und in einigen Fällen die einzige&mdash;Methode zum 
            Angeben der Sortierreihenfolge ist die Ordinalspaltenposition. Es ist jedoch 
            auch zulässig, die Spaltennamen oder Aliase <emphasis>nur</emphasis> 
            aus der ersten beitragenden Abfrage zu verwenden.</para>
        <para>Die Anweisungen <database>ASC / DESC</database> und / oder <database>NULLS</database> 
        sind für diese globale Gruppe verfügbar.</para>
        <para>Wenn eine diskrete Reihenfolge innerhalb der beitragenden Menge erforderlich ist, 
            kann die Verwendung von abgeleiteten Tabellen oder allgemeinen Tabellenausdrücken für 
            diese Mengen eine Lösung sein.</para>
      </section>

      <bridgehead renderas="sect4">Beispiele</bridgehead>
      <para>Sortierung der Ergebnismenge in aufsteigender Reihenfolge, Sortierung nach den Spalten
          RDB$CHARACTER_SET_ID, RDB$COLLATION_ID der Tabelle DB$COLLATIONS:
        <blockquote><programlisting>
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY RDB$CHARACTER_SET_ID, RDB$COLLATION_ID
        </programlisting></blockquote>
      Das Gleiche, aber Sortieren nach den Spaltenaliasnamen:
        <blockquote><programlisting>
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY CHARSET_ID, COLL_ID
        </programlisting></blockquote>
      </para>
      <para>Sortieren der Ausgabedaten nach den Spaltenpositionsnummern:
        <blockquote><programlisting>
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY 1, 2
        </programlisting></blockquote>
      </para>
      <para>Sortierung einer <database>SELECT *</database>-Abfrage nach 
      Positionsnummern möglich, aber <emphasis>hässlich</emphasis> und nicht empfohlen:
        <blockquote><programlisting>
SELECT *
FROM RDB$COLLATIONS
ORDER BY 3, 2
        </programlisting></blockquote>
      </para>
      <para>Sortierung nach der zweiten Spalte in der BOOKS-Tabelle:
        <blockquote><programlisting>
SELECT
    BOOKS.*,
    FILMS.DIRECTOR
FROM BOOKS, FILMS
ORDER BY 2
        </programlisting></blockquote>
      </para>
      <caution>
        <para>Ausdrücke, deren Berechnungsergebnisse nicht negative ganze Zahlen sind, 
            werden als Spaltenpositionszahlen interpretiert und verursachen eine Ausnahme, 
            wenn sie außerhalb des Bereichs von 1 bis zur Anzahl der Spalten liegen.
          <formalpara>
            <title>Beispiel</title>
            <blockquote><literallayout class="monospaced">
SELECT
  X, Y, NOTE
FROM PAIRS
ORDER BY X+Y DESC
            </literallayout></blockquote>
          </formalpara>
          <itemizedlist>
            <listitem>Die von einer Funktion oder Prozedur zurückgegebene Zahl ist nicht vorhersehbar, 
                unabhängig davon, ob die Sortierreihenfolge durch den Ausdruck selbst oder durch die 
                Spaltennummer definiert ist.</listitem>
            <listitem>Nur nicht negative ganze Zahlen werden als Spaltennummern interpretiert</listitem>
            <listitem>Eine Ganzzahl, die durch einmalige Auswertung eines Ausdrucks oder durch Parametersubstitution 
                erhalten wurde, wird als Konstante gespeichert, da dieser Wert für alle Zeilen gilt.</listitem>
          </itemizedlist>
        </para>
      </caution>

      <bridgehead renderas="sect4">Beispiele, Fortsetzung</bridgehead>
      <para>Sortierung in absteigender Reihenfolge nach den Werten der Spalte PROCESS_TIME, wobei NULL am Anfang der Menge steht:
        <blockquote><programlisting>
SELECT *
FROM MSG
ORDER BY PROCESS_TIME DESC NULLS FIRST
        </programlisting></blockquote>
       </para>
       <para>Sortieren der Menge, die von einer <database>UNION</database> von zwei 
       Abfragen erhalten wurde. Die Ergebnisse werden in absteigender Reihenfolge für 
       die Werte in der zweiten Spalte sortiert, wobei <constant>NULL</constant>en 
       am Ende der Menge stehen; und in aufsteigender Reihenfolge für die Werte der 
       ersten Spalte mit <constant>NULL</constant>en am Anfang.
        <blockquote><programlisting>
SELECT
  DOC_NUMBER, DOC_DATE
FROM PAYORDER
UNION ALL
SELECT
  DOC_NUMBER, DOC_DATE
FROM BUDGORDER
ORDER BY 2 DESC NULLS LAST, 1 ASC NULLS FIRST
        </programlisting></blockquote>
      </para>
    </section> <!-- ORDER BY -->

    <section id="fblangref25-dml-select-rows-de">
      <title><database>ROWS</database></title>
      <formalpara>
        <title>Verwendet für</title>
        <para>&nbsp;Abrufen eines Stücks von Zeilen aus einer geordneten Menge</para>
      </formalpara>

      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
              <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]
           </programlisting>
           </blockquote>
        </para>
      </formalpara>
      <table id="fblangref25-dml-tbl-rows-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente für die ROWS-Klausel</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">Beliebiger Integer-Ausdrücke</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <formalpara>
        <title>Beschreibung</title>

        <para>Begrenzt die Anzahl der Zeilen, die von der Anweisung <database>SELECT</database>
        an eine angegebene Zahl oder einen angegebenen Bereich zurückgegeben werden.</para>
      </formalpara>
      <para>Die Klauseln <database>FIRST</database> und <database>SKIP</database> haben die gleiche 
      Aufgabe wie <database>ROWS</database> sind jedoch nicht SQL-konform. Die Verwendung von 
      <database>ROWS</database> ist daher im neuen Code vorzuziehen. Im Gegensatz zu <database>FIRST</database> 
      und <database>SKIP</database> akzeptieren die Klauseln <database>ROWS</database> und 
      <database>TO</database> beliebige Integerausdrücke als Argumente ohne Klammern. Natürlich können Klammern 
      für verschachtelte Auswertungen innerhalb des Ausdrucks noch immer benötigt werden und eine 
      Unterabfrage muss immer in Klammern eingeschlossen sein.</para>

      <important>
        <itemizedlist>
          <listitem>Nummerierung der Zeilen in der Zwischenmenge&mdash;die Gesamtmenge, die auf der 
              Festplatte zwischengespeichert wird, bevor die <quote>Scheibe</quote> extrahiert 
              wird&mdash;beginnt bei 1.</listitem>
          <listitem>Sowohl <database>FIRST / SKIP</database> als auch <database>ROWS</database> 
            können ohne <database>ORDER BY</database>-Klausel verwendet werden, obwohl dies 
            selten sinnvoll ist, es sei denn Sie möchten nur einen kurzen Blick auf die 
            Tabellendaten werfen und es ist nicht wichtig, dass Zeilen in zufälliger 
            Reihenfolge stehen. Zu diesem Zweck würde eine Abfrage wie 
            <quote><function>SELECT * FROM TABLE1 ROWS 20</function></quote> die ersten 20 Zeilen 
            anstelle einer ganzen Tabelle, die ziemlich groß sein könnte, zurückgeben.</listitem>
        </itemizedlist>
      </important>

      <para>Der Aufruf von <database>ROWS</database> <replaceable>m</replaceable> gibt die 
      ersten <replaceable>m</replaceable> Zeilen des angegebenen Satzes zurück.</para>

      <bridgehead renderas="sect4">Merkmale der Verwendung von
      <database>ROWS</database> <replaceable>m</replaceable> ohne eine 
      <database>TO</database>-Klausel:</bridgehead>

      <itemizedlist spacing="compact">
        <listitem>Wenn <replaceable>m</replaceable> größer als die Gesamtzahl der Datensätze 
        im Zwischendatensatz ist, wird die gesamte Menge zurückgegeben</listitem>
        <listitem>Wenn <replaceable>m</replaceable> = 0, wird ein leerer Satz zurückgegeben</listitem>
        <listitem>Wenn <replaceable>m</replaceable> &lt; 0, wird der <database>SELECT</database>-Aufruf
        in einem Fehler enden</listitem>
      </itemizedlist>

      <para>Der Aufruf von <database>ROWS</database> <replaceable>m</replaceable> <database>TO</database>
      <replaceable>n</replaceable> gibt die Zeilen aus dem Satz zurück, beginnend mit Zeile
      <replaceable>m</replaceable> und endend nach Zeile <replaceable>n</replaceable>&mdash;inklusive
      Satz.</para>

      <bridgehead renderas="sect4">Merkmale der Verwendung von
      <database>ROWS</database> <replaceable>m</replaceable> mit einer 
      <database>TO</database>-Klausel:</bridgehead>
      <itemizedlist spacing="compact">
        <listitem>Wenn <replaceable>m</replaceable> größer ist als die Gesamtzahl der Zeilen in 
        der Zwischengruppe und <replaceable>n</replaceable> &lt; = <replaceable>m</replaceable>, 
        wird eine leere Menge zurückgegeben</listitem>
        <listitem>Ist <replaceable>m</replaceable> nicht größer als <replaceable>n</replaceable> 
        und <replaceable>n</replaceable> größer als die Gesamtzahl der Zeilen in der 
        Zwischengruppe, ist die Ergebnismenge beschränkt auf Zeilen beginnend mit 
        <replaceable>m</replaceable> bis zum Ende des Satzes</listitem>
        <listitem>Wenn <replaceable>m</replaceable> &lt; 1 und <replaceable>n</replaceable> 
        &lt; 1, schlägt der <database>SELECT</database>-Anweisungsaufruf mit einem Fehler 
        fehl</listitem>
        <listitem>Wenn <replaceable>n</replaceable> = <replaceable>m</replaceable> - 1 ist,
        wird eine leere Menge zurückgegeben</listitem>
        <listitem>Wenn <replaceable>n</replaceable> &lt; <replaceable>m</replaceable> - 1, 
        schlägt der Aufruf der Anweisung <database>SELECT</database> mit einem Fehler fehl</listitem>
      </itemizedlist>

      <bridgehead renderas="sect4">Verwenden einer <database>TO</database>-Klausel 
      ohne eine <database>ROWS</database>-Klausel:</bridgehead>
      <para>Während <database>ROWS</database> die nicht standardmäßige Syntax <database>FIRST</database> 
      und <database>SKIP</database> ersetzt, gibt es eine Situation, in der die Standardsyntax nicht 
      das gleiche Verhalten bietet: Mit Angabe von <database>SKIP</database> <replaceable>n</replaceable> 
      wird der gesamte Zwischensatz ohne die ersten <replaceable>n</replaceable>-Reihen zurückgegeben. 
      Die <database>ROWS</database> ... <database>TO</database>-Syntax benötigt ein wenig Hilfe, um dies 
      zu erreichen.</para>
      <para>Bei der Syntax <database>ROWS</database> benötigen Sie eine <database>ROWS</database>-Klausel 
      <emphasis>in Verbindung mit</emphasis> der <database>TO</database>-Klausel. Anschließend machen Sie
      das zweite Argument ( <replaceable>n</replaceable> ) größer als die Größe des Zwischendatensatzes. 
      Dies wird erreicht, indem ein Ausdruck für <replaceable>n</replaceable> erstellt wird, der eine 
      Unterabfrage verwendet, um die Anzahl der Zeilen in der Zwischengruppe abzurufen, und 1 dazu addiert.</para>

      <section id="fblangref25-dml-select-rows-mixing-de">
        <title>Das Mischen von <database>ROWS</database> und <database>FIRST / SKIP</database> </title> 
        <para>Die Syntax <database>ROWS</database> kann nicht mit der Syntax <database>FIRST / SKIP</database> 
        im selben <database>SELECT</database>-Ausdruck gemischt werden. Die Verwendung der verschiedenen Syntaxen 
        in verschiedenen Unterabfragen in derselben Anweisung ist jedoch zulässig.</para>
      </section>

      <section id="fblangref25-dml-select-rows-union-de">
        <title><database>ROWS</database>-Syntax in <database>UNION</database>-Abfragen</title>
        <para>Wenn <database>ROWS</database> in einer <database>UNION</database>-Abfrage verwendet wird,
        wird die <database>ROWS</database>-Direktive auf UNION-Satzes angewendet und muss hinter dem letzten
        <database>SELECT</database>-Statement stehen.</para>
        <para>Wenn es erforderlich ist, die Teilmengen zu begrenzen, die von einer oder mehreren 
            <database>SELECT</database>-Anweisungen innerhalb von UNION zurückgegeben werden, gibt es 
            eine Reihe von Optionen:
          <orderedlist>
            <listitem>Verwenden Sie die <database>FIRST / SKIP</database>-Syntax in diesen 
            <database>SELECT</database>-Anweisungen &mdash; bedenken Sie, dass eine ordering-Klausel 
            (<database>ORDER BY</database>) nicht lokal auf die einzelnen Abfragen angewendet werden kann, 
            aber nur für den kombinierten Ausgang.</listitem>
            <listitem>Konvertieren Sie die Abfragen in abgeleitete Tabellen mit ihren eigenen 
                <database>ROWS</database>-Klauseln.</listitem>
          </orderedlist>
        </para>
      </section>

      <bridgehead renderas="sect4">Beispiele</bridgehead>
      <para>Die folgenden Beispiele schreiben die <link linkend="firstskipexamples-de">Beispiele</link>
      des Abschnitts über <database>FIRST</database>
      und <database>SKIP</database>, 
      <link linkend="fblangref25-dml-select-first-skip-de">weiter oben in diesem Kapitel</link>, neu.</para>

      <para>Gib die ersten zehn Namen aus der Ausgabe einer sortierten Abfrage in der Tabelle PEOPLE aus:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 1 TO 10
        </programlisting></blockquote></para>
      <para>oder äquivalent dazu:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 10
        </programlisting></blockquote>
      </para>

      <para>Gib alle Datensätze aus der PEOPLE-Tabelle mit Ausnahme der ersten 10 Namen zurück:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 11 TO (SELECT COUNT(*) FROM People)
        </programlisting></blockquote>
      </para>
      <para>Und diese Abfrage gibt die letzten 10 Datensätze zurück (achten Sie auf die Klammern):
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS (SELECT COUNT(*) - 9 FROM People)
TO (SELECT COUNT(*) FROM People)
        </programlisting></blockquote>
      </para>
      <para>Diese gibt die Zeilen 81-100 aus der Tabelle PEOPLE zurück:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 81 TO 100
        </programlisting></blockquote>
      </para>
      <note>
        <para><database>ROWS</database> kann außerdem in Kombination mit den Anweisungen <link
        linkend="fblangref25-dml-update-de"><database>UPDATE</database></link> und
        <link
        linkend="fblangref25-dml-delete-de"><database>DELETE</database></link>
        verwendet werden.</para>
      </note>
    </section> <!-- ROWS -->

    <section id="fblangref-dml-for-update-de">
      <title><database>FOR UPDATE [OF]</database></title>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
          <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
          </programlisting>
        </blockquote></para>
      </formalpara>
      <para><database>FOR UPDATE</database> tut nicht, was es vorgibt. Der einzige Effekt ist derzeit, 
      den Pre-Fetch-Puffer zu deaktivieren.
        <tip>
          <para>Dies wird sich wahrscheinlich in Zukunft ändern: Es ist geplant, mit <database>FOR UPDATE</database> 
          markierte Cursor zu validieren, wenn sie wirklich aktualisierbar sind und positionierte Aktualisierungen 
          und Löschungen für Cursor ablehnen, die als nicht aktualisierbar eingestuft werden.</para>
        </tip>
      </para>
      <para>Die <database>OF</database>-Unterklausel tut rein gar nichts.</para>
    </section>
<!-- SELECT ... FOR UPDATE [OF] -->

    <section id="fblangref25-dml-with-lock-de">
      <title><database>WITH LOCK</database></title>

      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Verwendet für</title>
        <para>Begrenzte pessimistische Sperrung</para>
      </formalpara>

      <formalpara>
        <title>Beschreibung:</title>
        <para><database>WITH LOCK</database> bietet eine begrenzte explizite 
        pessimistische Sperrfunktion für die vorsichtige Verwendung unter Bedingungen, 
        bei denen für den betroffenen Zeilensatz Folgendes gilt:<orderedlist numeration="loweralpha"
            spacing="compact">
            <listitem>
              <para>extrem klein (idealerweise ein Singleton),
              <emphasis>und</emphasis></para>
            </listitem>

            <listitem>
              <para>genau gesteuert durch den Anwendungscode.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>
      <caution>
        <title>Dies ist nur für Experten!</title>

        <para>Die Notwendigkeit einer pessimistischen Sperre in Firebird ist in der Tat sehr selten und 
            sollte gut verstanden werden, bevor die Verwendung dieser Erweiterung in Betracht 
            gezogen wird.</para>
        <para>Es ist wichtig, die Auswirkungen der Transaktionsisolation und anderer Transaktionsattribute 
            zu verstehen, bevor Sie das explizite Sperren in Ihrer Anwendung implementieren.</para>
      </caution>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Wenn die <database>WITH LOCK</database>-Klausel erfolgreich ist, sichert sie eine 
      Sperre für die ausgewählten Zeilen und verhindert, dass eine andere Transaktion Schreibzugriff 
      auf eine dieser Zeilen oder deren abhängige Elemente erhält, bis die Transaktion endet.</para>

      <para><database>WITH LOCK</database> kann nur mit einer <database>SELECT</database>-Anweisung 
      der obersten Ebene verwendet werden. Es steht <emphasis>nicht</emphasis> zur Verfügung:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>in einer Unterabfrage-Spezifikation</para>
        </listitem>

        <listitem>
          <para>für Join-Sätze</para>
        </listitem>

        <listitem>
          <para>mit dem <database>DISTINCT</database>-Operator, einer
          <database>GROUP BY</database>-Klausel oder einer anderen Aggregat-Operation</para>
        </listitem>

        <listitem>
          <para>mit einer Ansicht</para>
        </listitem>

        <listitem>
          <para>mit der Ausgabe einer abfragbaren gespeicherten Prozedur</para>
        </listitem>

        <listitem>
          <para>mit einem externen Tabelle</para>
        </listitem>

        <listitem>
          <para>mti einer <database>UNION</database>-Abfrage</para>
        </listitem>

      </itemizedlist>

      <para>Da die Engine wiederum berücksichtigt, dass jeder Datensatz unter eine explizite Sperranweisung 
          fällt, gibt sie entweder die derzeit festgeschriebene Datensatzversion (zum Zeitpunkt als die Anweisung 
          gesendet wurde) zurück, unabhängig vom Datenbankstatus, oder eine Ausnahme.</para>
      <para>Das Warteverhalten und die Konfliktmeldung hängen von den im TPB-Block angegebenen 
          Transaktionsparametern ab:</para>
        <table id="fblangref25-tbl-tpb-effects-de">
          <title>Wie TPB-Einstellungen das explizite Sperren beeinflussen</title>
          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />
            <colspec align="left" colname="behaviour" colwidth="3*" />
            <thead>
              <row>
                <entry align="center">TPB-Modus</entry>
                <entry align="center">Verhalten</entry>
              </row>
            </thead>
            <tbody>
              <row valign="top">
                <entry><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explizite Sperren werden von impliziten oder expliziten 
                    Sperren auf Tabellenebene außer Kraft gesetzt und ignoriert.</para>
                </entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>Wenn ein Datensatz von einer Transaktion geändert wird, 
                    die festgeschrieben wurde, seit die Transaktion versucht hat, die explizite Sperre
                    zu starten, oder eine aktive Transaktion eine Änderung dieses Datensatzes durchgeführt
                    hat, wird sofort eine Aktualisierungskonfliktausnahme ausgelöst.</para>
                </entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>Wenn der Datensatz von einer Transaktion geändert wird, die 
                    seit dem Versuch der Ausführung der expliziten Sperre festgeschrieben wurde, 
                    wird sofort eine Ausnahme für den Aktualisierungskonflikt ausgelöst.</para>
                <para>Wenn eine aktive Transaktion den Besitz dieses Datensatzes innehat (durch explizites 
                    Sperren oder durch eine normale optimistische Schreibsperre), wartet die Transaktion, 
                    die die explizite Sperre verursacht, auf das Ergebnis der blockierenden Transaktion und, 
                    wenn sie beendet ist, versucht sie, die Sperre zu wieder aufzuheben. Wenn die 
                    blockierende Transaktion eine geänderte Version dieses Datensatzes erstellt hat, wird eine 
                    Ausnahme für den Aktualisierungskonflikt ausgelöst.</para>
                </entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>Wenn es eine aktive Transaktion gibt, die den Besitz für diesen 
                    Datensatz innehat (durch explizites Sperren oder normale Aktualisierung), wird sofort 
                    eine Aktualisierungskonfliktausnahme ausgelöst.</para>
                </entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>Wenn es eine aktive Transaktion gibt, die den Besitz dieses Datensatzes 
                    innehat (durch explizites Sperren oder durch eine normale optimistische Schreibsperre), wartet 
                    die Transaktion, die die explizite Sperre verursacht, auf das Ergebnis der Blockierungstransaktion 
                    und wenn sie beendet ist, versucht sie die Sperre zu wieder aufzuheben.</para>
                <para>Aktualisierungskonfliktausnahmen können niemals durch eine explizite Sperranweisung in 
                    diesem TPB-Modus ausgelöst werden.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      <section id="fblangref25-dml-withlock-forupdate-de">
        <title>Verwendung einer <database>FOR UPDATE</database>-Klausel</title>
        <para>Wenn die Unterklausel <database>FOR UPDATE</database> der Unterklausel 
        <database>WITH LOCK</database> vorangestellt ist, werden gepufferte Abrufe unterdrückt. 
        Somit wird die Sperre zum Zeitpunkt des Abrufens auf jede Zeile einzeln angewendet. 
        Es wird dann möglich, dass eine Sperre, die bei Anforderung erfolgreich zu sein scheint, 
        trotzdem <emphasis>anschließend fehlschlägt</emphasis>, wenn versucht wird, eine Zeile abzurufen, 
        die in der Zwischenzeit durch eine andere Transaktion gesperrt wurde.
          <tip>
            <para>Als eine Alternative kann es in Ihren Zugriffskomponenten möglich sein, die Größe 
                des Abrufpuffers auf 1 zu setzen. Dies würde es Ihnen ermöglichen, die aktuell gesperrte Zeile 
                zu verarbeiten, bevor die nächste geholt und gesperrt wird, oder Fehler zu behandeln, ohne 
                ihre Transaktion zurückzurollen.</para>
          </tip>
        </para>
        <note>
          <title>OF &lt;Spaltennamen&gt;</title>
          <para>Diese optionale Unterklausel macht überhaupt nichts.</para>
        </note>
        <formalpara>
          <title>Siehe auch</title>
          <para><link linkend="fblangref-dml-for-update-de"><database>FOR UPDATE [OF]</database></link></para>
        </formalpara>
      </section>

      <section id="fblangref25-dml-withlock-engine-de">
        <title>Wie die Engine mit <database>WITH LOCK</database> umgeht</title>
        <para>Wenn eine <database>UPDATE</database>-Anweisung versucht, auf einen Datensatz 
        zuzugreifen, der durch eine andere Transaktion gesperrt ist, löst sie abhängig vom 
        TPB-Modus entweder eine Aktualisierungskonfliktausnahme aus oder wartet auf den Abschluss 
        der Sperrtransaktion. Das Verhalten der Engine ist hier so, als wäre dieser Datensatz 
        bereits durch die Sperrtransaktion modifiziert worden.</para>
        <para>Bei Konflikten mit pessimistischen Sperren werden keine speziellen gdscodes zurückgegeben.</para>
        <para>Die Engine garantiert, dass alle von einer expliziten Lock-Anweisung zurückgegebenen Datensätze 
            tatsächlich gesperrt sind und die in der <database>WHERE</database>-Klausel 
            angegebenen Suchbedingungen <emphasis>erfüllen</emphasis>, solange die Suchbedingungen nicht von
            anderen Tabellen, Joins, Unterabfragen usw. abhängen. Außerdem wird garantiert, dass Zeilen, die die Suchbedingungen 
            nicht erfüllen, nicht von der Anweisung gesperrt werden. Sie kann <emphasis>nicht</emphasis> 
            garantieren, dass es keine Zeilen gibt, die zwar die Suchbedingungen erfüllen, aber nicht gesperrt sind.</para>
        <note>
          <para>Diese Situation kann auftreten, wenn andere parallele Transaktionen ihre Änderungen 
              im Verlauf der Ausführung der Sperranweisung festschreiben.</para>
        </note>
        <para>Die Engine sperrt Zeilen zum Abrufzeitpunkt. Dies hat wichtige Konsequenzen, wenn Sie mehrere 
            Zeilen gleichzeitig sperren. Bei vielen Zugriffsmethoden für Firebird-Datenbanken wird die Ausgabe 
            standardmäßig in Paketen mit einigen hundert Zeilen abgerufen (<quote>gepufferte Abrufe</quote>). 
            Die meisten Datenzugriffskomponenten können die Zeilen, die im zuletzt abgerufenen Paket enthalten sind, 
            nicht anzeigen, wenn ein Fehler aufgetreten ist.</para>
      </section>
      <section id="fblangref-dml-withlock-caveats-de">
        <title>Fallstricke mit <database>WITH LOCK</database></title>
        <itemizedlist>
          <listitem>
            <para>Durch das Zurücksetzen eines impliziten oder expliziten Sicherungspunkts werden 
                Datensatzsperren freigegeben, die unter diesem Sicherungspunkt ausgeführt wurden, 
                jedoch keine wartenden Transaktionen. Anwendungen sollten nicht von diesem Verhalten 
                abhängig sein, da sie sich in Zukunft ändern können.</para>
          </listitem>
          <listitem>
            <para>Während explizite Sperren zum Verhindern und / oder Behandeln ungewöhnlicher Fehler beim 
                Updatekonflikt verwendet werden können, steigt die Anzahl der Deadlockfehler, wenn Sie Ihre 
                Sperrstrategie nicht sorgfältig planen und streng steuern.</para>
          </listitem>
          <listitem>
            <para>Die meisten Anwendungen benötigen keine expliziten Sperren. Die Hauptzwecke expliziter Sperren 
                sind (1) die teure Behandlung von Fehlern bei der Aktualisierung von Konflikten in stark ausgelasteten 
                Anwendungen zu verhindern und (2) die Integrität von Objekten zu erhalten, die einer relationalen 
                Datenbank in einer Clusterumgebung zugeordnet sind. Wenn Ihre explizite Sperrung nicht in eine dieser 
                beiden Kategorien fällt, ist dies die falsche Vorgehensweise in Firebird.</para>
          </listitem>
          <listitem>
            <para>Explizites Sperren ist eine erweiterte Funktion. Missbrauchen Sie sie nicht! Während Lösungen 
                für diese Art von Problemen sehr wichtig für Websites sein können, die Tausende von gleichzeitigen 
                Schreibzugriffen behandeln, oder für ERP / CRM-Systeme, die in großen Unternehmen arbeiten, müssen 
                die meisten Anwendungsprogramme unter solchen Bedingungen nicht arbeiten.</para>
          </listitem>
        </itemizedlist>
      </section>
      <bridgehead id="fblangref25-dml-withlock-examples-de" renderas="sect4">
      Beispiele, die explizites Sperren verwenden</bridgehead>
      <orderedlist numeration="lowerroman">
          <listitem>
            <para>Einfach:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK</programlisting>
          </listitem>
          <listitem>
            <para>Mehrere Zeilen, eins-zu-eins-Verarbeitung mit SQL-Cursor:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK</programlisting>
          </listitem>
      </orderedlist>
    </section> <!-- select ... with lock -->

    <section id="fblangref25-dml-select-into-de">
      <title><database>INTO</database></title>
      <formalpara>
        <title>Verwendet für</title>
        <para>Übergabe von <database>SELECT</database>-Ausgaben an Variablen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>

      <para>Im PSQL-Code (Trigger, gespeicherte Prozeduren und ausführbare Blöcke) können die Ergebnisse einer 
          <database>SELECT</database>-Anweisung Zeile für Zeile in lokale Variablen geladen werden. 
          Es ist oft die einzige Möglichkeit, etwas mit den zurückgegebenen Werten zu tun. Die Anzahl, 
          Reihenfolge und Typen der Variablen müssen mit den Spalten in der Ausgabezeile übereinstimmen.</para>

      <para>Eine <quote>reine</quote> <database>SELECT</database>-Anweisung kann nur in PSQL verwendet werden, 
      wenn sie höchstens eine Zeile zurückgibt, d.h. wenn es ein <emphasis>Singleton</emphasis> ist. Bei mehrzeiligen 
      Auswahlmöglichkeiten bietet PSQL das <link linkend="fblangref25-psql-forselect-de"> 
              <database>FOR SELECT</database></link>-Schleifenkonstrukt, das später im PSQL-Kapitel erläutert wird. 
              PSQL unterstützt auch die Anweisung <database>DECLARE CURSOR</database>, die einen benannten Cursor an 
              eine Anweisung <database>SELECT</database> bindet. Der Cursor kann dann verwendet werden, um die 
              Ergebnismenge zu durchlaufen.
      </para>

      <formalpara>
        <title>Syntax</title>
        <para>In PSQL wird die <database>INTO</database>-Klausel am Ende des
        <database>SELECT</database>-Statements platziert.</para>
        <blockquote><programlisting>
SELECT [...] &lt;column-list&gt;
FROM ...
[...]
[INTO &lt;variable-list&gt;]

&lt;variable-list&gt; ::= [:]<replaceable>psqlvar</replaceable> [, [:]<replaceable>psqlvar</replaceable> ...]
        </programlisting></blockquote>
        <note>
          <para>Das Doppelpunkt-Präfix vor lokalen Variablennamen in PSQL ist optional.</para>
        </note>
      </formalpara>

      <bridgehead renderas="sect4">Beispiele</bridgehead>

      <para>Einige aggregierte Werte auswählen und an zuvor deklarierte Variablen <varname>min_amt</varname>,
      <varname>avg_amt</varname> und <varname>max_amt</varname> übergeben:

        <blockquote>
        <programlisting>select min(amount), avg(cast(amount as float)), max(amount)
  from orders
  where artno = 372218
  into min_amt, avg_amt, max_amt;</programlisting>
        </blockquote>
        <note>
          <para>Die <database> CAST </database> dient dazu, den Durchschnitt zu einer reellen 
          Zahl zu machen; Sonst würde <systemitem>amount</systemitem> vermutlich ein Integer-Feld 
          sein, SQL-Regeln würden es auf die nächste niedrigere Ganzzahl abschneiden.</para>
        </note>
      </para>
      <para>Ein PSQL-Trigger der zwei Werte als <database>BLOB</database>
      zurückliefert (Verwendung der <database>LIST()</database>-Funktion) und diese mittels <database>INTO</database> 
      einem dritten Feld zuweist:
        <blockquote>
        <programlisting>select list(name, ', ')
  from persons p
  where p.id in (new.father, new.mother)
  into new.parentnames;</programlisting>
        </blockquote>
      </para>
    </section> <!-- INTO clause -->


    <!-- C O M M O N   T A B L E   E X P R E S S I O N S  -->

    <section id="fblangref25-dml-select-cte-de">
      <title>Common Table Expressions (<quote><database>WITH ...
      AS ... SELECT</database></quote>)</title>

      <formalpara>
        <title>Verfügbar in</title>

        <para>DSQL, PSQL</para>


      </formalpara>

      <para>Ein allgemeiner Tabellenausdruck oder <database>CTE</database> kann als virtuelle Tabelle oder 
      Ansicht beschrieben werden, die in einer Präambel einer Hauptabfrage definiert ist und nach der Ausführung 
      der Hauptabfrage den Gültigkeitsbereich verlässt. Die Hauptabfrage kann auf alle <database>CTE</database>s 
      verweisen, die in der Präambel definiert sind, als wären sie reguläre Tabellen oder Sichten. 
      <database>CTE</database>s kann rekursiv sein, d.h. sich selbst referenzieren, aber sie können 
      nicht verschachtelt sein.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
              <programlisting><replaceable>&lt;cte-construct&gt;</replaceable>  ::=  <replaceable>&lt;cte-defs&gt;</replaceable>
                      <replaceable>&lt;main-query&gt;</replaceable>

<replaceable>&lt;cte-defs&gt;</replaceable>       ::=  WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]

<replaceable>&lt;cte&gt;</replaceable>            ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-stmt&gt;</replaceable>)

<replaceable>&lt;column-list&gt;</replaceable>    ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]
            </programlisting></blockquote>
        </para>
      </formalpara>
      <table id="fblangref25-dml-tbl-cte-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente für Common Table Expressions</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cte-stmt</entry>
              <entry align="left">Jede SELECT-Anweisung, einschließlich UNION</entry>
            </row>
            <row valign="middle">
              <entry align="center">main-query</entry>
              <entry align="left">Die Hauptanweisung SELECT, die sich auf die in der Präambel definierten CTEs beziehen kann</entry>
            </row>
            <row valign="middle">
              <entry align="center">name</entry>
              <entry align="left">Alias für einen Tabellenausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-alias</entry>
              <entry align="left">Alias für eine Spalte in einem Tabellenausdruck</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <formalpara>
        <title>Beispiel</title>

        <para><blockquote>
              <programlisting><emphasis role="bold">with dept_year_budget as (
  select fiscal_year,
         dept_no,
         sum(projected_budget) as budget
  from proj_dept_budget
  group by fiscal_year, dept_no
)</emphasis>
select d.dept_no,
       d.department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from department d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009
where exists (
  select * from proj_dept_budget b
  where d.dept_no = b.dept_no
)</programlisting>
            </blockquote></para>
      </formalpara>
      <bridgehead renderas="sect4">CTE-Hinweise</bridgehead>
      <itemizedlist>
        <listitem>
          <para>Eine <database>CTE</database>-Definition kann ein beliebiges
          <database>SELECT</database>-Statement sein, sofern es keine
          <quote><database>WITH...</database></quote>-Präampel besitzt 
          (keine Verschachtelung).</para>
        </listitem>

        <listitem>
          <para><database>CTE</database>s für die gleiche Hauptabfrage definiert sind, 
          können sich gegenseitig referenzieren, es sollte jedoch darauf geachtet werden, 
          Schleifen zu vermeiden.</para>
        </listitem>

        <listitem>
          <para><database>CTE</database>s kann von überall in der Hauptabfrage referenziert werden.</para>
        </listitem>

        <listitem>
          <para>Jede <database>CTE</database> kann in der Hauptabfrage mehrmals referenziert werden, 
          wobei bei Bedarf verschiedene Aliase verwendet werden.</para>
         </listitem>

        <listitem>
          <para>Ein in Klammern eingeschlossenes <database>CTE</database>-Konstrukt
          kann als Unterabfrage in
          <database>SELECT</database>-Statements verwendet werden, aber auch in
          <database>UPDATE</database>s, <database>MERGE</database>s
          etc.</para>
        </listitem>

        <listitem>
          <para>In PSQL, werden <database>CTE</database>s auch in
          <database>FOR</database>-Schleifen verwendet:</para>

          <literallayout class="monospaced">
for
  <emphasis role="bold">with my_rivers as (select * from rivers where owner = 'me')</emphasis>
    select name, length from my_rivers into :rname, :rlen
do
begin
  ..
end
          </literallayout>
        </listitem>
      </itemizedlist>

      <important>
        <para>Wenn eine <database>CTE</database> deklariert ist, muss sie später verwendet werden: 
        Andernfalls erhalten Sie einen Fehler wie diesen: 'CTE &quot;AAA&quot; is not used in query'.</para>
      </important>

      <section id="fblangref25-dml-select-cte-recursive-de">
        <title>Rekursive <database>CTE</database>s</title>

        <para>Eine rekursive (selbstverweisende) <database>CTE</database> ist eine <database>UNION</database>, 
        die mindestens ein nicht-rekursives Member haben muss, das als <firstterm>Anker</firstterm> 
        bezeichnet wird. Die nicht rekursiven Member müssen vor den rekursiven Membern platziert werden. 
        Rekursive Member sind untereinander und mit ihrem nicht rekursiven Nachbarn durch 
        <database>UNION ALL</database>-Operatoren verknüpft. Die Verbindungen zwischen nicht-rekursiven 
        Mitgliedern können beliebiger Art sein.</para>

        <para>Für rekursive <database>CTE</database>s muss das Schlüsselwort <database>RECURSIVE</database> 
        unmittelbar nach <database>WITH</database> vorhanden sein. Jedes rekursive Union-Member darf sich 
        nur einmal selbst referenzieren, und zwar in einer <database>FROM</database>-Klausel.</para>

        <para>Ein großer Vorteil von rekursiven <database>CTE</database>s ist, dass sie viel weniger 
        Speicher und CPU-Zyklen als eine äquivalente rekursive gespeicherte Prozedur verwenden.</para>

        <bridgehead renderas="sect4">Ausführungsmuster</bridgehead>
        <para>Das Ausführungsmuster einer rekursiven <database>CTE</database> 
            lautet wie folgt:</para>

        <itemizedlist>
          <listitem>
            <para>Die Engine beginnt mit der Ausführung von einem nicht rekursiven Element.</para>
          </listitem>

          <listitem>
            <para>Für jede ausgewertete Zeile beginnt die Ausführung jedes rekursiven Elements nacheinander, 
                wobei die aktuellen Werte aus der äußeren Reihe als Parameter verwendet werden.</para>
          </listitem>

          <listitem>
            <para>Wenn die aktuell ausgeführte Instanz eines rekursiven Members keine Zeilen erzeugt, 
                führt die Ausführung eine Schleife zurück und ruft die nächste Zeile aus der äußeren 
                Ergebnismenge ab.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
            <title>Beispiele für <database>CTE</database>s</title>
            <para><blockquote>
              <programlisting>
WITH RECURSIVE DEPT_YEAR_BUDGET AS (
  SELECT
      FISCAL_YEAR,
      DEPT_NO,
      SUM(PROJECTED_BUDGET) BUDGET
  FROM PROJ_DEPT_BUDGET
  GROUP BY FISCAL_YEAR, DEPT_NO
),
DEPT_TREE AS (
  SELECT
      DEPT_NO,
      HEAD_DEPT,
      DEPARTMENT,
      CAST('' AS VARCHAR(255)) AS INDENT
  FROM DEPARTMENT
  WHERE HEAD_DEPT IS NULL
  UNION ALL
  SELECT
      D.DEPT_NO,
      D.HEAD_DEPT,
      D.DEPARTMENT,
      H.INDENT || ' '
  FROM DEPARTMENT D
    JOIN DEPT_TREE H ON H.HEAD_DEPT = D.DEPT_NO
)
SELECT
    D.DEPT_NO,
    D.INDENT || D.DEPARTMENT DEPARTMENT,
    DYB_2008.BUDGET AS BUDGET_08,
    DYB_2009.BUDGET AS BUDGET_09
FROM DEPT_TREE D
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2008 ON
      (D.DEPT_NO = DYB_2008.DEPT_NO) AND
      (DYB_2008.FISCAL_YEAR = 2008)
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2009 ON
      (D.DEPT_NO = DYB_2009.DEPT_NO) AND
      (DYB_2009.FISCAL_YEAR = 2009)
              </programlisting></blockquote>
            </para>
            <para>Das nächste Beispiel gibt den Stammbaum eines Pferdes zurück. 
                Der Hauptunterschied besteht darin, dass Rekursion gleichzeitig in zwei 
                Zweigen des Stammbaums auftritt.
              <blockquote><programlisting>
WITH RECURSIVE PEDIGREE (
    CODE_HORSE,
    CODE_FATHER,
    CODE_MOTHER,
    NAME,
    MARK,
    DEPTH)
AS (SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        CAST('' AS VARCHAR(80)),
        0
    FROM
        HORSE
    WHERE
        HORSE.CODE_HORSE = :CODE_HORSE
    UNION ALL
    SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        'F' || PEDIGREE.MARK,
        PEDIGREE.DEPTH + 1
    FROM
        HORSE
        JOIN PEDIGREE
      ON HORSE.CODE_HORSE = PEDIGREE.CODE_FATHER
    WHERE
        PEDIGREE.DEPTH &lt; :MAX_DEPTH
    UNION ALL
    SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        'M' || PEDIGREE.MARK,
        PEDIGREE.DEPTH + 1
    FROM
        HORSE
        JOIN PEDIGREE
      ON HORSE.CODE_HORSE = PEDIGREE.CODE_MOTHER
    WHERE
        PEDIGREE.DEPTH &lt; :MAX_DEPTH
)
SELECT
    CODE_HORSE,
    NAME,
    MARK,
    DEPTH
FROM
    PEDIGREE
              </programlisting></blockquote>
            </para>
        </formalpara>

        <formalpara>
          <title>Hinweise zu rekursiven <database>CTE</database>s</title>

          <para><itemizedlist>
            <listitem>
              <para>Aggregate (<database>DISTINCT</database>,
                <database>GROUP BY</database>, <database>HAVING</database>)
                und Aggregatfunktionen (<database>SUM</database>,
                <database>COUNT</database>, <database>MAX</database> etc)
                sind in rekursiven Union-Membern nicht erlaubt.</para>
              </listitem>

              <listitem>
                <para>Eine rekursive Referenz kann nicht an einem Outer Join teilnehmen.</para>
              </listitem>

              <listitem>
                <para>Die maximale Rekursionstiefe beträgt 1024.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section> <!-- C O M M O N   T A B L E   E X P R E S S I O N S -->

  </section> <!-- S E L E C T -->

<!-- ========================================================================================
                   I N S E R T
     ======================================================================================== -->

  <section id="fblangref25-dml-insert-de">
    <title><database>INSERT</database></title>
    <formalpara>
      <title>Verwendet für</title>
      <para>&nbsp;Einfügen von Datenzeilen in eine Tabelle</para>
    </formalpara>

    <formalpara>
      <title>Verfügbar in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para>
      <blockquote><programlisting>
INSERT INTO <replaceable>target</replaceable>
{DEFAULT VALUES | [(&lt;column_list&gt;)] &lt;value_source&gt;}
[RETURNING &lt;returning_list&gt; [INTO &lt;variables&gt;]]

&lt;column_list&gt; ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]

&lt;value_source&gt; ::= VALUES (&lt;value_list&gt;) | &lt;select_stmt&gt;

&lt;value_list&gt; ::= <replaceable>value</replaceable> [, <replaceable>value</replaceable> ...]

&lt;returning_list&gt; ::= <replaceable>ret_value</replaceable> [, <replaceable>ret_value</replaceable> ...]
&lt;variables&gt; ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]
</programlisting></blockquote>
      </para>
    </formalpara>
          <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->
      <table id="fblangref25-dml-tbl-insert-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente für die Parameter des INSERT-Statements</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">Der Name der Tabelle oder Sicht, zu der eine neue Zeile oder ein Stapel von Zeilen hinzugefügt werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Spalte in der Tabelle oder in der Ansicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">Ein Ausdruck, dessen Wert zum Einfügen in die Tabelle verwendet wird</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">Der Ausdruck, der in der RETURNING-Klausel zurückgegeben werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name einer lokalen PSQL-Variablen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Beschreibung</title>

      <para>Das <database>INSERT</database>-Statement wird verwendet um Zeilen zu einer Tabelle 
      hinzuzufügen. Alternativ können Zeilen auch in eine oder mehrere Tabellen eingefügt werden, die 
      als Basis für eine View dienen:
        <itemizedlist>
          <listitem>Wenn die Spaltenwerte in einer <database>VALUES</database>-Klausel angegeben werden, 
          wird genau eine Zeile eingefügt</listitem>
          <listitem>Die Werte können stattdessen durch einen Ausdruck <database>SELECT</database> 
          bereitgestellt werden, in welchem Fall null bis viele Zeilen eingefügt werden können</listitem>
          <listitem>Mit der Klausel <database>DEFAULT VALUES</database> werden überhaupt keine Werte 
          bereitgestellt und genau eine Zeile eingefügt.</listitem>
        </itemizedlist>
      </para>
      <note>
        <title>Beschränkungen</title>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Für Spalten, die an die <database>NEW.</database><replaceable>column_list</replaceable>-Kontextvariablen 
            in Triggern zurückgegeben werden, darf kein Doppelpunkt (<quote> 
                <literal>:</literal></quote>) vorangestellt sein</para>
          </listitem>
          <listitem>
            <para>Keine Spalte darf mehr als einmal in der Spaltenliste vorkommen.</para>
          </listitem>
        </itemizedlist>
      </note>
    </formalpara>

    <important>
      <title>ACHTUNG :: 'BEFORE INSERT'-Trigger</title>
      <para>Berücksichtigen Sie unabhängig von der zum Einfügen von Zeilen verwendeten Methode alle Spalten in der Zieltabelle 
          oder -sicht, die von <database>BEFORE INSERT</database>-Triggern gefüllt werden, z. B. Primärschlüssel und 
          Suchfelder ohne Beachtung der Groß- / Kleinschreibung. Diese Spalten sollten sowohl von der 
          <replaceable>column_list</replaceable> als auch von der <database>VALUES</database>-Liste
          ausgeschlossen werden, wenn die Trigger die <database>NEW.</database><replaceable>column_name</replaceable> 
          auf <constant>NULL</constant> prüfen.
      </para>
    </important>

    <section id="fblangref25-dml-insert-values-de">
      <title><database>INSERT</database> ...
      <database>VALUES</database></title>

      <para>Die <database>VALUES</database>-Liste muss für jede Spalte in der Spaltenliste einen 
      Wert in derselben Reihenfolge und mit dem richtigen Typ angeben. Die Spaltenliste muss nicht
      jede Spalte im Ziel angeben, aber wenn die Spaltenliste nicht vorhanden ist, benötigt die Engine 
      für jede Spalte in der Tabelle oder Ansicht einen Wert (berechnete Spalten ausgeschlossen).</para>

        <note>
          <para><link linkend="fblangref25-commons-introducer-syntax-de">Introducer-Syntax</link>
          bietet eine Möglichkeit, den Zeichensatz eines Werts zu identifizieren, der eine 
          Zeichenfolgenkonstante (Literal) ist. Die Introducer-Syntax funktioniert nur mit 
          Literalstrings: Sie kann nicht auf Stringvariablen, Parameter, Spaltenreferenzen oder 
          Werte, die Ausdrücke sind, angewendet werden.</para>
        </note>

      <formalpara>
        <title>Beispiele</title>
        <para>
          <blockquote><programlisting>
INSERT INTO cars (make, model, year)
VALUES ('Ford', 'T', 1908);

INSERT INTO cars
VALUES ('Ford', 'T', 1908, 'USA', 850);

-- notice the '_' prefix (introducer syntax)
INSERT INTO People
VALUES (_ISO8859_1 'Hans-J&ouml;rg Sch&auml;fer')
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-insert-select-de">
      <title><database>INSERT</database> ...
      <database>SELECT</database></title>

      <para>Für diese Einfügemethode müssen die Ausgabespalten der Anweisung <database>SELECT</database> 
      für jede Zielspalte in der Spaltenliste einen Wert in derselben Reihenfolge und vom richtigen 
      Typ bereitstellen.</para>
      <para>Literale Werte, Kontextvariablen oder Ausdrücke des kompatiblen Typs können für jede Spalte 
          in der Quellzeile verwendet werden. In diesem Fall sind eine Quellenspaltenliste und eine 
          entsprechende <database>VALUES</database>-Liste erforderlich.</para>
      <para>Wenn die Spaltenliste abwesend ist &mdash; wie es ist, wenn 
        <database>SELECT *</database> für den Quellausdruck &mdash; verwendet wird, muss die 
        <replaceable>column_list</replaceable> die Namen jeder Spalte in der Zieltabelle oder Sicht 
        enthalten ( berechnete Spalten ausgeschlossen).</para>

      <formalpara>
        <title>Beispiele</title>

        <para>
          <blockquote><programlisting>
INSERT INTO cars (make, model, year)
  SELECT make, model, year
  FROM new_cars;

INSERT INTO cars
  SELECT * FROM new_cars;

INSERT INTO Members (number, name)
  SELECT number, name FROM NewMembers
    WHERE Accepted = 1
UNION ALL
  SELECT number, name FROM SuspendedMembers
    WHERE Vindicated = 1

INSERT INTO numbers(num)
  WITH RECURSIVE r(n) as (
      SELECT 1 FROM rdb$database
      UNION ALL
      SELECT n+1 FROM r WHERE n &lt; 100
                          )
SELECT n FROM r
          </programlisting></blockquote>
        </para>
      </formalpara>

      <para>Natürlich müssen die Spaltennamen in der Quelltabelle nicht mit denen in der 
          Zieltabelle übereinstimmen. Jede Art von <database>SELECT</database>-Anweisung 
          ist zulässig, solange ihre Ausgabespalten exakt mit den Einfügespalten in Anzahl, 
          Reihenfolge und Typ übereinstimmen. Typen müssen nicht exakt gleich sein, aber 
          sie müssen zuweisungskompatibel sein.</para>

      <section id="fblangref25-dml-insert-select-unstable-de">
        <title>Das Problem mit dem <quote>instabilen Cursor</quote></title>
        <para>In Firebird muss bis zu dieser Version ein Implementierungsfehler geachtet werden, 
            der diese Art von Einfügungen betrifft, wenn das Ziel darin besteht, Zeilen in 
            derselben Tabelle zu duplizieren. Beispielsweise
          <blockquote><programlisting>
INSERT INTO T
  SELECT * FROM T
          </programlisting></blockquote>
        liebevoll als die <quote>unendliche Einfügeschleife</quote> bezeichnet, wählt fortlaufend 
        Zeilen aus und fügt sie immer wieder ein, bis das System keinen Speicherplatz mehr hat.</para>
        <para>Dies ist eine Eigenart, die alle datenverändernden DML-Operationen mit einer Vielzahl 
            von Effekten beeinflusst. Dies geschieht, weil DML-Anweisungen in den Ausführungsebenen 
            implizite Cursor zum Ausführen der Operationen verwenden. Mit unserem einfachen Beispiel 
            funktioniert die Ausführung folgendermaßen:
          <blockquote><programlisting>
FOR SELECT &lt;values&gt; FROM T INTO &lt;tmp_vars&gt;
  DO
    INSERT INTO T VALUES (&lt;tmp_vars&gt;)
          </programlisting></blockquote>
        Die Implementierung führt zu einem Verhalten, das nicht mit den SQL-Standards übereinstimmt. 
          Zukünftige Versionen von Firebird werden dem Standard entsprechen.</para>
      </section> <!-- Unstable cursor - inserts -->
    </section>

    <section id="fblangref25-dml-insert-defaults-de">
      <title><database>INSERT</database> ... <database>DEFAULT
      VALUES</database></title>

      <para>Die <database>DEFAULT VALUES</database>-Klausel erlaubt das Einfügen
        eines Datensatzes ohne die Angabe von Werten, weder direkt oder durch
        ein <database>SELECT</database>-Statement. Dies ist nur möglich, wenn jede 
      <database>NOT NULL</database>- oder <database>CHECK</database>-basierte Spalte 
        in der Tabelle entweder einen gültigen Standardwert deklariert hat oder die Werte
        über einen <database>BEFORE INSERT</database>-Trigger erhält. Darüber hinaus dürfen 
        Trigger, die erforderliche Feldwerte bereitstellen, nicht von dem Vorhandensein 
        von Eingabewerten abhängen.</para>

      <formalpara>
        <title>Beispiel</title>

        <para>
          <blockquote><programlisting>
INSERT INTO journal
  DEFAULT VALUES
RETURNING entry_id
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-insert-returning-de">
      <title>Die <database>RETURNING</database>-Klausel</title>

      <para>Eine <database>INSERT</database>-Anweisung, die <emphasis>höchstens eine Zeile</emphasis> 
      hinzufügt, kann optional eine Klausel <database>RETURNING</database> enthalten, um Werte aus der 
      eingefügten Zeile zurückzugeben. Die Klausel, falls vorhanden, muss nicht alle Einfügungsspalten 
      enthalten und kann auch andere Spalten oder Ausdrücke enthalten. Die zurückgegebenen Werte spiegeln 
      alle Änderungen wider, die möglicherweise in den <database>BEFORE INSERT</database>-Triggern 
      vorgenommen wurden.</para>
      <important>
        <title>ACHTUNG :: Mehrfache INSERTs</title>
        <para>In DSQL gibt eine Anweisung mit <database>RETURNING</database> immer nur eine Zeile zurück. 
        Wenn die <database>RETURNING</database>-Klausel angegeben ist und mehr als eine Zeile von der 
        <database>INSERT</database>-Anweisung eingefügt wird, schlägt die Anweisung fehl und eine 
        Fehlermeldung wird zurückgegeben. Dieses Verhalten kann sich in zukünftigen Firebird-Versionen ändern.</para>
      </important>
      <formalpara>
        <title>Beispiele</title>

        <para>
          <blockquote><programlisting>
INSERT INTO Scholars (
  firstname, 
  lastname,
  address,
  phone,
  email)
VALUES (
  'Henry',
  'Higgins',
  '27A Wimpole Street',
  '3231212',
  NULL)
RETURNING lastname, fullname, id;

INSERT INTO Dumbbells (firstname, lastname, iq)
  SELECT fname, lname, iq
FROM Friends
  ORDER BY iq ROWS 1
  RETURNING id, firstname, iq
INTO :id, :fname, :iq;
          </programlisting></blockquote>
        </para>
      </formalpara>

      <formalpara>
        <title>Hinweise</title>

        <para>
          <itemizedlist>
            <listitem>
              <para><database>RETURNING</database> wird nur unterstützt für
              <database>VALUES</database>-Inserts und Singleton-
              <database>SELECT</database>-Inserts.</para>
            </listitem>

            <listitem>
              <para>In DSQL gibt eine Anweisung mit einer <database>RETURNING</database>-Klausel 
              <emphasis role = "">immer</emphasis> genau eine Zeile zurück. Wenn tatsächlich kein 
              Datensatz eingefügt wurde, sind die Felder in dieser Zeile alle
              <constant>NULL</constant>. Dieses Verhalten kann sich in einer späteren Version von 
              Firebird ändern. Wenn in PSQL keine Zeile eingefügt wurde, wird nichts zurückgegeben 
              und die Zielvariablen behalten ihre vorhandenen Werte bei.</para>
            </listitem>
          </itemizedlist>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-insert-blobs-de">
      <title>Einfügen in <database>BLOB</database>-Spalten</title>

      <para>Das Einfügen in <database>BLOB</database>-Spalten ist nur unter folgenden Umständen möglich:</para>

      <orderedlist>
        <listitem>
          <para>Die Client-Anwendung hat mit der Firebird-API spezielle Vorkehrungen für solche Einsätze getroffen. 
              In diesem Fall ist der <firstterm>modus operandi</firstterm> anwendungsspezifisch und außerhalb des 
              Geltungsbereichs dieses Handbuchs.</para>
        </listitem>

        <listitem>
          <para>Der eingegebene Wert ist eine Textzeichenfolge von nicht mehr als 32767 Byte.
            <caution>
              <para>Wenn der Wert kein String-Literal ist, achten Sie auf Verkettungen, da die 
                  Ausgabe des Ausdrucks die maximale Länge überschreiten kann.</para>
            </caution>
          </para>
        </listitem>

        <listitem>
          <para>Sie nutzen die Form <quote><database>INSERT</database> ...
          <database>SELECT</database></quote> und eine oder mehr Spalten im
          Rückgabesatz sind <database>BLOB</database>s.</para>
        </listitem>

      </orderedlist>
    </section>
  </section> <!-- INSERT -->

<!-- ========================================================================================
                   U P D A T E
     ======================================================================================== -->

  <section id="fblangref25-dml-update-de">
    <title><database>UPDATE</database></title>

    <formalpara>
      <title>Verwendet für</title>
      <para>&nbsp;Ändern von Zeilen in Tabellen und Sichten</para>
    </formalpara>
    <formalpara>
      <title>Verfügbar in</title>
      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>
      <para>
        <blockquote><programlisting>
   UPDATE <replaceable>target</replaceable> [[AS] <replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;returning_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;returning_list&gt;</replaceable>     ::=  <replaceable>ret_value</replaceable> [, <replaceable>ret_value</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
       </programlisting></blockquote>
     </para>
    </formalpara>

      <table id="fblangref25-dml-tbl-update-de">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the UPDATE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">Der Name der Tabelle oder Sicht, in der die Datensätze aktualisiert werden</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Alias für den Tisch oder die Ansicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Name oder Alias einer Spalte in der Tabelle oder Sicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">newval</entry>
              <entry align="left">Neuer Wert für eine Spalte, die von der Anweisung in der Tabelle oder Sicht aktualisiert werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">search-conditions</entry>
              <entry align="left">Eine Suchbedingung, die den Satz der zu aktualisierenden Zeilen begrenzt</entry>
            </row>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Der Name des Cursors, über den die zu aktualisierende Zeile(n) positioniert wird</entry>
            </row>
            <row valign="middle">
              <entry align="center">plan_items</entry>
              <entry align="left">Klauseln im Abfrageplan</entry>
            </row>
            <row valign="middle">
              <entry align="center">sort_items</entry>
              <entry align="left">Spalten, die in einer ORDER BY-Klausel aufgeführt sind</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">Integer-Ausdrücke zur Begrenzung der Anzahl der zu aktualisierenden Zeilen</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">Ein Wert, der in der RETURNING-Klausel zurückgegeben werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name einer lokalen PSQL-Variablen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    <formalpara>
      <title>Beschreibung</title>

      <para>Die Anweisung <database>UPDATE</database> ändert Werte in einer Tabelle oder in einer 
      oder mehreren Tabellen, die einer Sicht zugrunde liegen. Die betroffenen Spalten sind in 
      der Klausel <database>SET</database> angegeben. Die betroffenen Zeilen können durch die 
      Klauseln <database>WHERE</database> und <database>ROWS</database> eingeschränkt sein. 
      Wenn weder <database>WHERE</database> noch <database>ROWS</database> vorhanden ist, 
      werden alle Datensätze in der Tabelle aktualisiert.</para>
    </formalpara>

    <section id="fblangref25-dml-update-alias-use-de">
      <title>Verwendung eines Alias</title>

      <para>Wenn Sie einer Tabelle oder einer Ansicht einen Alias zuweisen, <emphasis>muss</emphasis> der 
      Alias verwendet werden, wenn Spalten angegeben werden, und auch in Spaltenreferenzen, die 
      in anderen Klauseln enthalten sind.</para>

      <formalpara>
        <title>Beispiele</title>

        <para><blockquote>
            <para>Korrekte Verwendung:</para>

            <programlisting>update Fruit set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit set Fruit.soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set F.soort = 'pisang' where ...</programlisting>

            <para>Nicht möglich:</para>

            <programlisting>update Fruit F set Fruit.soort = 'pisang' where ...</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-update-setclause-de">
      <title>Die <database>SET</database>-Klausel</title>

      <para>In der Klausel <database>SET</database> werden die Zuweisungsausdrücke, die die 
      Spalten mit den festzulegenden Werten enthalten, durch Kommata getrennt. In einer 
      Zuweisungsphrase befinden sich Spaltennamen auf der linken Seite und die Werte oder 
      Ausdrücke, die die Zuweisungswerte enthalten, befinden sich auf der rechten Seite. 
      Eine Spalte darf nur einmal in der Klausel <database>SET</database> enthalten sein.</para>

      <para>Ein Spaltenname kann in Ausdrücken auf der rechten Seite verwendet werden. Der alte 
          Wert der Spalte wird immer in diesen Werten auf der rechten Seite verwendet, auch wenn 
          der Spalte bereits in der <database>SET</database>-Klausel ein neuer Wert zugewiesen 
          wurde.
        <formalpara>
          <title>Hier ist ein Beispiel</title>
          <para>Daten in der TSET-Tabelle:
            <blockquote><literallayout class="monospaced">
A B
----
1 0
2 0
            </literallayout></blockquote>
          Die Anweisung
            <blockquote><programlisting>
UPDATE tset SET a = 5, b = a
        </programlisting></blockquote>
          ändert die Werte zu
          <blockquote><literallayout class="monospaced">
A B
----
5 1
5 2
          </literallayout></blockquote>

          Beachten Sie, dass die alten Werte (1 und 2) verwendet werden, um die Spalte b zu 
          aktualisieren, auch nachdem der Spalte ein neuer Wert zugewiesen wurde (5).
          </para>
          <note>
            <para>Dies war nicht immer so. Vor der Version 2.5 erhielten Spalten ihre neuen Werte sofort nach der Zuweisung. 
                Das war jedoch kein standardmäßiges Verhalten, und wurde in Version 2.5 behoben.</para>
            <para>Um die Kompatibilität mit Legacy-Code zu erhalten, enthält die Konfigurationsdatei <filename>firebird.conf</filename> 
            den Parameter <varname>OldSetClauseSemantics</varname>, der auf True (1) gesetzt werden kann, um das alte, fehlerhafte 
            Verhalten wiederherzustellen. Es ist eine vorübergehende Maßnahme, der Parameter wird in Zukunft entfernt.</para>
          </note>
        </formalpara>
      </para>
    </section> <!-- SET clause -->

    <section id="fblangref25-dml-update-whereclause-de">
      <title>Die <database>WHERE</database>-Klausel</title>
      <para>Die WHERE-Klausel legt die Bedingungen fest, die die Datensatzgruppe für ein 
          <firstterm>searched update</firstterm> begrenzen.</para>
      <para>Wenn in PSQL ein benannter Cursor zum Aktualisieren eines Satzes verwendet wird und die Klausel
          <database>WHERE CURRENT OF</database> verwendet wird, ist die Aktion auf die Zeile beschränkt, 
          in der sich der Cursor gerade befindet. Dies ist ein <firstterm>positioniertes Update</firstterm>.
        <note>
          <para>Die Klausel <database>WHERE CURRENT OF</database> ist nur in PSQL verfügbar, da es keine 
          Anweisung zum Erstellen und Bearbeiten eines expliziten Cursors in DSQL gibt. Gesuchte Updates 
          sind natürlich auch in PSQL verfügbar.</para>
        </note>
      </para>

      <formalpara>
        <title>Beispiele</title>
        <para>
          <blockquote><programlisting>
UPDATE People
  SET firstname = 'Boris'
  WHERE lastname = 'Johnson';

UPDATE employee e
  SET salary = salary * 1.05
  WHERE EXISTS(
         SELECT *
           FROM employee_project ep
           WHERE e.emp_no = ep.emp_no);

UPDATE addresses
  SET city = 'Saint Petersburg', citycode = 'PET'
  WHERE city = 'Leningrad'

UPDATE employees
  SET salary = 2.5 * salary
  WHERE title = 'CEO'
          </programlisting></blockquote>
        </para>
<!-- introducer syntax -->
        <para>Bei String-Literalen, mit denen der Parser Hilfe beim Interpretieren des 
            Zeichensatzes der Daten benötigt, kann die 
            <link linkend = "fblangref25-commons-introducer-syntax-de">Einführersyntax</link> 
            verwendet werden. Dem Zeichenfolgenliteral ist der Zeichensatzname vorangestellt, 
            dem ein Unterstrich vorangestellt ist:
          <blockquote><programlisting>
-- notice the '_' prefix

UPDATE People
SET name = _ISO8859_1 'Hans-J&ouml;rg Sch&auml;fer'
WHERE id = 53662
          </programlisting></blockquote>
        </para>
      </formalpara>

      <section id="fblangref25-dml-update-unstable-de">
        <title>Das Problem mit dem <quote>instabilen Cursor</quote></title>
        <para>In Firebird muss bis zu dieser Version ein Implementierungsfehler geachtet werden, 
            der diese Art von Aktualisierungen betrifft, wenn die
        WHERE-Bedingungen das <database>IN</database> (<replaceable>select-expr</replaceable>)
        und die <replaceable>select-expr</replaceable> in der Form
        <database>SELECT FIRST</database> <replaceable>n</replaceable> oder
        <database>SELECT ... ROWS</database> vorliegt. Zum Beispiel
          <blockquote><programlisting>
UPDATE T
  SET ...
  WHERE ID IN (SELECT FIRST 1 ID FROM T)
          </programlisting></blockquote>
        liebevoll als die <quote>unendliche Update-Schleife</quote> bekannt, wird fortlaufend 
        Zeilen aktualisieren, 
        immer und immer wieder, bis der Server hängen bleibt.</para>

        <para>Quarks wie dieses können sich auf datenverändernde DML-Operationen auswirken, meistens 
            wenn die Auswahlbedingungen eine Unterabfrage betreffen. Fälle wurden gemeldet, bei denen 
            die Sortierreihenfolge die Erwartungen beeinträchtigt, ohne dass eine Unterabfrage erforderlich 
            ist. Dies geschieht, weil DML-Anweisungen in den Ausführungsebenen anstelle eines stabilen 
            <quote>Zielsatzes</quote> und anschließendem Ausführen der Datenänderungen für jedes gesetzte 
            Element implizite Cursor zum Ausführen der Operationen für die Zeile verwenden, die derzeit die 
            Bedingungen erfüllt, ohne zu wissen, ob diese Zeile zuvor die Bedingung nicht erfüllt hat oder 
            bereits aktualisiert wurde. Also, mit einem einfachen Beispielmuster:

          <blockquote><programlisting>
UPDATE T SET &lt;fields&gt; = &lt;values&gt;
  WHERE &lt;conditions&gt;
          </programlisting></blockquote>

        the execution works as:
          <blockquote><programlisting>
FOR SELECT &lt;values&gt; FROM T
  WHERE &lt;conditions&gt;
  INTO &lt;tmp_vars&gt; AS CURSOR &lt;cursor&gt;
  DO
    UPDATE T SET &lt;fields&gt; = &lt;tmp_vars&gt;
    WHERE CURRENT OF &lt;cursor&gt;
          </programlisting></blockquote>
          Die Implementierung von Firebird stimmt nicht mit den SQL-Standards überein, nach 
          denen ein stabiles Set eingerichtet werden muss, bevor Daten geändert werden. Versionen 
          von Firebird ab V.3 werden dem Standard entsprechen.</para>
      </section> <!-- Unstable cursor - updates -->
    </section> <!-- WHERE clause -->

    <section id="fblangref25-dml-update-orderbyclause-de">
      <title>Die <database>ORDER BY</database>- und <database>ROWS</database>-Klauseln</title>
      <para>Die Klauseln <database>ORDER BY</database> und <database>ROWS</database> sind nur sinnvoll, 
      wenn sie zusammen verwendet werden. Sie können jedoch auch getrennt verwendet werden.</para>

      <para>Wenn <database>ROWS</database> ein Argument <replaceable>m</replaceable> hat, sind die 
      zu aktualisierenden Zeilen auf die ersten <replaceable>m</replaceable> Zeilen beschränkt.
        <formalpara>
          <title>Wichtige Punkte</title>
          <itemizedlist spacing="compact">
            <listitem>Wenn m &gt; der Anzahl der Zeilen, die verarbeitet werden, wird der gesamte
            Zeilensatz aktualisiert</listitem>
            <listitem>Wenn m = 0, wird keine Zeile aktualisiert</listitem>
            <listitem>Wenn m &lt; 0, tritt ein Fehler auf und die Aktualisierung schlägt fehl</listitem>
          </itemizedlist>
        </formalpara>
      </para>

      <para>Wenn zwei Argumente verwendet werden, <replaceable>m</replaceable> und <replaceable>n</replaceable>, 
      begrenzt <database>ROWS</database> die Zeilen, die aktualisiert werden, auf Zeilen von <replaceable>m</replaceable> 
      bis <replaceable>n</replaceable> einschließlich. Beide Argumente sind Ganzzahlen und beginnen bei 1.
        <formalpara>
          <title>Wichtige Punkte</title>
          <itemizedlist spacing="compact">
            <listitem>Wenn m &gt; der Anzahl der zu verarbeitenden Zeilen, werden keine Zeilen aktualisiert</listitem>
            <listitem>Wenn n &gt; der Anzahl der Zeilen, werden Zeilen von m bis zum Ende des Satzes werden aktualisiert</listitem>
            <listitem>Wenn m &lt; 1 oder n &lt; 1, tritt ein Fehler auf und das Update schlägt fehl</listitem>
            <listitem>Wenn n = m - 1, werden keine Zeilen aktualisiert.</listitem>
            <listitem>If n &lt; m -1, ein Fehler tritt auf und die Aktualisierung schlägt fehl</listitem>
          </itemizedlist>
        </formalpara>
      </para>
      <formalpara>
        <title>ROWS-Beispiel</title>
        <para>
          <blockquote><programlisting>
UPDATE employees
SET salary = salary + 50
ORDER BY salary ASC
ROWS 20
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- order by and rows -->

    <section id="fblangref25-dml-update-returningclause-de">
      <title>Die <database>RETURNING</database>-Klausel</title>
      <para>Eine Anweisung <database>UPDATE</database> mit <emphasis>höchstens einer Zeile</emphasis> 
      kann <database>RETURNING</database> enthalten, um einige Werte aus der aktualisierten Zeile zurückzugeben. 
      <database>RETURNING</database> kann Daten aus jeder Zeile enthalten, nicht zwangsläufig aus der Zeile, 
      die gerade aktualisiert wird. Es kann Literale enthalten, die nicht mit Spalten verknüpft sind, 
      wenn dies erforderlich ist.</para>
      <para>Wenn der <database>RETURNING</database>-Satz Daten aus der aktuellen Zeile enthält, melden die 
      zurückgegebenen Werte Änderungen, die in den <database>BEFORE UPDATE</database> Triggern vorgenommen 
      wurden, nicht jedoch in <database>AFTER UPDATE</database>-Triggern.</para>
      <para>Die Kontextvariablen <database>OLD</database>.fieldname und <database>NEW</database>.fieldname können 
      als Spaltennamen verwendet werden. Wenn <database>OLD.</database> oder <database>NEW.</database> nicht angegeben 
      ist, sind die zurückgegebenen Spaltenwerte die in <database>NEW.</database>.</para>
      <para>In DSQL gibt eine Anweisung mit <database>RETURNING</database> immer eine einzelne Zeile zurück. 
      Wenn die Anweisung keine Datensätze aktualisiert, enthalten die zurückgegebenen Werte <constant>NULL</constant>. 
      Dieses Verhalten kann sich in zukünftigen Firebird-Versionen ändern.</para>

      <section  id="fblangref25-dml-update-returning-into-de">
        <title>Die <database>INTO</database>-Unterklausel</title>
        <para>In PSQL kann die Klausel <database>INTO</database> verwendet werden, um die zurückgegebenen 
        Werte an lokale Variablen zu übergeben. Es ist nicht in DSQL verfügbar. Wenn keine Datensätze 
        aktualisiert werden, wird nichts zurückgegeben, und die in <database>RETURNING</database> angegebenen 
        Variablen behalten ihre vorherigen Werte bei.
          <note>
            <para>Wenn ein Wert zurückgegeben und einer <database>NEW</database>-Kontextvariablen zugewiesen 
            wird, ist die Verwendung eines Doppelpunktpräfixes nicht zulässig. 
            Dies ist beispielsweise ungültig:
              <literallayout class="monospaced">
...
into :var1, :var2, :new.id
              </literallayout>
            und dies gültig:
              <literallayout class="monospaced">
...
into :var1, :var2, new.id
              </literallayout>
            </para>
          </note>
        </para>
      </section> <!-- RETURNING INTO -->

      <formalpara>
      <title>RETURNING-Beispiel (DSQL)</title>
        <para>
          <blockquote><programlisting>
UPDATE Scholars
SET firstname = 'Hugh', lastname = 'Pickering'
WHERE firstname = 'Henry' and lastname = 'Higgins'
RETURNING id, old.lastname, new.lastname
          </programlisting></blockquote>
        </para>
      </formalpara>

    </section> <!-- RETURNING clause -->

    <section id="fblangref25-dml-update-blob-de">
      <title>Aktualisieren von <database>BLOB</database>-Spalten</title>

      <para>Das Aktualisieren einer <database>BLOB</database>-Spalte ersetzt immer den
        gesamten Inhalt. Sogar die <database>BLOB</database>-ID, das
      <quote>Handle</quote> welches direkt in der Spalte gespeichert wird, ändert sich.
      <database>BLOB</database>s können aktualisiert werden wenn:</para>

      <orderedlist>
        <listitem>
          <para>Die Client-Anwendung mit der Firebird-API spezielle Vorkehrungen für 
              diese Operation getroffen hat. In diesem Fall ist der <firstterm> modus operandi </firstterm> 
              anwendungsspezifisch und außerhalb des Geltungsbereichs dieses Handbuchs.</para>
        </listitem>

        <listitem>
          <para>Der neue Wert eine Textzeichenfolge von höchstens 32767 Byte ist. Bitte beachten Sie: 
              Wenn der Wert kein String-Literal ist, achten Sie auf Verkettungen, da 
              diese die maximale Länge überschreiten können.</para>
        </listitem>

        <listitem>
          <para>Die Quelle selbst eine <database>BLOB</database>-Spalte oder allgemeiner 
          ein Ausdruck ist, der ein <database>BLOB</database> zurückgibt.</para>
        </listitem>

        <listitem>
          <para>Sie die Anweisung <database>INSERT CURSOR</database> verwenden (nur ESQL).</para>
        </listitem>
      </orderedlist>
    </section>
  </section> <!-- UPDATE -->

<!-- ========================================================================================
                   U P D A T E   O R   I N S E R T
     ======================================================================================== -->

  <section id="fblangref25-dml-update-or-insert-de">
    <title><database>UPDATE OR INSERT</database></title>
    <formalpara>
      <title>Verwendet für</title>
      <para>Updating an existing record in a table or, if it does not exist,
      inserting it</para>
    </formalpara>
    <formalpara>
      <title>Verfügbar in</title>
      <para>DSQL, PSQL</para>

      <!--ESQL ? Guess not, readme says: Scope: DSQL, PSQL-->
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
        <programlisting>UPDATE OR INSERT INTO
   {<replaceable>target</replaceable>} [(<replaceable>&lt;column_list&gt;</replaceable>)]
   VALUES (<replaceable>&lt;value_list&gt;</replaceable>)
   [MATCHING (<replaceable>&lt;column_list&gt;</replaceable>)]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;column_list&gt;</replaceable>      ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;value_list&gt;</replaceable>       ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;ret_values&gt;</replaceable>       ::=  <replaceable>ret_value</replaceable>    [, <replaceable>ret_value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>    ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
        </programlisting>
      </blockquote></para>
    </formalpara>

      <table id="fblangref25-dml-tbl-updorins-de">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the UPDATE OR INSERT Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">The name of the table or view where the record[s] is to be updated
              or a new record inserted</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name of a column in the table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">An expression whose value is to be used for inserting or updating
              the table</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">An expression returned in the RETURNING clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variable name&mdash;PSQL only</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Beschreibung</title>
      <para><database>UPDATE OR INSERT</database> inserts a new record or
      updates one or more existing records. The action taken depends on the
      values provided for the columns in the <database>MATCHING</database>
      clause (or, if the latter is absent, in the primary key). If there are
      records found matching those values, they are updated. If not, a new
      record is inserted.</para>
      <para>
        <blockquote>A match only counts if all the values in the
        <database>MATCHING</database> or <database>PK</database> columns are
        equal. Matching is done with the <link
        linkend="fblangref25-commons-isnotdistinct-de"><database>IS NOT DISTINCT</database></link>
        operator, so one <constant>NULL</constant> matches another.</blockquote>
      </para>
    </formalpara>

    <note>
      <title>Beschränkungen</title>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If the table has no <database>PK</database>, the
          <database>MATCHING</database> clause becomes mandatory.</para>
        </listitem>

        <listitem>
          <para>In the <database>MATCHING</database> list as well as in
          the update/insert column list, each column name may occur only
          once.</para>
        </listitem>

        <listitem>
          <para>The <quote><database>INTO</database>
          <replaceable>&lt;variables&gt;</replaceable></quote> subclause
          is only available in PSQL.</para>
        </listitem>

        <listitem>
          <para>When values are returned into the context variable
          <database>NEW</database>, this name must not be preceded by a
          colon (<quote><literal>:</literal></quote>).</para>
        </listitem>
      </itemizedlist>
    </note>

    <section id="fblangref25-dml-update-or-insert-returning-de">
      <title>The <database>RETURNING</database> clause</title>

      <para>The optional <database>RETURNING</database> clause, if present,
      need not contain all the columns mentioned in the statement and may also
      contain other columns or expressions. The returned values reflect any
      changes that may have been made in <database>BEFORE</database> triggers,
      but not those in <database>AFTER</database> triggers.
      <database>OLD</database>.<replaceable>fieldname</replaceable> and
      <database>NEW</database>.<replaceable>fieldname</replaceable> may both
      be used in the list of columns to return; for field names not preceded
      by either of these, the new value is returned.</para>

      <para>In DSQL, a statement with a <database>RETURNING</database> clause
      <emphasis role="">always</emphasis> returns exactly one row. If a
      <database>RETURNING</database> clause is present and more than one
      matching record is found, an error is raised. This behaviour may change
      in a later version of Firebird.</para>
    </section>

    <formalpara>
      <title>Beispiel</title>
      <para>Modifying data in a table, using UPDATE OR INSERT in a PSQL
      module.  The return value is passed to a local variable, whose
      colon prefix is not optional.
      <blockquote>
          <programlisting>UPDATE OR INSERT INTO Cows (Name, Number, Location)
  VALUES ('Suzy Creamcheese', 3278823, 'Green Pastures')
  MATCHING (Number)
  RETURNING rec_id into :id;</programlisting>
        </blockquote>
      </para>
    </formalpara>
    <important>
      <title>The <quote>Unstable Cursor</quote> Problem</title>
      <para>Because of the way the execution of data-changing DML is implemented in
      Firebird, up to and including this version, the sets targeted for updating sometimes
      produce unexpected results.  For more information, refer to
      <link linkend="fblangref25-dml-update-unstable-de">
      <citetitle>The <quote>Unstable Cursor</quote> Problem</citetitle></link> in the
      <database>UPDATE</database> section.</para>
    </important>

  </section> <!-- update or insert -->

<!-- ========================================================================================
                   D E L E T E
     ======================================================================================== -->


  <section id="fblangref25-dml-delete-de">
    <title><database>DELETE</database></title>
    <formalpara>
      <title>Verwendet für</title>
      <para>&nbsp;Löschen von Zeilen aus einer Tabelle oder Ansicht</para>
    </formalpara>

    <formalpara>
      <title>Verfügbar in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>


    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>DELETE
   FROM {<replaceable>target</replaceable>} [[AS] <replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;returning_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;returning_list&gt;</replaceable>     ::=  <replaceable>ret_value</replaceable> [, <replaceable>ret_value</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
          </programlisting>
      </blockquote></para>
    </formalpara>

      <table id="fblangref25-dml-tbl-delete-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente der DELETE-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">Der Name der Tabelle oder Sicht, aus der die Datensätze gelöscht werden sollen</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Alias für die Zieltabelle oder -ansicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">search-conditions</entry>
              <entry align="left">Suchbedingung, die den Satz von Zeilen begrenzt, die zum Löschen vorgesehen sind</entry>
            </row>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Der Name des Cursors, in dem der aktuelle Datensatz zum Löschen positioniert ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">plan_items</entry>
              <entry align="left">Abfrageplanklausel</entry>
            </row>
            <row valign="middle">
              <entry align="center">sort_items</entry>
              <entry align="left">ORDER BY-Klausel</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">Integer-Ausdrücke zum Begrenzen der Anzahl der gelöschten Zeilen</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">Ein Ausdruck, der in der RETURNING-Klausel zurückgegeben werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name einer PSQL-Variablen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Beschreibung</title>

      <para><database>DELETE</database> entfernt Zeilen aus einer Datenbanktabelle oder aus einer 
      oder mehreren Tabellen, die einer Sicht zugrunde liegen. <database>WHERE</database> und 
      <database>ROWS</database>-Klauseln können die Anzahl der gelöschten Zeilen begrenzen. Wenn weder
      <database>WHERE</database> noch <database>ROWS</database> vorhanden ist, löscht <database>DELETE</database> 
      alle Zeilen in der Beziehung.</para>
    </formalpara>

    <section id="fblangref25-dml-delete-alias-use-de">
      <title>Aliases</title>
      <para>Wenn für die Zieltabelle oder -sicht ein Alias angegeben ist, muss dieser verwendet werden, 
          um alle Feldnamenreferenzen in der Anweisung <database>DELETE</database> zu qualifizieren.
        <formalpara>
          <title>Beispiele</title>
          <para>
            <blockquote>
            <para>Unterstützte Verwendung:</para>

            <programlisting>delete from Cities where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities where Cities.name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where C.name starting 'Alex'</programlisting>

            <para>Nicht möglich:</para>

            <programlisting>delete from Cities C where Cities.name starting 'Alex'</programlisting>
              </blockquote>
          </para>
        </formalpara>
      </para>
    </section>

    <section id="fblangref25-dml-delete-where-de">
      <title><database>WHERE</database></title>

      <para>Die WHERE-Klausel legt die Bedingungen fest, die den Satz von Datensätzen für ein
      <firstterm>searched delete</firstterm> begrenzen.</para>
      <para>Wenn in PSQL ein benannter Cursor zum Löschen eines Satzes verwendet wird und die 
          Klausel <database>WHERE CURRENT OF</database> verwendet wird, ist die Aktion auf die Zeile 
          beschränkt, in der sich der Cursor gerade befindet. Dies ist ein <firstterm>positioniertes Update</firstterm>.
        <note>
          <para>Die Klausel <database>WHERE CURRENT OF</database> ist nur in PSQL und ESQL verfügbar, 
          da es keine Anweisung zum Erstellen und Bearbeiten eines expliziten Cursors in DSQL gibt. 
          Gesuchte Löschungen sind natürlich auch in PSQL verfügbar.</para>
        </note>
      </para>

      <formalpara>
        <title>Beispiele</title>
        <para>
          <blockquote><programlisting>
DELETE FROM People
  WHERE firstname &lt;&gt; 'Boris' AND lastname &lt;&gt; 'Johnson'
         </programlisting>

          <programlisting>
DELETE FROM employee e
  WHERE NOT EXISTS(
    SELECT *
    FROM employee_project ep
     WHERE e.emp_no = ep.emp_no);
         </programlisting>

         <programlisting>
DELETE FROM Cities
  WHERE CURRENT OF Cur_Cities;  -- ESQL and PSQL only
         </programlisting>
          </blockquote>
        </para>
      </formalpara>
    </section><!-- where -->

    <section id="fblangref25-dml-delete-plan-de">
      <title><database>PLAN</database></title>
      <para>Eine <database>PLAN</database>-Klausel erlaubt dem Benutzer die Operation
      manuell zu optimieren.</para>

      <formalpara>
        <title>Beispiel</title>

        <para>
          <blockquote><programlisting>
DELETE FROM Submissions
  WHERE date_entered &lt; '1-Jan-2002'
  PLAN (Submissions INDEX ix_subm_date);
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-delete-orderby-de">
      <title><database>ORDER BY</database> und <database>ROWS</database></title>
      <para>Die Klausel <database>ORDER BY</database> sortiert die Menge vor dem 
      eigentlichen Löschen. Es ist nur in Kombination mit <database>ROWS</database> 
      sinnvoll, aber auch ohne gültig.</para>

      <para>Die Klausel <database>ROWS</database> begrenzt die Anzahl der gelöschten Zeilen. 
      Integer-Literale oder beliebige Integer-Ausdrücke können für die Argumente <replaceable>m</replaceable> 
      und <replaceable>n</replaceable> verwendet werden.
      </para>

      <para>Wenn <database>ROWS</database> ein Argument <replaceable>m</replaceable> hat, sind die zu löschenden 
      Zeilen auf die ersten <replaceable>m</replaceable> Zeilen beschränkt.
        <formalpara>
          <title>Wichtige Punkte</title>
          <itemizedlist spacing="compact">
            <listitem>Wenn m &gt; der Anzahl zu verarbeitender Zeilen, wird der gesamte Zeilensatz 
                gelöscht</listitem>
            <listitem>Wenn m = 0, werden keine Zeilen gelöscht</listitem>
            <listitem>Wenn m &lt; 0, tritt ein Fehler auf und die Löschung schlägt fehl</listitem>
          </itemizedlist>
        </formalpara>
      </para>

      <para>Werden die zwei Argumente <replaceable>m</replaceable> und <replaceable>n</replaceable> verwendet, 
      begrenzt <database>ROWS</database>die Anzahl der zu löschenden Zeilen, inklusive
      <replaceable>m</replaceable> bis <replaceable>n</replaceable>.
      Beide Argumente sind Ganzzahlen und beginnen bei 1.
        <formalpara>
          <title>Wichtige Punkte</title>
          <itemizedlist spacing="compact">
            <listitem>Wenn m &gt; der Anzahl der zu verarbeitenden Zeilen, wird keine Zeile gelöscht</listitem>
            <listitem>Wenn m &gt; 0 und &lt;= der Anzahl der Zeilen im Satz und n außerhalb dieser Werte liegt,
            werden die Zeilen von m bis zum Ende des Satzes gelöscht</listitem>
            <listitem>Wenn m &lt; 1 oder n &lt; 1, wird ein Fehler ausgegeben und das Löschen schlägt fehl</listitem>
            <listitem>Wenn n = m - 1, werden keine Zeilen gelöscht</listitem>
            <listitem>Wenn n &lt; m -1, wird ein Fehler ausgegeben und das Löschen schlägt fehl</listitem>
          </itemizedlist>
        </formalpara>
      </para>

      <formalpara>
        <title>Beispiele</title>
        <para>
          <blockquote>
         <para>Löschen des ältesten Kaufs:
            <programlisting>
DELETE FROM Purchases
  ORDER BY date ROWS 1
            </programlisting></para>
         <para>Löschen der höchsten Kundennummer(n):
            <programlisting>
DELETE FROM Sales
  ORDER BY custno DESC ROWS 1 to 10
            </programlisting></para>
         <para>Löschen aller Verkäufe, <database>ORDER BY</database>-Klausel ist sinnlos:
            <programlisting>
DELETE FROM Sales
  ORDER BY custno DESC
            </programlisting></para>
         <para>Löschen eines Datensatzes beginnend vom Ende, z.B. von Z&hellip;:
            <programlisting>
DELETE FROM popgroups
  ORDER BY name DESC ROWS 1
            </programlisting></para>
         <para>Löschen der fünf ältesten Gruppen:
            <programlisting>
DELETE FROM popgroups
  ORDER BY formed ROWS 5
            </programlisting></para>
         <para>Es wird keine Sortierung (<database>ORDER BY</database>) angegeben, 
         so dass 8 gefundene Datensätze, beginnend mit dem fünften, gelöscht werden:
            <programlisting>
DELETE FROM popgroups
  ROWS 5 TO 12
            </programlisting></para>
          </blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-delete-returning-de">
      <title><database>RETURNING</database></title>
      <para>Eine Anweisung <database>DELETE</database>, die <emphasis>in höchstens einer Zeile</emphasis> 
      löscht, kann optional eine Klausel <database>RETURNING</database> enthalten, um Werte aus der 
      gelöschten Zeile zurückzugeben. Die Klausel muss, falls vorhanden, nicht alle Spalten der Beziehung 
      enthalten und kann auch andere Spalten oder Ausdrücke enthalten.
      </para>
      <note>
        <title>Hinweise</title>
        <itemizedlist>
          <listitem>In DSQL gibt eine Anweisung mit <database>RETURNING</database> immer einen Singleton 
          zurück, niemals einen Satz mit mehreren Zeilen. Wenn keine Datensätze gelöscht werden, enthalten 
          die zurückgegebenen Spalten <constant>NULL</constant>. Dieses Verhalten kann sich in zukünftigen 
              Firebird-Versionen ändern</listitem>
          <listitem>Die <database>INTO</database>-Klausel ist nur in PSQL verfügbar
            <itemizedlist>
              <listitem>Wenn die Zeile nicht gelöscht wird, wird nichts zurückgegeben und die 
                  Zielvariablen behalten ihre Werte bei</listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </note>

      <formalpara>
        <title>Beispiele</title>
        <para>
          <blockquote>
             <programlisting>
DELETE FROM Scholars
  WHERE firstname = 'Henry' and lastname = 'Higgins'
  RETURNING lastname, fullname, id
            </programlisting>

            <programlisting>
DELETE FROM Dumbbells
  ORDER BY iq DESC
  ROWS 1
  RETURNING lastname, iq into :lname, :iq;
            </programlisting>
         </blockquote>
        </para>
      </formalpara>
    </section>
    <important>
      <title>Das Problem mit dem <quote>instabilen Cursor</quote></title>
      <para>Aufgrund der Art und Weise, in der die Ausführung der datenverändernden DML in Firebird bis 
          einschließlich dieser Version implementiert wird, führen die zum Löschen bestimmten Sätze 
          manchmal zu unerwarteten Ergebnissen.  Weitere Informationen finden Sie unter
      <link linkend="fblangref25-dml-update-unstable-de">
      <citetitle>Das Problem mit dem <quote>instabilen Cursor</quote> Problem</citetitle></link> im Abschnitt
      <database>UPDATE</database>.</para>
    </important>
  </section>  <!-- DELETE -->

<!-- ========================================================================================
                   M E R G E
     ======================================================================================== -->

  <section id="fblangref25-dml-merge-de">
    <title><database>MERGE</database></title>
      <formalpara>
        <title>Verwendet für</title>
        <para>&nbsp;Daten aus einer Quellenmenge in eine Zielbeziehung zusammenführen</para>
      </formalpara>

    <formalpara>
      <title>Verfügbar in</title>

      <para>DSQL, PSQL<!--ESQL... guess not--></para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>MERGE INTO <replaceable>target</replaceable> [[AS] <replaceable>target-alias</replaceable>]
   USING <replaceable>source</replaceable> [[AS] <replaceable>source-alias</replaceable>]
   ON <replaceable>join-condition</replaceable>
   WHEN MATCHED THEN UPDATE SET <replaceable>colname</replaceable> = <replaceable>value</replaceable> [, <replaceable>colname</replaceable> = <replaceable>value</replaceable> ...]
   WHEN NOT MATCHED THEN INSERT [(<replaceable>&lt;columns&gt;</replaceable>)] VALUES (<replaceable>&lt;values&gt;</replaceable>)

<replaceable>&lt;columns&gt;</replaceable>  ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;values&gt;</replaceable>   ::=  <replaceable>value</replaceable>   [, <replaceable>value</replaceable>   ...]
        </programlisting>
      </blockquote></para>
    </formalpara>

      <table id="fblangref25-dml-tbl-merge-de">
      <?dbfo keep-together='auto'?>
        <title>Argumente der MERGE-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">Name der Zielbeziehung (Tabelle oder änderbare Sicht)</entry>
            </row>
            <row valign="middle">
              <entry align="center">source</entry>
              <entry align="left">Datenquelle. Es kann eine Tabelle, eine Ansicht, eine gespeicherte Prozedur oder eine abgeleitete Tabelle sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">target-alias</entry>
              <entry align="left">Alias für die Zielbeziehung (Tabelle oder änderbare Sicht)</entry>
            </row>
            <row valign="middle">
              <entry align="center">source-alias</entry>
              <entry align="left">Alias für die Quellbeziehung oder den Quellsatz</entry>
            </row>
            <row valign="middle">
              <entry align="center">join-conditions</entry>
              <entry align="left">Die (ON) Bedingung(en) zum Abgleich der Quelldatensätze mit denen im Ziel</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name einer Spalte in der Zielbeziehung</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">Der Wert, der einer Spalte in der Zieltabelle zugewiesen ist. Es ist ein Ausdruck, der ein 
                  Literalwert, eine PSQL-Variable, eine Spalte aus der Quelle oder eine kompatible Kontextvariable sein kann</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <bridgehead renderas="sect4">Beschreibung</bridgehead>
    <para>Das <database>MERGE</database>-Statement führt Daten in einer Tabelle 
    oder aktualisierbaren Sicht zusammen. Die Quelle kann eine Tabelle, eine Sicht 
    oder ein allgemeines <quote><database>SELECT</database> FROM</quote> sein. 
    Jeder Quelldatensatz wird verwendet, um einen oder mehrere Zieldatensätze zu aktualisieren, 
    einen neuen Datensatz in die Zieltabelle einzufügen oder keinen.</para>
    <para>Die durchgeführte Aktion hängt von der angegebenen Join-Bedingung und 
        den <database>WHEN</database>-Klauseln ab. Die Bedingung enthält normalerweise 
        einen Vergleich der Felder in den Quell- und Zielbeziehungen.</para>

    <note>
      <title>Hinweise</title>
      <para>Nur eine der <database>WHEN</database>-Klauseln kann bereitgestellt werden. 
      Dies wird sich in der nächsten Hauptversion von Firebird ändern, wenn 
      Compound-Matching-Bedingungen unterstützt werden.</para>
      <para><database>WHEN NOT MATCHED</database> wird aus der Quellensicht ausgewertet, 
      d. h. der Tabelle oder dem Satz, der in <database>USING</database> angegeben ist. Die ist zwangsläufig so,
      da <database>INSERT</database> ausgeführt wird, wenn der Quelldatensatz 
      keinem Zieldatensatz entspricht. Wenn es einen Zieldatensatz gibt, der keinem Quelldatensatz 
      entspricht, wird natürlich nichts unternommen.</para>
      <para>Derzeit gibt die Variable ROW_COUNT den Wert 1 zurück, auch wenn mehr als ein Datensatz 
          geändert oder eingefügt wird. Einzelheiten und Fortschritt finden Sie unter
      <ulink url="http://tracker.firebirdsql.org/browse/CORE-4400">Tracker ticket CORE-4400</ulink>.</para>
    </note>
    <warning>
      <title>ACHTUNG :: Eine weitere Unregelmäßigkeit!</title>
      <para>Wenn die Klausel <database>WHEN MATCHED</database> vorhanden ist und mehrere Datensätze einem 
      einzelnen Datensatz in der Zieltabelle entsprechen, wird ein <database>UPDATE</database> für diesen 
      Zieldatensatz je übereinstimmender Quelle ausgeführt, wobei jedes nachfolgende 
      Update das vorherige überschreibt. Dieses Verhalten entspricht nicht dem SQL: 2003-Standard, der erfordert, 
      dass diese Situation eine Ausnahme (einen Fehler) auslöst.</para>
    </warning>

    <formalpara>
      <title>Beispiele</title>
      <para>
        <blockquote>
          <programlisting>
MERGE INTO books b
  USING purchases p
  ON p.title = b.title and p.type = 'bk'
  WHEN MATCHED THEN
    UPDATE SET b.desc = b.desc || '; ' || p.desc
  WHEN NOT MATCHED THEN
    INSERT (title, desc, bought) values (p.title, p.desc, p.bought)
          </programlisting>

          <programlisting>
MERGE INTO customers c
  USING (SELECT * from customers_delta WHERE id &gt; 10) cd
  ON (c.id = cd.id)
  WHEN MATCHED THEN
    UPDATE SET name = cd.name
  WHEN NOT MATCHED THEN
    INSERT (id, name) values (cd.id, cd.name)
          </programlisting>

          <programlisting>
MERGE INTO numbers
USING (
  WITH RECURSIVE r(n) AS (
    SELECT 1 FROM rdb$database
    UNION ALL
    SELECT n+1 FROM r WHERE n &lt; 200
  )
  SELECT n FROM r
) t
ON numbers.num = t.n
WHEN NOT MATCHED THEN
  INSERT(num) VALUES(t.n);
          </programlisting>
        </blockquote>
      </para>
    </formalpara>
    <important>
      <title>Das Problem mit dem <quote>instabilen Cursor</quote></title>
      <para>Aufgrund der Art und Weise, in der die Ausführung der datenverändernden DML in 
          Firebird bis einschließlich dieser Version implementiert wird, führen die für das 
          Zusammenführen ausgewählten Sets manchmal zu unerwarteten Ergebnissen. 
          Für weitere Informationen vergleichen Sie auch
      <link linkend="fblangref25-dml-update-unstable-de">
      <citetitle>Das Problem mit dem <quote>instabilen Cursor</quote></citetitle></link> im Abschnitt
      <database>UPDATE</database>.</para>
    </important>

  </section><!-- MERGE -->



<!-- ========================================================================================
                   E X E C U T E   P R O C E D U R E
     ======================================================================================== -->

  <section id="fblangref25-dml-execproc-de">
    <title><database>EXECUTE PROCEDURE</database></title>

    <formalpara>
      <title>Verwendet für</title>
      <para>&nbsp;Ausführen einer gespeicherten Prozedur</para>
    </formalpara>

    <formalpara>
      <title>Verfügbar in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para>
        <blockquote>
          <programlisting>
EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]] | [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]
   [RETURNING_VALUES <replaceable>&lt;outvar&gt;</replaceable> [, <replaceable>&lt;outvar&gt;</replaceable> ...] | (<replaceable>&lt;outvar&gt;</replaceable> [, <replaceable>&lt;outvar&gt;</replaceable> ...])]

<replaceable>&lt;outvar&gt;</replaceable> ::= [:]varname
          </programlisting>
        </blockquote>
      </para>
    </formalpara>
    
      <table id="fblangref25-dml-tbl-execproc-de">
      <?dbfo keep-together='auto'?>
        <title>Argument der EXECUTE PROCEDURE-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name der gespeicherten Prozedur</entry>
            </row>
            <row valign="middle">
              <entry align="center">inparam</entry>
              <entry align="left">Ein Ausdruck, der den deklarierten Datentyp eines Eingabeparameters auswertet</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Eine PSQL-Variable zum Empfangen des Rückgabewerts</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Beschreibung</title>

      <para>Führt eine <firstterm>ausführbare gespeicherte Prozedur</firstterm> aus, die eine Liste 
      aus einem oder mehreren Eingabeparametern verwendet, wenn sie für die Prozedur definiert sind, 
      und eine einreihige Menge von Ausgabewerten zurückgibt, wenn sie für die Prozedur definiert sind.</para>
    </formalpara>

    <section id="fblangref25-dml-execproc-which-de">
      <title><quote>Ausführbare</quote> gespeicherte Prozedur</title>
      <para>Das Statement <database>EXECUTE PROCEDURE</database> wird am häufigsten verwendet, um die 
      Art gespeicherte Prozedur aufzurufen, die geschrieben wird, um eine datenmodifizierende 
      Aufgabe auf der Serverseite auszuführen&mdash;das sind die Prozeduren, die kein <database>SUSPEND</database>-Statement
      im Code enthalten. Sie können so entworfen werden, dass sie eine Ergebnismenge zurückgeben, die nur aus einer Zeile 
      besteht, die normalerweise über eine Gruppe von <database>RETURNING_VALUES()</database>-Variablen an eine andere 
      gespeicherte Prozedur übergeben wird, die sie aufruft. Clientschnittstellen verfügen normalerweise über einen 
      API-Wrapper, der beim Aufruf von <database>EXECUTE PROCEDURE</database> in DSQL die Ausgabewerte in einen einzeiligen
      Puffer abrufen kann.</para>
      <para>Das Aufrufen der anderen Prozedurart&mdash;eine <quote>auswählbare</quote>&mdash; ist möglich mit 
      <database>EXECUTE PROCEDURE</database>, aber es gibt nur die erste Zeile eines Ausgabesatzes zurück, der fast sicher 
      als mehrzeilig ausgelegt ist. Auswählbare gespeicherte Prozeduren werden von einer Anweisung <database>SELECT</database> aufgerufen, 
      die eine Ausgabe erzeugt, die sich wie eine virtuelle Tabelle verhält.</para>
    </section>

    <note>
      <title>Hinweise</title>
      <itemizedlist>
        <listitem>
          <para>In PSQL und DSQL können Eingabeparameter beliebige Ausdrücke sein, die in den erwarteten Typ aufgelöst werden.</para>
        </listitem>
        <listitem>
          <para>Obwohl nach dem Namen der gespeicherten Prozedur keine Klammern erforderlich sind, um die Eingabeparameter zu 
              umschließen, wird ihre Verwendung aus Gründen einer guten Verwaltung empfohlen.</para>
        </listitem>
        <listitem>
          <para>Wenn Ausgabeparameter in einer Prozedur definiert wurden, kann die Klausel <database>RETURNING_VALUES</database> 
          in PSQL verwendet werden, um sie über eine Liste zuvor deklarierter Variablen abzurufen, die mit den definierten Ausgabeparametern 
          in Reihenfolge, Datentyp und Nummer übereinstimmen.</para>
        </listitem>
        <listitem>
          <para>Die Liste der <database>RETURNING_VALUES</database> kann optional in runde Klammern gesetzt werden und ihre 
          Verwendung wird empfohlen.</para>
        </listitem>
        <listitem>
          <para>Wenn DSQL-Anwendungen <database>EXECUTE PROCEDURE</database> mithilfe der Firebird-API oder eines Wrappers 
          aufrufen, wird ein Puffer für den Empfang der Ausgabezeile vorbereitet, und die Klausel <database>RETURNING_VALUES</database> 
          wird nicht verwendet.</para>
        </listitem>
      </itemizedlist>
    </note>
    <formalpara>
      <title>Beispiele</title>
      <para>
        <blockquote>
          <para>In PSQL mit optionalen Doppelpunkten und ohne optionale Klammern:</para>
          <programlisting>
EXECUTE PROCEDURE MakeFullName
  :FirstName, :MiddleName, :LastName
  RETURNING_VALUES :FullName;
          </programlisting>

          <para>In Firebirds Befehlszeilenprogramm 
              <emphasis>isql</emphasis> mit Literalparametern 
              und optionalen Klammern:</para>
          <programlisting>
EXECUTE PROCEDURE MakeFullName ('J', 'Edgar', 'Hoover');
          </programlisting>

          <para><emphasis role="bold">Hinweis:</emphasis> In <emphasis>isql</emphasis>,
          wird <database>RETURNING_VALUES</database> nicht verwendet. Alle Ausgabewerte werden 
          von der Anwendung erfasst und automatisch angezeigt.</para>

          <para>Ein PSQL-Beispiel mit Ausdrucksparametern und optionalen Klammern:</para>
          <programlisting>
EXECUTE PROCEDURE MakeFullName
  ('Mr./Mrs. ' || FirstName, MiddleName, upper(LastName))
  RETURNING_VALUES (FullName);
          </programlisting>
        </blockquote>
        </para>
    </formalpara>
  </section> <!-- EXECUTE PROCEDURE -->

<!-- ========================================================================================
                   E X E C U T E   B L O C K
     ======================================================================================== -->

  <section id="fblangref25-dml-execblock-de">
    <title><database>EXECUTE BLOCK</database></title>
    <formalpara>
      <title>Verwendet für</title>
      <para>&nbsp;Erstellen eines <quote>anonymen</quote> Blocks von PSQL-Code 
      in DSQL zur sofortigen Ausführung</para>
    </formalpara>

    <formalpara>
      <title>Verfügbar in</title>
      <para>DSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para>
        <blockquote>
          <programlisting>
EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparams&gt;</replaceable>         ::=  <replaceable>&lt;param_decl&gt;</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable> ]
<replaceable>&lt;outparams&gt;</replaceable>        ::=  <replaceable>&lt;param_decl&gt;</replaceable>     [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;param_decl&gt;</replaceable>       ::=  <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
<replaceable>&lt;type&gt;</replaceable>             ::=  <replaceable>datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>

<replaceable>datatype</replaceable> ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

<replaceable>&lt;declarations&gt;</replaceable>     ::=  <replaceable>declare_item</replaceable> [<replaceable>declare_item</replaceable> ...]
<replaceable>declare_item</replaceable> ::=  <replaceable>declare_var</replaceable>; | <replaceable>declare_cursor</replaceable>
          </programlisting>
        </blockquote>
      </para>
    </formalpara>

      <table id="fblangref25-dml-tbl-execblock-de">
      <?dbfo keep-together='auto'?>
        <title>Argument der EXECUTE BLOCK-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">param_decl</entry>
              <entry align="left">Name und Beschreibung eines Eingabe- oder Ausgabeparameters</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Ein Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Lokale Variablendeklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Deklaration eines benannten Cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">Der Name eines Eingabe- oder Ausgabeparameters des prozeduralen Blocks mit bis zu 31 
                  Zeichen. Der Name muss unter Ein- und Ausgabeparametern und lokalen Variablen im Block eindeutig sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Sortierreihenfolge</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Domain</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel</entry>
              <entry align="left">Name einer Tabelle oder Ansicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Name einer Spalte in einer Tabelle oder Sicht</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Präzision. Von 1 bis 18</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Rahmen. Von 0 bis 18. Es muss kleiner oder gleich <replaceable>precision</replaceable> sein </entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe einer Zeichenfolge in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Zeichensatz</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB-Subtypennummer</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">mnemotechnischer Name des BLOB-Subtyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße, kann nicht größer als 65.535 sein</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    <formalpara>
      <title>Beschreibung</title>

      <para>Führt einen PSQL-Block aus, als wäre es eine gespeicherte Prozedur, optional 
          mit Eingabe- und Ausgabeparametern und Variablendeklarationen. Dies ermöglicht dem 
          Benutzer <quote>on-the-fly</quote> PSQL innerhalb eines DSQL-Kontexts auszuführen.</para>
    </formalpara>

    <formalpara>
      <title>Beispiele</title>
      <para>
        <blockquote><programlisting>
          <para>In diesem Beispiel werden die Zahlen 0 bis 127 und die entsprechenden ASCII-Zeichen 
              in die Tabelle <database>ASCIITABLE</database> eingefügt:</para>
EXECUTE BLOCK
AS
declare i INT = 0;
BEGIN
  WHILE (i &lt; 128) DO
  BEGIN
    INSERT INTO AsciiTable VALUES (:i, ascii_char(:i));
    i = i + 1;
  END
END
          </programlisting>
        </blockquote>
        <blockquote>
          <para>Das nächste Beispiel berechnet das geometrische Mittel 
              zweier Zahlen und gibt es an den Benutzer zurück:</para>
           <programlisting>
EXECUTE BLOCK (x DOUBLE PRECISION = ?, y DOUBLE PRECISION = ?)
RETURNS (gmean DOUBLE PRECISION)
AS
BEGIN
  gmean = SQRT(x*y);
  SUSPEND;
END
          </programlisting>

          <para>Da dieser Block Eingabeparameter hat, muss er zuerst vorbereitet werden. 
              Dann können die Parameter eingestellt und der Block ausgeführt werden. Es 
              hängt von der Client-Software ab, wie dies durchgeführt werden muss. Auch 
              wenn dies möglich ist&mdash;beachten Sie die folgenden Hinweise.</para>

          <para>Unser letztes Beispiel nimmt zwei ganzzahlige Werte, 
              <varname>smallest</varname> und <varname>largest</varname>. Für alle Zahlen 
              im Bereich <varname>smallest</varname> ... <varname>largest</varname> gibt 
              der Block die Zahl selbst, sein Quadrat, seine dritte und seine vierte Potenz aus.</para>

          <programlisting>
EXECUTE BLOCK (smallest INT = ?, largest INT = ?)
RETURNS (number INT, square BIGINT, cube BIGINT, fourth BIGINT)
AS
BEGIN
  number = smallest;
  WHILE (number &lt;= largest) DO
  BEGIN
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    SUSPEND;
    number = number + 1;
  END
END
          </programlisting>
          <para>Auch hier hängt es von der Client-Software ab, ob und wie Sie 
              die Parameterwerte einstellen können.</para>
        </blockquote>
       </para>
    </formalpara>

    <section id="fblangref25-dml-execblock-params-de">
      <title>Eingabe- und Ausgabeparameter</title>

      <para>Das Ausführen eines Blocks ohne Eingabeparameter sollte mit jedem 
          Firebird-Client möglich sein, der es dem Benutzer erlaubt, seine eigenen 
          DSQL-Anweisungen einzugeben. Wenn es Eingabeparameter gibt, werden die 
          Dinge komplizierter: Diese Parameter müssen ihre Werte erhalten, nachdem 
          die Anweisung vorbereitet wurde, aber bevor sie ausgeführt wird. Dies erfordert 
          spezielle Voraussetzungen, die nicht jede Client-Anwendung bietet. 
          (Firebirds eigenes <application>isql</application>, zum Beispiel, nicht.)</para>

      <para>Der Server akzeptiert nur Fragezeichen
      (<quote><literal>?</literal></quote>) als Platzhalter für die Eingabewerte,
      also nicht <quote><literal>:a</literal></quote>,
      <quote><literal>:MyParam</literal></quote> etc., oder Literalwerte.
      Client-Software unterstützt möglicherweise die Form
      <quote><literal>:xxx</literal></quote> und wandelt es vor dem Senden 
      an den Server um.</para>

      <para>Wenn der Block Ausgabeparameter hat, <emphasis>müssen</emphasis> Sie <database>SUSPEND</database> 
      verwenden, sonst wird nichts zurückgegeben.</para>

      <para>Die Ausgabe erfolgt immer in Form einer Ergebnismenge, genau wie bei 
          einer Anweisung mit <database>SELECT</database>. Sie können weder
      <database>RETURNING_VALUES</database> verwenden noch einen Block mit
      <database>INTO</database> in Variablen anwenden, auch wenn es nur eine Ergebniszeile 
      gibt.</para>

      <sidebar>
        <title>PSQL Links</title>
        <para>Weitere Informationen zu Parameter- und Variablendeklarationen und
            <replaceable>&lt;PSQL-Statements&gt;</replaceable> liefert Ihnen Kapitel 7,
        <link linkend="fblangref25-psql-de"><citetitle>Prozedurale SQL-Anweisungen (PSQL)</citetitle></link>.</para>
        <para>Für <replaceable>&lt;Deklarationen&gt;</replaceable> im Speziellen, vgl.
        <link linkend="fblangref25-psql-declare-variable-de"><database>DECLARE [VARIABLE]</database></link>
        und <link linkend="fblangref25-psql-declare-cursor-de"><database>DECLARE CURSOR</database></link> für
        die exakte Syntax.</para>
      </sidebar>
    </section>
    
    <section id="fblangref25-dml-terminators-de">
      <title>Statement-Terminatoren</title>
      <para>Einige SQL-Statement-Editoren&mdash;insbesondere das <emphasis>isql</emphasis>-Dienstprogramm, 
      das mit Firebird geliefert wird, und möglicherweise einige Editoren von Drittanbietern&mdash;verwenden 
      eine interne Konvention, die erfordert, dass alle Anweisungen mit einem Semikolon abgeschlossen werden. 
      Dies erzeugt einen Konflikt mit der PSQL-Syntax beim Codieren in diesen Umgebungen. Wenn Sie mit diesem 
      Problem und seiner Lösung nicht vertraut sind, lesen Sie die Details im Kapitel PSQL im Abschnitt 
        <link linkend="fblangref25-sidebar01-de">Umschalten des Terminators in <emphasis>isql</emphasis></link>.</para>
    </section>
  </section>  <!-- EXECUTE BLOCK -->

</chapter>
