<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-ddl-de">
  <title>Statements der Data Definition (DDL)</title>
  <para>DDL ist die Untermenge der SQL-Sprache von Firebird zum Festlegen von Datendefinitionen.
   DDL-Anweisungen werden zum Erstellen, Ändern und Löschen von Datenbankobjekten verwendet, die
   von Benutzern erstellt wurden. Wenn eine DDL-Anweisung commited wird, werden die Metadaten für die
   Objekte erstellt, geändert oder gelöscht.
   </para>

  <section id="fblangref25-ddl-db-de">
    <title><database>DATABASE</database></title>
    <para>In diesem Abschnitt wird beschrieben, wie Sie eine Datenbank erstellen, eine Verbindung 
        zu einer vorhandenen Datenbank herstellen, die Dateistruktur einer Datenbank ändern und 
        löschen. Außerdem wird erläutert, wie Sie eine Datenbank auf zwei verschiedene Arten 
        sichern können und wie Sie die Datenbank in den <quote>kopiersicheren</quote> Modus 
            umwandeln können, um ein externes Backup sicher durchzuführen.
    </para>
    <section id="fblangref25-ddl-db-create-de">
      <title><database>CREATE DATABASE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <programlisting>
       CREATE {DATABASE | SCHEMA} '&lt;<replaceable>filespec</replaceable>&gt;'
       [USER <replaceable>'username'</replaceable> [PASSWORD <replaceable>'password'</replaceable>]]
       [PAGE_SIZE [=] <replaceable>size</replaceable>]
       [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]
       [SET NAMES '<replaceable>charset</replaceable>'] 
       [DEFAULT CHARACTER SET <replaceable>default_charset</replaceable>
         [COLLATION <replaceable>collation</replaceable>]] -- not supported in ESQL
       [&lt;<replaceable>sec_file</replaceable>&gt; [&lt;<replaceable>sec_file</replaceable>&gt; ...]]
       [DIFFERENCE FILE '<replaceable>diff_file</replaceable>']; -- not supported in ESQL

       &lt;<replaceable>filespec</replaceable>&gt; ::= [&lt;<replaceable>server_spec</replaceable>&gt;]{<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}

       &lt;<replaceable>server_spec</replaceable>&gt; ::= <replaceable>servername [/{port|service}]:</replaceable> | <replaceable>\\servername\</replaceable>

       &lt;<replaceable>sec_file</replaceable>&gt; ::= FILE '<replaceable>filepath</replaceable>'
       [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]] [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]
        </programlisting>
      </formalpara>

      <table id="fblangref25-ddl-tbl-createdatabase-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE DATABASE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">filespec</entry>
              <entry align="left">Dateispezifikation für primäre Datenbankdatei</entry>
            </row>
            <row valign="middle">
              <entry align="center">server_spec</entry>
              <entry align="left">Spezifikation des Remoteservers im TCP / IP- oder 
                  Windows-Netzwerkstil. Enthält optional eine Portnummer oder 
                  einen Servicenamen</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Vollständiger Pfad und Dateiname einschließlich seiner Erweiterung. 
                  Der Dateiname muss gemäß den Regeln des verwendeten Plattformdateisystems 
                  angegeben werden.
                  </entry>
            </row>
            <row valign="middle">
              <entry align="center">db_alias</entry>
              <entry align="left">Datenbank-Alias, der zuvor in der Datei
              <filename>aliases.conf</filename> definiert wurde.</entry>
            </row>
            <row valign="middle">
              <entry align="center">servername</entry>
              <entry align="left">Hostname oder IP-Adresse des Servers, auf dem die Datenbank
               erstellt werden soll.</entry>
            </row>
            <row valign="middle">
              <entry align="center">username</entry>
              <entry align="left">Benutzername des Eigentümers der neuen Datenbank. 
                  Es kann aus bis zu 31 Zeichen bestehen. Groß- / Kleinschreibung ist 
                  vernachlässigbar.</entry>
            </row>
            <row valign="middle">
              <entry align="center">password</entry>
              <entry align="left">Kennwort des Benutzers oder Datenbankeigentümers. Die maximale
                  Länge beträgt 31 Zeichen; es werden jedoch nur die ersten 8 Zeichen berücksichtigt.
                  Groß- / Kleinschreibung beachten.</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Seitengröße der Datenbank in Bytes. Mögliche Werte sind 4096
              (Standard), 8192 und 16384</entry>
            </row>
            <row valign="middle">
              <entry align="center">num</entry>
              <entry align="left">Maximale Größe des primären Datenbankdatei, oder einer sekundären, 
                  in Seiten (pages).
              </entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Legt den Zeichensatz der Verbindung fest, die von einem Client verwendet wird,
                  nachdem die Datenbank erfolgreich erstellt wurde. Einfache Anführungszeichen sind zu verwenden.
              </entry>
            </row>
            <row valign="middle">
              <entry align="center">default_charset</entry>
              <entry align="left">Legt den Standardzeichensatz für String-Datentypen fest.</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Standard-Collation für den Standardzeichensatz</entry>
            </row>
            <row valign="middle">
              <entry align="center">sec_file</entry>
              <entry align="left">Dateispezifikation für eine sekundäre Datei</entry>
            </row>
            <row valign="middle">
              <entry align="center">pagenum</entry>
              <entry align="left">Startseitenzahl für eine sekundäre Datenbankdatei</entry>
            </row>
            <row valign="middle">
              <entry align="center">diff_file</entry>
              <entry align="left">Dateipfad und -name für DIFFERENCE-Dateien (.delta-Dateien)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Das Statement <database>CREATE DATABASE</database> erstellt eine neue Datenbank. 
      Sie können sowohl <database>CREATE DATABASE</database> wie auch <database>CREATE SCHEMA</database> 
      verwenden. Dies sind Synonyme füreinander.</para>
      <para>Eine Datenbank besteht aus einer oder mehrerer Dateien. Die erste (Haupt-) Datei
          wird auch als die <emphasis>primäre Datei</emphasis> bezeichnet, folgende als 
      <emphasis>sekundäre Datei[en]</emphasis>.</para>
      <note>
        <title>Multi-Datei-Datenbanken</title>
        <para>Heutzutage gelten Multi-File-Datenbanken als rückschrittlich. Es ist sinnvoll, 
            Datenbanken mit mehreren Dateien auf alten Dateisystemen zu verwenden, bei denen 
            die Größe einer Datei begrenzt ist. Sie können beispielsweise keine Datei mit mehr 
            als 4 GB auf FAT32 erstellen.
        </para>
      </note>
      <para>Die primäre Dateispezifikation ist der Name der Datenbankdatei und ihrer Erweiterung 
          mit dem vollständigen Pfad zu den Regeln des verwendeten Betriebssystemplattformdateisystems. 
          Die Datenbankdatei darf zum Zeitpunkt der Datenbankerstellung nicht vorhanden sein. 
          Wenn dies der Fall ist, erhalten Sie eine Fehlermeldung und die Datenbank wird nicht erstellt.
      </para>
      <para>Wenn der vollständige Pfad zur Datenbank nicht angegeben ist, wird die Datenbank in einem 
          der Systemverzeichnisse erstellt. Das bestimmte Verzeichnis hängt vom Betriebssystem ab. 
          Geben Sie daher immer den absoluten Pfad an, wenn Sie entweder die Datenbank oder einen 
          <emphasis>Alias</emphasis> dafür erstellen, es sei denn, Sie haben einen guten Grund, 
          diese Situation zu bervorzugen.</para>

      <section id="fblangref25-ddl-db-alias-de">
        <title>Einen Datenbank-Alias verwendenUsing a Database Alias</title>
        <para>Sie können Aliasnamen anstelle des vollständigen Pfads zur primären Datenbankdatei verwenden. 
            Aliase sind in der Datei <filename>aliases.conf</filename> im folgenden Format definiert:
          <literallayout class="monospaced">
       alias = filepath
          </literallayout>
        </para>
      </section>

      <section id="fblangref25-ddl-db-createremote-de">
        <title>Eine Datenbank remote erstellen</title>
        <para>Wenn Sie eine Datenbank auf einem Remoteserver erstellen, sollten Sie 
            die Spezifikation des Remoteservers angeben. Die Spezifikation des 
            Remoteservers hängt vom verwendeten Protokoll ab. Wenn Sie das TCP / IP-Protokoll 
            zum Erstellen einer Datenbank verwenden, sollte die primäre Dateispezifikation 
            wie folgt aussehen:
        <blockquote>
          <programlisting>
servername[/{port|service}]:{filepath | db_alias}
          </programlisting>
        </blockquote>
        Wenn Sie das Named Pipes-Protokoll verwenden, um eine Datenbank auf einem Windows-Server 
        zu erstellen, sollte die primäre Dateispezifikation wie folgt aussehen:
        <blockquote>
          <programlisting>
\\servername\{filepath | db_alias}
          </programlisting>
        </blockquote>
        </para>
      </section>

      <section id="fblangref25-ddl-db-createdbopts-de">
        <title>Optionale Parameter für <database>CREATE DATABASE</database></title>
        <formalpara><title>Optional von <database>USER</database> und <database>PASSWORD</database></title>
          <para>Klauseln zur Angabe des Benutzernamens bzw. des Passworts eines vorhandenen Benutzers 
              in der Sicherheitsdatenbank <filename>security2.fdb</filename>. Sie müssen den Benutzernamen 
              und das Kennwort nicht angeben, wenn die Umgebungsvariablen <database>ISC_USER</database> 
              und <database>ISC_PASSWORD</database> festgelegt sind. Der Benutzer, der beim Erstellen 
              der Datenbank angegeben wird, wird ihr Eigentümer sein. Dies ist wichtig, wenn Sie Datenbank- 
              und Objektberechtigungen berücksichtigen.</para>
        </formalpara>
        <formalpara><title>Optional <database>PAGE_SIZE</database></title>
          <para>Klausel zum Festlegen der Seitengröße der Datenbank. Diese Größe wird für die primäre Datei 
              und alle sekundären Dateien der Datenbank festgelegt. Wenn Sie die Datenbankseitengröße unter 
              4.096 angeben, wird diese automatisch auf die Standardseitengröße 4.096 geändert. Andere Werte, 
              die nicht 4.096, 8.192 oder 16.384 entsprechen, werden in den nächst kleineren unterstützten 
              Wert geändert. Wenn die Größe der Datenbankseite nicht angegeben ist, wird der Standardwert auf 
              4.096 gesetzt.</para>
        </formalpara>
        <formalpara><title>Optional <database>LENGTH</database></title>
          <para>Klausel, die die maximale Größe der primären oder sekundären Datenbankdatei in Seiten angibt. 
              Wenn eine Datenbank erstellt wird, belegen ihre primären und sekundären Dateien die Mindestanzahl 
              an Seiten, die zum Speichern der Systemdaten erforderlich sind, unabhängig vom in der 
              <database>LENGTH</database>-Klausel angegebenen Wert. Der Wert der <database>LENGTH</database> 
              wirkt sich nicht auf die Größe der einzigen (oder zuletzt in einer Datei mit mehreren Dateien) 
              Datei aus. Die Datei wird bei Bedarf automatisch vergrößert.
          </para>
        </formalpara>
        <formalpara><title>Optional <database>SET NAMES</database></title>
          <para>Klausel, die den Zeichensatz der Verbindung angibt, die verfügbar ist, nachdem die Datenbank erfolgreich 
              erstellt wurde. Der Zeichensatz <database>NONE</database> wird standardmäßig verwendet. Beachten Sie, 
              dass der Zeichensatz in einem Apostroph-Paar eingeschlossen sein sollte (einfache Anführungszeichen).
          </para>
        </formalpara>
        <formalpara><title>Optional <database>DEFAULT CHARACTER SET</database></title>
          <para>Klausel, die den Standardzeichensatz zum Erstellen von Datenstrukturen von String-Datentypen angibt. 
              Zeichensätze werden auf Datentypen <database>CHAR</database>, <database>VARCHAR</database> und 
              <database>BLOB TEXT</database> angewendet. Der Zeichensatz <database>NONE</database> wird standardmäßig 
              verwendet. Es ist auch möglich, den Standardwert <database>COLLATION</database> für den Standardzeichensatz 
              festzulegen, wodurch diese Sortierfolge zum Standardwert für den Standardzeichensatz wird. Der Standardwert 
              wird für die gesamte Datenbank verwendet, es sei denn, ein alternativer Zeichensatz mit oder ohne eine 
              angegebene Collation wird explizit für ein Feld, eine Domain, eine Variable, einen Ausdruck usw. verwendet.
          </para>
        </formalpara>
        <formalpara><title><database>STARTING AT</database></title>
          <para>Klausel, die die Datenbankseitennummer angibt, bei der die nächste sekundäre Datenbankdatei gestartet werden 
              soll. Wenn die vorherige Datei vollständig mit Daten gemäß der angegebenen Seitennummer gefüllt ist, fügt 
              das System neue Daten zur nächsten Datenbankdatei hinzu.
          </para>
        </formalpara>
        <formalpara><title>Optional <database>DIFFERENCE FILE</database></title>
          <para>Klausel, die den Pfad und den Namen für das Datei-Delta angibt, das Änderungen in der Datenbankdatei 
              speichert, nachdem es durch die Anweisung <database>ALTER DATABASE BEGIN BACKUP</database> auf den 
              <quote>kopiersicheren</quote> Modus gestellt wurde. Eine detaillierte Beschreibung dieser Klausel finden 
              Sie unter <database>ALTER DATABASE</database>.
          </para>
        </formalpara>
        <formalpara><title><database>SET SQL DIALECT</database></title>
          <para>Datenbanken werden standardmäßig in Dialekt 3 erstellt. Damit die Datenbank in SQL-Dialekt 1 erstellt wird, 
              müssen Sie die Anweisung <database>SET SQL DIALECT 1</database> aus dem Skript oder der Clientanwendung, 
              z.B. <emphasis>isql</emphasis>, ausführen, noch vor der Anweisung <database>CREATE DATABASE</database>.</para>
        </formalpara>
      </section>

      <section id="fblangref25-ddl-db-createdbexamples-de">
        <title>Beispiele zur Verwendung von <database>CREATE DATABASE</database></title>
        <orderedlist>
          <listitem>Erstellen einer Datenbank in Windows auf der Festplatte D mit einer Seitengröße 
              von 8.192. Der Besitzer der Datenbank ist der Benutzer <emphasis>wizard</emphasis>. 
              Die Datenbank befindet sich in Dialekt 1 und verwendet als Standardzeichensatz 
              <database>WIN1251</database>.
            <programlisting>
SET SQL DIALECT 1;
CREATE DATABASE 'D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192 DEFAULT CHARACTER SET WIN1251;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Datenbank im Linux-Betriebssystem mit einer Seitengröße von 4.096. 
              Der Besitzer der Datenbank ist der Benutzer <emphasis>wizard</emphasis>. Die Datenbank 
              befindet sich in Dialekt 3 und verwendet <database>UTF8</database> als Standardzeichensatz, 
              wobei <database>UNICODE_CI_AI</database> als Standardsortierung verwendet wird.
            <programlisting>
CREATE DATABASE '/home/firebird/test.fdb'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8 COLLATION UNICODE_CI_AI;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Datenbank auf dem entfernten Server <quote>baseserver</quote> mit dem 
          angegebenen Alias <quote>test</quote>, der zuvor in der Datei <filename>aliases.conf</filename> 
          definiert wurde. Das TCP / IP-Protokoll wird verwendet. Der Besitzer der Datenbank wird der 
          Benutzer <emphasis>wizard</emphasis> sein. Die Datenbank befindet sich in Dialekt 3 und verwendet 
          <database>UTF8</database> als Standardzeichensatz.
            <programlisting>
CREATE DATABASE 'baseserver:test'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8;
            </programlisting>
          </listitem>
          <listitem>
              Erstellen einer Datenbank in Dialekt 3 mit <database>UTF8</database> als Standardzeichensatz. 
              Die primäre Datei enthält bis zu 10.000 Seiten mit einer Seitengröße von 8.192. Sobald die 
              primäre Datei die maximale Anzahl an Seiten erreicht hat, beginnt Firebird, Seiten der sekundären 
              Datei <filename>test.fdb2</filename> zuzuweisen. Wenn diese Datei ebenfalls maximal gefüllt ist, 
              wird <filename>test.fdb3</filename> zum Empfänger aller neuen Seitenzuweisungen. Als letzte Datei 
              hat Firebird kein Seitenlimit. Neue Zuweisungen werden so lange fortgesetzt, wie es das Dateisystem 
              zulässt, oder bis das Speichergerät keinen freien Speicher mehr hat. Wenn für diese letzte Datei ein 
              <database>LENGTH</database>-Parameter angegeben wurde, wird dieser ignoriert.
            <programlisting>
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
STARTING AT PAGE 10001
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Datenbank in Dialekt 3 mit <database>UTF8</database> als Standardzeichensatz. 
              Die primäre Datei enthält bis zu 10.000 Seiten mit einer Seitengröße von 8.192. In Bezug auf die 
          Dateigröße und die Verwendung von Sekundärdateien verhält sich diese Datenbank genau wie im vorherigen Beispiel.
            <programlisting>
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
LENGTH 10000 PAGES
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
            </programlisting>
          </listitem>
        </orderedlist>
        <formalpara><title>Siehe auch</title>
          <para><link linkend="fblangref25-ddl-db-alter-de"><database>ALTER DATABASE</database></link>,
          <link linkend="fblangref25-ddl-db-drop-de"><database>DROP DATABASE</database></link></para>
        </formalpara>
      </section>
    </section> <!-- CREATE DATABASE -->

    <section id="fblangref25-ddl-db-alter-de">
      <title><database>ALTER DATABASE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Ändern der Dateiorganisation einer Datenbank oder um diese in den 
        <quote>kopiersicheren</quote> Modus zu setzen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL&mdash;beide Funktionen. ESQL&mdash;nur Dateireorganisation</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER {DATABASE | SCHEMA}
[&lt;add_sec_clause&gt; [&lt;add_sec_clause&gt; ...]]
[ADD DIFFERENCE FILE 'diff_file' | DROP DIFFERENCE FILE]
[{BEGIN | END} BACKUP];

&lt;add_sec_clause&gt; ::= ADD &lt;sec_file&gt; [&lt;sec_file&gt; ...]

&lt;sec_file&gt; ::= FILE 'filepath'

ADD FILE &lt;sec_file&gt;

          [STARTING [AT [PAGE]] pagenum]
          [LENGTH [=] num [PAGE[S]]
        </programlisting></blockquote>
      </formalpara>
      <note>
        <para>Mehrere Dateien können mit einer ADD-Klausel hinzugefügt werden:
          <literallayout class="monospaced">
  ALTER DATABASE
    ADD FILE x LENGTH 8000
        FILE y LENGTH 8000
        FILE z
          </literallayout>
            Mehrere <database>ADD FILE</database>-Klauseln sind erlaubt; und eine 
            <database>ADD FILE</database>-Klausel, die mehrere Dateien hinzufügt (wie im obigen Beispiel), 
            kann mit anderen gemischt werden, die nur eine Datei hinzufügen. 
            Die Aussage wurde in der alten <citetitle>InterBase 6 Language Reference</citetitle>
            falsch dokumentiert.</para>
      </note>
      <?dbfo keep-together='auto'?>
      <table>
        <title>ALTER DATABASE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">add_sec_clause</entry>
              <entry align="left">Hinzufügen einer sekundären Datenbankdatei</entry>
            </row>
            <row valign="middle">
              <entry align="center">sec_file</entry>
              <entry align="left">Dateispezifikation für sekundäre Datei</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Vollständiger Pfad und Dateiname der Delta-Datei oder der sekundären Datenbankdatei</entry>
            </row>
            <row valign="middle">
              <entry align="center">pagenum</entry>
              <entry align="left">Seitennummer, von der aus die sekundäre Datenbankdatei gestartet werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">num</entry>
              <entry align="left">Maximale Größe der sekundären Datei in Seiten</entry>
            </row>
            <row valign="middle">
              <entry align="center">diff_file</entry>
              <entry align="left">Dateipfad und Name der .delta-Datei (Differenzdatei)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Das Statement <database>ALTER DATABASE</database> kann
        <itemizedlist spacing="compact">
          <listitem>sekundäre Dateien zu einer Datenbank hinzufügen</listitem>
          <listitem>eine Ein-Datei-Datenbank in und aus dem Modus <quote>kopiersicher</quote> 
            schalten (nur DSQL)</listitem>
          <listitem>festlegen und entfernen des Pfades und der Namen der Delta-Dateien
              für physikalische Backups (nur DSQL)
          </listitem>
        </itemizedlist>
      </para>
      
      <para>Nur <link linkend="fblangref25-security-administrators-de">Administratoren</link> 
      haben die Berechtigung das Statement <database>ALTER DATABASE</database> auszuführen.</para>

      <section id="fblangref25-ddl-db-alterdbopts-de">
        <title>Parameter für <database>ALTER DATABASE</database></title>
        <formalpara><title>Die <database>ADD FILE</database>-Klausel</title>
          <para>fügt eine sekundäre Datei zur Datenbank hinzu. Es ist erforderlich, den vollständigen 
              Pfad zur Datei und den Namen der sekundären Datei anzugeben. Die Beschreibung für die sekundäre 
              Datei ähnelt der für die Anweisung <database>CREATE DATABASE</database>.</para>
        </formalpara>

        <formalpara><title>Die <database>ADD DIFFERENCE FILE</database>-Klausel</title>
          <para>gibt den Pfad und den Namen der Delta-Datei an, die Änderungen in der Datenbank speichert, 
              wenn diese auf den Modus <quote>kopiersicher</quote> umgestellt wird. Diese Klausel fügt 
              tatsächlich keine Datei hinzu. Sie überschreibt nur den Standardnamen und den Standardpfad 
              der Delta-Datei. Um die vorhandenen Einstellungen zu ändern, sollten Sie die vorher angegebene 
              Beschreibung der .delta-Datei mit der <database>DROP DIFFERENCE FILE</database>-Klausel vor der 
              Angabe der neuen Beschreibung der Deltadatei löschen. </para> 
          <para>Wenn Pfad und Name der .delta-Datei nicht überschrieben werden, hat die Datei denselben Pfad 
              und denselben Namen wie die Datenbank, jedoch mit der Dateierweiterung <filename> .delta </filename>.
          </para>
          <caution>
            <para>Wenn nur ein Dateiname angegeben ist, wird die .delta-Datei im aktuellen Verzeichnis des Servers 
                erstellt. Unter Windows wird dies das Systemverzeichnis sein &mdash; ein sehr unkluger Speicherort für 
                flüchtige Benutzerdateien und entgegen den Windows-Dateisystemregeln.</para>
          </caution>
        </formalpara>

        <formalpara><title><database>DROP DIFFERENCE FILE</database></title>
          <para>Dies ist die Klausel, die die Beschreibung (Pfad und Name) der zuvor in der 
              <database>ADD DIFFERENCE FILE</database>-Klausel angegebenen Deltadatei löscht. Die Datei wird nicht gelöscht. 
              <database>DROP DIFFERENCE FILE</database> löscht den Pfad und den Namen der .delta-Datei aus dem 
              Datenbank-Header. Beim nächsten Umschalten der Datenbank auf den <quote>kopiersicheren</quote> Modus werden 
              die Standardwerte verwendet (d.h. derselbe Pfad und Name wie die Datenbank, jedoch mit der Erweiterung .delta).
          </para>
        </formalpara>

        <formalpara><title><database>BEGIN BACKUP</database></title>
          <para>Dies ist die Klausel, die die Datenbank in den <quote>kopiersicheren</quote> Modus 
          umschaltet. <database>ALTER DATABASE</database> friert mit dieser Klausel die 
          Hauptdatenbankdatei ein und ermöglicht die sichere Sicherung mithilfe von Dateisystemtools, 
          selbst wenn Benutzer verbunden sind und Operationen mit Daten ausführen. Bis der Sicherungsstatus 
          der Datenbank auf <database>NORMAL</database> zurückgesetzt wird, werden alle an der Datenbank 
          vorgenommenen Änderungen in die .delta (Differenz)-Datei geschrieben.</para>
          <important>
            <para>Trotz seiner Syntax startet eine Anweisung mit der Klausel <database>BEGIN BACKUP</database> 
            keinen Sicherungsprozess, sondern erstellt lediglich die Bedingungen für die Ausführung einer Aufgabe, 
            für die die Datenbankdatei nur vorübergehend schreibgeschützt sein muss.</para>
          </important>
        </formalpara>

        <formalpara><title><database>END BACKUP</database></title>
          <para>ist die Klausel, mit der die Datenbank vom <quote>kopiersicheren</quote> Modus in den normalen 
          Modus umgeschaltet wird. Eine Anweisung mit dieser Klausel fügt die .delta-Datei mit der 
          Hauptdatenbankdatei zusammen und stellt den normalen Betrieb der Datenbank wieder her. 
          Sobald der <database>END BACKUP</database>-Prozess gestartet wird, sind die Bedingungen für das 
          Erstellen sicherer Backups mit Dateisystemtools nicht mehr vorhanden.</para>
        </formalpara>
        <warning>
          <para>Die Verwendung von <database>BEGIN BACKUP</database> und <database>END BACKUP</database> und 
          das Kopieren der Datenbankdateien mit den Dateisystemtools ist <command>nicht sicher</command> mit 
          Mehrdateiendatenbanken! Verwenden Sie diese Methode nur für Datenbanken mit einer einzigen Datei.</para> 
          <para>Ein sicheres Backup mit dem Dienstprogramm <emphasis>gbak</emphasis> ist jederzeit möglich, wenn auch 
          nicht empfohlen, solange sich die Datenbank im Zustand LOCKED oder MERGE befindet.</para>
        </warning>
      </section>

      <bridgehead renderas="sect4">Beispiele zur Verwendung von <database>ALTER DATABASE</database></bridgehead>
      <orderedlist>
        <listitem>Hinzufügen einer sekundären Datei zur Datenbank. Sobald in der vorherigen primären oder sekundären Datei 
            30000 Seiten gefüllt sind, fügt die Firebird-Engine Daten zur sekundären Datei 
            <filename> test4.fdb </filename> hinzu.
          <programlisting>
ALTER DATABASE
ADD FILE 'D:\test4.fdb'
STARTING AT PAGE 30001;
          </programlisting>
        </listitem>
        <listitem>Pfad und Name der Delta-Datei angeben:
          <programlisting>
ALTER DATABASE
ADD DIFFERENCE FILE 'D:\test.diff';
          </programlisting>
        </listitem>
        <listitem>Beschreibung der Delta-Datei löschen:
          <programlisting>
ALTER DATABASE
DROP DIFFERENCE FILE;
          </programlisting>
        </listitem>
        <listitem>Wechseln der Datenbank in den <quote>kopiersicheren</quote> Modus:
          <programlisting>
ALTER DATABASE
BEGIN BACKUP;
          </programlisting>
        </listitem>
        <listitem>Umschalten der Datenbank vom <quote>kopiersicheren</quote> Modus in 
        den normalen Betriebsmodus:
          <programlisting>
ALTER DATABASE
END BACKUP;
          </programlisting>
        </listitem>
      </orderedlist>

      <formalpara><title>Siehe auch</title>
        <para><link linkend="fblangref25-ddl-db-create-de"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-ddl-db-drop-de"><database>DROP DATABASE</database></link></para>
      </formalpara>
    </section><!-- alter database -->

    <section id="fblangref25-ddl-db-drop-de">
      <title><database>DROP DATABASE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Löschen der Datenbank, mit der Sie gerade verbunden sind</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP DATABASE
        </programlisting></blockquote>
      </formalpara>
      <para>Die Anweisung <database>DROP DATABASE</database> löscht die aktuelle Datenbank. 
      Bevor Sie eine Datenbank löschen, müssen Sie eine Verbindung herstellen. Die Anweisung löscht 
      die primäre Datei, alle sekundären Dateien und alle <link linkend="fblangref25-ddl-shadow-de">Schattendateien</link>.
      </para>

      <para>Nur <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      haben die notwendigen Rechte zum Ausführen der Anweisung <database>DROP DATABASE</database>.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>Löschen der Datenbank, mit der der Client verbunden ist.
          <blockquote><programlisting>
DROP DATABASE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-db-create-de"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-ddl-db-alter-de"><database>ALTER DATABASE</database></link>
        </para>
      </formalpara>
    </section><!-- drop database -->
  </section><!-- database -->

  <section id="fblangref25-ddl-shadow-de">
    <title>SHADOW</title>
    <para>
        Ein <emphasis>shadow</emphasis> ist eine exakte Seite-für-Seite-Kopie einer Datenbank. Sobald 
        ein Shadow erstellt wurde, spiegeln sich alle Änderungen in der Datenbank sofort im Shadow wider. 
        Wenn die primäre Datenbankdatei aus irgendeinem Grund nicht verfügbar ist, wechselt das DBMS auf den 
        Shadow.</para> 
    <para> In diesem Abschnitt wird beschrieben, wie Sie Schattendateien erstellen und löschen.</para>

    <section id="fblangref25-ddl-createshadow-de">
      <title><database>CREATE SHADOW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen eines Shadows für die aktuelle Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE SHADOW sh_num [AUTO | MANUAL] [CONDITIONAL]
'filepath' [LENGTH [=] num [PAGE[S]]]
[&lt;secondary_file&gt; ...];

&lt;secondary_file&gt; ::=
  FILE 'filepath'
  [STARTING [AT [PAGE]] pagenum]
  [LENGTH [=] num [PAGE[S]]]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-createshadow-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE SHADOW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sh_num</entry>
              <entry align="left">Schattennummer &mdash; eine positive Zahl, die den Schattensatz identifiziert</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Der Name der Schattendatei und der Pfad dazu in Übereinstimmung 
                  mit den Regeln des Betriebssystems</entry>
            </row>
            <row valign="middle">
              <entry align="center">num</entry>
              <entry align="left">Maximale Schattengröße in Seiten</entry>
            </row>
            <row valign="middle">
              <entry align="center">secondary_file</entry>
              <entry align="left">Sekundäre Dateispezifikation</entry>
            </row>
            <row valign="middle">
              <entry align="center">page_num</entry>
              <entry align="left">Die Nummer der Seite, auf der die sekundäre 
                  Schattendatei gestartet werden soll</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die Anweisung <database>CREATE SHADOW</database> erstellt einen neuen 
      Shadow. Der Schatten beginnt mit dem Duplizieren der Datenbank in dem Moment, 
      in dem sie erstellt wird. Es ist für einen Benutzer nicht möglich, eine 
      Verbindung zu einem Schatten herzustellen.</para>

      <para>Wie bei einer Datenbank kann ein Shadow eine Mehrfachdatei sein. Die 
          Anzahl und Größe der Dateien eines Schattens hängt nicht mit der Anzahl 
          und Größe der Dateien der Datenbank, die es beschattet, zusammen.</para>

      <para>Die Seitengröße für Schattendateien wird auf die Größe der Datenbankseite 
          festgelegt und kann nicht geändert werden.</para>

      <para>Wenn ein Unglück mit der ursprünglichen Datenbank auftritt, konvertiert das 
          System den Schatten in eine Kopie der Datenbank und wechselt zu dieser. 
          Der Schatten ist dann <emphasis>nicht verfügbar</emphasis>. Was als nächstes 
          passiert, hängt von der Option <database>MODE</database> ab.</para>

      <section id="fblangref25-ddl-createshadowmode-de">
        <title><database>AUTO | MANUAL</database> Modes</title>
        <para>Wenn ein Schatten in eine Datenbank konvertiert wird, ist er nicht mehr verfügbar. 
            Ein Schatten kann auch unverfügbar werden, weil jemand versehentlich 
            seine Datei löscht oder der Speicherplatz, auf dem die Schatten-Dateien 
            gespeichert sind, erschöpft ist oder selbst beschädigt ist.
          <itemizedlist>
            <listitem>
              <para>Wenn der AUTO-Modus ausgewählt ist (Standardwert), wird die Spiegelung automatisch beendet, 
                  alle Referenzen werden aus dem Datenbank-Header gelöscht, und die 
                  Datenbank arbeitet normal weiter.</para>
              <para>Wenn die Option <database>CONDITIONAL</database> festgelegt wurde, 
                  versucht das System, einen neuen Schatten zu erstellen, um den verlorenen 
                  zu ersetzen. Es ist jedoch nicht immer erfolgreich und ein neuer muss 
                  möglicherweise manuell erstellt werden.</para>
            </listitem>
            <listitem>
              <para>Ist das MANUAL-Modus-Attribut gesetzt, wenn der Schatten nicht mehr verfügbar ist, 
                  werden alle Versuche, eine Verbindung zur Datenbank herzustellen und diese abzufragen, 
                  Fehlermeldungen erzeugen. Die Datenbank bleibt so lange unzugänglich, bis entweder der 
                  Schatten wieder verfügbar ist oder der Datenbankadministrator sie mithilfe der Anweisung 
                  <database>DROP SHADOW</database> löscht. MANUAL sollte ausgewählt werden, wenn 
                  kontinuierliches Shadowing wichtiger ist als der unterbrechungsfreie Betrieb der Datenbank.
              </para>
             </listitem>
           </itemizedlist>
        </para>
      </section>
      <section id="fblangref25-ddl-createshadowopts-de">
        <title>Optionen für <database>CREATE SHADOW</database></title>
        <formalpara><title>Optional LENGTH</title>
          <para> Klausel, die die maximale Größe der primären oder sekundären Schattendatei 
              in Seiten angibt. Der Wert <database>LENGTH</database> wirkt sich nicht 
              auf die Größe der einzigen Schattendatei aus, noch auf die letzte, wenn 
              es sich um eine Gruppe handelt. Die letzte (oder einzige) Datei wird 
              automatisch so lange vergrößert, wie es nötig ist.</para>
        </formalpara>

        <formalpara><title>STARTING AT</title>
          <para>Klausel, die die Schattenseitennummer angibt, bei der die nächste 
              Schattendatei gestartet werden soll. Das System fügt neue Daten zur 
              nächsten Schattendatei hinzu, wenn die vorherige Datei bis zur angegebenen 
              Seitenzahl mit Daten gefüllt ist.</para>
        </formalpara>
      </section>
      <para>Nur <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      haben die notwendigen Rechte die Anweisung <database>CREATE SHADOW</database> auszuführen.</para>
      <tip>
        <para>Sie können die Größen, Namen und den Speicherort der Schattendateien überprüfen, 
            indem Sie mit <emphasis>isql</emphasis> eine Verbindung zur Datenbank 
            herstellen und den Befehl <database>SHOW DATABASE;</database></para>
      </tip>

      <formalpara><title>Beispiele für die Verwendung von <database>CREATE SHADOW</database></title>
        <orderedlist>
          <listitem>Erstellen eines Schattens für die aktuelle Datenbank als <quote>shadow number 1</quote>:
            <programlisting>
CREATE SHADOW 1 'g:\data\test.shd';
            </programlisting>
          </listitem>
          <listitem>Erstellen eines Mehrdatei-Schattens für die aktuelle Datenbank als
          <quote>shadow number 2</quote>:
            <programlisting>
CREATE SHADOW 2 'g:\data\test.sh1'
LENGTH 8000 PAGES
FILE 'g:\data\test.sh2';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para><link linkend="fblangref25-ddl-db-create-de"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-ddl-dropshadow-de"><database>DROP SHADOW</database></link>
        </para>
      </formalpara>
    </section><!-- create shadow -->

    <section id="fblangref25-ddl-dropshadow-de">
      <title><database>DROP SHADOW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Deleting a shadow from the current database</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP SHADOW sh_num
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropshadow-de">
      <?dbfo keep-together='auto'?>
        <title>DROP SHADOW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sh_num</entry>
              <entry align="left">Schattennummer &mdash; eine positive Zahl, die 
                  den Schattensatz identifiziert</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP SHADOW</database> löscht den angegebenen Schatten 
      für die Datenbank, mit der eine Verbindung besteht. Wenn ein Schatten gelöscht wird, 
      werden alle zugehörigen Dateien gelöscht und Schatten auf die angegebene 
      <replaceable> sh_num </replaceable> werden beendet.</para>

      <para>Nur <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      haben die notwendigen Rechte die Anweisung <database>DROP SHADOW</database> auszuführen.</para>

      <formalpara><title>Beispiel zum Löschen eines Schattens</title>
        <para> Löschen von <quote>shadow Nummer 1</quote>.
          <blockquote><programlisting>
DROP SHADOW 1;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-createshadow-de"><database>CREATE SHADOW</database></link></para>
      </formalpara>
    </section><!-- drop shadow -->
  </section> <!-- shadow -->

  <section id="fblangref25-ddl-domn-de">
    <title><database>DOMAIN</database></title>
    <para><command>Domain</command> ist eine Objektart innerhalb einer relationalen Datenbank.
    Eine Domain wird als ein bestimmter Datentyp mit einigen Attributen erstellt. Sobald es in 
    der Datenbank definiert wurde, kann es wiederholt verwendet werden, um Tabellenspalten, 
    PSQL-Argumente und lokale PSQL-Variablen zu definieren. Diese Objekte erben alle Attribute 
    der Domain Einige Attribute können bei Bedarf überschrieben werden, wenn das neue 
    Objekt definiert ist.</para>
    <para>In diesem Abschnitt wird die Syntax von Anweisungen beschrieben, mit denen Domains erstellt, 
    geändert und gelöscht werden. Eine detaillierte Beschreibung von Domains und deren Verwendung 
    finden Sie in <link linkend="fblangref25-datatypes-custom-de">Benutzerdefinierte Datentypen &mdash; Domains</link>.
    </para>

    <section id="fblangref25-ddl-domn-create-de">
      <title><database>CREATE DOMAIN</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen Domain</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE DOMAIN name [AS] &lt;datatype&gt;
[DEFAULT {literal | NULL | &lt;context_var&gt;}]
[NOT NULL] [CHECK (&lt;dom_condition&gt;)]
[COLLATE collation_name];

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT} [&lt;array_dim&gt;]
  | {FLOAT | DOUBLE PRECISION} [&lt;array_dim&gt;]
  | {DATE | TIME | TIMESTAMP} [&lt;array_dim&gt;]
  | {DECIMAL | NUMERIC} [(precision [, scale])] [&lt;array_dim&gt;]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [&lt;array_dim&gt;] [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)] [&lt;array_dim&gt;]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;array_dim&gt; ::= <command>[</command>[m:]n [,[m:]n ...]<command>]</command>

&lt;dom_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM &lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;dom_condition&gt;)
  | NOT &lt;dom_condition&gt;
  | &lt;dom_condition&gt; OR &lt;dom_condition&gt;
  | &lt;dom_condition&gt; AND &lt;dom_condition&gt;

&lt;operator&gt; ::= 
  &lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    VALUE
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-createdomn-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE DOMAIN Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">name</entry>
              <entry align="left">Domainname aus maximal 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Ein literaler Wert, der kompatibel zu <replaceable>datatype</replaceable> ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Jede Kontextvariable, deren Typ kompatibel ist mit <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">dom_condition</entry>
              <entry align="left">Domain-Bedingung</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation_name</entry>
              <entry align="left">Name einer Collation, die für <replaceable> charset_name </replaceable> gültig ist,
                sofern dieser mit <replaceable>datatype</replaceable> übergeben wird, oder andernfalls für 
                den Standardzeichensatz der Datenbank</entry>
            </row>
            <row valign="middle">
              <entry align="center">array_dim</entry>
              <entry align="left">Array-Dimensionen</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left"><database>INTEGER</database>-Ganzzahlen, die den Indexbereich
                der Array-Dimensionen angeben</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Die Gesamtzahl der signifikanten Ziffern, die ein Wert von 
                  <replaceable> datatype </replaceable> aufnehmen kann (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Die Anzahl der Stellen nach dem Dezimalpunkt
              (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Anzahl einer Zeichenkette in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">Der Name eines gültigen Zeichensatzes, falls sich der Zeichensatz 
                  der Domain vom Standardzeichensatz der Datenbank unterscheidet</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB Subtype-Nummer</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB-Subtyp-Mnemonikname</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">Eine skalare SELECT-Anweisung &mdash; Auswählen einer Spalte 
                  und Zurückgeben nur eines row</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine Spalte auswählt und null 
                  oder mehr Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine Spalte oder mehrere Spalten
                  auswählt und null oder mehr Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Ein Ausdruck, der auf einen Wert auflöst, 
                  der mit <replaceable>datatype</replaceable> kompatibel ist
              </entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequenzname (Generatorname)</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Interne Funktion oder UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE DOMAIN</database> erstellt eine neue Domain.</para>
      <para>Jeder SQL-Datentyp kann als Domainntyp angegeben werden.</para>
      <section id="fblangref25-ddl-domn-typespec-de">
        <title>Typenspezifische Details</title>
        <formalpara>
          <title>ARRAY Typen</title>
          <itemizedlist spacing="compact">
            <listitem>Wenn die Domain ein Array sein soll, kann der Basistyp ein SQL-Datentyp mit Ausnahme 
                von <database>BLOB</database> und <database>ARRAY</database> sein.
            </listitem>
            <listitem>Die Dimensionen des Arrays werden in eckigen Klammern angegeben. 
                (Im Syntaxblock werden diese Klammern fett dargestellt, um sie von den 
                eckigen Klammern zu unterscheiden, die optionale Syntaxelemente kennzeichnen.)
            </listitem>
            <listitem>Für jede Array-Dimension definieren eine oder zwei ganze Zahlen die 
                untere und obere Grenze ihres Indexbereichs:
              <itemizedlist spacing="compact">
                <listitem>Standardmäßig sind Arrays 1-basiert. Die untere Grenze ist implizit und 
                    nur die obere Grenze muss angegeben werden. Eine einzelne Zahl kleiner als 1 
                    definiert den Bereich <replaceable> num </replaceable>..1 und eine Zahl 
                    größer als 1 definiert den Bereich 1..<replaceable> num </replaceable>.
                </listitem>
                <listitem>Zwei durch einen Doppelpunkt getrennte Zahlen (':') und optional ein Leerraum, 
                    der zweite ist größer als der erste, können verwendet werden, um den Bereich 
                    explizit zu definieren. Eine oder beide Grenzen können kleiner als Null sein, 
                    solange die obere Grenze größer als die untere ist.</listitem>
              </itemizedlist>
            </listitem>
            <listitem>Wenn das Array mehrere Dimensionen hat, müssen die Bereichsdefinitionen für jede 
                Dimension durch Kommas und ein optionales Leerzeichen getrennt werden.
            </listitem>
            <listitem>Indizes werden <emphasis>nur</emphasis> validiert, wenn ein Array tatsächlich 
            existiert. Dies bedeutet, dass keine Fehlermeldungen bezüglich ungültiger Subskripte 
            zurückgegeben werden, wenn ein bestimmtes Element nichts zurückgibt oder wenn ein Array-Feld 
            <constant>NULL</constant> ist.</listitem>
          </itemizedlist>
        </formalpara>

        <formalpara><title>CHARACTER Typen</title>
          <para>Sie können die <database>CHARACTER SET</database>-Klausel nutzen, um den
          Zeichensatz für die Datentypen <database>CHAR, VARCHAR</database> und <database>BLOB</database>
          (<database>SUB_TYPE TEXT</database>) zu definieren. Wird der Zeichensatz nicht angegeben,
          wird der in der Datenbank als <database>DEFAULT CHARACTER SET</database> Zeichensatz
          verwendet. Ist auch dieser nicht festgelegt, wird der Zeichensatz
          <database>NONE</database> als Standard für die Anlage von Domains verwendet.
            <warning>
              <para>Bei Zeichensatz <database>NONE</database> werden Zeichendaten gespeichert und 
              abgerufen, wie sie übermittelt wurden. Daten in einer beliebigen Codierung können 
              zu einer Spalte auf der Grundlage einer solchen Domain hinzugefügt werden. Es ist 
              jedoch nicht möglich, diese Daten zu einer Spalte mit einer anderen Codierung hinzuzufügen. 
              Da zwischen Quell- und Zielcodierung keine Transkription durchgeführt wird, können Fehler 
              auftreten.</para>
            </warning>
          </para>
        </formalpara>
        <formalpara><title><database>DEFAULT</database>-Klausel</title>
          <para> Mit der optionalen <database>DEFAULT</database>-Klausel können Sie einen 
          Standardwert für die Domain angeben. Dieser Wert wird der Tabellenspalte hinzugefügt, 
          die diese Domain erbt, wenn die Anweisung <database>INSERT</database> ausgeführt 
          wird, wenn in der DML-Anweisung kein Wert dafür angegeben ist.</para>
          <para> Lokale Variablen und Argumente in PSQL-Modulen, die auf diese Domain verweisen, 
              werden mit dem Standardwert initialisiert. Verwenden Sie als Standardwert ein Literal 
              eines kompatiblen Typs oder eine Kontextvariable eines kompatiblen Typs.</para>
        </formalpara>
        <formalpara><title>NOT NULL-Constraint</title>
          <para>Spalten und Variablen basierend auf einer Domain mit der NOT NULL-Beschränkung werden 
              daran gehindert, als NULL geschrieben zu werden, d.h. ein Wert ist 
              <emphasis>erforderlich</emphasis>.</para>
        </formalpara>
        <caution>
          <para>Achten Sie beim Anlegen einer Domain darauf, keine Einschränkungen zu spezifizieren, die einander 
              widersprechen würden. Zum Beispiel sind NOT NULL und DEFAULT NULL widersprüchlich.</para>
        </caution>
        <formalpara><title><database>CHECK-Constraint(s)</database></title>
          <para>Die optionale Klausel <database>CHECK</database> gibt Einschränkungen für die Domain an. 
              Eine Domainnbeschränkung gibt Bedingungen an, die von den Werten von Tabellenspalten oder 
              Variablen erfüllt werden müssen, die von der Domain erben. Eine Bedingung muss in Klammern 
              eingeschlossen werden.</para>
          <para>Eine Bedingung ist ein logischer Ausdruck (auch Prädikat genannt), der die booleschen 
              Ergebnisse <database>TRUE, FALSE</database> und <database>UNKNOWN</database> zurückgeben kann. 
              Eine Bedingung gilt als erfüllt, wenn das Prädikat den Wert <database>TRUE</database> 
              oder <quote>UNKNOWN</quote> (entspricht <database>NULL</database>) zurückgibt. 
              Wenn das Prädikat <database>FALSE</database> zurückgibt, ist die Bedingung für die 
              Annahme nicht erfüllt.</para>
        </formalpara>
        <formalpara><title>VALUE-Schlüsselwort</title>
          <para>Das Schlüsselwort <database>VALUE</database> in einer Domainbeschränkung ersetzt die 
          Tabellenspalte, die auf dieser Domain oder einer Variablen in einem PSQL-Modul basiert. Es 
          enthält den Wert, der der Variablen oder der Tabellenspalte zugewiesen ist. <database>VALUE</database> 
          kann überall in der CHECK-Bedingung verwendet werden, obwohl es normalerweise im linken Teil der Bedingung 
          verwendet wird.</para>
        </formalpara>
        <formalpara><title>COLLATE</title>
          <para>Mit der optionalen COLLATE-Klausel können Sie die Sortierreihenfolge (Collation) angeben, wenn die 
              Domain auf einem der String-Datentypen basiert, einschließlich <database>BLOB</database>s mit 
              Textsubtypen. Wenn keine Sortierreihenfolge angegeben ist, ist die Sortierreihenfolge 
              diejenige, die für den angegebenen Zeichensatz zum Zeitpunkt der Erstellung der Domain 
              voreingestellt ist.</para>
        </formalpara>
      </section>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Domain erstellen.</para>

      <section id="fblangref25-ddl-createdomnexmpls-de">
        <title>Beispiele für <database>CREATE DOMAIN</database></title>
        <orderedlist>
          <listitem>Erstellen einer Domain mit Werten von mehr als 1.000 und einem Standardwert 
              von 10.000.
            <programlisting>
CREATE DOMAIN CUSTNO AS
INTEGER DEFAULT 10000
CHECK (VALUE > 1000);
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Domain, die die Werte "Ja" und "Nein" in dem Standardzeichensatz annehmen kann, 
              der während der Erstellung der Datenbank angegeben wurde.
            <programlisting>
CREATE DOMAIN D_BOOLEAN AS
CHAR(3) CHECK (VALUE IN ('Yes', 'No'));
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Domain mit dem Zeichensatz <database>UTF8</database> und
          der Sortierreihenfolge (Collation) <database>UNICODE_CI_AI</database>.
            <programlisting>
CREATE DOMAIN FIRSTNAME AS
VARCHAR(30) CHARACTER SET UTF8
COLLATE UNICODE_CI_AI;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Domain vom Typ <database>DATE</database>, die NULL nicht 
          akzeptiert und das aktuelle Datum als Standardwert verwendet.
            <programlisting>
CREATE DOMAIN D_DATE AS
DATE DEFAULT CURRENT_DATE
NOT NULL;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Domain, die als ein Array aus zwei Elementen des Typs NUMERIC(18, 3) 
              definiert ist. Der Start-Array-Index ist 1.
            <programlisting>
CREATE DOMAIN D_POINT AS
NUMERIC(18, 3) [2];
            </programlisting>
            <note>
              <para>Über einen Array-Typ definierte Domainn dürfen nur zum Definieren von Tabellenspalten 
                  verwendet werden. Sie können keine Array-Domainn verwenden, um lokale Variablen in 
                  PSQL-Modulen zu definieren.</para>
            </note>
          </listitem>
          <listitem>Erstellen einer Domain, deren Elemente nur in der Tabelle COUNTRY definierte Ländercodes 
              sein können.
            <programlisting>
CREATE DOMAIN D_COUNTRYCODE AS CHAR(3)
CHECK (EXISTS(SELECT * FROM COUNTRY
       WHERE COUNTRYCODE = VALUE));
            </programlisting>
            <note>
              <para>Das Beispiel zeigt nur die Möglichkeit, Prädikate mit Abfragen in der Domainntestbedingung 
                  zu verwenden. Es wird nicht empfohlen, diesen Stil der Domain in der Praxis zu verwenden 
                  es sei denn, die Nachschlagetabelle enthält Daten, die niemals gelöscht werden.</para>
            </note>
          </listitem>
        </orderedlist>
      </section><!-- examples -->
      <formalpara><title>Siehe auch</title>
        <para><link linkend="fblangref25-ddl-domn-alter-de"><database>ALTER DOMAIN</database></link>,
        <link linkend="fblangref25-ddl-domn-drop-de"><database>DROP DOMAIN</database></link></para>
      </formalpara>
    </section><!-- create domain -->

    <section id="fblangref25-ddl-domn-alter-de">
      <title><database>ALTER DOMAIN</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Die aktuellen Attribute einer Domain ändern oder umbenennen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER DOMAIN <replaceable>domain_name</replaceable>
  [TO &lt;new_name&gt;]
  [TYPE &lt;datatype&gt;]
  [SET DEFAULT {literal | NULL | &lt;context_var&gt;} | DROP DEFAULT]
  [ADD [CONSTRAINT] CHECK (&lt;dom_condition&gt;) | DROP CONSTRAINT]

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;dom_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM &lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;dom_condition&gt;)
  | NOT &lt;dom_condition&gt;
  | &lt;dom_condition&gt; OR &lt;dom_condition&gt;
  | &lt;dom_condition&gt; AND &lt;dom_condition&gt;

&lt;operator&gt; ::= 
  &lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    VALUE
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-alterdomn-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER DOMAIN Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">new_name</entry>
              <entry align="left">Neuer Domainname, bestehend aus maximal 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Ein literaler Wert, der kompatibel zu <replaceable>datatype</replaceable> ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Jede Kontextvariable, deren Typ kompatibel ist mit <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Die Gesamtzahl der signifikanten Ziffern, die ein Wert des <replaceable> Datentyps </replaceable> 
              aufnehmen kann (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Die Anzahl der Stellen nach dem Dezimalkomma
              (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe einer Zeichenkette in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">Der Name eines gültigen Zeichensatzes, falls sich der Zeichensatz 
                der Domain vom Standardzeichensatz der Datenbank unterscheidet</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB Subtype-Nummer</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB-Subtyp-Mnemonikname</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">Eine skalare SELECT-Anweisung &mdash; Auswählen einer Spalte 
                      und Zurückgeben nur eines row</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine Spalte auswählt und null 
                      oder mehr Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine Spalte oder mehrere Spalten
                      auswählt und null oder mehr Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Ein Ausdruck, der auf einen Wert auflöst, 
                      der mit <replaceable>datatype</replaceable> kompatibel ist
              </entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequenzname (Generatorname)</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Interne Funktion oder UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>ALTER DOMAIN</database> ermöglicht Änderungen an den 
      aktuellen Attributen einer Domain einschließlich ihres Namens. Sie können beliebig viele Domainnänderungen 
      in einer <database>ALTER DOMAIN</database>-Anweisung vornehmen.</para>
      <formalpara><title>TO &lt;name&gt;</title>
        <para> Verwenden Sie die TO-Klausel, um die Domain umzubenennen, solange keine Abhängigkeiten von der Domain 
            vorhanden sind, z. B. Tabellenspalten, lokale Variablen oder Prozedurargumente, die darauf verweisen.</para>
      </formalpara>
      <formalpara><title>SET DEFAULT</title>
        <para>Mit der SET DEFAULT-Klausel können Sie einen neuen Standardwert setzen. Wenn die Domain 
            bereits einen Standardwert hat, muss sie nicht zuerst gelöscht werden, sondern wird durch 
            die neue ersetzt.</para>
      </formalpara>
      <formalpara><title>DROP DEFAULT</title>
        <para>Mit dieser Klausel löschen Sie einen zuvor festgelegten Standardwert und ersetzen ihn durch 
            <database>NULL</database>.</para>
      </formalpara>
      <formalpara><title>ADD CONSTRAINT CHECK</title>
        <para>Verwenden Sie die Klausel <database>ADD CONSTRAINT CHECK</database>, um einen
        <database>CHECK</database>-Constraint zur Domain hinzuzufügen. Existiert bereits ein 
        <database>CHECK</database>-Constraint für die Domain, muss dieser zunächst gelöscht werden.
        Nutzen Sie dazu ein <database>ALTER DOMAIN</database>-Statement, das eine 
        <database>DROP CONSTRAINT</database>-Klausel beinhaltet.</para>
      </formalpara>
      <formalpara><title>TYPE</title>
        <para>Die <database>TYPE</database>-Klausel wird verwendet, um den Datentyp der Domain 
        in eine andere, kompatible zu ändern. Das System verbietet jede Änderung des Typs, der zu 
        Datenverlust führen könnte. Ein Beispiel wäre, wenn die Anzahl der Zeichen im neuen Typ 
        kleiner als im vorhandenen Typ wäre.</para>
      </formalpara>
      <important>
         <para>Wenn Sie die Attribute einer Domain ändern, kann der vorhandene PSQL-Code ungültig 
             werden. Für Informationen zur Erkennung lesen Sie bitte den Artikel 
             <link linkend="fblangref25-appx01-supp-rdb_validblr-de"> 
                 <citetitle>Das RDB$VALID_BLR Feld</citetitle> 
            </link> in Anhang A.</para>
       </important>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Domain ändern, 
          sofern sie nicht durch Abhängigkeiten von Objekten verhindert wird, für die dieser Benutzer nicht 
          über ausreichende Berechtigungen verfügt.</para>

      <section id="fblangref25-ddl-domn-cannotalter-de">
        <title>Was die Ausführung von <database>ALTER DOMAIN</database> verhindert</title>
        <itemizedlist spacing="compact">
          <listitem>Wenn die Domain als ein Array deklariert wurde, ist es nicht möglich, ihren Typ oder 
              ihre Dimensionen zu ändern. Es kann auch kein anderer Typ in einen 
              <database>ARRAY</database>-Typ geändert werden.
          </listitem>
          <listitem>In Firebird 2.5 und niedriger darf die Einschränkung <database>NOT NULL</database> 
          weder für eine Domain aktiviert noch deaktiviert werden.</listitem>
          <listitem>Es gibt keine Möglichkeit, die Standardkollation zu ändern, ohne die Domain zu löschen 
              und sie mit den gewünschten Attributen neu zu erstellen.</listitem>
        </itemizedlist>
      </section>

      <section id="fblangref25-ddl-domn-alterdomnexmpls-de">
        <title>Beispiele für <database>ALTER DOMAIN</database></title>
        <orderedlist>
          <listitem>Ändern des Datentyps in <database>INTEGER</database> und festlegen 
            oder ändern des Standardwerts auf 2.000:
            <programlisting>
ALTER DOMAIN CUSTNO
  TYPE INTEGER
  SET DEFAULT 2000;
            </programlisting>
          </listitem>
          <listitem>Umbenennen einer Domain.
            <programlisting>
ALTER DOMAIN D_BOOLEAN TO D_BOOL;
            </programlisting>
          </listitem>
          <listitem>Löschen des Standardwerts und Hinzufügen einer Einschränkung für die Domain:
            <programlisting>
ALTER DOMAIN D_DATE
  DROP DEFAULT
  ADD CONSTRAINT CHECK (VALUE >= date '01.01.2000');
            </programlisting>
          </listitem>
          <listitem>Ändern des <database>CHECK</database>-Constraints:
            <programlisting>
ALTER DOMAIN D_DATE
  DROP CONSTRAINT;

ALTER DOMAIN D_DATE
  ADD CONSTRAINT CHECK
    (VALUE BETWEEN date '01.01.1900' AND date '31.12.2100');
            </programlisting>
          </listitem>
          <listitem>Ändern des Datentyps, um die zulässige Anzahl von Zeichen zu erhöhen:
            <programlisting>
ALTER DOMAIN FIRSTNAME
  TYPE VARCHAR(50) CHARACTER SET UTF8;
            </programlisting>
          </listitem>
        </orderedlist>
      </section>
      <formalpara><title>Siehe auch</title>
        <para><link linkend="fblangref25-ddl-domn-create-de"><database>CREATE DOMAIN</database></link>,
        <link linkend="fblangref25-ddl-domn-drop-de"><database>DROP DOMAIN</database></link></para>
      </formalpara>
    </section><!-- Alter domain -->

    <section id="fblangref25-ddl-domn-drop-de">
      <title><database>DROP DOMAIN</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Eine bestehende Domain löschen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP DOMAIN <replaceable>domain_name</replaceable>
        </programlisting></blockquote>
      </formalpara>
      <para>Die Anweisung <database>DROP DOMAIN</database> löscht eine Domain, die in der 
      Datenbank vorhanden ist. Es ist nicht möglich, eine Domain zu löschen, wenn sie von 
      Spalten der Datenbanktabellen referenziert oder in einem PSQL-Modul verwendet wird. Um 
      eine Domain zu löschen, die verwendet wird, müssen alle Spalten in allen Tabellen, die 
      auf die Domain verweisen, gelöscht werden und alle Verweise auf die Domain müssen aus 
      PSQL-Modulen entfernt werden.</para>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Domain löschen.</para>

      <bridgehead renderas="sect4">Beispiele</bridgehead>
        <para>Löschen der COUNTRYNAME-Domain:
          <blockquote><programlisting>
DROP DOMAIN COUNTRYNAME;
          </programlisting></blockquote>
        </para>

      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-domn-create-de"><database>CREATE DOMAIN</database></link>,
        <link linkend="fblangref25-ddl-domn-alter-de"><database>ALTER DOMAIN</database></link></para>
      </formalpara>
    </section><!-- DROP DOMAIN -->
  </section><!-- Domain -->

  <section id="fblangref25-ddl-tbl-de">
    <title><database>TABLE</database></title>
    <para>Als relationales DBMS speichert Firebird Daten in Tabellen. Eine Tabelle ist eine flache, 
        zweidimensionale Struktur, die eine beliebige Anzahl von Zeilen enthält. 
        Tabellenzeilen werden oft als <emphasis>Datensätze</emphasis> bezeichnet.</para>
    <para>Alle Zeilen in einer Tabelle haben die gleiche Struktur und bestehen aus Spalten. 
        Tabellenspalten werden oft als <emphasis>Felder</emphasis> bezeichnet. Eine Tabelle muss 
        mindestens eine Spalte haben. Jede Spalte enthält einen einzelnen Typ von SQL-Daten.</para>
    <para>In diesem Abschnitt wird beschrieben, wie Sie Tabellen in einer Datenbank erstellen, ändern und löschen.</para>

    <section id="fblangref25-ddl-tbl-create-de">
      <title><database>CREATE TABLE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen Tabelle (Relation)</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE [GLOBAL TEMPORARY] TABLE tablename
		[EXTERNAL [FILE] '&lt;filespec&gt;']
	(&lt;col_def&gt; [, {&lt;col_def&gt; | &lt;tconstraint&gt;} ...])
	[ON COMMIT {DELETE | PRESERVE} ROWS];

&lt;col_def&gt; ::= &lt;regular_col_def&gt; | &lt;computed_col_def&gt;

&lt;regular_col_def&gt; ::=
  colname {&lt;datatype&gt; | domainname}
  [DEFAULT {literal | NULL | &lt;context_var&gt;}]
  [NOT NULL]
  [&lt;col_constraint&gt;]
  [COLLATE collation_name]

&lt;computed_col_def&gt; ::=
  colname [&lt;datatype&gt;]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (&lt;expression&gt;)

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT} [&lt;array_dim&gt;]
  | {FLOAT | DOUBLE PRECISION} [&lt;array_dim&gt;]
  | {DATE | TIME | TIMESTAMP} [&lt;array_dim&gt;]
  | {DECIMAL | NUMERIC} [(precision [, scale])] [&lt;array_dim&gt;]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [&lt;array_dim&gt;] [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)] [&lt;array_dim&gt;]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;array_dim&gt; ::= <command>[</command>[m:]n [, [m:]n ...]<command>]</command>

&lt;col_constraint&gt; ::=
  [CONSTRAINT constr_name]
  {   PRIMARY KEY [&lt;using_index&gt;]
    | UNIQUE      [&lt;using_index&gt;]
    | REFERENCES other_table [(colname)] [&lt;using_index&gt;]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }

&lt;tconstraint&gt; ::=
  [CONSTRAINT constr_name]
  {   PRIMARY KEY (col_list) [&lt;using_index&gt;]
    | UNIQUE      (col_list) [&lt;using_index&gt;]
    | FOREIGN KEY (col_list)
        REFERENCES other_table [(col_list)] [&lt;using_index&gt;]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }"

&lt;col_list&gt; ::= colname [, colname ...]

&lt;using_index&gt; ::= USING
  [ASC[ENDING] | DESC[ENDING]] INDEX indexname

&lt;check_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM&lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;check_condition&gt;)
  | NOT &lt;check_condition&gt;
  | &lt;check_condition&gt; OR &lt;check_condition&gt;
  | &lt;check_condition&gt; AND &lt;check_condition&gt;

&lt;operator&gt; ::= 
&lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    colname [<command>[</command>&lt;array_idx&gt; [, &lt;array_idx&gt; ...]<command>]</command>]
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-createtbl-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE TABLE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name (Kennung) für die Tabelle. Sie kann aus bis zu 31 
                  Zeichen bestehen und in der Datenbank eindeutig sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">filespec</entry>
              <entry align="left">Dateispezifikation (nur für externe Tabellen). Vollständiger 
                  Dateiname und Pfad, der in einfache Anführungszeichen eingeschlossen ist, 
                  unter Berücksichtigung der Regeln des lokalen Dateisystems. Die Datei
                    muss physisch mit dem Host-Computer von Firebird verbunden sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name (Bezeichner) für eine Spalte in der Tabelle. 
                  Kann aus bis zu 31 Zeichen bestehen und in der Tabelle eindeutig sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">col_constraint</entry>
              <entry align="left">Spalten-Constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">tconstraint</entry>
              <entry align="left">Tabellen-Constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">constr_name</entry>
              <entry align="left">Der Name (Bezeichner) einer Einschränkung. Darf aus bis zu 31 Zeichen bestehen.</entry>
            </row>
            <row valign="middle">
              <entry align="center">other_table</entry>
              <entry align="left">Der Name der Tabelle, auf die die Constraint verweist</entry>
            </row>
            <row valign="middle">
              <entry align="center">other_col</entry>
              <entry align="left">Der Name der Spalte in <replaceable> other_table </replaceable>, auf 
              die der Fremdschlüssel verweist</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Ein Literalwert, der im angegebenen Kontext zulässig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Beliebige Kontextvariable, deren Datentyp im angegebenen Kontext zulässig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">check_condition</entry>
              <entry align="left">Die Bedingung, die auf eine CHECK-Einschränkung angewendet wird,
                  die als wahr, false oder <database>NULL</database> aufgelöst wird.
              </entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation</entry>
            </row>
            <row valign="middle">
              <entry align="center">array_dim</entry>
              <entry align="left">Array-Dimensionen</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">INTEGER-Ganzzahlen die den Bereich der Array-Dimensionen angeben</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Die Gesamtzahl der signifikanten Ziffern, die ein Wert des Datentyps 
                  halten kann (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Die Anzahl Stellen nach dem Dezimalkomma (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe eines Strings in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">Der Name eines gültigen Zeichensatzes, falls der Zeichensatz der Spalte 
                  vom Standardzeichensatz der Datenbank abweichen soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB-Subtype-Nummer</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB-Subtyp-Mnemonikname</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">Eine skalare SELECT-Anweisung &mdash; auswählen einer Spalte und 
                  zurückgeben nur einer Zeile</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine Spalte auswählt und null oder mehr 
                  Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine oder mehrere Spalten auswählt und null oder 
                  mehr Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Ein Ausdruck, der auf einen Wert auflöst, der im angegebenen Kontext zulässig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequenzname (Generatorname)</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Interne Funktion oder UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die Anweisung <database>CREATE TABLE</database> erstellt eine neue Tabelle. 
        Jeder Benutzer kann sie erstellen und ihr Name muss unter den Namen aller Tabellen, Ansichten
        und gespeicherten Prozeduren in der Datenbank eindeutig sein. </para>
       <para>Eine Tabelle muss mindestens eine Spalte enthalten, die nicht berechnet wird, 
           und die Namen der Spalten müssen in der Tabelle eindeutig sein.</para>

      <para>Eine Spalte muss entweder einen expliziten <emphasis>SQL-Datentyp</emphasis>, den 
        Namen einer <emphasis>Domain</emphasis>, dessen Attribute für die Spalte kopiert werden 
        oder als <database>COMPUTED BY</database>-Ausdruck (ein <emphasis>berechnetes Feld</emphasis>).</para>

      <para>Eine Tabelle kann eine beliebige Anzahl von Tabelleneinschränkungen haben, einschließlich keiner.</para>

      <section id="fblangref25-ddl-tbl-nonnull-de">
      <title>Eine Spalte nicht nullbar machen</title>
        <para>In Firebird sind Spalten standardmäßig nullwertig. Die optionale <database>NOT NULL</database>-Klausel 
        gibt an, dass die Spalte <database>NULL</database> anstelle eines Wertes nicht verwenden darf.</para>
      </section><!-- non-nullable -->

      <section id="fblangref25-ddl-tbl-character-de">
        <title>Zeichen-Spalten</title>
        <para>Sie können die <database>CHARACTER SET</database>-Klausel verwenden, um den Zeichensatz 
        für die Typen <database>CHAR, VARCHAR</database> und <database>BLOB</database> (SUB_TYPE TEXT) anzugeben. 
        Wenn der Zeichensatz nicht angegeben ist, wird standardmäßig der während der Erstellung der Datenbank angegebene Zeichensatz 
        verwendet. Wurde während der Erstellung der Datenbank kein Zeichensatz angegeben, wird standardmäßig der Zeichensatz NONE 
        übernommen. In diesem Fall werden Daten gespeichert und abgerufen, wie sie übermittelt wurden. Daten in einer beliebigen 
        Kodierung können zu einer solchen Spalte hinzugefügt werden, aber es ist nicht möglich, diese Daten zu einer Spalte mit 
        einer anderen Kodierung hinzuzufügen. Keine Transliteration wird zwischen den
         Quell- und Zielcodierungen, das dies zu Fehlern führen kann.</para>

        <para>Mit der optionalen <database>COLLATE</database>-Klausel können Sie die Sortierreihenfolge für 
        Zeichendatentypen angeben, einschließlich <database>BLOB SUB_TYPE TEXT</database>. Wenn keine 
            Sortierreihenfolge angegeben ist, wird standardmäßig die Sortierreihenfolge angewendet, die für den 
            angegebenen Zeichensatz beim Erstellen der Spalte standardmäßig verwendet wird.</para>
      </section> <!-- character columns -->

      <section id="fblangref25-ddl-tbl-default-de">
        <title>Angabe eines <database>DEFAULT</database>-Wertes</title>
          <para>Die optionale <database>DEFAULT</database>-Klausel erlaubt Ihnen, den Standardwert für eine 
            Tabellenspalte festzulegen. Dieser Wert wird der Spalte während der Ausführung eines 
          <database>INSERT</database>-Statements zugewiesen, sofern kein anderer Wert festgelegt wurde
          <emphasis>und</emphasis> diese Spalte von der <database>INSERT</database>-Anweisung ausgelassen wurde.</para>
          <para>Der Standardwert kann ein Literal eines kompatiblen Typs sein, eine Kontextvariable, die mit dem Datentyp 
              der Spalte typkompatibel ist, oder <database>NULL</database>, wenn die Spalte dies zulässt. Wenn kein 
                  Standardwert explizit angegeben ist, wird NULL impliziert.</para>
          <para>Ein Ausdruck kann nicht als Standardwert verwendet werden.</para>
      </section><!-- default value -->

      <section id="fblangref25-ddl-tbl-domainbased-de">
        <title>Domain-basierte Spalten</title>
        <para>Um eine Spalte zu definieren, können Sie eine zuvor definierte Domain verwenden. Wenn die Definition einer 
            Spalte auf einer Domain basiert, enthält sie möglicherweise einen neuen Standardwert, zusätzliche 
            <database>CHECK</database>-Einschränkungen und eine <database>COLLATE</database>-Klausel, die die 
            in der Domain angegebenen Werte überschreibt. Die Definition einer solchen Spalte kann 
            zusätzliche Spaltenbeschränkungen enthalten (z. B. <database>NOT NULL</database>), wenn die 
            Domain diese nicht besitzt.</para>
        <important>
          <para>Es ist nicht möglich, eine Domain-basierte Spalte zu definieren, die nullbar ist, wenn die Domain mit dem Attribut 
              <database>NOT NULL</database> definiert wurde. Wenn Sie eine Domain haben möchten, die zum Definieren sowohl von 
              nullbaren als auch von nicht-nullbaren Spalten und Variablen verwendet werden kann, empfiehlt es sich, die 
              Domain auf null zu setzen und <database>NOT NULL</database> in der Spaltendefinition zu verwenden.</para>
        </important>
      </section> <!-- domain-based -->

      <section id="fblangref25-ddl-tbl-computedby-de">
        <title>Berechnete Felder</title>
        <para>Berechnete Felder können in der Datenbank mittels <database>COMPUTED [BY]</database> oder <database>GENERATED ALWAYS AS</database> 
        (gemäß SQL: 2003 Standard) definiert werden. Sie meinen dasselbe. Das Beschreiben des Datentyps ist für berechnete 
        Felder nicht erforderlich (aber möglich), da das DBMS den entsprechenden Typ als Ergebnis der Ausdrucksanalyse berechnet 
        und speichert. Entsprechende Operationen für die in einem Ausdruck enthaltenen Datentypen müssen genau angegeben werden.</para>
        <para>Wenn der Datentyp explizit für ein berechnetes Feld angegeben wird, wird das Berechnungsergebnis in den angegebenen Typ konvertiert. 
            Dies bedeutet zum Beispiel, dass das Ergebnis eines numerischen Ausdrucks als String dargestellt werden kann.</para>
        <para>In einer Abfrage, die eine <database>COMPUTED BY</database>-Spalte auswählt, wird der Ausdruck für jede Zeile der 
            ausgewählten Daten ausgewertet.</para>
        <tip>
          <para>Anstelle einer berechneten Spalte ist es in manchen Fällen sinnvoll, eine reguläre Spalte zu verwenden, deren Wert in 
              Triggern zum Hinzufügen und Aktualisieren von Daten ausgewertet wird. Es kann die Leistung des Einfügens / Aktualisierens 
              von Datensätzen verringern, aber es wird die Leistung der Datenabfrage erhöhen.</para>
        </tip>
      </section><!-- calculated fields -->

      <section id="fblangref25-ddl-tbl-array-de">
        <title>Definieren einer <database>ARRAY</database>-Spalte</title>
        <itemizedlist spacing="compact">
          <listitem>Wenn die Spalte ein Array sein soll, kann der Basistyp ein beliebiger SQL-Datentyp sein,
                mit Ausnahme von <database>BLOB</database> und <database>ARRAY</database>.
          </listitem>
          <listitem>Die Grenzen des Arrays werden in eckigen Klammern angegeben. 
              (Im <link linkend="fblangref25-ddl-tbl-create-de"> Syntaxblock</link> werden diese Klammern fett dargestellt, 
              um sie von eckigen Klammern zu unterscheiden, die optionale Syntaxelemente kennzeichnen.
          </listitem>
          <listitem>Für jede Array-Dimension definieren eine oder zwei ganze Zahlen die untere und obere Grenze ihres Indexbereichs:
            <itemizedlist spacing="compact">
              <listitem>Standardmäßig sind Arrays 1-basiert. Die untere Grenze ist implizit und nur die obere Grenze muss angegeben 
                  werden. Eine einzelne Zahl kleiner als 1 definiert den Bereich <replaceable> num </replaceable>. 1 und eine Zahl 
                  größer als 1 definiert den Bereich 1..<replaceable> num </replaceable>.</listitem>
              <listitem>Zwei durch einen Doppelpunkt getrennte Zahlen (':') und optionaler Leerraum, der zweite ist größer als 
                  der erste, können verwendet werden, um den Bereich explizit zu definieren. Eine oder beide Grenzen können 
                  kleiner als Null sein, solange die obere Grenze größer als die untere ist.</listitem>
            </itemizedlist>
          </listitem>
          <listitem>Wenn das Array mehrere Dimensionen hat, müssen die Bereichsdefinitionen für jede Dimension durch Kommas 
              und optionales Leerzeichen getrennt werden.
          </listitem>
          <listitem>Indizes werden <emphasis>nur</emphasis> validiert, wenn ein Array tatsächlich existiert. Dies bedeutet, 
              dass keine Fehlermeldungen bezüglich ungültiger Subskripte zurückgegeben werden, wenn ein bestimmtes Element 
              nichts zurückgibt oder wenn ein Array-Feld <constant>NULL</constant> ist.</listitem>
        </itemizedlist>
      </section><!-- array column -->

      <section id="fblangref25-ddl-tbl-constraints-de">
        <title>Constraints</title>
        <para>Es gibt vier Constraint-Typen. Diese sind:
        <itemizedlist spacing="compact">
          <listitem>Primärschlüssel (<database>PRIMARY KEY</database>)</listitem>
          <listitem>Eindeutigkeitsschlüssel (<database>UNIQUE</database>)</listitem>
          <listitem>Fremdschlüssel(<database>REFERENCES</database>)</listitem>
          <listitem><database>CHECK</database>-Constraint (<database>CHECK</database>)</listitem>
        </itemizedlist>
        </para>
        <para>Constraints können auf Spaltenebene (<quote>Spaltenbeschränkungen</quote>) oder auf Tabellenebene 
        (<quote>Tabellenbeschränkungen</quote>) angegeben werden. Einschränkungen auf Tabellenebene sind erforderlich, 
            wenn Schlüssel (Eindeutigkeitsbeschränkung, Primärschlüssel, Fremdschlüssel) über mehrere Spalten hinweg 
            gebildet werden sollen und wenn eine CHECK-Einschränkung neben der definierten Spalte andere Spalten in der 
            Zeile einbezieht. Die Syntax für einige Constraint-Typen kann je nachdem, ob die Constraint auf Spalten- oder
            Tabellenebene definiert wird, leicht unterschiedlich sein.
          <itemizedlist>
            <listitem>Eine Spaltenbeschränkung wird während einer Spaltendefinition angegeben, nachdem alle Spaltenattribute,
                mit Ausnahme von <database>COLLATION</database>, angegeben wurden und nur die in dieser Definition 
                angegebene Spalte enthalten ist</listitem>
            <listitem>Einschränkungen auf Tabellenebene werden nach allen Spaltendefinitionen angegeben. Sie sind ein flexiblerer 
                Weg, um Einschränkungen festzulegen, da sie Einschränkungen für mehrere Spalten berücksichtigen können</listitem>
            <listitem>Sie können Einschränkungen auf Tabellen- und Spaltenebene im gleichen
            <database>CREATE TABLE</database>-Statement mischen</listitem>
          </itemizedlist>
        </para>
        <para>Das System erstellt automatisch den entsprechenden Index für einen Primärschlüssel (<database>PRIMARY KEY</database>), 
        einen eindeutigen Schlüssel (<database>UNIQUE</database>) und einen Fremdschlüssel (<database>REFERENCES</database> 
         ist eine Einschränkung auf Spaltenebene, <database>FOREIGN KEY REFERENCES</database> eine auf Tabellenebene).</para>

        <section id="fblangref25-ddl-tbl-constraints-names-de">
          <title>Name für Constraints und ihre Indizes</title>
          <para>Spaltenbeschränkungen und ihre Indizes werden automatisch benannt:
            <itemizedlist>
              <listitem>Der Constraint-Name besitzt die Form <database>INTEG_n</database>, wobei
             <database>n</database> ein oder mehrere Ziffern repräsentiert</listitem>
             <listitem>Der Indexname besitzt die Form <database>RDB$PRIMARYn</database> (für einen
                Primärschlüsselindex), <database>RDB$FOREIGNn</database> (für einen Fremdschlüsselindex)
              oder <database>RDB$n</database> (für einen Eindeutigkeitsindex). Auch hier repräsentiert <database>n</database>
              eine oder mehrere Ziffern.</listitem>
            </itemizedlist>
          </para>
          <para>Die automatische Benennung von Einschränkungen auf Tabellenebene und deren Indizes folgt dem 
              gleichen Muster, es sei denn, die Namen werden explizit angegeben.</para>

          <section id="fblangref25-ddl-tbl-constraints-named-de">
            <title>Benannte Constratints</title>
            <para>Ein Constraint kann explizit benannt werden, wenn für ihre Definition die 
                <database>CONSTRAINT</database>-Klausel verwendet wird. Die <database>CONSTRAINT</database>-Klausel 
                ist optional für die Definition von Spaltentypen auf Spaltenebene. Sie ist jedoch 
                obligatorisch für Tabellenstufen. Standardmäßig hat der Constraint-Index denselben 
                Namen wie die Constraint. Wenn für den Constraint-Index ein anderer Name gewünscht 
                wird, kann eine <database>USING</database>-Klausel enthalten sein.</para>
          </section>

          <section id="fblangref25-ddl-tbl-constraints-using-de">
            <title>Die <database>USING</database>-Klausel</title>
            <para>Die Klausel <database>USING</database> erlaubt Ihnen die benutzerdefiniserte Benennung
            des Index, der automatisch erstellt wurde und, optional, die Definition der Indexrichtigung
            &mdash;entweder aufsteigend (Standardwert) oder absteigend.</para>
          </section>
        </section><!-- names for constraints and their indexes -->

        <section id="fblangref25-ddl-tbl-constraints-pk-de">
          <title><database>PRIMARY KEY</database></title>
          <para>Der <database>PRIMARY KEY</database>-Constraint wird auf einer oder mehr
          <firstterm>Schlüsselspalten</firstterm> gebildet, wobei jede Spalte mit einem
          <database>NOT NULL</database>-Constraint definiert wurde. Die Werte in den Schlüsselspalten 
          einer Zeile müssen eindeutig sein. Eine Tabelle kann nur einen Primärschlüssel enthalten.
          <itemizedlist spacing="compact">
            <listitem>Ein einspaltiger Primärschlüssel kann als Spalten- oder Tabellenebene definiert werden</listitem>
            <listitem>Ein mehrspaltiger Primärschlüssel muss als Einschränkung auf Tabellenebene angegeben werden.</listitem>
          </itemizedlist>
          </para>
        </section> <!-- primary key -->

        <section id="fblangref25-ddl-tbl-constraints-uq-de">
          <title>Der <database>UNIQUE</database>-Constraint</title>
          <para>Die Einschränkung <database>UNIQUE</database> definiert die Anforderung der Eindeutigkeit 
          des Inhalts für die Werte in einem Schlüssel in der gesamten Tabelle. Eine Tabelle kann eine 
          beliebige Anzahl von eindeutigen Schlüsseleinschränkungen enthalten.</para>

          <para>Wie beim Primärschlüssel kann die eindeutige Einschränkung mehrspaltig sein. Ist dies der Fall, 
              muss es als Einschränkung auf Tabellenebene angegeben werden.</para>

          <section id="fblangref25-ddl-tbl-uqkey-nulls-de">
            <title><database>NULL</database> in Eindeutigkeitsschlüsseln</title>
            <para>Die SQL-99-konformen Regeln für <database>UNIQUE</database>-Constraints erlauben einen
            oder mehrere <database>NULL</database>s in einer Spalte mit einem <database>UNIQUE</database>-Constraint.
            Dadurch ist es möglich, eine <database>UNIQUE</database>-Beschränkung für eine Spalte zu definieren, 
            die nicht die Einschränkung <database>NOT NULL</database> hat.</para>

            <para>Bei <database>UNIQUE</database>-Schlüsseln, die mehrere Spalten umfassen, ist die Logik 
            ein wenig kompliziert:
              <itemizedlist spacing="compact">
                <listitem>Mehrere Zeilen mit Null in allen Spalten des Schlüssels sind erlaubt
                </listitem>
                <listitem>Mehrere Zeilen mit Schlüsseln mit verschiedenen Kombinationen von Nullen und Nicht-Null-Werten 
                    sind erlaubt</listitem>
                <listitem>Mehrere Zeilen mit denselben Schlüsselspalten null und der Rest mit Werten ungleich null sind zulässig, 
                    sofern sich die Werte in mindestens einer Spalte unterscheiden</listitem>
                <listitem>Mehrere Zeilen mit denselben Schlüsselspalten null und der Rest mit Nicht-Nullwerten, die in jeder 
                    Spalte gleich sind, verletzen die Bedingung</listitem>
              </itemizedlist>
            Die Regeln für die Eindeutigkeit lassen sich so zusammenfassen:
            <blockquote>Im Prinzip werden alle Nullen als eindeutig betrachtet. Wenn jedoch zwei Zeilen exakt die gleichen 
                Schlüsselspalten aufweisen, die mit Werten gefüllt sind, die nicht Null sind, werden die NULL-Spalten ignoriert 
                und die Eindeutigkeit wird für Spalten ohne Null festgelegt, als ob sie den gesamten Schlüssel 
                bilden würden.</blockquote>
              <formalpara>
                <title>Illustration</title>
                <blockquote><programlisting>
RECREATE TABLE t( x int, y int, z int, unique(x,y,z));
INSERT INTO t values( NULL, 1, 1 );
INSERT INTO t values( NULL, NULL, 1 );
INSERT INTO t values( NULL, NULL, NULL );
INSERT INTO t values( NULL, NULL, NULL ); -- Erlaubt
INSERT INTO t values( NULL, NULL, 1 );    -- Nicht erlaubt
                </programlisting></blockquote>
              </formalpara>
            </para>
          </section> <!-- null in unique keys -->
        </section><!-- unique constraint -->

        <section id="fblangref25-ddl-tbl-constraints-refs-de">
          <title><database>FOREIGN KEY</database></title>
          <para>Ein Fremdschlüssel stellt sicher, dass die teilnehmenden Spalten nur Werte 
              enthalten dürfen, die auch in der referenzierten Spalte (n) in der Mastertabelle 
              vorhanden sind. Diese referenzierten Spalten werden oft als 
              <firstterm> Zielspalten </firstterm> bezeichnet. Sie müssen der Primärschlüssel 
              oder ein eindeutiger Schlüssel in der Zieltabelle sein. Sie müssen keine 
              <database>NOT NULL</database>-Einschränkung definiert haben, obwohl sie, wenn 
              sie der Primärschlüssel sind, natürlich diese Einschränkung haben.</para>
          <para>Die Fremdschlüsselspalten in der referenzierenden Tabelle selbst erfordern keine 
              <database>NOT NULL</database>-Einschränkung.</para>
          <para>Ein einspaltiger Fremdschlüssel kann in der Spaltendeklaration definiert werden, 
              wobei das Schlüsselwort <database>REFERENCES</database> verwendet wird:
            <blockquote><programlisting>
... ,
ARTIFACT_ID INTEGER REFERENCES COLLECTION (ARTIFACT_ID),
            </programlisting></blockquote>
          Die Spalte <database>ARTIFACT_ID</database> im Beispiel verweist auf eine gleichnamige 
          Spalte in der Tabelle <database>COLLECTIONS</database>.
          </para>
          <para>Sowohl einspaltige als auch mehrspaltige Fremdschlüssel können auf der <firstterm> Tabellenebene </firstterm> 
          definiert werden. Bei einem mehrspaltigen Fremdschlüssel ist die Deklaration auf Tabellenebene die einzige Option. 
          Diese Methode ermöglicht auch die Angabe eines optionalen Namens für die Einschränkung:
            <blockquote><programlisting>
...
CONSTRAINT FK_ARTSOURCE FOREIGN KEY(DEALER_ID, COUNTRY)
  REFERENCES DEALER (DEALER_ID, COUNTRY),
            </programlisting></blockquote>
          Beachten Sie, dass sich die Spaltennamen in der referenzierten Tabelle (<quote>master</quote>) möglicherweise 
          von denen im Fremdschlüssel unterscheiden.</para>
          <note>
            <para>Wenn keine Zielspalten angegeben sind, verweist der Fremdschlüssel automatisch auf den Primärschlüssel 
                der Zieltabelle.</para>
          </note>
          <section id="fblangref25-ddl-tbl-constraints-fkactions-de">
            <title>Fremdschlüsselaktionen</title>
            <para>Mit den Unterklauseln <database>ON UPDATE</database> und <database>ON DELETE</database> ist es möglich, 
            eine Aktion für die betroffenen Fremdschlüsselspalte anzugeben, wenn referenzierte Werte in der 
            Mastertabelle geändert werden:
              <itemizedlist>
                <listitem><database>NO ACTION</database> (der Standard) - nichts wird getan </listitem>
                <listitem><database>CASCADE</database> - Die Änderung in der Mastertabelle wird an die entsprechende(n) Zeile(n) 
                in der untergeordneten Tabelle weitergegeben. Wenn sich ein Schlüsselwert ändert, ändert sich der entsprechende 
                Schlüssel in den untergeordneten Datensätzen auf den neuen Wert; Wenn die Master-Zeile gelöscht wird, werden 
                die untergeordneten Datensätze gelöscht.</listitem>
                <listitem><database>SET DEFAULT</database> - Die Fremdschlüsselspalten in den betroffenen Zeilen werden wie bei der 
                Definition der Fremdschlüsselbeschränkung <emphasis>auf ihre Standardwerte gesetzt</emphasis>.</listitem>
                <listitem><database>SET NULL</database> - Die Fremdschlüssel-Spalten in den betroffenen Zeilen werden auf 
                NULL gesetzt.</listitem>
              </itemizedlist>
            Die angegebene Aktion oder die Standardeinstellung <database>NO ACTION</database> könnte dazu führen, dass eine 
            Fremdschlüsselspalte ungültig wird. Beispielsweise könnte er einen Wert erhalten, der in der Mastertabelle nicht 
            vorhanden ist, oder er könnte <database>NULL</database> werden, während die Spalte eine 
            <database>NOT NULL</database>-Einschränkung hat. Solche Bedingungen führen dazu, dass die Operation in der 
            Master-Tabelle mit einer Fehlermeldung fehlschlägt.
            </para>
            <formalpara>
              <title>Beispiel</title>
              <blockquote><programlisting>
...
  CONSTRAINT FK_ORDERS_CUST
    FOREIGN KEY (CUSTOMER) REFERENCES CUSTOMERS (ID)
    ON UPDATE CASCADE ON DELETE SET NULL
              </programlisting></blockquote>
            </formalpara>
          </section> <!-- FK actions -->
        </section><!-- foreign key -->

        <section id="fblangref25-ddl-tbl-constraints-check-de">
          <title><database>CHECK</database>-Constraint</title>
          <para>Die Bedingung <database>CHECK</database> definiert die Bedingung, die die in diese 
          Spalte eingefügten Werte erfüllen müssen. Eine Bedingung ist ein logischer Ausdruck 
          (auch Prädikat genannt), der die Werte TRUE, FALSE und UNKNOWN zurückgeben kann. Eine Bedingung 
          gilt als erfüllt, wenn das Prädikat TRUE oder den Wert UNKNOWN (entspricht NULL) zurückgibt. 
          Wenn das Prädikat FALSE zurückgibt, wird der Wert nicht akzeptiert. Diese Bedingung wird zum 
          Einfügen einer neuen Zeile in die Tabelle (die Anweisung <database>INSERT</database>) und zum 
          Aktualisieren des vorhandenen Werts der Tabellenspalte (die Anweisung <database>UPDATE</database> 
          wo eine dieser Aktionen stattfinden kann (UPDATE ODER INSERT, MERGE).</para>
          <important>
            <para>Eine <database>CHECK</database>-Beschränkung für eine Domainbasierte Spalte ersetzt 
            eine vorhandene <database>CHECK</database>-Bedingung in der Domain nicht, sondern wird zu 
            einer Ergänzung. Die Firebird-Engine hat während der Definition keine Möglichkeit zu überprüfen, 
            ob der zusätzliche <database>CHECK</database> nicht mit dem vorhandenen übereinstimmt.</para>
          </important>

          <para><database>CHECK</database>-Bedingungen &mdash; ob auf Tabellen- oder Spaltenebene definiert &mdash; 
          beziehen sich auf Tabellenspalten <emphasis>durch ihren Namen</emphasis>. Die Verwendung des Schlüsselworts 
          <database>VALUE</database> als Platzhalter wie auch in der <database>CHECK</database>-Bedingung für Domains
          ist im Kontext der Definition von Spalteneinschränkungen nicht zulässig.</para>
          <formalpara>
            <title>Beispiele</title>
            <para> mit zwei Einschränkungen auf Spaltenebene und einer auf Tabellenebene:
              <blockquote><programlisting>
CREATE TABLE PLACES (
  ...
  LAT DECIMAL(9, 6) CHECK (ABS(LAT) &lt;=  90),
  LON DECIMAL(9, 6) CHECK (ABS(LON) &lt;= 180),
  ...
  CONSTRAINT CHK_POLES CHECK (ABS(LAT) &lt; 90 OR LON = 0)
                     );
              </programlisting></blockquote>
            </para>
          </formalpara>
        </section> <!-- check constraint -->
      </section> <!-- constraints -->

      <section id="fblangref25-ddl-tbl-gtt-de">
        <title>Global Temporary Tables (GTT)</title>
        <para>Global Temporary Tables haben persistente Metadaten, aber ihre Inhalte sind transaktions- 
            (Standard) oder verbindungsgebunden. Jede Transaktion oder Verbindung hat eine eigene private 
            Instanz eines GTT, isoliert von allen anderen. Instanzen werden nur dann erstellt, wenn auf 
            das GTT verwiesen wird. Sie werden beim Beenden der Transaktion oder beim Trennen zerstört. 
            Die Metadaten eines GTT können mit ALTER TABLE bzw. DROP TABLE geändert oder entfernt werden.</para>

        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE <replaceable>name</replaceable>
  (&lt;column_def&gt; [, {&lt;column_def&gt; | &lt;table_constraint&gt;} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
            </programlisting></blockquote>
          </para>
        </formalpara>
        <note>
          <title>Hinweise zur Syntax</title>
          <itemizedlist spacing="compact">
            <listitem><database>ON COMMIT DELETE ROWS</database> erstellt eine transaktionsgebundene GTT (der Standard)
            <database>ON COMMIT PRESERVE ROWS</database> eine verbindungsgebundene GTT</listitem>
            <listitem>Eine <database>EXTERNAL [FILE]</database>-Klausel ist nicht zulässig in der Definition einer
            GTT</listitem>
          </itemizedlist>
        </note>

        <section id="fblangref25-ddl-tbl-gtt-restrictions-de">
          <title>Einschränkungen für GTTs</title>
          <para>GTTs können mit allen Features und Utensilien gewöhnlicher Tabellen 
              (Schlüssel, Referenzen, Indizes, Trigger usw.) <quote>ausgestattet werden</quote>, 
              aber es gibt einige Einschränkungen:
            <itemizedlist spacing="compact">
              <listitem>GTTs und reguläre Tabellen können sich nicht gegenseitig referenzieren</listitem>
              <listitem>Eine verbindungsgebundene (<quote>PRESERVE ROWS</quote>) GTT kann nicht auf eine 
              transaktionsgebundene (<quote>DELETE ROWS</quote>) GTT verweisen</listitem>
              <listitem>Domain-Constraints können nicht auf GTTs verweisen</listitem>
              <listitem>Die Zerstörung einer GTT-Instanz am Ende ihres Lebenszyklus löst keine 
                  <database>BEFORE / AFTER</database>-Löschtrigger aus</listitem>
            </itemizedlist>
          </para>
        </section>

        <tip>
          <para>In einer vorhandenen Datenbank ist es nicht immer einfach, eine reguläre Tabelle 
              von einer GTT oder einer GTT auf Transaktions- von einer GTT auf Verbindungsebene 
              zu unterscheiden. Verwenden Sie diese Abfrage, um herauszufinden, welche Art von Tabelle 
              Sie betrachten:
            <programlisting>
select t.rdb$type_name
  from rdb$relations r
  join rdb$types t on r.rdb$relation_type = t.rdb$type
    where t.rdb$field_name = 'RDB$RELATION_TYPE'
    and r.rdb$relation_name = '<replaceable>TABLENAME</replaceable>'
            </programlisting>
        Für einen Überblick über die Typen aller Beziehungen in der Datenbank:
            <programlisting>
    select r.rdb$relation_name, t.rdb$type_name
    from rdb$relations r
    join rdb$types t on r.rdb$relation_type = t.rdb$type
    where t.rdb$field_name = 'RDB$RELATION_TYPE'
    and coalesce (r.rdb$system_flag, 0) = 0
            </programlisting>
          Das Feld <database>RDB$TYPE_NAME</database> zeigt PERSISTENT für eine reguläre Tabelle, 
          VIEW für eine Ansicht, GLOBAL_TEMPORARY_PRESERVE für eine verbindungsgebundene GTT 
          und GLOBAL_TEMPORARY_DELETE für eine transaktionsgebundene GTT.</para>
        </tip>
      </section> <!-- GTTs -->

      <section id="fblangref25-ddl-tbl-external-de">
      <title>Externe Tabellen</title>
        <para>Die optionale Klausel <database>EXTERNAL [FILE]</database> gibt an, dass die Tabelle außerhalb der 
        Datenbank in einer externen Textdatei mit Datensätzen fester Länge gespeichert wird. Die Spalten einer Tabelle, 
        die in einer externen Datei gespeichert sind, können von einem beliebigen Typ außer <database>BLOB</database> 
        oder <database>ARRAY</database> sein.</para> 
        <para> Alles, was Sie mit einer in einer externen Datei gespeicherten Tabelle tun können, ist, neue Zeilen einzufügen
            (<database>INSERT</database>) und die Daten abzufragen). Das Aktualisieren vorhandener Daten 
            (<database>UPDATE</database>) und das Löschen von Zeilen (<database>DELETE</database>) 
            sind nicht möglich.</para>

        <para>Eine Datei, die als externe Tabelle definiert ist, muss sich auf einem Speichergerät befinden, 
            das physisch auf dem Computer vorhanden ist, auf dem der Firebird-Server ausgeführt wird. Wenn der 
            Parameter <emphasis>ExternalFileAccess</emphasis> in der Konfigurationsdatei <filename>firebird.conf</filename> 
            auf <function> Restrict </function> lautet, muss in einem der dort aufgeführten Verzeichnisse das Argument für 
            <function> Restrict </function> stehen. Wenn die Datei nicht schon
         existiert, wird Firebird diese beim ersten Zugriff erstellen.</para>

        <important>
          <para>Die Möglichkeit, externe Dateien für eine Tabelle zu verwenden, hängt vom Wert ab, der für den Parameter 
              <emphasis>ExternalFileAccess</emphasis> in <filename> firebird.conf </filename> festgelegt wurde:
            <itemizedlist>
              <listitem>Wenn der Parameter auf <function> None </function> (Standardeinstellung) eingestellt ist, 
              wird jeder Zugriff auf eine externe Datei verweigert.</listitem>
              <listitem>Die Einstellung <function> Restrict </function> wird empfohlen, um den Zugriff externer Dateien auf 
                  Verzeichnisse einzuschränken, die vom Serveradministrator explizit für diesen Zweck erstellt wurden. 
              Beispielsweise:
                <itemizedlist spacing="compact">
                  <listitem><function>ExternalFileAccess = Restrict externalfiles</function> schränkt den 
                  Zugriff auf ein Verzeichnis namens <function>externalfiles</function> direkt unterhalb des Firebird
                  Wurzelverzeichnisses ein</listitem>
                  <listitem><function>ExternalFileAccess = d:\databases\outfiles; e:\infiles</function> schränkt den Zugriff 
                  auf die zwei angegebenen Verzeichnisse des Windows-Hostservers ein. Beachten Sie, dass jeder Pfad, der eine 
                  Netzwerkzuordnung ist, nicht funktioniert. Pfade, die in einfachen oder doppelten Anführungszeichen 
                  eingeschlossen sind, funktionieren auch nicht.</listitem>
                </itemizedlist>
              </listitem>
              <listitem>Wenn dieser Parameter auf <function> Full </function> eingestellt ist, kann auf externe Dateien im 
                  Host-Dateisystem zugegriffen werden. Es schafft eine Sicherheitslücke und wird nicht empfohlen.</listitem>
            </itemizedlist>
          </para>
        </important>

        <section id="fblangref25-ddl-tbl-ext-format-de">
          <title>Externes Dateiformat</title>
          <para>Das <quote>Zeilen</quote>-Format einer externen Tabelle besteht aus fester Länge. Es gibt keine Feldbegrenzer: Sowohl 
          Feld- als auch Zeilengrenzen werden durch die maximale Größe der Felddefinitionen in Bytes bestimmt. Dies ist sowohl 
          beim Definieren der Struktur der externen Tabelle als auch beim Entwerfen einer Eingabedatei für eine externe Tabelle 
          wichtig, die Daten aus einer anderen Anwendung importieren soll. Das ubiquitäre <quote>.csv</quote>-Format ist 
          z. B. nicht nützlich als Eingabedatei und kann nicht direkt in eine externe Datei generiert werden.</para>

          <para>Der nützlichste Datentyp für die Spalten externer Tabellen ist der Typ <database>CHAR</database> mit fester 
          Länge mit geeigneten Längen für die Daten, die sie tragen sollen. Datums- und Zahlentypen können problemlos zu und 
          von Zeichenketten umgewandelt werden, solange die Dateien nicht von einer anderen Firebird-Datenbank gelesen werden sollen,
          werden die nativen Datentypen externen Anwendungen als unparsbar <quote>alphabetti</quote> angezeigt.</para>

          <para>Natürlich gibt es Möglichkeiten, typisierte Daten zu manipulieren, um Ausgabedateien von Firebird zu generieren, 
              die als Eingabedateien für andere Anwendungen mithilfe von gespeicherten Prozeduren mit oder ohne externe Tabellen 
              gelesen werden können. Solche Techniken liegen außerhalb des Bereichs einer Sprachreferenz. Hier finden Sie einige 
              Richtlinien und Tipps zum Erstellen und Arbeiten mit einfachen Textdateien, da die externe Tabellenfunktion häufig als 
              einfache Möglichkeit zum Erstellen oder Lesen von transaktionsunabhängigen Protokollen verwendet wird, die offline in 
              einem Texteditor oder in einem Auditing untersucht werden können Anwendung.</para>

          <section id="fblangref25-ddl-tbl-ext-format-delimiter-de">
            <title>Zeilenbegrenzer</title>
            <para>Im Allgemeinen sind externe Dateien nützlicher, wenn Zeilen durch ein Trennzeichen in Form einer 
                <quote>newline</quote>-Sequenz getrennt werden, die von Leseanwendungen auf der vorgesehenen Plattform erkannt wird. 
                Für die meisten Kontexte unter Windows ist dies die Zwei-Byte-CRLF-Sequenz, Wagenrücklauf (ASCII-Code dezimal 13) und 
                Zeilenvorschub (ASCII-Code dezimal 10). Auf POSIX ist LF für sich allein üblich; Bei einigen MacOSX-Anwendungen kann es 
                sich um LFCR handeln. Es gibt verschiedene Möglichkeiten, diese Begrenzerspalte zu füllen. In unserem Beispiel unten 
                geschieht dies mittel Before Insert-Trigger und der internen Funktion <database>ASCII_CHAR</database>.</para>
          </section> <!-- row delimiters -->

          <bridgehead renderas="sect4">Beispiel einer externen Tabelle</bridgehead>
          <para>In unserem Beispiel definieren wir eine externe Protokolltabelle, die von einem Ausnahmehandler in einer gespeicherten 
              Prozedur oder einem Trigger verwendet werden kann. Die externe Tabelle wird ausgewählt, da die Nachrichten aus den 
              behandelten Ausnahmen im Protokoll beibehalten werden, selbst wenn die Transaktion, die den Prozess gestartet hat, 
              aufgrund einer anderen, nicht behandelten Ausnahme schließlich zurückgesetzt wird. Zu Demonstrationszwecken gibt es nur 
              zwei Datenspalten, einen Zeitstempel und eine Nachricht. Die dritte Spalte speichert den Zeilenbegrenzer:
           <blockquote><programlisting>
CREATE TABLE ext_log
  EXTERNAL FILE 'd:\externals\log_me.txt' (
  stamp CHAR (24),
  message CHAR(100),
  crlf CHAR(2) );  -- for a Windows context
COMMIT;
           </programlisting></blockquote>
            Jetzt noch einen Trigger erstellen, der Zeitstempel und Zeilenbegrenzer festlegt, sobald eine Nachricht in 
           die Datei geschrieben wird:
           <blockquote><programlisting>
SET TERM ^;
CREATE TRIGGER bi_ext_log FOR ext_log
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (new.stamp is NULL) then
    new.stamp = CAST (CURRENT_TIMESTAMP as CHAR(24));
  new.crlf = ASCII_CHAR(13) || ASCII_CHAR(10);
END ^
COMMIT ^
SET TERM ;^
           </programlisting></blockquote>
         Einfügen von Datensätzen (die von einem Exception-Handler oder Shakespeare-Fan gemacht worden sein könnten):
           <blockquote><programlisting>
insert into ext_log (message)
values('Shall I compare thee to a summer''s day?');
insert into ext_log (message)
values('Thou art more lovely and more temperate')
           </programlisting></blockquote>
         Die Ausgabe:
           <blockquote><literallayout class="monospaced">
2015-10-07 15:19:03.4110Shall I compare thee to a summer's day?
2015-10-07 15:19:58.7600Thou art more lovely and more temperate
           </literallayout></blockquote>
         </para>
        </section> <!-- external file format -->
      </section><!-- external table -->

      <section id="fblangref25-ddl-tbl-exmpls-de">
        <title>Beispiele für <database>CREATE TABLE</database></title>
        <orderedlist>
          <listitem>Erstellen der Tabelle COUNTRY mit dem als Spaltenbeschränkung angegebenen Primärschlüssel.
            <programlisting>
CREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
            </programlisting>
          </listitem>
          <listitem>Erstellen der STOCK-Tabelle mit dem auf der Spaltenebene angegebenen benannten Primärschlüssel und 
              dem auf der Tabellenebene angegebenen benannten eindeutigen Schlüssel.
            <programlisting>
CREATE TABLE STOCK (
  MODEL SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID));
            </programlisting>
          </listitem>
          <listitem>Erstellen der JOB-Tabelle mit einer Primärschlüsselbeschränkung, die zwei Spalten umfasst, eine 
              Fremdschlüsselbeschränkung für die Tabelle COUNTRY und eine CHECK-Einschränkung auf Tabellenebene. Die 
              Tabelle enthält außerdem eine Reihe von 5 Elementen.
            <programlisting>
CREATE TABLE JOB (
    JOB_CODE         JOBCODE NOT NULL,
    JOB_GRADE        JOBGRADE NOT NULL,
    JOB_COUNTRY      COUNTRYNAME,
    JOB_TITLE        VARCHAR(25) NOT NULL,
    MIN_SALARY       NUMERIC(18, 2) DEFAULT 0 NOT NULL,
    MAX_SALARY       NUMERIC(18, 2) NOT NULL,
    JOB_REQUIREMENT  BLOB SUB_TYPE 1,
    LANGUAGE_REQ     VARCHAR(15) [1:5],
    PRIMARY KEY (JOB_CODE, JOB_GRADE),
    FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY)
    ON UPDATE CASCADE
    ON DELETE SET NULL,
    CONSTRAINT CHK_SALARY CHECK (MIN_SALARY &lt; MAX_SALARY)
);
            </programlisting>
          </listitem>
          <listitem>Erstellen der PROJECT-Tabelle mit Primär-, Fremd- und eindeutigen 
              Schlüsseleinschränkungen mit benutzerdefinierten Indexnamen, die mit der 
              USING-Klausel angegeben wurden.
            <programlisting>
CREATE TABLE PROJECT (
    PROJ_ID    PROJNO NOT NULL,
    PROJ_NAME  VARCHAR(20) NOT NULL UNIQUE USING DESC INDEX IDX_PROJNAME,
    PROJ_DESC    BLOB SUB_TYPE 1,
    TEAM_LEADER  EMPNO,
    PRODUCT      PRODTYPE,
    CONSTRAINT PK_PROJECT PRIMARY KEY (PROJ_ID) USING INDEX IDX_PROJ_ID,
    FOREIGN KEY (TEAM_LEADER) REFERENCES EMPLOYEE (EMP_NO)
      USING INDEX IDX_LEADER
);
            </programlisting>
          </listitem>
          <listitem>Erstellen der Tabelle SALARY_HISTORY mit zwei berechneten Feldern. 
              Der erste wird gemäß dem Standard SQL:2003 deklariert, während der zweite gemäß der 
              traditionellen Deklaration der berechneten Felder in Firebird deklariert wird.
            <programlisting>
CREATE TABLE SALARY_HISTORY (
    EMP_NO          EMPNO NOT NULL,
    CHANGE_DATE     TIMESTAMP DEFAULT 'NOW' NOT NULL,
    UPDATER_ID      VARCHAR(20) NOT NULL,
    OLD_SALARY      SALARY NOT NULL,
    PERCENT_CHANGE  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    SALARY_CHANGE   GENERATED ALWAYS AS
      (OLD_SALARY * PERCENT_CHANGE / 100),
    NEW_SALARY      COMPUTED BY
      (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
);
            </programlisting>
          </listitem>
          <listitem>Erstellen einer verbindungsabhängigen Global Temporary Table.
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
ON COMMIT PRESERVE ROWS;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer transaktionsbezogenen globalen temporären Tabelle, die einen 
              Fremdschlüssel verwendet, um auf eine globale globale temporäre Tabelle mit Verbindungsbereich 
              zu verweisen. Die ON COMMIT-Unterklausel ist optional, da DELETE ROWS die Standardeinstellung ist.
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
      ON COMMIT DELETE ROWS;
            </programlisting>
          </listitem>
        </orderedlist>
      </section> <!-- create table examples -->
    </section> <!-- Create table -->

    <section id="fblangref25-ddl-tbl-alter-de">
      <title><database>ALTER TABLE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Ändern der Tabellenstruktur.</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER TABLE tablename
&lt;operation&gt; [, &lt;operation&gt; ...]

&lt;operation&gt; ::= ADD &lt;col_def&gt;
                      ADD &lt;tconstraint&gt;
                      DROP <replaceable>colname</replaceable>
                      DROP CONSTRAINT <replaceable>constr_name</replaceable>
                      ALTER [COLUMN] <replaceable>colname</replaceable> &lt;col_mod&gt;

&lt;col_def&gt; ::= &lt;regular_col_def&gt; | &lt;computed_col_def&gt;

&lt;regular_col_def&gt; ::=
  colname {&lt;datatype&gt; | domainname}
  [DEFAULT {literal | NULL | &lt;context_var&gt;}]
  [NOT NULL]
  [&lt;col_constraint&gt;]
  [COLLATE collation_name]

&lt;computed_col_def&gt; ::=
  colname [&lt;datatype&gt;]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (&lt;expression&gt;)

&lt;col_mod&gt; ::= &lt;regular_col_mod&gt; | &lt;computed_col_mod&gt;

&lt;regular_col_mod&gt; ::=
    TO <replaceable>newname</replaceable>
  | POSITION <replaceable>newpos</replaceable>
  | TYPE {&lt;datatype&gt; | <replaceable>domainname</replaceable>}
  | SET DEFAULT {<replaceable>literal</replaceable> | NULL | &lt;context_var&gt;}
  | DROP DEFAULT

&lt;computed_col_mod&gt; ::=
    TO <replaceable>newname</replaceable>
  | POSITION <replaceable>newpos</replaceable>
  | [TYPE &lt;datatype&gt;] {COMPUTED [BY] | GENERATED ALWAYS AS} (&lt;expression&gt;)

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT} [&lt;array_dim&gt;]
  | {FLOAT | DOUBLE PRECISION} [&lt;array_dim&gt;]
  | {DATE | TIME | TIMESTAMP} [&lt;array_dim&gt;]
  | {DECIMAL | NUMERIC} [(precision [, scale])] [&lt;array_dim&gt;]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [&lt;array_dim&gt;] [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)] [&lt;array_dim&gt;]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;array_dim&gt; ::= <command>[</command>[m]:n [,[m]:n ...]<command>]</command>

&lt;col_constraint&gt; ::=
  [CONSTRAINT constr_name]
  {   PRIMARY KEY [&lt;using_index&gt;]
    | UNIQUE      [&lt;using_index&gt;]
    | REFERENCES other_table [(colname)] [&lt;using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }

&lt;tconstraint&gt; ::=
  [CONSTRAINT <replaceable>constr_name</replaceable>]
  {   PRIMARY KEY (<replaceable>col_list</replaceable>) [&lt;using_index&gt;]
    | UNIQUE      (<replaceable>col_list</replaceable>) [&lt;using_index&gt;]
    | FOREIGN KEY (<replaceable>col_list</replaceable>)
        REFERENCES <replaceable>other_table</replaceable> [(<replaceable>col_list</replaceable>)] [&lt;using_index&gt;]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }

&lt;col_list&gt; ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]

&lt;using_index&gt; ::= USING
[ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>indexname</replaceable>

&lt;check_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM &lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;search_condition&gt;)
  | NOT &lt;search_condition&gt;
  | &lt;search_condition&gt; OR &lt;search_condition&gt;
  | &lt;search_condition&gt; AND &lt;search_condition&gt;

&lt;operator&gt; ::= 
  &lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    colname [<command>[</command>&lt;array_idx&gt; [, &lt;array_idx&gt; ...]<command>]</command>]
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-altertbl-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER TABLE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name (Kennung) für die Tabelle. Sie kann aus bis zu 31 
                  Zeichen bestehen und in der Datenbank eindeutig sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">operation</entry>
              <entry align="left">Eine der verfügbaren Operationen, die die Struktur der Tabelle verändert</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name (Bezeichner) für eine Spalte in der Tabelle, max. 31 Zeichen. Muss in der Tabelle eindeutig sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">newname</entry>
              <entry align="left">Neuer Name (Bezeichner) für die Spalte, max. 31 Zeichen. Muss in der Tabelle eindeutig sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">newpos</entry>
              <entry align="left">Die neue Spaltenposition (eine Ganzzahl zwischen 1 und der Anzahl der Spalten in der Tabelle)</entry>
            </row>
            <row valign="middle">
              <entry align="center">col_constraint</entry>
              <entry align="left">Spalten-Constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">tconstraint</entry>
              <entry align="left">Tabellen-Constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">constr_name</entry>
              <entry align="left">Der Name (Bezeichner) einer Einschränkung. Darf aus bis zu 31 Zeichen bestehen.</entry>
            </row>
            <row valign="middle">
              <entry align="center">other_table</entry>
              <entry align="left">Der Name der Tabelle, auf die die Constraint verweist</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Ein Literalwert, der im angegebenen Kontext zulässig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Beliebige Kontextvariable, deren Datentyp im angegebenen Kontext zulässig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">check_condition</entry>
              <entry align="left">Die Bedingung, die auf eine CHECK-Einschränkung angewendet wird,
                  die als wahr, false oder <database>NULL</database> aufgelöst wird.
              </entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation</entry>
            </row>
            <row valign="middle">
              <entry align="center">array_dim</entry>
              <entry align="left">Array-Dimensionen</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">INTEGER-Ganzzahlen die den Bereich der Array-Dimensionen angeben</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Die Gesamtzahl der signifikanten Ziffern, die ein Wert des Datentyps 
                  halten kann (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Die Anzahl Stellen nach dem Dezimalkomma (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe eines Strings in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">Der Name eines gültigen Zeichensatzes, falls der Zeichensatz der Spalte 
                  vom Standardzeichensatz der Datenbank abweichen soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB-Subtype-Nummer</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB-Subtyp-Mnemonikname</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">Eine skalare SELECT-Anweisung &mdash; auswählen einer Spalte und 
                  zurückgeben nur einer Zeile</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine Spalte auswählt und null oder mehr 
                  Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">Eine SELECT-Anweisung, die eine oder mehrere Spalten auswählt und null oder 
                  mehr Zeilen zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Ein Ausdruck, der auf einen Wert auflöst, der im angegebenen Kontext zulässig ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequenzname (Generatorname)</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Interne Funktion oder UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die <database>ALTER TABLE</database>-Anweisung ändert die Struktur einer vorhandenen Tabelle. 
      Mit einer Anweisung <database>ALTER TABLE</database> können Sie mehrere Operationen ausführen, 
      Spalten und Einschränkungen hinzufügen und löschen sowie Spaltenangaben ändern. </para>
      <para>Mehrere Operationen in einer Anweisung <database>ALTER TABLE</database> werden durch Kommata 
      getrennt.</para>

      <section id="fblangref25-ddl-tbl-altrvcount-de">
        <title>Zählung von Versionsinkrementen</title>
        <para>Einige Änderungen in der Struktur einer Tabelle erhöhen den Metadatenänderungszähler (<quote>Versionszähler</quote>), 
        der jeder Tabelle zugewiesen ist. Die Anzahl der Metadatenänderungen ist für jede Tabelle auf 255 beschränkt. Sobald der 
        Zähler die Grenze von 255 erreicht hat, können Sie keine weiteren Änderungen an der Struktur der Tabelle vornehmen,
         ohne den Zähler zurückzusetzen.
          <formalpara>
            <title>So setzen Sie den Metadaten-Änderungszähler zurück</title>
            <para> Sie sollten die Datenbank mithilfe des Dienstprogramms <emphasis>gbak</emphasis> sichern und 
            wiederherstellen.</para>
          </formalpara>
        </para>
      </section>

      <section id="fblangref25-ddl-tbl-altradd-de">
        <title>Die <database>ADD</database>-Klausel</title>
        <para>Mit der <database>ADD</database>-Klausel können Sie eine neue Spalte oder eine neue Tabellenbeschränkung 
        hinzufügen. Die Syntax zum Definieren der Spalte und die Syntax zum Definieren der Tabellenbeschränkung 
        entsprechen denen, die für die Anweisung <database>CREATE TABLE</database> beschrieben wurden.</para>
        <formalpara>
          <title>Auswirkung auf die Versionszählung</title>
          <itemizedlist spacing="compact">
            <listitem>Jedes Mal, wenn eine neue Spalte hinzugefügt wird, wächst der Metadatenänderungszähler um eins</listitem>
            <listitem>Das Hinzufügen einer neuen Tabellenbeschränkung erhöht den Metadatenänderungszähler nicht</listitem>
          </itemizedlist>
        </formalpara>
        <caution>
          <title>Zu beachtende Punkte</title>
          <orderedlist>
            <listitem>
              <para>Seien Sie vorsichtig beim Hinzufügen einer neuen Spalte mit der Einschränkungsgruppe 
               <database>NOT NULL</database>. Es kann dazu führen, dass die logische Integrität von Daten beeinträchtigt wird, 
              wenn Sie in einer Spalte, die nicht auf Null gesetzt werden kann, Datensätze mit <database>NULL</database> 
              haben. Beim Hinzufügen einer nicht-nullbaren Spalte wird empfohlen, entweder einen Standardwert dafür 
              festzulegen oder die Spalte in vorhandenen Zeilen mit einem anderen Wert als Null zu aktualisieren.</para>
            </listitem>
            <listitem>
              <para>Wenn eine neue <database>CHECK</database>-Beschränkung hinzugefügt wird, werden vorhandene Daten nicht 
              auf Übereinstimmung geprüft. Es wird empfohlen, vorhandene Daten mit dem neuen <database>CHECK</database>-Ausdruck 
              zu testen.</para>
            </listitem>
          </orderedlist>
        </caution>
      </section>

      <section id="fblangref25-ddl-tbl-altrdropcol-de">
        <title>Die <database>DROP</database>-Klausel</title>
        <para>Die Klausel <database>DROP</database> <emphasis>&lt; Spaltenname &gt;</emphasis> löscht die angegebene 
            Spalte aus der Tabelle. Ein Versuch, eine Spalte zu löschen, schlägt fehl, wenn irgendetwas darauf verweist. 
            Betrachten Sie die folgenden Elemente als Quellen potenzieller Abhängigkeiten:
          <itemizedlist spacing="compact">
            <listitem>Spalten- oder Tabellenbeschränkungen</listitem>
            <listitem>Indizes</listitem>
            <listitem>Stored Procedures und Trigger</listitem>
            <listitem>Ansichten (Views)</listitem>
          </itemizedlist>
        </para>
        <formalpara>
          <title>Auswirkung auf Versionszählung</title>
          <para> Jedes Mal, wenn eine Spalte gelöscht wird, wird der Metadatenänderungszähler der 
              Tabelle um eins erhöht.</para>
        </formalpara>
      </section>

      <section id="fblangref25-ddl-tbl-altrdropconstr-de">
        <title>Die <database>DROP CONSTRAINT</database>-Klausel</title>
        <para>Die <database>DROP CONSTRAINT</database>-Klausel löscht die angegebene Spalten- 
        oder Tabellenebenenbeschränkung.</para>
        <para>Eine <database>PRIMARY KEY</database>- oder <database>UNIQUE</database>-Beschränkung kann nicht gelöscht werden, 
        wenn sie in einer anderen Tabelle durch eine <database>FOREIGN KEY</database>-Constraint referenziert wird. 
        Es ist notwendig, die <database>FOREIGN KEY</database>-Beschränkung zu löschen, bevor Sie versuchen, die 
        hierauf verweisenden <database>PRIMARY KEY</database>-Constraints oder <database>UNIQUE</database>-Constraints zu 
        löschen.</para>
        <formalpara>
          <title>Auswirkung auf Versionszähler</title>
          <para> Das Löschen einer Spaltenbeschränkung oder einer Tabellenbeschränkung erhöht den Metadatenänderungszähler nicht.</para>
        </formalpara>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrcol-de">
        <title>Die <database>ALTER [COLUMN]</database>-Klausel</title>
        <para>Mit der <database>ALTER [COLUMN]</database>-Klausel können Attribute bestehender Spalten geändert 
        werden, ohne dass die Spalte gelöscht oder neu hinzugefügt werden muss. Erlaubte Änderungen sind:
          <itemizedlist>
            <listitem>Ändern des Namens (wirkt sich nicht auf den Metadatenversionszähler aus)</listitem>
            <listitem>Ändern des Datentyps (erhöht den Metadatenversionszähler um eins)</listitem>
            <listitem>Ändern der Spaltenposition in der Spaltenliste der Tabelle (wirkt sich nicht auf den Metadatenversionszähler aus)</listitem>
            <listitem>Löschen des Standardspaltenwert (wirkt sich nicht auf den Metadatenversionszähler aus)</listitem>
            <listitem>Festlegen des Standardspaltenwertes oder den vorhandenen Standardwert ändern (hat keinen Einfluss auf den Metadatenversionszähler)</listitem>
            <listitem>Ändern des Typs und des Ausdrucks für eine berechnete Spalte (wirkt sich nicht auf den Metadatenversionszähler aus)</listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrto-de">
        <title>Umbenennen einer Spalte: das <database>TO</database>-Schlüsselwort</title>
        <para>Das TO-Schlüsselwort mit einer neuen Kennung benennt eine vorhandene Spalte um. Die Tabelle darf keine existierende 
            Spalte haben, die den gleichen Bezeichner hat.</para>
        <para>Es ist nicht möglich, den Namen einer Spalte zu ändern, die in einer Einschränkung enthalten ist:
        <database>PRIMARY KEY</database>, <database>UNIQUE</database>-Schlüssel, <database>FOREIGN KEY</database>, Spaltenbeschränkung
        oder der <database>CHECK</database>-Constraint einer Tabelle.</para>
        <para>Das Umbenennen einer Spalte ist ebenfalls nicht zulässig, wenn die Spalte in einem Trigger, einer gespeicherten Prozedur 
            oder einer Ansicht (View) verwendet wird.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrtyp-de">
        <title>Ändern des Datentyps einer Spalte: Das <database>TYPE</database>-Schlüsselwort</title>
        <para>Das Schlüsselwort <database>TYPE</database> ändert den Datentyp einer vorhandenen Spalte 
        in einen anderen, zulässigen Typ. Eine Typänderung, die zu einem Datenverlust führen kann, wird nicht 
        zugelassen. Beispielsweise kann die Anzahl der Zeichen im neuen Typ für eine <database>CHAR</database>- 
        oder <database>VARCHAR</database>-Spalte nicht kleiner sein als die bestehende Spezifikation dafür.</para>
        <para>Wenn die Spalte als Array deklariert wurde, ist keine Änderung des Typs oder der Anzahl 
            der Dimensionen zulässig.</para>
        <para>Der Datentyp einer Spalte, die an einem Fremdschlüssel, einem Primärschlüssel oder einer eindeutigen
            Einschränkung beteiligt ist, kann überhaupt nicht geändert werden.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrpos-de">
        <title>Ändern der Position einer Spalte: Das <database>POSITION</database>-Schlüsselwort</title>
        <para>Das POSITION-Schlüsselwort ändert die Position einer vorhandenen Spalte im fiktiven 
            <quote>von links nach rechts</quote>-Layout des Datensatzes.</para>
        <para>Die Nummerierung der Spaltenpositionen beginnt bei 1.
          <itemizedlist spacing="compact">
            <listitem>Wenn eine Position kleiner als 1 angegeben ist, wird eine Fehlermeldung zurückgegeben</listitem>
            <listitem>Wenn eine Positionsnummer größer als die Anzahl der Spalten in der Tabelle ist, wird die neue Position 
                automatisch an die Anzahl der Spalten angepasst.</listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="fblangref25-ddl-tbl-altrdefault-de">
        <title>Die <database>DROP DEFAULT</database>- und <database>SET DEFAULT</database>-Klauseln</title>
        <para>Die optionale <database>DROP DEFAULT</database>-Klausel löscht den Standardwert für die Spalte, 
        wenn sie zuvor durch eine CREATE TABLE- oder ALTER TABLE-Anweisung dort gesetzt wurde.
          <itemizedlist>
            <listitem>Wenn die Spalte auf einer Domäne mit einem Standardwert basiert, wird der Standardwert 
                auf die Standarddomain zurückgesetzt</listitem>
            <listitem>Ein Ausführungsfehler wird ausgelöst, wenn versucht wird, den Standardwert einer Spalte zu löschen, 
                die keinen Standardwert hat oder deren Standardwert Domain-basiert ist</listitem>
          </itemizedlist>
        </para>
        <para>Die optionale <database>SET DEFAULT</database>-Klausel setzt einen Standardwert für die Spalte. 
        Wenn die Spalte bereits einen Standardwert hat, wird sie durch die neue ersetzt. Der Standardwert, der auf 
        eine Spalte angewendet wird, überschreibt immer einen von einer Domain geerbten Wert.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altrcmptd-de">
        <title>Die <database>COMPUTED [BY]</database>- oder <database>GENERATED ALWAYS AS</database>-Klauseln</title>
        <para>Der Datentyp und der Ausdruck, die einer berechneten Spalte zugrunde liegen, können mit der
        <database>ALTER TABLE ALTER [COLUMN]</database>-Anweisung angepasst werden. Die Umwandlung einer 
        regulären Spalte in eine berechnete und umgekehrt ist nicht zulässig.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altrtblnogo-de">
        <title>Attribute, die nicht geändert werden können</title>
        <para>Folgende Änderungen werden nicht unterstützt:
          <itemizedlist spacing="compact">
            <listitem>Aktivieren oder Deaktivieren der Einschränkung <database>NOT NULL</database> für eine Spalte</listitem>
            <listitem>Ändern der Standardkollation für eine Zeichentypspalte</listitem>
          </itemizedlist>
        </para>
      </section>

      <para>Nur der Tabelleneigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link> haben 
      die Berechtigung für <database>ALTER TABLE</database>.</para>

      <section id="fblangref25-ddl-tbl-altrtblexmpls-de">
        <title>Beispiele für die Verwendung von <database>ALTER TABLE</database></title>
        <orderedlist>
          <listitem>Hinzufügen der Spalte CAPITAL zur Tabelle COUNTRY.
            <programlisting>
ALTER TABLE COUNTRY
ADD CAPITAL VARCHAR(25);
            </programlisting>
          </listitem>
          <listitem>Hinzufügen der CAPITAL-Spalte mit der UNIQUE-Einschränkung und Löschen der CURRENCY-Spalte.
            <programlisting>
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25) NOT NULL UNIQUE,
  DROP CURRENCY;
            </programlisting>
          </listitem>
          <listitem>Hinzufügen der CHK_SALARY-Prüfbedingung und eines Fremdschlüssels zur JOB-Tabelle.
            <programlisting>
ALTER TABLE JOB
ADD CONSTRAINT CHK_SALARY CHECK (MIN_SALARY &lt; MAX_SALARY),
ADD FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY);
            </programlisting>
          </listitem>
          <listitem>Festlegen des Standardwerts für das Feld MODEL, Ändern des Typs der ITEMID-Spalte 
              und umbenennen der Spalte MODELNAME.
            <programlisting>
ALTER TABLE STOCK
ALTER COLUMN MODEL SET DEFAULT 1,
ALTER COLUMN ITEMID TYPE BIGINT,
ALTER COLUMN MODELNAME TO NAME;
            </programlisting>
          </listitem>
          <listitem>Ändern der berechneten Spalten NEW_SALARY und SALARY_CHANGE.
            <programlisting>
ALTER TABLE SALARY_HISTORY
ALTER NEW_SALARY GENERATED ALWAYS AS 
  (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
ALTER SALARY_CHANGE COMPUTED BY 
  (OLD_SALARY * PERCENT_CHANGE / 100);
            </programlisting>
          </listitem>
        </orderedlist>
      </section>

      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-tbl-create-de"><database>CREATE TABLE</database></link>,
               <link linkend="fblangref25-ddl-tbl-drop-de"><database>DROP TABLE</database></link>,
               <link linkend="fblangref25-ddl-domn-create-de"><database>CREATE DOMAIN</database></link>
        </para>
      </formalpara>
    </section> <!-- alter table -->

    <section id="fblangref25-ddl-tbl-drop-de">
      <title><database>DROP TABLE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Löschen einer Tabelle</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
drop table <replaceable>tablename</replaceable>;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-droptbl-de">
      <?dbfo keep-together='auto'?>
        <title>DROP TABLE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name (Kennung) der Tabelle</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP TABLE</database> löscht eine vorhandene Tabelle. 
      Wenn die Tabelle Abhängigkeiten hat, schlägt die Anweisung <database>DROP TABLE</database> mit 
      einem Ausführungsfehler fehl.</para>
      <para> Wenn eine Tabelle gelöscht wird, werden auch alle Trigger für ihre Ereignisse und Indizes, die für 
          ihre Felder erstellt wurden, gelöscht.</para>

      <para>Nur der Tabelleneigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link> 
      haben die Berechtigung, <database>DROP TABLE</database> zu verwenden.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>Die Tabelle COUNTRY löschen.
          <blockquote><programlisting>
DROP TABLE COUNTRY;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-tbl-create-de"><database>CREATE TABLE</database></link>,
               <link linkend="fblangref25-ddl-tbl-alter-de"><database>ALTER TABLE</database></link>,
               <link linkend="fblangref25-ddl-tbl-recreate-de"><database>RECREATE TABLE</database></link>
        </para>
      </formalpara>
    </section> <!-- drop table -->

    <section id="fblangref25-ddl-tbl-recreate-de">
      <title><database>RECREATE TABLE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen Tabelle (Relation) oder Wiederherstellen einer bestehenden</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE [GLOBAL TEMPORARY] TABLE <replaceable>tablename</replaceable>
  [EXTERNAL [FILE] '&lt;filespec&gt;']
  (&lt;col_def&gt; [, {&lt;col_def&gt; | &lt;tconstraint&gt;} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
        </programlisting></blockquote>
      </formalpara>
      <para>Vergleichen Sie den <link linkend="fblangref25-ddl-tbl-create-de"><database>CREATE TABLE</database>-
      Abschnitt</link> für die vollständige Syntax für <database>CREATE TABLE</database> und beachten Sie die Beschreibungen zum
      Definieren von Tabellen, Spalten und Constraints.</para>

      <para><database>RECREATE TABLE</database> erstellt eine Tabelle neu oder erneut. Wenn bereits eine Tabelle 
      mit diesem Namen vorhanden ist, versucht die Anweisung <database>RECREATE TABLE</database>, diese zu löschen und 
      eine neue zu erstellen. Bestehende Abhängigkeiten verhindern die Ausführung der Anweisung.</para>
      <formalpara>
        <title>Beispiel</title>
        <para> Erstellen oder Wiederherstellen der Tabelle COUNTRY.
          <blockquote><programlisting>
RECREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-tbl-create-de"><database>CREATE TABLE</database></link>,
        <link linkend="fblangref25-ddl-tbl-drop-de"><database>DROP TABLE</database></link>
        </para>
      </formalpara>
    </section><!-- recreate table -->
  </section><!-- TABLE -->

  <section id="fblangref25-ddl-idx-de">
    <title><database>INDEX</database></title>
    <para>Ein Index ist ein Datenbankobjekt, das für eine schnellere Datenabfrage aus einer Tabelle 
        oder zur Beschleunigung der Sortierung der Abfrage verwendet wird. Indizes werden auch verwendet, 
        um die referenziellen Integritätsbedingungen <database>PRIMARY KEY</database>, <database>FOREIGN KEY</database> 
        und <database>UNIQUE</database> sicherzustellen.
    </para>
       <para> In diesem Abschnitt wird beschrieben, wie Sie Indizes erstellen, aktivieren und deaktivieren, 
           löschen und Statistiken sammeln (Selektivität neu berechnen).</para>
    <section id="fblangref25-ddl-idx-create-de">
      <title><database>CREATE INDEX</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Einen Index für eine Tabelle erstellen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]]
INDEX indexname ON tablename
{(col [, col &hellip;]) | COMPUTED BY (&lt;expression&gt;)};
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-idx-createidx-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE INDEX Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Indexname. Es kann aus bis zu 31 Zeichen bestehen</entry>
            </row>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Der Name der Tabelle, für die der Index erstellt werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Name einer Spalte in der Tabelle. Spalten der Typen BLOB sowie ARRAY 
                  und berechnete Felder können nicht in einem Index verwendet werden</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Der Ausdruck, der die Werte für einen berechneten Index berechnet, 
                  auch bekannt als <quote>Ausdrucksindex</quote>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE INDEX</database> erstellt einen Index für eine Tabelle, mit 
      der das Suchen, Sortieren und Gruppieren beschleunigt werden kann. Indizes werden automatisch beim 
      Definieren von Constraints wie Primärschlüssel, Fremdschlüssel oder eindeutigen Constraints erstellt.</para>
       <para>Ein Index kann auf den Inhalt von Spalten eines beliebigen Datentyps mit Ausnahme von <database>BLOB</database> und 
       Arrays aufgebaut werden. Der Name (Bezeichner) eines Index muss unter allen Indexnamen eindeutig sein.</para>
      <note>
        <title>Schlüssel-Indizes</title>
        <para>Wenn ein Primärschlüssel, ein Fremdschlüssel oder eine eindeutige Einschränkung zu einer Tabelle 
            oder Spalte hinzugefügt wird, wird automatisch ein Index mit demselben Namen erstellt, ohne 
            explizite Anweisung vom Designer. Beispielsweise wird der PK_COUNTRY-Index automatisch 
            erstellt, wenn Sie die folgende Anweisung ausführen und übergeben:
          <blockquote><literallayout class="monospaced">
ALTER TABLE COUNTRY ADD CONSTRAINT PK_COUNTRY
	PRIMARY KEY (ID);
          </literallayout></blockquote>
        </para>
      </note>
      <section id="fblangref25-ddl-idx-uq-de">
        <title>Unique-Indizes</title>
        <para>Wenn Sie in der Indexerstellungsanweisung das Schlüsselwort <database>UNIQUE</database> angeben, 
        wird ein Index erstellt, in dem die Eindeutigkeit in der gesamten Tabelle durchgesetzt wird. Der Index 
        wird als <quote>eindeutiger Index</quote> bezeichnet. Ein eindeutiger Index ist keine Einschränkung.</para>
        <para>Eindeutige Indizes dürfen keine doppelten Schlüsselwerte (oder Duplikatschlüsselwertkombinationen im 
            Falle von <emphasis>berechnet</emphasis> Indizes oder multi-column oder multi-segment) enthalten. 
            Duplizierte <database>NULL</database>s sind gemäß dem SQL: 99-Standard sowohl in Indizes mit 
            einem einzelnen Segment als auch mit mehreren Segmenten zulässig.</para>
      </section>

      <section id="fblangref25-ddl-idx-drctn-de">
        <title>Index-Sortierung</title>
        <para>Alle Indizes in Firebird sind unidirektional. Ein Index kann vom niedrigsten Wert zum höchsten (aufsteigend) 
            oder vom höchsten zum niedrigsten (absteigend) erstellt werden. Die Schlüsselwörter <database>ASC [ENDING]</database> und 
            <database>DESC [ENDING]</database> werden verwendet, um die Richtung des Index anzugeben. Die Standardindexreihenfolge 
            ist <database>ASC [ENDING]</database>. Es ist durchaus sinnvoll, sowohl einen auf- als auch einen absteigenden 
            Index für dieselbe Spalte oder denselben Schlüsselsatz zu definieren.</para>
        <tip>
          <para>Ein absteigender Index kann für eine Spalte nützlich sein, die Suchanfragen auf den hohen Werten unterzogen 
              wird (<quote>neuestes</quote>, Maximum usw.)</para>
        </tip>
      </section>    

      <section id="fblangref25-ddl-idx-exprssn-de">
        <title>Berechnete (Ausdrucks-) Indizes</title>
        <para>Beim Erstellen eines Index können Sie die <database>COMPUTED BY</database> -Klausel verwenden, um anstelle 
        einer oder mehrerer Spalten einen Ausdruck anzugeben. Berechnete Indizes werden in Abfragen verwendet, bei denen 
        die Bedingung in einer <database>WHERE</database>, <database>ORDER BY</database> oder <database>GROUP BY</database>-Klausel 
        exakt dem Ausdruck in der Indexdefinition entspricht. Der Ausdruck in einem berechneten Index kann mehrere Spalten in der Tabelle enthalten.
          <note>
            <para>Sie können tatsächlich einen berechneten Index für ein berechnetes Feld erstellen, der Index wird jedoch nie verwendet.</para>
          </note>
        </para>
      </section> <!-- computed indexes -->

      <section id="fblangref25-ddl-idx-limits-de">
        <title>Indexgrenzen</title>
        <para>Bestimmte Beschränkungen gelten für Indizes.</para>
        <para>Die maximale Länge eines Schlüssels in einem Index ist auf &frac14; der Seitengröße.</para>

        <section id="fblangref25-ddl-idx-maxno-de">
          <title>Maximale Anzahl Indizes pro Tabelle</title>
          <para>Die Anzahl der Indizes, die für jede Tabelle untergebracht werden können, ist begrenzt. 
              Das tatsächliche Maximum für eine bestimmte Tabelle hängt von der Seitengröße und 
              der Anzahl der Spalten in den Indizes ab.</para>

          <table id="fblangref25-ddl-idx-idxpertbl-de">
          <?dbfo keep-together='auto'?>
            <title>Maximale Anzahl Indizes pro Tabelle</title>
            <tgroup cols="4">
              <colspec colname="colPgsize" colwidth="*"></colspec>
              <colspec colname="col1Col" colwidth="*"></colspec>
              <colspec colname="col2Col" colwidth="*"></colspec>
              <colspec colname="col3Col" colwidth="*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center" morerows="1">Seitengröße</entry>
                  <entry align="center" nameend="col3Col" namest="col1Col">Anzahl der Indizes in Abhängigkeit 
                      von der Spaltenanzahl</entry>
                </row>
                <row>
                  <entry align="center">einspaltig</entry>
                  <entry align="center">zweispaltig</entry>
                  <entry align="center">dreispaltig</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center">4096</entry>
                  <entry align="center">203</entry>
                  <entry align="center">145</entry>
                  <entry align="center">113</entry>
                </row>
                <row valign="middle">
                  <entry align="center">8192</entry>
                  <entry align="center">408</entry>
                  <entry align="center">291</entry>
                  <entry align="center">227</entry>
                </row>
                <row valign="middle">
                  <entry align="center">16384</entry>
                  <entry align="center">818</entry>
                  <entry align="center">584</entry>
                  <entry align="center">454</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section id="fblangref25-ddl-idx-maxstrnglgth-de">
          <title>Zeichenindexgrenzen</title>
          <para>Die maximale Länge der indizierten Zeichenfolgen beträgt 9 Byte weniger 
              als die maximale Schlüssellänge. Die maximale indexierbare Zeichenfolgenlänge 
              hängt von der Seitengröße und dem Zeichensatz ab.</para>
          <table id="fblangref25-ddl-idx-idxstrnglgth-de">
          <?dbfo keep-together='auto'?>
            <title>Maximale indizierbare (VAR)CHAR-Länge</title>
            <tgroup cols="5">
              <colspec colname="colPgsize" colwidth="*"></colspec>
              <colspec colname="col1B" colwidth="*"></colspec>
              <colspec colname="col2B" colwidth="*"></colspec>
              <colspec colname="col3B" colwidth="*"></colspec>
              <colspec colname="col4B" colwidth="*"></colspec>
              <spanspec spanname="4cols" namest="col1B" nameend="col4B"></spanspec>
              <thead>
                <row valign="middle">
                  <entry align="center" morerows="1">Seitengröße</entry>
                  <entry align="center" spanname="4cols">Maximale indexierbare Zeichenfolgenlänge nach Zeichensatz</entry>
                </row>
                <row>
                  <entry align="center">1 Byte/Zeichen</entry>
                  <entry align="center">2 Bytes/Zeichen</entry>
                  <entry align="center">3 Bytes/Zeichen</entry>
                  <entry align="center">4 Bytes/Zeichen</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center">4096</entry>
                  <entry align="center">1015</entry>
                  <entry align="center">507</entry>
                  <entry align="center">338</entry>
                  <entry align="center">253</entry>
                </row>
                <row valign="middle">
                  <entry align="center">8192</entry>
                  <entry align="center">2039</entry>
                  <entry align="center">1019</entry>
                  <entry align="center">679</entry>
                  <entry align="center">509</entry>
                </row>
                <row valign="middle">
                  <entry align="center">16384</entry>
                  <entry align="center">4087</entry>
                  <entry align="center">2043</entry>
                  <entry align="center">1362</entry>
                  <entry align="center">1021</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section> <!-- Index limits -->


      <para>Nur der Tabelleneigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      besitzen die notwendigen Rechte für die Verwendung von <database>CREATE INDEX</database>.</para>

      <section id="fblangref25-ddl-tbl-crtidxexmpls-de">
        <title>Beispiel für die Verwendung von <database>CREATE INDEX</database></title>
        <orderedlist>
          <listitem>Erstellen eines Index für die UPDATER_ID in der Tabelle SALARY_HISTORY
            <programlisting>
CREATE INDEX IDX_UPDATER
    ON SALARY_HISTORY (UPDATER_ID);
            </programlisting>
          </listitem>
          <listitem>Erstellen eines Index mit Schlüsseln in absteigender Reihenfolge für die
           CHANGE_DATE-Spalte in der Tabelle SALARY_HISTORY.
            <programlisting>
CREATE DESCENDING INDEX IDX_CHANGE
   ON SALARY_HISTORY (CHANGE_DATE);
            </programlisting>
          </listitem>
          <listitem>Erstellen eines Multisegment-Index für die Spalten ORDER_STATUS sowie PAID in der Tabelle SALES
            <programlisting>
CREATE INDEX IDX_SALESTAT
    ON SALES (ORDER_STATUS, PAID);
            </programlisting>
          </listitem>
          <listitem>Erstellen eines Index, der keine doppelten Werte für die Spalte NAME in der Tabelle COUNTRY zulässt
            <programlisting>
CREATE UNIQUE INDEX UNQ_COUNTRY_NAME
    ON COUNTRY (NAME);
            </programlisting>
          </listitem>
          <listitem>Erstellen eines berechneten Index für die PERSONS-Tabelle
            <programlisting>
CREATE INDEX IDX_NAME_UPPER ON PERSONS
    COMPUTED BY (UPPER (NAME));
            </programlisting>
          Ein solcher Index kann für eine Groß- / Kleinschreibungs-sensitive Suche verwendet werden:
            <programlisting>
SELECT *
    FROM PERSONS
    WHERE UPPER(NAME) STARTING WITH UPPER('Iv');
            </programlisting>
          </listitem>
        </orderedlist>
      </section> <!-- index examples -->

      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-idx-altridx-de"><database>ALTER INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-dropidx-de"><database>DROP INDEX</database></link>
        </para>
      </formalpara>
    </section> <!-- create index -->

    <section id="fblangref25-ddl-idx-altridx-de">
      <title><database>ALTER INDEX</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Aktivieren oder Deaktivieren eines Indexes; einen Index neu aufbauen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER INDEX indexname {ACTIVE | INACTIVE};
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-idx-alteridx-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER INDEX Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Indexname</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die <database>ALTER INDEX</database>-Anweisung aktiviert oder deaktiviert 
      einen Index. In dieser Anweisung gibt es keine Möglichkeit, Attribute des Index zu ändern.
        <itemizedlist>
          <listitem>
            <para>Mit der Option <database>INACTIVE</database> wird der Index vom aktiven in den 
                inaktiven Zustand geschaltet. Der Effekt ähnelt der Anweisung <database>DROP INDEX</database>, 
                mit der Ausnahme, dass die Indexdefinition in der Datenbank verbleibt. Das Ändern eines 
                Beschränkungsindex in den inaktiven Zustand ist nicht zulässig.</para>
            <para>Ein aktiver Index kann deaktiviert werden, wenn keine Abfragen mit diesem Index vorhanden sind. 
                Andernfalls wird ein <quote>Objekt in Verwendung</quote>-Fehler zurückgegeben.</para>
            <para>Die Aktivierung eines inaktiven Index ist ebenfalls sicher. Wenn jedoch aktive Transaktionen die 
                Tabelle ändern, schlägt die Transaktion mit der Anweisung <database>ALTER INDEX</database> fehl, 
                wenn das Attribut <database>NOWAIT</database> vorhanden ist. Wenn sich die Transaktion im 
                Modus <database>WAIT</database> befindet, wartet sie auf den Abschluss der gleichzeitigen Transaktionen.</para>
            <para>Auf der anderen Seite der Münze werden andere Transaktionen, die diese Tabelle modifizieren den 
                Index nach einem <database>COMMIT</database> neu erstellen oder fehlschlagen 
                je nach Status der <database>WAIT / NO WAIT</database>-Attribute. Die Situation ist genau 
                dieselbe für <database>CREATE INDEX</database>.</para>
            <note>
              <title>Wie sinnvoll ist dies?</title>
              <para>Es kann sinnvoll sein, einen Index in den inaktiven Zustand zu wechseln, während Sie einen großen Stapel von 
                  Datensätzen in der Tabelle, in der sich der Index befindet, einfügen, aktualisieren oder löschen.</para>
            </note>
          </listitem>

          <listitem>Wenn sich der Index im Status INAKTIV befindet, wird es mit der Option ACTIVE in den aktiven Status 
              umgeschaltet, und das System erstellt den Index neu.
            <note>
              <title>Wie sinnvoll ist dies?</title>
              <para>Auch wenn der Index <emphasis>active</emphasis> ist, wenn <database>ALTER INDEX ... ACTIVE</database> 
              ausgeführt wird, wird der Index neu erstellt. Die Wiederherstellung von Indizes kann eine nützliche Haushaltshilfe 
              sein, gelegentlich auch für die Indizes einer großen Tabelle in einer Datenbank, die häufige Neuaufnahmen 
              Aktualisierungen oder Löschungen aufweist, aber selten wiederhergestellt wird.</para>
            </note>
          </listitem>
        </itemizedlist>
      </para>

      <section id="fblangref25-ddl-idx-altrcnstrntidx-de">
        <title>Verwendung von <database>ALTER INDEX</database> in einem Constraint-Index</title>
        <para>Das Ändern des Erzwingungsindex für eine <database>PRIMARY KEY, FOREIGN KEY</database>- oder
        <database>UNIQUE</database>-Einschränkung auf <database>INACTIVE</database> ist nicht zulässig.
        der  oder <database>UNIQUE</database> ist nicht zulässig. 
        Jedoch funktionert <database>ALTER INDEX ... ACTIVE</database> genauso gut wie andere als Indexwiederherstellungstool.</para>
      </section>

      <para>Nur der Tabelleneigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link>
        haben die Berechtigungen für die Anweisung <database>ALTER INDEX</database>.</para>

      <formalpara>
        <title>Beispiele für ALTER INDEX</title>
        <orderedlist>
          <listitem>Deaktivieren des IDX_UPDATER-Index
            <programlisting>
ALTER INDEX IDX_UPDATER INACTIVE;
            </programlisting>
          </listitem>
          <listitem>Den IDX_UPDATER-Index in den aktiven Zustand zurückschalten und neu erstellen
            <programlisting>
ALTER INDEX IDX_UPDATER ACTIVE;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-idx-create-de"><database>CREATE INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-dropidx-de"><database>DROP INDEX</database></link>,
        <database>SET STATISTICS</database>
        </para>
      </formalpara>
    </section> <!-- Alter index -->

    <section id="fblangref25-ddl-idx-dropidx-de">
      <title><database>DROP INDEX</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Deleting an index</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP INDEX indexname;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-idx-dropidx">
      <?dbfo keep-together='auto'?>
        <title>DROP INDEX Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Indexname</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Das Statement <database>DROP INDEX</database> löscht den angegebenen Index aus der Datenbank.
        <note>
          <para>Ein Constraint-Index kann nicht mittels <database>DROP INDEX</database> gelöscht werden.
          Constraint-Indizes werden während des Ausführens des Befehls 
          <database>ALTER TABLE ... DROP CONSTRAINT ...</database> gelöscht.</para>
        </note>
      </para>

      <para>Nur die Tabelleneigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      besitzen die Berechtigungen die Anweisung <database>DROP INDEX</database> auszuführen.</para>

      <formalpara>
        <title>DROP INDEX Example</title>
        <para> Löschen des Index IDX_UPDATER
          <blockquote><programlisting>
DROP INDEX IDX_UPDATER;
           </programlisting></blockquote>
         </para>
       </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-idx-create-de"><database>CREATE INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-altridx-de"><database>ALTER INDEX</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop index -->

    <section id="fblangref25-ddl-idx-setsttstcs-de">
      <title><database>SET STATISTICS</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Neuberechnung der Selektivität eines Index</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
SET STATISTICS indexname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-idx-setsttstcs-de">
      <?dbfo keep-together='auto'?>
        <title>SET STATISTICS Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Indexname</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>SET STATISTICS</database> berechnet die Selektivität des angegebenen 
      Index neu.</para>
      <section id="fblangref25-ddl-idx-selectivity-de">
        <title>Index-Selektivität</title>
        <para>Die Selektivität eines Index ergibt sich aus der Auswertung der Anzahl der Zeilen, die 
            bei einer Suche für jeden Indexwert ausgewählt werden können. Ein eindeutiger Index hat 
            die maximale Selektivität, da es nicht möglich ist, mehr als eine Zeile für jeden Wert 
            eines Indexschlüssels auszuwählen, wenn dieser verwendet wird. Die Selektivität eines Index 
            auf dem neuesten Stand zu halten ist wichtig für die Wahl des Optimierers bei der Suche nach 
            dem optimalen Abfrageplan.</para>
        <para>Indexstatistiken in Firebird werden nicht automatisch als Reaktion auf große Stapel von Neuaufnahmen, 
            Aktualisierungen oder Löschungen neu berechnet. Es kann vorteilhaft sein, die Selektivität eines Index 
            nach solchen Operationen neu zu berechnen, da die Selektivität dazu neigt, zu veralten.
          <note>
            <para>Die Anweisungen <database>CREATE INDEX</database> und <database>ALTER INDEX ACTIVE</database> 
            speichern beide Indexstatistiken, die vollständig dem Inhalt des (neu) erstellten Index entsprechen.</para>
          </note>
        </para>
      </section>

      <para>Die Selektivität eines Index kann vom Besitzer der Tabelle oder einem 
          <link linkend="fblangref25-security-administrators-de">Administrator</link> neu berechnet werden. 
          Es kann unter gleichzeitiger Belastung ohne Korruptionsrisiko durchgeführt werden. Beachten Sie jedoch, 
          dass die neu berechnete Statistik bei gleichzeitiger Auslastung veraltet sein kann, sobald 
          <database>SET STATISTICS</database> beendet ist.</para>

      <formalpara>
        <title>Beispiele für die Verwendung von SET STATISTICS</title>
        <para> Neuberechnung der Selektivität des Index IDX_UPDATER
          <blockquote><programlisting>
SET STATISTICS INDEX IDX_UPDATER;
           </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-idx-create-de"><database>CREATE INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-altridx-de"><database>ALTER INDEX</database></link>
        </para>
      </formalpara>
    </section> <!-- set statistics -->
  </section> <!-- INDEX -->

  <section id="fblangref25-ddl-view-de">
  <title><database>VIEW</database></title>
    <para>Eine Sicht (VIEW) ist eine virtuelle Tabelle, bei der es sich um eine gespeicherte und 
        benannte <database>SELECT</database>-Abfrage zum Abrufen von Daten beliebiger Komplexität
        handelt. Daten können aus einer oder mehreren Tabellen, aus anderen Ansichten und aus 
        ausgewählten gespeicherten Prozeduren abgerufen werden.</para>
    <para>Im Gegensatz zu regulären Tabellen in relationalen Datenbanken ist eine Sicht kein 
        unabhängiger Datensatz, der in der Datenbank gespeichert ist. Das Ergebnis wird dynamisch 
        als Datensatz erstellt, wenn die Ansicht ausgewählt wird.</para>
    <para>Die Metadaten einer Sicht sind für den Prozess verfügbar, der den Binärcode für gespeicherte 
        Prozeduren und Trigger generiert, so als wären es konkrete Tabellen, in denen persistente
        Daten gespeichert werden.</para>
    <section id="fblangref25-ddl-view-create-de">
      <title><database>CREATE VIEW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer View</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-view-createview-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE VIEW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">View-Name, maximal 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">Die Liste der Spalten in der View</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Spaltenname der View. Doppelte Spaltennamen sind nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE VIEW</database> erstellt eine neue View Der Bezeichner (Name) 
      einer View muss unter den Namen aller Ansichten, Tabellen und gespeicherten Prozeduren in der Datenbank 
      eindeutig sein. </para>
      <para> Dem Namen der neuen Sicht kann die Liste der Spaltennamen folgen, die beim Aufrufen der View an den 
          Aufrufer zurückgegeben werden sollen. Namen in der Liste müssen nicht mit den Namen der Spalten in den
          Basistabellen verknüpft sein, von denen sie abgeleitet werden.</para>
      <para>Wenn die Sichtspaltenliste ausgelassen wird, verwendet das System die Spaltennamen und / oder Aliase aus 
          der Anweisung <database>SELECT</database>. Wenn doppelte Namen oder nicht von Alias-Ausdrucken abgeleitete 
          Spalten das Erstellen einer gültigen Liste unmöglich machen, schlägt die Erstellung der View mit einem 
          Fehler fehl.</para>
      <para>Die Anzahl der Spalten in der Liste der Ansichten muss genau der Anzahl der Spalten in der Auswahlliste 
          der zugrunde liegenden SELECT-Anweisung in der Sichtdefinition entsprechen.</para>
      <note>
        <title>Zusätzliche Punkte</title>
        <itemizedlist>
          <listitem>Wenn die vollständige Liste der Spalten angegeben ist, ist es nicht sinnvoll, Aliase in der Anweisung 
              <database>SELECT</database> anzugeben, da die Namen in der Spaltenliste diese überschreiben</listitem>
          <listitem>Die Spaltenliste ist optional, wenn alle Spalten in <database>SELECT</database> explizit benannt 
          sind und in der Auswahlliste eindeutig sind</listitem>
        </itemizedlist>
      </note>
      <section id="fblangref25-ddl-view-create-updatable-de">
        <title>Aktualisierbare Views</title>
        <para>Eine View kann aktualisierbar oder schreibgeschützt sein. Wenn eine Sicht aktualisierbar ist, 
            können die beim Aufruf dieser Sicht abgerufenen Daten durch die DML-Anweisungen <database>INSERT</database>,
            <database>UPDATE</database>, <database>DELETE</database>, <database>UPDATE OR INSERT</database> oder 
            <database>MERGE</database>. Änderungen, die in einer aktualisierbaren View vorgenommen wurden, werden 
                auf die zugrunde liegenden Tabelle (n) angewendet.</para>
        <para>Eine Nur-Lese-Ansicht kann mit Hilfe von Triggern aktualisiert werden. Nachdem Trigger in einer Sicht definiert 
            wurden, werden Änderungen, die an sie gesendet wurden, niemals automatisch in die zugrunde liegende Tabelle 
            geschrieben, selbst wenn die Ansicht von vornherein aktualisiert werden konnte. Es liegt in der Verantwortung 
            des Programmierers, sicherzustellen, dass die Trigger die Basistabellen nach Bedarf aktualisieren (oder 
            löschen oder einfügen).</para>
        <para>Eine View wird automatisch aktualisiert, wenn alle der folgenden Bedingungen erfüllt sind:
          <itemizedlist>
            <listitem>Die <database>SELECT</database>-Anweisung fragt nur eine Tabelle oder eine 
            aktualisierbare Ansicht ab</listitem>
            <listitem>Die Anweisung <database>SELECT</database> ruft keine gespeicherten Prozeduren auf</listitem>
            <listitem>jede Spalte der Basistabelle (oder Basissicht), die in der Sichtdefinition nicht vorhanden ist, 
                wird durch eine der folgenden Bedingungen abgedeckt:
              <itemizedlist spacing="compact">
                <listitem>sie ist nullbar</listitem>
                <listitem>sie hat einen nicht-NULL Standardwert</listitem>
                <listitem>sie hat einen Trigger, der einen zulässigen Wert liefert</listitem>
              </itemizedlist>
            </listitem>
            <listitem>die Anweisung <database>SELECT</database> enthält keine Felder, die von Unterabfragen oder anderen 
            Ausdrücken abgeleitet wurden</listitem>
            <listitem>die <database>SELECT</database>-Anweisung enthält keine durch Aggregatfunktionen definierten Felder 
            wie <database>MIN</database>, <database>MAX</database>, <database>AVG</database>, <database>SUM</database>, 
            <database>COUNT</database>, <database>LIST</database></listitem>
           <listitem>Die <database>SELECT</database>-Anweisung enthält keine der Klauseln <database>ORDER BY</database> oder 
           <database>GROUP BY</database>
           </listitem>
           <listitem>Das <database>SELECT</database>-Statement enthält weder das Schlüsselwort <database>DISTINCT</database>
           noch zeilenbeschränkende Schlüsselwörter wie <database>ROWS</database>, <database>FIRST</database>,
           <database>SKIP</database></listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="fblangref25-ddl-view-create-chkopt-de">
        <title><database>WITH CHECK OPTION</database></title>
        <para>Die optionale Klausel <database>WITH CHECK OPTION</database> erfordert eine aktualisierbare 
        Sicht, um zu überprüfen, ob neue oder aktualisierte Daten die in der <database>WHERE</database>-Klausel 
        der <database>SELECT</database>. Jeder Versuch, einen neuen Datensatz einzufügen oder einen bestehenden 
        zu aktualisieren, wird überprüft, ob der neue oder aktualisierte Datensatz den Kriterien 
        aus <database>WHERE</database> entspricht. Wenn die Überprüfung fehlschlägt, wird die Operation nicht ausgeführt 
        und eine entsprechende Fehlermeldung wird zurückgegeben.</para>
        <para><database>WITH CHECK OPTION</database> kann nur in einer CREATE VIEW-Anweisung angegeben werden, in der 
        eine WHERE-Klausel vorhanden ist, um die Ausgabe der <database>SELECT</database>-Anweisung einzuschränken. 
        Eine Fehlermeldung wird ansonsten zurückgegeben.</para>

        <important>
         <title>Bitte beachten:</title>
         <para>Wenn <database>WITH CHECK OPTION</database> verwendet wird, prüft das Modul die 
         Eingabe für die <database>WHERE</database>-Klausel, bevor etwas an die Basisrelation 
         übergeben wird. Wenn die Überprüfung der Eingabe fehlschlägt, werden daher keine Standardklauseln 
         oder Trigger der Basisrelation, welche möglicherweise zur Korrektur der Eingaben erstellt wurden, 
         ausgeführt.</para>
         <para>Außerdem werden Sichtfelder, die in der Anweisung <database>INSERT</database> ausgelassen wurden, 
         unabhängig von ihrer Anwesenheit oder Abwesenheit in der <database>WHERE</database>-Klausel als 
         <database>NULL</database>s an die Basisrelation übergeben. Infolgedessen werden Basistabellenstandards, 
         die für solche Felder definiert sind, nicht angewendet. Auslöser dagegen werden wie erwartet feuern und arbeiten.
         </para>
         <para>Für Views, die <database>WITH CHECK OPTION</database> nicht enthalten, werden Felder, die in der Anweisung 
            <database>INSERT</database> fehlen, überhaupt nicht an die Basisrelation übergeben.</para>
       </important>
     </section>

      <section id="fblangref25-ddl-view-createwho-de">
        <title>Eigentümer einer View</title>
        <para>Der Ersteller einer Sicht wird zu seinem Besitzer.</para>
        <para>Um eine Sicht zu erstellen, benötigt ein Benutzer ohne Administratorrechte mindestens 
            <database>SELECT</database>-Zugriff auf die zugrunde liegenden Tabelle(n) und / oder Ansichten 
            und die Berechtigung <database>EXECUTE</database> auf abfragbare gespeicherte Prozeduren.</para>
        <para>Um Einfügungen, Aktualisierungen und Löschungen durch die Sicht zu ermöglichen, muss der 
            Ersteller / Eigentümer auch die entsprechenden Berechtigungen <database>INSERT</database>, 
            <database>UPDATE</database> und <database>DELETE</database> auf die zugrunde liegenden Objekt(e) besitzen.
        </para>
        <para>Das Freigeben anderer Benutzerprivilegien für die Sicht ist nur möglich, wenn der Sichtbesitzer selbst diese 
            Berechtigungen für die zugrunde liegenden Objekte <database>WITH GRANT OPTION</database> besitzt. 
            Dies ist immer dann der Fall, wenn der View-Besitzer auch Eigentümer der zugrunde liegenden Objekte ist.</para>
      </section>

      <formalpara>
        <title>Beispiele zum Erstellen von Views</title>
        <orderedlist>
          <listitem>Creating view returning the JOB_CODE and JOB_TITLE columns only for those jobs
          where MAX_SALARY is less than $15,000.
            <programlisting>
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY &lt; 15000;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Ansicht, die die Spalten JOB_CODE und JOB_TITLE nur 
              für diejenigen Jobs zurückgibt, bei denen MAX_SALARY weniger als 15.000 USD beträgt. 
              Immer wenn ein neuer Datensatz eingefügt oder ein vorhandener Datensatz aktualisiert 
              wird, wird der Wert MAX_SALARY &lt; 15000 Zustand wird überprüft. Wenn die Bedingung 
              nicht wahr ist, wird die Operation zum Einfügen / Aktualisieren zurückgewiesen.
            <programlisting>
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY &lt; 15000
WITH CHECK OPTION;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Ansicht mit einer expliziten Spaltenliste.
            <programlisting>
CREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1
FROM PRICE;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer View mit Hilfe von Aliasnamen für Felder in der 
              SELECT-Anweisung (das gleiche Ergebnis wie in Beispiel 3).
            <programlisting>
CREATE VIEW PRICE_WITH_MARKUP AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1 AS COST_WITH_MARKUP
FROM PRICE;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer schreibgeschützten Ansicht basierend auf zwei Tabellen 
              und einer gespeicherten Prozedur.
            <programlisting>
CREATE VIEW GOODS_PRICE AS
SELECT
    goods.name AS goodsname,
    price.cost AS cost,
    b.quantity AS quantity
FROM
    goods
    JOIN price ON goods.code_goods = price.code_goods
    LEFT JOIN sp_get_balance(goods.code_goods) b ON 1 = 1;
           </programlisting>
         </listitem>
       </orderedlist>
     </formalpara>
     <formalpara><title>Siehe auch</title>
       <para> <link linkend="fblangref25-ddl-view-alter-de"><database>ALTER VIEW</database></link>,
       <link linkend="fblangref25-ddl-view-crtoralter-de"><database>CREATE OR ALTER VIEW</database></link>,
       <link linkend="fblangref25-ddl-view-recreate-de"><database>RECREATE VIEW</database></link>,
       <link linkend="fblangref25-ddl-view-drop-de"><database>DROP VIEW</database></link>
       </para>
     </formalpara>
   </section> <!-- create view -->

   <section id="fblangref25-ddl-view-alter-de">
      <title><database>ALTER VIEW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Ändern einer existierenden View</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-view-alterview-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER VIEW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">Name einer existierenden View</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">Die Liste der Spalten in der View</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Spaltenname der View Doppelte Spaltennamen sind nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Verwenden Sie die Anweisung <database>ALTER VIEW</database>, um die Definition einer 
      vorhandenen View zu ändern. Berechtigungen für Ansichten bleiben erhalten und 
      Abhängigkeiten sind nicht betroffen.</para>

      <para>Die Syntax der Anweisung <database>ALTER VIEW</database> entspricht vollständig der von 
      <database>CREATE VIEW</database>.
        <caution>
          <para>Seien Sie vorsichtig, wenn Sie die Anzahl der Spalten in einer Ansicht ändern. 
              Vorhandener Anwendungscode und PSQL-Module, die auf die Sicht zugreifen, können ungültig werden. 
              Informationen zur Erkennung dieser Art von Problemen in gespeicherten Prozeduren und Triggern 
              finden Sie unter <link linkend="fblangref25-appx01-supp-rdb_validblr-de"> 
                  <citetitle>Das <database>RDB$VALID_BLR</database>-Feld</citetitle> 
             </link> im Anhang.</para>
        </caution>
      </para>

      <para>Nur der View-Eigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      besitzen die notwendigen Berechtigungen zum Ausführen von <database>ALTER VIEW</database>.</para>

      <formalpara>
        <title>Beispiele zur Verwendung von ALTER VIEW</title>
        <para>Ansicht ändern PRICE_WITH_MARKUP
          <blockquote><programlisting>
ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-view-create-de"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-crtoralter-de"><database>CREATE OR ALTER VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-recreate-de"><database>RECREATE VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- alter view -->

    <section id="fblangref25-ddl-view-crtoralter-de">
      <title><database>CREATE OR ALTER VIEW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Creating a new view or altering an existing view.</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-view-crtalterview-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE OR ALTER VIEW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">Name einer View, die vorhanden oder nicht vorhanden ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">Die Liste der Spalten in der View</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Spaltenname der View. Duplikate sind nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Verwenden Sie die Anweisung <database>CREATE OR ALTER VIEW</database>, um die Definition 
      einer vorhandenen Ansicht zu ändern oder sie zu erstellen, falls sie nicht existiert. Berechtigungen 
      für eine vorhandene Ansicht bleiben erhalten und Abhängigkeiten werden nicht beeinflusst.</para>
      <para>Die Syntax der Anweisung <database>CREATE OR ALTER VIEW</database> entspricht vollständig
      der von <database>CREATE VIEW</database>.</para>
      <formalpara>
        <title>Beispiel</title>
        <para> Erstellen Sie die Ansicht PRICE_WITH_MARKUP der neuen Ansicht oder ändern Sie sie, falls diese bereits vorhanden ist:
          <blockquote><programlisting>
CREATE OR ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-view-create-de"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-alter-de"><database>ALTER VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-recreate-de"><database>RECREATE VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- Create or alter view -->

    <section id="fblangref25-ddl-view-drop-de">
      <title><database>DROP VIEW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Löschen (dropping) einer View</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP VIEW viewname;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-view-dropview-de">
      <?dbfo keep-together='auto'?>
        <title>DROP VIEW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">View-Name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP VIEW</database> löscht eine existierende View.
            Die Anweisung wird fehlschlagen wenn die View Abhängigkeiten besitzt.</para>

      <para>Nur der Eigentümer der View und <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      besitzen die notwendigen Berechtigungen zum Ausführen von <database>DROP VIEW</database>.</para>
      <formalpara>
        <title>Beispiel</title>
        <para> Löschen der View PRICE_WITH_MARKUP.
          <blockquote><programlisting>
DROP VIEW PRICE_WITH_MARKUP;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-view-create-de"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-recreate-de"><database>RECREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-crtoralter-de"><database>CREATE OR ALTER VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop view -->

    <section id="fblangref25-ddl-view-recreate-de">
      <title><database>RECREATE VIEW</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen Ansicht oder Wiederherstellen einer vorhandenen View</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-view-recreate">
      <?dbfo keep-together='auto'?>
        <title>RECREATE VIEW Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">View-Name, maximal 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">Die Liste der Spalten in der View</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Spaltenname der View. Duplikate sind nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Erstellt oder erstellt eine Ansicht neu. Wenn bereits eine Ansicht mit diesem Namen vorhanden ist, 
          versucht die Engine, sie vor dem Erstellen der neuen Instanz zu löschen. Wenn die vorhandene Sicht 
          aufgrund von Abhängigkeiten oder unzureichenden Rechten nicht gelöscht werden kann, schlägt 
          <database>RECREATE VIEW</database> mit einem Fehler fehl.</para>
      <formalpara>
        <title>Beispiel</title>
        <para> Die neue View PRICE_WITH_MARKUP erstellen oder neu erstellen, falls diese bereits vorhanden ist.
          <blockquote><programlisting>
RECREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-view-create-de"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-drop-de"><database>DROP VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-crtoralter-de"><database>CREATE OR ALTER VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- Recreate view -->
  </section> <!--VIEW -->

  <section id="fblangref25-ddl-trgr-de">
    <title><database>TRIGGER</database></title>
    <para>Ein Trigger ist ein spezieller Typ einer gespeicherten Prozedur, der nicht direkt aufgerufen wird, 
        sondern ausgeführt wird, wenn ein bestimmtes Ereignis in der zugeordneten Tabelle oder Sicht (View) auftritt. 
        Ein Trigger ist spezifisch für eine und nur eine Relation (Tabelle oder View) und eine Phase im Timing des 
        Ereignisses (<emphasis>BEFORE</emphasis> oder <emphasis>AFTER</emphasis>). Es kann angegeben werden, 
        dass dieser für ein bestimmtes Ereignis (Einfügen, Aktualisieren, Löschen) oder für eine Kombination von zwei 
        oder drei dieser Ereignisse ausgeführt wird.</para>
    <para>Eine andere Form eines Triggers - bekannt als ein <quote>Datenbanktrigger</quote> - kann spezifiziert 
    werden, um in Verbindung mit dem Start oder dem Ende einer Benutzersitzung (Verbindung) oder einer 
    Benutzertransaktion zu ausgelöst zu werden.</para>
    <section id="fblangref25-ddl-trgr-create-de">
      <title><database>CREATE TRIGGER</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen eines neuen Triggers</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE TRIGGER trigname  {
  &lt;relation_trigger_legacy&gt; |
  &lt;relation_trigger_sql2003&gt; |
  &lt;database_trigger&gt; }
AS
	[&lt;declarations&gt;]
BEGIN
	[&lt;PSQL_statements&gt;]
END

&lt;relation_trigger_legacy&gt; ::=
  FOR {tablename | viewname}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} &lt;mutation_list&gt;
  [POSITION number]

&lt;relation_trigger_sql2003&gt; ::=
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} &lt;mutation_list&gt;
  [POSITION number]
  ON {tablename | viewname}

&lt;database_trigger&gt; ::=
  [ACTIVE | INACTIVE] ON db_event [POSITION number]

&lt;mutation_list&gt; ::=
  &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::= {
  CONNECT |
  DISCONNECT |
  TRANSACTION START |
  TRANSACTION COMMIT |
  TRANSACTION ROLLBACK
}

&lt;declarations&gt; ::= {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
  [{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-trgr-createtrigger-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE TRIGGER Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">trigname</entry>
              <entry align="left">Triggername bestehend aus bis zu 31 Zeichen. Dieser muss unter allen Triggernamen 
                  in der Datenbank eindeutig sein.</entry>
            </row>
            <row valign="middle">
              <entry align="center">relation_trigger_legacy</entry>
              <entry align="left">Legacy-Stil der Trigger-Deklaration für einen Relation-Trigger</entry>
            </row>
            <row valign="middle">
              <entry align="center">relation_trigger_sql2003</entry>
              <entry align="left">Relation-Trigger-Deklaration gemäß dem SQL: 2003-Standard</entry>
            </row>
            <row valign="middle">
              <entry align="center">database_trigger</entry>
              <entry align="left">Datenbank-Triggerdeklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name der Tabelle, der der Relationstrigger zugeordnet ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">Name der Sicht, der der Relationstrigger zugeordnet ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">mutation_list</entry>
              <entry align="left">Liste von Relationsereignissen (Tabelle | Ansicht)</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Position des Triggers in der Zündreihenfolge. Von 0 bis 32.767</entry>
            </row>
            <row valign="middle">
              <entry align="center">db_event</entry>
              <entry align="left">Verbindungs- oder Transaktionsereignis</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Lokale Variablendeklarieren</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Benannte Cursor-Deklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Anweisungen in der Programmiersprache von Firebird (PSQL)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE TRIGGER</database> dient zum Erstellen eines neuen Triggers. 
          Ein Trigger kann entweder für ein Ereignis <emphasis>Relation (Table | View)</emphasis> (oder eine 
          Kombination von Ereignissen) oder für ein <emphasis>Datenbankereignis</emphasis> erstellt 
          werden.</para>
      <para><database>CREATE TRIGGER</database>, zusammen mit den zugehörigen Assoziaten 
        <database>ALTER TRIGGER</database>, <database>CREATE ODER ALTER TRIGGER</database> und <database>RECREATE TRIGGER</database>, 
        ist eine <emphasis > zusammengesetzte Anweisung</emphasis>, bestehend aus einem Header und einem Rumpf. 
        Der Header spezifiziert den Namen des Triggers, den Namen der Relation (für einen Relations-Trigger), die Phase 
        des Triggers und das Ereignis, für das er gilt. Der Körper besteht aus optionalen Deklarationen von lokalen Variablen 
        und benannten Cursors, gefolgt von einer oder mehreren Anweisungen oder Anweisungsblöcken, die alle in einem äußeren 
        Block eingeschlossen sind, der mit dem Schlüsselwort <database>BEGIN</database> beginnt und mit dem Schlüsselwort 
            <database>END</database> endet. Deklarationen und eingebettete Anweisungen werden mit Semikolons 
            (<command>;</command>) abgeschlossen.</para>
      <para>Der Name des Triggers muss unter allen Triggernamen eindeutig sein.</para>
      
      <section id="fblangref25-ddl-terminators01-de">
        <title>Statement-Terminatoren</title>
        <para>Einige SQL-Anweisungseditoren - insbesondere das mit Firebird mitgelieferte Dienstprogramm 
            <emphasis>isql</emphasis> und möglicherweise einige Editoren von Drittanbietern - verwenden 
            eine interne Konvention, die erfordert, dass alle Anweisungen mit einem Semikolon abgeschlossen werden. 
            Dies führt bei der Codierung in diesen Umgebungen zu einem Konflikt mit der PSQL-Syntax. Wenn Sie mit 
            diesem Problem und seiner Lösung nicht vertraut sind, lesen Sie bitte die Details im Kapitel PSQL im Abschnitt 
            <link linkend="fblangref25-sidebar01-de"> Umschalten des Terminators in <emphasis>isql</emphasis></link>.
        </para>
      </section>

      <section id="fblangref25-ddl-trgr-relntrigger-de">
        <title>Relations-Trigger (auf Tabellen oder Views)</title>
        <para>Relation-Trigger werden jedes Mal auf der Zeilen- (Datensatz-) Ebene ausgeführt, wenn sich das Zeilenbild ändert. 
            Ein Trigger kann entweder <database>ACTIVE</database> oder <database>INACTIVE</database> sein. Nur aktive 
            Trigger werden ausgeführt. Trigger werden standardmäßig mit <database>ACTIVE</database> erstellt.</para>
        <section id="fblangref25-ddl-trgr-relntrigger-form-de">
          <title>Formen der Deklaration</title>
          <para>Firebird unterstützt zwei Arten der Deklaration für Relationstrigger:
          <itemizedlist spacing="compact">
            <listitem>Die ursprüngliche Legacy-Syntax</listitem>
            <listitem>Das standardmäßige SQL: 2003-Formular (empfohlen)</listitem>
          </itemizedlist>
          Das standardmäßige SQL: 2003-Formular ist das empfohlene Format.</para>
        </section>

        <para>Ein Relationstrigger spezifiziert unter anderem &lt; eine <emphasis>Phase</emphasis> und 
        ein oder mehrere <emphasis>Ereignisse</emphasis>.</para>

        <section id="fblangref25-ddl-trgr-relntrigger-rowphase-de">
          <title>Phase</title>
          <para>Die Phase betrifft das Timing des Triggers in Bezug auf das Zustandswechselereignis 
              in der Datenzeile:
            <itemizedlist spacing="compact">
              <listitem>Ein <database>BEFORE</database>-Trigger wird ausgelöst, bevor die angegebene Datenbankoperation 
              (Einfügen, Aktualisieren oder Löschen) ausgeführt wird.</listitem>
              <listitem>Ein <database>AFTER</database>-Trigger wird ausgeführt, nachdem die Datenbankoperation abgeschlossen
                wurde.</listitem>
            </itemizedlist>
          </para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-rowevent-de">
          <title>Zeilenereignisse</title>
          <para>Eine Relationstriggerdefinition gibt mindestens eine der DML-Operationen INSERT, 
              UPDATE und DELETE an, um ein oder mehrere Ereignisse anzuzeigen, auf die der Trigger 
              ausgelöst werden soll. Wenn mehrere Operationen angegeben werden, müssen sie durch 
              das Schlüsselwort <database>OR</database> getrennt werden. Keine Operation darf
                mehrmals auftreten.</para>
          <para>Innerhalb des Anweisungsblocks werden die Booleschen Kontextvariablen
          <link linkend="fblangref25-contextvars-inserting-de"><database>INSERTING</database></link>,
          <link linkend="fblangref25-contextvars-updating-de"><database>UPDATING</database></link> und
          <link linkend="fblangref25-contextvars-deleting-de"><database>DELETING</database></link>
          verwendet, um die Art der derzeit ausgeführten Operation zu prüfen.</para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-position-de">
          <title>Ausführungsreihenfolge von Triggern</title>
          <para>Das Schlüsselwort <database>POSITION</database> erlaubt es, eine optionale Ausführungsreihenfolge 
          (<quote>firing order</quote>) für eine Reihe von Triggern anzugeben, die dieselbe Phase und dasselbe 
          Ereignis wie ihr Ziel haben. Die Standardposition ist 0. Wenn keine Positionen angegeben werden oder 
          wenn mehrere Trigger eine einzelne Positionsnummer haben, werden die Trigger in der alphabetischen 
          Reihenfolge ihrer Namen ausgeführt.</para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-declrtns-de">
          <title>Variablendeklarationen</title>
          <para>Der optionale Deklarationsabschnitt unter dem Schlüsselwort <database>AS</database> im Header des 
          Triggers dient zum Definieren von Variablen und benannten Cursorn, die lokal zum Trigger gehören. Weitere Informationen 
          finden Sie unter <link linkend = "fblangref25-psql-declare-variable-de"> 
              <database>DECLARE VARIABLE</database></link> und <link linkend = "fblangref25-psql-declare-cursor-de"> 
              <database>DECLARE CURSOR</database></link> im Kapitel <link linkend = "fblangref25-psql-de"> Prozedurales SQL</link>.
          </para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-body-de">
          <title>Der Trigger-Body</title>
          <para>Die lokalen Deklarationen (falls vorhanden) sind der letzte Teil des Headerabschnitts eines Triggers. 
              Der Trigger-Body folgt, wobei ein oder mehrere Blöcke von PSQL-Anweisungen in einer Struktur eingeschlossen sind, 
              die mit dem Schlüsselwort <database>BEGIN</database> beginnt und mit dem Schlüsselwort 
              <database>END</database> endet.</para>
        </section>

        <para>Nur der Eigentümer der Sicht oder Tabelle und <link linkend="fblangref25-security-administrators-de">Administratoren</link> 
        haben die Berechtigung, <database>CREATE TRIGGER</database> zu verwenden.</para>

        <formalpara>
          <title>Beispiele für CREATE TRIGGER für Tabellen und Views</title>
          <orderedlist>
            <listitem>Erstellung eines Triggers in <quote>Legacy</quote>-Form. Wird vor dem Einfügen eines neuen Datensatzes 
            in die Tabelle CUSTOMER ausgelöst.
              <programlisting>
CREATE TRIGGER SET_CUST_NO FOR CUSTOMER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CUST_NO IS NULL) THEN
    NEW.CUST_NO = GEN_ID(CUST_NO_GEN, 1);
END
              </programlisting>
            </listitem>
            <listitem>Erstellen eines Triggers in SQL:2003-konformer Variante, der vor dem Einfügen eines neuen Datensatzes 
                in die Tabelle CUSTOMER ausgelöst wird.
              <programlisting>
CREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
              </programlisting>
            </listitem>
            <listitem>Einen Trigger erstellen, der nach dem Einfügen, Aktualisieren oder Löschen eines Datensatzes 
                in der Tabelle CUSTOMER ausgeführt wird.
              <programlisting>
CREATE TRIGGER TR_CUST_LOG
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
ON CUSTOMER
AS
BEGIN
  INSERT INTO CHANGE_LOG (LOG_ID,
                          ID_TABLE,
                          TABLE_NAME,
                          MUTATION)
  VALUES (NEXT VALUE FOR SEQ_CHANGE_LOG,
          OLD.CUST_NO,
          'CUSTOMER',
          CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING  THEN 'UPDATE'
            WHEN DELETING  THEN 'DELETE'
          END);
END
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
      </section><!-- Relation triggers -->

      <section id="fblangref25-ddl-trgr-dbtrigger-de">
        <title>Datenbank-Trigger</title>
        <para>Trigger können definiert werden, um auf <quote>Datenbankereignisse</quote> zu reagieren. Dies 
        können verschiedene Ereignisse sein. Diese können auf den Umfang einer Sitzung (Verbindung) 
        hinweg agieren, aber auch über die Umgebung einer Transaktion wirken:
          <blockquote><itemizedlist spacing="compact">
            <listitem>CONNECT</listitem>
            <listitem>DISCONNECT</listitem>
            <listitem>TRANSACTION START</listitem>
            <listitem>TRANSACTION COMMIT</listitem>
            <listitem>TRANSACTION ROLLBACK</listitem>
          </itemizedlist></blockquote>
        </para>

        <section id="fblangref25-ddl-trgr-dbtrigger-exec-de">
          <title>Ausführung von Datenbanktriggern und Fehlerbehandlung</title>
          <para><database>CONNECT</database>- und <database>DISCONNECT</database>-Trigger
          werden in einer speziell für diesen Zweck erstellten Transaktion ausgeführt.
          Läuft alles glatt, wird die Transaktion committed. 
          Nicht abgefangene Ausnahmen bewirken, dass die Transaktion zurückgesetzt wird, und
            <itemizedlist>
              <listitem>für einen <database>CONNECT</database>-Trigger wird die Verbindung 
              unterbrochen und die Ausnahme wird an den Client zurückgegeben</listitem>
              <listitem>für einen <database>DISCONNECT</database>-Trigger werden 
              Ausnahmen nicht gemeldet. Die Verbindung ist wie beabsichtigt unterbrochen</listitem>
            </itemizedlist>
          </para>

          <para><database>TRANSACTION</database>-Trigger werden innerhalb der Transaktion 
            ausgeführt, deren Start, Commit oder Rollback sie hervorruft. Die Aktion, die nach einer
            nicht abgefangenen Ausnahme ausgeführt wird, hängt vom Ereignis ab:
            <itemizedlist>
              <listitem>In einem <database>TRANSACTION START</database>-Trigger wird die 
              Ausnahme an den Client gemeldet und die Transaktion wird zurückgesetzt</listitem>
              <listitem>In einem <database>TRANSACTION COMMIT</database>-Trigger wird die 
              Ausnahme gemeldet, die bisherigen Aktionen des Triggers werden rückgängig 
              gemacht und das Commit abgebrochen</listitem>
              <listitem>In einem <database>TRANSACTION ROLLBACK</database>-Trigger
              wird die Ausnahme nicht gemeldet und die Transaktion wird wie beabsichtigt 
              zurückgesetzt.</listitem>
            </itemizedlist>
          </para>

          <section id="fblangref25-ddl-trgr-dbtrigger-traps-de">
            <title>Fallen</title>
            <para>Offensichtlich gibt es keine direkte Möglichkeit zu wissen, ob ein  
                <database>DISCONNECT</database>- oder 
                <database>TRANSACTION ROLLBACK</database>-Trigger eine Ausnahme verursacht hat. 
                Daraus folgt auch, dass die Verbindung zur Datenbank nicht zustande kommen kann, 
                wenn ein <database>CONNECT</database>-Trigger eine Ausnahme verursacht und eine 
                Transaktion nicht gestartet werden kann, wenn auch ein 
                <database>TRANSACTION START</database>-Trigger einen auslöst. Beide Phänomene 
                sperrt Sie effektiv aus Ihrer Datenbank aus, bis Sie mit unterdrückten Datenbanktriggern 
                zurückkehren und den fehlerhaften Code beheben.</para>
            
            <section id="fblangref25-ddl-trgr-dbtrigger-notrgr-de">
              <title>Triggerunterdrückung</title>
              <para>Einige Firebird-Befehlszeilentools wurden mit Switches ausgestattet, mit denen ein Administrator 
                  die automatische Auslösung von Datenbanktriggern unterdrücken kann. 
                  Bisher sind sie:
                <blockquote><literallayout class="monospaced">
gbak -nodbtriggers
isql -nodbtriggers
nbackup -T
                </literallayout></blockquote>
              </para>
            </section>
          </section>

          <section id="fblangref25-ddl-trgr-dbtrigger-2pc-de">
            <title>Zwei-Phasen Commit</title>
            <para>In einem zweiphasigen Commit-Szenario löst ein 
                <database>TRANSACTION COMMIT</database>-Trigger bereits
            in der Vorbereitungsphase aus und nicht erst beim Commit.</para>
          </section>

          <section id="fblangref25-ddl-trgr-dbtrigger-caveats-de">
            <title>Einige Vorbehalte</title>
            <orderedlist>
              <listitem>Die Verwendung der Anweisung <database>IN AUTONOMOUS TRANSACTION DO</database> 
              in den Datenbanktriggern für Transaktionen (<database>TRANSACTION START</database>, 
              <database>TRANSACTION ROLLBACK</database>, <database>TRANSACTION COMMIT</database>) kann 
                  dazu führen, dass die autonome Transaktion eine Endlosschleife generiert</listitem>
              <listitem>Die Ereignistrigger <database>DISCONNECT</database> und 
              <database>TRANSACTION ROLLBACK</database> werden nicht ausgeführt, wenn Clients über 
              Überwachungstabellen getrennt werden
              (<database>DELETE FROM MON$ATTACHMENTS</database>)</listitem>
            </orderedlist>
          </section>
        </section> <!-- Excecution etc. -->

      <para>Nur der Datenbankbesitzer und <link linkend="fblangref25-security-administrators-de">Administratoren</link> 
      haben die Berechtigung zum Erstellen von Datenbanktriggern.</para>

        <formalpara>
          <title>Beispiele für CREATE TRIGGER für <quote>Database Triggers</quote></title>
          <orderedlist>
            <listitem>Einen Trigger für das Ereignis erstellen, bei dem eine Verbindung zur 
                Datenbank hergestellt wird, in der Benutzer protokolliert werden, die sich am 
                System anmelden. Der Trigger wird als inaktiv erstellt.
              <programlisting>
CREATE TRIGGER tr_log_connect
INACTIVE ON CONNECT POSITION 0
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_TIMESTAMP);
END
              </programlisting>
            </listitem>
            <listitem>Einen Trigger für das Ereignis der Verbindung mit der Datenbank erstellen, 
                das es keinem Benutzer, außer SYSDBA, erlaubt, sich außerhalb der Geschäftszeiten anzumelden.
              <programlisting>
CREATE EXCEPTION E_INCORRECT_WORKTIME 'The working day has not started yet.';

CREATE TRIGGER TR_LIMIT_WORKTIME ACTIVE
ON CONNECT POSITION 1
AS
BEGIN
  IF ((CURRENT_USER &lt;&gt; 'SYSDBA') AND
      NOT (CURRENT_TIME BETWEEN time '9:00' AND time '17:00')) THEN
     EXCEPTION E_INCORRECT_WORKTIME;
END
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
        <formalpara><title>Siehe auch</title>
          <para> <link linkend="fblangref25-ddl-trgr-alter-de"><database>ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-crtalter-de"><database>CREATE OR ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-recreate-de"><database>RECREATE TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-drop-de"><database>DROP TRIGGER</database></link>
          </para>
        </formalpara>
      </section> <!-- Database triggers -->
    </section> <!-- Create trigger -->

    <section id="fblangref25-ddl-trgr-alter-de">
      <title><database>ALTER TRIGGER</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Ändern und Deaktivieren eines vorhandenen Triggers </para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER TRIGGER trigname
[ACTIVE | INACTIVE]
[{BEFORE | AFTER} &lt;mutation_list&gt; | ON db_event]
[POSITION number]
[
 AS
  [&lt;declarations&gt;]
	 BEGIN
    [&lt;PSQL_statements&gt;]
	 END
]

&lt;mutation_list&gt; ::=
  &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::= {
  CONNECT |
  DISCONNECT |
  TRANSACTION START |
  TRANSACTION COMMIT |
  TRANSACTION ROLLBACK
}

&lt;declarations&gt; ::= {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
	[{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-altertrigger-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER TRIGGER Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">trigname</entry>
              <entry align="left">Name eines vorhandenen Triggers</entry>
            </row>
            <row valign="middle">
              <entry align="center">mutation_list</entry>
              <entry align="left">Liste von Relation-Ereignissen (Tabelle | Ansicht) </entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Position des Triggers in der Zündreihenfolge. Von 0 bis 32.767</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Abschnitt zum Deklarieren von lokalen Variablen und benannter Cursor</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Lokale Variablendeklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Benannte Cursor-Deklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Anweisungen in der Programmiersprache von Firebird (PSQL)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>ALTER TRIGGER</database> erlaubt bestimmte 
      Änderungen am Header und am Rumpf eines Triggers.</para>

      <section id="fblangref25-ddl-trgr-alterwhat-de">
        <title>Zulässige Änderungen an Triggern</title>
        <itemizedlist>
          <listitem>Status (<database>ACTIVE | INACTIVE</database>)</listitem>
          <listitem>Phase (<database>BEFORE | AFTER</database>)</listitem>
          <listitem>Veranstaltungen; aber Relationstriggerereignisse können nicht in 
              Datenbanktriggerereignisse geändert werden, und umgekehrt</listitem>
          <listitem>Position innerhalb der Ausführungsreihenfolge</listitem>
          <listitem>Änderungen am Code im Trigger-Body</listitem>
        </itemizedlist>

        <para>Wenn ein Element nicht angegeben wurde, bleibt es unverändert.</para>
        <note>
          <title>Zur Erinnerungen</title>
          <para>Das BEFORE-Schlüsselwort weist darauf hin, dass der Trigger ausgeführt wird, 
              bevor das zugehörige Ereignis eintritt. Das Schlüsselwort AFTER weist darauf hin, 
              dass es nach dem Ereignis ausgeführt wird.</para>
          <para>Mehr als ein Beziehungsereignis - <database>INSERT, UPDATE, DELETE</database> - 
          kann mit einem einzigen Trigger abgedeckt werden. Die Ereignisse sollten mit dem 
          Schlüsselwort <database>OR</database> getrennt werden. Kein Ereignis sollte mehr als 
          einmal erwähnt werden.</para>
          <para>Das Schlüsselwort <database>POSITION</database> erlaubt es, eine optionale Ausführungsreihenfolge 
          (<quote>firing order</quote>) für eine Reihe von Triggern anzugeben, die dieselbe 
          Phase und dasselbe Ereignis wie ihr Ziel haben. Die Standardposition ist 0. 
          Wenn keine Positionen angegeben werden oder wenn mehrere Trigger eine einzelne Positionsnummer 
          haben, werden die Trigger in der alphabetischen Reihenfolge ihrer Namen ausgeführt.</para>
        </note>
       </section>

      <para><link linkend="fblangref25-security-administrators-de">Administratoren</link> und folgende Benutzer
      haben die Berechtigung für die Ausführung von <database>ALTER TRIGGER</database>:
        <itemizedlist spacing="compact">
          <listitem>Für Relations-Trigger der Besitzer des Tisches</listitem>
          <listitem>Für Datenbank-Trigger der Eigentümer der Datenbank</listitem>
        </itemizedlist>
      </para>

      <formalpara>
        <title>Beispiele mit ALTER TRIGGER</title>
        <orderedlist>
          <listitem>Deaktivieren des Triggers set_cust_no (Umschalten in den inaktiven Status)
            <programlisting>
ALTER TRIGGER set_cust_no INACTIVE;
            </programlisting>
          </listitem>

          <listitem>Ändern der Ausführungsreihenfolge des Triggers set_cust_no.
            <programlisting>
ALTER TRIGGER set_cust_no POSITION 14;
            </programlisting>
          </listitem>

          <listitem>Den Trigger TR_CUST_LOG in den inaktiven Status schalten und die Liste der 
              Ereignisse ändern.
            <programlisting>
ALTER TRIGGER TR_CUST_LOG
INACTIVE AFTER INSERT OR UPDATE;
            </programlisting>
          </listitem>

          <listitem>Den tr_log_connect-Trigger in den aktiven Status schalten und seine Position und 
              seinen Körper ändern.
            <programlisting>
ALTER TRIGGER tr_log_connect
ACTIVE POSITION 1
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ROLENAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_ROLE,
          CURRENT_TIMESTAMP);
END
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-trgr-create-de"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-crtalter-de"><database>CREATE OR ALTER TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-recreate-de"><database>RECREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-drop-de"><database>DROP TRIGGER</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter trigger -->

    <section id="fblangref25-ddl-trgr-crtalter-de">
      <title><database>CREATE OR ALTER TRIGGER</database></title>
      <formalpara><title>Benutzt für</title>
        <para> Erstellen eines neuen Triggers oder Ändern eines vorhandenen Triggers</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER TRIGGER trigname  {
  &lt;relation_trigger_legacy&gt; |
  &lt;relation_trigger_sql2003&gt; |
  &lt;database_trigger&gt; }
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
      </formalpara>
      <para>Für das vollständige Detail der Syntax siehe 
          <link linkend="fblangref25-ddl-trgr-create-de">
              <database>CREATE TRIGGER</database>
         </link>.</para>
      <para>Die Anweisung <database>CREATE OR ALTER TRIGGER</database> erstellt einen neuen Trigger, 
      falls er nicht existiert. Andernfalls ändert und kompiliert er es erneut, wobei die Privilegien 
      intakt und die Abhängigkeiten unberührt bleiben.</para>
      <formalpara>
        <title>Beispiel mit CREATE OR ALTER TRIGGER</title>
        <para> Erstellen eines neuen Triggers, falls er nicht existiert oder anpassen, falls vorhanden.
          <blockquote><programlisting>
CREATE OR ALTER TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-trgr-create-de"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-alter-de"><database>ALTER TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-recreate-de"><database>RECREATE TRIGGER</database></link>
        </para>
      </formalpara>
    </section><!-- create or alter trigger -->

    <section id="fblangref25-ddl-trgr-drop-de">
      <title><database>DROP TRIGGER</database></title>
      <formalpara><title>Benutzt für</title>
        <para> Einen vorhandenen Trigger löschen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP TRIGGER trigname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-droptrigger-de">
      <?dbfo keep-together='auto'?>
        <title>DROP TRIGGER Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">trigname</entry>
              <entry align="left">Triggername</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP TRIGGER</database> löscht einen vorhandenen Trigger.</para>

      <para><link linkend="fblangref25-security-administrators-de">Administrators</link> und die folgenden
        Benutzer besitzen die Berechtigung, die Anweisung <database>DROP TRIGGER</database>
        auszuführen:
        <itemizedlist spacing="compact">
          <listitem>Für Relations-Trigger, der Eigentümer der Tabelle</listitem>
          <listitem>Für Datenbank-Trigger, der Eigentümer der Datenbank</listitem>
        </itemizedlist>
      </para>

      <formalpara>
        <title>Beispiele für DROP TRIGGER</title>
        <para> Löschen des Triggers set_cust_no.
          <blockquote><programlisting>
DROP TRIGGER set_cust_no;
          </programlisting></blockquote>
        </para>
      </formalpara>

      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-trgr-create-de"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-recreate-de"><database>RECREATE TRIGGER</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop trigger -->

    <section id="fblangref25-ddl-trgr-recreate-de">
      <title><database>RECREATE TRIGGER</database></title>
      <formalpara><title>Benutzt für</title>
        <para> Erstellen eines neuen Triggers oder Neuerstellung eines vorhandenen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE TRIGGER trigname {
  &lt;relation_trigger_legacy&gt; | 
  &lt;relation_trigger_sql2003&gt; | 
  &lt;database_trigger&gt; }
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
      </formalpara>
      <para>Für die detaillierte Syntax, vergleichen Sie
          <link linkend="fblangref25-ddl-trgr-create-de">
              <database>CREATE TRIGGER</database>
         </link>.</para>
      <para>Die Anweisung <database>RECREATE TRIGGER</database> erzeugt einen neuen Trigger, 
      wenn kein Trigger mit dem angegebenen Namen existiert. Andernfalls versucht die Anweisung 
      <database>RECREATE TRIGGER</database>, den vorhandenen Trigger zu löschen und einen neuen 
          zu erstellen. Die Operation schlägt beim <database>COMMIT</database> fehl, wenn 
          Triggerabhängigkeiten vorliegen.</para>
      <warning>
        <para>Beachten Sie, dass Abhängigkeitsfehler erst in der Phase <database>COMMIT</database> 
        dieser Operation erkannt werden.</para>
      </warning>
      <formalpara>
        <title>Beispiele für RECREATE TRIGGER</title>
        <para> Erstellen oder Neuerstellung des Triggers set_cust_no.
          <blockquote><programlisting>
RECREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-trgr-create-de"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-drop-de"><database>DROP TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-crtalter-de"><database>CREATE OR ALTER TRIGGER</database></link>
        </para>
      </formalpara>
    </section><!-- create or alter trigger -->
  </section> <!-- TRIGGER -->

  <section id="fblangref25-ddl-procedure-de">
    <title><database>PROCEDURE</database></title>
    <para>Eine gespeicherte Prozedur (Stored Procedure) ist ein Softwaremodul, das von einem Client, einer anderen 
        Prozedur, einem ausführbaren Block oder einem Trigger aufgerufen werden kann. Gespeicherte Prozeduren, 
        ausführbare Blöcke und Trigger werden in prozeduralem SQL (PSQL) geschrieben. Die meisten SQL-Anweisungen 
        sind auch in PSQL verfügbar, manchmal mit Einschränkungen oder Erweiterungen. Zu den bemerkenswerten 
        Ausnahmen zählen DDL- und Transaktionskontrollanweisungen. 
    </para>
    <para>Gespeicherte Prozeduren können viele Eingabe- und Ausgabeparameter haben.</para>

    <section id="fblangref25-ddl-proc-create-de">
      <title><database>CREATE PROCEDURE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen gespeicherten Prozedur</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END

	&lt;inparam&gt; ::= &lt;param_decl&gt; [{= | DEFAULT} &lt;value&gt;]

	&lt;outparam&gt; ::= &lt;param_decl&gt;

	&lt;value&gt; ::= {literal | NULL | context_var}

	&lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL]
	[COLLATE collation]

&lt;type&gt; ::=
  &lt;datatype&gt; |
  [TYPE OF] domain |
  TYPE OF COLUMN rel.col

&lt;datatype&gt; ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

&lt;declarations&gt; ::=
  {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
    [{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-proc-createproc-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE PROCEDURE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Der Name der gespeicherten Prozedur besteht aus bis zu 31 Zeichen. 
                  Muss für alle Tabellen-, View- und Prozedurnamen in der Datenbank eindeutig sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">inparam</entry>
              <entry align="left">Beschreibung der Eingabeparameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">outparam</entry>
              <entry align="left">Beschreibung der Ausgangsparameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Lokale Variablendeklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Benannte Cursor-Deklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Prozedurale SQL-Anweisungen</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Ein Literalwert, der mit dem Datentyp des Parameters 
                  zuweisungskompatibel ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Jede Kontextvariable, deren Typ mit dem Datentyp des 
                  Parameters kompatibel ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">Der Name eines Eingabe- oder Ausgabeparameters der Prozedur. 
                  Dieser kann aus bis zu 31 Zeichen bestehen. Der Name des Parameters muss unter den 
                  Eingabe- und Ausgabeparametern der Prozedur und ihren lokalen Variablen eindeutig sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Sortierfolge</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Domain-Name</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel</entry>
              <entry align="left">Tabellen- oder View-Name</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Spaltenname einer Tabelle oder View</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Die Gesamtanzahl der signifikanten Stellen, die der 
                  Parameter halten kann (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Die Anzahl der Stellen nach dem Dezimalpunkt (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe eines Zeichenfolgentypparameters oder einer Variablen in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Zeichensatz eines String-Typ-Parameters oder einer Variablen</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">Subtyp-Nummer eines BLOB</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">Mnemonischer Name eines BLOB-Subtyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße (max. 65535)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE PROCEDURE</database> erstellt eine neue gespeicherte Prozedur. Der 
          Name der Prozedur muss unter den Namen aller gespeicherten Prozeduren, Tabellen und Ansichten 
          in der Datenbank eindeutig sein.</para>

      <para><database>CREATE PROCEDURE</database> ist eine <emphasis>zusammengesetzte Anweisung</emphasis>, 
      bestehend aus einem Header und einem Body. Der Header gibt den Namen der Prozedur an und deklariert 
      Eingabeparameter und ggf. die Ausgabeparameter, die von der Prozedur zurückgegeben werden sollen.</para>
      <para>Der Prozedurhauptteil besteht aus Deklarationen für alle lokalen Variablen und benannten Cursors, die 
          von der Prozedur verwendet werden, gefolgt von einer oder mehreren Anweisungen oder Anweisungsblöcken, 
          die alle in einem äußeren Block eingeschlossen sind, der mit dem Schlüsselwort <database>BEGIN</database> 
          beginnt und endet mit dem Schlüsselwort <database>END</database> endet. Deklarationen und eingebettete 
          Anweisungen werden mit Semikolon (<command>;</command>) abgeschlossen.</para>
      
      <section id="fblangref25-ddl-terminators02-de">
        <title>Statement-Terminatoren</title>
        <para>Einige SQL-Anweisungseditoren &mdash; insbesondere das mit Firebird mitgelieferte Dienstprogramm <emphasis>isql</emphasis> 
        und möglicherweise einige Editoren von Drittanbietern &mdash; verwenden eine interne Konvention, die erfordert, 
        dass alle Anweisungen mit einem Semikolon abgeschlossen werden. Dies führt bei der Codierung in diesen Umgebungen zu einem 
        Konflikt mit der PSQL-Syntax. Wenn Sie mit diesem Problem und seiner Lösung nicht vertraut sind, lesen Sie bitte die Details 
        im Kapitel PSQL im Abschnitt <link linkend="fblangref25-sidebar01-de"> Umschalten des Terminators in <emphasis>isql</emphasis></link>.</para>
      </section>

      <section id="fblangref25-ddl-proc-params-de">
        <title><database>Parameter</database></title>
        <para>Jeder Parameter hat einen Datentyp, der dafür angegeben ist. Die Einschränkung <database>NOT NULL</database> kann auch für jeden 
        beliebigen Parameter angegeben werden, um zu verhindern, dass <database>NULL</database> übergeben oder zugewiesen wird.</para>
        <para>Mit der Klausel <database>COLLATE</database> kann eine Sortierfolge für Parameter vom Typ String festgelegt werden.</para>
        
        <formalpara>
          <title>Eingabeparameter</title>
          <blockquote><para> Eingabeparameter werden nach dem Namen der Prozedur in Klammern angezeigt. Sie werden als Werte an die Prozedur übergeben, 
              d.h. alles, was sie innerhalb der Prozedur ändert, hat keine Auswirkungen auf die Parameter im aufrufenden Programm.</para>
          <para>Eingabeparameter können Standardwerte haben. Diejenigen, für die Werte angegeben sind, müssen sich 
              am Ende der Parameterliste befinden.</para>
          </blockquote>
        </formalpara>
        <formalpara><title>Ausgabeparameter</title>
          <blockquote><para> Die optionale Klausel <database>RETURNS</database> dient zur Angabe 
          einer eingeklammerten Liste von Ausgabeparametern 
          für die gespeicherte Prozedur.</para>
          </blockquote>
        </formalpara>

        <section id="fblangref25-ddl-proc-paramsdomns-de">
          <title>Verwendung von Domains in Deklarationen</title>
          <para>Ein Domainname kann als Typ eines Parameters angegeben werden. Der Parameter erbt alle 
              Domainattribute. Wenn ein Standardwert für den Parameter angegeben wird, überschreibt 
              dieser den in der Domänendefinition angegebenen Standardwert.</para>

          <para>Wenn die Klausel <database>TYPE OF</database> vor dem Domänennamen hinzugefügt wird, 
            wird nur der Datentyp der Domain verwendet: Alle anderen Attribute der Domain &mdash; 
            <database>NOT NULL-Einschränkung</database>, <database>CHECK</database>-Bedingung, 
            Standardwert &mdash; werden weder geprüft noch verwendet. Wenn die Domain jedoch aus einem 
            Texttyp besteht, werden immer ihre Zeichensatz und die Sortierreihenfolge verwendet.</para>
        </section> <!-- Use of domains -->

        <section id="fblangref25-ddl-proc-paramscoltype-de">
          <title>Verwendung des Spaltentyps in Deklarationen</title>
          <para>Eingabe- und Ausgabeparameter können auch über den Datentyp von Spalten in vorhandenen 
              Tabellen und Ansichten deklariert werden. Die Klausel <database>TYPE OF COLUMN</database> 
              wird dafür verwendet, wobei <replaceable> relationname.columnname </replaceable> als Argument 
              angegeben wird.</para>
          <para>Wenn <database>TYPE OF COLUMN</database> verwendet wird, erbt der Parameter nur den Datentyp,
              bei Zeichenkettentypen den Zeichensatz und die Sortierreihenfolge. Die Constraints und der 
              Standardwert der Spalte werden ignoriert.</para>
          <warning>
            <title>Bugwarnung für Versionen vor Firebird 3:</title>
            <para>Für Eingabeparameter wird die Sortierung, die mit dem Typ der Spalte geliefert wird, 
                in Vergleichen ignoriert (z. B. Gleichheitstests). Bei lokalen Variablen variiert das Verhalten.</para>
            <para>Der Bug wurde für Firebird 3 behoben.</para>
          </warning>
        </section>
      </section> <!-- Parameters -->

      <section id="fblangref25-ddl-proc-declarations-de">
        <title>Variablen- und Cursor-Deklarationen</title>
        <para>Der optionale Deklarationsabschnitt, der zuletzt im Headerabschnitt der Prozedurdefinition 
            aufgeführt ist, definiert lokale Variablen für die Prozedur und ihre benannten Cursor. 
            Lokale Variablendeklarationen folgen denselben Regeln wie Parameter bezüglich der Spezifikation 
            des Datentyps. Bitte entnehmen Sie Details den Abschnitten <link linkend="fblangref25-psql-de">PSQL chapter</link> 
            for <link linkend="fblangref25-psql-declare-variable-de"><database>DECLARE VARIABLE</database></link>
            und <link linkend="fblangref25-psql-declare-cursor-de"><database>DECLARE CURSOR</database></link>.</para>
      </section> <!-- Declarations -->

      <section id="fblangref25-ddl-proc-procbody-de">
        <para>Auf den Headerabschnitt folgt der Prozedurhauptteil, der aus einer oder mehreren PSQL-Anweisungen besteht, die 
            zwischen den äußeren Schlüsselwörtern <database>BEGIN</database> und <database>END</database> eingeschlossen 
            sind. Mehrere <database>BEGIN ... END</database>-Blöcke von beendeten Anweisungen können in den 
            Prozedurtext eingebettet werden.</para>
      </section>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine neue gespeicherte Prozedur erstellen. Der Benutzer, 
          der eine gespeicherte Prozedur erstellt, wird zu seinem Besitzer.</para>

      <formalpara id="create-procedure-examples-de">
        <title>Beispiele</title>
        <para> Erstellen einer gespeicherten Prozedur, die einen Datensatz in die BREED-Tabelle einfügt und den Code des 
            eingefügten Datensatzes zurückgibt:
          <blockquote><programlisting>
CREATE PROCEDURE ADD_BREED (
  NAME D_BREEDNAME, /* Domain attributes are inherited */
  NAME_EN TYPE OF D_BREEDNAME, /* Only the domain type is inherited */
  SHORTNAME TYPE OF COLUMN BREED.SHORTNAME, 
    /* The table column type is inherited */
  REMARK VARCHAR(120) CHARACTER SET WIN1251 COLLATE PXW_CYRL,
  CODE_ANIMAL INT NOT NULL DEFAULT 1
)
RETURNS (
  CODE_BREED INT
)
AS
BEGIN
  INSERT INTO BREED (
    CODE_ANIMAL, NAME, NAME_EN, SHORTNAME, REMARK)
  VALUES (
    :CODE_ANIMAL, :NAME, :NAME_EN, :SHORTNAME, :REMARK)
  RETURNING CODE_BREED INTO CODE_BREED;
END
          </programlisting></blockquote>
        </para>
        <para>Erstellen einer wählbaren gespeicherten Prozedur, die Daten für Adressetiketten generiert
            (aus <function>employee.fdb</function>):
          <blockquote><programlisting>
CREATE PROCEDURE mail_label (cust_no INTEGER)
RETURNS (line1 CHAR(40), line2 CHAR(40), line3 CHAR(40),
         line4 CHAR(40), line5 CHAR(40), line6 CHAR(40))
AS
  DECLARE VARIABLE customer VARCHAR(25);
  DECLARE VARIABLE first_name VARCHAR(15);
  DECLARE VARIABLE last_name VARCHAR(20);
  DECLARE VARIABLE addr1 VARCHAR(30);
  DECLARE VARIABLE addr2 VARCHAR(30);
  DECLARE VARIABLE city VARCHAR(25);
  DECLARE VARIABLE state VARCHAR(15);
  DECLARE VARIABLE country VARCHAR(15);
  DECLARE VARIABLE postcode VARCHAR(12);
  DECLARE VARIABLE cnt INTEGER;
BEGIN
	line1 = '';
	line2 = '';
	line3 = '';
	line4 = '';
	line5 = '';
	line6 = '';

	SELECT customer, contact_first, contact_last, address_line1,
		address_line2, city, state_province, country, postal_code
	FROM CUSTOMER
	WHERE cust_no = :cust_no
	INTO :customer, :first_name, :last_name, :addr1, :addr2,
		:city, :state, :country, :postcode;

	IF (customer IS NOT NULL) THEN
		line1 = customer;
	IF (first_name IS NOT NULL) THEN
		line2 = first_name || ' ' || last_name;
	ELSE
		line2 = last_name;
	IF (addr1 IS NOT NULL) THEN
		line3 = addr1;
	IF (addr2 IS NOT NULL) THEN
		line4 = addr2;

	IF (country = 'USA') THEN
	BEGIN
		IF (city IS NOT NULL) THEN
			line5 = city || ', ' || state || '  ' || postcode;
		ELSE
			line5 = state || '  ' || postcode;
	END
	ELSE
	BEGIN
		IF (city IS NOT NULL) THEN
			line5 = city || ', ' || state;
		ELSE
			line5 = state;
		line6 = country || '    ' || postcode;
	END

	SUSPEND; -- the statement that sends an output row to the buffer
	         -- and makes the procedure &quot;selectable&quot;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para>
        <link linkend="fblangref25-ddl-proc-crtoralter-de"><database>CREATE OR ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-alter-de"><database>ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate-de"><database>RECREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-drop-de"><database>DROP PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Create procedure -->

    <section id="fblangref25-ddl-proc-alter-de">
      <title><database>ALTER PROCEDURE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Ändern einer vorhandenen gespeicherten Prozedur</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END

	&lt;inparam&gt; ::= &lt;param_decl&gt; [{= | DEFAULT} value]

	&lt;outparam&gt; ::= &lt;param_decl&gt;

	&lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL]
	[COLLATE collation]

&lt;type&gt; ::=
  &lt;datatype&gt; |
  [TYPE OF] domain |
  TYPE OF COLUMN rel.col

&lt;datatype&gt; ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISSION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

	&lt;declarations&gt; ::= {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
	[{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-proc-alterproc-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER PROCEDURE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Der Name einer existierenden gespeicherten Prozedur</entry>
            </row>
            <row valign="middle">
              <entry align="center">inparam</entry>
              <entry align="left">Beschreibung der Eingabeparameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">outparam</entry>
              <entry align="left">Beschreibung der Ausgangsparameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Lokale Variablendeklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Benannte Cursor-Deklaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Prozedurale SQL-Anweisungen</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Ein Literalwert, der mit dem Datentyp des Parameters 
                  zuweisungskompatibel ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Jede Kontextvariable, deren Typ mit dem Datentyp des 
                  Parameters kompatibel ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">Der Name eines Eingabe- oder Ausgabeparameters der Prozedur. 
                  Dieser kann aus bis zu 31 Zeichen bestehen. Der Name des Parameters muss unter den 
                  Eingabe- und Ausgabeparametern der Prozedur und ihren lokalen Variablen eindeutig sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Sortierfolge</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Domain-Name</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel</entry>
              <entry align="left">Tabellen- oder View-Name</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Spaltenname einer Tabelle oder View</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Die Gesamtanzahl der signifikanten Stellen, die der 
                  Parameter halten kann (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Die Anzahl der Stellen nach dem Dezimalpunkt (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe eines Zeichenfolgentypparameters oder einer Variablen in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Zeichensatz eines String-Typ-Parameters oder einer Variablen</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">Subtyp-Nummer eines BLOB</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">Mnemonischer Name eines BLOB-Subtyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße (max. 65535)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>ALTER PROCEDURE</database> erlaubt folgende Änderungen der Definition für gespeicherte Prozeduren:
        <itemizedlist spacing="compact">
          <listitem>Satz und die Eigenschaften von Eingangs- und Ausgangsparametern</listitem>
          <listitem>lokale Variablen</listitem>
          <listitem>Code im Hauptteil der gespeicherten Prozedur</listitem>
        </itemizedlist>
      Nach der Ausführung von <database>ALTER PROCEDURE</database> bleiben vorhandene Berechtigungen erhalten und 
      Abhängigkeiten werden nicht beeinflusst.</para>
      <caution>
        <para>Achten Sie darauf, die Anzahl und Art der Eingabe- und Ausgabeparameter in gespeicherten Prozeduren zu ändern. 
            Bestehender Anwendungscode und Prozeduren und Trigger, die ihn aufrufen, könnten ungültig werden, weil die neue Beschreibung 
            der Parameter mit dem alten Aufrufformat nicht kompatibel ist. Informationen zum Beheben einer solchen Situation finden Sie im Artikel
        <link linkend="fblangref25-appx01-supp-rdb_validblr-de">Das Feld <database>RDB$VALID_BLR</database></link>
        im Anhang.</para>
      </caution>

      <para>Der Prozedureigentümer und <link linkend="fblangref25-security-administrators-de">Administratoren</link> 
      besitzen die Recht zum Ausführen von <database>ALTER PROCEDURE</database>.</para>

      <formalpara><title>Beispiele für ALTER PROCEDURE</title>
        <para>Ändern der gespeicherten Prozedur GET_EMP_PROJ
          <blockquote><programlisting>
ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-proc-create-de"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-crtoralter-de"><database>CREATE OR ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate-de"><database>RECREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-drop-de"><database>DROP PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter procedure -->

    <section id="fblangref25-ddl-proc-crtoralter-de">
      <title><database>CREATE OR ALTER PROCEDURE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen einer neuen gespeicherten Prozedur oder Ändern einer vorhandenen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
        <para>Das vollständige Syntaxdetail finden Sie unter 
            <link linkend="fblangref25-ddl-proc-create-de">
                <database>CREATE DATABASE</database>
           </link>.</para>
      </formalpara>
      <para>Die Anweisung <database>CREATE OR ALTER PROCEDURE</database> erstellt eine neue 
      gespeicherte Prozedur oder ändert eine vorhandene Prozedur. Wenn die gespeicherte Prozedur 
      nicht vorhanden ist, wird sie durch das transparente Aufrufen einer Anweisung 
      <database>CREATE PROCEDURE</database> erstellt. Wenn die Prozedur bereits vorhanden ist, 
      wird sie geändert und kompiliert, ohne die vorhandenen Berechtigungen und Abhängigkeiten zu 
      beeinträchtigen.</para>

      <formalpara><title>Beispiel</title>
        <para>&nbsp;Creating or altering the GET_EMP_PROJ procedure.
          <blockquote><programlisting>
CREATE OR ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-proc-create-de"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-alter-de"><database>ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate-de"><database>RECREATE PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Create or alter procedure -->

    <section id="fblangref25-ddl-proc-drop-de">
      <title><database>DROP PROCEDURE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Löschen einer gespeicherten Prozedur</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP PROCEDURE procname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-procdrop-de">
      <?dbfo keep-together='auto'?>
        <title>DROP PROCEDURE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name einer vorhandenen gespeicherten Prozedur</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP PROCEDURE</database> löscht eine vorhandene 
      gespeicherte Prozedur. Wenn die gespeicherte Prozedur Abhängigkeiten aufweist, 
      schlägt der Löschversuch fehl und der entsprechende Fehler wird ausgelöst.</para>
      
      <para>Der Prozedureigentümer und <link linkend="fblangref25-security-administrators-de"> Administratoren</link> 
      haben die Berechtigung, <database>DROP PROCEDURE</database> zu verwenden.</para>

      <formalpara><title>Beispiel</title>
        <para>&nbsp;Löschen der gespeicherten Prozedur GET_EMP_PROJ
          <blockquote><programlisting>
DROP PROCEDURE GET_EMP_PROJ;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-proc-create-de"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate-de"><database>RECREATE PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop procedure -->

    <section id="fblangref25-ddl-proc-recreate-de">
      <title><database>RECREATE PROCEDURE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Eine neue gespeicherte Prozedur erstellen oder eine vorhandene wiederherstellen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
        <para>Das vollständige Syntaxdetail finden Sie unter 
            <link linkend="fblangref25-ddl-proc-create-de">
                <database>CREATE PROCEDURE</database>
           </link>.</para>
      </formalpara>
      <para>Die Anweisung <database>RECREATE PROCEDURE</database> erstellt eine neue gespeicherte 
      Prozedur oder erstellt eine vorhandene Prozedur neu. Wenn es bereits eine Prozedur mit diesem 
      Namen gibt, versucht die Engine diese zu löschen und eine neue zu erstellen. Das Wiederherstellen 
      einer vorhandenen Prozedur schlägt bei der Anforderung <database>COMMIT</database> fehl, wenn 
          die Prozedur Abhängigkeiten aufweist.</para>
      <warning>
        <para>Beachten Sie, dass Abhängigkeitsfehler erst in der Phase <database>COMMIT</database> 
        dieser Operation erkannt werden.</para>
      </warning>
      <para>Nachdem eine Prozedur erfolgreich neu erstellt wurde, werden Berechtigungen zum Ausführen 
          der gespeicherten Prozedur und die Berechtigungen der gespeicherten Prozedur selbst gelöscht.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Erstellen der neuen gespeicherten Prozedur GET_EMP_PROJ oder Wiederherstellen der 
            vorhandenen gespeicherten Prozedur GET_EMP_PROJ.
          <blockquote><programlisting>
RECREATE PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-proc-create-de"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-drop-de"><database>DROP PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-crtoralter-de"><database>CREATE OR ALTER PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Recreate procedure -->
  </section> <!-- Procedure -->
  
  <section id="fblangref25-ddl-extfunc-de">
    <title><database>EXTERNAL FUNCTION</database></title>
  <!-- Review status notice -->
  <important>
    <title>ÜBERPRÜFUNGSSTATUS</title>
    <para>Alle Abschnitte von diesem Punkt bis zum Ende des Kapitels warten auf eine technische und redaktionelle Überprüfung.</para>
  </important>


    <para>Externe Funktionen, die auch als <quote>benutzerdefinierte Funktionen</quote> (UDFs) bezeichnet werden, sind Programme, 
        die in einer externen Programmiersprache geschrieben und in dynamisch geladenen Bibliotheken gespeichert werden. 
        Sobald sie in einer Datenbank deklariert sind, werden sie in dynamischen und prozeduralen Anweisungen verfügbar, 
        als wären sie intern in der SQL-Sprache implementiert.</para>
    <para>Externe Funktionen erweitern die Möglichkeiten zur Datenverarbeitung mit SQL erheblich. Um eine Funktion 
        für eine Datenbank verfügbar zu machen, wird sie mit der Anweisung <database>DECLARE EXTERNAL FUNCTON</database> 
        deklariert.</para>
    <para>Die Bibliothek, die eine Funktion enthält, wird geladen, wenn eine darin enthaltene Funktion aufgerufen wird.</para>
    <note>
      <para>Externe Funktionen können in mehr als einem Bibliotheks- oder <quote>-Modul</quote> enthalten sein, wie es in der 
      Syntax erwähnt wird.</para>
    </note>

    <section id="fblangref25-ddl-extfunc-declare-de">
      <title><database>DECLARE EXTERNAL FUNCTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Deklarieren einer benutzerdefinierten Funktion (UDF) zur Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DECLARE EXTERNAL FUNCTION funcname
[&lt;arg_type_decl&gt; [, &lt;arg_type_decl&gt; ...]]
RETURNS {
  sqltype [BY {DESCRIPTOR | VALUE}] |
  CSTRING(length) |
  PARAMETER param_num }
[FREE_IT]
ENTRY_POINT 'entry_point' MODULE_NAME 'library_name';

&lt;arg_type_decl&gt; ::=
  sqltype [{BY DESCRIPTOR} | NULL] |
  CSTRING(length) [NULL]
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-declarefunc-de">
      <?dbfo keep-together='auto'?>
        <title>DECLARE EXTERNAL FUNCTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">funcname</entry>
              <entry align="left">Funktionsname in der Datenbank. Es kann aus bis zu 31 Zeichen 
                  bestehen. Es sollte unter allen internen und externen Funktionsnamen in der 
                  Datenbank eindeutig sein und nicht mit dem Namen übereinstimmen, der aus der 
                  UDF-Bibliothek über <database>ENTRY_POINT</database>.</entry>
            </row>
            <row valign="middle">
              <entry align="center">entry_point</entry>
              <entry align="left">Der exportierte Name der Funktion</entry>
            </row>
            <row valign="middle">
              <entry align="center">library_name</entry>
              <entry align="left">Der Name des Moduls (<database>MODULE_NAME</database>, aus dem die Funktion 
              exportiert wird. Dies ist der Name der Datei ohne die <quote>.dll</quote> oder 
              <quote>.so</quote>-Dateierweiterung.</entry>
            </row>
            <row valign="middle">
              <entry align="center">sqltype</entry>
              <entry align="left">SQL-Datentyp. Es kann kein Array oder Array-Element sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">length</entry>
              <entry align="left">Die maximale Länge einer nullterminierten Zeichenfolge, angegeben in Bytes</entry>
            </row>
            <row valign="middle">
              <entry align="center">param_num</entry>
              <entry align="left">Die Nummer des Eingabeparameters, von 1 in der Liste der 
                  Eingabeparameter in der Deklaration nummeriert, beschreibt den Datentyp, 
                  der von der Funktion zurückgegeben wird</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DECLARE EXTERNAL FUNCTION</database> stellt eine benutzerdefinierte 
      Funktion in der Datenbank zur Verfügung. UDF-Deklarationen müssen in <emphasis>jeder Datenbank</emphasis> 
      vorgenommen werden, die sie verwenden soll. Es gibt keine Notwendigkeit, UDFs zu deklarieren, die niemals 
      verwendet werden. </para>
      <para> Der Name der externen Funktion muss unter allen Funktionsnamen eindeutig sein. Es kann sich 
          vom exportierten Namen der Funktion unterscheiden, wie im 
          <database>ENTRY_POINT</database>-Argument angegeben.</para>
      <section id="fblangref25-ddl-extfunc-inp-de">
          
      <title><database>DECLARE EXTERNAL FUNCTION</database>-Eingabeparameter</title>
      <para>Die Eingabeparameter der Funktion folgen dem Namen der Funktion und sind durch Kommas getrennt. 
          Für jeden Parameter ist ein SQL-Datentyp angegeben. Arrays können nicht als Funktionsparameter 
          verwendet werden. Neben den SQL-Typen steht der CSTRING-Typ für die Angabe einer nullterminierten 
          Zeichenfolge mit einer maximalen Länge von <database>LENGTH</database> Bytes zur Verfügung.</para>
      <para>Standardmäßig werden Eingabeparameter <emphasis>durch Referenz</emphasis> übergeben. 
      Die <database>BY DESCRIPTOR</database>-Klausel kann stattdessen angegeben werden,
      wenn der Eingabeparameter durch den Deskriptor übergeben wird. Das Übergeben eines Parameters nach 
      Deskriptor ermöglicht die Verarbeitung von <database>NULLs</database>.</para>

      <section id="fblangref25-ddl-extfunc-keywords-de">
        <title>Klauseln und Schlüsselwörter</title>
        <formalpara><title>RETURNS-Klausel</title>
          <para>&nbsp;(Erforderlich) gibt den von der Funktion zurückgegebenen Ausgabeparameter an. 
              Eine Funktion ist skalar: Sie gibt nur einen Parameter zurück. Der Ausgabeparameter kann von 
              einem beliebigen SQL-Typ (außer einem Array oder einem Array-Element) oder einer nullterminierten 
              Zeichenfolge (<database>CSTRING</database>) sein. Der Ausgabeparameter kann durch Referenz (Standard), 
              Deskriptor oder Wert übergeben werden. Wenn die Klausel <database>BY DESCRIPTOR</database> 
              angegeben ist, wird der Ausgabeparameter von Deskriptor übergeben. Wenn die 
              <database>BY VALUE</database>-Klausel angegeben ist, wird der Ausgabeparameter über den Wert übergeben.</para>
        </formalpara>
        <formalpara><title>PARAMETER-Schlüsselwort</title>
          <para>&nbsp;gibt an, dass die Funktion den Wert aus dem Parameter an Stelle
          <emphasis>param_num</emphasis> zurückgibt. Es ist notwendig, wenn Sie einen Wert des Datentyps 
          <database>BLOB</database> zurückgeben müssen.</para>
        </formalpara>
        <formalpara><title>FREE_IT Schlüsselwort</title>
          <para>&nbsp;bedeutet, dass der Speicher, der zum Speichern des Rückgabewerts zugewiesen wurde, 
              freigegeben wird, nachdem die Funktion ausgeführt wurde. Sie wird nur verwendet, wenn der Speicher 
              in der UDF dynamisch zugewiesen wurde. In einer solchen UDF muss der Speicher mit Hilfe der Funktion 
              <function> ib_util_malloc </function> aus dem <filename> ib_util </filename>-Modul zugewiesen werden, 
              was die Kompatibilität mit den im Firebird-Code verwendeten Funktionen und Code der ausgelieferten 
              UDF-Module, zum Zuweisen und Freigeben von Speicher.</para>
        </formalpara>
        <formalpara><title>ENTRY_POINT-Klausel</title>
          <para>&nbsp;gibt den Namen des Einstiegspunkts (den Namen der importierten Funktion) an, der aus dem 
              Modul exportiert wird.</para>
        </formalpara>
        <formalpara><title>MODULE_NAME-Klausel</title>
          <para>&nbsp;Definiert den Namen des Moduls, in dem sich die exportierte Funktion befindet. Der Link zum 
              Modul sollte nicht der vollständige Pfad und die Erweiterung der Datei sein, wenn dies vermieden 
              werden kann. Wenn sich das Modul am Standardspeicherort (im Unterverzeichnis ../UDF des Firebird-Serverstammes) 
              oder an einem in <filename> firebird.conf </filename> explizit konfigurierten Speicherort befindet, 
              ist es einfacher, die Datenbank zwischen verschiedene Plattformen. Der Parameter <emphasis>UDFAccess</emphasis> 
              in der Datei firebird.conf ermöglicht die Konfiguration von Zugriffsbeschränkungen für externe Funktionsmodule.
          </para>
        </formalpara>
      </section><!-- Clauses and keywords -->
    </section> <!-- Parameters -->
    <para>&nbsp;Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine externe Funktion (UDF) deklarieren.</para>

    <formalpara><title>Beispiele zuv Verwendung von DECLARE EXTERNAL FUNCTION</title>
      <orderedlist>
        <listitem>Deklarieren der externen AddDate-Funktion im fbudf-Modul. Die Ein- und Ausgabeparameter 
            werden als Referenz übergeben.
          <programlisting>
DECLARE EXTERNAL FUNCTION addDay
TIMESTAMP, INT
RETURNS TIMESTAMP
ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
        <listitem>Deklaration der externen Invl-Funktion im fbudf-Modul. Die Ein- und Ausgabeparameter 
            werden vom Deskriptor übergeben.
          <programlisting>
DECLARE EXTERNAL FUNCTION invl
INT BY DESCRIPTOR, INT BY DESCRIPTOR
RETURNS INT BY DESCRIPTOR
ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
        <listitem>Declaring the isLeapYear external function located in the fbudf module.
        The input parameter is passed by reference, while the output parameter is passed by value.
          <programlisting>
DECLARE EXTERNAL FUNCTION isLeapYear
TIMESTAMP
RETURNS INT BY VALUE
ENTRY_POINT 'isLeapYear' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
        <listitem>Deklaration der externen Funktion i64Truncate im fbudf-Modul. Die Ein- und 
            Ausgabeparameter werden vom Deskriptor übergeben. Der zweite Parameter der 
            Funktion wird als Rückgabewert verwendet.
          <programlisting>
DECLARE EXTERNAL FUNCTION i64Truncate
NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
RETURNS PARAMETER 2
ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
      </orderedlist>
    </formalpara>
    <formalpara><title>Siehe auch</title>
      <para> <link linkend="fblangref25-ddl-extfunc-alter-de"><database>ALTER EXTERNAL FUNCTION</database></link>,
      <link linkend="fblangref25-ddl-extfunc-drop-de"><database>DROP EXTERNAL FUNCTION</database></link>
      </para>
    </formalpara>
    </section> <!-- Declare external function -->


    <section id="fblangref25-ddl-extfunc-alter-de">
      <title><database>ALTER EXTERNAL FUNCTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Ändern des Eintrittspunkts und / oder des Modulnamens für eine 
            benutzerdefinierte Funktion (UDF)</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER EXTERNAL FUNCTION funcname
[ENTRY_POINT 'new_entry_point']
[MODULE_NAME 'new_library_name'];
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-alterfunc-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER EXTERNAL FUNCTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">funcname</entry>
              <entry align="left">Funktionsname in der Datenbank</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_entry_point</entry>
              <entry align="left">Der neue exportierte Name der Funktion</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_library_name</entry>
              <entry align="left">Der neue Name des Moduls (<database>MODULE_NAME</database>, 
              aus dem die Funktion exportiert wird, ist der Name der Datei ohne die <quote>.dll</quote>-
              oder <quote>.so</quote>-Dateierweiterung.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>ALTER EXTERNAL FUNCTION</database> ändert den Eintrittspunkt 
      und / oder den Modulnamen für eine benutzerdefinierte Funktion (UDF). Vorhandene 
      Abhängigkeiten bleiben erhalten, nachdem die Anweisung mit der Änderung [s] ausgeführt wurde.</para>
      <formalpara>
        <title>Die <database>ENTRY_POINT</database>-Klausel</title>
        <para>&nbsp;dient zur Angabe des neuen Eintrittspunktes (der Name der Funktion, 
            die aus dem Modul exportiert wird).</para>
      </formalpara>
      <formalpara><title>Die <database>MODULE_NAME</database>-Klausel</title>
        <para>&nbsp;Gibt den neuen Namen des Moduls an, in dem sich die exportierte Funktion befindet.</para>
      </formalpara>

      <para>&nbsp;Jeder an die Datenbank angeschlossene Benutzer kann den Eintrittspunkt und den 
          Modulnamen ändern.</para>

      <formalpara>
        <title>Beispiele für die Verwendung von ALTER EXTERNAL FUNCTION</title>
        <orderedlist>
          <listitem>Ändern des Einstiegspunkts für eine externe Funktion
            <programlisting>
ALTER EXTERNAL FUNCTION invl ENTRY_POINT 'intNvl';
            </programlisting>
          </listitem>
          <listitem>Ändern des Modulnamens für eine externe Funktion
            <programlisting>
ALTER EXTERNAL FUNCTION invl MODULE_NAME 'fbudf2';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
    <formalpara><title>Siehe auch</title>
      <para> <link linkend="fblangref25-ddl-extfunc-declare-de"><database>DECLARE EXTERNAL FUNCTION</database></link>,
      <link linkend="fblangref25-ddl-extfunc-drop-de"><database>DROP EXTERNAL FUNCTION</database></link>
      </para>
    </formalpara>
    </section><!-- Alter external function -->

    <section id="fblangref25-ddl-extfunc-drop-de">
      <title><database>DROP EXTERNAL FUNCTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Entfernen einer benutzerdefinierten Funktion (UDF) aus einer Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP EXTERNAL FUNCTION funcname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropfunc-de">
      <?dbfo keep-together='auto'?>
        <title>DROP EXTERNAL FUNCTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">funcname</entry>
              <entry align="left">Funktionsname in der Datenbank</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP EXTERNAL FUNCTION</database> löscht die Deklaration 
      einer benutzerdefinierten Funktion aus der Datenbank. Wenn es Abhängigkeiten von der externen 
      Funktion gibt, schlägt die Anweisung fehl und der entsprechende Fehler wird ausgelöst.</para>

      <para>&nbsp;Jeder mit der Datenbank verbundene Benutzer kann die Deklaration 
          einer internen Funktion löschen.</para>

      <formalpara>
        <title>Beispiel der Verwendung von DROP EXTERNAL FUNCTION</title>
        <para>&nbsp;Löschen der Deklaration der addDay-Funktion.
          <blockquote><programlisting>
DROP EXTERNAL FUNCTION addDay;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-extfunc-declare-de"><database>DECLARE EXTERNAL FUNCTION</database></link>
        </para>
      </formalpara>
    </section><!-- Drop external function -->
  </section><!-- External function -->

  <section id="fblangref25-ddl-filter-de">
    <title><database>FILTER</database></title>
    <para> Ein <database>BLOB FILTER</database>-Filter ist ein Datenbankobjekt, das eigentlich ein spezieller Typ einer 
    externen Funktion ist, mit dem alleinigen Zweck, ein <database>BLOB</database>-Objekt in einem 
    Format zu verwenden und es zu konvertieren zu einem <database>BLOB</database>-Objekt in einem 
    anderen Format. Die Formate der <database>BLOB</database>-Objekte werden mit benutzerdefinierten 
    <database>BLOB</database>-Subtypen angegeben. </para>
     <para>Externe Funktionen zum Konvertieren von <database>BLOB</database>-Typen werden in dynamischen 
     Bibliotheken gespeichert und bei Bedarf geladen. </para>
     <para>Weitere Informationen zu <database>BLOB</database>-Subtypen finden Sie unter 
     <link linkend="fblangref25-datatypes-bnrytypes-de"> Binäre Datentypen</link>.</para>
    
    <section id="fblangref25-ddl-filter-declare-de">
      <title><database>DECLARE FILTER</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Deklarieren eines <database>BLOB</database>-Filters zur Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DECLARE FILTER filtername
INPUT_TYPE &lt;sub_type&gt; OUTPUT_TYPE &lt;sub_type&gt;
ENTRY_POINT 'function_name' MODULE_NAME 'library_name';

&lt;sub_type&gt; ::= number | &lt;mnemonic&gt;

&lt;mnemonic&gt; ::= binary | text | blr | acl | ranges
             | summary | format | transaction_description
             | external_file_description | user_defined
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-declarefiltr-de">
      <?dbfo keep-together='auto'?>
        <title>DECLARE FILTER Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">filtername</entry>
              <entry align="left">Name des Filters in der Datenbank. Es kann aus bis zu 31 
                  Zeichen bestehen. Es muss nicht derselbe Name sein, wie der aus der 
                  Filterbibliothek via <database>ENTRY_POINT</database> geholt wird.</entry>
            </row>
            <row valign="middle">
              <entry align="center">sub_type</entry>
              <entry align="left"><database>BLOB</database>-Subtype</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left"><database>BLOB SUB_TYPE</database>-Nummer (muss negativ sein)</entry>
            </row>
            <row valign="middle">
              <entry align="center">mnemonic</entry>
              <entry align="left"><database>BLOB SUB_TYPE</database> mnemonischer Name</entry>
            </row>
            <row valign="middle">
              <entry align="center">function_name</entry>
              <entry align="left">Der exportierte Name (Einstiegspunkt) der Funktion</entry>
            </row>
            <row valign="middle">
              <entry align="center">library_name</entry>
              <entry align="left">Der Name des Moduls, in dem sich der Filter befindet</entry>
            </row>
            <row valign="middle">
              <entry align="center">user_defined</entry>
              <entry align="left">Benutzerdefinierter <database>BLOB SUB_TYPE</database> mnemonischer Name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Mit der Anweisung <database>DECLARE FILTER</database> wird ein <database>BLOB</database>-Filter 
        für die Datenbank verfügbar. Der Name des <database>BLOB</database>-Filters muss unter den Namen 
        von <database>BLOB</database>-Filtern eindeutig sein.</para>
      <section id="fblangref25-ddl-filter-subtype-de">
        <title>Spezifizieren der Subtypen</title>
        <para>Die Subtypen können als Untertypnummer oder als Subtyp-Mnemonikname angegeben werden. Benutzerdefinierte 
            Subtypen müssen durch negative Zahlen (von -1 bis -32.768) dargestellt werden. Ein Versuch, mehr als 
            einen <database>BLOB</database>-Filter mit derselben Kombination der Ein- und Ausgabetypen zu 
            deklarieren, schlägt mit einem Fehler fehl.
          <formalpara>
            <title>INPUT_TYPE</title>
            <para>&nbsp;Klausel, die den <database>BLOB</database>-Subtyp des zu konvertierenden Objekts definiert</para>
          </formalpara>
          <formalpara>
            <title>OUTPUT_TYPE</title>
            <para>&nbsp;Klausel definiert den <database>BLOB</database>-Subtyp des zu erstellenden Objekts.</para>
          </formalpara>
        </para>
      </section>
      <note>
        <para>Mnemonische Namen können für benutzerdefinierte <database>BLOB</database>-Subtypen definiert 
            und manuell in die Systemtabelle <database>RDB$TYPES</database> eingefügt werden.
          <programlisting>
       INSERT INTO RDB$TYPES (RDB$FIELD_NAME, RDB$TYPE, RDB$TYPE_NAME)
       VALUES ('RDB$FIELD_SUB_TYPE', -33, 'MIDI');
          </programlisting>
          Nachdem die Transaktion bestätigt wurde, können die mnemonischen Namen in Deklarationen verwendet 
          werden, wenn Sie neue Filter erstellen.</para>

        <para>Der Wert der Spalte RDB$FIELD_NAME muss immer 'RDB$FIELD_SUB_TYPE' sein. 
            Bei mnemonischen Namen in Großbuchstaben können sie bei der Definition eines 
            Filters case-insensitiv und ohne Anführungszeichen verwendet werden.</para>
        <formalpara><title>Warning</title>
          <para>&nbsp;Ab Firebird 3 sind die Systemtabellen nicht mehr von Benutzern beschreibbar.</para>
        </formalpara>
      </note>

      <section id="fblangref25-ddl-filter-params-de">
        <title>Parameters</title>
        <formalpara>
          <title>ENTRY_POINT</title>
          <para>&nbsp;Klausel, die den Namen des Einstiegspunkts (den Namen der importierten 
              Funktion) im Modul definiert.</para>
        </formalpara>
        <formalpara>
          <title>MODULE_NAME</title>
          <para>&nbsp;Die Klausel definiert den Namen des Moduls, in dem sich die exportierte 
              Funktion befindet. Standardmäßig müssen sich die Module im UDF-Ordner des Stammverzeichnisses 
              auf dem Server befinden. Der Parameter <emphasis>UDFAccess</emphasis> in <filename> firebird.conf </filename> 
              ermöglicht das Bearbeiten von Zugriffsbeschränkungen für Filterbibliotheken.</para>
          <blockquote>
            <para>* * * * * * * * * * * * * * * * * * * * *</para>
          </blockquote>
        </formalpara>
      </section>
      <para>&nbsp;Jeder Benutzer, der mit der Datenbank verbunden ist, kann einen BLOB-Filter deklarieren.</para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Erstellen eines BLOB-Filters mit Subtypnummern.
            <programlisting>
DECLARE FILTER DESC_FILTER
INPUT_TYPE 1
OUTPUT_TYPE -4
ENTRY_POINT 'desc_filter'
MODULE_NAME 'FILTERLIB';
            </programlisting>
          </listitem>
          <listitem>Erstellen eines BLOB-Filters mit Untertyp-Mnemoniknamen.
            <programlisting>
DECLARE FILTER FUNNEL
INPUT_TYPE blr OUTPUT_TYPE text
ENTRY_POINT 'blr2asc' MODULE_NAME 'myfilterlib';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-extfunc-drop-de"><database>DROP FILTER</database></link>
        </para>
      </formalpara>
    </section><!-- Declare Filter -->

    <section id="fblangref25-ddl-filter-drop-de">
      <title><database>DROP FILTER</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Entfernen einer <database>BLOB</database>-Filterdeklaration aus der Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP FILTER filtername;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-dropfiltr-de">
      <?dbfo keep-together='auto'?>
        <title>DROP FILTER Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">filtername</entry>
              <entry align="left">Filtername in der Datenbank</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP FILTER</database> entfernt die Deklaration eines 
        <database>BLOB</database>-Filters aus der Datenbank. Wenn Sie einen <database>BLOB</database>-Filter 
        aus einer Datenbank entfernen, kann er für diese Datenbank nicht mehr verwendet werden. Die dynamische 
        Bibliothek, in der sich die Konvertierungsfunktion befindet, bleibt erhalten und das Entfernen aus 
        einer Datenbank hat keine Auswirkungen auf andere Datenbanken, in denen derselbe 
        <database>BLOB</database>-Filter noch deklariert ist.</para>

      <para>&nbsp;Jeder Benutzer, der mit der Datenbank verbunden ist, kann einen BLOB-Filter löschen.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Löschen eines BLOB-Filters.
          <blockquote><programlisting>
DROP FILTER DESC_FILTER;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-extfunc-declare-de"><database>DECLARE FILTER</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop filter -->
  </section> <!-- Filters -->

  <section id="fblangref25-ddl-sequence-de">
    <title><database>SEQUENCE (GENERATOR)</database></title>
    <para>Eine Sequenz oder ein Generator ist ein Datenbankobjekt, das verwendet wird, 
        um eindeutige Zahlenwerte zu erhalten, um eine Reihe zu füllen. <quote>Sequenz</quote> ist 
        der SQL-konforme Begriff für das gleiche Ding, das in Firebird traditionell als 
        <quote>Generator</quote> bekannt ist. Beide Begriffe sind in Firebird implementiert. 
        Für beide Terme ist eine Syntax implementiert.</para>
    <para>Sequenzen (oder Generatoren) werden immer als 64-Bit-Ganzzahlen gespeichert, 
        unabhängig vom SQL-Dialekt der Datenbank.
      <caution>
        <para>Wenn ein Client mit Dialekt 1 verbunden ist, sendet der Server Sequenzwerte 
            als 32-Bit-Ganzzahlen an ihn. Das Übergeben eines Sequenzwerts an ein 32-Bit-Feld 
            oder eine Variable führt nicht zu Fehlern, solange der aktuelle Wert der Sequenz die Grenzen 
            einer 32-Bit-Zahl nicht überschreitet. Sobald jedoch der Sequenzwert diese Grenze überschreitet, 
            erzeugt die Datenbank in Dialekt 3 einen Fehler. Eine Datenbank in Dialekt 1 wird weiterhin die 
            Werte beschneiden, was die Einzigartigkeit der Serie beeinträchtigt.</para>
      </caution>
    </para>
    <para>In diesem Abschnitt wird beschrieben, wie Sequenzen erstellt, festgelegt und gelöscht werden.</para>

    <section id="fblangref25-ddl-sequence-create-de">
      <title><database>CREATE SEQUENCE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Erstellen einer neuen <database>SEQUENCE (GENERATOR)</database></para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE {SEQUENCE | GENERATOR} seq_name
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-crtseq-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE SEQUENCE | CREATE GENERATOR Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Name der Sequenz (Generator). Diese kann aus bis zu 31 Zeichen bestehen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisungen <database>CREATE SEQUENCE</database> und <database>CREATE GENERATOR</database> sind 
        Synonyme &mdash; beide erzeugen eine neue Sequenz. Jede kann verwendet werden, jedoch wird 
        <database>CREATE SEQUENCE</database> empfohlen, sofern die normkonforme Metadatenverwaltung wichtig ist.
      </para>

      <para>Wenn eine Sequenz erstellt wird, wird ihr Wert auf 0 gesetzt. Jedes Mal, wenn der 
          <database><link linkend="fblangref25-commons-conditional-nxtvlufor-de"> NEXT VALUE FOR seq_name</link></database>
          wird der Wert um 1 erhöht. Die <database>GEN_ID(seq_name, &lt;step&gt;)</database>-Funktion kann stattdessen 
          aufgerufen werden, um die Reihe durch eine andere Ganzzahl zu erhöhen oder zu reduzieren.
      </para>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Sequenz (Generator) erstellen.</para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Erstellen der EMP_NO_GEN-Sequenz mittels <database>CREATE SEQUENCE</database>.
            <programlisting>
CREATE SEQUENCE EMP_NO_GEN;
            </programlisting>
          </listitem>
          <listitem>Erstellen der EMP_NO_GEN-Sequenz mittels <database>CREATE GENERATOR</database>.
            <programlisting>
CREATE GENERATOR EMP_NO_GEN;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-sequence-alter-de"><database>ALTER SEQUENCE</database></link>,
        <link linkend="fblangref25-ddl-sequence-setgen-de"><database>SET GENERATOR</database></link>,
        <link linkend="fblangref25-ddl-sequence-drop-de"><database>DROP SEQUENCE (GENERATOR)</database></link>,
        <link linkend="fblangref25-commons-conditional-nxtvlufor-de"><database>NEXT VALUE FOR</database></link>,
        <link linkend="fblangref25-functions-scalarfuncs-gen_id-de"><database>GEN_ID() function</database></link>
        </para>
      </formalpara>
    </section> <!-- Create sequence -->

    <section id="fblangref25-ddl-sequence-alter-de">
      <title><database>ALTER SEQUENCE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Festlegen des Werts einer Sequenz oder eines Generators auf einen bestimmten Wert</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER SEQUENCE seq_name RESTART WITH new_val
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-alterseq-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER SEQUENCE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Name der Sequenz (Generator)</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_val</entry>
              <entry align="left">Neuer Sequenzwert (Generatorwert). Eine 64-Bit-Ganzzahl
              von -2<superscript>-63</superscript> bis 2<superscript>63</superscript>-1.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Mit der Anweisung <database>ALTER SEQUENCE</database> wird der aktuelle Wert einer 
      Sequenz oder eines Generators auf den angegebenen Wert gesetzt.
        <warning>
          <para>Die falsche Verwendung der <database>ALTER SEQUENCE</database>-Anweisung 
              (Ändern des aktuellen Werts der Sequenz oder des Generators) kann die logische Integrität 
                von Daten beeinträchtigen.</para>
        </warning>
      </para>
      <para>Jeder an die Datenbank angeschlossene Benutzer kann den Sequenzwert (Generator) festlegen.</para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Festlegen des Werts der EMP_NO_GEN-Sequenz auf 145.
            <programlisting>
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
            </programlisting>
          </listitem>
          <listitem>Das gleiche Prozedere unter Verwendung von <database>SET GENERATOR</database>:
            <programlisting>
SET GENERATOR EMP_NO_GEN TO 145;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-sequence-setgen-de"><database>SET GENERATOR</database></link>,
        <link linkend="fblangref25-ddl-sequence-create-de"><database>CREATE SEQUENCE (GENERATOR)</database></link>,
        <link linkend="fblangref25-ddl-sequence-drop-de"><database>DROP SEQUENCE (GENERATOR)</database></link>,
        <link linkend="fblangref25-commons-conditional-nxtvlufor-de"><database>NEXT VALUE FOR</database></link>,
        <link linkend="fblangref25-functions-scalarfuncs-gen_id-de"><database>GEN_ID() function</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter sequence -->

    <section id="fblangref25-ddl-sequence-setgen-de">
      <title><database>SET GENERATOR</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Festlegen des Werts einer Sequenz oder eines Generators auf einen bestimmten Wert</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
SET GENERATOR seq_name TO new_val
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-setgen-de">
      <?dbfo keep-together='auto'?>
        <title>SET GENERATOR Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Name des Generators (Sequenz)</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_val</entry>
              <entry align="left">Neuer Sequenzwert (Generatorwert). Eine 64-Bit-Ganzzahl
              von -2<superscript>-63</superscript> bis 2<superscript>63</superscript>-1.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Mit der Anweisung <database>SET GENERATOR</database> wird der aktuelle Wert 
      einer Sequenz oder eines Generators auf den angegebenen Wert gesetzt.</para>
      <note>
        <para>Obwohl <database>SET GENERATOR</database> als veraltet gilt, 
        wird es aus Gründen der Abwärtskompatibilität beibehalten. Die standardkonforme 
        Anweisung <database>ALTER SEQUENCE</database> ist aktuell und wird empfohlen.</para>
      </note>

      <para>Jeder an die Datenbank angeschlossene Benutzer kann den Sequenzwert (Generator) festlegen.</para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Einstellen des Werts der EMP_NO_GEN-Sequenz auf 145:
            <programlisting>
SET GENERATOR EMP_NO_GEN TO 145;
            </programlisting>
          </listitem>
          <listitem>Das gleiche Prozedere unter Verwendung von <database>ALTER SEQUENCE</database>:
            <programlisting>
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para> <link linkend="fblangref25-ddl-sequence-alter-de"><database>ALTER SEQUENCE</database></link>,
        <link linkend="fblangref25-ddl-sequence-create-de"><database>CREATE SEQUENCE (GENERATOR)</database></link>
        </para>
      </formalpara>
    </section> <!-- Set Generator -->

    <section id="fblangref25-ddl-sequence-drop-de">
      <title><database>DROP SEQUENCE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Löschen von <database>SEQUENCE (GENERATOR)</database></para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP {SEQUENCE | GENERATOR} seq_name
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropseq-de">
      <?dbfo keep-together='auto'?>
        <title>DROP SEQUENCE | DROP GENERATOR Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Name der Sequenz (Generator). Kann aus bis zu 31 Zeichen bestehen.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisungen <database>DROP SEQUENCE</database> und <database>DROP GENERATOR</database> 
      sind gleichwertig: Beide löschen eine vorhandene Sequenz (Generator). Beide sind gültig, jedoch
      wird <database>DROP SEQUENCE</database> empfohlen.</para>
      <para>Die Anweisungen schlagen fehl, wenn die Sequenz (Generator) Abhängigkeiten hat.</para>

      <para>Jeder an die Datenbank angeschlossene Benutzer kann eine Sequenz (Generator) löschen.</para>

      <formalpara>
        <title>Beispiele</title>
        <para>&nbsp;Löschen der EMP_NO_GEN-Sequenz:
            <blockquote><programlisting>
DROP SEQUENCE EMP_NO_GEN;
            </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-sequence-create-de"><database>CREATE SEQUENCE (GENERATOR</database></link>,
        <link linkend="fblangref25-ddl-sequence-alter-de"><database>ALTER SEQUENCE</database></link>,
        <link linkend="fblangref25-ddl-sequence-setgen-de"><database>SET GENERATOR</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop sequence -->
  </section> <!-- sequence / generator -->

  <section id="fblangref25-ddl-exception-de">
    <title><database>EXCEPTION</database></title>
    <para>In diesem Abschnitt wird beschrieben, wie <firstterm> benutzerdefinierte Ausnahmen </firstterm> 
    zur Verwendung in Fehlerbehandlungsroutinen in PSQL-Modulen erstellt, geändert und gelöscht 
    werden.
    </para>

    <section id="fblangref25-ddl-exception-create-de">
      <title><database>CREATE EXCEPTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Erstellen einer neuen Ausnahme für die Verwendung in PSQL-Modulen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-crtexcep-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE EXCEPTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme. Die maximale Länge beträgt 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Standardfehlermeldung. Die maximale Länge beträgt 1.021 Zeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE EXCEPTION</database> erstellt eine neue Ausnahme zur Verwendung 
          in PSQL-Modulen. Wenn eine Ausnahme desselben Namens existiert, schlägt die Anweisung mit einer 
          entsprechenden Fehlermeldung fehl.</para>
      <para>Der Name der Ausnahme ist eine Standardkennung. In einer Dialekt 3-Datenbank kann sie in doppelte 
          Anführungszeichen eingeschlossen werden, um Groß- und Kleinschreibung zu berücksichtigen und 
          bei Bedarf Zeichen zu verwenden, die in regulären Bezeichnern nicht gültig sind. Weitere Informationen 
          finden Sie unter <link linkend="fblangref25-structure-identifiers-de"> Bezeichner</link>.
      </para>
      <para>Die Standardnachricht wird im Zeichensatz <database>NONE</database> gespeichert, d.h. In 
          Zeichen eines Einbytezeichensatzes. Der Text kann im PSQL-Code überschrieben werden, 
          wenn die Ausnahme ausgelöst wird.</para>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahme erstellen.</para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Erstellen einer Ausnahme mit dem Namen E_LARGE_VALUE:
            <programlisting>
CREATE EXCEPTION E_LARGE_VALUE
       'The value is out of range';
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Ausnahme mit dem Namen ERROR_REFIN_RATE:
            <programlisting>
CREATE EXCEPTION ERROR_REFIN_RATE
  'Error detected in the spread of discount rates';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <tip>
        <title>Tipps</title>
        <para>Die Zusammenfassung von <database>CREATE EXCEPTION</database>-Anweisungen in 
        Systemaktualisierungsskripts vereinfacht die Arbeit mit ihnen und dokumentiert sie. 
        Ein System von Präfixen zum Benennen und Kategorisieren von Gruppen von Ausnahmen wird empfohlen. </para> 
        <para>Benutzerdefinierte Ausnahmen werden in der Systemtabelle gespeichert
        <link linkend="fblangref-appx04-exceptions-de"><database>RDB$EXCEPTIONS</database></link>.
        </para>
      </tip>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-alter-de"><database>ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-crtalter-de"><database>CREATE OR ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-drop-de"><database>DROP EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate-de"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Create exception -->

    <section id="fblangref25-ddl-exception-alter-de">
      <title><database>ALTER EXCEPTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Ändern der Nachricht, die von einer benutzerdefinierten Ausnahme zurückgegeben wird</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-altrexcep-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER EXCEPTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Neue Standardfehlermeldung. Die maximale Länge beträgt 1.021 Zeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>ALTER EXCEPTION</database> kann jederzeit verwendet werden, um den 
          Standardtext der Nachricht zu ändern. Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine 
          Ausnahmemeldung ändern.</para>
      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Ändern der Standardnachricht für die Ausnahme E_LARGE_VALUE:
            <programlisting>
ALTER EXCEPTION E_LARGE_VALUE
       'The value exceeds the prescribed limit of 32,765 bytes';
            </programlisting>
          </listitem>
          <listitem>Ändern der Standardnachricht für die Ausnahme ERROR_REFIN_RATE:
            <programlisting>
ALTER EXCEPTION ERROR_REFIN_RATE 'Rate is outside the allowed range';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create-de"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-crtalter-de"><database>CREATE OR ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-drop-de"><database>DROP EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate-de"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter exception -->

    <section id="fblangref25-ddl-exception-crtalter-de">
      <title><database>CREATE OR ALTER EXCEPTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Ändern der Nachricht, die von einer benutzerdefinierten Ausnahme zurückgegeben wird, wenn 
            die Ausnahme existiert; andernfalls erstellen Sie eine neue Ausnahme</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-crtaltrexcep-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE OR ALTER EXCEPTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Fehlermeldung. Die maximale Länge ist auf 1.021 Zeichen begrenzt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE ODER ALTER EXCEPTION</database> wird verwendet, um die angegebene 
      Ausnahme zu erstellen, falls sie nicht existiert, oder um den Text der von ihr zurückgegebenen 
      Fehlermeldung zu ändern. Wenn eine vorhandene Ausnahme durch diese Anweisung geändert wird, 
      bleiben vorhandene Abhängigkeiten erhalten. </para>
      <para> Jeder Benutzer, der mit der Datenbank verbunden ist, kann diese Anweisung verwenden, um eine 
          Ausnahme zu erstellen oder den bereits vorhandenen Text zu ändern.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Nachricht für die Ausnahme ändern E_LARGE_VALUE:
            <blockquote><programlisting>
CREATE OR ALTER EXCEPTION E_LARGE_VALUE
       'The value is higher than the permitted range 0 to 32,765';
            </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create-de"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-alter-de"><database>ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate-de"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Create or alter exception -->

    <section id="fblangref25-ddl-exception-drop-de">
      <title><database>DROP EXCEPTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Löschen einer benutzerdefinierten Ausnahme</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP EXCEPTION exception_name
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropexcep-de">
      <?dbfo keep-together='auto'?>
        <title>DROP EXCEPTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP EXCEPTION</database> wird zum Löschen einer Ausnahme 
      verwendet. Alle Abhängigkeiten von der Ausnahme führen dazu, dass die Anweisung 
      fehlschlägt und nicht gelöscht wird.</para>
      <para>Wenn eine Ausnahme nur in gespeicherten Prozeduren verwendet wird, kann sie jederzeit 
          gelöscht werden. Wenn es in einem Auslöser verwendet wird, kann es nicht gelöscht werden.</para>
      <para>Bei der Planung, eine Ausnahme zu löschen, sollten alle Verweise darauf aus dem Code der 
          gespeicherten Prozeduren entfernt werden, um zu vermeiden, dass die Abwesenheit Fehler 
          verursacht.</para>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahme löschen.</para>

      <formalpara>
        <title>Beispiele</title>
        <orderedlist>
          <listitem>Ausnahme löschen ERROR_REFIN_RATE:
            <programlisting>
DROP EXCEPTION ERROR_REFIN_RATE;
            </programlisting>
          </listitem>
          <listitem>Ausnahme löschen E_LARGE_VALUE:
            <programlisting>
DELETE EXCEPTION E_LARGE_VALUE;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create-de"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate-de"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop exception -->

    <section id="fblangref25-ddl-exception-recreate-de">
      <title><database>RECREATE EXCEPTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Eine neue benutzerdefinierte Ausnahme oder eine bestehende erstellen</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-recrtexcep-de">
      <?dbfo keep-together='auto'?>
        <title>RECREATE EXCEPTION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme. Die maximale Länge beträgt 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Fehlermeldung. Die maximale Länge ist auf 1.021 Zeichen begrenzt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>RECREATE EXCEPTION</database> erstellt eine neue Ausnahme für die 
        Verwendung in PSQL-Modulen. Wenn bereits eine Exception mit demselben Namen existiert, versucht die 
        Anweisung <database>RECREATE EXCEPTION</database>, diese zu löschen und eine neue zu erstellen. 
        Wenn es Abhängigkeiten zur bestehenden Ausnahme gibt, schlägt die versuchte Löschung fehl und 
        <database>RECREATE EXCEPTION</database> wird nicht ausgeführt.
      </para>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahme erstellen.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Wiederherstellen der Ausnahme E_LARGE_VALUE:
            <blockquote><programlisting>
RECREATE EXCEPTION E_LARGE_VALUE 
       'The value exceeds its limit';
            </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create-de"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-drop-de"><database>DROP EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-crtalter-de"><database>CREATE OR ALTER EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Recreate exception -->
  </section> <!-- Exception -->

  <section id="fblangref25-ddl-collation-de">
    <title><database>COLLATION</database></title>
    <para></para>

    <section id="fblangref25-ddl-collation-create-de">
      <title><database>CREATE COLLATION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Erstellen einer neuen Sortierung für einen unterstützten Zeichensatz, 
            der für die Datenbank verfügbar ist</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE COLLATION collname
FOR charset
[FROM basecoll | FROM EXTERNAL ('extname')]
[NO PAD | PAD SPACE]
[CASE [IN]SENSITIVE]
[ACCENT [IN]SENSITIVE]
['&lt;specific-attributes&gt;'];

&lt;specific-attributes&gt; ::= &lt;attribute&gt; [; &lt;attribute&gt; ...]

&lt;attribute&gt; ::= attrname=attrvalue
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-collatcrt-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE COLLATION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">collname</entry>
              <entry align="left">Der Name, der für die neue Collation verwendet werden soll. 
                  Die maximale Länge beträgt 31 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Ein in der Datenbank vorhandener Zeichensatz</entry>
            </row>
            <row valign="middle">
              <entry align="center">basecoll</entry>
              <entry align="left">Eine bereits in der Datenbank vorhandene Collation</entry>
            </row>
            <row valign="middle">
              <entry align="center">extname</entry>
              <entry align="left">Der in der Datei <filename>.conf</filename> verwendete Collation-Name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE COLLATION</database> <quote>erzeugt</quote> nichts: Sie dient dazu, 
      eine Datenbank-Collation bekannt zu machen. Die Collation muss bereits auf dem System vorhanden sein, 
      normalerweise in einer Bibliotheksdatei und muss ordnungsgemäß in einer <filename> .conf </filename>-Datei 
      im Unterverzeichnis <filename> intl </filename> der Firebird-Installation registriert sein. </para> 
      <para> Die Collation kann alternativ auf einer basieren, die bereits in der Datenbank vorhanden ist.</para>
      <section id="fblangref25-ddl-collation-createhow-de">
        <title>Wie die Engine die Collation erkennt</title>
        <para>Wenn keine <database>FROM</database>-Klausel vorhanden ist, scannt Firebird die 
        <filename> .conf </filename>-Dateien im <filename> intl </filename>-Unterverzeichnis nach einer Collation 
        mit dem Namen, der als Objekt mit <database>CREATE COLLATION</database> gesetzt wurde. 
        Anders ausgedrückt, das Weglassen der <database>FROM basecoll</database>-Klausel entspricht der Angabe 
        von <database>FROM EXTERNAL ('collname')</database>.</para>
        <para>Bei der Angabe von <replaceable> 'extname' </replaceable> muss die Groß- / Kleinschreibung beachtet werden 
        und sie muss genau mit dem Collations-Namen in der Datei <filename> .conf </filename> übereinstimmen. 
        Bei den Parametern <replaceable> Collname </replaceable>, <replaceable> Zeichensatz </replaceable> und 
        <replaceable> basecoll </replaceable> wird zwischen Groß- und Kleinschreibung unterschieden, sofern sie 
        nicht in doppelten Anführungszeichen eingeschlossen sind.</para>
      </section>

      <section id="fblangref25-ddl-collation-specatt-de">
        <title>Spezifische Attribute</title>
        <para>Die verfügbaren spezifischen Attribute sind in der folgenden Tabelle aufgeführt. 
            Nicht alle spezifischen Attribute gelten für jede Collation auch wenn sie nicht 
            durch einen Fehler verursacht werden.
        <important>
          <para>Spezifische Attribute unterscheiden Groß- und Kleinschreibung.</para>
        </important>
        In der Tabelle zeigt <quote>1 bpc</quote> an, dass ein Attribut für Collationen 
        von Zeichensätzen mit 1 Byte pro Zeichen (sogenannte enge Zeichensätze) gültig ist. 
        <quote>UNI</quote> steht für <quote>UNICODE Collationen</quote>.
        </para>

        <table id="fblangref25-ddl-tbl-specific-colls-de">
        <?dbfo keep-together='auto'?>
          <title>Spezifische Collations-Attribute</title>
          <tgroup cols="4">
            <colspec colname="colAttr" colwidth="2*"></colspec>
            <colspec colname="colVals" colwidth="1*"></colspec>
            <colspec colname="colValidFor" colwidth="1*"></colspec>
            <colspec colname="colComment" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Atrribute</entry>
                <entry align="center">Wert</entry>
                <entry align="center">Gültig für</entry>
                <entry align="center">Kommentar</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">DISABLE-COMPRESSIONS</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Deaktiviert Komprimierungen (a.k.a. Kontraktionen). 
                    Komprimierungen bewirken, dass bestimmte Zeichenfolgen als atomare 
                    Einheiten sortiert werden, z.B. spanisch c + h als einzelner Buchstabe ch</entry>
              </row>
              <row valign="middle">
                <entry align="center">DISABLE-EXPANSIONS</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Deaktiviert Erweiterungen. Erweiterungen bewirken, dass 
                    bestimmte Zeichen (z. B. Ligaturen oder umlautete Vokale) als 
                    Zeichenfolgen behandelt und entsprechend sortiert werden</entry>
              </row>
              <row valign="middle">
                <entry align="center">ICU-VERSION</entry>
                <entry align="center">default oder H.U</entry>
                <entry align="center">UNI</entry>
                <entry align="left">Gibt die zu verwendende ICU-Bibliotheksversion an. 
                    Gültige Werte sind diejenigen, die im anwendbaren Element &lt;intl_module&gt; 
                    in <filename> intl / fbintl.conf </filename>. Format: entweder das 
                    Stringliteral <quote>default</quote> oder eine Hauptversion + Unterversion 
                    wie <quote>3.0</quote> (beide nicht angegeben).
                    </entry>
              </row>
              <row valign="middle">
                <entry align="center">LOCALE</entry>
                <entry align="center">xx_YY</entry>
                <entry align="center">UNI</entry>
                <entry align="left">Gibt das Sortierungskriterium an. Benötigt eine vollständige 
                    Version von ICU-Bibliotheken. Format: eine Gebietsschema-Zeichenfolge 
                    wie <quote>du_NL</quote> (nicht angegeben)</entry>
              </row>
              <row valign="middle">
                <entry align="center">MULTI-LEVEL</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Verwendet mehr als eine Sortierebene</entry>
              </row>
              <row valign="middle">
                <entry align="center">NUMERIC-SORT</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">UNI</entry>
                <entry align="left">Behandelt zusammenhängende Gruppen von Dezimalziffern 
                    in der Zeichenfolge als atomare Einheiten und sortiert sie numerisch. 
                    (Dies ist auch als natürliche Sortierung bekannt)</entry>
              </row>
              <row valign="middle">
                <entry align="center">SPECIALS-FIRST</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Ordnet Sonderzeichen (Leerzeichen, Symbole etc.) vor 
                    alphanumerischen Zeichen</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <tip>
          <para>Deklarieren Sie die gespeicherte Prozedur 
              <function> sp_register_character_set (name, max_bytes_per_character) </function>, 
              die Sie in <filename> misc / intl.sql / </filename> im Firebird-Installationsverzeichnis. </para>
              <para><command>Hinweis:</command> Damit dies funktioniert, muss der Zeichensatz auf dem 
              System vorhanden und in einer <filename> .conf </filename> im Unterverzeichnis <filename> intl </filename>
              liegen.</para>
        </tip>
      </section> <!-- collation attributes -->

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann 
          <database>CREATE COLLATION</database> verwenden, um eine neue Collation hinzuzufügen.</para>

      <formalpara>
        <title>Beispiele für die Verwendung von CREATE COLLATION</title>
        <orderedlist>
          <listitem>Erstellen einer Collation mit dem in der Datei <filename> fbintl.conf </filename> 
          enthaltenen Namen (Groß- und Kleinschreibung beachten).
            <programlisting>
CREATE COLLATION ISO8859_1_UNICODE FOR ISO8859_1;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Collation, mithilfe eines speziellen (benutzerdefinierten) 
              Namens (der <quote>externe</quote> Name muss vollständig mit dem Namen 
              in der Datei <filename> fbintl.conf </filename> übereinstimmen).
            <programlisting>
CREATE COLLATION LAT_UNI
FOR ISO8859_1
FROM EXTERNAL ('ISO8859_1_UNICODE');
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Collation, die Groß- und Kleinschreibung nicht berücksichtigt
              und auf einer bereits in der Datenbank vorhandenen basiert.
            <programlisting>
CREATE COLLATION ES_ES_NOPAD_CI
FOR ISO8859_1
FROM ES_ES
NO PAD
CASE INSENSITIVE;
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Collation, die Groß- und Kleinschreibung nicht berücksichtigt
              und auf einer bereits in der Datenbank vorhandenen basiert. Angabe spezifischer
              Attribute.
            <programlisting>
CREATE COLLATION ES_ES_CI_COMPR
FOR ISO8859_1
FROM ES_ES
CASE INSENSITIVE
'DISABLE-COMPRESSIONS=0';
            </programlisting>
          </listitem>
          <listitem>Erstellen einer Collation, die Groß- und Kleinschreibung nicht berücksichtigt
              durch Verwendung von Zahlen (die sogenannte natürliche Collation).
            <programlisting>
CREATE COLLATION nums_coll FOR UTF8
FROM UNICODE
CASE INSENSITIVE 'NUMERIC-SORT=1';

CREATE DOMAIN dm_nums AS varchar(20)
CHARACTER SET UTF8 COLLATE nums_coll; -- original (manufacturer) numbers

CREATE TABLE wares(id int primary key, articul dm_nums ...);
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para><link linkend="fblangref25-ddl-collation-drop-de"><database>DROP COLLATION</database></link>
        </para>
      </formalpara>
    </section><!-- Create collation -->

    <section id="fblangref25-ddl-collation-drop-de">
      <title><database>DROP COLLATION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Löschen einer Collation aus der Datenbank</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP COLLATION collname
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-collatdrp-de">
      <?dbfo keep-together='auto'?>
        <title>DROP COLLATION Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">collname</entry>
              <entry align="left">Name der Collation</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DROP COLLATION</database> entfernt die 
      angegebene Collation aus der Datenbank, falls vorhanden. Ein Fehler wird ausgelöst, 
      wenn die angegebene Collation nicht vorhanden ist.</para>
      <tip>
        <para>
            Deklarieren und führen Sie die gespeicherte Prozedur 
            <function> sp_unregister_character_set (name) </function> aus dem Unterverzeichnis 
            <filename> misc / intl.sql </filename> der Firebird-Installation aus, wenn Sie einen ganzen Zeichensatz 
            mit allen Collationen aus der Datenbank entfernen möchten.</para>
      </tip>

      <para>Jeder Benutzer, der mit der Datenbank verbunden ist, kann <database>DROP COLLATION</database> verwenden, 
      um eine Collation zu entfernen.</para>

      <formalpara>
        <title>Beispiele für die Verwendung von DROP COLLATION</title>
        <para>&nbsp;Löschen der ES_ES_NOPAD_CI-Collation.
          <blockquote><programlisting>
DROP COLLATION ES_ES_NOPAD_CI;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para><link linkend="fblangref25-ddl-tbl-collatcrt-de"><database>CREATE COLLATION</database></link>
        </para>
      </formalpara>
    </section><!-- Drop collation -->
  </section> <!-- Collation -->

  <section id="fblangref25-ddl-charset-de">
    <title><database>CHARACTER SET</database></title>
    <para></para>

    <section id="fblangref25-ddl-charset-alter-de">
      <title><database>ALTER CHARACTER SET</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Festlegen der Standardsortierung für einen Zeichensatz</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER CHARACTER SET charset
SET DEFAULT COLLATION collation;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-charsetalter-de">
      <?dbfo keep-together='auto'?>
        <title>ALTER CHARACTER SET Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Zeichensatzkennung</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Der Name der Sortierung</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>ALTER CHARACTER SET</database> ändert die Standardsortierung 
          für den angegebenen Zeichensatz. Dies wirkt sich auf die zukünftige Verwendung des Zeichensatzes 
          aus, mit Ausnahme der Fälle, in denen die <database>COLLATE</database>-Klausel explizit 
          überschrieben wird. In diesem Fall bleibt die Sortierreihenfolge bestehender Domainn, 
          Spalten und PSQL-Variablen nach der Änderung der Standardsortierung des zugrunde liegenden 
          Zeichensatzes erhalten.</para>
      <note>
        <title>Hinweise</title>
        <para>Wenn Sie die Standardsortierung für den Datenbankzeichensatz ändern 
            (die beim Erstellen der Datenbank definiert wurde), wird die Standardsortierung 
            für die Datenbank geändert.
        </para>
        <para>Wenn Sie die Standardsortierung für den Zeichensatz ändern, der während der 
            Verbindung angegeben wurde, werden Stringkonstanten gemäß dem neuen Sortierungswert 
            interpretiert, außer in den Fällen, in denen der Zeichensatz und / oder die 
            Collation überschrieben wurde.</para>
      </note>
      <formalpara>
        <title>Beispiel zur Verwendung</title>
        <para>&nbsp;Festlegen der Standard-UNICODE_CI_AI-Sortierung für die UTF8-Codierung.
          <blockquote><programlisting>
ALTER CHARACTER SET UTF8
       SET DEFAULT COLLATION UNICODE_CI_AI;
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- Alter character set -->
  </section> <!-- Character set -->

  <section id="fblangref25-ddl-role-de">
    <title><database>ROLE</database></title>
    <para>Eine Rolle ist ein Datenbankobjekt, das eine Reihe 
        <link linkend="fblangref25-security-privs-de"> SQL-Berechtigungen</link> paketiert. 
        Rollen implementieren das Konzept der Zugriffskontrolle auf Gruppenebene. Der Rolle 
        werden mehrere Berechtigungen erteilt, und diese Rolle kann einem oder mehreren Benutzern 
        gewährt oder widerrufen werden.
    </para>

    <para>Ein Benutzer, dem eine Rolle zugewiesen wurde, muss diese Rolle in seinen Anmeldeinformationen 
        bereitstellen, um die zugehörigen Berechtigungen auszuüben. Alle anderen Berechtigungen, 
        die dem Benutzer gewährt werden, sind von seiner Anmeldung mit der Rolle nicht betroffen. 
        Die gleichzeitige Anmeldung mit mehreren Rollen wird nicht unterstützt.</para>
    <para>In diesem Abschnitt werden die Aufgaben zum Erstellen und Löschen von Rollen besprochen.</para>

    <section id="fblangref25-ddl-createrole-de">
      <title><database>CREATE ROLE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Erstellen eines neuen <database>ROLE</database>-Objektes</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE ROLE rolename;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-createrole-de">
      <?dbfo keep-together='auto'?>
        <title>CREATE ROLE Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">rolename</entry>
              <entry align="left">Rollenname. Die maximale Länge beträgt 31 Zeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>CREATE ROLE</database> erstellt ein neues Rollenobjekt, 
      dem später ein oder mehrere Berechtigungen erteilt werden können. Der Name einer Rolle 
      muss unter den Namen der Rollen in der aktuellen Datenbank eindeutig sein.
        <warning>
          <para>Es ist ratsam, den Namen einer Rolle auch unter den Benutzernamen eindeutig zu machen. 
              Das System verhindert nicht die Erstellung einer Rolle, deren Name mit einem vorhandenen 
              Benutzernamen kollidiert. Wenn dies der Fall ist, kann der Benutzer keine Verbindung 
              zur Datenbank herstellen.</para>
        </warning>
      </para>
      <para>&nbsp;Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Rolle erstellen. 
          Der Benutzer, der eine Rolle erstellt, wird zu seinem Besitzer.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Erstellen einer Rolle SELLERS:
          <blockquote><programlisting>
CREATE ROLE SELLERS;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-droprole-de"><database>DROP ROLE</database></link>,
        <link linkend="fblangref25-security-privs-grant-de"><database>GRANT</database></link>,
        <link linkend="fblangref25-security-privs-revoke-de"><database>REVOKE</database></link>
        </para>
      </formalpara>
    </section><!-- create role -->

    <section id="fblangref25-ddl-alterrole">
      <title><database>ALTER ROLE</database></title>
      <para><database>ALTER ROLE</database> hat keinen Platz im create-alter-drop-Paradigma 
      für Datenbankobjekte, da eine Rolle keine Attribute besitzt, die geändert werden können. 
      Sein tatsächlicher Effekt besteht darin, ein Attribut der Datenbank zu ändern: Firebird 
      verwendet es, um die Fähigkeit von Windows Adminstratoren zu aktivieren und zu deaktivieren, 
      beim Anmelden automatisch <link linkend="fblangref25-security-administrators-de">Administratorrechte</link>
      zu erhalten.</para>
      <para>Diese Prozedur trifft nur auf eine Rolle zu: Die systemgenerierte Rolle <database>RDB$ADMIN</database>, 
      die in jeder Datenbank von ODS 11.2 oder höher vorhanden ist. Bei der Aktivierung dieser Funktion sind mehrere 
      Faktoren beteiligt.</para>
      <para>Für weitere Details, siehe <link linkend="fblangref25-security-autoadminmapping-de"><citetitle>AUTO ADMIN
      MAPPING</citetitle></link> im Kapitel <citetitle>Sicherheit</citetitle>.</para>
    </section>

    <section id="fblangref25-ddl-droprole-de">
      <title><database>DROP ROLE</database></title>
      <formalpara><title>Benutzt für</title>
        <para>Löschen einer Rolle</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP ROLE rolename;
        </programlisting></blockquote>
      </formalpara>
      <para>Die Anweisung <database>DROP ROLE</database> löscht eine vorhandene Rolle. 
          Es braucht nur ein einziges Argument, den Namen der Rolle. Sobald die Rolle 
          gelöscht wurde, wird der gesamte Berechtigungssatz von allen Benutzern und Objekten, 
          denen die Rolle gewährt wurde, widerrufen.</para>
      <para>Eine Rolle kann vom Eigentümer gelöscht oder von einem
      <link linkend="fblangref25-security-administrators-de">Administrator</link>.</para>

      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Löschen der Rolle SELLERS:
          <blockquote><programlisting>
DROP ROLE SELLERS;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-createrole-de"><database>CREATE ROLE</database></link>,
        <link linkend="fblangref25-security-privs-grant-de"><database>GRANT</database></link>,
        <link linkend="fblangref25-security-privs-revoke-de"><database>REVOKE</database></link>
        </para>
      </formalpara>
    </section> <!-- drop role -->
  </section> <!-- ROLE -->

  <section id="fblangref25-ddl-comment-de">
    <title><database>COMMENTS</database></title>
    <para>Datenbankobjekte und eine Datenbank selbst können Kommentare enthalten. Es ist ein bequemer Mechanismus 
        zur Dokumentation der Entwicklung und Pflege einer Datenbank. Kommentare, die mit <database>COMMENT ON</database> 
        erstellt wurden, überstehen eine <emphasis>gbak</emphasis>-Sicherung und -Wiederherstellung.</para>

    <section id="fblangref25-ddl-comment-create-de">
      <title><database>COMMENT ON</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Documentation von Metadaten</para>
      </formalpara>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
COMMENT ON &lt;object&gt; IS {'sometext' | NULL}

&lt;object&gt; ::=
    DATABASE
  | &lt;basic-type&gt; objectname
  | COLUMN relationname.fieldname
  | PARAMETER procname.paramname

&lt;basic-type&gt; ::=
  CHARACTER SET |
  COLLATION |
  DOMAIN |
  EXCEPTION |
  EXTERNAL FUNCTION |
  FILTER |
  GENERATOR |
  INDEX |
  PROCEDURE |
  ROLE |
  SEQUENCE |
  TABLE |
  TRIGGER |
  VIEW
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-commenton-de">
      <?dbfo keep-together='auto'?>
        <title>COMMENT ON Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
           </thead>
           <tbody>
            <row valign="middle">
              <entry align="center">sometext</entry>
              <entry align="left">Kommentartext</entry>
            </row>
            <row valign="middle">
              <entry align="center">basic-type</entry>
              <entry align="left">Metadatenobjekttyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">objectname</entry>
              <entry align="left">Name des Metadatenobjekts</entry>
            </row>
            <row valign="middle">
              <entry align="center">relationname</entry>
              <entry align="left">Name der Tabelle oder View</entry>
            </row>

            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name der Stored Procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">Name des Stored Procedure Parameters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>COMMENT ON</database> fügt Kommentare zu Datenbankobjekten (Metadaten) 
          hinzu. Kommentare werden in Textfeldern des Typs <database>BLOB</database> in der Spalte RDB$DESCRIPTION 
          der entsprechenden Systemtabellen gespeichert. Clientanwendungen können Kommentare aus diesen Feldern anzeigen.
        <note>
          <para>Wenn Sie einen leeren Kommentar ('') hinzufügen, wird dieser als NULL in der Datenbank gespeichert.</para>
        </note>
      </para>

      <para>Der Eigentümer der Tabelle oder Prozedur und <link linkend="fblangref25-security-administrators-de">Administratoren</link>
      haben die notwendigen Berechtigungen die Anweisung <database>COMMENT ON</database> zu verwenden.</para>

      <formalpara>
        <title>Beispiele zur Verwendung von COMMENT ON</title>
        <orderedlist>
          <listitem>Einen Kommentar für die aktuelle Datenbank hinzufügen
            <programlisting>
COMMENT ON DATABASE IS 'It is a test (''my.fdb'') database';
            </programlisting>
          </listitem>
          <listitem>Einen Kommentar für die METALS-Tabelle hinzufügen
            <programlisting>
COMMENT ON TABLE METALS IS 'Metal directory';
            </programlisting>
          </listitem>
          <listitem>Hinzufügen eines Kommentars zum Feld ISALLOY in der METALS-Tabelle
            <programlisting>
COMMENT ON COLUMN METALS.ISALLOY IS '0 = fine metal, 1 = alloy';
            </programlisting>
          </listitem>
          <listitem>Einen Kommentar für einen Parameter hinzufügen
            <programlisting>
COMMENT ON PARAMETER ADD_EMP_PROJ. EMP_NO IS 'Employee ID';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
    </section> <!-- Comment on -->
  </section> <!-- Comments -->

</chapter>
