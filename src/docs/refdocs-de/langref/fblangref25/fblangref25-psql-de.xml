<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="fblangref25-psql-de" lang="de">
  <title>Prozedurale SQL-Anweisungen (PSQL)</title>

  <para>Prozedurales SQL (PSQL) ist eine prozedurale Erweiterung von SQL. Diese Sprachuntermenge 
      wird zum Schreiben von gespeicherten Prozeduren, Triggern und PSQL-Blöcken verwendet.</para>
  <para>PSQL bietet alle grundlegenden Konstrukte traditioneller strukturierter Programmiersprachen 
      und enthält auch DML-Anweisungen (SELECT, INSERT, UPDATE, DELETE usw.), in einigen Fällen 
      mit geringfügigen Änderungen der Syntax.</para>
  <section id="fblangref25-psql-elements-de">
    <title>Elemente der PSQL</title>
    <para>Eine prozedurale Erweiterung kann Deklarationen von lokalen Variablen und Cursorn, 
        Zuweisungen, bedingten Anweisungen, Schleifen, Anweisungen zum Abrufen von benutzerdefinierten 
        Ausnahmen, Fehlerbehandlung und Senden von Nachrichten (Ereignissen) an Clientanwendungen 
        enthalten. Trigger haben Zugriff auf spezielle Kontextvariablen, zwei Arrays, die die NEW-Werte 
        für alle Spalten während der Einfüge- und Aktualisierungsaktivität bzw. die OLD-Werte während 
        der Aktualisierungs- und Löscharbeiten speichern.</para>
    <para>Anweisungen, die Metadaten ändern (DDL), sind in PSQL nicht verfügbar.</para>

    <section id="fblangref25-psql-elements-dml-de">
      <title>DML-Anweisungen mit Parametern</title>
      <para>Wenn DML-Anweisungen (SELECT, INSERT, UPDATE, DELETE usw.) im Rumpf des Moduls (Prozedur, 
          Trigger oder Block) Parameter verwenden, können nur benannte Parameter verwendet werden und sie 
          müssen <quote>existieren</quote> bevor die Anweisung diese verwenden kann. Sie können verfügbar gemacht 
          werden, indem sie entweder als Ein- oder Ausgabeparameter im Header des Moduls oder als 
          lokale Variablen in DECLARE [VARIABLE]-Anweisungen im unteren Headerbereich deklariert werden.</para>

      <para>Wenn eine DML-Anweisung mit Parametern im PSQL-Code enthalten ist, muss dem Parameternamen in den 
          meisten Situationen ein Doppelpunkt (<quote>:</quote>) vorangestellt werden. Der Doppelpunkt ist in 
          PSQL-spezifischer Anweisungssyntax wie Zuweisungen und Bedingungen optional. Das Doppelpunktpräfix 
          für Parameter ist nicht erforderlich, wenn gespeicherte Prozeduren von einem anderen PSQL-Modul 
          oder in DSQL aufgerufen werden.</para>
    </section>

    <section id="fblangref25-psql-elements-transacs-de">
      <title>Transaktionen</title>
      <para>Gespeicherte Prozeduren werden im Kontext der Transaktion ausgeführt, in der sie aufgerufen werden. 
          Trigger werden als ein intrinsischer Teil der Operation der DML-Anweisung ausgeführt: ihre Ausführung 
          befindet sich also innerhalb des gleichen Transaktionskontextes wie die Anweisung selbst. Einzelne 
          Transaktionen werden für Datenbank-Trigger gestartet.</para>
      <para>Anweisungen, die Transaktionen starten und beenden, sind in PSQL nicht verfügbar, aber es ist möglich, 
          eine Anweisung oder einen Anweisungsblock in einer autonomen Transaktion auszuführen.</para>
    </section>

    <section id="fblangref25-psql-elements-structure-de">
      <title>Modulstruktur</title>
      <para>PSQL-Codemodule bestehen aus einem Header und einem Body. Die DDL-Anweisungen zum Definieren dieser 
          sind <emphasis>komplexe Anweisungen</emphasis>; das heißt, sie sind Bestandteile einer einzigen Anweisung, die 
          Blöcke von mehreren Anweisungen umfasst. Diese Anweisungen beginnen mit einem Verb 
          (CREATE, ALTER, DROP, RECREATE, CREATE oder ALTER) und enden mit
          die letzten END-Anweisung des Bodys.</para>

      <section id="fblangref25-psql-elements-header-de">
        <title>Der Modul-Header</title>
        <para>Der Header gibt den Modulnamen an und definiert alle Parameter und Variablen, die im Rumpf verwendet werden. 
            Gespeicherte Prozeduren und PSQL-Blöcke können Ein- und Ausgangsparameter haben. Trigger 
            haben keine Ein- oder Ausgangsparameter.</para>

        <para>Der Header eines Triggers zeigt das Datenbankereignis (Einfügen, Aktualisieren oder Löschen oder eine Kombination) 
            und die Betriebsphase (VOR oder NACH diesem Ereignis) an, die dazu führt, dass dieser <quote>ausgelöst wird</quote>.</para>
      </section>

      <section id="fblangref25-psql-elements-body-de">
        <title>Der Modul-Body</title>
        <para>Der Rumpf eines PSQL-Moduls ist ein Block von Anweisungen, die wie ein Programm in einer logischen Reihenfolge ablaufen. 
            Ein Anweisungsblock ist in einer BEGIN- und einer END-Anweisung enthalten. Der Hauptblock BEGIN ... END kann beliebig 
            viele andere BEGIN ... END-Blöcke enthalten, sowohl eingebettete als auch sequenzielle. Alle Anweisungen außer 
            BEGIN und END werden durch Semikolons (;) abgeschlossen. Kein anderes Zeichen ist als Terminator für PSQL-Anweisungen 
            gültig.</para>
      </section>
    </section>
  </section><!-- Elements of -->

  <sidebar id="fblangref25-sidebar01-de">
    <title>Umschalten des Terminators in <emphasis>isql</emphasis></title>
    <para>Hier werden wir ein wenig abschweifen, um zu erklären, wie man das Terminatorzeichen im Dienstprogramm 
        <emphasis>isql</emphasis> umschaltet, um es zu ermöglichen, PSQL-Module in dieser Umgebung zu definieren, 
        ohne mit <emphasis>isql</emphasis> selbst in Konflikt zu geraten, da <emphasis>isql</emphasis> 
        dasselbe Zeichen, Semikolon (;), als eigenen Anweisungsabschluss verwendet.</para>
    <formalpara>
      <title>isql-Befehl SET TERM</title>
      <para>&nbsp;</para>
    </formalpara>
    <formalpara>
      <title>Verwendet für</title>
      <para>&nbsp;Ändern des Terminatorzeichens, um Konflikte mit dem Terminatorzeichen 
          in PSQL-Anweisungen zu vermeiden</para>
    </formalpara>
    <formalpara>
      <title>Verfügbar in</title>
      <para>&nbsp;nur in ISQL</para>
    </formalpara>
    <formalpara>
      <title>Syntax</title>
      <para>
      <blockquote><literallayout class="monospaced">
SET TERM &lt;new_terminator&gt; &lt;old_terminator&gt;
      </literallayout></blockquote>
      </para>
    </formalpara>

    <table id="fblangref25-psql-tbl-setterm-de">
    <?dbfo keep-together='auto'?>
      <title>SET TERM-Parameter</title>
      <tgroup cols="2">
        <colspec colname="colParam" colwidth="*"></colspec>
        <colspec colname="colDes" colwidth="3*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Argument</entry>
            <entry align="center">Beschreibung</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="center">new_terminator</entry>
            <entry align="left">Neuer Terminator</entry>
          </row>
          <row valign="middle">
            <entry align="center">old_terminator</entry>
            <entry align="left">Alter Terminator</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>Wenn Sie Ihre Trigger und gespeicherten Prozeduren in <emphasis>isql</emphasis> schreiben, 
    entweder in der interaktiven Schnittstelle oder in Skripten, müssen Sie eine 
    <database>SET TERM</database>-Anweisung ausführen, um das normale <emphasis>isql</emphasis>-Anweisungsterminal 
    vom Semikolon zu einem anderen Zeichen oder einer kurzen Zeichenfolge umzuschalten. Hierdurch
    werden Konflikte mit dem nicht änderbaren Semikolon-Terminator in PSQL zu vermieden. Der Wechsel 
    zu einem alternativen Terminator muss durchgeführt werden, bevor Sie beginnen, PSQL-Objekte zu 
    definieren oder Ihre Skripte auszuführen.</para>

    <para>Der alternative Terminator kann eine beliebige Zeichenkette sein, mit Ausnahme eines Leerzeichens, 
        eines Apostrophs oder des aktuellen Terminatorzeichens. Bei jedem Buchstabenzeichen wird zwischen 
        Groß- und Kleinschreibung unterschieden.</para>
    <formalpara>
      <title>Beispiel</title>
      <para>&nbsp;Ändern Sie das Standard-Semikolon in '^' (Caret) und verwenden Sie es, um eine 
          Stored Procedure-Definition zu übergeben: Zeichen als alternatives Terminatorzeichen:
        <blockquote><literallayout class="monospaced">
SET TERM ^;

CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
BEGIN
  /* Stored procedure body */
END^

/* Other stored procedures and triggers */

SET TERM ;^

/* Other DDL statements */
        </literallayout></blockquote>
      </para>
    </formalpara>
  </sidebar>

  <section id="fblangref25-psql-storedprocs-de">
    <title>Gespeicherte Prozeduren</title>
    <para>Eine gespeicherte Prozedur ist ein Programm, das in den Datenbankmetadaten zur Ausführung auf 
        dem Server gespeichert ist. Eine gespeicherte Prozedur kann durch gespeicherte Prozeduren (einschließlich sich selbst), 
        Trigger und Clientanwendungen aufgerufen werden. Eine Prozedur, die sich selbst aufruft, heißt <emphasis>rekursiv</emphasis>.</para>
    <section id="fblangref25-psql-storedprocs-benefits-de">
      <title>Vorteile von gespeicherten Prozeduren</title>
      <para>Gespeicherten Prozeduren besitzen die folgenden Vorteile:
        <orderedlist>
          <listitem><para>Modularität&#x2014;Anwendungen, die mit der Datenbank arbeiten, können die gleiche gespeicherte Prozedur
              verwenden, wodurch die Größe des Anwendungscodes reduziert wird und eine Codeduplizierung vermieden wird.</para></listitem>
          <listitem><para>Vereinfachte Anwendungsunterstützung&#x2014;Wenn eine gespeicherte Prozedur geändert wird, werden
              Änderungen sofort allen Host-Anwendungen angezeigt, ohne dass sie bei unveränderten Parametern neu kompiliert werden müssen.</para></listitem>
          <listitem><para>Verbesserte Leistung&#x2014;Da gespeicherte Prozeduren auf einem Server statt auf dem Client ausgeführt werden,
              wird der Netzwerkverkehr reduziert, wodurch die Leistung verbessert wird.</para></listitem>
        </orderedlist>
      </para>
    </section>

    <section id="fblangref25-psql-storedprocs-types-de">
      <title>Varianten der gespeicherten Prozeduren</title>
      <para>Firebird untertützt zwei Arten der gespeicherten Prozeduren: <emphasis>executable</emphasis> (ausführbar)
      <emphasis>selectable</emphasis> (abfragbar).</para>

      <section id="fblangref25-psql-storedprocs-executable-de">
        <title>Ausführbare Prozeduren</title>
        <para>Ausführbare Prozeduren ändern normalerweise Daten in einer Datenbank. Sie können Eingabeparameter 
            empfangen und einen einzigen Satz von Ausgabeparametern (RETURNS) zurückgeben. Sie werden mit der 
            Anweisung <database>EXECUTE PROCEDURE</database> aufgerufen.  Siehe auch 
            <link linkend="create-procedure-examples-de">ein Beispiel für eine ausführbare gespeicherte Prozedur</link> 
            am Ende des  <link linkend="fblangref25-ddl-proc-create-de">Abschnitts <database>CREATE PROCEDURE</database></link> 
            von Kapitel 5.</para>
      </section>
      <section id="fblangref25-psql-storedprocs-selectable-de">
        <title>Abfragbare Prozeduren</title>
        <para>Abfragbare bzw. auswählbare gespeicherte Prozeduren rufen normalerweise Daten aus einer Datenbank ab und geben eine 
            beliebige Anzahl von Zeilen an den Aufrufer zurück. Der Aufrufer erhält die Ausgabe Zeile für Zeile aus 
            einem Zeilenpuffer, der von der Datenbank-Engine darauf vorbereitet wird.</para>
        <para>Auswählbare Prozeduren können nützlich sein, um komplexe Datensätze zu erhalten, die mit regulären DSQL SELECT-Abfragen 
            oft nicht oder nur schwer oder zu langsam abgerufen werden können. Typischerweise iteriert diese Art der Prozedur 
            durch einen Schleifenprozess des Extrahierens von Daten, wobei sie möglicherweise transformiert wird, bevor die 
            Ausgangsvariablen (Parameter) bei jeder Iteration der Schleife mit frischen Daten gefüllt werden. Eine SUSPEND-Anweisung 
            am Ende der Iteration füllt den Puffer und wartet darauf, dass der Aufrufer die Zeile abfragt. Die Ausführung der nächsten 
            Iteration der Schleife beginnt, wenn der Puffer gelöscht wurde.</para>
        <para>Auswählbare Prozeduren können Eingabeparameter haben, und der Ausgabesatz wird durch die Klausel <database>RETURNS</database> 
        im Header angegeben.</para>

        <para>Eine wählbare gespeicherte Prozedur wird mit einer SELECT-Anweisung aufgerufen.
        Siehe auch <link linkend="create-procedure-examples-de">ein Beispiel für eine abfragbare gespeicherte Prozedur</link> 
            am Ende des  <link linkend="fblangref25-ddl-proc-create-de">Abschnitts <database>CREATE PROCEDURE</database></link> 
            von Kapitel 5.</para>

      </section> <!-- selectable procedures -->
    </section><!-- Types of Stored Procedures -->

    <section id="fblangref25-psql-storedprocs-creating-de">
      <title>Erstellen einer gespeicherte Prozedur</title>
      <para>Die Syntax zum Erstellen ausführbarer gespeicherter Prozeduren und wählbarer gespeicherter Prozeduren ist exakt gleich. 
          Der Unterschied liegt in der Logik des Programmcodes.</para>
      <formalpara>
        <title>Syntax (partiell)</title>
        <para>
        <blockquote><programlisting>
CREATE PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
        </para>
      </formalpara>
      <para>Der Header einer gespeicherten Prozedur muss den Prozedurnamen enthalten und muss unter den 
          Namen gespeicherter Prozeduren, Tabellen und Ansichten eindeutig sein. Es kann auch einige Ein- 
          und Ausgabeparameter definieren. Eingabeparameter werden nach dem Prozedurnamen in Klammern 
          angegeben. Ausgabeparameter, die für auswählbare Prozeduren obligatorisch sind, sind innerhalb 
          einer Klausel <database>RETURNS</database> eingeklammert.</para>
      <para>Das letzte Element im Header (oder das erste Element im Textkörper, abhängig von Ihrer Ansicht 
          darüber, wo die Grenze liegt) umfasst eine oder mehrere Deklarationen von lokalen Variablen und / oder 
          benannten Cursorn die Ihre Prozedur möglicherweise erfordert.</para>
      <para>Nach den Deklarationen folgt der Hauptblock BEGIN ... END, der den PSQL-Code der Prozedur beschreibt. 
          Innerhalb dieses Blocks könnten PSQL- und DML-Anweisungen, Ablaufsteuerungsblöcke, Sequenzen anderer 
          BEGIN ... END-Blöcke einschließlich eingebetteter Blöcke sein. Blöcke, einschließlich des Hauptblocks, 
          können leer sein und die Prozedur wird trotzdem kompiliert. Es ist nicht ungewöhnlich, ein Verfahren in 
          Stufen aus einem Gliederung zu entwickeln.</para>
      <formalpara>
        <title>Weitere Informationen zum Erstellen gespeicherter Prozeduren</title>
        <para>&nbsp;Siehe auch <link linkend="fblangref25-ddl-proc-create-de"><database>CREATE PROCEDURE</database></link>
        in Kapitel 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- CREATE PROCEDURE -->

    <section id="fblangref25-psql-storedprocs-modifying-de">
      <title>Anpassen einer gespeicherte Prozedur</title>
      <para>Eine vorhandene gespeicherte Prozedur kann geändert werden, um die Sätze von Ein- 
          und Ausgabeparametern und alles im Prozedurhauptteil zu ändern.</para>
      <formalpara>
        <title>Syntax (partiell)</title>
        <para>
        <blockquote><programlisting>
ALTER PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Weitere Informationen zum Ändern gespeicherter Prozeduren</title>
        <para>&nbsp;Siehe auch
        <link linkend="fblangref25-ddl-proc-alter-de"><database>ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-crtoralter-de"><database>CREATE OR ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate-de"><database>RECREATE PROCEDURE</database></link>,
        in Kapitel 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- MODIFY PROCEDURE -->

    <section id="fblangref25-psql-storedprocs-deleting-de">
      <title>Löschen einer gespeicherte Prozedur</title>
      <para>Die Anweisung <database>DROP PROCEDURE</database> wird verwendet um 
      gespeicherte Prozeduren zu löschen.</para>
      <formalpara>
        <title>Syntax (vollständig)</title>
        <para>
        <blockquote><programlisting>
DROP PROCEDURE procname;
        </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Weitere Informationen zum Löschen gespeicherter Prozeduren</title>
        <para>&nbsp;See <link linkend="fblangref25-ddl-proc-drop-de"><database>DROP
        PROCEDURE</database></link>
        in Kapitel 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- DELETE PROCEDURE -->
  </section> <!-- Stored Procedures -->

  <section id="fblangref25-psql-storedfuncs-de">
    <title>Gespeicherte Funktionen (Stored Functions)</title>
    <para>Gespeicherte PSQL-Skalarfunktionen werden in dieser Version nicht unterstützt, 
        sie kommen jedoch in Firebird 3. In Firebird 2.5 und niedriger können Sie stattdessen 
        eine abfragbare gespeicherte Prozedur schreiben, die ein Skalarergebnis zurückgibt, 
        und SELECT aus Ihrer DML-Abfrage oder Unterabfrage.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>
        <blockquote><programlisting>
SELECT
  PSQL_FUNC(T.col1, T.col2) AS col3,
  col3
FROM T
        </programlisting></blockquote>
    kann ersetzt werden durch
        <blockquote><programlisting>
SELECT
  (SELECT output_column FROM  PSQL_PROC(T.col1)) AS col3,
  col2
FROM T
        </programlisting></blockquote>
    oder
        <blockquote><programlisting>
SELECT
  output_column AS col3,
  col2,
FROM T
LEFT JOIN PSQL_PROC(T.col1)
        </programlisting></blockquote>
        </para>
      </formalpara>
  </section> <!-- stored functions -->


  <section id="fblangref25-psql-dynblocks-de">
    <title>PSQL-Blöcke</title>
    <para>Ein in sich abgeschlossener, unbenannter (<quote>anonymous</quote>) Block von PSQL-Code 
    kann dynamisch in DSQL unter Verwendung der Syntax <database>EXECUTE BLOCK</database> ausgeführt 
    werden. Der Header eines anonymen PSQL-Blocks kann optional Eingabe- und Ausgabeparameter enthalten. 
    Der Körper kann lokale Variablen und Cursordeklarationen enthalten. Ein Block von PSQL-Anweisungen folgt.</para>
    <para>Ein anonymer PSQL-Block wird nicht definiert und als Objekt gespeichert, im Gegensatz zu gespeicherten 
        Prozeduren und Triggern. Er wird zur Laufzeit ausgeführt und kann nicht auf sich selbst verweisen.</para>
    <para>Genau wie gespeicherte Prozeduren können anonyme PSQL-Blöcke verwendet werden, um Daten zu verarbeiten 
        und Daten aus der Datenbank abzurufen.</para>
    <formalpara>
      <title>Syntax (unvollständig)</title>
      <para>
      <blockquote><programlisting>
EXECUTE BLOCK
[(&lt;inparam&gt; = ? [, &lt;inparam&gt; = ? ...])]
[RETURNS (&lt;outparam> [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
      </programlisting></blockquote>
      </para>
    </formalpara>
    <table id="fblangref25-psql-tbl-dynblock-de">
    <?dbfo keep-together='auto'?>
      <title>PSQL Block Parameters</title>
      <tgroup cols="2">
        <colspec colname="colParam" colwidth="*"></colspec>
        <colspec colname="colDes" colwidth="3*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Argument</entry>
            <entry align="center">Beschreibung</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="center">inparam</entry>
            <entry align="left">Beschreibung der Eingabeparameter</entry>
          </row>
          <row valign="middle">
            <entry align="center">outparam</entry>
            <entry align="left">Beschreibung der Ausgangsparameter</entry>
          </row>
          <row valign="middle">
            <entry align="center">declarations</entry>
            <entry align="left">Ein Abschnitt zum Deklarieren lokaler Variablen und benannter Cursor</entry>
          </row>
          <row valign="middle">
            <entry align="center">PSQL statements</entry>
            <entry align="left">PSQL- und DML-Anweisungen</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <formalpara>
      <title>Weiterlesen</title>
      <para>&nbsp;Siehe auch
      <link linkend="fblangref25-dml-execblock-de"><database>EXECUTE BLOCK</database></link> für weitere Details.
      </para>
    </formalpara>
  </section><!-- PSQL Blocks -->

  <section id="fblangref25-psql-triggers-de">
    <title>Trigger</title>
    <para>Ein Trigger ist eine andere Form von ausführbarem Code, der in den Metadaten der Datenbank zur 
        Ausführung durch den Server gespeichert wird. Ein Trigger kann nicht direkt aufgerufen werden. 
        Er wird automatisch aufgerufen (<quote>gefeuert</quote>), wenn Datenänderungsereignisse mit 
        einer bestimmten Tabelle oder Sicht (View) auftreten.</para>
    <para>Ein Trigger gilt für genau eine Tabelle oder Sicht und nur eine <emphasis>Phase</emphasis> in 
    einem Ereignis (VOR oder NACH dem Ereignis). Ein einzelner Trigger kann nur dann ausgelöst werden,
    wenn ein bestimmtes Datenänderungsereignis auftritt (INSERT / UPDATE / DELETE) oder wenn es auf mehr 
    als eines dieser Ereignisse angewendet werden soll.</para>

    <para>Ein DML-Trigger wird im Kontext der Transaktion ausgeführt, in der die datenändernde DML-Anweisung 
        ausgeführt wird. Bei Triggern, die auf Datenbankereignisse reagieren, ist die Regel unterschiedlich: 
        Für einige von ihnen wird eine Standardtransaktion gestartet.</para>

    <section id="fblangref25-psql-firingorder-de">
      <title>Reihenfolge der Ausführung</title>
      <para>Für jede Phase-Ereignis-Kombination kann mehr als ein Trigger definiert werden. Die Reihenfolge, 
          in der sie ausgeführt werden (bekannt als <quote>firing order</quote>, kann explizit mit dem optionalen 
          Argument <database>POSITION</database> in der Triggerdefinition angegeben werden.) Sie haben 32.767 
          Nummern zur Auswahl. Die niedrigsten Positionsnummern feuern zuerst.</para>
      <para>Wenn eine Klausel <database>POSITION</database> weggelassen wird oder mehrere übereinstimmende 
          Ereignisphasen-Trigger die gleiche Positionsnummer haben, werden die Trigger in alphabetischer 
          Reihenfolge ausgelöst.</para>
    </section>

    <section id="fblangref25-psql-dmltriggers-de">
    <title>DML-Trigger</title>
    <para>DML-Trigger sind solche, die ausgelöst werden, wenn eine DML-Operation den Datenstatus ändert: 
        Zeilen in Tabellen ändern, neue Zeilen einfügen oder Zeilen löschen. Sie können sowohl für Tabellen 
        als auch für Ansichten definiert werden.</para>

      <section id="fblangref25-psql-triggeroptions-de">
        <title>Trigger-Optionen</title>
        <para>Für die Ereignis-Phasen-Kombination für Tabellen und Ansichten stehen sechs 
            Basisoptionen zur Verfügung:

          <informaltable id="fblangref25-psql-tbl-dmltriggers-de" frame="none" rowsep="1" colsep="1">
          <?dbfo keep-together='auto'?>
            <tgroup cols="2">
              <colspec colname="colEvent" colwidth="*"></colspec>
              <colspec colname="colKeywords" colwidth="*"></colspec>
              <tbody>
                <row valign="middle">
                  <entry align="right">Bevor eine neue Zeile eingefügt wird</entry>
                  <entry align="left"><database>(BEFORE INSERT)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Nachdem eine neue Zeile eingefügt wurde</entry>
                  <entry align="left"><database>(AFTER INSERT)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Bevor eine Zeile aktualisiert wird</entry>
                  <entry align="left"><database>(BEFORE UPDATE)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Nachdem eine Zeile aktualisiert wurde</entry>
                  <entry align="left"><database>(AFTER UPDATE)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Bevor eine Zeile gelöscht wird</entry>
                  <entry align="left"><database>(BEFORE DELETE)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Nachdem eine Zeile gelöscht wurde</entry>
                  <entry align="left"><database>(AFTER DELETE)</database></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
            Diese Basisformulare dienen zum Erstellen von Einzelphasen- / Einzelereignisauslösern. 
          Firebird unterstützt auch Formulare zum Erstellen von Auslösern für eine Phase und mehrere Ereignisse, 
          z. B. <database>BEFORE INSERT ODER UPDATE ODER DELETE</database>, oder <database>AFTER UPDATE ODER DELETE</database>: 
          Die Kombinationen unterliegen Ihrer Wahl.
          <note>
            <para><quote>Multiphasen-</quote>-Trigger, wie BEFORE OR AFTER..., sind nicht möglich.</para>
          </note>
        </para>
      </section> <!-- TRIGGER OPTIONS -->

      <section id="fblangref25-psql-oldnew-de">
        <title>Kontextvariablen OLD und NEW</title>
        <para>Für DML-Trigger bietet die Firebird-Engine Zugriff auf Sätze von OLD- und NEW-Kontextvariablen. 
            Jedes ist ein Array der Werte der gesamten Zeile: eine für die Werte, wie sie vor dem Datenänderungsereignis 
            sind (die BEFORE-Phase) und eine für die Werte, wie sie nach dem Ereignis sein werden (die AFTER-Phase). 
            Sie werden in Anweisungen referenziert, die das Formular <database>NEW.column_name</database> bzw. 
            <database>OLD.column_name</database> verwenden. <database>column_name</database> kann eine beliebige Spalte 
            in der Definition der Tabelle sein, nicht nur die, die gerade aktualisiert wird.</para>
        <para>Die Variablen NEW und OLD unterliegen einigen Regeln:
          <itemizedlist spacing="compact">
            <listitem><para>In allen Triggern ist der OLD-Wert schreibgeschützt</para></listitem>
            <listitem><para>In BEFORE UPDATE und BEFORE INSERT Code wird der NEW-Wert gelesen / geschrieben,
                sofern es sich nicht um eine <database>COMPUTED BY</database>-Spalte handelt</para></listitem>
            <listitem><para>In INSERT-Triggern sind Verweise auf die OLD-Variablen ungültig und
                lösen eine Ausnahme aus</para></listitem>
            <listitem><para>In DELETE-Triggern sind Verweise auf die NEW-Variablen ungültig und lösen
                eine Ausnahme aus</para></listitem>
            <listitem><para>In allen AFTER-Triggercodes sind die NEW-Variablen schreibgeschützt</para></listitem>
          </itemizedlist>
        </para>
      </section> <!-- OLD / NEW -->
    </section> <!-- DML triggers -->

    <section id="fblangref25-psql-dbtriggers-de">
      <title>Datenbank-Trigger</title>
      <para>Ein mit einer Datenbank oder einem Transaktionsereignis verknüpfter Trigger 
          kann für die folgenden Ereignisse definiert werden:

      <informaltable id="fblangref25-psql-tbl-dbtriggers-de" frame="none" rowsep="1" colsep="1">
      <?dbfo keep-together='auto'?>
        <tgroup cols="3">
          <colspec colname="colEvent" colwidth="4*"></colspec>
          <colspec colname="colKeywords" colwidth="3*"></colspec>
          <colspec colname="colDesc" colwidth="5*"></colspec>
          <tbody>
            <row valign="middle">
              <entry align="left">Verbindung mit einer Datenbank herstellen</entry>
              <entry align="center"><database>(ON CONNECT)</database></entry>
              <entry align="left">Bevor der Trigger ausgeführt wird, wird automatisch eine Standardtransaktion gestartet</entry>
            </row>
            <row valign="middle">
              <entry align="left">Trennen von einer Datenbank</entry>
              <entry align="center"><database>(ON DISCONNECT)</database></entry>
              <entry align="left">Bevor der Trigger ausgeführt wird, wird automatisch eine Standardtransaktion gestartet</entry>
            </row>
            <row valign="middle">
              <entry align="left">Wenn eine Transaktion gestartet wird</entry>
              <entry align="center"><database>(ON TRANSACTION START)</database></entry>
              <entry align="left">Der Trigger wird im aktuellen Transaktionskontext ausgeführt</entry>
            </row>
            <row valign="middle">
              <entry align="left">Wenn eine Transaktion übergeben wird</entry>
              <entry align="center"><database>(ON TRANSACTION COMMIT)</database></entry>
              <entry align="left">Der Trigger wird im aktuellen Transaktionskontext ausgeführt</entry>
            </row>
            <row valign="middle">
              <entry align="left">Wenn eine Transaktion abgebrochen wird</entry>
              <entry align="center"><database>(ON TRANSACTION ROLLBACK)</database></entry>
              <entry align="left">Der Trigger wird im aktuellen Transaktionskontext ausgeführt</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      </para>
    </section> <!-- database triggers -->

    <section id="fblangref25-psql-triggercreate-de">
      <title>Trigger erstellen</title>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
CREATE TRIGGER trigname {
    &lt;relation_trigger_legacy&gt;
  | &lt;relation_trigger_sql2003&gt;
  | &lt;database_trigger&gt; }
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END

&lt;relation_trigger_legacy&gt; ::= FOR {tablename | viewname}
[ACTIVE | INACTIVE]
{BEFORE | AFTER} &lt;mutation_list&gt;
[POSITION number]

&lt;relation_trigger_sql2003&gt; ::= [ACTIVE | INACTIVE]
{BEFORE | AFTER} &lt;mutation_list&gt;
[POSITION number]
ON {tablename | viewname}

&lt;database_trigger&gt; ::= [ACTIVE | INACTIVE]
ON db_event
[POSITION number]

&lt;mutation_list&gt; ::= &lt;mutation&gt; [OR &lt;mutation&gt;
   [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::=
    CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK
        </programlisting></blockquote>
        </para>
      </formalpara>
      <para>Der Header muss einen Namen für den Trigger enthalten, der unter den Triggernamen eindeutig ist. 
          Er muss das Ereignis oder die Ereignisse enthalten, die den Auslöser auslösen. Für einen DML-Trigger 
          müssen Sie außerdem die Ereignisphase und den Namen der Tabelle oder Ansicht angeben, die den 
          Trigger <quote>besitzen</quote> soll.</para>
      <para>Der Rumpf des Triggers kann durch die Deklarationen von lokalen Variablen und Cursorn, falls vorhanden, 
          geleitet werden. Innerhalb des umschließenden Hauptblocks von <database>BEGIN ... END</database> befinden 
          sich ein oder mehrere Blöcke von PSQL-Anweisungen, die leer sein können.</para>

      <formalpara>
        <title>Weitere Informationen zum Erstellen von Triggern</title>
        <para>&nbsp;Siehe
        <link linkend="fblangref25-ddl-trgr-create-de">"><database>CREATE TRIGGER</database></link>
        in Kapitel 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- Creating Triggers -->

    <section id="fblangref25-psql-triggermodify-de">
      <title>Trigger ändern</title>
      <para>Das Ändern der Status-, Phasen-, Tabellen- oder Ansichtsereignisse, der Auslöseposition 
          und des Codes im Rumpf eines DML-Triggers ist möglich. Sie können jedoch einen DML-Trigger 
          nicht ändern, um ihn in einen Datenbank-Trigger zu konvertieren, und umgekehrt. Jedes nicht 
          angegebene Element wird von <database>ALTER TRIGGER</database> nicht geändert. Die alternativen 
          Anweisungen <database>CREATE OR ALTER TRIGGER</database> und <database>RECREATE TRIGGER</database> 
          ersetzen die ursprüngliche Triggerdefinition vollständig.</para>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
ALTER TRIGGER trigname
[ACTIVE | INACTIVE]
[{BEFORE | AFTER} &lt;mutation_list&gt;]
[POSITION number]
[
 AS
 [&lt;declarations&gt;]
 BEGIN
 [&lt;PSQL_statements&gt;]
 END
]

&lt;mutation_list&gt; ::= 
  &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::=
    CONNECT 
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK
        </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Weitere Informationen zum Ändern von Triggern</title>
        <para>&nbsp;Siehe
          <link linkend="fblangref25-ddl-trgr-alter-de"><database>ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-crtalter-de"><database>CREATE OR ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-recreate-de"><database>RECREATE TRIGGER</database></link>
        in Kapitel 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- MODIFY TRIGGER -->

    <section id="fblangref25-psql-triggerdelete-de">
      <title>Trigger löschen</title>
      <para>Die Anweisung <database>DROP TRIGGER</database> dient zum Löschen von Triggern.</para>
      <formalpara>
        <title>Syntax (vollständig)</title>
        <para>
        <blockquote><programlisting>
DROP TRIGGER trigname;
        </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Weitere Informationen zum Löschen von Triggern</title>
        <para>&nbsp;Siehe <link linkend="fblangref25-ddl-trgr-drop-de"><database>DROP
        TRIGGER</database></link>
        in Kapitel 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- DELETE TRIGGER -->
  </section> <!-- triggers -->

  <section id="fblangref25-psql-coding-de">
    <title>Schreiben des Body-Codes</title>
    <para>In diesem Abschnitt werden die prozeduralen SQL-Sprachkonstrukte und -Anweisungen näher betrachtet, 
        die zum Codieren des Rumpfs einer gespeicherten Prozedur, eines Triggers oder eines anonymen
        PSQL-Blocks verfügbar sind.</para>

    <sidebar>
      <title>Doppelpunkt-Markierungspräfix (:)</title>
      <para>Das Doppelpunkt-Markierungspräfix (:) wird in PSQL verwendet, um einen Verweis auf 
          eine Variable in einer DML-Anweisung zu markieren. Der Doppelpunkt-Marker ist vor 
          Variablennamen in anderem Code nicht erforderlich und sollte niemals auf Kontextvariablen 
          angewendet werden.</para>
    </sidebar>

    <section id="fblangref25-psql-coding-assign-de">
      <title>Zuweisungs-Statements</title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Zuweisen eines Werts zu einer Variablen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
varname = &lt;value_expr&gt;
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-assign-de">
      <?dbfo keep-together='auto'?>
        <title>Zuweisungs-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name eines Parameters oder einer lokalen Variablen</entry>
            </row>
            <row valign="middle">
              <entry align="center">value_expr</entry>
              <entry align="left">Ein Ausdruck, eine Konstante oder eine Variable, dessen 
                  Wert in den gleichen Datentyp wie &lt;varname&gt;</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>PSQL verwendet das Äquivalenzsymbol (=) als Zuweisungsoperator. Die Zuweisungsanweisung 
          weist der Variablen links vom Operator den rechten SQL-Ausdruckswert zu. Der Ausdruck kann 
          ein beliebiger gültiger SQL-Ausdruck sein: Er kann Literale, interne Variablennamen, 
          Arithmetik-, logische und Zeichenfolgenoperationen, Aufrufe von internen Funktionen oder 
          externe Funktionen (UDFs) enthalten.</para>
      <formalpara>
        <title>Beispiel mit Zuweisungsanweisungen</title>
        <para>
        <blockquote><programlisting>
CREATE PROCEDURE MYPROC (
    a INTEGER,
    b INTEGER,
    name VARCHAR (30)
)
RETURNS (
    c INTEGER,
    str VARCHAR(100))
AS
BEGIN
  -- assigning a constant
  c = 0;
  str = '';
  SUSPEND;
  -- assigning expression values
  c = a + b;
  str = name || CAST(b AS VARCHAR(10));
  SUSPEND;
  -- assigning expression value
  -- built by a query
  c = (SELECT 1 FROM rdb$database);
  -- assigning a value from a context variable
  str = CURRENT_USER;
  SUSPEND;
END
        </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>
        <link linkend="fblangref25-psql-declare-variable-de"><database>DECLARE VARIABLE</database></link>
        </para>
      </formalpara>
    </section> <!-- assignment statement -->

    <section id="fblangref25-psql-declare-cursor-de">
      <title><database>DECLARE CURSOR</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Deklarieren eines benannten Cursors</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
DECLARE [VARIABLE] cursorname CURSOR FOR (&lt;select&gt;) [FOR UPDATE]
        </programlisting></blockquote>
        </para>
      </formalpara>
      <table id="fblangref25-psql-tbl-declare-cursor-de">
      <?dbfo keep-together='auto'?>
        <title>DECLARE CURSOR-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Name des Cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">select</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>DECLARE CURSOR ... FOR</database> bindet einen benannten Cursor an die Ergebnismenge, 
      die in der in der Klausel <database>FOR</database> angegebenen SELECT-Anweisung ermittelt wurde. Im Body-Code 
      kann der Cursor geöffnet werden, um zeilenweise durch die Ergebnismenge zu gehen und zu schließen. Während der 
      Cursor geöffnet ist, kann der Code positionierte Aktualisierungen und Löschungen unter Verwendung der
      Anweisung <database>WHERE CURRENT OF</database> für <database>UPDATE</database> oder 
      <database>DELETE</database> durchführen.</para>
      <section id="fblangref25-psql-idio-cursor-de">
        <title>Cursor-Idiosynkrasien</title>
        <itemizedlist>
          <listitem>
            <para>Die optionale Klausel <database>FOR UPDATE</database> kann in der SELECT-Anweisung 
            enthalten sein, ihre Abwesenheit verhindert jedoch nicht die erfolgreiche Ausführung einer 
            positionierten Aktualisierung oder Löschung.</para>
          </listitem>
          <listitem>
            <para>Es sollte darauf geachtet werden, dass die Namen von deklarierten Cursorn nicht mit Namen 
                in Konflikt geraten, die später in Anweisungen für <database>AS CURSOR</database>-Klauseln 
                verwendet werden.</para>
          </listitem>
          <listitem>
            <para>Wenn der Cursor nur zum Durchlaufen der Ergebnismenge benötigt wird, ist es fast immer einfacher 
                und weniger fehleranfällig, eine Anweisung <database>FOR SELECT</database> mit der Klausel 
                <database>AS CURSOR</database> zu verwenden. Deklarierte Cursor müssen zum Abrufen von Daten explizit geöffnet
                und geschlossen werden. Die Kontextvariable <database>ROW_COUNT</database> 
                muss nach jedem Abruf überprüft werden. Wenn der Wert Null ist, muss die Schleife beendet werden. 
                Eine <database>FOR SELECT</database>-Anweisung überprüft dies automatisch.</para>
            <para>Dennoch bieten deklarierte Cursor ein hohes Maß an Kontrolle über sequentielle Ereignisse und 
                ermöglichen die parallele Verwaltung mehrerer Cursor.</para>
          </listitem>
          <listitem>
            <para>Das <database>SELECT</database>-Statement kann Parameter enthalten. Zum Beispiel:
              <blockquote><literallayout class="monospaced">
SELECT NAME || :SFX FROM NAMES WHERE NUMBER = :NUM
              </literallayout></blockquote>
            Jeder Parameter muss zuvor als PSQL-Variable deklariert worden sein, auch wenn sie als Ein- 
              und Ausgabeparameter entstehen. Wenn der Cursor geöffnet wird, wird dem Parameter der aktuelle 
              Wert der Variablen zugewiesen.</para>
          </listitem>
        </itemizedlist>
        <warning>
          <title>Achtung!</title>
          <para>Wenn sich der Wert einer PSQL-Variablen, die in der SELECT-Anweisung verwendet wird, während der 
              Schleife ändert, kann der neue Wert (jedoch nicht immer) für die verbleibenden Zeilen verwendet werden. 
              Es ist besser, solche Situationen nicht unbeabsichtigt entstehen zu lassen. Wenn Sie dieses Verhalten 
              wirklich benötigen, sollten Sie Ihren Code sorgfältig testen, um sicherzustellen, dass Sie genau wissen, 
              wie sich Änderungen in der Variablen auf das Ergebnis auswirken.</para>
          <para>Beachten Sie besonders, dass das Verhalten möglicherweise vom Abfrageplan abhängt, insbesondere von 
              den verwendeten Indizes. Es gibt derzeit keine strengen Regeln für solche Situationen, aber das könnte 
              sich in zukünftigen Versionen von Firebird ändern.</para>
        </warning>
      </section> <!-- Cursor idiosyncrasies -->

      <section id="fblangref25-psql-cursor-examples-de">
        <title>Beispiel für benannte Cursor</title>
        <orderedlist>
          <listitem><para>Declaring a named cursor in the trigger.</para>
            <blockquote><programlisting>
CREATE OR ALTER TRIGGER TBU_STOCK
BEFORE UPDATE ON STOCK
AS
  DECLARE C_COUNTRY CURSOR FOR (
    SELECT
      COUNTRY,
      CAPITAL
    FROM COUNTRY
  );
BEGIN
  /* PSQL statements */
END
            </programlisting></blockquote>
          </listitem>
          <listitem><para>Eine Sammlung von Skripts zum Erstellen von Ansichten mit einem PSQL-Block
              unter Verwendung von benannten Cursors.</para>
            <blockquote><programlisting>
EXECUTE BLOCK
RETURNS (
    SCRIPT BLOB SUB_TYPE TEXT)
AS
DECLARE VARIABLE FIELDS VARCHAR(8191);
DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
DECLARE VARIABLE RELATION RDB$RELATION_NAME;
DECLARE VARIABLE SOURCE   TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
DECLARE VARIABLE CUR_R      CURSOR FOR (
    SELECT
        RDB$RELATION_NAME,
        RDB$VIEW_SOURCE
    FROM
        RDB$RELATIONS
    WHERE
        RDB$VIEW_SOURCE IS NOT NULL);
-- Declaring a named cursor where
-- a local variable is used
DECLARE CUR_F      CURSOR FOR (
    SELECT
        RDB$FIELD_NAME
    FROM
        RDB$RELATION_FIELDS
    WHERE
        -- It is important that the variable must be declared earlier
        RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SOURCE;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
    -- The CUR_F cursor will use the value
    -- of the RELATION variable initiated above
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SOURCE;

    SUSPEND;
  END
  CLOSE CUR_R;
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-psql-open-de"><database>OPEN</database></link>,
            <link linkend="fblangref25-psql-fetch-de"><database>FETCH</database></link>,
            <link linkend="fblangref25-psql-close-de"><database>CLOSE</database></link>
          </para>
        </formalpara>
      </section> <!-- Cursor examples -->
    </section> <!-- DECLARE CURSOR -->

    <section id="fblangref25-psql-declare-variable-de">
      <title><database>DECLARE VARIABLE</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Deklaration einer lokalen Variablen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
DECLARE [VARIABLE] &lt;varname&gt;
  {&lt;datatype&gt; | &lt;domain&gt; | TYPE OF {&lt;domain&gt; | COLUMN &lt;rel.col&gt;}
    [NOT NULL]  [CHARACTER SET &lt;charset&gt;] [COLLATE &lt;collation&gt;]
    [{DEFAULT | = } &lt;initvalue&gt;];

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

&lt;initvalue&gt; ::= &lt;literal&gt; | &lt;context_var&gt;
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-declare-variable-de">
      <?dbfo keep-together='auto'?>
        <title>DECLARE VARIABLE-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name der lokalen Variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">Ein SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Der Name einer bestehenden Domain in dieser Datenbank</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel.col</entry>
              <entry align="left">Beziehungsname (Tabelle oder Sicht) in dieser 
                  Datenbank und der Name einer Spalte in dieser Beziehung</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Präzision. Von 1 bis 18</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Rahmen. Von 0 bis 18 muss es kleiner oder gleich der Genauigkeit sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe einer Zeichenfolge in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB-Untertyp-Nummer</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">Mnemonischer Name des BLOB-Untertyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße, nicht größer als 65.535</entry>
            </row>
            <row valign="middle">
              <entry align="center">initvalue</entry>
              <entry align="left">Anfangswert für diese Variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Literal eines Typs, der mit dem Typ der lokalen Variablen kompatibel ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Jede Kontextvariable, deren Typ mit dem Typ der lokalen Variablen kompatibel ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Zeichensatz</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Sortierfolge</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die Anweisung <database>DECLARE [VARIABLE]</database> wird zum Deklarieren
      einer lokalen Variable verwendet. Das Schlüsselwor <database>VARIABLE</database> kann weggelassen werden.
      Je ein <database>DECLARE [VARIABLE]</database>-Statement ist für jede Variable notwendig.
      Jede beliebige Anzahl von <database>DECLARE [VARIABLE]</database>-Statements kann in jeglicher Reihenfolge
      eingefügt werden. Der Name jeder lokalen Variable muss eindeutig innerhalb der lokalen Variablen und Ausgabeparametern
      in der Moduldeklaration sein.</para>

      <section id="fblangref25-psql-variable-type-de">
        <title>Datentypen für Variablen</title>
        <para>Eine lokale Variable kann von einem anderen SQL-Typ als ein Array sein.
          <itemizedlist spacing="compact">
            <listitem><para>Ein Domainname kann als Typ angegeben werden und die
                Variable erbt alle ihre Attribute.</para></listitem>
            <listitem><para>Wenn die TYPE OF &lt;domain&gt;-Klausel verwendet wird, erbt die Variable
                nur den Datentyp der Domain und gegebenenfalls ihre Zeichensatz- und Sortierattribute. 
                Alle Standardwerte oder Einschränkungen wie NOT NULL oder CHECK-Einschränkungen werden nicht 
                vererbt.</para></listitem>
            <listitem><para>Wenn die Option "TYPE OF COLUMN" &lt;relation.column&gt; verwendet wird,
                um Daten aus einer Spalte in einer Tabelle oder Sicht zu <quote>leihen</quote>, 
                wird die Variable nur den Datentyp der Spalte erben, und gegebenenfalls ihren
                Zeichensatz und Sortierattribute. Alle anderen Attribute werden ignoriert.</para></listitem>
          </itemizedlist>
        </para>
      </section>
      
      <section>
        <title>NOT NULL-Constraint</title>
          <para>&nbsp;Die Variable kann bei Bedarf auf NOT NULL beschränkt werden. Wenn eine Domain als 
              Datentyp angegeben wurde und bereits die NOT NULL-Einschränkung enthält, ist sie nicht erforderlich.
              Bei den anderen Formen, einschließlich der Verwendung einer Domain, die nullwertfähig ist, 
              sollte das NOT NULL-Attribut bei Bedarf eingefügt werden.</para>
       </section>
       <section>
         <title>CHARACTER SET- und COLLATE-Klauseln</title>
         <para>&nbsp;Sofern nicht anders angegeben, sind der Zeichensatz und die Sortierfolge einer String-Variablen 
             die Standardeinstellungen der Datenbank. Eine Klausel <database>CHARACTER SET</database> kann bei Bedarf 
             eingefügt werden, um Zeichenkettendaten zu verarbeiten, die sich in einem anderen Zeichensatz befinden. 
             Eine gültige Sortierreihenfolge (<database>COLLATE</database>-Klausel) kann ebenfalls mit oder ohne die 
             Zeichensatzklausel eingeschlossen werden.</para>
      </section>
      <section>
        <title>Initialisieren einer Variablen</title>
        <para>Lokale Variablen sind NULL, wenn die Ausführung des Moduls beginnt. Sie können initialisiert werden, 
            sodass ein Start- oder Standardwert verfügbar ist, wenn sie zum ersten Mal referenziert werden.
        Die Form <database>DEFAULT</database> &lt;initvalue&gt; kann verwendet werden, oder nur der Zuweisungsoperator,
        &quot;=&quot;: = &lt;initvalue&gt;.  Der Wert kann ein beliebiges Typ-kompatibles Literal oder eine Kontextvariable sein.
          <important>
            <para>Stellen Sie sicher, dass Sie diese Klausel für alle Variablen verwenden, die auf NOT NULL festgelegt sind 
                und ansonsten keinen Standardwert haben.</para>
          </important>
        </para>
      </section>

      <section>
        <title>Beispiele für verschiedene Möglichkeiten, lokale Variablen zu deklarieren</title>
        <blockquote><programlisting>
CREATE OR ALTER PROCEDURE SOME_PROC
AS
  -- Declaring a variable of the INT type
  DECLARE I INT;
  -- Declaring a variable of the INT type that does not allow NULL
  DECLARE VARIABLE J INT NOT NULL;
  -- Declaring a variable of the INT type with the default value of 0
  DECLARE VARIABLE K INT DEFAULT 0;
  -- Declaring a variable of the INT type with the default value of 1
  DECLARE VARIABLE L INT = 1;
  -- Declaring a variable based on the COUNTRYNAME domain
  DECLARE FARM_COUNTRY COUNTRYNAME;
  -- Declaring a variable of the type equal to the COUNTRYNAME domain
  DECLARE FROM_COUNTRY TYPE OF COUNTRYNAME;
  -- Declaring a variable with the type of the CAPITAL column in the COUNTRY table
  DECLARE CAPITAL TYPE OF COLUMN COUNTRY.CAPITAL;
BEGIN
  /* PSQL statements */
END
        </programlisting></blockquote>
        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-datatypes-de">Datentypen und Unterdatentypen</link>,
            <link linkend="fblangref25-datatypes-custom-de">Benutzerdefinierte Datentypen &#x2014; Domains</link>,
            <link linkend="fblangref25-ddl-domn-de"><database>CREATE DOMAIN</database></link>
          </para>
        </formalpara>
      </section>
    </section><!-- DECLARE VARIABLE -->

    <section id="fblangref25-psql-beginend-de">
      <title><database>BEGIN ... END</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Einen Block von Anweisungen abgrenzen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
&lt;block&gt; ::=
BEGIN
  &lt;compound_statement&gt;
  [&lt;compound_statement&gt;
  &#x2026;]
END

&lt;compound_statement&gt; ::= {&lt;block&gt; | &lt;statement&gt;;}
        </programlisting></blockquote>
        </para>
      </formalpara>
      <para>Das Konstrukt <database>BEGIN ... END</database> ist eine zweiteilige Anweisung, die einen 
      Block von Anweisungen umhüllt, die als eine Codeeinheit ausgeführt werden. Jeder Block beginnt 
      mit der Halb-Anweisung <database>BEGIN</database> und endet mit der anderen Halb-Anweisung 
      <database>END</database>. Blöcke können in unbegrenzter Tiefe verschachtelt werden. Sie können 
      leer sein, so dass sie als Stubs fungieren können, ohne dass Dummy-Anweisungen geschrieben 
      werden müssen.</para>
      <para>Die Anweisungen BEGIN und END haben keine Zeilenabschlußzeichen. Wenn jedoch ein PSQL-Modul im Dienstprogramm 
          <emphasis>isql</emphasis> definiert oder geändert wird, muss für diese Anwendung der letzten 
          <database>END</database>-Anweisung ein eigenes Terminatorzeichen folgen, das zuvor umgeschaltet wurde. 
          <database>SET TERM</database> auf eine andere Zeichenfolge als ein Semikolon. Dieser Terminator ist 
          nicht Teil der PSQL-Syntax.</para>
      <para>Die letzte oder äußerste <database>END</database>-Anweisung in einem Trigger beendet den Trigger. 
      Was die letzte Anweisung <database>END</database> in einer gespeicherten Prozedur macht, hängt vom 
      Typ der Prozedur ab:
        <itemizedlist spacing="compact">
          <listitem><para>In einer wählbaren Prozedur gibt die endgültige Anweisung <database>END</database> die
          Steuerung an den Aufrufer zurück und gibt SQLCODE 100 zurück, um anzugeben, dass keine weiteren 
          Zeilen abgerufen werden müssen.</para></listitem>
          <listitem><para>In einer ausführbaren Prozedur gibt die endgültige Anweisung <database>END</database>
          die Kontrolle an den Aufrufer zurück, zusammen mit den aktuellen Werten aller definierten 
          Ausgabeparameter.</para></listitem>
        </itemizedlist>
      </para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Eine Beispielprozedur aus der Datenbank <filename>employee.fdb</filename>, die die einfache 
        Verwendung der Blöcke <database>BEGIN ... END</database> zeigt:
          <blockquote><programlisting>
SET TERM ^;
CREATE OR ALTER PROCEDURE DEPT_BUDGET (
    DNO CHAR(3))
RETURNS (
    TOT DECIMAL(12,2))
AS
    DECLARE VARIABLE SUMB DECIMAL(12,2);
    DECLARE VARIABLE RDNO CHAR(3);
    DECLARE VARIABLE CNT  INTEGER;
BEGIN
  TOT = 0;

  SELECT
      BUDGET
  FROM
      DEPARTMENT
  WHERE DEPT_NO = :DNO
  INTO :TOT;

  SELECT
      COUNT(BUDGET)
  FROM
      DEPARTMENT
  WHERE HEAD_DEPT = :DNO
  INTO :CNT;

  IF (CNT = 0) THEN
    SUSPEND;

  FOR
      SELECT
          DEPT_NO
      FROM
          DEPARTMENT
      WHERE HEAD_DEPT = :DNO
      INTO :RDNO
  DO
  BEGIN
    EXECUTE PROCEDURE DEPT_BUDGET(:RDNO)
    RETURNING_VALUES :SUMB;
    TOT = TOT + SUMB;
  END

  SUSPEND;
END^
SET TERM ;^
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exit-de"><database>EXIT</database></link>,
        <link linkend="fblangref25-psql-leave-de"><database>LEAVE</database></link>,
        <link linkend="fblangref25-sidebar01-de"><database>SET TERM</database></link>
        </para>
      </formalpara>
    </section> <!-- begin ... end -->

    <section id="fblangref25-psql-ifthen-de">
      <title><database>IF ... THEN ... ELSE</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Bedingte Sprünge</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
IF (&lt;condition&gt;)
	THEN &lt;single_statement&gt; ; | BEGIN &lt;compound_statement&gt; END
[ELSE &lt;single_statement&gt; ; | BEGIN &lt;compound_statement&gt; END]
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-ifthen-de">
      <?dbfo keep-together='auto'?>
        <title>IF ... THEN ... ELSE Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">Eine logische Bedingung, die TRUE, FALSE oder UNKNOWN zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">Eine einzelne Anweisung wurde mit einem Semikolon abgeschlossen</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Zwei oder mehr Anweisungen, die in BEGIN ... END verpackt sind</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die bedingte Sprunganweisung <database>IF ... THEN</database> wird verwendet, um den 
      Ausführungsprozess in einem PSQL-Modul zu verzweigen. Die Bedingung ist immer in Klammern eingeschlossen. 
      Wenn es den Wert <database>TRUE</database> zurückgibt, verzweigt die Ausführung in die Anweisung oder den 
      Anweisungsblock nach dem Schlüsselwort <database>THEN</database>. Wenn eine <database>ELSE</database> vorhanden 
      ist und die Bedingung FALSE oder UNKNOWN zurückgibt, verzweigt die Ausführung in die Anweisung oder den 
      Anweisungsblock danach.</para>

      <sidebar id="multijump-de">
        <title>Verzweigungen mit mehreren Unterverzweigungen</title>
        <para>PSQL bietet keine Multi-Branch-Sprünge wie CASE oder SWITCH. Nichtsdestoweniger ist die CASE-Suchanweisung 
          von DSQL in PSQL verfügbar und kann zumindest einige Anwendungsfälle in der Art eines Schalters erfüllen:</para>
          <blockquote><programlisting>
CASE &lt;test_expr&gt;
  WHEN &lt;expr&gt; THEN result
  [WHEN &lt;expr&gt; THEN result ...]
  [ELSE defaultresult]
END

CASE
  WHEN &lt;bool_expr&gt; THEN result
  [WHEN &lt;bool_expr&gt; THEN result ...]
  [ELSE defaultresult]
END
          </programlisting></blockquote>
          <formalpara>
            <title>Beispiel in PSQL</title>
            <para>
            <blockquote><programlisting>
...
C = CASE
      WHEN A=2 THEN 1
      WHEN A=1 THEN 3
      ELSE 0
    END;
...
            </programlisting></blockquote>
            </para>
          </formalpara>
      </sidebar> <!-- multi-branch jumps -->

      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Ein Beispiel mit der IF-Anweisung. Angenommen, die Variablen FIRST, LINE2 
            und LAST wurden früher deklariert.
          <blockquote><programlisting>
...
IF (FIRST IS NOT NULL) THEN
     LINE2 = FIRST || ' ' || LAST;
ELSE
     LINE2 = LAST;
...
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-while-de"><database>WHILE ... DO</database></link>,
        <link linkend="fblangref25-commons-conditional-case-de"><database>CASE</database></link>
        </para>
      </formalpara>
    </section> <!-- if ... then ... do -->

    <section id="fblangref25-psql-while-de">
      <title><database>WHILE ... DO</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Schleifenkonstrukte</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
WHILE &lt;condition&gt; DO
&lt;single_statement&gt; ; | BEGIN &lt;compound_statement&gt; END
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-while-de">
      <?dbfo keep-together='auto'?>
        <title>WHILE ... DO Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">Eine logische Bedingung, die TRUE, FALSE oder UNKNOWN zurückgibt</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">Eine einzelne Anweisung wurde mit einem Semikolon abgeschlossen</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Zwei oder mehr Anweisungen, die in BEGIN ... END verpackt sind</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Eine <database>WHILE</database>-Anweisung implementiert das Schleifenkonstrukt in PSQL. 
      Die Anweisung oder der Anweisungsblock wird ausgeführt, bis die Bedingung TRUE zurückgibt. 
      Schleifen können beliebig tief verschachtelt werden.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Eine Prozedur, die die Summe der Zahlen von 1 bis I berechnet, zeigt, wie das 
            Schleifenkonstrukt verwendet wird.
          <blockquote><programlisting>
CREATE PROCEDURE SUM_INT (I INTEGER)
RETURNS (S INTEGER)
AS
BEGIN
  s = 0;
  WHILE (i > 0) DO
  BEGIN
    s = s + i;
    i = i - 1;
  END
END
          </programlisting></blockquote>
        Ausführen der Prozedur in <emphasis>isql</emphasis>:
          <blockquote><programlisting>
EXECUTE PROCEDURE SUM_INT(4);
          </programlisting></blockquote>
        Das Ergebnis ist:
          <blockquote><programlisting>
S
==========
10
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-ifthen-de"><database>IF ... THEN ... ELSE</database></link>,
        <link linkend="fblangref25-psql-leave-de"><database>LEAVE</database></link>,
        <link linkend="fblangref25-psql-exit-de"><database>EXIT</database></link>,
        <link linkend="fblangref25-psql-forselect-de"><database>FOR SELECT</database></link>,
        <link linkend="fblangref25-psql-forexec-de"><database>FOR EXECUTE STATEMENT</database></link>
        </para>
      </formalpara>
    </section> <!-- while -->

    <section id="fblangref25-psql-leave-de">
      <title><database>LEAVE</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Eine Schleife beenden</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
[label:]
&lt;loop&gt;
BEGIN
  ...
  LEAVE [label];
  ...
END
&lt;loop_stmt&gt; ::=
    FOR &lt;select_stmt&gt; INTO &lt;var_list&gt; DO
  | FOR EXECUTE STATEMENT ... INTO &lt;var_list&gt; DO
  | WHILE (&lt;condition&gt;)} DO
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-leave-de">
      <?dbfo keep-together='auto'?>
        <title>LEAVE-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">label</entry>
              <entry align="left">Label</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_stmt	</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">Eine logische Bedingung, die TRUE, FALSE oder UNKNOWN zurückgibt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Eine <database>LEAVE</database>-Anweisung beendet sofort die innere Schleife einer 
      <database>WHILE</database> oder <database>FOR</database> Schleifenanweisung. Der Parameter 
      <database>LABEL</database> ist optional.</para>
      <para><database>LEAVE</database> kann auch zum Beenden von äußeren Schleifen führen. Code 
      wird weiterhin von der ersten Anweisung nach der Beendigung des äußeren Schleifenblocks 
      ausgeführt.</para>
      <formalpara>
        <title>Beispiele</title>
        <para>
        <orderedlist>
          <listitem><para>Eine Schleife verlassen, wenn bei einem Einfügen in die NUMBERS-Tabelle ein
              Fehler auftritt. Der Code wird weiterhin von der Zeile C = 0 ausgeführt.</para>
            <blockquote><programlisting>
...
WHILE (B &lt; 10) DO
BEGIN
    INSERT INTO NUMBERS(B)
    VALUES (:B);
    B = B + 1;
    WHEN ANY DO
    BEGIN
        EXECUTE PROCEDURE LOG_ERROR (
             CURRENT_TIMESTAMP,
             'ERROR IN B LOOP');
        LEAVE;
    END
END
C = 0;
...
            </programlisting></blockquote>
          </listitem>

          <listitem><para>Ein Beispiel für die Verwendung von Labels in der <database>LEAVE</database>-Anweisung.
          <function>LEAVE LOOPA</function> beendet die äußere Schleife und <function>LEAVE LOOPB</function>
          beendet die innere Schleife. Beachten Sie, dass die einfache Anweisung <database>LEAVE</database> 
          ausreichen würde, um die innere Schleife zu beenden.</para>
            <blockquote><programlisting>
...
STMT1 = 'SELECT NAME FROM FARMS';
LOOPA:
FOR EXECUTE STATEMENT :STMT1
INTO :FARM DO
BEGIN
  STMT2 = 'SELECT NAME ' || 'FROM ANIMALS WHERE FARM = ''';
  LOOPB:
  FOR EXECUTE STATEMENT :STMT2 || :FARM || ''''
  INTO :ANIMAL DO
  BEGIN
    IF (ANIMAL = 'FLUFFY') THEN
      LEAVE LOOPB;
    ELSE IF (ANIMAL = FARM) THEN
      LEAVE LOOPA;
    ELSE
      SUSPEND;
  END
END
...
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exit-de"><database>EXIT</database></link>
        </para>
      </formalpara>
    </section> <!-- leave -->

    <section id="fblangref25-psql-exit-de">
      <title><database>EXIT</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Beenden der Modulausführung</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
EXIT;
        </programlisting></blockquote>
        </para>
      </formalpara>
      <para>Die Anweisung <database>EXIT</database> bewirkt, dass die Ausführung der 
      Prozedur oder des Triggers von jedem Punkt des Codes zur endgültigen 
      <database>END</database>-Anweisung springt, wodurch das Programm beendet wird.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>Verwenden der EXIT-Anweisung in einer auswählbaren Prozedur:
          <blockquote><programlisting>
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-leave-de"><database>LEAVE</database></link>,
        <link linkend="fblangref25-psql-suspend-de"><database>SUSPEND</database></link>
        </para>
      </formalpara>
    </section> <!-- EXIT -->

    <section id="fblangref25-psql-suspend-de">
      <title><database>SUSPEND</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Übergeben der Ausgabe an den Puffer und Aussetzen der Ausführung, 
            während darauf gewartet wird, dass der Aufrufer sie abruft</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
SUSPEND;
        </programlisting></blockquote>
        </para>
      </formalpara>
      <para>Die Anweisung <database>SUSPEND</database> wird in einer auswählbaren gespeicherten Prozedur verwendet, 
          um die Werte von Ausgabeparametern an einen Puffer zu übergeben und die Ausführung anzuhalten. Die Ausführung 
          bleibt ausgesetzt, bis die aufrufende Anwendung den Inhalt des Puffers abruft. Die Ausführung wird von der 
          Anweisung direkt nach der <database>SUSPEND</database>-Anweisung fortgesetzt. In der Praxis ist dies wahrscheinlich 
          eine neue Iteration eines Schleifenprozesses.
        <important>
          <title>Wichtige Hinweise</title>
          <orderedlist>
            <listitem><para>Anwendungen, die Schnittstellen verwenden, die die API umschließen, 
                führen die Abrufe von auswählbaren Prozeduren transparent aus.</para>
            </listitem>
            <listitem><para>Wenn eine <database>SUSPEND</database> -Anweisung in einer ausführbaren gespeicherten Prozedur 
                ausgeführt wird, entspricht dies der Ausführung der Anweisung <database>EXIT</database>, was zu einer 
                    sofortigen Beendigung der Prozedur führt.</para>
            </listitem>
            <listitem><para><database>SUSPEND</database> <quote>unterbricht</quote> die Atomizität des Blocks, in dem es 
            sich befindet. Wenn in einer auswählbaren Prozedur ein Fehler auftritt, werden Anweisungen, die nach der endgültigen
            <database>SUSPEND</database>-Anweisung ausgeführt werden, zurückgesetzt. Anweisungen, die vor der endgültigen 
            <database>SUSPEND</database>-Anweisung ausgeführt wurden, werden erst zurückgesetzt, wenn die Transaktion 
            zurückgesetzt wird.</para>
            </listitem>
          </orderedlist>
        </important>
      </para>
      <formalpara>
        <title>Beispiel</title>
        <para>Verwenden der Anweisung <database>SUSPEND</database> in einer auswählbaren Prozedur:
          <blockquote><programlisting>
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exit-de"><database>EXIT</database></link>
      </para>
      </formalpara>
    </section> <!-- suspend -->

    <section id="fblangref25-psql-execstmt-de">
      <title><database>EXECUTE STATEMENT</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Ausführen dynamisch erstellter SQL-Anweisungen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <para>
        <blockquote><programlisting>
&lt;execute_statement&gt; ::= EXECUTE STATEMENT &lt;argument&gt;
  [&lt;option&gt; &#x2026;]
  [INTO &lt;variables&gt;]

&lt;argument&gt; ::= paramless_stmt
            | (paramless_stmt)
            | (&lt;stmt_with_params&gt;) (&lt;param_values&gt;)

&lt;param_values&gt; ::= &lt;named_values&gt; | &lt;positional_values&gt;

&lt;named_values&gt; ::= paramname := value_expr
   [, paramname := value_expr ...]

&lt;positional_values&gt; ::= value_expr [, value_expr ...]

&lt;option&gt; ::= WITH {AUTONOMOUS | COMMON} TRANSACTION
           | WITH CALLER PRIVILEGES
           | AS USER user
           | PASSWORD password
           | ROLE role
           | ON EXTERNAL [DATA SOURCE] &lt;connect_string&gt;

&lt;connect_string&gt; ::= [&lt;hostspec&gt;] {filepath | db_alias}

&lt;hostspec&gt; ::= &lt;tcpip_hostspec&gt; | &lt;NamedPipes_hostspec&gt;

&lt;tcpip_hostspec&gt; ::= hostname:

&lt;NamePipes_hostspec&gt; ::= \\hostname\

&lt;variables&gt; ::= [:]varname [, [:]varname ...]
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-execstmt-de">
      <?dbfo keep-together='auto'?>
        <title>EXECUTE STATEMENT-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">paramless_stmt</entry>
              <entry align="left">Literale Zeichenfolge oder Variable, die eine nicht parametrisierte 
                  SQL-Abfrage enthält</entry>
            </row>
            <row valign="middle">
              <entry align="center">stmt_with_params</entry>
              <entry align="left">Literale Zeichenfolge oder Variable, die eine parametrisierte 
                  SQL-Abfrage enthält</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">Name des SQL-Abfrageparameters</entry>
            </row>
            <row valign="middle">
              <entry align="center">value_expr</entry>
              <entry align="left">SQL-Ausdruck, der in einen Wert aufgelöst wird</entry>
            </row>
            <row valign="middle">
              <entry align="center">user</entry>
              <entry align="left">Nutzername. Dies kann eine Zeichenfolge, <database>CURRENT_USER</database> 
              oder eine Zeichenfolgenvariable sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">password</entry>
              <entry align="left">Passwort. Es kann eine Zeichenfolge oder eine Zeichenfolgevariable sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">role</entry>
              <entry align="left">Rolle. Dies kann eine Zeichenfolge, <database> CURRENT_ROLE </database> oder 
              eine Zeichenfolgenvariable sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">connection_string</entry>
              <entry align="left">Verbindungszeichenfolge Es kann eine Zeichenfolge oder eine Zeichenfolgevariable sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Pfad zur primären Datenbankdatei</entry>
            </row>
            <row valign="middle">
              <entry align="center">db_alias</entry>
              <entry align="left">Datenbankalias</entry>
            </row>
            <row valign="middle">
              <entry align="center">hostname</entry>
              <entry align="left">Computername oder IP-Adresse</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>EXECUTE STATEMENT</database> verwendet einen Zeichenfolgenparameter und 
      führt ihn wie eine DSQL-Anweisung aus. Wenn die Anweisung Daten zurückgibt, kann sie über eine 
      <database>INTO</database> -Klausel an lokale Variablen übergeben werden.</para>

      <section id="fblangref25-psql-execstmt-wparams-de">
        <title>Parametrisierte Anweisungen</title>
        <para>Sie können die Parameter &#x2014; entweder benannt oder positional &#x2014; in der DSQL-Anweisungsfolge verwenden. 
            Jedem Parameter muss ein Wert zugewiesen werden.</para>
        <section id="fblangref25-psql-execstmt-wparams01-de">
          <title>Spezielle Regeln für parametrisierte Anweisungen</title>
          <orderedlist>
            <listitem>
              <para>Benannte und positionale Parameter können nicht in einer Abfrage gemischt werden</para>
            </listitem>
            <listitem>
              <para>Wenn die Anweisung Parameter hat, müssen sie beim Aufruf von <database>EXECUTE STATEMENT</database> 
              in Klammern stehen, unabhängig davon, ob sie direkt als Strings, als Variablennamen oder als Ausdrücke 
              verwendet werden</para>
            </listitem>
            <listitem>
              <para>Jedem benannten Parameter muss in der Anweisungszeichenfolge ein Doppelpunkt (:) vorangestellt werden, 
                  jedoch nicht, wenn dem Parameter ein Wert zugewiesen ist</para>
            </listitem>
            <listitem>
              <para>Positionsparameter müssen ihre Werte in derselben Reihenfolge erhalten, in der sie im 
                  Abfragetext erscheinen</para>
            </listitem>
            <listitem>
              <para>Der Zuweisungsoperator für Parameter ist der Spezialoperator ": =", ähnlich dem Zuweisungsoperator 
                  in Pascal</para>
            </listitem>
            <listitem>
              <para>Jeder benannte Parameter kann mehrmals in der Anweisung verwendet werden, sein Wert muss jedoch nur 
                  einmal zugewiesen werden</para>
            </listitem>
            <listitem>
              <para>Bei Positionsparametern muss die Anzahl der zugewiesenen Werte genau der Anzahl der Parameterplatzhalter 
                  (Fragezeichen) in der Anweisung entsprechen</para>
            </listitem>
          </orderedlist>
        </section> <!-- special rules -->

        <section>
          <title>Beispiele</title>
          <para>&nbsp;Mit benannten Paramtern:</para>
            <blockquote><programlisting>
...
DECLARE license_num VARCHAR(15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = :driver AND location = :loc';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  INTO connect_string;
  ...
  FOR
    SELECT id
    FROM drivers
    INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
        (driver := current_driver,
         loc := current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...
            </programlisting></blockquote>
          <para>Derselbe Code mit Positionsparametern:</para>
            <blockquote><programlisting>
DECLARE license_num VARCHAR (15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = ? AND location = ?';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  into connect_string;
  ...
  FOR SELECT id
      FROM drivers
      INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
        (current_driver, current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...
            </programlisting></blockquote>
         </section>
      </section> <!-- parameterised statements -->

      <section id="fblangref25-psql-execstmt-wautonomous-de">
        <title><database>WITH {AUTONOMOUS | COMMON} TRANSACTION</database></title>
        <para>Üblicherweise lief die ausgeführte SQL-Anweisung immer innerhalb der aktuellen Transaktion, 
            und dies ist immer noch der Standardwert. <database>WITH AUTONOMOUS TRANSACTION</database> 
            bewirkt, dass eine separate Transaktion mit denselben Parametern wie die aktuelle Transaktion 
            gestartet wird. Es wird festgeschrieben, wenn die Anweisung ohne Fehler ausgeführt wird und 
            andernfalls zurückgesetzt wird. <database> WITH COMMON TRANSACTION </database> verwendet, 
            wenn möglich, die aktuelle Transaktion.</para>
        <para>Wenn die Anweisung in einer separaten Verbindung ausgeführt werden muss, wird eine bereits 
            gestartete Transaktion innerhalb dieser Verbindung verwendet, sofern verfügbar. Andernfalls 
            wird eine neue Transaktion mit den gleichen Parametern wie die aktuelle Transaktion gestartet. 
            Alle neuen Transaktionen, die unter dem <quote>COMMON </quote>-Regime gestartet wurden, 
            werden mit der aktuellen Transaktion festgeschrieben oder zurückgesetzt.</para>
      </section> <!-- with autonomous -->

      <section id="fblangref25-psql-execstmt-wcaller-de">
        <title><database>WITH CALLER PRIVILEGES</database></title>
        <para>Standardmäßig wird die SQL-Anweisung mit den Berechtigungen des aktuellen Benutzers ausgeführt. 
            Die Angabe von <database>WITH CALLER PRIVILEGES</database> fügt dazu die Privilegien der aufrufenden 
            Prozedur oder des Triggers hinzu, so als ob die Anweisung direkt von der Routine ausgeführt würde. 
            <database>WITH WITH CALLER PRIVILEGES</database> hat keine Auswirkung, wenn die Klausel 
            <database>ON EXTERNAL</database> ebenfalls vorhanden ist.</para>
      </section> <!-- with caller privileges -->

      <section id="fblangref25-psql-execstmt-onexternal-de">
        <title><database>ON EXTERNAL [DATA SOURCE]</database></title>
        <para>Mit <database>ON EXTERNAL [DATA SOURCE]</database> wird die SQL-Anweisung in einer separaten 
        Verbindung zu derselben oder einer anderen Datenbank ausgeführt, möglicherweise sogar auf einem anderen 
        Server. Wenn die Verbindungszeichenfolge NULL oder '' (leere Zeichenfolge) ist, wird die gesamte Klausel 
        <database>ON EXTERNAL [DATA SOURCE]</database> als abwesend betrachtet und die Anweisung wird für die 
        aktuelle Datenbank ausgeführt.</para>
        <section id="fblangref25-psql-execstmt-onext-connpool-de">
          <title>Verbindungspooling</title>
          <itemizedlist>
            <listitem><para>Externe Verbindungen, die durch Anweisungen <database>WITH COMMON TRANSACTION</database>
            (der Standardwert) hergestellt werden, bleiben geöffnet, bis die aktuelle Transaktion beendet wird. 
            Sie können durch nachfolgende Aufrufe an <database>EXECUTE STATEMENT</database> wiederverwendet 
                werden, aber nur, wenn die Verbindungszeichenfolge genau gleich ist, einschließlich case</para></listitem>
            <listitem><para>Externe Verbindungen, die durch Anweisungen <database>WITH AUTONOMOUS TRANSACTION</database>
            hergestellt werden, werden geschlossen, sobald die Anweisung ausgeführt wurde</para></listitem>
            <listitem><para>Beachten Sie, dass Statements unter <database>WITH AUTONOMOUS TRANSACTION</database>-Verbindungen,
                die zuvor von Anweisungen unter <database>WITH COMMON TRANSACTION</database> geöffnet wurden, wiederverwendet 
                werden. Wenn dies geschieht, bleibt die wiederverwendete Verbindung nach der Ausführung der 
                Anweisung offen. (Dies geschieht, da es mindestens eine nicht-abgeschlossene Transaktion gibt!)</para></listitem>
          </itemizedlist>
        </section>
        <section id="fblangref25-psql-execstmt-onext-transpool-de">
          <title>Transaktionspooling</title>
          <itemizedlist>
            <listitem><para>Wenn <database>WITH COMMON TRANSACTION</database> aktiviert ist, werden Transaktionen so oft wie möglich
                wiederverwendet. Sie werden zusammen mit der aktuellen Transaktion festgeschrieben oder zurückgesetzt</para></listitem>
            <listitem><para>Wenn <database>WITH AUTONOMOUS TRANSACTION</database> angegeben ist, wird immer eine neue Transaktion
                für die Anweisung gestartet. Diese Transaktion wird unmittelbar nach der Ausführung der Anweisung festgeschrieben 
                oder zurückgesetzt</para></listitem>
          </itemizedlist>
        </section>
        <section id="fblangref25-psql-execstmt-onext-errhandling-de">
          <title>Ausnahmebehandlung</title>
          <para>Ausnahmebehandlung: Wenn <database>ON EXTERNAL</database> verwendet wird, erfolgt die zusätzliche Verbindung immer 
                über einen sogenannten externen Provider, auch wenn die Verbindung zur aktuellen Datenbank besteht. Eine der Folgen ist, 
                dass Ausnahmen nicht auf die übliche Art und Weise abgefangen werden können. Jede von der Anweisung verursachte Ausnahme 
                wird entweder in einen <function>eds_connection</function>- oder einen <function>eds_statement</function>-Fehler 
                enden. Um sie in Ihrem PSQL-Code abzufangen, müssen Sie <database>WHEN GDSCODE eds_connection</database>, 
                <database>WHEN GDSCODE eds_statement</database> oder <database>WHEN ANY</database> verwenden.
            <note>
              <para>Ohne <database>ON EXTERNAL</database> werden Ausnahmen auf die übliche Weise abgefangen, selbst wenn eine zusätzliche 
              Verbindung zur aktuellen Datenbank hergestellt wird.</para>
            </note>
          </para>
        </section>
        <section id="fblangref25-psql-execstmt-onext-morenotes-de">
          <title>Verschiedene Hinweise</title>
          <itemizedlist>
            <listitem><para>Der für die externe Verbindung verwendete Zeichensatz ist der gleiche wie für die aktuelle Verbindung</para></listitem>
            <listitem><para>Zweiphasen-Commits werden nicht unterstützt</para></listitem>
          </itemizedlist>
        </section>
      </section> <!-- onexternal -->

      <section id="fblangref25-psql-execstmt-asuser-de">
        <title><database>AS USER, PASSWORD</database> und <database>ROLE</database></title>
        <para>Die optionalen Klauseln <database>AS USER, PASSWORD</database> und <database>ROLE</database> 
        erlauben die Angabe unter welchem Benutzer und unter welcher Rolle das SQL-Statement ausgeführt wird.
        Die Methode der Benutzeranmeldung und die Existenz einer separaten offenen Verbindung hängt von dem Vorhandensein
        und den Werten der Klauseln
        <database>ON EXTERNAL [DATA SOURCE]</database>, <database>AS USER</database>,
        <database>PASSWORD</database> und <database>ROLE</database> ab:
        <itemizedlist>
          <listitem><para>Wenn <database>ON EXTERNAL</database> verwendet wird, wird immer eine neue Verbindung aufgebaut und:</para>
            <itemizedlist spacing="compact">
              <listitem><para>Wenn mindestens eines von <database>AS USER, PASSWORD</database> und <database>ROLE</database>
              vorhanden ist, wird die native Authentifizierung mit den angegebenen Parameterwerten versucht 
              (lokal oder remote abhängig von der Verbindungszeichenfolge). Für fehlende Parameter werden keine 
              Standardwerte verwendet</para></listitem>
              <listitem><para>Wenn alle drei nicht vorhanden sind und die Verbindungszeichenfolge keinen Hostnamen enthält,
                  wird die neue Verbindung auf dem lokalen Host mit demselben Benutzer und derselben Rolle wie die 
                  aktuelle Verbindung hergestellt. Der Begriff "lokal" bedeutet hier "auf der gleichen Maschine wie der Server". 
                  Dies ist nicht unbedingt der Standort des Clients</para></listitem>
              <listitem><para>Wenn alle drei nicht vorhanden sind und die Verbindungszeichenfolge einen Hostnamen enthält, wird eine
                  vertrauenswürdige Authentifizierung auf dem Remote-Host versucht (aus der Perspektive des Servers wiederum "Remote").
                  Wenn dies erfolgreich ist, gibt das Remote-Betriebssystem den Benutzernamen an (normalerweise das Betriebssystemkonto, 
                  unter dem der Firebird-Prozess ausgeführt wird).</para></listitem>
             </itemizedlist>
          </listitem>
          <listitem><para>Fehlt <database>ON EXTERNAL</database>:</para>
            <itemizedlist spacing="compact">
              <listitem><para>Wenn mindestens eines von <database>AS USER, PASSWORD</database> und <database>ROLE</database> vorhanden ist,
                  wird eine neue Verbindung zur aktuellen Datenbank mit den angegebenen Parameterwerten geöffnet. Für fehlende Parameter 
                  werden keine Standardwerte verwendet</para></listitem>
              <listitem><para>Wenn alle drei nicht vorhanden sind, wird die Anweisung innerhalb der aktuellen Verbindung ausgeführt</para></listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
        <note>
          <title>Hinweis</title>
          <para>Wenn ein Parameterwert NULL oder '' (leere Zeichenfolge) ist, wird der gesamte Parameter als abwesend betrachtet. 
              Darüber hinaus gilt <database>AS USER</database> als abwesend, wenn der Wert gleich <database>CURRENT_USER</database> und 
              <database>ROLE</database> wenn es identisch mit <database>CURRENT_ROLE</database> ist.</para>
        </note>
        </para>
      </section> <!-- AS USER, etc. -->

      <section id="fblangref25-psql-execstmt-caveats-de">
        <title>Vorsicht mit <database>EXECUTE STATEMENT</database></title>
        <orderedlist>
          <listitem><para>Es gibt keine Möglichkeit, die Syntax der enthaltenen Anweisung zu überprüfen</para></listitem>
          <listitem><para>Es gibt keine Abhängigkeitsprüfungen, um festzustellen, ob Tabellen oder Spalten gelöscht wurden</para></listitem>
          <listitem><para>Obwohl die Leistung in Schleifen in Firebird 2.5 erheblich verbessert wurde, ist die Ausführung
              immer noch erheblich langsamer als wenn dieselben Anweisungen direkt gestartet werden</para></listitem>
          <listitem><para>Rückgabewerte werden streng auf den Datentyp überprüft, um unvorhersehbare Ausnahmen für das Typcasting zu vermeiden.
              Beispielsweise würde die Zeichenfolge '1234' in eine Ganzzahl, 1234, konvertiert, aber 'abc' würde einen 
              Konvertierungsfehler ergeben</para></listitem>
        </orderedlist>
        <para>Alles in allem sollte diese Funktion sehr vorsichtig verwendet werden und Sie sollten immer die Vorbehalte berücksichtigen. 
            Wenn Sie das gleiche Ergebnis mit PSQL und / oder DSQL erzielen können, ist dies fast immer vorzuziehen.</para>
        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-psql-forexec-de"><database>FOR EXECUTE STATEMENT</database></link>
          </para>
        </formalpara>
      </section> <!-- caveats -->

    </section> <!-- execute statement -->

    <section id="fblangref25-psql-forselect-de">
      <title><database>FOR SELECT</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Zeilenweises Durchlaufen einer ausgewählten Ergebnismenge</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
FOR &lt;select_stmt&gt; [AS CURSOR cursorname]
DO {&lt;single_statement&gt; | BEGIN &lt;compound_statement&gt; END}
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-forselect-de">
      <?dbfo keep-together='auto'?>
        <title>FOR SELECT-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">select_stmt</entry>
              <entry align="left">SELECT-Statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Name des Cursors. Dieser muss eindeutig unter den Cursor-Namen 
                  im PSQL-Modul (gespeicherte Prozedur, Trigger oder PSQL-Block) sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">Eine einzelne Anweisung, die mit einem Doppelpunkt abgeschlossen 
                  wird und die gesamte Verarbeitung für diese FOR-Schleife ausführt</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Ein Anweisungsblock, der in BEGIN ... END eingeschlossen ist und 
                  der die gesamte Verarbeitung für diese FOR-Schleife ausführt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Ein <database>FOR SELECT</database>-Statement
        <itemizedlist>
          <listitem>
            <para>ruft jede Zeile sequenziell aus der Ergebnismenge ab und führt die Anweisung 
                oder den Anweisungsblock in der Zeile aus. In jeder Iteration der Schleife 
                werden die Feldwerte der aktuellen Zeile in vordefinierte Variablen kopiert.</para>
            <para>Mit der Klausel <database>AS CURSOR</database> können positionierte Löschungen 
                und Aktualisierungen durchgeführt werden, siehe unten</para>
          </listitem>
          <listitem><para>kann andere <database>FOR SELECT</database>-Anweisungen einbetten</para></listitem>
          <listitem>
            <para>kann benannte Parameter enthalten, die zuvor in der <database>DECLARE VARIABLE</database>-Anweisung
            deklariert werden müssen, oder als Eingabe- oder Ausgabeparameter der Prozedur vorhanden sein</para></listitem>
          <listitem><para>erfordert eine <database>INTO</database>-Klausel, die sich am Ende der
          <database>SELECT ... FROM ...</database>-Spezifikation befindet. In jeder Iteration der Schleife werden 
          die Feldwerte in der aktuellen Zeile in die Liste der Variablen kopiert, die in der Klausel 
          <database>INTO</database> angegeben sind. Die Schleife wird wiederholt, bis alle Zeilen abgerufen wurden. 
          Danach wird sie beendet</para></listitem>
          <listitem><para>kann mit einem <database>LEAVE</database>-Statement beendet werden, bevor alle Zeilen abgeholt wurden.</para>
            </listitem>
        </itemizedlist>
      </para>
      <section id="fblangref25-psql-undeclaredcursor-de">
        <title>Der undeklarierte Cursor</title>
        <para>Die optionale <database>AS CURSOR</database>-Klausel behandelt den Satz in der 
        <database>FOR SELECT</database>-Struktur als nicht deklarierten benannten Cursor, der mit der 
        <database>WHERE CURRENT OF</database>-Klausel bearbeitet werden kann, innerhalb der Anweisung oder 
        des Blocks nach dem Befehl <database>DO</database>, um die aktuelle Zeile zu löschen oder zu aktualisieren, 
        bevor die Ausführung zur nächsten Iteration übergeht.</para>
        <para>Weitere Punkte, die in Bezug auf nicht deklarierte Cursor berücksichtigt werden müssen:
          <orderedlist>
            <listitem><para>Die Anweisungen <database>OPEN</database>, <database>FETCH</database> und <database>CLOSE</database>
            können nicht auf einen Cursor angewendet werden, der durch die Klausel <database>AS CURSOR</database> 
            angezeigt wird</para></listitem>
            <listitem><para>Das Argument cursorname, das einer Klausel <database>AS CURSOR</database> zugeordnet ist, darf nicht
            mit Namen kollidieren, die von den Anweisungen <database>DECLARE VARIABLE</database> oder <database>DECLARE CURSOR</database> 
            am Anfang der body-Codes, noch mit anderen Cursorn, die durch eine Klausel <database>AS CURSOR</database> erstellt wurden</para></listitem>
            <listitem><para>Die optionale Klausel <database>FOR UPDATE</database> in der Anweisung <database>SELECT</database> ist für ein
            positioniertes Update nicht erforderlich</para></listitem>
          </orderedlist>
        </para>
      </section><!-- the undeclared cursor -->

      <section>
        <title>Beispiele für die Verwendung von FOR SELECT</title>
        <orderedlist>
          <listitem><para>Eine einfache Schleife durch Abfrageergebnisse:</para>
            <blockquote><programlisting>
CREATE PROCEDURE SHOWNUMS
RETURNS (
  AA INTEGER,
  BB INTEGER,
  SM INTEGER,
  DF INTEGER)
AS
BEGIN
  FOR SELECT DISTINCT A, B
      FROM NUMBERS
    ORDER BY A, B
    INTO AA, BB
  DO
  BEGIN
    SM = AA + BB;
    DF = AA - BB;
    SUSPEND;
  END
END
            </programlisting></blockquote>
          </listitem>
          <listitem><para>Geschachtelte FOR SELECT-Schleife:</para>
            <blockquote><programlisting>
CREATE PROCEDURE RELFIELDS
RETURNS (
  RELATION CHAR(32),
  POS INTEGER,
  FIELD CHAR(32))
AS
BEGIN
  FOR SELECT RDB$RELATION_NAME
      FROM RDB$RELATIONS
      ORDER BY 1
      INTO :RELATION
  DO
  BEGIN
    FOR SELECT
          RDB$FIELD_POSITION + 1,
          RDB$FIELD_NAME
        FROM RDB$RELATION_FIELDS
        WHERE
          RDB$RELATION_NAME = :RELATION
        ORDER BY RDB$FIELD_POSITION
        INTO :POS, :FIELD
    DO
    BEGIN
      IF (POS = 2) THEN
        RELATION = ' "';

      SUSPEND;
    END
  END
END
            </programlisting></blockquote>
          </listitem>
          <listitem><para>Verwenden Sie die <database>AS CURSOR</database>-Klausel,
          um einen Cursor für das positionierte Löschen eines Datensatzes zu verwenden:</para>
            <blockquote><programlisting>
CREATE PROCEDURE DELTOWN (
  TOWNTODELETE VARCHAR(24))
RETURNS (
  TOWN VARCHAR(24),
  POP INTEGER)
AS
BEGIN
  FOR SELECT TOWN, POP
      FROM TOWNS
      INTO :TOWN, :POP AS CURSOR TCUR
  DO
  BEGIN
    IF (:TOWN = :TOWNTODELETE) THEN
      -- Positional delete
      DELETE FROM TOWNS
      WHERE CURRENT OF TCUR;
    ELSE
      SUSPEND;
  END
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor-de"><database>DECLARE CURSOR</database></link>,
            <link linkend="fblangref25-psql-leave-de"><database>LEAVE</database></link>,
            <link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>,
            <link linkend="fblangref25-dml-update-de"><database>UPDATE</database></link>,
            <link linkend="fblangref25-dml-delete-de"><database>DELETE</database></link>
          </para>
        </formalpara>
      </section>
    </section> <!-- for select -->

    <section id="fblangref25-psql-forexec-de">
      <title><database>FOR EXECUTE STATEMENT</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Ausführen von dynamisch erstellten SQL-Anweisungen, die einen Zeilensatz zurückgeben</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
FOR &lt;execute_statement&gt; DO {&lt;single_statement&gt; | BEGIN &lt;compound_statement&gt; END}
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-forexec-de">
      <?dbfo keep-together='auto'?>
        <title>FOR EXECUTE STATEMENT-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">execute_stmt</entry>
              <entry align="left">Ein EXECUTE STATEMENT-String</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">Eine einzelne Anweisung, die mit einem Doppelpunkt abgeschlossen wird und 
                  die gesamte Verarbeitung für diese FOR-Schleife ausführt</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Ein Anweisungsblock, der in BEGIN ... END eingeschlossen ist und der die 
                  gesamte Verarbeitung für diese FOR-Schleife ausführt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>FOR EXECUTE STATEMENT</database> wird in Analogie zu <database>FOR SELECT</database> 
      verwendet, um die Ergebnismenge einer dynamisch ausgeführten Abfrage, die mehrere Zeilen zurückgibt, zu durchlaufen.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Ausführen einer dynamisch erstellten Abfrage <database>SELECT</database>, die einen Datensatz zurückgibt:
          <blockquote><programlisting>
CREATE PROCEDURE DynamicSampleThree (
   Q_FIELD_NAME VARCHAR(100),
   Q_TABLE_NAME VARCHAR(100)
) RETURNS(
  LINE VARCHAR(32000)
)
AS
  DECLARE VARIABLE P_ONE_LINE VARCHAR(100);
BEGIN
  LINE = '';
  FOR
    EXECUTE STATEMENT
      'SELECT T1.' || :Q_FIELD_NAME ||
      ' FROM ' || :Q_TABLE_NAME || ' T1 '
    INTO :P_ONE_LINE
  DO
    IF (:P_ONE_LINE IS NOT NULL) THEN
      LINE = :LINE || :P_ONE_LINE || ' ';
  SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-execstmt-de"><database>EXECUTE STATEMENT</database></link>
        </para>
      </formalpara>
    </section> <!-- FOR EXECUTE STATEMENT -->

    <section id="fblangref25-psql-open-de">
      <title><database>OPEN</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Öffnen eines deklarierten Cursors</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
OPEN cursorname;
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-open-de">
      <?dbfo keep-together='auto'?>
        <title>OPEN Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Name des Cursors. Ein Cursor mit diesem Namen muss zuvor mit 
                  einer <database>DECLARE CURSOR</database>-Anweisung deklariert werden</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Eine <database>OPEN</database> -Anweisung öffnet einen zuvor deklarierten Cursor, 
      führt die für sie deklarierte <database>SELECT</database> -Anweisung aus und macht den ersten 
      Datensatz zum abzurufenden Ergebnisdatensatz. <database>OPEN</database> kann nur auf zuvor in einer 
      <database>DECLARE VARIABLE</database>-Anweisung deklarierte Cursor angewendet werden.
        <note>
          <para>Wenn die für den Cursor deklarierte Anweisung <database>SELECT</database> über Parameter 
          verfügt, müssen sie als lokale Variablen deklariert sein oder als Ein- oder Ausgabeparameter vor 
          dem Deklarieren des Cursors vorhanden sein. Wenn der Cursor geöffnet wird, wird dem Parameter 
          der aktuelle Wert der Variablen zugewiesen.</para>
        </note>
      </para>
      <formalpara>
        <title>Beispiele</title>
        <para>
        <orderedlist>
          <listitem><para>Verwenden der OPEN-Anweisung:</para>
            <blockquote><programlisting>
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^
            </programlisting></blockquote>
          </listitem>
          <listitem><para>Eine Sammlung von Skripts zum Erstellen von Ansichten mit einem PSQL-Block mit benannten Cursorn:</para>
            <blockquote><programlisting>
EXECUTE BLOCK
RETURNS (
    SCRIPT BLOB SUB_TYPE TEXT)
AS
DECLARE VARIABLE FIELDS VARCHAR(8191);
DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
DECLARE VARIABLE RELATION RDB$RELATION_NAME;
DECLARE VARIABLE SOURCE   TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
-- named cursor
DECLARE VARIABLE CUR_R      CURSOR FOR (
    SELECT
        RDB$RELATION_NAME,
        RDB$VIEW_SOURCE
    FROM
        RDB$RELATIONS
    WHERE
        RDB$VIEW_SOURCE IS NOT NULL);
-- named cursor with local variable
DECLARE CUR_F      CURSOR FOR (
    SELECT
        RDB$FIELD_NAME
    FROM
        RDB$RELATION_FIELDS
    WHERE
          -- Important! The variable shall be declared earlier
        RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SOURCE;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
        -- The CUR_F cursor will use
        -- variable value of RELATION initialized above
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SOURCE;

    SUSPEND;
  END
  CLOSE CUR_R;
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor-de"><database>DECLARE CURSOR</database></link>,
          <link linkend="fblangref25-psql-fetch-de"><database>FETCH</database></link>,
          <link linkend="fblangref25-psql-close-de"><database>CLOSE</database></link>
        </para>
      </formalpara>
    </section> <!-- OPEN -->

    <section id="fblangref25-psql-fetch-de">
      <title><database>FETCH</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Abrufen aufeinanderfolgender Datensätze aus einem Datensatz, der mit einem 
            Cursor abgerufen wurde</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
FETCH cursorname INTO [:]varname [, [:]varname ...];
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-fetch-de">
      <?dbfo keep-together='auto'?>
        <title>FETCH-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Name des Cursors Ein Cursor mit diesem Namen muss zuvor mit einer 
                  <database>DECLARE CURSOR</database>-Anweisung deklariert und durch eine 
                  <database>OPEN</database>-Anweisung geöffnet werden.</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variablenname</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Eine <database>FETCH</database>-Anweisung ruft die erste und die folgenden Zeilen aus 
      der Ergebnismenge des Cursors ab und weist PSQL-Variablen die Spaltenwerte zu. Die Anweisung 
      <database>FETCH</database> kann nur mit einem Cursor verwendet werden, der mit der Anweisung 
      <database>DECLARE CURSOR</database> deklariert wurde.</para>
      <para>Die <database>INTO</database>-Klausel ruft Daten aus der aktuellen Zeile des Cursors ab 
      und lädt sie in PSQL-Variablen.</para>
      <para>Um zu überprüfen, ob alle Datensatzzeilen abgerufen wurden, gibt die Kontextvariable 
          <database>ROW_COUNT</database> die Anzahl der Zeilen zurück, die von der Anweisung abgerufen 
          wurden. Es ist positiv, bis alle Zeilen überprüft wurden. Ein <database>ROW_COUNT</database> 
          von 1 gibt an, dass der nächste Abruf der letzte sein wird.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Verwenden der FETCH-Anweisung:
          <blockquote><programlisting>
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor-de"><database>DECLARE CURSOR</database></link>,
          <link linkend="fblangref25-psql-open-de"><database>OPEN</database></link>,
          <link linkend="fblangref25-psql-close-de"><database>CLOSE</database></link>
        </para>
      </formalpara>
    </section> <!-- FETCH -->

    <section id="fblangref25-psql-close-de">
      <title><database>CLOSE</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Einen deklarierten Cursor schließen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
CLOSE cursorname;
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-close-de">
      <?dbfo keep-together='auto'?>
        <title>CLOSE-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Name des Cursors. Ein Cursor mit diesem Namen muss zuvor mit einer 
                  <database>DECLARE CURSOR</database>-Anweisung deklariert und durch eine 
                  <database>OPEN</database>-Anweisung geöffnet werden</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Eine Anweisung <database>CLOSE</database> schließt einen geöffneten Cursor. Alle Cursor, 
      die noch geöffnet sind, werden automatisch geschlossen, nachdem der Modulcode ausgeführt wurde.
      Nur ein Cursor, der mit <database>DECLARE CURSOR</database> deklariert wurde, kann mit einer 
      <database>CLOSE</database>-Anweisung geschlossen werden.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Verwenden der CLOSE-Anweisung:
          <blockquote><programlisting>
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor-de"><database>DECLARE CURSOR</database></link>,
          <link linkend="fblangref25-psql-open-de"><database>OPEN</database></link>,
          <link linkend="fblangref25-psql-fetch-de"><database>FETCH</database></link>
        </para>
      </formalpara>
    </section> <!-- CLOSE -->

    <section id="fblangref25-psql-inauton-de">
      <title><database>IN AUTONOMOUS TRANSACTION</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Eine Anweisung oder einen Block von Anweisungen in einer autonomen 
            Transaktion ausführen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
IN AUTONOMOUS TRANSACTION DO &lt;compound_statement&gt;
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-inauton-de">
      <?dbfo keep-together='auto'?>
        <title>IN AUTONOMOUS TRANSACTION Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Ein Statement oder ein Block von Statements</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Eine Anweisung <database>IN AUTONOMOUS TRANSACTION</database> ermöglicht die 
      Ausführung einer Anweisung oder eines Anweisungsblocks in einer autonomen Transaktion. 
      Code, der in einer autonomen Transaktion ausgeführt wird, wird unmittelbar nach seiner 
      erfolgreichen Ausführung unabhängig vom Status seiner übergeordneten Transaktion festgeschrieben. 
      Dies kann erforderlich sein, wenn bestimmte Vorgänge nicht zurückgesetzt werden sollen, auch 
      wenn in der übergeordneten Transaktion ein Fehler auftritt.</para>
      <para>Eine autonome Transaktion hat dieselbe Isolationsstufe wie ihre übergeordnete Transaktion. 
          Jede Ausnahme, die im Block des autonomen Transaktionscodes ausgelöst wird, führt dazu, 
          dass die autonome Transaktion zurückgesetzt wird und alle vorgenommenen Änderungen storniert werden. 
          Wenn der Code erfolgreich ausgeführt wird, wird die autonome Transaktion festgeschrieben.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Verwenden einer autonomen Transaktion in einem Trigger für das Datenbankereignis
            <database>ON CONNECT</database>, um alle Verbindungsversuche einschließlich 
            der fehlgeschlagenen zu protokollieren:
          <blockquote><programlisting>
CREATE TRIGGER TR_CONNECT ON CONNECT
AS
BEGIN
  -- Logging all attempts to connect to the database
  IN AUTONOMOUS TRANSACTION DO
    INSERT INTO LOG(MSG)
    VALUES ('USER ' || CURRENT_USER || ' CONNECTS.');
  IF (CURRENT_USER IN (SELECT
                           USERNAME
                       FROM
                           BLOCKED_USERS)) THEN
  BEGIN
    -- Logging that the attempt to connect
    -- to the database failed and sending
    -- a message about the event
    IN AUTONOMOUS TRANSACTION DO
    BEGIN
      INSERT INTO LOG(MSG)
      VALUES ('USER ' || CURRENT_USER || ' REFUSED.');
      POST_EVENT 'CONNECTION ATTEMPT' || ' BY BLOCKED USER!';
    END
    -- now calling an exception
    EXCEPTION EX_BADUSER;
  END
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-de"><database>Transaktionskontrolle</database></link>
        </para>
      </formalpara>
    </section><!-- in autonomous transaction -->

    <section id="fblangref25-psql-postevent-de">
      <title><database>POST_EVENT</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Benachrichtigung von Listening-Clients über Datenbankereignisse in einem Modul</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
POST_EVENT event_name;
        </programlisting></blockquote>
        </para>
      </formalpara>
      <table id="fblangref25-psql-tbl-postevent-de">
      <?dbfo keep-together='auto'?>
        <title>POST_EVENT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">event_name</entry>
              <entry align="left">Ereignisname (Nachricht) ist auf 127 Byte beschränkt</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>POST_EVENT</database> benachrichtigt den Ereignismanager über das 
      Ereignis, das es in einer Ereignistabelle speichert. Wenn die Transaktion festgeschrieben wird, 
      benachrichtigt der Ereignismanager Anwendungen, die ihr Interesse an dem Ereignis signalisieren.</para> 
      <para>Der Ereignisname kann eine Art Code oder eine kurze Nachricht sein: Die Auswahl ist offen, da sie 
          nur eine Zeichenfolge von bis zu 127 Bytes ist.</para>
      <para>Der Inhalt der Zeichenfolge kann ein Zeichenfolgenliteral, eine Variable oder ein beliebiger 
          gültiger SQL-Ausdruck sein, der in eine Zeichenfolge aufgelöst wird.</para>
      <formalpara>
        <title>Beispiel</title>
        <para>&nbsp;Benachrichtigung der zuhörenden Anwendungen über das Einfügen eines Datensatzes in die 
            SALES-Tabelle:
          <blockquote><programlisting>
SET TERM ^;
CREATE TRIGGER POST_NEW_ORDER FOR SALES
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
  POST_EVENT 'new_order';
END^
SET TERM ;^
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- post_event -->

  </section> <!-- body code -->

  <section id="fblangref25-psql-handleexceptions-de">
    <title>Abfangen und Behandeln von Fehlern</title>
    <para>Firebird hat ein nützliches Lexikon von PSQL-Anweisungen und -Ressourcen, 
        um Fehler in Modulen einzufangen und sie zu behandeln. Intern implementierte 
        Ausnahmen existieren, um die Ausführung anzuhalten, wenn jeder Standardfehler in 
        DDL, DSQL und der physischen Umgebung auftritt.</para>

    <para>Im PSQL-Code werden Ausnahmen mit der WHEN-Anweisung behandelt. Bei der Behandlung einer Ausnahme im Code wird
      entweder das Problem in situ behoben oder es wird übergangen. Bei beiden Lösungen kann die Ausführung fortgesetzt
      werden, ohne dass eine Ausnahmebedingungsnachricht an den Client zurückgegeben wird.</para>

    <para>Eine Ausnahme führt dazu, dass die Ausführung im Block beendet wird. Anstatt die Ausführung an die
      <database>END</database>-Anweisung zu übergeben, bewegt sich die Prozedur durch Ebenen von verschachtelten Blöcken nach
      außen, beginnend mit dem Block, in dem die Ausnahme abgefangen wird, nach dem Code des Handlers, der
      diese Ausnahme <quote>kennt</quote>. Sie stoppt die Suche, wenn die erste <database>WHEN</database>-Anweisung gefunden wird,
      die diese Ausnahme verarbeiten kann.</para>

    <section id="fblangref25-ddl-sysexcept-de">
      <title>Systemausnahmen</title>
      <para>Eine Ausnahme ist eine Nachricht, die generiert wird, wenn ein Fehler auftritt.</para>
      <para>Alle Ausnahmen, die von Firebird behandelt werden, haben vordefinierte numerische Werte für Kontextvariablen 
          (Symbole) und Textnachrichten, die ihnen zugeordnet sind. Fehlermeldungen werden standardmäßig in Englisch 
          ausgegeben. Lokalisierte Firebird-Builds sind verfügbar, in denen Fehlermeldungen in andere Sprachen übersetzt werden.</para>

      <para>Vollständige Auflistungen der Systemausnahmen finden Sie in
      <link linkend="fblangref25-appx02-errorcodes-de"><citetitle>Anhang B: Fehlercodes und Meldungen</citetitle></link>:
        <itemizedlist>
          <listitem><para><link linkend="fblangref25-appx02-sqlstates-de">SQLSTATE Fehlercodes und Beschreibungen</link></para></listitem>
          <listitem><para><link linkend="fblangref25-appx02-sqlcodes-de">GDSCODE Fehlercodes, SQLCODEs und Beschreibungen</link></para></listitem>
        </itemizedlist>
      </para>
    </section> <!-- system exceptions -->

    <section id="fblangref25-ddl-customexcept-de">
      <title>Benutzerdefinierte Ausnahmen</title>
      <para>Benutzerdefinierte Ausnahmen können in der Datenbank als permanente Objekte deklariert und im PSQL-Code 
          aufgerufen werden, um bestimmte Fehler zu signalisieren, zum Beispiel, um bestimmte Geschäftsregeln durchzusetzen. 
          Eine benutzerdefinierte Ausnahme besteht aus einem Bezeichner und einer Standardnachricht von ungefähr 1000 Byte. 
          Weitere Informationen finden Sie unter <link linkend="fblangref25-ddl-exception-create-de"> 
          <database>CREATE EXCEPTION</database></link>.</para>
    </section>

    <section id="fblangref25-psql-exception-de">
      <title><database>EXCEPTION</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Eine benutzerdefinierte Ausnahme auslösen oder eine Ausnahme erneut auslösen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
EXCEPTION [exception_name [custom_message]]
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-exception-de">
      <?dbfo keep-together='auto'?>
        <title>EXCEPTION-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme</entry>
            </row>
            <row valign="middle">
              <entry align="center">custom_message</entry>
              <entry align="left">Alternativer Nachrichtentext, der an die Aufruferschnittstelle zurückgegeben 
                  wird, wenn eine Ausnahme ausgelöst wird. Die maximale Länge der Textnachricht beträgt 1.021 Byte</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Eine Anweisung <database>EXCEPTION</database> löst die benutzerdefinierte Ausnahme mit dem angegebenen 
      Namen aus. Ein alternativer Nachrichtentext von bis zu 1.021 Byte kann optional den Standardnachrichtentext 
      der Ausnahme überschreiben.</para>
      <para>Die Ausnahmebedingung kann in der Anweisung behandelt werden, indem sie nur mit einem bestimmten 
          <database>WHEN ... DO</database>-Handler belassen wird und dem Trigger oder der gespeicherten Prozedur 
          erlaubt wird, alle Operationen zu beenden und rückgängig zu machen. Die aufrufende Anwendung erhält den 
          alternativen Nachrichtentext, sofern einer angegeben wurde. Andernfalls empfängt es die ursprünglich für 
          diese Ausnahme definierte Nachricht.</para>
      <para>Innerhalb des Ausnahmebehandlungsblocks &#x2014; und nur innerhalb davon &#x2014; kann die abgefangene 
          Ausnahme erneut ausgelöst werden, indem die Anweisung <database>EXCEPTION</database> ohne Parameter ausgeführt 
          wird. Wenn der Befehl außerhalb des Blocks liegt, hat die erneut aufgerufene <database>EXCEPTION</database>-Anweisung
          keine Auswirkung.</para>
      <note>
        <para>Benutzerdefinierte Ausnahmen werden in der Systemtabelle 
        <link linkend="fblangref-appx04-exceptions-de"><database>RDB$EXCEPTIONS</database></link> gespeichert.
        </para>
      </note>
      <formalpara>
        <title>Beispiele</title>
        <para>
        <orderedlist>
          <listitem><para>Eine Ausnahme mit dynamisch erzeugtem Text auslösen:</para>
          <blockquote><programlisting>
&#x2026;
EXCEPTION EX_BAD_TYPE
  'Incorrect record type with id ' || new.id;
&#x2026;
          </programlisting></blockquote>
          </listitem>
          <listitem><para>Eine Ausnahme für eine Bedingung in der gespeicherten SHIP_ORDER-Prozedur auslösen:</para>
            <blockquote><programlisting>
CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
DECLARE VARIABLE ord_stat  CHAR(7);
DECLARE VARIABLE hold_stat CHAR(1);
DECLARE VARIABLE cust_no   INTEGER;
DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
      s.order_status,
      c.on_hold,
      c.cust_no
  FROM
      sales s, customer c
  WHERE
      po_number = :po_num AND
      s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped;
  /* Other statements */
END
            </programlisting></blockquote>
          </listitem>
          <listitem><para>Eine Ausnahme bei einer Bedingung auslösen und die ursprüngliche Nachricht durch
              eine alternative Nachricht ersetzen:</para>
            <blockquote><programlisting>
CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
DECLARE VARIABLE ord_stat  CHAR(7);
DECLARE VARIABLE hold_stat CHAR(1);
DECLARE VARIABLE cust_no   INTEGER;
DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
      s.order_status,
      c.on_hold,
      c.cust_no
  FROM
      sales s, customer c
  WHERE
      po_number = :po_num AND
      s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped
      'Order status is "' || ord_stat || '"';
  /* Other statements */
END
            </programlisting></blockquote>
          </listitem>
          <listitem><para>Einen Fehler protokollieren und erneut in den WHEN-Block werfen:</para>
            <blockquote><programlisting>
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
        -- write an error in log
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              GDSCODE,
              SQLCODE,
              SQLSTATE);
    -- Re-throw exception
    EXCEPTION;
  END
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
        </para>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create-de"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-psql-when-de"><database>WHEN ... DO</database></link>
        </para>
      </formalpara>
    </section><!-- EXCEPTION -->

    <section id="fblangref25-psql-when-de">
      <title><database>WHEN ... DO</database></title>
      <formalpara><title>Verwendet für</title>
        <para>&nbsp;Eine Ausnahme abfangen und den Fehler behandeln</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>
        <blockquote><programlisting>
WHEN {&lt;error&gt; [, &lt;error&gt; &#x2026;] | ANY}
DO &lt;compound_statement&gt;

&lt;error&gt; ::= {
    EXCEPTION exception_name
  | SQLCODE number
  | GDSCODE errcode
}
        </programlisting></blockquote>
        </para>
      </formalpara>

      <table id="fblangref25-psql-tbl-when-de">
      <?dbfo keep-together='auto'?>
        <title>WHEN ... DO-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Name der Ausnahme</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">SQLCODE Fehler-Code</entry>
            </row>
            <row valign="middle">
              <entry align="center">errcode</entry>
              <entry align="left">Symbolischer GDSCODE-Fehlername</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Ein Statement oder ein Block von Statements</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>WHEN ... DO</database> wird verwendet, um Fehler und benutzerdefinierte 
      Ausnahmen zu behandeln. Die Anweisung erfasst alle Fehler und benutzerdefinierten Ausnahmen, die nach 
      dem Schlüsselwort <database>WHEN</database> aufgeführt sind. Wenn <database>WHEN</database> das 
      Schlüsselwort <database>ANY</database> folgt, fängt die Anweisung jeden Fehler oder jede benutzerdefinierte 
      Ausnahme ab, auch wenn sie bereits in einer <database>WHEN</database>-Anweisung weiter oben im Block
      behandelt wurden.</para>
      <para>Der <database>WHEN ... DO</database>-Block muss sich am Ende eines Anweisungsblocks befinden, 
      vor der Anweisung <database>END</database> des Blocks.</para>
      <para>Auf das Schlüsselwort <database>DO</database> folgt eine Anweisung oder ein Anweisungsblock 
      innerhalb eines BEGIN ... END-Wrappers, der die Ausnahme behandelt. Die Kontextvariablen 
      <database>SQLCODE, GDSCODE</database> und <database>SQLSTATE </database> stehen im Kontext dieser 
      Anweisung oder dieses Blocks zur Verfügung. Die Anweisung <database>EXCEPTION</database> ohne Parameter 
      kann auch in diesem Kontext verwendet werden, um den Fehler oder die Ausnahme erneut zu werfen.</para>

      <sidebar id="fblangref25-psql-when-gdscode-de">
        <title>Bezüglich <database>GDSCODE</database></title>
        <para>Das Argument für die Klausel <database>WHEN GDSCODE</database> ist der symbolische Name, 
        der der intern definierten Ausnahme zugeordnet ist, z. B. <function>grant_obj_notfound</function> 
        für den GDS-Fehler 335544551.</para>
        <para>Nach der <database>DO</database>-Klausel wird eine weitere <database>GDSCODE</database>-Kontextvariable, 
        die den numerischen Code enthält, für die Verwendung in der Anweisung oder dem Anweisungsblock verfügbar, die den 
        Error-Handler codieren. Dieser numerische Code ist erforderlich, wenn Sie eine <database>GDSCODE</database>-Ausnahme 
        mit einem gezielten Fehler vergleichen möchten.</para>
      </sidebar> <!--  Targeting GDSCODE -->

      <para>Die <database>WHEN ... DO</database>-Anweisung oder der <database>WHEN ... DO</database>-Block werden niemals ausgeführt, 
      es sei denn, eines der Ereignisse, auf die die Bedingungen abzielen, wird zur Laufzeit ausgeführt. Wenn die Anweisung ausgeführt
      wird, wird die Ausführung fortgesetzt, so als ob kein Fehler aufgetreten wäre: Der Fehler oder die benutzerdefinierte 
      Ausnahme beendet weder die Operationen des Triggers noch der gespeicherten Prozedur.</para>
      <para>Wenn jedoch die <database>WHEN ... DO</database>-Anweisung oder der <database>WHEN ... DO</database>-Block nichts 
      zum Behandeln oder Beheben des Fehlers tut, wird die DML-Anweisung (<database>SELECT, INSERT, UPDATE, DELETE, MERGE</database>), 
      die den Fehler verursacht hat zurückgerollt, und keine der Anweisungen darunter im selben Anweisungsblock wird ausgeführt.
        <important>
          <orderedlist spacing="compact">
            <listitem><para>Wenn der Fehler nicht durch eine der DML-Anweisungen (<database>SELECT, INSERT, UPDATE, DELETE, MERGE</database>)
            verursacht wird, wird der gesamte Block der Anweisungen zurückgesetzt, nicht nur der, der einen Fehler verursacht hat. 
            Alle Operationen in der <database>WHEN ... DO</database>-Anweisung werden ebenfalls zurückgesetzt. Dieselbe 
                Einschränkung gilt für die Anweisung <database>EXECUTE PROCEDURE</database>. Lesen Sie eine interessante 
                Diskussion über das Phänomen im Firebird Tracker-Ticket 
                <ulink url = "http://tracker.firebirdsql.org/browse/CORE-4483">CORE-4483</ulink>.</para></listitem>
            <listitem><para>Bei auswählbaren gespeicherten Prozeduren bleiben Ausgabezeilen, die bereits in früheren Iterationen einer
                 <database>FOR SELECT &#x2026; DO &#x2026; SUSPEND</database>-Schleife an den Client übergeben wurden erhalten,
                 wenn beim Abrufen von Zeilen eine Ausnahme ausgelöst wird.</para></listitem>
          </orderedlist>
        </important>
      </para>
      <section id="fblangref25-psql-whendo-scope-de">
        <title>Anwendungsbereiche einer <database>WHEN ... DO</database> Anweisung</title>
        <para>Eine Anweisung <database>WHEN ... DO</database> fängt Fehler und Ausnahmen im aktuellen Anweisungsblock ab. 
        Es fängt auch ähnliche Ausnahmen in verschachtelten Blöcken ab, wenn diese Ausnahmen nicht in ihnen 
        behandelt wurden.</para>
        <para>Alle Änderungen, die vor der Anweisung vorgenommen wurden, die den Fehler verursacht hat, sind für eine 
            <database>WHEN ... DO</database>-Anweisung sichtbar. Wenn Sie jedoch versuchen, sie in einer autonomen Transaktion 
            zu protokollieren, sind diese Änderungen nicht verfügbar, da die Transaktion, bei der die Änderungen stattfanden, 
            zu dem Zeitpunkt, zu dem die autonome Transaktion gestartet wird, nicht festgeschrieben ist. 
            Das untere Beispiel 4 zeigt dieses Verhalten.</para>
        <tip>
          <para>Bei der Behandlung von Ausnahmen ist es manchmal wünschenswert, die Ausnahme zu behandeln, indem eine Protokollnachricht
            geschrieben wird, um den Fehler zu markieren, und die Ausführung über den fehlerhaften Datensatz hinaus fortgesetzt wird.
            Protokolle können in reguläre Tabellen geschrieben werden, aber es gibt ein Problem damit: Die Protokolldatensätze
            <quote>verschwinden</quote>, wenn ein nicht behandelter Fehler dazu führt, dass das Modul nicht mehr ausgeführt wird und
            ein Rollback erfolgt. Die Verwendung von <link linkend="fblangref25-ddl-tbl-external-de">externen Tabellen</link> kann hier
            nützlich sein, da Daten, die an sie geschrieben werden, transaktionsunabhängig sind. Die verknüpfte externe Datei ist immer
            noch vorhanden, unabhängig davon, ob der Gesamtprozess erfolgreich ist oder nicht.</para>
        </tip>
      </section> <!-- Scope of WHEN ... Do -->

      <section>
        <title>Beispiele zur Verwendung von WHEN...DO</title>
          <orderedlist>
            <listitem><para>Ersetzen des Standardfehlers durch einen benutzerdefinierten Fehler:</para>
              <blockquote><programlisting>
CREATE EXCEPTION COUNTRY_EXIST '';
SET TERM ^;
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country, currency)
  VALUES (:ACountryName, :ACurrency);

  WHEN SQLCODE -803 DO
    EXCEPTION COUNTRY_EXIST 'Country already exists!';
END^
SET TERM ^;
              </programlisting></blockquote>
            </listitem>
            <listitem><para>Einen Fehler protokollieren und erneut in den <database>WHEN</database>-Block werfen:</para>
              <blockquote><programlisting>
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
    -- write an error in log
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              GDSCODE,
              SQLCODE,
              SQLSTATE);
    -- Re-throw exception
    EXCEPTION;
  END
END
              </programlisting></blockquote>
            </listitem>
            <listitem><para>Behandeln mehrerer Fehler in einem <database>WHEN</database>-Block</para>
              <blockquote><programlisting>
...
WHEN GDSCODE GRANT_OBJ_NOTFOUND,
	   GDSCODE GRANT_FLD_NOTFOUND,
	   GDSCODE GRANT_NOPRIV,
	   GDSCODE GRANT_NOPRIV_ON_BASE
DO
BEGIN
	EXECUTE PROCEDURE LOG_GRANT_ERROR(GDSCODE);
	EXIT;
END
...
              </programlisting></blockquote>
            </listitem>
          </orderedlist>
        <formalpara>
          <title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-psql-exception-de"><database>EXCEPTION</database></link>,
            <link linkend="fblangref25-ddl-exception-create-de"><database>CREATE EXCEPTION</database></link>,
            <link linkend="fblangref25-appx02-tbl-errcodes01-de">SQLCODE und GDSCODE Fehlercodes und Meldungen (1)</link> und
            <link linkend="fblangref25-appx02-tbl-sqlstates-de">SQLSTATE Fehlercodes und Meldungen</link>
          </para>
        </formalpara>
      </section>
    </section> <!-- WHEN ... DO -->

  </section> <!-- handling errors and exceptions -->
</chapter>