<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="fblangref25-functions-de" lang="de">
  <title>Eingebaute Funktionen und Variablen</title>
  
  <para>In diesem Abschnitt wird die große Sammlung der Kontextvariablen, Skalar-
      und Aggregat-Funktionen beschrieben.</para>
    <section id="fblangref25-functions-contextvars-de">
    <title>Kontextvariablen</title>
    <section id="fblangref25-contextvars-current_connection-de">
      <title><database>CURRENT_CONNECTION</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_CONNECTION</database> enthält den eindeutigen Bezeichner der aktuellen
        Verbindung.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiele</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Der Wert in <database>CURRENT_CONNECTION</database> wird in der Datenbank Headerseite gespeichert
      und bei einer Wiederherstellung auf 0 zurückgesetzt. Seit Version 2.1 wird dieser Wert bei jeder neuen 
      Verbindung inkrementiert.
      (In vorigen Versionen, wurde der Wert nur inkrementiert, wenn der Client diesen während der Sitzung 
      ausgelesen hat.) Daraus resultiert, dass
      <database>CURRENT_CONNECTION</database> die Anzahl der Verbindungen seit dem Anlegen
      &#x2014;oder der aktuellsten Wiederherstellung&#x2014; der Datenbank anzeigt.</para>
    </section>

    <section id="fblangref25-contextvars-current_date-de">
      <title><database>CURRENT_DATE</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_DATE</database> gibt das aktuelle Serverdatum zurück.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>DATE</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_DATE</programlisting>
        </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Beispiele</title>
        <para><blockquote>
            <programlisting>select current_date from rdb$database
-- ergibt z.B. 2011-10-03</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Hinweise</title>
        <para><itemizedlist>
            <listitem>
              <para>Innerhalb eines PSQL-Moduls (Prozedur, Trigger oder 
                  ausführbarer Block) bleibt der Wert von <database>CURRENT_DATE</database>
                  bei jedem Lesen konstant. Wenn mehrere Module einander aufrufen oder auslösen, bleibt 
                  der Wert während der gesamten Dauer des äußersten Moduls konstant. Wenn Sie einen 
                  fortschreitenden Wert in PSQL benötigen (z. B. um Zeitintervalle zu messen), verwenden 
                  Sie <link linkend="fblangref25-contextvars-today-de"><database>'TODAY'</database></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="fblangref25-contextvars-current_role-de">
      <title><database>CURRENT_ROLE</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_ROLE</database> ist eine Kontextvariable, die die Rolle des derzeit
        verbundenen Benutzers enthält. Ist keine Rolle aktiv, ist <database>CURRENT_ROLE</database>
        <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>CURRENT_ROLE</database> repräsentiert immer eine gültige Rolle oder
      <database>NONE</database>. Wenn sich ein Benutzer mit einer nicht-existenten Rolle verbindet,
      wird die Engine die Rolle stillschweigend auf <database>NONE</database> setzen, ohne
      einen Fehler zurückzugeben.</para>
    </section>

    <section id="fblangref25-contextvars-current_time-de">
      <title><database>CURRENT_TIME</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_TIME</database> gibt die derzeitige Serverzeit zurück. In Versionen
        vor 2.0, ist der Bruchteil immer <quote><literal>.0000</literal></quote>, was eine 
        effektive Genauigkeit von 0 Dezimalstellen ergibt. Ab Firebird 2.0 können Sie eine Genauigkeit 
        angeben, wenn Sie diese Variable abfragen. Der Standardwert ist immer noch 0 
        Dezimalstellen, d.h. Sekundengenauigkeit.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>TIME</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIME [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>Das optionale Argument <replaceable>precision</replaceable> wird in 
            ESQL nicht unterstützt.</para>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-funcs-tbl-current_time-de">
      <?dbfo keep-together='auto'?>
        <title>CURRENT_TIME Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">Genauigkeit</entry>
              <entry align="left">Präzision. Der Standardwert ist 0. In ESQL nicht unterstützt..</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <formalpara>
        <title>Beispiele</title>
        <para><blockquote>
            <programlisting>select current_time from rdb$database
-- ergibt z.B. 14:20:19.6170</programlisting>
            <programlisting>select current_time(2) from rdb$database
-- ergibt z.B. 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Hinweise</title>
        <para><itemizedlist>
            <listitem>
              <para>Im Gegensatz zu <database>CURRENT_TIME</database> wurde der Standardwert von
              <database>CURRENT_TIMESTAMP</database> auf 3 Dezimalstellen geändert. Somit ist
              <database>CURRENT_TIMESTAMP</database> nicht länger die genaue Summe aus
              <database>CURRENT_DATE</database> und <database>CURRENT_TIME</database>, es sei denn, Sie 
              geben die Genauigkeit selbst an.</para>
            </listitem>
            <listitem>
              <para>Innerhalb eines PSQL-Moduls (Prozedur, Trigger oder ausführbarer Block) bleibt der Wert von
                  <database>CURRENT_TIME</database> bei jedem Lesen konstant. Wenn mehrere Module einander aufrufen 
                  oder auslösen, bleibt der Wert während der gesamten Dauer des äußersten Moduls konstant. Wenn Sie 
                  einen fortschreitenden Wert in PSQL benötigen (z. B. um Zeitintervalle zu messen), verwenden Sie <link
              linkend="fblangref25-contextvars-now-de"><database>'NOW'</database></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="fblangref25-contextvars-current_timestamp-de">
      <title><database>CURRENT_TIMESTAMP</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_TIMESTAMP</database> gibt das aktuelle Datum und die Uhrzeit des 
        aktuellen Servers zurück. In Versionen vor 2.0 war der Bruchteil immer <quote>
            <literal>.0000</literal> </quote>, was eine effektive Genauigkeit von 0 Dezimalstellen ergab. 
                Ab Firebird 2.0 können Sie eine Genauigkeit angeben, wenn Sie diese Variable abfragen. Der 
                Standardwert ist 3 Dezimalstellen, d. H. Millisekunden.
                <!--This new functionality also available in ESQL? Dimtry says about the new ms precision:
"I believe it should be supported automagically." About the precision arg: "Not supported."--></para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIMESTAMP [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>Das optionale Argument <replaceable>precision</replaceable> wird in ESQL nicht 
            unterstützt.</para>
          </blockquote></para>
      </formalpara>
      <table id="fblangref25-funcs-tbl-current_timestamp-de">
      <?dbfo keep-together='auto'?>
        <title>CURRENT_TIMESTAMP Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">Genauigkeit</entry>
              <entry align="left">Präzision. Der Standardwert ist 0. In ESQL nicht unterstützt.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <formalpara>
        <title>Beispiele</title>
        <para><blockquote>
            <programlisting>select current_timestamp from rdb$database
-- ergibt z.B. 2008-08-13 14:20:19.6170</programlisting>
            <programlisting>select current_timestamp(2) from rdb$database
-- ergibt z.B. 2008-08-13 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Hinweise</title>
        <para><itemizedlist>
            <listitem>
              <para>Die Standardpräzision von <database>CURRENT_TIME</database> ist immer noch 0 
              Dezimalstellen, sodass in Firebird 2.0 und höher <database>CURRENT_TIMESTAMP</database>
              nicht mehr die exakte Summe von <database>CURRENT_DATE</database> und 
              <database>CURRENT_TIME</database> ergibt, außer Sie geben explizit eine Genauigkeit an.</para>
            </listitem>
            <listitem>
              <para>Innerhalb eines PSQL-Moduls (Prozedur, Trigger oder ausführbarer Block) bleibt der Wert von 
                  <database>CURRENT_TIMESTAMP</database> bei jedem Lesen konstant. Wenn mehrere Module einander 
                  aufrufen oder auslösen, bleibt der Wert während der gesamten Dauer des äußersten Moduls konstant. 
                  Wenn Sie einen fortschreitenden Wert in PSQL benötigen (z. B. um Zeitintervalle zu messen), 
                  verwenden Sie <link
              linkend="fblangref25-contextvars-now-de"><database>'NOW'</database></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="fblangref25-contextvars-current_transaction-de">
      <title><database>CURRENT_TRANSACTION</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_TRANSACTION</database> beinhaltet den eindeutigen Bezeichner der 
        aktuellen Transaktion.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiele</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Der Wert von <database>CURRENT_TRANSACTION</database> wird in der Datenbank-Header-Seite
      vorgehalten und beim Wiederherstellen auf 0 zurückgesetzt. Dieser wird mit jeder neuen 
      Transaktion inkrementiert.</para>
    </section>

    <section id="fblangref25-contextvars-current_user-de">
      <title><database>CURRENT_USER</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>CURRENT_USER</database> ist eine Kontextvariable, die den Namen des aktuell verbundenen Benutzers enthält.
        Diese ist vollständig äquivalent zu <link linkend="fblangref25-contextvars-user-de">
            <database>USER</database>
        </link>.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="fblangref25-contextvars-deleting-de">
      <title><database>DELETING</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>Nur in Triggern verfügbar. <database>DELETING</database> gibt an, ob der Trigger durch eine
        Löschoperation (<database>DELETE</database>) ausgelöst wurde. Vorgesehen für den Einsatz in <link
        linkend="fblangref25-ddl-trgr-relntrigger-rowevent-de">Multi-Aktions-Trigger</link>.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="fblangref25-contextvars-gdscode-de">
      <title><database>GDSCODE</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>In einem <quote><database>WHEN ... DO</database></quote>-Fehlerbehandlungsblock, enthält die 
        <database>GDSCODE</database>-Kontextvariable die numerische Repräsentation des derzeitigen Firebird-Fehlercodes.
        Vor Firebird 2.0, wurde <database>GDSCODE</database> nur innerhalb eines
        <database>WHEN GDSCODE</database>-Handlers gesetzt. Nun kann es in <database>WHEN ANY</database>, 
        <database>WHEN SQLCODE</database> und <database>WHEN EXCEPTION</database> auch nicht-null sein, 
        vorausgesetzt, die Bedingung, die den Fehler verursacht, entspricht einem Firebird Fehlercode. 
        Außerhalb der Fehler-Handler ist <database>GDSCODE</database> ist immer 0. Außerhalb von PSQL existiert es 
        überhaupt nicht.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>when gdscode grant_obj_notfound, gdscode grant_fld_notfound,
     gdscode grant_nopriv, gdscode grant_nopriv_on_base
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Hinweis</title>
        <para>Nach <database>WHEN GDSCODE</database> müssen Sie symbolische Namen wie z.B.
        <errorcode>grant_obj_notfound</errorcode> etc. verwenden. Jedoch ist die Kontextvariable <database>GDSCODE</database>
        ein <database>INTEGER</database>. Wenn Sie es mit einem bestimmten Fehler vergleichen möchten, 
        muss der numerische Wert verwendet werden, z.B. 335544551 für
        <errorcode>grant_obj_notfound</errorcode>.</para>
      </note>
    </section>

    <section id="fblangref25-contextvars-inserting-de">
      <title><database>INSERTING</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>Nur in Triggern verfügbar. <database>INSERTING</database> gibt an, ob der Trigger durch eine
        Einfügeoperation (<database>INSERTING</database>) ausgelöst wurde. Vorgesehen für den Einsatz in <link
        linkend="fblangref25-ddl-trgr-relntrigger-rowevent-de">Multi-Aktions-Trigger</link>.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="fblangref25-contextvars-new-de">
      <title><database>NEW</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>NEW</database> beinhaltet die neue Version einer Datenbankzeile, die gerade 
        eingefügt oder aktualisiert wurde. Seit Firebird 2.0 steht diese nur noch im Lesemodus in
        <database>AFTER</database>-Triggern zur Verfügung.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para>Datenzeile</para>
      </formalpara>
      <note>
        <para>In Multi-Aktions-Triggern&#x2014;eingeführt in Firebird 1.5&#x2014;ist <database>NEW</database>
        immer verfügbar. Wurde der Trigger jedoch durch ein <database>DELETE</database> ausgelöst, existiert keine
        neue Version des Datensatzes. In diesem Falle wird das Lesen von <database>NEW</database> immer 
        <constant>NULL</constant> zurückgeben; das Schreiben hierein wird in einem Laufzeitfehler resultieren.</para>
      </note>
    </section>
    <section id="fblangref25-contextvars-now-de">
      <title><database>'NOW'</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Geändert in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>'NOW'</database> ist keine Variable, sondern ein String-Literal. Es ist jedoch 
                speziell in dem Sinne, dass, wenn Sie es mittels <database>CAST()</database> zu einem Datum / Uhrzeit-Typ umwandeln, 
                Sie das aktuelle Datum und / oder Uhrzeit erhalten. Der Bruchteil der Zeit war immer 
                <quote><literal>.0000</literal></quote>, was eine effektive Sekundengenauigkeit ergab. Seit 
                Firebird 2.0 beträgt die Genauigkeit 3 Dezimalstellen, d.h. Millisekunden. <database>'NOW'</database>
                unterscheidet nicht zwischen Groß- und Kleinschreibung, und die Engine ignoriert beim Casting führende 
                oder nachgestellte Leerzeichen.</para>
      </formalpara>
	      <formalpara>
	        <title>Hinweis</title>
	        <para>Bitte beachten Sie, dass diese Abkürzungsausdrücke sofort bei der Analyse ausgewertet werden und gleich 
                    bleiben, solange die Anweisung vorbereitet bleibt. Selbst wenn eine Abfrage mehrere Male ausgeführt wird, 
                    änder sich der Wert für z.B. <quote>timestamp 'now'</quote> nicht, egal wie viel Zeit vergeht. Wenn 
                    Sie den Wert für den Fortschritt benötigen (d.h. bei jedem Aufruf ausgewertet werden), verwenden Sie 
                    eine vollständige Umwandlung.</para>
	      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>CHAR(3)</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiele</title>
        <para><blockquote>
            <programlisting>select 'Now' from rdb$database
-- ergibt 'Now'</programlisting>
            <programlisting>select cast('Now' as date) from rdb$database
-- ergibt z.B. 2008-08-13</programlisting>
            <programlisting>select cast('now' as time) from rdb$database
-- ergibt z.B. 14:20:19.6170</programlisting>
            <programlisting>select cast('NOW' as timestamp) from rdb$database
-- ergibt z.B. 2008-08-13 14:20:19.6170</programlisting>
            <para><link linkend="fblangref25-datatypes-convert-shortcasts-de">Kurzschreibweisen für Casts von Datums- und Zeit-Datentypen</link> für die letzten
            drei Statements:</para>
            <programlisting>select date 'Now' from rdb$database
select time 'now' from rdb$database
select timestamp 'NOW' from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Hinweise</title>
        <para><itemizedlist>
            <listitem>
              <para><database>'NOW'</database> gibt immer die aktuelle Uhrzeit bzw. das aktuelle Datum zurück, auch in PSQL-Modulen,
              in denen <database>CURRENT_DATE</database>, <link
              linkend="fblangref25-contextvars-current_time-de"><database>CURRENT_TIME</database></link> und <link
              linkend="fblangref25-contextvars-current_timestamp-de"><database>CURRENT_TIMESTAMP</database></link>
              während der gesamt Laufzeit der äußeren Routine den selben Wert liefern. Dies macht 
              <database>'NOW'</database> nützlich zum Messen von Zeitintervallen in Triggern, Prozeduren und
              ausführbaren Blöcken.</para>
            </listitem>
            <listitem>
              <para>Außer in der oben genannten Situation, ist das Lesen von
              <database>CURRENT_DATE</database>, <link
              linkend="fblangref25-contextvars-current_time-de"><database>CURRENT_TIME</database></link> und <link
              linkend="fblangref25-contextvars-current_timestamp-de"><database>CURRENT_TIMESTAMP</database></link>
              dem Casting gundsätzlich vorzuziehen <database>'NOW'</database>. Seien Sie sich jedoch bewusst, dass
              <database>CURRENT_TIME</database> standardmäßig sekundengenau ist; um millisekundengenaue Genauigkeit
              zu erhalten, nutzen Sie <database>CURRENT_TIME</database>(<parameter>3</parameter>).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="fblangref25-contextvars-old-de">
      <title><database>OLD</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>OLD</database> beinhaltet die existierende Version einer Datenbankzeile, gerade vor dem Aktualisieren
        oder Löschen. Seit Firebird 2.0 ist dies nur lesend.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para>Datenzeile</para>
      </formalpara>
      <note>
        <para>In Multi-Aktions-Triggern &#x2014;eingeführt inFirebird 1.5&#x2014; ist <database>OLD</database>
        immer verfügbar. Wird der Trigger jedoch durch ein <database>INSERT</database> ausgelöst, existiert 
        offensichtlich keine Vor-Version des Datensatzes. In diesem Falle, gibt 
        <database>OLD</database> immer <constant>NULL</constant> zurück; schreiben wird in einem Laufzeitfehler
        enden.</para>
      </note>
    </section>
    <section id="fblangref25-contextvars-row_count-de">
      <title><database>ROW_COUNT</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Geändert in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>Die Kontextvariable <database>ROW_COUNT</database> enhält die Anzahl der Zeilen, die durch das
        letzte DML-Statement (<database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database>, <database>SELECT</database> oder <database>FETCH</database>) im
        derzeitigen Trigger, Stored Procedure oder ausführbaren Block betroffen sind.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Verhalten von <database>SELECT</database> und <database>FETCH<!--Better make this a table!--></database></title>
        <para><itemizedlist>
            <listitem>
              <para>Nach einem einzelnen <database>SELECT</database>, ist <database>ROW_COUNT</database> gleich 1,
              sofern eine Datenzeile zurückgegeben wurde, andernfalls 0.</para>
            </listitem>
            <listitem>
              <para>In einer <database>FOR SELECT</database>-Schleife wird <database>ROW_COUNT</database>
              mit jeder Iteration inkrementiert (beginnend bei 0 vor dem ersten Durchlauf).</para>
            </listitem>
            <listitem>
              <para>Nach einem <database>FETCH</database> durch einen Cursor, ist <database>ROW_COUNT</database>
              gleich 1, falls eine Datenzeile zurückgegeben wurde und andernfalls 0. Werden weitere Datenzeilen durch
              den gleichen Cursor geholt, wird <database>ROW_COUNT</database><emphasis>nicht</emphasis> über 1 hinaus
              inkrementiert.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.<replaceable>x</replaceable> ist <database>ROW_COUNT</database>0
              nach jeder Art von <database>SELECT</database>-Anweisung.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <note>
        <para><database>ROW_COUNT</database> kann nicht verwendet werden um die Anzahl der betroffenen Zeilen eines
        <database>EXECUTE STATEMENT</database>- oder <database>EXECUTE PROCEDURE</database>-Befehls zu erhalten.</para>
      </note>
    </section>
    <section id="fblangref25-contextvars-sqlcode-de">
      <title><database>SQLCODE</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Veraltet ab</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>In einem <quote><database>WHEN ... DO</database></quote>-Fehlerbehandlungsblock enthält die
        <database>SQLCODE</database>-Kontextvariable den aktuellen SQL-Fehlercode. Vor
        Firebird 2.0 wurde <database>SQLCODE</database> nur in <database>WHEN SQLCODE</database>-
        und <database>WHEN ANY</database>-Handlern. Nun kann es auch in <database>WHEN GDSCODE</database>
        und <database>WHEN EXCEPTION</database> ungleich null sein, vorausgesetzt, die Bedingung, die den 
        Fehler auslöst, entspricht einem SQL-Fehlercode. Außerhalb der Error-Handler ist <database>SQLCODE</database>
        immer 0. Außerhalb PSQL ist es überhaupt nicht vorhanden.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Wichtiger Hinweis</title>
        <para><database>SQLCODE</database> ist im Rahmen des SQL-2003-konformen <link
        linkend="fblangref25-contextvars-sqlstate-de"><citetitle><database>SQLSTATE</database></citetitle></link>-Statuscodes
        veraltet. Die Unterstützung für <database>SQLCODE</database> und <database>WHEN SQLCODE</database>
        wird in einer späteren Firebird-Version entfernt werden.</para>
      </formalpara>
    </section>
    <section id="fblangref25-contextvars-sqlstate-de">
      <title><database>SQLSTATE</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Aufgenommen in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title> 
        <para>In einem <quote><database>WHEN ... DO</database></quote>-Error-Handler enthält die
        <database>SQLSTATE</database>-Kontextvariable den 5 Zeichen langen, SQL-2003-konformen
        Statuscode, der vom Statement erzeugt wurde, das den Fehler verursacht hat. Außerhalb der Error-Hander
        ist <database>SQLSTATE</database> immer '00000'. Außerhalb PSQL ist es nicht verfügbar.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>CHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  Msg = case sqlstate
          when '22003' then 'Numeric value out of range.'
          when '22012' then 'Division by zero.'
          when '23000' then 'Integrity constraint violation.'
          else 'Something bad happened! SQLSTATE = ' || sqlstate
        end;  
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Hinweise</title>
        <para><itemizedlist>
            <listitem>
                <para><database>SQLSTATE</database> soll <database>SQLCODE</database> ersetzen. Letzteres 
                ist jetzt in Firebird veraltet und wird in einer zukünftigen Version verschwinden.</para>
            </listitem>
            <listitem>
              <para>Firebird unterstützt (noch) nicht die Syntax <quote><database>WHEN SQLSTATE ... DO</database></quote>. 
              Sie müssen <database>WHEN ANY</database> verwenden und die Variable <database>SQLSTATE</database>
              im Handler testen.</para>
              <!--Request for improvement CORE-3526-->
            </listitem>
            <listitem>
              <para>Jeder <database>SQLSTATE</database>-Code ist die Verkettung einer 2-Zeichen-Klasse und 
              einer 3-Zeichen-Unterklasse. Die Klassen 00 (erfolgreicher Abschluss), 01 (Warnung) und 02 (keine Daten) 
              repräsentieren <firstterm>Abschlussbedingungen</firstterm>. Jeder Statuscode außerhalb dieser 
              Klassen ist eine <firstterm>Ausnahme</firstterm>. Da die Klassen 00, 01 und 02 keinen Fehler 
              verursachen, werden sie niemals in der <database>SQLSTATE</database>-Variable angezeigt.</para>
            </listitem>
            <listitem>
              <para>Für eine vollständige Auflistung der <database>SQLSTATE</database>-Codes, konsultieren Sie bitte
               den Abschnitt <link linkend="fblangref25-appx02-tbl-sqlstates-de">SQLSTATE Fehlercodes und Meldungen</link>
               in <citetitle>Appendix B: Fehlercodes und Meldungen</citetitle>.
              </para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
		<section id="fblangref25-contextvars-today-de">
		  <title><database>'TODAY'</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL, ESQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>'TODAY'</database> ist keine Variable, sondern ein String-Literal. Es ist jedoch speziell im Sinne
                    dass Sie das aktuelle Datum erhalten, wenn Sie ein <database>CAST()</database> zu einem Datum / einer Zeit durchführen.
		<database>'TODAY'</database> unterscheided nicht zwischen Groß- und Kleinschreibung. Die Engine ignoriert führende oder 
                nachstehende Leerzeichen beim Umwandeln.</para>
		  </formalpara>
		  <formalpara>
		    <title>Typ</title>
		    <para><database>CHAR(5)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select 'Today' from rdb$database
		-- ergibt 'Today'</programlisting>
		        <programlisting>select cast('Today' as date) from rdb$database
		-- ergibt z.B. 2011-10-03</programlisting>
		        <programlisting>select cast('TODAY' as timestamp) from rdb$database
		-- ergibt z.B. 2011-10-03 00:00:00.0000</programlisting>
		        <para><link linkend="fblangref25-datatypes-convert-shortcasts-de">Kurzschreibweisen für Casts von Datums- und Zeit-Datentypen</link> 
                        für die letzten beiden Statements:</para>
		        <programlisting>select date 'Today' from rdb$database
		select timestamp 'TODAY' from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Hinweise</title>
		    <para><itemizedlist>
		        <listitem>
		          <para><database>'TODAY'</database> gibt immer das aktuelle Datum zurück, auch in PSQL-Modulen, 
                          in denen <database>CURRENT_DATE</database>, <link
		          linkend="fblangref25-contextvars-current_time-de"><database>CURRENT_TIME</database></link> und <link
		          linkend="fblangref25-contextvars-current_timestamp-de"><database>CURRENT_TIMESTAMP</database></link>
		          den gleichen Rückgabewert während der gesamten Dauer der äußersten Routine hat. Dies macht 
		          <database>'TODAY'</database> nützlich für die Messung von Zeitintervallen in Triggern, Prozeduren und
                          ausführbaren Blöcken (zumindest, wenn Ihre Prozeduren für mehrere Tage läuft.).</para>
		        </listitem>
		        <listitem>
		          <para>Außer in der oben genannten Situation ist das Lesen von <database>CURRENT_DATE</database> im 
                          Allgemeinen besser als das Konvertieren von <database>'NOW'</database>.
                          </para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		</section>
		<section id="fblangref25-contextvars-tomorrow-de">
		  <title><database>'TOMORROW'</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL, ESQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>'TOMORROW'</database> ist keine Variable, sondern ein String-Literal. Es ist jedoch speziell im Sinne
                    dass Sie das Datum des nächsten Tages erhalten, wenn Sie ein <database>CAST()</database> zu einem Datum / einer Zeit durchführen.
		<database>'TOMORROW'</database> unterscheided nicht zwischen Groß- und Kleinschreibung. Die Engine ignoriert führende oder 
                nachstehende Leerzeichen beim Umwandeln. Siehe auch <link
        linkend="fblangref25-contextvars-today-de"><database>'TODAY'</database></link>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Typ</title>
		    <para><database>CHAR(8)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select 'Tomorrow' from rdb$database
		-- ergibt 'Tomorrow'</programlisting>
		        <programlisting>select cast('Tomorrow' as date) from rdb$database
		-- ergibt z.B. 2011-10-04</programlisting>
		        <programlisting>select cast('TOMORROW' as timestamp) from rdb$database
		-- ergibt z.B. 2011-10-04 00:00:00.0000</programlisting>
		        <para><link linkend="fblangref25-datatypes-convert-shortcasts-de">Kurzschreibweisen für Casts von Datums- und Zeit-Datentypen</link> 
                        für die letzten beiden Statements:</para>
		        <programlisting>select date 'Tomorrow' from rdb$database
		select timestamp 'TOMORROW' from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>
    <section id="fblangref25-contextvars-updating-de">
      <title><database>UPDATING</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>Nur in Triggern verfügbar. <database>UPDATING</database> gibt an, ob der Trigger durch eine
        Aktualisierungsoperation (<database>UPDATING</database>) ausgelöst wurde. Vorgesehen für den Einsatz in <link
        linkend="fblangref25-ddl-trgr-relntrigger-rowevent-de">Multi-Aktions-Trigger</link>.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

		<section id="fblangref25-contextvars-yesterday-de">
		  <title><database>'YESTERDAY'</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL, ESQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>'YESTERDAY'</database> ist keine Variable, sondern ein String-Literal. Es ist jedoch speziell im Sinne
                    dass Sie das aktuelle Datum erhalten, wenn Sie ein <database>CAST()</database> zu einem Datum / einer Zeit durchführen.
		<database>'YESTERDAY'</database> unterscheided nicht zwischen Groß- und Kleinschreibung. Die Engine ignoriert führende oder 
                nachstehende Leerzeichen beim Umwandeln. Siehe auch <link
        linkend="fblangref25-contextvars-today-de"><database>'TODAY'</database></link>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Typ</title>
		    <para><database>CHAR(9)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select 'Yesterday' from rdb$database
		-- ergibt 'Tomorrow'</programlisting>
		        <programlisting>select cast('Yesterday as date) from rdb$database
		-- ergibt z.B. 2011-10-02</programlisting>
		        <programlisting>select cast('YESTERDAY' as timestamp) from rdb$database
		-- ergibt z.B. 2011-10-02 00:00:00.0000</programlisting>
		        <para><link linkend="fblangref25-datatypes-convert-shortcasts-de">Kurzschreibweisen für Casts von Datums- und Zeit-Datentypen</link> 
                        für die letzten beiden Statements:</para>
		        <programlisting>select date 'Yesterday' from rdb$database
		select timestamp 'YESTERDAY' from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>

    <section id="fblangref25-contextvars-user-de">
      <title><database>USER</database></title>
      <formalpara>
        <title>Verfügbar in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para><database>USER</database> ist eine Kontextvariable, die den aktuellen Namen des derzeit 
        verbundenen Benutzers vorhält. Es ist vollständig äquivalent zu
            <link linkend="fblangref25-contextvars-current_user-de">
            <database>CURRENT_USER</database>
        </link>.</para>
      </formalpara>
      <formalpara>
        <title>Typ</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Beispiel</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

  </section>
<!-- **************************************************************************************
                   S C A L A R   F U N C T I O N S
    ************************************************************************************** -->

  <section id="fblangref25-functions-scalarfuncs-de">
    <title>Skalarfunktionen</title>

      <sidebar id="fblangref25-functions-nameclashes-de">
        <title>Upgrader: BITTE LESEN!</title>
        <para>Eine große Anzahl von Funktionen, die in früheren Versionen von Firebird als 
            externe Funktionen (UDFs) implementiert wurden, wurden schrittweise als interne 
            (eingebaute) Funktionen neu implementiert. Wenn eine externe Funktion mit dem 
            gleichen Namen wie eine integrierte Funktion in Ihrer Datenbank deklariert ist, 
            bleibt sie dort und überschreibt alle internen Funktionen desselben Namens.</para>
        <para>Um die internen Funktionen verfügbar sind, müssen Sie entweder ein
        <link linkend="fblangref25-ddl-extfunc-drop-de"><database>DROP</database></link>
        der UDF durchführen oder mittels <link linkend="fblangref25-ddl-extfunc-alter-de"><database>ALTER
        EXTERNAL FUNCTION</database></link> den Namen der UDF ändern.</para>
      </sidebar>

<!-- **************************************************************************************
    F U N C T I O N S  F O R   W O R K I N G   W I T H   C O N T E X T   V A R I A B L E S
    ************************************************************************************** -->
    <section id="fblangref25-functions-workcontext-de">
      <title>Funktionen zum Arbeiten mit Kontextvariablen</title>
		<section id="fblangref25-functions-scalarfuncs-get_context-de">
		  <title><database>RDB$GET_CONTEXT()</database></title>
		  <note>
		    <para><database>RDB$GET_CONTEXT</database> und sein Gegenpart
		    <database>RDB$SET_CONTEXT</database> sind vordefinierte UDFs. Sie werden hier als 
                    interne Funktionen geführt, da sie immer präsent sind&#x2014;der Benutzer muss nichts tun, damit
                    diese verfügbar sind.</para>
		  </note>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL
		    &nbsp; * Als deklariertes UDF sollte es in ESQL verfügbar sein</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Ruft den Wert einer Kontextvariablen aus einem der Namespaces
		    <database>SYSTEM</database>, <database>USER_SESSION</database> und
		    <database>USER_TRANSACTION</database> auf.</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RDB$GET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>')

		<replaceable>&lt;namespace&gt;</replaceable>  ::=  SYSTEM | USER_SESSION | USER_TRANSACTION
		<replaceable>&lt;varname&gt;</replaceable>    ::=  Eine Zeichenfolge, bei der die Groß- und Kleinschreibung beachtet werden muss. 
                Maximal 80 Zeichen</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-rdbgetcontext-de">
      <?dbfo keep-together='auto'?>
        <title>RDB$GET_CONTEXT-Funktionsparameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">namespace</entry>
              <entry align="left">Namespace</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variablennamen. Groß- und Kleinschreibung Die maximale Länge beträgt 80 Zeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR(255)</database></para>
		  </formalpara>

		  <formalpara>
		    <title role="block">Die Namespaces</title>
		    <para>Die Namespaces <database>USER_SESSION</database> und <database>USER_TRANSACTION</database>
		    sind initial leer. Der Benutzer kann hierin Variablen erstellen und mittels
		    <database>RDB$SET_CONTEXT()</database> festlegen und diese mit
		    <database>RDB$GET_CONTEXT()</database> zurückgeben lassen. Der Zugriff auf den Namespace <database>SYSTEM</database>
                    erfolgt nur lesend. Dieser enthält eine Menge vordefinierter Variablen, die in folgender Tabelle aufgelistet sind.<table
		        border="topbot" id="fblangref25-funcs-tbl-systemnamespace-de">
		        <title>Kontextvariablen im SYSTEM-Namespace</title>
		        <tgroup cols="2">
		          <colspec colname="colVarname" colwidth="1*" />
		          <colspec colname="colVardescr" colwidth="3*" />
		          <tbody>
		            <row valign="top">
		              <entry><database>DB_NAME</database></entry>
		              <entry>Entweder der vollständige Pfad der Datenbank oder&#x2014;falls das Verbinden mittels des Pfades 
                                  deaktiviert ist&#x2014;dessen Alias.</entry>
		            </row>
		            <row valign="top">
		              <entry><database>NETWORK_PROTOCOL</database></entry>
		              <entry>Das Verbindungsprotokoll: <literal>'TCPv4'</literal>,
		              <literal>'WNET'</literal>, <literal>'XNET'</literal> oder
		              <constant>NULL</constant>.</entry>
		            </row>
		            <row valign="top">
		              <entry><database>CLIENT_ADDRESS</database></entry>
		              <entry>Für TCPv4 ist dies die IP-Adresse. Für XNET die lokale Prozess-ID. Für alle anderen 
                                  Protokolle ist diese Variable <constant>NULL</constant>.</entry>
		            </row>
		            <row valign="top">
		              <entry><database>CURRENT_USER</database></entry>
		              <entry>Identisch zur globalen Variable <link
		              linkend="fblangref25-contextvars-current_user-de"><database>CURRENT_USER</database></link>.
		              </entry>
		            </row>
		            <row valign="top">
		              <entry><database>CURRENT_ROLE</database></entry>
		              <entry>Identisch zur globalen Variable <link
		              linkend="fblangref25-contextvars-current_role-de"><database>CURRENT_ROLE</database></link>.
                              </entry>
		            </row>
		            <row valign="top">
		              <entry><database>SESSION_ID</database></entry>
		              <entry>Identisch zur globalen Variable <link
		              linkend="fblangref25-contextvars-current_connection-de"><database>CURRENT_CONNECTION</database></link>
		              </entry>
		            </row>
		            <row valign="top">
		              <entry><database>TRANSACTION_ID</database></entry>
		              <entry>Identisch zur globalen Variable <link
		              linkend="fblangref25-contextvars-current_transaction-de"><database>CURRENT_TRANSACTION</database></link>
		              </entry>
		            </row>
		            <row valign="top">
		              <entry><database>ISOLATION_LEVEL</database></entry>
		              <entry>Die Isolationsstufe der aktuellen Transaktion: <database>'READ COMMITTED'</database>,
                              <database>'SNAPSHOT'</database> oder <database>'CONSISTENCY'</database>.</entry>
		            </row>
		            <row valign="top">
		              <entry><database>ENGINE_VERSION</database></entry>
		              <entry>Die (Server-) Version der Firebird-Engine. Hinzugefügt in 2.1.</entry>
		            </row>
		          </tbody>
		        </tgroup>
		      </table></para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabewerte und Fehlerverhalten</title>
		    <para>Wenn die abgefragte Variable im angegebenen Namespace vorhanden ist, wird ihr Wert als eine Zeichenfolge 
                        mit max. 255 Zeichen. Wenn der Namespace nicht vorhanden ist oder wenn Sie versuchen, auf eine nicht 
                        vorhandene Variable im Namespace <database>SYSTEM</database> zuzugreifen, wird ein Fehler ausgegeben. 
                            Wenn Sie eine nicht vorhandene Variable in einem der anderen Namespaces abfragen, wird <constant>NULL</constant> 
                            zurückgegeben. Sowohl Namespaces als auch Variablennamen müssen als single-quoted, case-sensitive, nicht 
                            <constant>NULL</constant>-Strings angegeben werden.</para>
		    <!--Funny enough, a variable's name may be the empty string.-->
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database</programlisting>
		      </blockquote><blockquote>
		        <programlisting>New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');</programlisting>
		        <programlisting>insert into MyTable (TestField)
		values (rdb$get_context('USER_SESSION', 'MyVar'))</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-set_context-de"><database>RDB$SET_CONTEXT()</database></link></para>
		  </formalpara>
		</section>
		<section id="fblangref25-functions-scalarfuncs-set_context-de">
		  <title><database>RDB$SET_CONTEXT()</database></title>
		  <note>
		    <para><database>RDB$SET_CONTEXT</database> und dessen Gegenpart
		    <database>RDB$GET_CONTEXT</database> sind vordefinierte UDFs. Sie werden hier als 
                    interne Funktionen geführt, da sie immer präsent sind&#x2014;der Benutzer muss nichts tun, damit
                    diese verfügbar sind.</para>
		  </note>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL
		    &nbsp; * Als deklariertes UDF sollte es in ESQL verfügbar sein</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Erstellt, setzt oder löscht eine Variable in einem der vom Benutzer beschreibbaren Namespaces
		    <database>USER_SESSION</database> und <database>USER_TRANSACTION</database>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RDB$SET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>', <replaceable>&lt;value&gt;</replaceable> | <constant>NULL</constant>)

		<replaceable>&lt;namespace&gt;</replaceable>  ::=  USER_SESSION | USER_TRANSACTION
		<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters
		<replaceable>&lt;value&gt;</replaceable>      ::=  A value of any type, as long as it's castable
		              to a VARCHAR(255)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-rdbsetcontext-de">
      <?dbfo keep-together='auto'?>
        <title>RDB$SET_CONTEXT-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">namespace</entry>
              <entry align="left">Namespace</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variablennamen. Groß- und Kleinschreibung Die maximale Länge beträgt 80 Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">Daten eines beliebigen Typs, sofern sie in VARCHAR (255) umgewandelt werden können</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>

		  <formalpara>
		    <title role="block">Die Namespaces</title>
		    <para>Die Namespaces <database>USER_SESSION</database> und <database>USER_TRANSACTION</database>
                        sind initial leer. Der Benutzer kann hierin Variablen erstellen und mittels
                        <database>RDB$SET_CONTEXT()</database> festlegen und diese mit
                        <database>RDB$GET_CONTEXT()</database> zurückgeben lassen. Der Kontext <database>USER_SESSION</database>
                        ist an die derzeitige Verbindung gebunden Variablen in <database>USER_TRANSACTION</database> existieren
                        nur in der Transaktion, in der sie erstellt wurden. Wenn die Transaktion endet, werden der Kontext und
                        alle hierin definierten Variablen zerstört.</para>
		  </formalpara>
		  <formalpara>
		    <title role="block">Rückgabewerte und Fehlerverhalten</title>
		    <para>Die Funktion gibt 1 zurück, wenn die Variable bereits vor dem Aufruf vorhanden, 
                        und 0, falls dies nicht der Fall war. Um eine Variable aus einem Kontext zu entfernen, 
                        setzen Sie sie auf <constant>NULL</constant>. Wenn der angegebene Namespace nicht existiert, wird ein Fehler 
                        ausgelöst. Sowohl Namespaces als auch Variablennamen müssen als nicht-<constant>NULL</constant>-Zeichenketten ind
                        einzelne Anführungszeichen eingegeben werden. Beachten Sie dabei Groß- und Kleinschreibung.</para>
		    <!--Funny enough, a variable's name may be the empty string.-->
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database</programlisting>
		      </blockquote><blockquote>
		        <programlisting>rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);</programlisting>
		        <programlisting>select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
		from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Hinweise</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>Die maximale Anzahl der Variablen in einem einzelnen Kontext beträgt 1000.</para>
		        </listitem>
		        <listitem>
		          <para>Alle <database>USER_TRANSACTION</database>-Variablen überleben das <link
		          linkend="fblangref25-transacs-rollback-options-de"><database>ROLLBACK RETAIN</database></link> 
                          (siehe <database>ROLLBACK</database>-Optionen) oder
		          <link linkend="fblangref25-transacs-rollback-tosavepoint-de"><database>ROLLBACK TO
		          SAVEPOINT</database></link> unverändert, unabhängig zu welchen Zeitpunkt der Transaktion diese gesetzt
                          wurden.</para>
		        </listitem>
		        <listitem>
		          <para>Aufgrund seiner UDF-ähnlichen Eigenschaft kann <database>RDB$SET_CONTEXT</database>
                            &#x2014;nur in PSQL&#x2014;
                          wie eine void-Funktion aufgerufen werden, ohne das Ergebnis wie im zweiten Beispiel oben zuzuweisen. 
                          Reguläre interne Funktionen erlauben diese Art der Verwendung nicht.</para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-get_context-de"><database>RDB$GET_CONTEXT()</database></link></para>
		  </formalpara>
		</section>
    </section> <!-- Functions for Working with Context Variables -->

<!-- **************************************************************************************
                 M A T H   F U N C T I O N S
    ************************************************************************************** -->
    <section id="fblangref25-functions-math-de">
      <title>Mathematische Funktionen</title>
		<section id="fblangref25-functions-scalarfuncs-abs-de">
		  <title><database>ABS()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ABS (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-abs-de">
      <?dbfo keep-together='auto'?>
        <title>ABS Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Numerisch</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den absoluten Wert des Arguments zurck.</para>
		  </formalpara>

		</section>

		<section id="fblangref25-functions-scalarfuncs-acos-de">
		  <title><database>ACOS()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ACOS (<replaceable>number</replaceable>)
                        </programlisting></blockquote>
                    </para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-acos-de">
      <?dbfo keep-together='auto'?>
        <title>ACOS Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs im Bereich [-1; 1]</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
                  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Arkuskosinus des Arguments zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Das Ergebnis ist ein Winkel im Bereich <!-- [0, π] -->[0, pi].</para>
		          </listitem>
		          <listitem>
		            <para>Ist das Argument außerhalb der Bereichs [-1, 1], wird NaN zurückgegeben.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>

		</section>

		<section id="fblangref25-functions-scalarfuncs-asin-de">
		  <title><database>ASIN()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ASIN (<replaceable>number</replaceable>)</programlisting>
		        </blockquote>
		     </para>
                  </formalpara>
      <table id="fblangref25-funcs-tbl-asin-de">
      <?dbfo keep-together='auto'?>
        <title>ASIN Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs im Bereich [-1; 1]</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Arkussinus des Arguments zurück.
                       <itemizedlist>
		          <listitem>
		            <para>Das Ergebnis ist ein Winkel im Bereich <!-- [-π/2, π/2] -->[-pi/2, pi/2].</para>
		          </listitem>
		          <listitem>
		            <para>Liegt das Argument außerhalb des Bereichs [-1, 1], wird NaN zurückgegeben.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>

		</section>

		<section id="fblangref25-functions-scalarfuncs-atan-de">
		  <title><database>ATAN()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ATAN (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-atan-de">
      <?dbfo keep-together='auto'?>
        <title>ATAN Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
      <formalpara>
        <title>Beschreibung</title>
        <para>&nbsp;Die Funktion <database>ATAN</database> gibt den Arcustangens des Arguments zurück. 
        Das Ergebnis ist ein Winkel im Bereich &lt;-pi/2, pi/2&gt;.
        </para>
      </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-atan2-de">
		  <title><database>ATAN2()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <!--Note for maintainers/editors: the argument names y and x (in that order!) are chosen on purpose, for geometrical reasons.-->
		        <programlisting>ATAN2 (<replaceable>y</replaceable>, <replaceable>x</replaceable>)</programlisting>
		        </blockquote></para>
                   </formalpara>

      <table id="fblangref25-funcs-tbl-atan2-de">
      <?dbfo keep-together='auto'?>
        <title>ATAN2-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">x</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">y</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
                  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Winkel zurück, dessen Sinus-Kosinus<emphasis>-Verhältnis</emphasis> durch die beiden 
                    Argumente gegeben ist und dessen Sinus- und Kosinus<emphasis>-Zeichen</emphasis> den Vorzeichen
                        der Argumente entsprechen. Dies ermöglicht Ergebnisse über den gesamten Kreis einschließlich der
                        Winkel -pi/2 und pi/2.
                      <itemizedlist>
		          <listitem>
		            <para>Das Ergebnis ist ein Winkel im Bereich [-pi, pi].</para>
		          </listitem>
		          <listitem>
		            <para>Ist <replaceable>x</replaceable> negativ, ist das Ergebnis Pi, falls
		            <replaceable>y</replaceable> gleich 0 ist, und -Pi falls <replaceable>y</replaceable> gleich
		            -0 ist.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn sowohl <replaceable>y</replaceable> als auch <replaceable>x</replaceable> 0 sind, 
                            ist das Ergebnis bedeutungslos. Beginnend mit Firebird 3 wird ein Fehler ausgelöst, wenn beide 
                            Argumente 0 sind. Bei Version 2.5.4 ist es in niedrigeren Versionen immer noch nicht behoben. 
                            Für weitere Details, besuchen Sie 
                            <ulink url="http://tracker.firebirdsql.org/browse/CORE-3201">Tracker-Ticket CORE-3201</ulink>.</para>
		          </listitem>
                      </itemizedlist>
		      </para>
		  </formalpara>

		  <formalpara>
		    <title>Hinweise</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>Eine vollständig äquivalente Beschreibung dieser Funktion ist die folgende:
		          <database>ATAN2</database>(<replaceable>y</replaceable>, <replaceable>x</replaceable>)
		          ist ein Winkel zwischen der positiven X-Achse und der Linie vom Ursprung zum Punkt
		          (<replaceable>x</replaceable>, <replaceable>y</replaceable>). Damit wird offensichtlich, dass
                           <database>ATAN2</database>(0, 0) nicht definiert ist.</para>
		        </listitem>
		        <listitem>
		          <para>Ist <replaceable>x</replaceable> größer als 0, ist
		          <database>ATAN2</database>(<replaceable>y</replaceable>, <replaceable>x</replaceable>)
		          das gleiche wie
		          <database>ATAN</database>(<replaceable>y</replaceable>/<replaceable>x</replaceable>).</para>
		        </listitem>
		        <listitem>
		          <para>Wenn Sinus und Kosinus des Winkels bereits bekannt sind, gibt
		          <database>ATAN2</database>(<replaceable>sin</replaceable>,
		          <replaceable>cos</replaceable>) den Winkel zurück.</para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-ceil-de">
		  <title><database>CEIL()</database>, <database>CEILING()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    &nbsp; (Betrifft nur <database>CEILING</database></para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CEIL[ING] (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-ceil-de">
      <?dbfo keep-together='auto'?>
        <title>CEIL[ING]-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database> or <database>DOUBLE PRECISION</database><!--DOUBLE PRECISION if arg is an SQL parameter--></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die kleinste ganze Zahl zurück, die größer oder gleich dem Argument ist.</para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-floor-de"><database>FLOOR()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-cos-de">
		  <title><database>COS()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COS (<replaceable>angle</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-cos-de">
      <?dbfo keep-together='auto'?>
        <title>COS Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">angle</entry>
              <entry align="left">Ein Winkel in Bogenmaß</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Kosinus eines Winkels zurück. Das Argument muss im Bogenmaß angegeben werden.
                      <itemizedlist>
		          <listitem>
		            <para>Jedes nicht-<constant>NULL</constant>-Ergebnis ist&#x2014;offensichtlich&#x2014;im Bereich [-1,
		            1].</para>
		          </listitem>
		        </itemizedlist>
        </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-cosh-de">
		  <title><database>COSH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COSH (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-cosh-de">
      <?dbfo keep-together='auto'?>
        <title>COSH Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Eine Zahl eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Hyperbelkosinus des Arguments zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Beliebiges non-<constant>NULL</constant>-Ergebnis liegt im Bereich [1, INF].</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-cot-de">
		  <title><database>COT()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COT (<replaceable>angle</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-cot-de">
      <?dbfo keep-together='auto'?>
        <title>COT Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">angle</entry>
              <entry align="left">Ein Winkel in Bogenmaß</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Kotangens eines Winkels zurück. Das Argument muss im Bogenmaß angegeben werden.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-exp-de">
		  <title><database>EXP()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>EXP (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-exp-de">
      <?dbfo keep-together='auto'?>
        <title>EXP Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Eine Zahl eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das natürliche Exponential zurück,
		    <emphasis>e</emphasis><superscript><replaceable>number</replaceable></superscript></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-ln-de"><database>LN()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-floor-de">
		  <title><database>FLOOR()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>FLOOR (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-floor-de">
      <?dbfo keep-together='auto'?>
        <title>FLOOR Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database> oder <database>DOUBLE PRECISION</database><!--DOUBLE PRECISION if arg is an SQL parameter--></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die größte ganze Zahl zurück, die kleiner oder gleich dem Argument ist.</para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-ceil-de"><database>CEIL()</database>/
		    <database>CEILING()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-ln-de">
		  <title><database>LN()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LN (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-ln-de">
      <?dbfo keep-together='auto'?>
        <title>LN Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den natürlichen Logarithmus des Arguments zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Ein Fehler wird ausgelöst, wenn das Argument negativ oder 0 ist.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-exp-de"><database>EXP()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-log-de">
		  <title><database>LOG()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LOG (<replaceable>x</replaceable>, <replaceable>y</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-log-de">
      <?dbfo keep-together='auto'?>
        <title>LOG-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">x</entry>
              <entry align="left">Base. Ein Ausdruck eines numerischen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">y</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den <replaceable>x</replaceable>-basierten Logarithmus von
		    <replaceable>y</replaceable> zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Wenn eines der Argumente 0 oder niedriger ist, wird ein Fehler ausgelöst. 
                                (Vor 2.5 würde dies <constant>NaN</constant>, <constant>±INF</constant> oder 0
                                ergeben, abhängig von den genauen Argumentwerten)</para>
		          </listitem>
		          <listitem>
		            <para>Wenn beide Argumente 1 sind, wird <constant>NaN</constant> zurückgegebenreturned.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>x</replaceable> = 1 und <replaceable>y</replaceable> &lt; 1,
		            -<constant>INF</constant> wird zurückgegeben.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>x</replaceable> = 1 und <replaceable>y</replaceable> &gt; 1,
		            <constant>INF</constant> wird zurückgegeben.</para>
		          </listitem>
		        </itemizedlist>
        </para>
		        <!--See CORE-1936: In 2.1, this was a mess.-->
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-log10-de">
		  <title><database>LOG10()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Geändert in</title>
		    <para>2.5</para>
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LOG10 (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-log10-de">
      <?dbfo keep-together='auto'?>
        <title>LOG10 Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den 10-basierten Logarithmus des Arguments zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Ein Fehler wird ausgelöst, wenn das Argument negativ oder 0 ist. (In Versionen vor 2.5 würden solche Werte zu
                                <constant>NaN</constant> und <constant>INF</constant> resultieren.)</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-mod-de">
		  <title><database>MOD()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>MOD (<replaceable>a</replaceable>, <replaceable>b</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-mod-de">
      <?dbfo keep-together='auto'?>
        <title>MOD-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">a</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">b</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database> oder <database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Rest einer Ganzzahldivision zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Nicht ganzzahlige Argumente werden vor der Division gerundet. Demnach
                                ergibt <quote>7.5 mod 2.5</quote>  2 (8 mod 3), nicht 0.</para>
		          </listitem>
		        </itemizedlist>
        </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-pi-de">
		  <title><database>PI()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>PI()</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt eine Annäherung an den Wert von <literal>Pi</literal>.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-power-de">
		  <title><database>POWER()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>POWER (<replaceable>x</replaceable>, <replaceable>y</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-power-de">
      <?dbfo keep-together='auto'?>
        <title>POWER-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">x</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">y</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt <replaceable>x</replaceable> hoch <replaceable>y</replaceable> zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Ist <replaceable>x</replaceable> negativ, wird ein Fehler ausgegeben.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-rand-de">
		  <title><database>RAND()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RAND()</programlisting>
                    </blockquote></para>
                  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt eine Zufallszahl zwischen 0 und 1 zurück.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-round-de">
		  <title><database>ROUND()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ROUND (<replaceable>&lt;number&gt;</replaceable> [, <replaceable>&lt;scale&gt;</replaceable>])
                        </programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-round-de">
      <?dbfo keep-together='auto'?>
        <title>ROUND-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Eine ganze Zahl, die die Anzahl der Dezimalstellen angibt, auf die gerundet 
                  werden soll, z.B.:
                <simplelist type="horiz" columns="1">
                  <member>&nbsp;2 zum Runden auf das nächste Vielfache von 0,01</member>
                  <member>&nbsp;1 zum Runden auf das nächste Vielfache von 0,1</member>
                  <member>&nbsp;0 zum Runden auf die nächste ganze Zahl</member>
                  <member>-1 zum Runden auf das nächste Vielfache von 10</member>
                  <member>-2 zum Runden auf das nächste Vielfache von 100</member>
                </simplelist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database>, (scaled) <database>BIGINT</database> or
		    <database>DOUBLE PRECISION</database></para>
		    <!--DOUBLE if the first arg is a statement parameter-->
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Rundet eine Zahl auf die nächste ganze Zahl. Wenn der Bruchteil genau <literal>0,5</literal> 
                    ist, ist das Runden für positive Zahlen aufwärts und für negative Zahlen abwärts. Mit dem optionalen 
                    Argument <parameter>scale</parameter> kann die Zahl anstelle von ganzen Zahlen auf Zehnerpotenzen 
                    (Zehner, Hunderter, Zehntel, Hundertstel usw.) gerundet werden.</para>
		  </formalpara>

		  <important>
		    <itemizedlist>
		      <listitem>
		        <para>Wenn Sie das Verhalten der externen Funktion <function>ROUND</function> gewohnt sind, beachten Sie bitte, dass die 
                                <emphasis>interne</emphasis> Funktion immer die Hälfte von Null weg, d.h. abwärts für negative Zahlen, abrundet.</para>
		      </listitem>
		    </itemizedlist>
		  </important>
       <formalpara>
         <title>Beispiele</title>
           <para>Ist das Argument <parameter>scale</parameter> vorhanden, hat das Ergebnis üblicherweise die gleiche Genauigkeit
           wie das erste Argument:
             <blockquote><programlisting>
ROUND(123.654, 1) -- ergibt 123.700 (nicht 123.7)
ROUND(8341.7, -3) -- ergibt 8000.0 (nicht 8000)
ROUND(45.1212, 0) -- ergibt 45.0000 (nicht 45)
             </programlisting></blockquote>
         Andernfalls ist die Ergebnisgenauigkeit 0:
             <blockquote><programlisting>
ROUND(45.1212) -- ergibt 45
             </programlisting></blockquote>
           </para>
       </formalpara>
		</section>


		<section id="fblangref25-functions-scalarfuncs-sign-de">
		  <title><database>SIGN()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SIGN (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-sign-de">
      <?dbfo keep-together='auto'?>
        <title>SIGN Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>SMALLINT</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Returns the sign of the argument: -1, 0 or 1.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-sin-de">
		  <title><database>SIN()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SIN (<replaceable>angle</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-sin-de">
      <?dbfo keep-together='auto'?>
        <title>SIN Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">angle</entry>
              <entry align="left">Ein Winkel im Bogenmaß</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
         	    <para>Gibt den Sinus eines Winkels zurück. Das Argument muss im Bogenmaß angegeben werden.
                        <itemizedlist>
		          <listitem>
		            <para>Beliebiges nicht-<constant>NULL</constant>-Ergebnis liegt&#x2014;offensichtlich&#x2014;im Bereich [-1,
		            1].</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-sinh-de">
		  <title><database>SINH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SINH (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-sinh-de">
      <?dbfo keep-together='auto'?>
        <title>SINH Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Hyperbelsinus des Arguments zurück.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-sqrt-de">
		  <title><database>SQRT()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SQRT (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-sqrt-de">
      <?dbfo keep-together='auto'?>
        <title>SQRT Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die Quadratwurzel des Arguments zurück.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-tan-de">
		  <title><database>TAN()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>TAN (<replaceable>angle</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-tan-de">
      <?dbfo keep-together='auto'?>
        <title>TAN Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">angle</entry>
              <entry align="left">Ein Winkel im Bogenmaß</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die Tangente eines Winkels zurück. Das Argument muss im Bogenmaß angegeben werden.</para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-tanh-de">
		  <title><database>TANH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>TANH (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-tanh-de">
      <?dbfo keep-together='auto'?>
        <title>TANH-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Hyperbeltangens des Arguments zurück.
                      <itemizedlist>
		        <listitem>
		        <para>Aufgrund von Rundungen liegt ein nicht-<constant>NULL</constant>-Ergebnis im Bereich [-1,
		            1] (mathematisch ist es &lt;-1, 1&gt;).</para>
		        </listitem>
		      </itemizedlist>
                   </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-trunc-de">
		  <title><database>TRUNC()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		       <programlisting>TRUNC (<replaceable>&lt;number&gt;</replaceable> [, <replaceable>&lt;scale&gt;</replaceable>])
                       </programlisting>
		     </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-trunc-de">
      <?dbfo keep-together='auto'?>
        <title>TRUNC-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ausdruck eines numerischen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center"></entry>
              <entry align="left">Eine Ganzzahl, die die Anzahl der Dezimalstellen angibt, auf 
                  die die Abschneidung angewendet werden soll, z.
                <simplelist type="horiz" columns="1">
                  <member>&nbsp;2 zum Abschneiden auf das nächste Vielfache von 0,01</member>
                  <member>&nbsp;1 zum Abschneiden auf das nächste Vielfache von 0,1</member>
                  <member>&nbsp;0 zum Abschneiden auf die nächste ganze Zahl</member>
                  <member>-1 zum Abschneiden auf das nächste Vielfache von 10</member>
                  <member>-2 zum Abschneiden auf das nächste Vielfache von 100</member>
                </simplelist>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database>, (scaled) <database>BIGINT</database> or
		    <database>DOUBLE PRECISION</database></para>
		    <!--DOUBLE if the first arg is a statement parameter-->
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den ganzzahligen Teil einer Zahl zurück. Mit dem optionalen Argument <parameter>scale</parameter> 
                    kann die Zahl anstelle von ganzen Zahlen auf Zehnerpotenzen (Zehner, Hunderter, Zehntel, 
                    Hundertstel usw.) abgeschnitten werden.</para>
		  </formalpara>

		  <formalpara>
		    <title>Hinweise</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>IWenn das Argument <parameter>scale</parameter> vorhanden ist, hat das Ergebnis normalerweise 
                          die gleiche Genauigkeit wie das erste Argument, z.B.</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><database>TRUNC</database>(789.2225, 2) ergibt 789.2200 (nicht 789.22)</para>
		            </listitem>
		            <listitem>
		              <para><database>TRUNC</database>(345.4, -2) ergibt 300.0 (nicht 300)</para>
		            </listitem>
		            <listitem>
		              <para><database>TRUNC</database>(-163.41, 0) ergibt -163.00 (nicht -163)</para>
		            </listitem>
		          </itemizedlist>
		          <para>Andernfalls ist die Genauigkeit 0:</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><database>TRUNC</database>(-163.41) ergibt -163</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <important>
		    <para>Wenn Sie das Verhalten der <ulink
  url="http://www.firebirdsql.org/file/documentation/reference_manuals/reference_material/html/langrefupd25-udf-truncate.html">externen
  Funktion <function>TRUNCATE</function></ulink> untersuchen,
		    beachten Sie bitte, dass die <emphasis>interne</emphasis> Funktion <database>TRUNC</database>
		    immer gegen Null abschneidet, d.h. aufwärts für negative Zahlen.</para>
		  </important>
		</section>

  </section> <!-- Mathematical Functions -->

<!-- **************************************************************************************
            F U N C T I O N S   F O R   W O R K I N G   W I T H   S T R I N G S
    ************************************************************************************** -->
  <section id="fblangref25-functions-string-de">
    <title>Functions for Working with Strings</title>

		<section id="fblangref25-functions-scalarfuncs-ascii_char-de">
		  <title><database>ASCII_CHAR()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ASCII_CHAR (<replaceable>&lt;code&gt;</replaceable>)
                        </programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-asciichar-de">
      <?dbfo keep-together='auto'?>
        <title>ASCII_CHAR Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">code</entry>
              <entry align="left">Eine Ganzzahl im Bereich von  0 bis 255</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>[VAR]CHAR(1) CHARACTER SET NONE</database><!--VARCHAR when arg is NULL--></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das ASCII-Zeichen zurück, das der im Argument übergebenen Zahl entspricht.
         	      <important>
 		        <itemizedlist>
		          <listitem>
		            <para>Wenn Sie das Verhalten der UDF <function>ASCII_CHAR</function> gewohnt sind, die 
                            eine leere Zeichenfolge zurückgibt, wenn das Argument 0 ist, beachten Sie bitte, dass
                            die interne Funktion hier korrekt ein Zeichen mit dem ASCII-Code 0 zurückgibt.</para>
		          </listitem>
		        </itemizedlist>
		      </important>
		    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-ascii_val-de">
		  <title><database>ASCII_VAL()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ASCII_VAL (<replaceable>ch</replaceable>)
                        </programlisting>
                     </blockquote></para>
                   </formalpara>
      <table id="fblangref25-funcs-tbl-asciival-de">
      <?dbfo keep-together='auto'?>
        <title>ASCII_VAL Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">ch</entry>
              <entry align="left">Eine Zeichenfolge des Datentyps [VAR]CHAR oder ein Text-BLOB mit der maximalen Größe von 32.767 Byte</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>SMALLINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den ASCII-Code des übergebenen Zeichens zurück.
		        <itemizedlist>
		          <listitem>
		            <para>Wenn das Argument eine Zeichenfolge mit mehr als einem Zeichen ist, wird der 
                                ASCII-Code des ersten Zeichens zurückgegeben.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn das Argument eine leere Zeichenfolge ist, wird 0 zurückgegeben.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn das Argument <constant>NULL</constant> ist, wird <constant>NULL</constant>
		            zurückgegeben.</para>
		            <!--Should that be mentioned? It is the expected behaviour.-->
		          </listitem>
		          <listitem>
		            <para>Wenn das erste Zeichen der Argument-Zeichenfolge multi-Byte ist, wird ein Fehler ausgelöst. 
                                (Ein Fehler in Firebird 2.1&#x2014;2.1.3 und 2.5 führt dazu, dass ein Fehler ausgelöst wird, 
                                wenn <emphasis>irgendein</emphasis> Zeichen in der Zeichenfolge Multibyte ist. 
                                Dies ist in den Versionen 2.1.4 und 2.5.1 behoben. )
                            </para>
		            <!--RlsNotes say: Error if *first* char is multibyte. Entered bug CORE-3227. Fixed for 2.1.4, 2.5.1, 3.0-->
		          </listitem>
		        </itemizedlist>
		      </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-bit_length-de">
		  <title><database>BIT_LENGTH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIT_LENGTH (<replaceable>string</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-bitlength-de">
      <?dbfo keep-together='auto'?>
        <title>BIT_LENGTH Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die Länge in Bits der Eingabezeichenfolge an. Bei Multi-Byte-Zeichensätzen ist dies 
                        möglicherweise weniger als die Anzahl der Zeichen mal 8 mal die <quote>formale</quote> Anzahl 
                        der Bytes pro Zeichen wie in <database>RDB$CHARACTER_SETS</database>.</para>
		  </formalpara>
		  <note>
		    <para>Bei Argumenten vom Typ <database>CHAR</database> berücksichtigt diese Funktion die gesamte Länge
                    der formalen Zeichenfolge (z. B. die deklarierte Länge eines Felds oder einer Variablen). Wenn Sie die 
                    <quote>logische</quote> Bitlänge erhalten möchten, ohne die nachfolgenden Leerzeichen zu zählen,
		    schneiden sie das Argument mittels <link linkend="fblangref25-functions-scalarfuncs-trim-de"><database>TRIM</database></link> 
                    rechtsseitig ab, bevor Sie es an <database>BIT_LENGTH</database>übergeben.</para>
		  </note>
		  <formalpara>
		    <title><database>BLOB</database>-Unterstützung</title>
                    <para>Seit Firebird 2.1 unterstützt diese Funktion vollständig Text <database>BLOB</database>s beliebiger Länge und Zeichensatz.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select bit_length('Hello!') from rdb$database
		-- ergibt 48</programlisting>
		        <programlisting>select bit_length(_iso8859_1 'Grüß di!') from rdb$database
		-- ergibt 64: ü und ß nehmen je ein Byte in Anspruc in ISO8859_1</programlisting>
		        <programlisting>select bit_length
		(cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
		from rdb$database
		-- ergibt 80: ü und ß belegen je zwei Bytes in UTF8</programlisting>
		        <programlisting>select bit_length
		(cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
		from rdb$database
		-- ergibt 208: alle 24 <database>CHAR</database>-Positionen zählen ud zwei von ihnen haben 16 Bit.</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-octet_length-de"><database>OCTET_LENGTH()</database></link>,
		    <link
		    linkend="fblangref25-functions-scalarfuncs-char_length-de"><database>CHARACTER_LENGTH()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-char_length-de">
		  <title><database>CHAR_LENGTH()</database>, <database>CHARACTER_LENGTH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CHAR_LENGTH (<replaceable>str</replaceable>)
		CHARACTER_LENGTH (<replaceable>string</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-charlength-de">
      <?dbfo keep-together='auto'?>
        <title>CHAR[ACTER]_LENGTH Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die Länge der Zeichen der Eingabezeichenfolge an.</para>
		  </formalpara>
		  <note>
		    <title>Hinweise</title>
		      <itemizedlist>
		        <listitem><para>Mit Argumenten vom Typ <database>CHAR</database> gibt diese Funktion die formale 
                        Stringlänge (d.h. die deklarierte Länge eines Felds oder einer Variablen) zurück. Wenn Sie die <quote>logische</quote> 
                        Länge erhalten möchten, ohne die nachfolgenden Leerzeichen zu zählen, <link linkend="fblangref25-functions-scalarfuncs-trim-de"> 
                        <database>TRIM</database></link> das Argument, bevor es an <database>CHAR[ACTER]_LENGTH</database>übergeben wird.</para>
                        </listitem>
		    <!--This is the case when
		- CASTing to CHAR(n)
		- Reading a CHAR(n) variable or table field

		But e.g. a SUBSTRING result, although formally of the same length as the first
		argument, has a CHAR_LENGTH (and strlen) equal to the 'FOR' argument or the
		length to the end of the string, e.g:
		SUBSTRING('Hello' from 3 for 2) is a CHAR(5) with CHAR_LENGTH 2
		SUBSTRING('Hello' from 2) is a CHAR(5) with CHAR_LENGTH 4
		SUBSTRING('Hello' from 2 for 8) is a CHAR(5) with CHAR_LENGTH 4

		However, as soon as you CAST such substrings to a CHAR(n) or store them
		in a CHAR(n) field or variable, the CHAR_LENGTH becomes n.

		Another example: if you have a char(12) column with the string 'AB', it has
		a CHAR_LENGTH of 12 and concatenation with '.' shows the 10 spaces. Now if
		you select SUBSTRING(field from 2 for 2), you get a CHAR(12) with CHAR_LENGTH 2.
		You see only an A, but concatenation with '.' shows there's a space behind it.

		The conclusion must be (I think) that SUBSTRING puts a zero character after the
		result, or maybe fills the entire formal length with zero chars.-->
                        <listitem><para><emphasis role="bold"><database>BLOB</database>-Untersützung</emphasis>: 
                        &nbsp; Seit Firebird 2.1 unterstützt diese Funktion Text-<database>BLOB</database>s 
                        beliebiger Länge und beliebiger Zeichensätze.</para>
		        </listitem>
		      </itemizedlist>
		  </note>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select char_length('Hello!') from rdb$database
		-- ergibt 6</programlisting>
		        <programlisting>select char_length(_iso8859_1 'Grüß di!') from rdb$database
		-- ergibt 8</programlisting>
		        <programlisting>select char_length
		(cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
		from rdb$database
		-- ergibt 8; die Tatsache, dass ü und ß jeweils zwei Bytes belegen, ist irrelevant</programlisting>
		        <programlisting>select char_length
		(cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
		from rdb$database
		-- ergibt 24: alle 24 <database>CHAR</database>-Positionen zählen</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-bit_length-de"><database>BIT_LENGTH()</database></link>, <link
		    linkend="fblangref25-functions-scalarfuncs-octet_length-de"><database>OCTET_LENGTH()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-hash-de">
		  <title><database>HASH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>HASH (<replaceable>string</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-hash-de">
      <?dbfo keep-together='auto'?>
        <title>HASH Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt einen Hash-Wert für die Eingabezeichenfolge zurück. Diese Funktion unterstützt vollständig Text-<database>BLOB</database>s 
                    beliebiger Länge und beliebige Zeichensätze.</para>
		    <!--This function seems rather crummy. It's only 64-bit, and for shorter strings it returns smaller numbers.
		For single ASCII characters it simply returns the ASCII code.-->
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-left-de">
		  <title><database>LEFT()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LEFT (<replaceable>string</replaceable>, <replaceable>length</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-left-de">
      <?dbfo keep-together='auto'?>
        <title>LEFT-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Ganze Zahl. Definiert die Anzahl der zurückzugebenden Zeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den äußersten linken Teil der Argument-Zeichenfolge zurück. Die Anzahl der Zeichen 
                        ist im zweiten Argument angegeben.
		        <itemizedlist>
		          <listitem>
		            <para>Diese Funktion unterstützt vollständig Text<database>BLOB</database>s beliebiger 
                            Länge, einschließlich solcher mit einem Multi-Byte-Zeichensatz.</para>
		          </listitem>
		          <listitem>
		            <para>Falls <replaceable>string</replaceable> ein <database>BLOB</database> ist, ist das Ergebnis
		            ein <database>BLOB</database>. Andernfalls ist das Ergebnis ein
		            <database>VARCHAR(<replaceable>n</replaceable>)</database>, wobei
		            <replaceable>n</replaceable> die Länge der Eingabezeichenfolge ist.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn das Argument <replaceable>length</replaceable> die Länge der Zeichenfolge überschreitet,
                            wird die Eingabezeichenfolge unverändert zurückgegeben.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn das Argument <replaceable>length</replaceable> keine Ganzzahl ist,
		            wird kaufmännisch gerundet, z.B. wird 0.5 zu 0, 1.5 wird zu 2, 2.5
		            wird zu 2, 3.5 wird zu 4, etc.</para>
		          </listitem>
		        </itemizedlist>
        </para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-right-de"><database>RIGHT()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-lower-de">
		  <title><database>LOWER()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="lowernote-de">&gt;siehe Details unten</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LOWER (<replaceable>string</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-lower-de">
      <?dbfo keep-together='auto'?>
        <title>LOWER FunktionsparameterS</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>(VAR)CHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das Kleinbuchstabenäquivalent der Eingabezeichenfolge zurück. Das genaue Ergebnis hängt vom Zeichensatz ab. 
                        Bei <database>ASCII</database> oder <database>NONE</database> zum Beispiel sind nur ASCII-Zeichen kleiner; 
                        mit <database>OCTETS</database> wird die gesamte Zeichenfolge unverändert zurückgegeben. Seit Firebird 2.1 
                        unterstützt diese Funktion auch vollständig Text-<database>BLOB</database>s beliebiger Länge und Zeichensatzes.</para>
		  </formalpara>
		  <note id="lowernote-de">
		    <title>Namenskonflikt</title>
		    <para>Da <database>LOWER</database> ein reserviertes Wort ist, hat die interne Funktion Vorrang, auch wenn die externe 
                    Funktion mit diesem Namen ebenfalls deklariert wurde. Um die (untergeordnete!) externe Funktion aufzurufen, verwenden 
                    Sie doppelte Anführungszeichen und die genaue Großschreibung, wie in
		    <function>"LOWER"</function>(<replaceable>str</replaceable>).</para>
		  </note>
		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>select Sheriff from Towns
		where lower(Name) = 'cooper''s valley'</programlisting>
		        <!--Maybe add some examples that show the workings with accented characters in different character sets.
		E.g. lower(_octets HÓPLÄ)  lower(_ascii 'HÓPLÄ') vs. lower(_iso8859_1 'HÓPLÄ').
		Do likewise for UPPER().-->
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-upper-de"><database>UPPER</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-lpad-de">
		  <title><database>LPAD()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LPAD(<replaceable>str</replaceable>, <replaceable>endlen</replaceable> [, <replaceable>padstr</replaceable>])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-lpad-de">
      <?dbfo keep-together='auto'?>
        <title>LPAD-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">str</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">endlen</entry>
              <entry align="left">Länge der Ausgabezeichenfolge</entry>
            </row>
            <row valign="middle">
              <entry align="center">padstr</entry>
              <entry align="left">Das Zeichen oder die Zeichenfolge, die zum Auffüllen der Quellzeichenfolge bis zur 
                  angegebenen Länge verwendet werden soll. Standard ist Leerzeichen (' ')</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database> oder <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Füllt eine Zeichenfolge linksseitig mit Leerzeichen oder mit einer benutzerdefinierten Zeichenfolge, 
                        bis eine bestimmte Länge erreicht ist.</para>
		  </formalpara>
		        <itemizedlist>
		          <listitem>
		            <para>Diese Funktion unterstützt vollständig Text-<database>BLOB</database>s beliebiger Länge und Zeichensätze.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>str</replaceable> ein <database>BLOB</database> ist, ist das Ergebnis
                            ebenfalls ein <database>BLOB</database>. Andernfalls ist das Ergebnis ein
		            <database>VARCHAR</database>(<replaceable>endlen</replaceable>).</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>padstr</replaceable> angegeben wurde und gleich <literal>''</literal> 
		            (Leeres Zeichen) ist, findet kein Auffüllen statt.</para>
		          </listitem>
		          <listitem>
		            <para>Ist <replaceable>endlen</replaceable> kleiner als die aktuelle Länge der Zeichenkette,
		            wird die Zeichenkette auf <replaceable>endlen</replaceable> Zeichen abgeschnitten, auch wenn
		            <replaceable>padstr</replaceable> ein leeres Zeichen ist.</para>
		          </listitem>
         	        </itemizedlist>

		  <note>
                      <para>In Firebird 2.1 2.1.3 waren alle Nicht-BLOB-Ergebnisse vom Typ <database>VARCHAR</database>(32765), 
                      was es ratsam machte, sie auf eine bescheidenere Größe zu übertragen. Dies ist nicht mehr der Fall.</para>
		    <!--CORE-1346, backported to 2.1.4
		Actually, the length was 32765 for single-byte charsets, 8191 for UTF8, etc.-->
		  </note>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion möglicherweise 
                        das gesamte Objekt in den Speicher laden. Es wird zwar versucht, den Speicherverbrauch zu begrenzen, dies kann 
                        jedoch die Leistung beeinträchtigen, wenn riesige <database>BLOB</database>s beteiligt sind.</para>
		  </warning>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <para><programlisting>lpad ('Hello', 12)                 -- ergibt '       Hello'
lpad ('Hello', 12, '-')            -- ergibt '-------Hello'
lpad ('Hello', 12, '')             -- ergibt 'Hello'
lpad ('Hello', 12, 'abc')          -- ergibt 'abcabcaHello'
lpad ('Hello', 12, 'abcdefghij')   -- ergibt 'abcdefgHello'
lpad ('Hello', 2)                  -- ergibt 'He'
lpad ('Hello', 2, '-')             -- ergibt 'He'
lpad ('Hello', 2, '')              -- ergibt 'He'</programlisting></para>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-rpad-de"><database>RPAD()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-octet_length-de">
		  <title><database>OCTET_LENGTH()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>OCTET_LENGTH (<replaceable>string</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-octetlength-de">
      <?dbfo keep-together='auto'?>
        <title>OCTET_LENGTH Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die Länge in Bytes (Oktetts) der Eingabezeichenfolge an. Bei Multi-Byte-Zeichensätzen ist dies möglicherweise 
                        weniger als die Anzahl der Zeichen mal der <quote>formalen</quote>Anzahl der Bytes pro Zeichen, wie in 
                        <database>RDB$CHARACTER_SETS</database> gefunden.</para>
		  </formalpara>
		  <note>
		    <para>Bei Argumenten vom Typ <database>CHAR</database> berücksichtigt diese Funktion die gesamte Länge der formalen 
                        Zeichenfolge (z. B. die deklarierte Länge eines Felds oder einer Variablen). Wenn Sie die <quote>logische</quote>
                            Byte-Länge erhalten möchten, ohne die nachfolgenden Leerzeichen zu zählen, <link linkend="fblangref25-functions-scalarfuncs-trim-de"> 
                            beschneiden Sie die Zeichenfolge mittels <database>TRIM</database></link>, bevor sie diese an <database>OCTET_LENGTH</database>
                            übergeben wird.</para>
		  </note>
		  <formalpara>
		    <title><database>BLOB</database> support</title>
		    <para>Diese Funktion unterstützt vollständig Text-<database>BLOB</database>s beliebiger Länge und Zeichensätze.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select octet_length('Hello!') from rdb$database
		-- ergibt 6</programlisting>
		        <programlisting>select octet_length(_iso8859_1 'Grüß di!') from rdb$database
		-- ergibt 8: ü und ß belegen ein Byte pro Zeichen in ISO8859_1</programlisting>
		        <programlisting>select octet_length
		(cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
		from rdb$database
		-- ergibt 10: ü und ß belegen zwei Bytes je Zeichen in UTF8</programlisting>
		        <programlisting>select octet_length
		(cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
		from rdb$database
		-- ergibt 26: alle 24 <database>CHAR</database>-Positionen zählen, und zwei Zeichen belegen 2 Bytes</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-bit_length-de"><database>BIT_LENGTH()</database></link>, <link
		    linkend="fblangref25-functions-scalarfuncs-char_length-de"><database>CHARACTER_LENGTH()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-overlay-de">
		  <title><database>OVERLAY()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>
OVERLAY (<replaceable>string</replaceable> PLACING <replaceable>replacement</replaceable> FROM <replaceable>pos</replaceable> [FOR <replaceable>length</replaceable>])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-overlay-de">
      <?dbfo keep-together='auto'?>
        <title>OVERLAY-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Die Zeichenfolge, in die der Austausch stattfindet</entry>
            </row>
            <row valign="middle">
              <entry align="center">replacement</entry>
              <entry align="left">Ersatzzeichenfolge</entry>
            </row>
            <row valign="middle">
              <entry align="center">pos</entry>
              <entry align="left">Die Position, von der aus der Austausch stattfindet (Startposition)</entry>
            </row>
            <row valign="middle">
              <entry align="center">length</entry>
              <entry align="left">Die Anzahl der Zeichen, die überschrieben werden sollen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>OVERLAY()</database>überschreibt einen Teil einer Zeichenfolge mit einer anderen 
                        Zeichenfolge. Standardmäßig ist die Anzahl der Zeichen, die aus der Host-Zeichenfolge entfernt (überschrieben) 
                        werden, gleich der Länge der Ersatzzeichenfolge. Mit dem optionalen vierten Argument kann eine andere Anzahl 
                        von Zeichen zum Entfernen angegeben werden.
		        <itemizedlist>
		          <listitem>
		            <para>Diese Funktion unterstütz <database>BLOB</database>s beliebiger Länge.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>string</replaceable> oder <replaceable>replacement</replaceable>
		            ein <database>BLOB</database> ist, ist das Ergebnis ebenfalls ein <database>BLOB</database>.
		            Andernfalls ist das Ergebnisd ein <database>VARCHAR(<replaceable>n</replaceable>) wobei
		            <replaceable>n</replaceable> die Summe der Längen von
		            <replaceable>string</replaceable> und
		            <replaceable>replacement</replaceable> bildet.</database></para>
		          </listitem>
		          <listitem>
		            <para>Wie üblich in SQL-String-Funktionen ist <replaceable>pos</replaceable> 
		            1-basierend</para>
		          </listitem>
		          <listitem>
		            <para>Ist <replaceable>pos</replaceable> hinter dem Ende von
		            <replaceable>string</replaceable>, wird <replaceable>replacement</replaceable> direkt
		            hinter <replaceable>string</replaceable> platziert.</para>
		          </listitem>
		          <listitem>
		            <para>Ist die Anzahl der Zeichen von <replaceable>pos</replaceable> bis zum Ende von
                            <replaceable>string</replaceable> kleiner als die Länge von
		            <replaceable>replacement</replaceable> (oder als Argument
		            <replaceable>length</replaceable>, falls vorhanden),
		            wird <replaceable>string</replaceable> an Stelle <replaceable>pos</replaceable> abgeschnitten und
		            <replaceable>replacement</replaceable> direkt dahinter platziert.</para>
		          </listitem>
		          <listitem>
		            <para>Der Effekt einer <quote><database>FOR</database>0</quote>-Klausel ist, dass
		            <replaceable>replacement</replaceable> einfach in
		            <replaceable>string</replaceable> eingesetzt wird.</para>
		          </listitem>
		          <listitem>
		            <para>Ist eines der Argumente <constant>NULL</constant> ist, ist das Ergebnis ebenfalls
		            <constant>NULL</constant>.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>pos</replaceable> oder <replaceable>length</replaceable> keine
                            Ganzzahl ist, wird kaufmännisch gerundet, d.h. 0.5 wird 0,
		            1.5 wird 2, 2.5 wird 2, 3.5 wird 4, etc.</para>
		          </listitem>
		        </itemizedlist>
        </para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>overlay ('Goodbye' placing 'Hello' from 2)    -- ergibt 'GHelloe'
overlay ('Goodbye' placing 'Hello' from 5)    -- ergibt 'GoodHello'
overlay ('Goodbye' placing 'Hello' from 8)    -- ergibt 'GoodbyeHello'
overlay ('Goodbye' placing 'Hello' from 20)   -- ergibt 'GoodbyeHello'

overlay ('Goodbye' placing 'Hello' from 2 for 0)   -- ergibt 'GHellooodbye'
overlay ('Goodbye' placing 'Hello' from 2 for 3)   -- ergibt 'GHellobye'
overlay ('Goodbye' placing 'Hello' from 2 for 6)   -- ergibt 'GHello'
overlay ('Goodbye' placing 'Hello' from 2 for 9)   -- ergibt 'GHello'

overlay ('Goodbye' placing '' from 4)         -- ergibt 'Goodbye'
overlay ('Goodbye' placing '' from 4 for 3)   -- ergibt 'Gooe'
overlay ('Goodbye' placing '' from 4 for 20)  -- ergibt 'Goo'

overlay ('' placing 'Hello' from 4)           -- ergibt 'Hello'
overlay ('' placing 'Hello' from 4 for 0)     -- ergibt 'Hello'
overlay ('' placing 'Hello' from 4 for 20)    -- ergibt 'Hello'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Wenn in einem <database>BLOB</database> verwendet, muss die Funktion das gesamte Objekt in den Speicher laden.
                    Dies kann die Leistung beeinflussen, wenn große <database>BLOB</database>s genutzt werden.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-replace-de"><database>REPLACE()</database></link></para>
		  </formalpara>
		</section>


		<section id="fblangref25-functions-scalarfuncs-position-de">
		  <title><database>POSITION()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>
POSITION (substr IN string)
| POSITION (substr, string [, startpos])
                         </programlisting></blockquote>
                     </para>
                   </formalpara>

      <table id="fblangref25-funcs-tbl-position-de">
      <?dbfo keep-together='auto'?>
        <title>POSITION-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">substr</entry>
              <entry align="left">Der Teilstring, dessen Position gesucht werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Die Zeichenfolge, die durchsucht werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">startpos</entry>
              <entry align="left">Die Position in <replaceable>string</replaceable>, in der die Suche beginnen soll</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die (1-basierte) Position des ersten Vorkommens einer Teilzeichenfolge in einer 
                        Hostzeichenfolge zurück. Mit dem optionalen dritten Argument beginnt die Suche bei einem 
                        gegebenen Offset, wobei etwaige Übereinstimmungen unberücksichtigt bleiben, die früher in 
                        der Zeichenfolge auftreten können. Wenn keine Übereinstimmung gefunden wird, ist das Ergebnis 0.</para>
		  </formalpara>
                  <formalpara>
                    <title>Hinweise</title>
                    <para>
		        <itemizedlist>
		          <listitem>
		            <para>Das optionale Argument <database>wird nur in der zweiten Syntax (Kommasyntax) unterstützt.</database></para>
		          </listitem>
		          <listitem>
		            <para>Die leere Zeichenfolge wird als Teilzeichenfolge jeder Zeichenfolge betrachtet. Wenn
		            <replaceable>substr</replaceable> gleich '' (leerer String) ist und ist
                            <replaceable>string</replaceable> ungleich <constant>NULL</constant>, ergibt dies:</para>
		            <itemizedlist spacing="compact">
		              <listitem>
		                <para>1 wenn <replaceable>startpos</replaceable> nicht übergeben wurde;</para>
		              </listitem>
		              <listitem>
		                <para><replaceable>startpos</replaceable> wenn <replaceable>startpos</replaceable>
		                innerhalb <replaceable>string</replaceable> liegt;</para>
		              </listitem>
		              <listitem>
		                <para>0 wenn <replaceable>startpos</replaceable> hinter dem Ende von
		                <replaceable>string</replaceable> liegt.</para>
		              </listitem>
		            </itemizedlist>
		            <para><emphasis role="bold">Hinweis:</emphasis> Ein Bug in Firebird 2.1&#x2014;2.1.3 und 2.5
		            bewirken, dass <database>POSITION</database><emphasis>immer</emphasis> 1 zurückgibt, wenn
		            <replaceable>substr</replaceable> ein Leerstring ist. Dies wurde in 2.1.4 und 2.5.1 gefixt.</para>
		            <!--If startpos present, result should be startpos if inside string, and 0 if past string. CORE-3244.
		Fixed in 2.1.4, 2.5.1, 3.0-->
		          </listitem>
		          <listitem>
		            <para>Diese Funktion unterstützt Text-<database>BLOBS</database>s beliebiger Größe und
		            Zeichensatzes.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>position ('be' in 'To be or not to be')      -- ergibt 4
position ('be', 'To be or not to be')        -- ergibt 4
position ('be', 'To be or not to be', 4)     -- ergibt 4
position ('be', 'To be or not to be', 8)     -- ergibt 17
position ('be', 'To be or not to be', 18)    -- ergibt 0
position ('be' in 'Alas, poor Yorick!')      -- ergibt 0</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion 
                        möglicherweise das gesamte Objekt in den Speicher laden. Dies kann sich auf die Leistung auswirken, 
                        wenn riesige <database>BLOB</database> beteiligt sind.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-substring-de"><database>SUBSTRING</database></link>
		    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-replace-de">
		  <title><database>REPLACE()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>REPLACE (<replaceable>str</replaceable>, <replaceable>find</replaceable>, <replaceable>repl</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-replace-de">
      <?dbfo keep-together='auto'?>
        <title>REPLACE-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">str</entry>
              <entry align="left">Die Zeichenfolge, in der der Austausch stattfinden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">find</entry>
              <entry align="left">Die Zeichenfolge, nach der gesucht werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">repl</entry>
              <entry align="left">Die Ersatzzeichenfolge</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
                  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Ersetzt alle Vorkommen einer Teilzeichenfolge in einer Zeichenfolge.
		        <itemizedlist>
		          <listitem>
		            <para>Diese Funktion unterstützt Text-<database>BLOBS</database>s beliebiger Größe und
                            Zeichensatzes.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn eines der Argumente ein <database>BLOB</database> ist, ist das Ergebnis ebenfalls
                            ein <database>BLOB</database>. Andernfalls ist das Ergebnis ein
		            <database>VARCHAR(<replaceable>n</replaceable>) mit <replaceable>n</replaceable>
		            berechnet aus den Längen von <replaceable>str</replaceable>,
		            <replaceable>find</replaceable> und <replaceable>repl</replaceable> in der Form, dass
                            sogar die größtmögliche Anzahl an Ersetzungen das Feld nicht überschreiten würde.</database></para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>find</replaceable> ein leerer String ist,
		            bleibt <replaceable>str</replaceable> unverändert.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>repl</replaceable> ein Leerstring ist, werden alle Vorkommen von
		            <replaceable>find</replaceable> in
		            <replaceable>str</replaceable> entfernt.</para>
		          </listitem>
		          <listitem>
		            <para>Ist ein Argument <constant>NULL</constant>, wird das Ergebnis immer
		            <constant>NULL</constant> sein, auch wenn nichts ersetzt würde.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>replace ('Billy Wilder',  'il', 'oog')     -- ergibt 'Boogly Woogder'
replace ('Billy Wilder',  'il',    '')     -- ergibt 'Bly Wder'
replace ('Billy Wilder',  null, 'oog')     -- ergibt <constant>NULL</constant>
replace ('Billy Wilder',  'il',  null)     -- ergibt <constant>NULL</constant>
replace ('Billy Wilder', 'xyz',  null)     -- ergibt <constant>NULL</constant> (!)
replace ('Billy Wilder', 'xyz', 'abc')     -- ergibt 'Billy Wilder'
replace ('Billy Wilder',    '', 'abc')     -- ergibt 'Billy Wilder'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion 
                        möglicherweise das gesamte Objekt in den Speicher laden. Dies kann sich auf die Leistung auswirken, 
                        wenn riesige <database>BLOB</database> beteiligt sind.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link	linkend="fblangref25-functions-scalarfuncs-overlay-de"><database>OVERLAY()</database></link>,
                   <link linkend="fblangref25-functions-scalarfuncs-substring-de"><database>SUBSTRING()</database></link>,
                   <link linkend="fblangref25-functions-scalarfuncs-position-de"><database>POSITION()</database></link>,
                   <link linkend="fblangref25-functions-scalarfuncs-char_length-de"><database>CHAR[ACTER]_LENGTH()</database></link>
                    </para>
		  </formalpara>
		</section>


		<section id="fblangref25-functions-scalarfuncs-reverse-de">
		  <title><database>REVERSE()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>REVERSE (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-reverse-de">
      <?dbfo keep-together='auto'?>
        <title>REVERSE Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Kehrt eine Zeichenfolge zurück.</para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>  reverse ('spoonful')                 -- ergibt 'lufnoops'
		reverse ('Was it a cat I saw?')      -- ergibt '?was I tac a ti saW'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <tip>
		    <para>Diese Funktion ist sehr nützlich, wenn Sie Stringendungen, z.B. bei Domain-Namen oder E-Mail-Adressen:
		    <blockquote><programlisting>
create index ix_people_email on people
  computed by (reverse(email));

select * from people
  where reverse(email) starting with reverse('.br');
                    </programlisting></blockquote>
		    </para>
		  </tip>
		</section>

		<section id="fblangref25-functions-scalarfuncs-right-de">
		  <title><database>RIGHT()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RIGHT (<replaceable>string</replaceable>, <replaceable>length</replaceable>)</programlisting>
		        </blockquote>
		    </para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-right-de">
      <?dbfo keep-together='auto'?>
        <title>RIGHT-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">string</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">length</entry>
              <entry align="left">Ganze Zahl. Definiert die Anzahl der zurückzugebenden Zeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den rechten Teil der Argument-Zeichenfolge zurück. Die Anzahl der Zeichen ist im zweiten Argument angegeben.
		        <itemizedlist>
		          <listitem>
		            <para>Diese Funktion unterstützt Text <database>BLOB</database>s beliebiger Länge, aber hat einen 
                                Fehler in den Versionen 2.1 2.1.3 und 2.5, der es scheitert mit Text <database>BLOB</database>s 
                                    größer als 1024 Bytes die einen Multi-Byte-Zeichensatz haben. Dies wurde in den Versionen 2.1.4 
                                    und 2.5.1 behoben.<!--Reported as CORE-3228. Bug present in 2.1-2.1.3 and 2.5 - fixed for 2.1.4, 2.5.1, 3.0
		Notice: the limit is 1024 BYTES, not characters.--></para>
		          </listitem>
		          <listitem>
		            <para>Ist <replaceable>string</replaceable> ein <database>BLOB</database>, ist 
                            das Ergebnis ebenfalls ein <database>BLOB</database>. Andernfalls ist das Ergebnis ein
		            <database>VARCHAR(<replaceable>n</replaceable>)</database>, wobei 
		            <replaceable>n</replaceable> die Länge der Eingabezeichenfolge ist.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn das Argument <replaceable>length</replaceable> die Länge der Zeichenfolge überschreitet,
		            wird die Eingabezeichenfolge unverändert zurückgegeben.</para>
		          </listitem>
		          <listitem>
		            <para>Ist das Argument <replaceable>length</replaceable> keine Ganzzahl, wird
		            kaufmännisch gerundet, d.h. 0.5 wird 0, 1.5 wird 2, 2.5
		            wird 2, 3.5 wird 4, etc.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion 
                        möglicherweise das gesamte Objekt in den Speicher laden. Dies kann sich auf die Leistung auswirken, 
                        wenn riesige <database>BLOB</database> beteiligt sind.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-left-de"><database>LEFT()</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-substring-de"><database>SUBSTRING()</database></link>
                    </para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-rpad-de">
		  <title><database>RPAD()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Geändert in</title>
		    <para>2.5 (backported to 2.1.4)</para>
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RPAD (<replaceable>str</replaceable>, <replaceable>endlen</replaceable> [, <replaceable>padstr</replaceable>])
                        </programlisting>
                    </blockquote></para>
                  </formalpara>
      <table id="fblangref25-funcs-tbl-rpad-de">
      <?dbfo keep-together='auto'?>
        <title>RPAD-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">str</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">endlen</entry>
              <entry align="left">Länge der Ausgabezeichenfolge</entry>
            </row>
            <row valign="middle">
              <entry align="center">padstr</entry>
              <entry align="left">Das Zeichen oder die Zeichenfolge, die zum Auffüllen der Quellzeichenfolge bis zur 
                  angegebenen Länge verwendet werden soll. Standard ist Leerzeichen (' ')</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Füllt eine Zeichenfolge rechtsseitig mit Leerzeichen oder mit einer benutzerdefinierten Zeichenfolge, 
                        bis eine bestimmte Länge erreicht ist.</para>
		  </formalpara>
		        <itemizedlist>
		          <listitem>
		            <para>Diese Funktion unterstützt vollständig Text-<database>BLOB</database>s beliebiger Länge und Zeichensätze.</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>str</replaceable> ein <database>BLOB</database> ist, ist das Ergebnis
                            ebenfalls ein <database>BLOB</database>. Andernfalls ist das Ergebnis ein
		            <database>VARCHAR</database>(<replaceable>endlen</replaceable>).</para>
		          </listitem>
		          <listitem>
		            <para>Wenn <replaceable>padstr</replaceable> angegeben wurde und gleich <literal>''</literal> 
		            (Leeres Zeichen) ist, findet kein Auffüllen statt.</para>
		          </listitem>
		          <listitem>
		            <para>Ist <replaceable>endlen</replaceable> kleiner als die aktuelle Länge der Zeichenkette,
		            wird die Zeichenkette auf <replaceable>endlen</replaceable> Zeichen abgeschnitten, auch wenn
		            <replaceable>padstr</replaceable> ein leeres Zeichen ist.</para>
		          </listitem>
         	        </itemizedlist>

		  <note>
                      <para>In Firebird 2.1 2.1.3 waren alle Nicht-BLOB-Ergebnisse vom Typ <database>VARCHAR</database>(32765), 
                      was es ratsam machte, sie auf eine bescheidenere Größe zu übertragen. Dies ist nicht mehr der Fall.</para>
		    <!--CORE-1346, backported to 2.1.4
		Actually, the length was 32765 for single-byte charsets, 8191 for UTF8, etc.-->
		  </note>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion möglicherweise 
                        das gesamte Objekt in den Speicher laden. Es wird zwar versucht, den Speicherverbrauch zu begrenzen, dies kann 
                        jedoch die Leistung beeinträchtigen, wenn riesige <database>BLOB</database>s beteiligt sind.</para>
		  </warning>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <para><programlisting>  rpad ('Hello', 12)                 -- ergibt 'Hello       '
		rpad ('Hello', 12, '-')            -- ergibt 'Hello-------'
		rpad ('Hello', 12, '')             -- ergibt 'Hello'
		rpad ('Hello', 12, 'abc')          -- ergibt 'Helloabcabca'
		rpad ('Hello', 12, 'abcdefghij')   -- ergibt 'Helloabcdefg'
		rpad ('Hello', 2)                  -- ergibt 'He'
		rpad ('Hello', 2, '-')             -- ergibt 'He'
		rpad ('Hello', 2, '')              -- ergibt 'He'</programlisting></para>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion 
                        möglicherweise das gesamte Objekt in den Speicher laden. Dies kann sich auf die Leistung auswirken, 
                        wenn riesige <database>BLOB</database> beteiligt sind.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-lpad-de"><database>LPAD()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-substring-de">
		  <title><database>SUBSTRING()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Geändert in</title>
		    <para>2.5.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SUBSTRING (<replaceable>str</replaceable> FROM <replaceable>startpos</replaceable> [FOR <replaceable>length</replaceable>])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-substring-de">
      <?dbfo keep-together='auto'?>
        <title>SUBSTRING-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">str</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">startpos</entry>
              <entry align="left">Integer-Ausdruck, die Position, von der aus der Teilstring abgerufen werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">length</entry>
              <entry align="left">Die Anzahl der Zeichen, die nach &lt;startpos&gt; liegen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetypen</title>
		    <para><database>VARCHAR(<replaceable>n</replaceable>)</database> oder
		    <database>BLOB</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Die Anzahl der abzurufenden Zeichen nach dem Zurückgeben der Teilzeichenfolge einer 
                        Zeichenfolge beginnend an der angegebenen Position, entweder bis zum Ende der Zeichenfolge 
                        oder mit einer bestimmten Länge.</para>
		  </formalpara>

		  <para>Diese Funktion gibt den Teilstring zurück, der an der Zeichenposition <replaceable>startpos</replaceable> 
                      beginnt (die erste Position ist 1). Ohne das Argument <database>FOR</database> werden alle verbleibenden 
                          Zeichen in der Zeichenfolge zurückgegeben. Mit <database>FOR</database> werden 
                    <replaceable>length</replaceable> Zeichen oder der Rest der Zeichenfolge zurückgegeben, je nachdem, 
                        welcher Wert kürzer ist.</para>
		  <para>In Firebird 1.x müssen <replaceable>startpos</replaceable> und <replaceable>length</replaceable> 
                      Integer-Literale sein. In 2.0 und höher können sie beliebige gültige Integer-Ausdrücke sein.</para>
		  <para>Ab Firebird 2.1 unterstützt diese Funktion vollständig binäre und text <database>BLOB</database>s 
                      beliebiger Länge und Zeichensatz. Wenn <replaceable>str</replaceable> ein <database>BLOB</database>
                          ist, ist das Ergebnis auch ein <database>BLOB</database>. Für alle anderen Argumenttypen ist das 
                              Ergebnis eine <database>VARCHAR</database>(<replaceable>n</replaceable>). Zuvor war der 
                                  Ergebnistyp <database>CHAR</database>(<replaceable>n</replaceable>), wenn das Argument 
                                      eine <database>CHAR</database>(<replaceable>n</replaceable>) oder ein String-Literal.</para>
		  <para>Für nicht-<database>BLOB</database>-Agumente entspricht die Breite des Ergebnisfelds immer der Länge von <replaceable>str</replaceable>, 
                      unabhängig von <replaceable>startpos</replaceable> und <replaceable>length</replaceable>. Also, <code>substring ('pinhead' von 4 für 2)</code> 
                          gibt eine <database>VARCHAR (7)</database> zurück, die die Zeichenkette <literal>'he'</literal> enthält.</para>
		  <para>Ist ein Argument <constant>NULL</constant>, ist das Ergebnis
		  <constant>NULL</constant>.</para>
		  <warning>
		    <title>Bugs</title>
		    <itemizedlist>
		      <listitem>
		        <para>Wenn <replaceable>str</replaceable> ein <database>BLOB</database> ist und das <replaceable>length</replaceable> 
                            Argument nicht vorhanden ist, ist die Ausgabe auf 32767 Zeichen begrenzt. Problemumgehung: Geben Sie bei langen 
                            <database>BLOB</database> immer char_length (<replaceable>str</replaceable>) &#x2014; oder eine ausreichend 
                                hohe Ganzzahl &#x2014; als drittes Argument an, es sei denn, Sie sind sicher, dass die angeforderte Teilzeichenfolge 
                                darin passt 32767 Zeichen.</para>
		        <para>Dieser Fehler wurde in Version 2.5.1 behoben. Der Fix wurde auch nach 2.1.5 zurückportiert.<!--CORE-3245
		Indeed, it takes max 32767 CHARACTERS - the number of BYTES may be larger.
		Fixed 2 Feb 2011 by Dmitry for 2.1.5, 2.5.1, 3.0 alpha 1--></para>
		      </listitem>
		      <listitem>
		        <para>Ein älterer Fehler in Firebird 2.0, der dazu führte, dass die Funktion <quote>false emptystrings</quote>zurückgab, wenn
                            <replaceable>startpos</replaceable> oder <replaceable>length</replaceable> <constant>NULL</constant>war. wurde behoben.
                        <!--Also in later 2.0.x versions?-->
                        </para>
		      </listitem>
		    </itemizedlist>
		  </warning>
		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>insert into AbbrNames(AbbrName)
		select substring(LongName from 1 for 3) from LongNames</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion 
                        möglicherweise das gesamte Objekt in den Speicher laden. Dies kann sich auf die Leistung auswirken, 
                        wenn riesige <database>BLOB</database> beteiligt sind.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-position-de"><database>POSITION</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-left-de"><database>LEFT</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-right-de"><database>RIGHT</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-char_length-de"><database>CHAR[ACTER]_LENGTH</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-trim-de">
		  <title><database>TRIM()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>
TRIM ([&lt;adjust&gt;] str)

&lt;adjust&gt; ::=  {[&lt;where&gt;] [what]} FROM

&lt;where&gt; ::=  BOTH | LEADING | TRAILING
		      </programlisting></blockquote>
                    </para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-trim-de">
      <?dbfo keep-together='auto'?>
        <title>TRIM-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">str</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">where</entry>
              <entry align="left">Die Position, von der der Teilstring entfernt werden soll&#x2014;BOTH | LEADING | TRAILING.
              BOTH ist der Standard</entry>
            </row>
            <row valign="middle">
              <entry align="center">what</entry>
              <entry align="left">Der Teilstring, der entfernt werden soll (mehrfach, wenn mehrere Übereinstimmungen vorkommen)
                  vom Anfang | dem Ende | beider Seiten des Eingabestrings &lt;str&gt;. Standard ist das Leerzeichen (' ')</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>VARCHAR(<replaceable>n</replaceable>)</database> or
		    <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Entfernt führende und / oder nachgestellte Leerzeichen (oder optional andere Zeichenfolgen) 
                        aus der Eingabezeichenfolge. Seit Firebird 2.1 unterstützt diese Funktion vollständig Text 
                        <database>BLOB</database>s beliebiger Länge und Zeichensatzes.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select trim ('  Waste no space   ') from rdb$database
		-- ergibt 'Waste no space'</programlisting>
		        <programlisting>select trim (leading from '  Waste no space   ') from rdb$database
		-- ergibt 'Waste no space   '</programlisting>
		        <programlisting>select trim (leading '.' from '  Waste no space   ') from rdb$database
		-- ergibt '  Waste no space   '</programlisting>
		        <programlisting>select trim (trailing '!' from 'Help!!!!') from rdb$database
		-- ergibt 'Help'</programlisting>
		        <programlisting>select trim ('la' from 'lalala I love you Ella') from rdb$database
		-- ergibt ' I love you El'</programlisting>
		        <programlisting>select trim ('la' from 'Lalala I love you Ella') from rdb$database
		-- ergibt 'Lalala I love you El'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Hinweise</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>Wenn <replaceable>str</replaceable> ein <database>BLOB</database> ist, ist das Ergebnis ein
		          <database>BLOB</database>. Andernfalls ist das Ergebnis ein
		          <database>VARCHAR</database>(<replaceable>n</replaceable>) mit der formalen Länge
		          <replaceable>n</replaceable> des Strings
		          <replaceable>str</replaceable>.</para>
		        </listitem>
		        <listitem>
		          <para>Die zu entfernende Teilzeichenfolge darf, falls angegeben, nicht größer als 32767 Byte sein. 
                              Wenn diese Teilzeichenfolge jedoch <emphasis>wiederholt</emphasis> an der Kopf- oder Endstelle 
                              von <replaceable>str</replaceable> ist, kann die Gesamtzahl der entfernten Byte viel größer sein. 
                              (Die Einschränkung der Größe des Teilstrings wird in Firebird 3 aufgehoben.)<!--CORE-3234: Lifting of this restriction requested. Fixed by Adriano for 3.0 alpha 1.--></para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <warning>
		    <para>Wenn diese Funktion in einem <database>BLOB</database> verwendet wird, muss diese Funktion 
                        möglicherweise das gesamte Objekt in den Speicher laden. Dies kann sich auf die Leistung auswirken, 
                        wenn riesige <database>BLOB</database> beteiligt sind.</para>
		  </warning>
		</section>

		<section id="fblangref25-functions-scalarfuncs-upper-de">
		  <title><database>UPPER()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>UPPER (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-upper-de">
      <?dbfo keep-together='auto'?>
        <title>UPPER Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">str</entry>
              <entry align="left">Ein Ausdruck eines Zeichenfolgetyps</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>(VAR)CHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das Großbuchstabenäquivalent der Eingabezeichenfolge zurück. Das genaue Ergebnis hängt vom Zeichensatz ab. 
                        Bei <database>ASCII</database> oder <database>NONE</database> zum Beispiel sind nur ASCII-Zeichen größer; 
                        mit <database>OCTETS</database> wird die gesamte Zeichenfolge unverändert zurückgegeben. Seit Firebird 2.1 
                        unterstützt diese Funktion auch vollständig Text-<database>BLOB</database>s beliebiger Länge und Zeichensatzes.</para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select upper(_iso8859_1 'Débâcle')
		from rdb$database
		-- ergibt 'DÉBÂCLE' (before Firebird 2.0: 'DéBâCLE')</programlisting>
		        <programlisting>select upper(_iso8859_1 'Débâcle' collate fr_fr)
		from rdb$database
		-- ergibt 'DEBACLE', following French uppercasing rules</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-functions-scalarfuncs-lower-de"><database>LOWER</database></link></para>
		  </formalpara>
		</section>
  </section> <!-- Functions for Working with Strings -->

<!-- **************************************************************************************
                   D A T E   A N D   T I M E   F U N C T I O N S
    ************************************************************************************** -->
  <section id="fblangref25-functions-datetime-de">
    <title>Date and Time Functions</title>

		<section id="fblangref25-functions-scalarfuncs-dateadd-de">
		  <title><database>DATEADD()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Geändert in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>DATEADD (<replaceable>&lt;args&gt;</replaceable>)

		<replaceable>&lt;args&gt;</replaceable>      ::=  <replaceable>&lt;amount&gt;</replaceable> <replaceable>&lt;unit&gt;</replaceable> TO <replaceable>&lt;datetime&gt;</replaceable>
		             | <replaceable>&lt;unit&gt;</replaceable>, <replaceable>&lt;amount&gt;</replaceable>, <replaceable>&lt;datetime&gt;</replaceable>

		<replaceable>&lt;amount&gt;</replaceable>    ::=  an integer expression (negative to subtract)
		<replaceable>&lt;unit&gt;</replaceable>      ::=  YEAR | MONTH | WEEK | DAY
		               | HOUR | MINUTE | SECOND | MILLISECOND
		<replaceable>&lt;datetime&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-dateadd-de">
      <?dbfo keep-together='auto'?>
        <title>DATEADD-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">amount</entry>
              <entry align="left">Ein ganzzahliger Ausdruck vom Typ SMALLINT, INTEGER oder BIGINT. Ein negativer Wert wird subtrahiert</entry>
            </row>
            <row valign="middle">
              <entry align="center">unit</entry>
              <entry align="left">Datums-/Zeit-Einheit</entry>
            </row>
            <row valign="middle">
              <entry align="center">datetime</entry>
              <entry align="left">Ein Ausdruck der Typen DATE, TIME oder TIMESTAMP</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
                  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>DATE</database>, <database>TIME</database> oder
		    <database>TIMESTAMP</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Fügt einem Datum / Uhrzeit-Wert die angegebene Anzahl von Jahren, Monaten, Wochen, Tagen, Stunden, Minuten, Sekunden 
                        oder Millisekunden hinzu. (Die <database>WEEK</database>-Einheit ist neu in 2.5.)
		        <itemizedlist>
		          <listitem>
		            <para>Der Ergebnistyp wird durch das dritte Argument bestimmt.</para>
		          </listitem>
		          <listitem>
		            <para>Mit <database>TIMESTAMP</database> und <database>DATE</database>-Argumenten können alle
                            Einheiten verwendet werden. (Vor Firebird 2.5 waren Einheiten kleiner als
		            <database>DAY</database> nicht erlaubt für <database>DATE</database> s.)</para>
		          </listitem>
		          <listitem>
		            <para>Mit <database>TIME</database>-Argumenten können nur <database>HOUR</database>,
		            <database>MINUTE</database>, <database>SECOND</database> und
		            <database>MILLISECOND</database> genutzt werden.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>  dateadd (28 day to current_date)
		dateadd (-6 hour to current_time)
		dateadd (month, 9, DateOfConception)
		dateadd (-38 week to DateOfBirth)
		dateadd (minute, 90, time 'now')
		dateadd (? year to date '11-Sep-1973')</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-datediff-de"><database>DATEDIFF</database></link>, 
                    <link linkend="fblangref25-datatypes-datetimeops-de"><database>Operationen, die Datums- und Zeitfunktionen verwenden</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-datediff-de">
		  <title><database>DATEDIFF()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Geändert in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>DATEDIFF (<replaceable>&lt;args&gt;</replaceable>)

		<replaceable>&lt;args&gt;</replaceable>     ::=  <replaceable>&lt;unit&gt;</replaceable> FROM <replaceable>&lt;moment1&gt;</replaceable> TO <replaceable>&lt;moment2&gt;</replaceable>
		            | <replaceable>&lt;unit&gt;</replaceable>, <replaceable>&lt;moment1&gt;</replaceable>, <replaceable>&lt;moment2&gt;</replaceable>

		<replaceable>&lt;unit&gt;</replaceable>     ::=  YEAR | MONTH | WEEK | DAY
		              | HOUR | MINUTE | SECOND | MILLISECOND
		<replaceable>&lt;momentN&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression
                        </programlisting>
                    </blockquote></para>
                  </formalpara>
      <table id="fblangref25-funcs-tbl-datediff-de">
      <?dbfo keep-together='auto'?>
        <title>DATEDIFF-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">unit</entry>
              <entry align="left">Date/time unit</entry>
            </row>
            <row valign="middle">
              <entry align="center">moment1</entry>
              <entry align="left">Ein Ausdruck eines DATE-, TIME- oder TIMESTAMP-Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">moment2</entry>
              <entry align="left">Ein Ausdruck eines DATE-, TIME- oder TIMESTAMP-Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt die Anzahl der Jahre, Monate, Wochen, Tage, Stunden, Minuten, Sekunden oder Millisekunden zurück, die zwischen zwei 
                        Datums- / Uhrzeitwerten vergangen sind. (Die <database>WEEK</database>-Einheit ist neu in 2.5.)
		        <itemizedlist>
		          <listitem>
		            <para><database>DATE</database>- und <database>TIMESTAMP</database>-Argumente können kombiniert werden.
                            Andere Kombinationen sind nicht erlaubt.</para>
		          </listitem>
		          <listitem>
		            <para>Mit <database>TIMESTAMP</database> und <database>DATE</database>-Argumenten können alle
                            Einheiten verwendet werden. (Vor Firebird 2.5 waren Einheiten kleiner als
		            <database>DAY</database> nicht erlaubt für <database>DATE</database> s.)</para>
		          </listitem>
		          <listitem>
		            <para>Mit <database>TIME</database>-Argumenten können nur <database>HOUR</database>,
		            <database>MINUTE</database>, <database>SECOND</database> und
		            <database>MILLISECOND</database> genutzt werden.</para>
		          </listitem>
		        </itemizedlist>
		      </para>
		  </formalpara>
		  <formalpara>
		    <title>Berechnung</title>
		    <para><itemizedlist>
		        <listitem>
		          <para><database>DATEDIFF</database> betrachtet keine kleineren Einheiten als die, 
                          die im ersten Argument angegeben wurden. Als Ergebnis,</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><quote><code>datediff (year, date '1-Jan-2009', date
		              '31-Dec-2009')</code></quote> ergibt 0, jedoch</para>
		            </listitem>
		            <listitem>
		              <para><quote><code>datediff (year, date '31-Dec-2009', date
		              '1-Jan-2010')</code></quote> ergibt 1</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		        <listitem>
		          <para>Es sieht jedoch alle <emphasis>größeren</emphasis> Einheiten. Somit gilt:</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><quote><code>datediff (day, date '26-Jun-1908', date
		              '11-Sep-1973')</code></quote> ergibt 23818</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		        <listitem>
		          <para>Ein negatives Ergebnis gibt an, dass <replaceable>moment2</replaceable> vor
		          <replaceable>moment1</replaceable> liegt.</para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>  datediff (hour from current_timestamp to timestamp '12-Jun-2059 06:00')
		datediff (minute from time '0:00' to current_time)
		datediff (month, current_date, date '1-1-1900')
		datediff (day from current_date to cast(? as date))</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-dateadd-de"><database>DATEADD</database></link>,
                    <link linkend="fblangref25-datatypes-datetimeops-de"><database>Operations Using Date and Time Values</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-extract-de">
		  <title><database>EXTRACT()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

		<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | WEEK
		               | DAY | WEEKDAY | YEARDAY
		               | HOUR | MINUTE | SECOND | MILLISECOND
		<replaceable>&lt;datetime&gt;</replaceable>  ::=  ein DATE-, TIME- oder TIMESTAMP-Ausdruck</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-extract-de">
      <?dbfo keep-together='auto'?>
        <title>EXTRACT-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">part</entry>
              <entry align="left">Datums- / Zeit-Einheit</entry>
            </row>
            <row valign="middle">
              <entry align="center">datetime</entry>
              <entry align="left">Ein Ausdruck des DATE-, TIME- oder TIMESTAMP-Typs</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
	    <formalpara>
	      <title>Rückgabetyp</title>
              <para><database>SMALLINT</database> oder <database>NUMERIC</database><!--or DECIMAL?--></para>
	    </formalpara>

	    <formalpara>
	      <title>Beschreibung</title>
              <para>Extrahiert und gibt ein Element aus einem Ausdruck <database>DATE</database>, 
                <database>TIME</database> oder <database>TIMESTAMP</database> zurück. Diese Funktion 
                    wurde bereits in InterBase 6 hinzugefügt, aber zu diesem Zeitpunkt nicht in der 
                    <citetitle>Sprachreferenz</citetitle> dokumentiert.</para>
	    </formalpara>

            <section id="fblangref25-functions-scalarfuncs-extract-types-de">
              <title>Zurückgegebene Datentypen und Bereiche</title>
              <para>Die zurückgegebenen Datentypen und möglichen Bereiche sind in der folgenden Tabelle aufgeführt. 
                  Wenn Sie versuchen, einen Teil zu extrahieren, der nicht im Argument Datum / Uhrzeit enthalten ist 
                  (z. B. <database>SECOND</database> aus einem <database>DATE</database>- oder 
                  <database>YEAR</database> aus einem <database>TIME</database>-Feld), tritt ein Fehler auf.</para>
		  <table id="fblangref25-tbl-extractranges-de">
		    <title>Typen und Bereiche der <database>EXTRACT</database>-Ergebnisse</title>
                   <?dbfo keep-together='auto'?>
		    <tgroup cols="4">
		      <thead>
		        <row>
		          <entry>Part</entry>
		          <entry>Type</entry>
		          <entry>Bereich</entry>
		          <entry>Beschreibung</entry>
		        </row>
		      </thead>
		      <tbody>
		        <row>
		          <entry><database>YEAR</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1&#x2014;9999</entry>
		          <entry>&nbsp;</entry>
		        </row>
		        <row>
		          <entry><database>MONTH</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1&#x2014;12</entry>
		          <entry>&nbsp;</entry>
		        </row>
		        <row>
		          <entry><database>WEEK</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1&#x2014;53</entry>
		          <entry>&nbsp;</entry>
		        </row>
		        <row>
		          <entry><database>DAY</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1&#x2014;31</entry>
		          <entry>&nbsp;</entry>
		        </row>
		        <row>
		          <entry><database>WEEKDAY</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0&#x2014;6</entry>
		          <entry>0 = Sonntag</entry>
		        </row>
		        <row>
		          <entry><database>YEARDAY</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0&#x2014;365</entry>
		          <entry>0 = 1. Januar</entry>
		        </row>
		        <row>
		          <entry><database>HOUR</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0&#x2014;23</entry>
		          <entry>&nbsp;</entry>
		        </row>
		        <row>
		          <entry><database>MINUTE</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0&#x2014;59</entry>
		          <entry>&nbsp;</entry>
		        </row>
		        <row>
		          <entry><database>SECOND</database></entry>
		          <entry><database>NUMERIC(9,4)</database></entry>
		          <entry>0.0000&#x2014;59.9999</entry>
		          <entry>enthält Millisekunde als Bruchteil</entry>
		        </row>
		        <row>
		          <entry><database>MILLISECOND</database></entry>
		          <entry><database>NUMERIC(9,1)</database></entry>
		          <entry>0.0&#x2014;999.9</entry>
		          <entry>defekt in 2.1, 2.1.1</entry>
		        </row>
		      </tbody>
		    </tgroup>
		  </table>

		</section> <!-- returned data types and ranges -->
		<section id="fblangref25-functions-scalarfuncs-extract-millisecond-de">
		    <title><database>MILLISECOND</database></title>
		    <formalpara>
		      <title>Beschreibung</title>
		      <para>Firebird 2.1 und höher unterstützen die Extraktion der Millisekunde aus
		      <database>TIME</database> oder <database>TIMESTAMP</database>. Der zurückgegebene Datentyp ist
		      <database>NUMERIC(9,1)</database>.</para>
		    </formalpara>
		    <note>
		      <para>Wenn Sie Millisekunden aus <link
		      linkend="fblangref25-contextvars-current_time-de"><database>CURRENT_TIME</database></link> extrahieren, 
                      beachten Sie, dass diese Variable starndardmäßig auf volle Sekunden auflöst, womit das Ergebnis
                      immer 0 ist. Nutzen Sie <database>CURRENT_TIME(3)</database> oder <link
		      linkend="fblangref25-contextvars-current_timestamp-de"><database>CURRENT_TIMESTAMP</database></link> um 
                      Millisekundengenauigkeit zu erhalten.</para>
		    </note>
		</section>
		<section id="fblangref25-functions-scalarfuncs-extract-week-de">
		    <title><database>WEEK</database></title>
		    <formalpara>
		      <title>Beschreibung</title>
		      <para>Firebird 2.1 und höher unterstützen die Extraktion der ISO-8601-Wochennummer aus 
                          <database>DATUM</database> oder <database>TIMESTAMP</database>. 
                              ISO-8601 Wochen beginnen an einem Montag und haben immer die vollen sieben 
                              Tage. Woche 1 ist die erste Woche, die eine Mehrheit (mindestens 4) ihrer Tage
                              im neuen Jahr hat. Die ersten 1&#x2014;3 Tage des Jahres können zur letzten
                              Woche (52 oder 53) des vorhergehenden Jahres gehören. Ebenso kann ein Jahr, das 
                              letzte 1&#x2014;3 Tage, zur Woche 1 des folgenden Jahres gehören.</para>
		    </formalpara>
		    <caution>
		      <para>Seien Sie vorsichtig, wenn Sie die Ergebnisse <database>WEEK</database> und 
                            <database>YEAR</database> kombinieren. Zum Beispiel liegt der 30. Dezember 2008 
                                in Woche 1 von 2009, also <quote><code>extract (Woche vom Datum '30 Dec 2008 ')</code></quote> 
                                gibt 1 zurück. Extrahiert jedoch <database>YEAR</database> gibt immer das Kalenderjahr an,
                                welches 2008 ist. In diesem Fall stehen <database>WEEK</database> und <database>YEAR</database>
                                im Widerspruch zueinander. Das Gleiche passiert, wenn die ersten Januartage zur letzten 
                                Woche des Vorjahres gehören.</para>
		      <para>Beachten Sie außerdem, dass <database>WEEKDAY</database> <emphasis>nicht</emphasis> 
                          ISO-8601-kompatibel ist: Es gibt 0 für Sonntag zurück, während ISO-8601 7 angibt.</para>
		    </caution>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-datatypes-datetime-de">Datentypen für Datum und Zeit</link>
        </para>
      </formalpara>
    </section>
              </section> <!-- EXTRACT -->

  </section> <!-- date and time functions -->

<!-- **************************************************************************************
                T Y P E   C A S T I N G   F U N C T I O N S
    ************************************************************************************** -->
  <section id="fblangref25-functions-casting-de">
    <title>Funktionen zur Typumwandlung</title>

		<section id="fblangref25-functions-scalarfuncs-cast-de">
		  <title><database>CAST()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Geändert in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CAST (<replaceable>expression</replaceable> AS <replaceable>&lt;target_type&gt;</replaceable>)

		<replaceable>&lt;target_type&gt;</replaceable>  ::=  <replaceable>sql_datatype</replaceable>
		                | [TYPE OF] <replaceable>domain</replaceable>
		                | TYPE OF COLUMN <replaceable>relname</replaceable>.<replaceable>colname</replaceable></programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-cast-de">
      <?dbfo keep-together='auto'?>
        <title>CAST-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">SQL-Ausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL-Datentyp</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">&nbsp;</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Spaltenname eine Tabelle oder View</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Genauigkeit. Von 1 bis 18</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Skalierung (Nachkommastellen). Von 0 bis 18&#x2014;muss kleiner oder 
                  gleich der Präzision sein</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Die maximale Größe einer Zeichenfolge in Zeichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Zeichensatz</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">Mnemotechnischer Name des BLOB-Untertyps</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segmentgröße&#x2014;diese kann nicht größer als 65.535 sein</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Benutzerdefiiert.</para>
		  </formalpara>

		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>CAST</database> konvertiert einen Ausdruck in den gewünschten Datentyp 
                    oder die gewünschte Domain. Wenn die Konvertierung nicht möglich ist, wird ein Fehler 
                    ausgelöst.</para>
		  </formalpara>


		  <section id="fblangref25-functions-scalarfuncs-shortcast-de">
		    <title>Syntax der <quote>Kurzschreibweise</quote></title>
		        <para>Alternative Syntax, die nur unterstützt wird, wenn ein Zeichenfolgenliteral an
		        <database>DATE</database>, <database>TIME</database> oder
		        <database>TIMESTAMP</database> übergeben wird:</para>
		        <programlisting><replaceable>datatype</replaceable> <replaceable>'date/timestring'</replaceable></programlisting>
		        <para>Diese Syntax war bereits in InterBase verfügbar, wurde aber nie richtig dokumentiert.
		          <note>
		            <para>Die Kurzsyntax wird sofort zur Analysezeit ausgewertet, wodurch der Wert gleich bleibt, bis die Anweisung 
                                unvorbereitet ist. Für Datetime-Literale wie <literal>'12-Oktober-2012'</literal> macht dies keinen Unterschied. Für die 
                                Pseudovariablen <database>'NOW'</database>, <database>'YESTERDAY'</database>, <database>'TODAY'</database> 
                                und <database>'TOMORROW'</database> mag dies nich das gewünschte Verhalten sein. Wenn Sie bei jedem Aufruf den Wert benötigen, 
                                der ausgewertet werden soll, verwenden Sie die vollständige <database>CAST ()</database> -Syntax.</para>
                          </note>
                        </para>
		  </section>

		  <section>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <para>Ein Voll-Syntax-Cast:</para>
		        <programlisting>select cast ('12' || '-June-' || '1959' as date) from rdb$database</programlisting>
		        <para>Ein String-zu-Datum-Cast in Kurzschreibweise:</para>
		        <programlisting>update People set AgeCat = 'Old'
		where BirthDate &lt; date '1-Jan-1943'</programlisting>
		        <para>Beachten Sie, dass Sie auch die Kurzschrift aus dem obigen Beispiel löschen können, da die Engine aus dem Kontext 
                            (Vergleich mit einem Feld <database>DATE</database>) versteht, wie die Zeichenfolge zu interpretieren ist:</para>
		        <programlisting>update People set AgeCat = 'Old'
		where BirthDate &lt; '1-Jan-1943'</programlisting>
		        <para>Aber das ist nicht immer möglich. Die folgende Darstellungsart kann nicht aufgelöst werden, da die Engine 
                            sonst eine Ganzzahl findet, die von einer Zeichenfolge abgezogen wird:</para>
		        <programlisting>select date 'today' - 7 from rdb$database</programlisting>
		      </blockquote></para>
		  
		  <para>Die folgende Tabelle zeigt die möglichen Typkonvertierungen mit
		  <database>CAST</database>.</para>
		  <table id="fblangref25-tbl-cast-de">
		  <?dbfo keep-together='auto'?>
		    <title>Mögliche Typkonvertierungen mit <database>CAST</database></title>
		    <tgroup cols="2">
		      <colspec colname="colFromType" />
		      <colspec colname="colToType" />
		      <thead>
		        <row valign="top">
		          <entry>Von</entry>
		          <entry>Zu</entry>
		        </row>
		      </thead>
		      <tbody>
		        <row valign="top">
		          <entry><simplelist>
		              <member>Numerische Typen</member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member>Numerische Typen</member>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		            </simplelist></entry>
		        </row>
		        <row valign="top">
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		              <member>Numerische Typen</member>
		              <member><database>DATE</database></member>
		              <member><database>TIME</database></member>
		              <member><database>TIMESTAMP</database></member>
		            </simplelist></entry>
		        </row>
		        <row valign="top">
		          <entry><simplelist>
		              <member><database>DATE</database></member>
		              <member><database>TIME</database></member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		              <member><database>TIMESTAMP</database></member>
		            </simplelist></entry>
		        </row>
		        <row valign="top">
		          <entry><simplelist>
		              <member><database>TIMESTAMP</database></member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		              <member><database>DATE</database></member>
		              <member><database>TIME</database></member>
		            </simplelist></entry>
		        </row>
		      </tbody>
		    </tgroup>
		  </table>
		  <para>Beachten Sie, dass Informationen unter Umständen verloren gehen, z.B. wenn Sie eine Typkonvertierung
                      von <database>TIMESTAMP</database> zu <database>DATE</database> durchführen. Die Tatsache, dass die Typen
		  <database>CAST</database>-kompatibel sind, ist keine Garantie, dass die Umwandlung erfolgreich sein wird.
		  <quote><database>CAST</database>(123456789 as <database>SMALLINT</database>)</quote> wird in jedem
                  Falle in einem Fehler enden, genauso wie <quote><database>CAST</database>('Judgement Day' as
		  <database>DATE</database>)</quote>.</para>
		  <formalpara>
		    <title>Umwandlung von Eingabefeldern</title>
		    <para>Seit Firebird 2.0 können Sie Anweisungsparameter in einen Datentyp umwandeln:</para>
		  </formalpara>
		  <blockquote>
		    <programlisting>cast (? as integer)</programlisting>
		  </blockquote>
		  <para>Dies gibt Ihnen die Kontrolle über den Typ des von der Engine eingerichteten Eingabefeldes. Bitte beachten 
                      Sie, dass Sie bei Anweisungsparametern immer einen Vollsyntax Cast &#x2014; benötigen; Kurzformen 
                      werden nicht unterstützt.</para>
		  <formalpara>
		    <title>Umwandlung zu einer Domain oder dessen Typ</title>
		    <para>Firebird 2.1 und später unterstützen die Umwandlung zu einer Domain oder dessen Basistypen.
                        Bei der Umwandlung zur Domain müssen Constraints (<database>NOT NULL</database> und / oder <database>CHECK</database>),
                        die auf dieser basieren weiterhin die Bedingungen erfüllen, da die Umwandlung sonst fehlschlägt.
		    <database>CHECK</database> ist erfüllt, wenn es zu <constant>TRUE</constant>
		    <emphasis>oder</emphasis> <constant>NULL</constant> ausgewertet wird! Folgene Statements seien gegeben:</para>
		  </formalpara>
		  <blockquote>
		    <programlisting>create domain quint as int check (value &gt;= 5000)
select cast (2000 as quint) from rdb$database     -- (1)
select cast (8000 as quint) from rdb$database     -- (2)
select cast (null as quint) from rdb$database     -- (3)</programlisting>
		  </blockquote>
		  <para>Nur die erste Umwandlung (1) schlägt fehl.</para>
		  <para>Wenn der Modifikator <database>TYPE OF</database> verwendet wird, wird der Ausdruck in den Basistyp der 
                      Domäne umgewandelt, wobei alle Einschränkungen ignoriert werden. Mit der wie oben definierten Domäne <type>quint</type>
                      sind die folgenden beiden Umwandlungen äquivalent und beide werden erfolgreich sein:</para>
		  <blockquote>
		    <programlisting>select cast (2000 as type of quint) from rdb$database
		select cast (2000 as int) from rdb$database</programlisting>
		  </blockquote>
		  <para>Wenn <database>TYPE OF</database> mit einem
		  (<database>VAR</database>)<database>CHAR</database> verwendet wird, werden der Zeichensatz und die 
                  Collation beibehalten:</para>
		  <blockquote>
		    <programlisting>create domain iso20 varchar(20) character set iso8859_1;
create domain dunl20 varchar(20) character set iso8859_1 collate du_nl;
create table zinnen (zin varchar(20));
commit;
insert into zinnen values ('Deze');
insert into zinnen values ('Die');
insert into zinnen values ('die');
insert into zinnen values ('deze');

select cast(zin as type of iso20) from zinnen order by 1;
-- ergibt Deze -&gt; Die -&gt; deze -&gt; die

select cast(zin as type of dunl20) from zinnen order by 1;
-- ergibt deze -&gt; Deze -&gt; die -&gt; Die</programlisting>
		  </blockquote>
		  <warning>
		    <para>Wird die Definition einer Domain geändert, werden existierende <database>CAST</database>s 
                    auf diese Domain oder dessen Typ ungültig. Treten diese <database>CAST</database>s in PSQL-Modulen auf,
                    kann ihre Ungültigkeit entdeckt werden. Siehe auch <link
		    linkend="fblangref25-appx01-supp-rdb_validblr-de"><citetitle>Das <database>RDB$VALID_BLR</database>-Feld
		    </citetitle></link> in Anhang A.</para>
		  </warning>
		  <formalpara>
		    <title>Umwandlung zu einem Spaltentyp</title>
		    <para>In Firebird 2.5 und höher ist es möglich, Ausdrücke in den Typ einer vorhandenen Tabellen- oder 
                        Ansichtsspalte umzuwandeln. Nur der Typ selbst wird verwendet; Bei String-Typen umfasst dies den 
                        Zeichensatz, nicht aber die Sortierung. Constraints und Standardwerte der Quellspalte werden nicht 
                        angewendet.</para>
		  </formalpara>
		  <blockquote>
		    <programlisting>create table ttt (
s varchar(40) character set utf8 collate unicode_ci_ai
);
commit;

select cast ('Jag har många vänner' as type of column ttt.s) from rdb$database;</programlisting>
		  </blockquote>
		  <warning>
		    <title>Warnungen</title>
		    <itemizedlist>
		      <listitem>
		        <para>Bei Texttypen werden Zeichensatz und Sortierung durch den Cast beibehalten&#x2014;genau wie beim Casting 
                            einer Domain. Aufgrund eines Fehlers wird die Collation jedoch nicht immer berücksichtigt, wenn 
                            Vergleiche (z. B. Gleichheitsprüfungen) durchgeführt werden. In Fällen, in denen die Sortierung von Bedeutung ist, 
                            sollten Sie Ihren Code vor der Bereitstellung gründlich testen. Dieser Fehler wurde für Firebird 3 behoben.</para>
		        <!--More specific: If the column has a direct type, comparisons igmore the collation even though output column
		descriptions do include the collation. If the column has a domain type, comparisons function correctly.-->
		      </listitem>
		      <listitem>
		        <para>Wenn die Definition einer Spalte geändert wird, werden existierende <database>CAST</database>s 
                        zu diesem Spaltentyp ungültig. Treten diese <database>CAST</database>s PSQL-Modulen auf,
                        können diese Ungültigkeiten erkannt werden. Siehe auch <link
		        linkend="fblangref25-appx01-supp-rdb_validblr-de"><citetitle>Das
		        <database>RDB$VALID_BLR</database>-Feld</citetitle></link> in Anhang A.</para>
		      </listitem>
		    </itemizedlist>
		  </warning>
		  <formalpara>
		    <title>Umwandlung von <database>BLOB</database> s</title>
		    <para>Erfolgreiche Umwandlungen von und zu <database>BLOB</database>s werden seit Firebird 2.1
                    unterstützt.</para>
		  </formalpara>
      </section>
		</section>
  </section> <!-- casting functions -->

<!-- **************************************************************************************
           F U N C T I O N S   F O R   B I T W I S E   O P E R A T I O N S
    ************************************************************************************** -->

  <section id="fblangref25-functions-bitwise-de">
    <title>Funktionen für Bitweise Operationen</title>

		<section id="fblangref25-functions-scalarfuncs-bin_and-de">
		  <title><database>BIN_AND()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_AND (<replaceable>number</replaceable>, <replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-binand-de">
      <?dbfo keep-together='auto'?>
        <title>BIN_AND-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Beliebiger Ganzzahlwert (Literal, smallint/integer/bigint, numeric/decimal mit Skalierung von 0)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>SMALLINT</database>, <database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <note>
		    <para>Das SMALLINT-Ergebnis wird nur zurückgegeben, wenn alle Argumente explizit SMALLINTs oder NUMERIC(n, 0) 
                        mit n &lt; = 4; ansonsten geben kleine Ganzzahlen ein INTEGER-Ergebnis zurück.</para>
		  </note>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das Ergebnis der bitweisen UND-Operation für das Argument (die Argumente) zurück.</para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-bin_or-de"><database>BIN_OR</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-bin_xor-de"><database>BIN_XOR</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-bin_not-de">
		  <title><database>BIN_NOT()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;NEIN</para>
                  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_NOT (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>

      <table id="fblangref25-funcs-tbl-binnot-de">
      <?dbfo keep-together='auto'?>
        <title>BIN_NOT Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Beliebige Ganzzahl (Literal, smallint/integer/bigint, numeric/decimal mit der Skalierung von 0)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>SMALLINT</database>, <database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <note>
		    <para>Das SMALLINT-Ergebnis wird nur zurückgegeben, wenn alle Argumente explizit SMALLINTs oder NUMERIC(n, 0) 
                        mit n &lt; = 4; ansonsten geben kleine Ganzzahlen ein INTEGER-Ergebnis zurück.</para>
		  </note>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Returns the result of the bitwise NOT operation on the argument, i.e., 
                    <firstterm>ones complement</firstterm>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-bin_or-de"><database>BIN_OR</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-bin_xor-de"><database>BIN_XOR</database></link> and
                    others in this set.</para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-bin_or-de">
		  <title><database>BIN_OR()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_OR (<replaceable>number</replaceable>, <replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-binor-de">
      <?dbfo keep-together='auto'?>
        <title>BIN_OR-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Beliebige Ganzzahl (Literal, smallint/integer/bigint, numeric/decimal mit der Skalierung von 0)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>SMALLINT</database>, <database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <note>
		    <para>Das SMALLINT-Ergebnis wird nur zurückgegeben, wenn alle Argumente explizit SMALLINTs oder NUMERIC(n, 0) 
                        mit n &lt; = 4; ansonsten geben kleine Ganzzahlen ein INTEGER-Ergebnis zurück.</para>
		  </note>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das Ergebnis der bitweisen ODER-Operation für das Argument (die Argumente) zurück.</para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-bin_and-de"><database>BIN_AND</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-bin_xor-de"><database>BIN_XOR</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-bin_shl-de">
		  <title><database>BIN_SHL()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_SHL (<replaceable>number</replaceable>, <replaceable>shift</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-binshl-de">
      <?dbfo keep-together='auto'?>
        <title>BIN_SHL-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Die Zahl eines Integer-Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">shift</entry>
              <entry align="left">Die Anzahl der Bits, um die der Zahlenwert verschoben wird</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Returns the first argument bitwise left-shifted by the second argument, i.e.
		    <replaceable>a</replaceable> &lt;&lt; <replaceable>b</replaceable> or
		    <replaceable>a</replaceable>·2^<replaceable>b</replaceable>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-bin_shr-de"><database>BIN_SHR</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-bin_shr-de">
		  <title><database>BIN_SHR()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_SHR (<replaceable>number</replaceable>, <replaceable>shift</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-binshr-de">
      <?dbfo keep-together='auto'?>
        <title>BIN_SHR-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Die Zahl eines Integer-Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">shift</entry>
              <entry align="left">Die Anzahl der Bits, um die der Zahlenwert verschoben wird</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das erste Argument bitweise nach rechts verschoben durch das zweite Argument zurück, d.h.
		    <replaceable>a</replaceable> &gt;&gt; <replaceable>b</replaceable> oder
		    <replaceable>a</replaceable>/2^<replaceable>b</replaceable>.
		        <itemizedlist>
		          <listitem>
		            <para>Die durchgeführte Operation ist eine arithmetische Rechtsverschiebung (SAR), was bedeutet, 
                                dass das Vorzeichen des ersten Operanden immer erhalten bleibt.</para>
		          </listitem>
		        </itemizedlist>
                    </para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-bin_shl-de"><database>BIN_SHL</database></link>
                    </para>
                  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-bin_xor-de">
		  <title><database>BIN_XOR()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
                  <formalpara>
                    <title>Möglicher Namenskonflikt</title>
                    <para>&nbsp;JA&#x2014;<link linkend="fblangref25-functions-nameclashes-de">&gt;siehe Details</link>
                    </para>
                  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_XOR (<replaceable>number</replaceable>, <replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-binxor-de">
      <?dbfo keep-together='auto'?>
        <title>BIN_XOR-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Beliebige Ganzzahl (Literal, smallint/integer/bigint, numeric/decimal mit der Skalierung von 0)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt das Ergebnis der bitweisen XOR-Operation für das Argument (die Argumente) zurück.</para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>SMALLINT</database>, <database>INTEGER</database> oder <database>BIGINT</database></para>
		  </formalpara>
		  <note>
		    <para>Das SMALLINT-Ergebnis wird nur zurückgegeben, wenn alle Argumente explizit SMALLINTs oder NUMERIC(n, 0) 
                        mit n &lt; = 4; ansonsten geben kleine Ganzzahlen ein INTEGER-Ergebnis zurück.</para>
		  </note>
		  <formalpara>
		    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-bin_and-de"><database>BIN_AND</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-bin_or-de"><database>BIN_OR</database></link>
                    </para>
                  </formalpara>
		</section>
  </section> <!-- Bitwise Operations -->


<!-- **************************************************************************************
       F U N C T I O N S   F O R   W O R K I N G   W I T H   U U I D
    ************************************************************************************** -->
  <section id="fblangref25-functions-uuid-de">
    <title>Funktionen zum Arbeiten mit UUID</title>

		<section id="fblangref25-functions-scalarfuncs-char_to_uuid-de">
		  <title><database>CHAR_TO_UUID()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Aufgenommen in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CHAR_TO_UUID (<replaceable>ascii_uuid</replaceable>)
                        </programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-char_to_uuid-de">
      <?dbfo keep-together='auto'?>
        <title>CHAR_TO_UUID Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">ascii_uuid</entry>
              <entry align="left">Eine 36-stellige Darstellung der UUID. '-' (Bindestrich) in den Positionen 9, 14, 19 und 24; 
                  gültige hexadezimale Ziffern in anderen Positionen, z. "A0bF4E45-3029-2a44-D493-4998c9b439A3"</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>CHAR(16) CHARACTER SET OCTETS</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Konvertiert eine für Menschen lesbare UUID-Zeichenfolge mit 36 Zeichen in die 
                        entsprechende 16-Byte-UUID.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select char_to_uuid('A0bF4E45-3029-2a44-D493-4998c9b439A3') from rdb$database
		-- ergibt A0BF4E4530292A44D4934998C9B439A3 (16-byte string)

		select char_to_uuid('A0bF4E45-3029-2A44-X493-4998c9b439A3') from rdb$database
		-- error: - Das für den Benutzer lesbare UUID-Argument für CHAR_TO_UUID muss eine 
                --          Hexadezimalstelle an Position 20 anstelle von "X (ASCII 88)" haben.</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-uuid_to_char-de"><database>UUID_TO_CHAR()</database></link>,
		    <link linkend="fblangref25-functions-scalarfuncs-gen_uuid-de"><database>GEN_UUID()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-gen_uuid-de">
		  <title><database>GEN_UUID()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>GEN_UUID()</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>CHAR(16) CHARACTER SET OCTETS</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt eine universell eindeutige ID als 16-Byte-Zeichenfolge zurück.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>select gen_uuid() from rdb$database
		-- ergibt z.B. 017347BFE212B2479C00FA4323B36320 (16-byte string)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-uuid_to_char-de"><database>UUID_TO_CHAR()</database></link>,
		    <link
		    linkend="fblangref25-functions-scalarfuncs-char_to_uuid-de"><database>CHAR_TO_UUID()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-uuid_to_char-de">
		  <title><database>UUID_TO_CHAR()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Aufgenommen in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>UUID_TO_CHAR (<replaceable>uuid</replaceable>)

		<replaceable>uuid</replaceable>  ::=  eine Zeichenfolge bestehend aus 16 Einzelbyte-Zeichen</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-uuid_to_char-de">
      <?dbfo keep-together='auto'?>
        <title>UUID_TO_CHAR-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">uuid</entry>
              <entry align="left">16-byte UUID</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>CHAR(36)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Konvertiert eine 16-Byte-UUID in ihre aus 36 Zeichen bestehende, für Menschen lesbare ASCII-Darstellung.</para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiele</title>
		    <para><blockquote>
		        <programlisting>select uuid_to_char(x'876C45F4569B320DBCB4735AC3509E5F') from rdb$database
		-- ergibt '876C45F4-569B-320D-BCB4-735AC3509E5F'

		select uuid_to_char(gen_uuid()) from rdb$database
		-- ergibt z.B. '680D946B-45FF-DB4E-B103-BB5711529B86'

		select uuid_to_char('Firebird swings!') from rdb$database
		-- ergibt '46697265-6269-7264-2073-77696E677321'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-char_to_uuid-de"><database>CHAR_TO_UUID()</database></link>,
		    <link linkend="fblangref25-functions-scalarfuncs-gen_uuid-de"><database>GEN_UUID()</database></link></para>
		  </formalpara>
		</section>

  </section> <!-- functions for working with UUID -->

  <!-- **************************************************************************************
          F U N C T I O N S   F O R   W O R K I N G   W I T H   G E N E R A T O R S
    ************************************************************************************** -->
  <section id="fblangref25-functions-generators-de">
    <title>Funktionen zum Arbeiten mit Generatoren (Sequenzen)</title>

		<section id="fblangref25-functions-scalarfuncs-gen_id-de">
		  <title><database>GEN_ID()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Inkrementiert einen Generator oder eine Sequenz und gibt den neuen Wert zurück. Ab Firebird 2.0 wird die 
                        SQL-kompatible Syntax <database>NEXT VALUE FOR</database> bevorzugt, außer wenn ein anderes Inkrement 
                            als 1 benötigt wird.</para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>GEN_ID (<replaceable>generator-name</replaceable>, <replaceable>&lt;step&gt;</replaceable>)
		      </programlisting></blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-gen_id-de">
      <?dbfo keep-together='auto'?>
        <title>GEN_ID-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">generator-name</entry>
              <entry align="left">Name eines Generators (Sequenz), der existiert. Wenn es in doppelten 
                  Anführungszeichen mit einer Kennung, bei der die Groß- und Kleinschreibung beachtet wird, 
                  definiert wurde, muss es in derselben Form verwendet werden, es sei denn, der Name ist ausschließlich 
                  in Großbuchstaben angegeben.</entry>
            </row>
            <row valign="middle">
              <entry align="center">step</entry>
              <entry align="left">Ein Integer-Ausdruck</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Inkrementiert einen Generator oder eine Sequenz und gibt den neuen Wert zurück. Wenn die Schrittweite 
                        gleich 0 ist, behält die Funktion den Wert des Generators unverändert bei und gibt den aktuellen Wert zurück.
                      <itemizedlist>
                        <listitem><para>Ab Firebird 2.0 wird die SQL-kompatible Syntax <database>NEXT VALUE FOR</database> bevorzugt,
                            außer wenn ein anderes Inkrement als 1 benötigt wird.</para></listitem>
                      </itemizedlist>
                    </para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>new.rec_id = gen_id(gen_recnum, 1);</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Wenn der Wert des Schrittparameters kleiner als Null ist, wird der Wert des Generators verringert. Aber Achtung! 
                        Sie sollten mit solchen Manipulationen in der Datenbank äußerst vorsichtig sein, da sie die Datenintegrität 
                        beeinträchtigen könnten.</para>
		  </warning>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-commons-conditional-nxtvlufor-de"><database>NEXT VALUE FOR</database></link>,
		    <link linkend="fblangref25-ddl-sequence-create-de"><database>CREATE SEQUENCE (GENERATOR)</database></link></para>
		  </formalpara>
		</section>
  </section> <!-- functions for working with generators (sequences) -->

<!-- **************************************************************************************
               C O N D I T I O N A L   F U N C T I O N S
    ************************************************************************************** -->
  <section id="fblangref25-functions-conditional-de">
    <title>Bedingte Funktionen</title>

		<section id="fblangref25-functions-scalarfuncs-coalesce-de">
		  <title><database>COALESCE()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-coalesce-de">
      <?dbfo keep-together='auto'?>
        <title>COALESCE-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exp1, exp2 &#x2026; expN</entry>
              <entry align="left">Eine Liste von Ausdrücken aller kompatiblen Typen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Die Funktion <database>COALESCE</database> übernimmt zwei oder mehr Argumente und
                    gibt den ersten Wert zurück, den nicht <constant>NULL</constant> ist. Werden alle Argumente zu
		    <constant>NULL</constant> aufgelöst, ist das Ergebnis ebenfalls <constant>NULL</constant>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Abhängig von der Eingabe.</para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiel</title>
		    <para>In diesem Beispiel wird der Spitzname aus der Tabelle "Personen" ausgewählt. Wenn dieser
                        <constant>NULL</constant> ist, geht es weiter zu FirstName. Wenn dieser auch <constant>NULL</constant> 
                        ist, wird <quote>Mr./Mrs.</quote> verwendet. Schließlich fügt es den Familiennamen hinzu. Alles in
                        allem versucht es, die verfügbaren Daten zu verwenden, um einen vollständigen Namen zu formulieren, der so
                        informell wie möglich ist. Beachten Sie, dass dieses Schema nur funktioniert, wenn fehlende Spitznamen und 
                        Vornamen wirklich <constant>NULL</constant> sind: Wenn eine davon eine leere Zeichenfolge ist, gibt 
                        <database>COALESCE</database> diese an den Aufrufer zurück.
                    <blockquote>
		        <programlisting>select
		coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
		as FullName
		from Persons</programlisting>
		      </blockquote></para>
                  </formalpara>
                  <formalpara>
                    <title>Siehe auch</title>
                    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-iif-de"><database>IIF</database></link>,
                     <link linkend="fblangref25-functions-scalarfuncs-nullif-de"><database>NULLIF</database></link>,
                     <link linkend="fblangref25-commons-conditional-case-de"><database>CASE</database></link></para>
                   </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-decode-de">
		  <title><database>DECODE()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>
DECODE(testexpr,
       expr1, result1
       expr2, result2 &#x2026;]
       [, defaultresult])
                      </programlisting></blockquote>
The equivalent CASE construct:
                      <blockquote><programlisting>
CASE testexpr
       WHEN expr1 THEN result1
       [WHEN expr2 THEN result2 &#x2026;]
       [ELSE defaultresult]
END
                      </programlisting></blockquote>
                    </para>
                  </formalpara>
      <table id="fblangref25-funcs-tbl-decode-de">
      <?dbfo keep-together='auto'?>
        <title>DECODE-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">testexpr</entry>
              <entry align="left">Ein Ausdruck eines kompatiblen Typs, der mit den Ausdrücken 
                  expr1, expr2 ... exprN verglichen wird</entry>
            </row>
            <row valign="middle">
              <entry align="center">expr1, expr2, &#x2026; exprN</entry>
              <entry align="left">Ausdrücke beliebiger kompatibler Typen, auf die der
                     &lt;testexpr&gt; Ausdruck wird verglichen</entry>
            </row>
            <row valign="middle">
              <entry align="center">result1, result2, &#x2026; resultN</entry>
              <entry align="left">Zurückgegebene Werte eines beliebigen Typs</entry>
            </row>
            <row valign="middle">
              <entry align="center">defaultresult</entry>
              <entry align="left">Der Ausdruck, der zurückgegeben werden soll, wenn keine der Bedingungen erfüllt ist</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Verschieden</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>DECODE</database> ist eine Kurzform des sogenannten <link
		    linkend="fblangref25-commons-conditional-case-simple-de"><quote>einfachen <database>CASE</database></quote>-Konstruktes</link>, 
                    in welchem ein Ausdruck mit einer Anzahl weiterer Ausdrücke verglichen wird, bis eine Übereinstimmung gefunden wird.
                    Das Ergebnis wird durch den Wert bestimmt, der nach dem übereinstimmenden Ausdruck aufgeführt wird. 
                    Wenn keine Übereinstimmung gefunden wird, wird das Standardergebnis zurückgegeben, sofern vorhanden. Andernfalls wird
		    <constant>NULL</constant> zurückgegeben.</para>
		  </formalpara>
		        <caution>
		          <para>Die Prüfung auf Übereinstimmung wird mit dem Operator <quote><literal>=</literal></quote> durchgeführt, was bedeutet,
                            dass wenn <replaceable>&lt;testexpr&gt;</replaceable> <constant>NULL</constant> ist, keine der 
                            Ausdrücke (<replaceable>&lt;expr&gt;</replaceable>s) übereinstimmt, auch wenn diese
		          <constant>NULL</constant> sind.</para>
		        </caution>
		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>select name,
		   age,
		   decode( upper(sex),
		           'M', 'Male',
		           'F', 'Female',
		           'Unknown' ),
		   religion
		from people</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link linkend="fblangref25-commons-conditional-case-de"><database>CASE</database></link>, <link
		    linkend="fblangref25-commons-conditional-case-simple-de">Simple <database>CASE</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-iif-de">
		  <title><database>IIF()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>
IIF (<replaceable>&lt;condition&gt;</replaceable>, <replaceable>ResultT</replaceable>, <replaceable>ResultF</replaceable>)
                        </programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-iif-de">
      <?dbfo keep-together='auto'?>
        <title>IIF-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">Ein wahr-|falsch-Ausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">resultT</entry>
              <entry align="left">Der Wert wird zurückgegeben, wenn die Bedingung wahr ist</entry>
            </row>
            <row valign="middle">
              <entry align="center">resultF</entry>
              <entry align="left">Der Wert wird zurückgegeben, wenn die Bedingung falsch ist</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Abhängig von der Eingabe.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>IIF</database> benötigt drei Argumente. Wenn der erste Wert zu 
                            <constant>true</constant> lautet, wird das zweite Argument zurückgegeben. 
                                Andernfalls wird die dritte zurückgegeben.
                      <itemizedlist>
                        <listitem><para><database>IIF</database> könnte mit dem ternären Operator
                        <quote><literal>?</literal> <literal>:</literal></quote> in C-ähnlichen
                        Sprachen verglichen werden.</para></listitem>
                      </itemizedlist>
                    </para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>select iif( sex = 'M', 'Sir', 'Madam' ) from Customers</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <note>
  		    <para><database>IIF</database>(<parameter>Cond</parameter>, <parameter>Result1</parameter>,
		    <parameter>Result2</parameter>) ist eine Kurzform für <quote><database>CASE</database>
		    <database>WHEN</database><parameter>Cond</parameter> <database>THEN</database>
		    <parameter>Result1</parameter> <database>ELSE</database><parameter>Result2</parameter>
		    <database>END</database></quote>.</para>
		  </note>
                  <formalpara>
                    <title>Siehe auch</title>
		    <para>&nbsp;<link linkend="fblangref25-commons-conditional-case-de"><database>CASE</database></link>, <link
		    linkend="fblangref25-functions-scalarfuncs-decode-de"><database>DECODE</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-maxvalue-de">
		  <title><database>MAXVALUE()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>

		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>MAXVALUE (<replaceable>expr1</replaceable> [, ... ,<replaceable>exprN</replaceable> ])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-maxvalue-de">
      <?dbfo keep-together='auto'?>
        <title>MAXVALUE-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr1 &#x2026; exprN</entry>
              <entry align="left">Liste der Ausdrücke kompatibler Typen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Variiert entsprechend der Eingabe&#x2014;Ergebnis wird vom selben Datentyp wie der 
                        erste Ausdruck in der Liste (&lt;Ausdruck1&gt;) sein.</para>
		  </formalpara>
		  <formalpara>
       		    <title>Beschreibung</title>
                    <para>Gibt den Maximalwert aus einer Liste von Zahlen-, Zeichenfolgen- oder Datums- / Uhrzeitausdrücken zurück.
		    Diese Funktion unterstützt Text-<database>BLOBS</database>s beliebiger Größe und Zeichenfolge
		        <itemizedlist>
		          <listitem>
		            <para>Löst ein Ausdruck auf <constant>NULL</constant> aus, gibt
		            <database>MAXVALUE</database> ebenfalls <constant>NULL</constant> zurück. Dieses Verhalten
                            unterscheided sich zur Aggregatfunktion <database>MAX</database>.</para>
		          </listitem>
		        </itemizedlist></para>
		  </formalpara>
                  <formalpara>
                    <title>Beispiel</title>
                    <para>
                    <blockquote><programlisting>
SELECT MAXVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
                    </programlisting></blockquote>
                    </para>
                   </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-minvalue-de"><database>MINVALUE()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-minvalue-de">
		  <title><database>MINVALUE()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>MINVALUE (<replaceable>expr1</replaceable> [, ... , <replaceable>exprN</replaceable> ])</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-minvalue-de">
      <?dbfo keep-together='auto'?>
        <title>MINVALUE-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr1 &#x2026; exprN</entry>
              <entry align="left">Liste der Ausdrücke kompatibler Typen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Variiert entsprechend der Eingabe&#x2014;Ergebnis wird vom selben Datentyp wie der 
                        erste Ausdruck in der Liste (&lt;Ausdruck1&gt;) sein.</para>
		  </formalpara>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para>Gibt den Maximalwert aus einer Liste von Zahlen-, Zeichenfolgen- oder Datums- / Uhrzeitausdrücken zurück.
		    Diese Funktion unterstützt Text-<database>BLOBS</database>s beliebiger Größe und Zeichenfolge
		        <itemizedlist>
		          <listitem>
		            <para>Löst ein Ausdruck auf <constant>NULL</constant> aus, gibt
		            <database>MINVALUE</database> ebenfalls <constant>NULL</constant> zurück. Dieses Verhalten
                            unterscheided sich zur Aggregatfunktion <database>MIN</database>.</para>
		          </listitem>
		        </itemizedlist></para>
		  </formalpara>
		  <formalpara>
		    <title>Beispiel</title>
        <para>
		    <blockquote><programlisting>
SELECT MINVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
                    </programlisting></blockquote>
        </para>
                  </formalpara>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para><link
		    linkend="fblangref25-functions-scalarfuncs-maxvalue-de"><database>MAXVALUE()</database></link></para>
		  </formalpara>
		</section>

		<section id="fblangref25-functions-scalarfuncs-nullif-de">
		  <title><database>NULLIF()</database></title>
		  <formalpara>
		    <title>Verfügbar in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
      <table id="fblangref25-funcs-tbl-nullif-de">
      <?dbfo keep-together='auto'?>
        <title>NULLIF-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exp1</entry>
              <entry align="left">Ein Ausdruck</entry>
            </row>
            <row valign="middle">
              <entry align="center">exp2</entry>
              <entry align="left">Ein anderer Ausdruck eines Datentyps, der mit &lt;exp1&gt; kompatibel ist</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		  <formalpara>
		    <title>Beschreibung</title>
		    <para><database>NULLIF</database> gibt den Wert des ersten Argumentes zurück, es sei denn es 
                    ist identisch zum zweiten. In diesem Fall wird <constant>NULL</constant> zurückgegeben.</para>
		  </formalpara>
		  <formalpara>
		    <title>Rückgabetyp</title>
		    <para>Abhängig von der Eingabe.</para>
		  </formalpara>

		  <formalpara>
		    <title>Beispiel</title>
		    <para><blockquote>
		        <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para>Dies ergibt das Durchschnittsgewicht der in FatPeople aufgeführten Personen, mit 
                      Ausnahme eines Gewichts von -1, da <database>AVG</database> <constant>NULL</constant>-Daten 
                      überspringt.               
                      Augescheinlich bedeutet -1 soviel wie <quote>Gewicht unbekannt</quote> in dieser Tabelle.
                      Ein normales <database>AVG</database>(Weight) würde die Gewichte von -1 inkludieren und das Ergebnis verfälschen.</para>
		  <formalpara>
		    <title>Siehe auch</title>
		    <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs-coalesce-de"><database>COALESCE</database></link>, 
                    <link linkend="fblangref25-functions-scalarfuncs-decode-de"><database>DECODE</database></link>,
                    <link linkend="fblangref25-functions-scalarfuncs-iif-de"><database>IIF</database></link>,
                    <link linkend="fblangref25-commons-conditional-case-de"><database>CASE</database></link>
                    </para>
                  </formalpara>
		</section>

  </section> <!-- conditional functions -->

	</section>

<!-- **************************************************************************************
                    A G G R E G A T E   F U N C T I O N S
    ************************************************************************************** -->

		<section id="fblangref25-functions-aggfuncs-de">
		    <title>Aggregatfunktionen</title>
		    <para>Aggregatfunktionen arbeiten mit Gruppen von Datensätzen und nicht mit einzelnen Datensätzen oder Variablen. 
                        Sie werden oft in Kombination mit einer Klausel <database>GROUP BY</database> verwendet.</para>

		    <section id="fblangref25-functions-aggfuncs-avg-de">
		      <title><database>AVG()</database></title>
		      <formalpara>
		        <title>Verfügbar in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
            <para>
		        <blockquote><programlisting>
AVG ([ALL | DISTINCT] &lt;expr&gt;)
                        </programlisting></blockquote>
            </para>
                      </formalpara>
      <table id="fblangref25-funcs-tbl-avg-de">
      <?dbfo keep-together='auto'?>
        <title>AVG-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr</entry>
              <entry align="left">Ausdruck. Es kann eine Tabellenspalte, eine Konstante, eine Variable, 
                  einen Ausdruck, eine nicht aggregierte Funktion oder eine benutzerdefinierte Funktion 
                  enthalten, die einen numerischen Datentyp zurückgibt. Aggregatfunktionen sind als 
                  Ausdrücke nicht zulässig</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		      <formalpara>
		        <title>Beschreibung</title>
		        <para><database>AVG</database> gibt den durchschnittlichen Argumentwert in der Gruppe zurück. 
                        NULL wird ignoriert.
                          <itemizedlist>
                            <listitem><para>Der Parameter ALL (der Standardwert) wendet die Aggregatfunktion auf alle Werte an.</para></listitem>
                            <listitem><para>Der Parameter DISTINCT weist die AVG-Funktion an, nur eine Instanz jedes eindeutigen Werts
                                zu berücksichtigen, unabhängig davon, wie oft dieser Wert auftritt.</para>
                            </listitem>
                            <listitem><para>Wenn die Menge der abgerufenen Datensätze leer ist oder nur
                            <constant>NULL</constant> enthält, ist das Ergebnis ebenfalls <constant>NULL</constant>.</para></listitem>
                          </itemizedlist>
                        </para>
		      </formalpara>
		      <formalpara>
		        <title>Rückgabetyp</title>
		        <para>Ein numerischer Datentyp, der dem Datentyp des Arguments entspricht.</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>AVG (<replaceable>expression</replaceable>)</programlisting>
		            <itemizedlist>
		              <listitem>
		                <para>Wenn die Menge der abgerufenen Datensätze leer ist oder nur 
                            <constant>NULL</constant> enthält, ist das Ergebnis ebenfalls <constant>NULL</constant>.</para>
		              </listitem>
		            </itemizedlist>
		          </blockquote></para>
		      </formalpara>
		      <formalpara>
		        <title>Beispiel</title>
            <para>
		        <blockquote><programlisting>
SELECT
  dept_no,
  AVG(salary)
FROM employee
GROUP BY dept_no
                        </programlisting></blockquote>
            </para>
                      </formalpara>
                      <formalpara>
                        <title>Siehe auch</title>
                        <para>&nbsp;<link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>
                        </para>
                      </formalpara>
		    </section>

		    <section id="fblangref25-functions-aggfuncs-count-de">
		      <title><database>COUNT()</database></title>
		      <formalpara>
		        <title>Verfügbar in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>COUNT ([ALL | DISTINCT] &lt;expr&gt; | *)</programlisting>
		          </blockquote></para>
		      </formalpara>
      <table id="fblangref25-funcs-tbl-count-de">
      <?dbfo keep-together='auto'?>
        <title>COUNT-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr</entry>
              <entry align="left">Ausdruck. Es kann eine Tabellenspalte, eine Konstante, eine Variable, einen Ausdruck, 
                  eine nicht aggregierte Funktion oder eine benutzerdefinierte Funktion enthalten, die einen numerischen 
                  Datentyp zurückgibt. Aggregatfunktionen sind als Ausdrücke nicht zulässig</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		      <formalpara>
		        <title>Rückgabetyp</title>
		        <para>Integer</para>
		      </formalpara>
		      <formalpara>
		        <title>Beschreibung</title>
		        <para><database>COUNT</database> gibt die Anzahl der nicht-null-Werte einer Menge zurück.
                          <itemizedlist>
                            <listitem><para>ALL ist der Standard: es werden alle Werte gezählt, die nicht
                            <constant>NULL</constant> sind.</para></listitem>
                            <listitem><para>Wenn <database>DISTINCT</database> angegeben wurde, werden Duplikate aus der Zählung
                            entfernt.</para></listitem>
                            <listitem><para>Wurde <database>COUNT (*)</database> anstelle eines Ausdrucks &lt;expr&gt;
                            angegeben, werden alle Zeilen gezählt. <database>COUNT (*)</database>&#x2014;</para>
                              <itemizedlist>
                                <listitem><para>akzeptiert keine Parameter</para></listitem>
                                <listitem><para>kann nicht mit dem Schlüsselwort <database>DISTINCT</database> verwendet werden</para></listitem>
                                <listitem><para>übernimmt kein &lt;expr&gt;-Argument, da sein Kontext während der Definition
                                    spaltenunspezifisch ist</para></listitem>
                                <listitem><para>zählt jede Zeile einzeln und gibt die Anzahl der Zeilen in der angegebenen Tabelle oder
                                    Gruppe zurück, ohne doppelte Zeilen zu entfernen</para></listitem>
                                <listitem><para>zähle Zeilen, die <constant>NULL</constant> enthalten</para></listitem>
                              </itemizedlist>
                            </listitem>
                            <listitem><para>Wenn die Ergebnismenge leer ist oder nur <constant>NULL</constant> in der(den) angegebenen Spalte(n) enthält,
                            ist die zurückgegebene Anzahl Null.</para></listitem>
                          </itemizedlist>
                        </para>
                      </formalpara>
                      <formalpara>
                        <title>Beispiel</title>
                        <para>
		        <blockquote><programlisting>
SELECT
  dept_no,
  COUNT(*) AS cnt,
  COUNT(DISTINCT name) AS cnt_name
FROM employee
GROUP BY dept_no
                        </programlisting></blockquote>
                        </para>
                      </formalpara>
                      <formalpara>
                        <title>Siehe auch</title>
                        <para>&nbsp;<link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>.
                        </para>
                      </formalpara>
		    </section>

		    <section id="fblangref25-functions-aggfuncs-list-de">
		      <title><database>LIST()</database></title>
		      <formalpara>
		        <title>Verfügbar in</title>
		        <para>DSQL, PSQL</para>
		        <!--ESQL?  -> Oleg Loa, Dmitry Yemanov-->
		      </formalpara>
		      <formalpara>
		        <title>Geändert in</title>
		        <para>2.5</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>LIST ([ALL | DISTINCT] <replaceable>expression</replaceable> [, <replaceable>separator</replaceable>])</programlisting>
		          </blockquote></para>
		      </formalpara>
      <table id="fblangref25-funcs-tbl-list-de">
      <?dbfo keep-together='auto'?>
        <title>LIST-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr</entry>
              <entry align="left">Ausdruck. Es kann eine Tabellenspalte, eine Konstante, eine Variable, 
                  einen Ausdruck, eine Nicht-Aggregatfunktion oder eine UDF enthalten, die den String-Datentyp 
                  oder ein BLOB zurückgibt. Felder von numerischen und Datum / Uhrzeit-Typen werden in Zeichenfolgen 
                  konvertiert. Aggregatfunktionen sind als Ausdrücke nicht zulässig</entry>
            </row>
            <row valign="middle">
              <entry align="center">separator</entry>
              <entry align="left">Optionales alternatives Trennzeichen, ein Zeichenfolgenausdruck. Komma ist das Standardtrennzeichen</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		      <formalpara>
		        <title>Rückgabetyp</title>
		        <para><database>BLOB</database></para>
		      </formalpara>
		      <formalpara>
		        <title>Beschreibung</title>
		        <para><database>LIST</database> gibt eine Zeichenfolge zurück, die aus den Nicht-Konstantenwerten 
                            NULL und Konstanten in der Gruppe besteht, die entweder durch ein Komma oder durch ein benutzerdefiniertes 
                            Trennzeichen getrennt sind. Wenn es keine nicht-<constant>NULL</constant>-Werte gibt (dies schließt 
                                den Fall ein, dass die Gruppe leer ist), wird <constant>NULL</constant> zurückgegeben.
		            <itemizedlist>
		              <listitem>
		                <para><database>ALL</database> (der Standard) ergibt, dass alle
		                nicht-<constant>NULL</constant>-Werte aufgelistet werden. Mit
		                <database>DISTINCT</database> werden Duplikate entfernt, es sei denn
		                <replaceable>expression</replaceable> ist ein <database>BLOB</database>.<!--CORE-3253--></para>
		              </listitem>
		              <listitem>
		                <para>In Firebird 2.5 und später, kann das optionale Trennzeichen ein beliebiger
                                String-Ausdruck sein. Damit ist es beispielsweise möglich
		                <parameter><literal>ascii_char(13)</literal></parameter> als Trenner zu definieren. 
                                (Diese Verbesserung wurde auch auf 2.1.4 zurückversetzt.)</para>
		              </listitem>
		              <listitem>
		                <para>Die Argumente <replaceable>expression</replaceable> und
		                <replaceable>separator</replaceable> unterstützen <database>BLOB</database>s 
                                beliebiger Größe und beliebigen Zeichensatzes.</para>
		              </listitem>
		              <listitem>
		                <para>Datum / Uhrzeit und numerische Argumente werden implizit vor der 
                                    Verkettung in Zeichenfolgen konvertiert.</para>
		              </listitem>
		              <listitem>
		                <para>Das Ergebnis ist ein Text-<database>BLOB</database>, außer 
		                <replaceable>expression</replaceable> ist ein <database>BLOB</database> eines anderen
		                Untertyps.</para>
		              </listitem>
		              <listitem>
		                <para>Die Reihenfolge der Listenwerte ist undefiniert. Die Reihenfolge, in der die Strings 
                                    verkettet werden, wird durch die Lesereihenfolge aus der Quellenmenge bestimmt, die in 
                                    Tabellen nicht allgemein definiert ist. Wenn die Reihenfolge wichtig ist, können die Quelldaten 
                                    mit einer abgeleiteten Tabelle oder ähnlichem vorsortiert werden.</para>
		              </listitem>
		            </itemizedlist></para>
		      </formalpara>
                      <formalpara>
                        <title>Beispiele</title>
                        <para>
                        <orderedlist>
                          <listitem><para>Abrufen der Liste, Reihenfolge undefiniert:</para>
                          <blockquote><programlisting>
SELECT LIST (display_name, '; ') FROM GR_WORK;
                          </programlisting></blockquote>
                          </listitem>
                          <listitem><para>Abrufen der Liste in alphabetischer Reihenfolge mit einer abgeleiteten Tabelle:</para>
                          <blockquote><programlisting>
SELECT LIST (display_name, '; ')
FROM (SELECT display_name
      FROM GR_WORK
      ORDER BY display_name);
                          </programlisting></blockquote>
                          </listitem>
                        </orderedlist>
                        </para>
                      </formalpara>
                      <formalpara>
                        <title>Siehe auch</title>
                        <para>&nbsp;<link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>
                        </para>
                      </formalpara>
		    </section>

		    <section id="fblangref25-functions-aggfuncs-max-de">
		      <title><database>MAX()</database></title>
		      <formalpara>
		        <title>Verfügbar in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>MAX ([ALL | DISTINCT] <replaceable>&lt;expr&gt;</replaceable>)</programlisting>
		          </blockquote></para>
		      </formalpara>
      <table id="fblangref25-funcs-tbl-max-de">
      <?dbfo keep-together='auto'?>
        <title>MAX-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr</entry>
              <entry align="left">Ausdruck. Es kann eine Tabellenspalte, eine Konstante, eine Variable, 
                  einen Ausdruck, eine Nicht-Aggregatfunktion oder eine UDF enthalten. Aggregatfunktionen 
                  sind als Ausdrücke nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		      <formalpara>
		        <title>Rückgabetyp</title>
		        <para>Gibt ein Ergebnis desselben Datentyps als Eingabeausdruck zurück.</para>
		      </formalpara>
		      <formalpara>
		        <title>Beschreibung</title>
		        <para><database>MAX</database> gibt das größte nicht-<constant>NULL</constant>-Element
                              der Ergebnismenge zurück.
      		            <itemizedlist>
		              <listitem>
		                <para>Ist die Menge leer oder enthält nur <database>NULL</database>, ist das Ergebnis
		                <database>NULL</database>.</para>
		              </listitem>
		              <listitem><para>Wenn das Eingabeargument eine Zeichenfolge ist, gibt die Funktion den Wert zurück,
                                  der zuletzt sortiert wird, wenn <database>COLLATE</database> verwendet wird.</para></listitem>
		              <listitem><para>Diese Funktion unterstützt vollständig Text <database>BLOB</database>s
                                  beliebiger Größe und Zeichensatz.</para></listitem>
		            </itemizedlist>
                          <note>
                            <para>Der Parameter <database>DISTINCT</database> hat keinen Sinn, wenn er mit 
                                <database>MAX()</database> verwendet wird und nur für die Einhaltung des Standards implementiert ist.</para>
                          </note>
                        </para>
		      </formalpara>
		      <formalpara>
		        <title>Beispiel</title>
            <para>
                          <blockquote><programlisting>
SELECT
  dept_no,
  MAX(salary)
FROM employee
GROUP BY dept_no
                          </programlisting></blockquote>
            </para>
                      </formalpara>
                      <formalpara>
                        <title>Siehe auch</title>
                        <para>&nbsp;<link linkend="fblangref25-functions-aggfuncs-min-de"><database>MIN</database></link>,
                        <link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>
                        </para>
                      </formalpara>
		    </section>

		    <section id="fblangref25-functions-aggfuncs-min-de">
		      <title><database>MIN()</database></title>
		      <formalpara>
		        <title>Verfügbar in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>MIN ([ALL | DISTINCT] <replaceable>&lt;expr&gt;</replaceable>)</programlisting>
		          </blockquote></para>
		      </formalpara>
      <table id="fblangref25-funcs-tbl-min-de">
      <?dbfo keep-together='auto'?>
        <title>MIN-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr</entry>
              <entry align="left">Ausdruck. Es kann eine Tabellenspalte, eine Konstante, eine Variable, einen Ausdruck, eine Nicht-Aggregatfunktion 
                  oder eine UDF enthalten. Aggregatfunktionen sind als Ausdrücke nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		      <formalpara>
		        <title>Rückgabetyp</title>
		        <para>Gibt ein Ergebnis desselben Datentyps als Eingabeausdruck zurück.</para>
		      </formalpara>
		      <formalpara>
		        <title>Beschreibung</title>
		        <para><database>MIN</database> gibt das größte nicht-<constant>NULL</constant>-Element
                              der Ergebnismenge zurück.
      		            <itemizedlist>
		              <listitem>
		                <para>Ist die Menge leer oder enthält nur <database>NULL</database>, ist das Ergebnis
		                <database>NULL</database>.</para>
		              </listitem>
		              <listitem><para>Wenn das Eingabeargument eine Zeichenfolge ist, gibt die Funktion den Wert zurück,
                                  der zuletzt sortiert wird, wenn <database>COLLATE</database> verwendet wird.</para></listitem>
		              <listitem><para>Diese Funktion unterstützt vollständig Text <database>BLOB</database>s
                                  beliebiger Größe und Zeichensatz.</para></listitem>
		            </itemizedlist>
                          <note>
                            <para>Der Parameter <database>DISTINCT</database> hat keinen Sinn, wenn er mit 
                                <database>MIN()</database> verwendet wird und nur für die Einhaltung des Standards implementiert ist.</para>
                          </note>
                        </para>
		      </formalpara>
		      <formalpara>
		        <title>Beispiel</title>
            <para>
                          <blockquote><programlisting>
SELECT
  dept_no,
  MIN(salary)
FROM employee
GROUP BY dept_no
                          </programlisting></blockquote>
            </para>
                      </formalpara>
                      <formalpara>
                        <title>Siehe auch</title>
                        <para>&nbsp;<link linkend="fblangref25-functions-aggfuncs-max-de"><database>MAX</database></link>,
                        <link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>
                        </para>
                      </formalpara>
		    </section>

		    <section id="fblangref25-functions-aggfuncs-sum-de">
		      <title><database>SUM()</database></title>
		      <formalpara>
		        <title>Verfügbar in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>SUM ([ALL | DISTINCT] <replaceable>&lt;expr&gt;</replaceable>)</programlisting>
		          </blockquote></para>
		      </formalpara>
      <table id="fblangref25-funcs-tbl-sum-de">
      <?dbfo keep-together='auto'?>
        <title>SUM-Funktionsparameter</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">expr</entry>
              <entry align="left">Numerischer Ausdruck Es kann eine Tabellenspalte, eine Konstante, eine Variable, einen 
                  Ausdruck, eine Nicht-Aggregatfunktion oder eine UDF enthalten. Aggregatfunktionen sind als Ausdrücke nicht zulässig.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
		      <formalpara>
		        <title>Rückgabetyp</title>
		        <para>Gibt ein Ergebnis des gleichen numerischen Datentyps wie der Eingabeausdruck zurück.</para>
		      </formalpara>

		      <formalpara>
		        <title>Beschreibung</title>
		        <para><database>SUM</database> berechnet und gibt die Summe der nicht-Null-Werte in der Gruppe zurück.
		            <itemizedlist>
		              <listitem>
		                <para>Wenn die Gruppe leer ist oder nur <database>NULL</database> enthält, ist das Ergebnis
                                ebenfalls <database>NULL</database>.</para>
		              </listitem>
		              <listitem><para>ALL ist die Standardoption &#x2014; alle Werte in der Gruppe, die nicht <database>NULL</database>
                                  sind, werden verarbeitet. Wenn <database>DISTINCT</database> angegeben ist, werden Duplikate aus der Datenmenge 
                                  entfernt, und die Auswertung <database>SUM</database> erfolgt anschließend.</para></listitem>
		            </itemizedlist>
                        </para>
		      </formalpara>
		      <formalpara>
		        <title>Beispiel</title>
            <para>
            <blockquote><programlisting>
SELECT
  dept_no,
  SUM (salary),
FROM employee
GROUP BY dept_no

                          </programlisting></blockquote>
            </para>
                      </formalpara>
                      <formalpara>
                        <title>Siehe auch</title>
                        <para>&nbsp;<link linkend="fblangref25-dml-select-de"><database>SELECT</database></link>
                        </para>
                      </formalpara>  
		    </section>
  </section>
</chapter>
