<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-transacs-de">
  <title>Transaktionskontrolle</title>
  
  <para>Alles in Firebird passiert in Transaktionen. Arbeitseinheiten sind zwischen einem Start- und 
      einem Endpunkt isoliert. Änderungen an Daten bleiben bis zu dem Moment reversibel, zu dem 
      die Clientanwendung den Server anweist, sie zu übertragen.</para>
  <section id="fblangref25-transacs-statements-de">
    <title>Transaktions-Statements</title>
    <para>Firebird verfügt über ein kleines Lexikon von SQL-Anweisungen, die von Client-Anwendungen 
        zum Starten, Verwalten, Festschreiben und Zurücksetzen (Rollback) der Transaktionen 
        verwendet werden, die die Grenzen aller Datenbankaufgaben bilden:
      <formalpara>
        <title><link linkend="fblangref25-transacs-settransac-de">SET TRANSACTION</link></title>
        <para>&nbsp;zum Konfigurieren und Starten einer Transaktion</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-commit-de">COMMIT</link></title>
        <para>&nbsp;das Ende einer Arbeitseinheit signalisieren und Änderungen 
            dauerhaft in die Datenbank schreiben</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-rollback-de">ROLLBACK</link></title>
        <para>&nbsp;die in der Transaktion durchgeführten Änderungen rückgängig machen</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-savepoint-de">SAVEPOINT</link></title>
        <para>&nbsp;um eine Position im Protokoll der geleisteten Arbeit zu markieren, 
            falls ein partieller Rollback benötigt wird</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-releasesp-de">RELEASE SAVEPOINT</link></title>
        <para>&nbsp;einen Sicherungspunkt löschen</para>
      </formalpara>
    </para>

    <section id="fblangref25-transacs-settransac-de">
      <title><database>SET TRANSACTION</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Konfiguration und Start einer Transaktion</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
SET TRANSACTION
   [NAME tr_name]
   [READ WRITE | READ ONLY]
   [[ISOLATION LEVEL] {
       SNAPSHOT [TABLE STABILITY]
     | READ COMMITTED [[NO] RECORD_VERSION] }]
   [WAIT | NO WAIT]
   [LOCK TIMEOUT seconds]
   [NO AUTO UNDO]
   [IGNORE LIMBO]
   [RESERVING &lt;tables&gt; | USING &lt;dbhandles&gt;]

    &lt;tables&gt; ::= &lt;table_spec&gt; [, &lt;table_spec&gt; ...]

    &lt;table_spec&gt; ::= tablename [, tablename ...]
      [FOR [SHARED | PROTECTED] {READ | WRITE}]

    &lt;dbhandles&gt; ::= dbhandle [, dbhandle ...]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-settransac-de">
      <?dbfo keep-together='auto'?>
        <title>SET TRANSACTION-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tr_name</entry>
              <entry align="left">Name der Transaktion. Nur in ESQL verfügbar</entry>
            </row>
            <row valign="middle">
              <entry align="center">seconds</entry>
              <entry align="left">Die Zeit in Sekunden, die die Anweisung im Falle eines Konflikts warten muss</entry>
            </row>
            <row valign="middle">
              <entry align="center">tables</entry>
              <entry align="left">Die Liste der zu reservierenden Tabellen</entry>
            </row>
            <row valign="middle">
              <entry align="center">dbhandles</entry>
              <entry align="left">Die Liste der Datenbanken, auf die die Datenbank zugreifen kann. Nur in ESQL verfügbar</entry>
            </row>
            <row valign="middle">
              <entry align="center">table_spec</entry>
              <entry align="left">Reservierungsspezifiktationen für Tabellen</entry>
            </row>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Der Name der Tabelle, die reserviert werden soll</entry>
            </row>
            <row valign="middle">
              <entry align="center">dbhandle</entry>
              <entry align="left">Der Handle der Datenbank, auf die die Datenbank zugreifen kann. 
                  Nur in ESQL verfügbar</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die Anweisung <database>SET TRANSACTION</database> konfiguriert die Transaktion und 
      startet sie. In der Regel starten nur Client-Anwendungen Transaktionen. Die Ausnahmen sind 
      die Fälle, in denen der Server eine autonome Transaktion oder Transaktionen für bestimmte 
      Hintergrundsystem-Threads / -Prozesse startet, z. B. das Sweeping.</para>
      <para>Eine Clientanwendung kann beliebig viele gleichzeitig ausgeführte Transaktionen starten. 
          Es gibt eine Beschränkung für die Gesamtzahl der ausgeführten Transaktionen in allen Clientanwendungen, 
          die mit einer bestimmten Datenbank ab dem Zeitpunkt arbeiten, zu dem die Datenbank aus ihrer Sicherungskopie 
          wiederhergestellt wurde oder ab dem Moment, als die Datenbank ursprünglich erstellt wurde. Die 
          Grenze ist 2<superscript>31</superscript>-1 oder 2.147.483.647.</para>
      <para>Alle Klauseln in der Anweisung <database>SET TRANSACTION</database> sind optional. Wenn in der 
      Anweisung, die eine Transaktion startet, keine Klauseln angegeben sind, wird die Transaktion mit Standardwerten 
      für den Zugriffsmodus, den Sperrauflösungsmodus und die Isolationsstufe gestartet. Dies sind:
        <blockquote><programlisting>
SET TRANSACTION
  READ WRITE
  WAIT
  ISOLATION LEVEL SNAPSHOT;
        </programlisting></blockquote>
      </para>

      <para>Der Server weist Transaktionen sequenziell Ganzzahlen zu. Wenn ein Client eine Transaktion startet, 
          entweder explizit definiert oder standardmäßig, sendet der Server die Transaktions-ID an den Client. 
          Diese Nummer kann in SQL über die Kontextvariable <database>CURRENT_TRANSACTION</database> 
          abgerufen werden.</para>

      <section id="fblangref25-transacs-settransac-params-de">
        <title>Transaktionsparameter</title>
        <para>Die wichtigsten Parameter einer Transaktion sind:
          <itemizedlist spacing="compact">
            <listitem>Datenzugriffsmodus (READ WRITE, READ ONLY)</listitem>
            <listitem>Modus zur Sperrauflösung (WAIT, NO WAIT) mit optionaler Spezifikation des LOCK TIMEOUT</listitem>
            <listitem>Isolationslevel (READ COMMITTED, SNAPSHOT, TABLE STABILITY)</listitem>
            <listitem>ein Mechanismus zum Reservieren oder Freigeben von Tabellen (die RESERVING-Klausel)</listitem>
          </itemizedlist>
        </para>

        <section id="fblangref25-transacs-settransac-params01-de">
          <title>Transaktionsname</title>
          <para>Das optionale NAME-Attribut definiert den Namen einer Transaktion. Die Verwendung dieses Attributs ist
              nur in Embedded SQL verfügbar. In ESQL-Anwendungen ermöglichen benannte Transaktionen die gleichzeitige 
              Aktivierung mehrerer Transaktionen in einer Anwendung. Wenn benannte Transaktionen verwendet werden, 
              muss eine hostspezifische Variable mit demselben Namen für jede benannte Transaktion deklariert und 
              initialisiert werden. Dies ist eine Einschränkung, die die dynamische Angabe von Transaktionsnamen 
              verhindert und daher die Transaktionsbenennung in DSQL ausschließt.</para>
        </section>

        <section id="fblangref25-transacs-settransac-params02-de">
          <title>Zugriffsmodus</title>
          <para>Die zwei verfügbaren Zugriffsvarianten für Transaktionen sind READ WRITE und READ ONLY.
            <itemizedlist>
              <listitem>Wenn der Zugriffsmodus READ WRITE lautet, können Operationen im Kontext dieser 
                  Transaktion sowohl Leseoperationen als auch Datenaktualisierungsoperationen sein. 
                  Dies ist der Standardmodus.</listitem>
              <listitem>Wenn der Zugriffsmodus READ ONLY ist, können im Kontext dieser Transaktion nur 
                  SELECT-Operationen ausgeführt werden. Jeder Versuch, Daten im Kontext einer solchen 
                  Transaktion zu ändern, führt zu Datenbankausnahmen. Es gilt jedoch nicht für globale 
                  temporäre Tabellen (GTT), die in READ ONLY-Transaktionen geändert werden dürfen.</listitem>
            </itemizedlist>
          </para>
        </section>

        <section id="fblangref25-transacs-settransac-params03-de">
          <title>Modus zur Sperrauflösung</title>
          <para>Wenn mehrere Clientprozesse mit derselben Datenbank arbeiten, können Sperren auftreten, 
              wenn ein Prozess nicht festgeschriebene Änderungen in einer Tabellenzeile vornimmt oder 
              eine Zeile löscht und ein anderer Prozess versucht, dieselbe Zeile zu aktualisieren oder 
              zu löschen. Solche Sperren heißen <emphasis> Aktualisierungskonflikte (update conflicts)</emphasis>.</para>
          <para>Sperren können in anderen Situationen auftreten, wenn mehrere Transaktionsisolationsstufen 
              verwendet werden.</para>
          <para>Die zwei Lock-Auflösungsmodi sind WAIT und NO WAIT.</para>

          <section id="fblangref25-transacs-settransac-params03-wait-de">
            <title>WAIT Modus</title>
            <para>Wenn im WAIT-Modus (Standardmodus) ein Konflikt zwischen zwei parallelen Prozessen 
                auftritt, die gleichzeitige Datenaktualisierungen in derselben Datenbank ausführen, 
                wartet eine WAIT-Transaktion, bis die andere Transaktion abgeschlossen ist &mdash;
                durch Commit (COMMIT) oder Rollback (ROLLBACK). Die Clientanwendung mit der 
                WAIT-Transaktion wird gehalten, bis der Konflikt behoben ist.</para>

            <para>Wenn für die WAIT-Transaktion ein LOCK TIMEOUT angegeben ist, wird das Warten 
                nur für die in dieser Klausel angegebene Anzahl von Sekunden fortgesetzt. 
                Wenn die Sperre am Ende des angegebenen Intervalls nicht aufgelöst wird, wird die 
                Fehlermeldung <quote>Lock time-out on wait transaction</quote> an den Client 
                zurückgegeben.
            </para>

            <para>Das Verhalten der Sperrenauflösung kann abhängig von der Transaktionsisolationsstufe 
                etwas variieren.</para>
          </section>
          <section id="fblangref25-transacs-settransac-params03-nowait-de">
            <title>NO WAIT Modus</title>
            <para>Im NO WAIT-Modus löst eine Transaktion sofort eine Datenbankausnahme aus, 
                wenn ein Konflikt auftritt.</para>
          </section>
        </section>

        <section id="fblangref25-transacs-settransac-params04-de">
          <title>Isolationslevel</title>
          <para>Die Arbeit einer Datenbankaufgabe von anderen getrennt zu halten, ist die Frage nach 
              der Isolation. Änderungen, die von einer Anweisung vorgenommen werden, werden für alle 
              übrigen Anweisungen sichtbar, die innerhalb der gleichen Transaktion ausgeführt werden, 
              unabhängig von ihrer Isolationsstufe. Änderungen, die in anderen Transaktionen ausgeführt 
              werden, bleiben für die aktuelle Transaktion unsichtbar, solange sie nicht festgeschrieben 
              sind. Die Isolationsstufe und manchmal auch andere Attribute bestimmen, wie Transaktionen 
              miteinander interagieren, wenn eine andere Transaktion ihre Arbeit verrichten will.</para>

          <para>Das ISOLATION LEVEL-Attribut definiert die Isolationsstufe für die zu startende Transaktion. 
              Es ist der wichtigste Transaktionsparameter, um sein Verhalten gegenüber anderen 
              gleichzeitig ausgeführten Transaktionen zu bestimmen.</para>

          <para>Die drei in Firebird unterstützten Isolationsstufen sind:
            <itemizedlist spacing="compact">
              <listitem>SNAPSHOT</listitem>
              <listitem>SNAPSHOT TABLE STABILITY</listitem>
              <listitem>READ COMMITTED mit zwei Spezifikationen (NO RECORD_VERSION und RECORD_VERSION)</listitem>
            </itemizedlist>
          </para>
          <section id="fblangref25-transacs-settransac-params04a-de">
            <title>SNAPSHOT-Isolationslevel</title>
            <para>SNAPSHOT-Isolationsstufe &mdash; die Standardebene &mdash; ermöglicht es der Transaktion, 
                nur die Änderungen zu sehen, die bereits vor dem Start festgeschrieben wurden. Alle durch gleichzeitige 
                Transaktionen vorgenommenen festgeschriebenen Änderungen werden in einer SNAPSHOT-Transaktion 
                nicht angezeigt, solange sie aktiv ist. Die Änderungen werden für eine neue Transaktion sichtbar, 
                sobald die aktuelle Transaktion festgeschrieben oder vollständig zurückgesetzt wurde, jedoch nicht, 
                wenn sie nur auf einen Sicherungspunkt zurückgesetzt wird.</para>
            <note>
              <title>Autonome Transaktionen</title>
              <para>Änderungen, die durch autonome (autonomous) Transaktionen vorgenommen werden, werden nicht im Kontext der 
                  SNAPSHOT-Transaktion gesehen, die sie gestartet hat.</para>
            </note>
           </section>

          <section id="fblangref25-transacs-settransac-params04b-de">
            <title>SNAPSHOT TABLE STABILITY-Isolationslevel</title>
            <para>Die Isolationsstufe SNAPSHOT TABLE STABILITY ist am restriktivsten. Wie in SNAPSHOT sieht eine 
                Transaktion in der SNAPSHOT TABLE STABILITY-Isolation nur die Änderungen, die vor dem Start 
                der aktuellen Transaktion festgeschrieben wurden. Nachdem eine SNAPSHOT TABLE STABILITY gestartet 
                wurde, können keine anderen Transaktionen Änderungen an einer Tabelle in der Datenbank vornehmen, 
                für die Änderungen anstehen. Andere Transaktionen können andere Daten lesen, aber jeder Versuch, 
                durch einen parallelen Prozess einzufügen, zu aktualisieren oder zu löschen, führt zu 
                Konfliktausnahmen.</para>
            <para>Die RESERVING-Klausel kann verwendet werden, um anderen Transaktionen zu ermöglichen, 
                Daten in einigen Tabellen zu ändern.</para>
            <para>Wenn eine andere Transaktion eine nicht festgeschriebene Änderung von Daten in einer Datenbanktabelle 
                aussteht, bevor eine Transaktion mit der Isolationsstufe SNAPSHOT TABLE STABILITY gestartet wird, führt 
                der Versuch, eine Transaktion SNAPSHOT TABLE STABILITY zu starten, zu einer Ausnahme.</para>
          </section>

          <section id="fblangref25-transacs-settransac-params04c-de">
            <title>READ COMMITTED Isolationslevel</title>
            <para>Die READ COMMITTED-Isolationsstufe ermöglicht alle Datenänderungen, die andere Transaktionen festgeschrieben 
                haben, seit sie durch die nicht festgeschriebene aktuelle Transaktion unmittelbar erkannt wurden. Nicht 
                festgeschriebene Änderungen sind für eine READ COMMITTED-Transaktion nicht sichtbar.</para>

            <para>Um die aktualisierte Liste von Zeilen in der Tabelle, die Sie interessieren, abzurufen, muss die 
                SELECT-Anweisung nur &mdash; <quote>erneut</quote> &mdash; angefordert werden, während sie sich noch in der nicht 
                übergebenen READ COMMITTED-Transaktion befindet.</para>

            <section id="fblangref25-transacs-settransac-params04c1-de">
              <title>RECORD_VERSION</title>
              <para>Einer von zwei modifizierenden Parametern kann für READ COMMITTED-Transaktionen spezifiziert werden, 
                  abhängig von der Art der gewünschten Konfliktlösung: RECORD_VERSION und NO RECORD_VERSION. Wie die 
                  Namen andeuten, schließen sie sich gegenseitig aus.
                <itemizedlist>
                  <listitem>NO RECORD_VERSION (der Standardwert) ist eine Art zweiphasiger Sperrmechanismus: 
                      Dadurch kann die Transaktion nicht in eine Zeile schreiben, für die ein Update 
                      aus einer anderen Transaktion ansteht.
                    <itemizedlist>
                      <listitem>Wenn NO WAIT die angegebene Sperrauflösungsstrategie ist, wird sofort ein 
                          Sperrkonfliktfehler ausgegeben.</listitem>
                      <listitem>Wenn WAIT angegeben ist, wartet es, bis die andere Transaktion festgeschrieben oder 
                          zurückgesetzt wird. Wenn die andere Transaktion zurückgesetzt wird oder wenn sie festgeschrieben 
                          ist und ihre Transaktions-ID älter als die ID der aktuellen Transaktion ist, ist die Änderung der 
                          aktuellen Transaktion zulässig. Ein Sperrkonfliktfehler wird zurückgegeben, wenn die andere Transaktion 
                          festgeschrieben wurde und ihre ID neuer als die der aktuellen Transaktion war.</listitem>
                    </itemizedlist>
                  </listitem>
                  <listitem>Wenn RECORD_VERSION angegeben ist, liest die Transaktion die letzte festgeschriebene Version 
                      der Zeile, unabhängig von anderen ausstehenden Versionen der Zeile. Die Sperrauflösungsstrategie 
                      (WAIT oder NO WAIT) hat keinen Einfluss auf das Verhalten der Transaktion beim Start.</listitem>
                </itemizedlist>
              </para>
            </section>
          </section> <!-- read committed -->
        </section> <!-- isolation level -->

        <section id="fblangref25-transacs-settransac-params05-de">
          <title>NO AUTO UNDO</title>
          <para>Die Option NO AUTO UNDO wirkt sich auf die Behandlung nicht verwendeter Datensatzversionen (Garbage) 
              im Falle eines Rollbacks aus. Wenn NO AUTO UNDO markiert ist, markiert die ROLLBACK-Anweisung 
              die Transaktion nur als Rollback, ohne die in der Transaktion erstellten unbenutzten Datensatzversionen 
              zu löschen. Sie müssen später von der Garbage Collection aufgeräumt werden.</para>
          <para>NO AUTO UNDO kann nützlich sein, wenn viele separate Anweisungen ausgeführt werden, die Daten in Bedingungen 
              ändern, in denen die Transaktion üblicherweise erfolgreich abgeschlossen wird.</para>
          <para>Die Option NO AUTO UNDO wird für Transaktionen ignoriert, bei denen keine Änderungen vorgenommen werden.</para>
        </section>

        <section id="fblangref25-transacs-settransac-params06-de">
          <title>IGNORE LIMBO</title>
          <para>Dieses Kennzeichen wird verwendet, um zu signalisieren, dass von Limbo-Transaktionen erzeugte 
              Datensätze ignoriert werden sollen. Transaktionen werden <quote> in der Schwebe gehalten </quote>, 
              wenn die zweite Phase eines zweiphasigen Commits fehlschlägt.</para>
          <note>
            <title>Historische Anmerkung</title>
            <para>IGNORE LIMBO enthält den TPB-Parameter <function> isc_tpb_ignore_limbo </function>, 
            der seit InterBase in der API verfügbar ist und hauptsächlich von <emphasis> gfix </emphasis> 
            verwendet wird.</para>
          </note>
        </section>

        <section id="fblangref25-transacs-settransac-params07-de">
          <title>RESERVING</title>
          <para>Die RESERVING-Klausel in der SET TRANSACTION-Anweisung reserviert Tabellen, die in der Tabellenliste 
              angegeben sind. Das Reservieren einer Tabelle verhindert, dass andere Transaktionen Änderungen an 
              ihnen vornehmen oder sogar unter Einbeziehung bestimmter Parameter Daten von ihnen lesen, während 
              diese Transaktion ausgeführt wird.</para>
          <para>Eine RESERVING-Klausel kann auch verwendet werden, um eine Liste von Tabellen anzugeben, die von anderen 
              Transaktionen geändert werden können, auch wenn die Transaktion mit der Isolationsstufe 
              SNAPSHOT TABLE STABILITY gestartet wird.</para>
          <para>Eine RESERVING-Klausel wird verwendet, um so viele reservierte Tabellen wie erforderlich anzugeben.</para>

          <section id="fblangref25-transacs-settransac-params07a-de">
            <title>Optionen für die RESERVING-Klausel</title>
            <para>Wenn eines der Schlüsselwörter SHARED oder PROTECTED weggelassen wird, wird SHARED angenommen. Wenn 
                die gesamte FOR-Klausel weggelassen wird, wird FOR SHARED READ angenommen. Die Namen und die Kompatibilität 
                der vier Zugriffsoptionen zum Reservieren von Tabellen sind nicht offensichtlich.</para>

            <table id="fblangref25-transacs-tbl-accesscompat-de">
            <?dbfo keep-together='auto'?>
              <title>Kompatibilität der Zugriffsoptionen für RESERVING</title>
              <tgroup cols="5">
                <colspec colname="colOne" colwidth="1*"></colspec>
                <colspec colname="colTwo" colwidth="1*"></colspec>
                <colspec colname="colThree" colwidth="1*"></colspec>
                <colspec colname="colFour" colwidth="1*"></colspec>
                <colspec colname="colFive" colwidth="1*"></colspec>
                <tbody>
                  <row valign="middle">
                    <entry align="center">&nbsp;</entry>
                    <entry align="center">SHARED READ</entry>
                    <entry align="center">SHARED WRITE</entry>
                    <entry align="center">PROTECTED READ</entry>
                    <entry align="center">PROTECTED WRITE</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">SHARED READ</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Ja</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">SHARED WRITE</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Nein</entry>
                    <entry align="center">Nein</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">PROTECTED READ</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Nein</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Nein</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">PROTECTED WRITE</entry>
                    <entry align="center">Ja</entry>
                    <entry align="center">Nein</entry>
                    <entry align="center">Nein</entry>
                    <entry align="center">Nein</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            <para>Die Kombinationen dieser RESERVING-Klauselflags für den gleichzeitigen Zugriff hängen von 
                den Isolationsstufen der gleichzeitigen Transaktionen ab:
              <itemizedlist>
                <listitem>SNAPSHOT-Isolation
                  <itemizedlist spacing="compact">
                    <listitem>Gleichzeitige SNAPSHOT-Transaktionen mit SHARED READ wirken sich nicht auf 
                        den Zugriff eines anderen aus</listitem>
                    <listitem>Eine gleichzeitige Mischung aus SNAPSHOT- und READ COMMITTED-Transaktionen 
                        mit SHARED WRITE wirkt sich nicht auf den Zugriff des anderen aus, blockiert jedoch 
                        Transaktionen mit der SNAPSHOT TABLE STABILITY-Isolation beim Lesen oder Schreiben 
                        in die angegebene Tabelle[n].</listitem>
                    <listitem>Gleichzeitige Transaktionen mit einer beliebigen Isolationsstufe und PROTECTED READ 
                        können nur Daten aus den reservierten Tabellen lesen. Jeder Versuch, an sie zu schreiben, 
                        führt zu einer Ausnahme</listitem>
                    <listitem>Mit PROTECTED WRITE können gleichzeitige Transaktionen mit der Isolation SNAPSHOT 
                        und READ COMMITTED nicht in die angegebenen Tabellen schreiben. Transaktionen mit der 
                        SNAPSHOT TABLE STABILITY-Isolation können überhaupt nicht aus den reservierten Tabellen 
                        lesen oder in diese schreiben.</listitem>
                  </itemizedlist>
                </listitem>

                <listitem>SNAPSHOT TABLE STABILITY-Isolation
                  <itemizedlist spacing="compact">
                    <listitem>Alle gleichzeitigen Transaktionen mit SHARED READ, unabhängig von ihrer Isolationsstufe, 
                        können aus den reservierten Tabellen lesen oder in den schreibgeschützten Tabellen 
                        schreiben (falls im READ WRITE-Modus)</listitem>
                    <listitem>Gleichzeitige Transaktionen mit den Isolationsstufen SNAPSHOT und READ COMMITTED und 
                        SHARED WRITE können Daten aus den Tabellen lesen und schreiben (falls im Modus READ WRITE), 
                        aber der gleichzeitige Zugriff auf diese Tabellen aus Transaktionen mit SNAPSHOT TABLE STABILITY 
                        wird vollständig blockiert, solange diese Transaktionen aktiv sind.</listitem>
                    <listitem>Gleichzeitige Transaktionen mit einer beliebigen Isolationsstufe und PROTECTED READ 
                        können nur aus den reservierten Tabellen lesen</listitem>
                    <listitem>Mit PROTECTED WRITE können gleichzeitige SNAPSHOT- und READ COMMITTED-Transaktionen die 
                        reservierten Tabellen lesen, aber nicht in diese schreiben. Der Zugriff durch Transaktionen mit 
                        der Isolationsstufe SNAPSHOT TABLE STABILITY ist vollständig blockiert.</listitem>
                  </itemizedlist>
                </listitem>

                <listitem>READ COMMITTED-Isolation
                  <itemizedlist spacing="compact">
                    <listitem>Mit SHARED READ können alle gleichzeitigen Transaktionen mit einer beliebigen Isolationsstufe 
                        von den reservierten Tabellen gelesen und geschrieben werden (wenn im READ WRITE-Modus).</listitem>
                    <listitem>SHARED WRITE ermöglicht allen Transaktionen in der SNAPSHOT- und READ COMMITTED-Isolation 
                        das Lesen und Schreiben (falls im Modus READ WRITE) in die angegebenen Tabellen und das vollständige 
                        Sperren des Zugriffs von Transaktionen mit der Isolation SNAPSHOT TABLE STABILITY</listitem>
                    <listitem>Mit PROTECTED READ können gleichzeitige Transaktionen mit einer beliebigen Isolationsstufe nur 
                        aus den reservierten Tabellen gelesen werden</listitem>
                    <listitem>Mit PROTECTED WRITE können gleichzeitige Transaktionen in der SNAPSHOT- und READ COMMITTED-Isolation 
                        die angegebenen Tabellen lesen, aber nicht in diese schreiben. Der Zugriff von Transaktionen in der 
                        SNAPSHOT TABLE STABILITY-Isolation ist vollständig blockiert.</listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
              <tip>
                <para>In Embedded SQL kann die USING-Klausel verwendet werden, um Systemressourcen einzusparen, indem die Datenbanken 
                    beschränkt werden, auf die die Transaktion auf eine Aufzählungsliste (von Datenbanken) zugreifen kann. 
                    USING ist nicht kompatibel mit RESERVING. Eine USING-Klausel in der SET TRANSACTION-Syntax wird 
                    in DSQL nicht unterstützt.</para>
              </tip>
            </para>
          </section> <!-- options for RESERVING -->
        </section> <!-- RESERVING -->
      </section> <!-- transaction parameters -->
      <formalpara><title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-commit-de"><database>COMMIT</database></link>,
        <link linkend="fblangref25-transacs-rollback-de"><database>ROLLBACK</database></link></para>
      </formalpara>
    </section> <!-- SET TRANSACTION -->

    <section id="fblangref25-transacs-commit-de">
      <title><database>COMMIT</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Transaktion festschreiben</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
COMMIT [WORK] [TRANSACTION tr_name]
  [RELEASE] [RETAIN [SNAPSHOT]];
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-commit-de">
      <?dbfo keep-together='auto'?>
        <title>COMMIT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tr_name</entry>
              <entry align="left">Name der Transaktion. Nur in ESQL verfügbar</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die COMMIT-Anweisung schreibt alle Arbeiten fest, die im Zusammenhang mit dieser 
          Transaktion ausgeführt werden (Einfügen, Aktualisieren, Löschen, Auswählen, 
          Ausführen von Prozeduren). Neue Datensatzversionen werden für andere Transaktionen 
          verfügbar, und wenn die RETAIN-Klausel nicht verwendet wird, werden alle 
          Serverressourcen freigegeben, die ihrer Arbeit zugewiesen wurden.</para>
      <para>Wenn Konflikte oder andere Fehler in der Datenbank während des Festschreibens der 
          Transaktion auftreten, wird die Transaktion nicht festgeschrieben, und die Gründe werden 
          an die Benutzeranwendung zur Bearbeitung und der Möglichkeit, einen weiteren Commit zu 
          versuchen oder die Transaktion rückgängig zu machen, zurückgegeben.</para>

      <section id="fblangref25-transacs-commit-options-de">
        <title><database>COMMIT</database> Options</title>
        <itemizedlist>
          <listitem>
            <para>Die optionale Klausel <database>TRANSACTION &lt;tr_name&gt;</database>, die nur in Embedded SQL
            verfügbar ist, gibt den Namen der Transaktion an, die festgeschrieben werden soll. Ohne die Klausel 
            <database>TRANSACTION</database> wird COMMIT auf die Standardtransaktion angewendet.
              <note>
                <para>In ESQL-Anwendungen ermöglichen benannte Transaktionen die gleichzeitige Aktivierung mehrerer 
                    Transaktionen in einer Anwendung. Wenn benannte Transaktionen verwendet werden, muss eine hostspezifische 
                    Variable mit demselben Namen für jede benannte Transaktion deklariert und initialisiert werden. 
                    Dies ist eine Einschränkung, die die dynamische Angabe von Transaktionsnamen verhindert und daher die 
                    Transaktionsbenennung in DSQL ausschließt.</para>
              </note>
            </para>
          </listitem>

          <listitem>Das optionale Schlüsselwort <database>WORK</database> wird nur aus Kompatibilitätsgründen 
          mit anderen relationalen Datenbankverwaltungssystemen unterstützt, für die dies erforderlich ist.</listitem>

          <listitem>Das Schlüsselwort <database>RELEASE</database> ist nur in Embedded SQL verfügbar und ermöglicht 
          die Trennung von allen Datenbanken, nachdem die Transaktion festgeschrieben wurde. 
          <database>RELEASE</database> wird in Firebird nur zur Kompatibilität mit älteren Versionen von InterBase verwendet. 
          Es wurde in ESQL durch die Anweisung <database>DISCONNECT</database> ersetzt.</listitem>

          <listitem>
            <para>Die Klausel <database>RETAIN [SNAPSHOT]</database> wird für das <quote>weiche</quote> Festschreiben,
            verschiedentlich unter den Host-Sprachen und ihren Anwendern auch als <database>COMMIT WITH
            RETAIN</database>, CommitRetaining, <quote>warm commit</quote>, etc. bezeichnet. Die Transaktion ist festgeschrieben, 
            aber einige Serverressourcen bleiben erhalten, und die Transaktion wird transparent mit derselben 
            Transaktions-ID erneut gestartet. Der Status von Zeilencaches und Cursorn wird beibehalten wie vor dem Soft Commit.</para>
            <para>Für Soft-Committed-Transaktionen, deren Isolationsstufe SNAPSHOT oder SNAPSHOT TABLE STABILITY ist, wird 
                die Ansicht des Datenbankstatus nicht aktualisiert, um Änderungen durch andere Transaktionen widerzuspiegeln, 
                und der Benutzer der Anwendungsinstanz hat weiterhin dieselbe Ansicht wie beim ursprünglichen Start der Transaktion. 
                Änderungen, die während der Laufzeit der zurückbehaltenen Transaktion vorgenommen wurden, sind natürlich für 
                diese Transaktion sichtbar.</para>
          </listitem>
        </itemizedlist>
      </section> <!-- Commit options -->
      <note>
        <title>Empfehlung</title>
        <para>Die Verwendung der Anweisung <database>COMMIT</database> anstelle von <database>ROLLBACK</database> wird zum 
        Beenden von Transaktionen empfohlen, die nur Daten aus der Datenbank lesen, da <database>COMMIT</database>
        weniger Serverressourcen verbraucht und hilft damit bei der Optimierung der Performance nachfolgender Transaktionen.</para>
      </note>
      <formalpara><title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-settransac-de"><database>SET TRANSACTION</database></link>,
        <link linkend="fblangref25-transacs-rollback-de"><database>ROLLBACK</database></link></para>
      </formalpara>
    </section> <!-- commit -->

    <section id="fblangref25-transacs-rollback-de">
      <title><database>ROLLBACK</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Rollback einer Transaktion</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
ROLLBACK [WORK] [TRANSACTION tr_name]
[RETAIN [SNAPSHOT] | TO [SAVEPOINT] sp_name | RELEASE]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-rollback-de">
      <?dbfo keep-together='auto'?>
        <title>ROLLBACK Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tr_name</entry>
              <entry align="left">Name der Transaktion. Nur in ESQL verfügbar</entry>
            </row>
            <row valign="middle">
              <entry align="center">sp_name</entry>
              <entry align="left">Name des Sicherungspunkts. Nur in SQL verfügbar</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die ROLLBACK-Anweisung setzt alle im Zusammenhang mit dieser Transaktion ausgeführten Arbeiten zurück 
          (Einfügen, Aktualisieren, Löschen, Auswählen, Ausführen von Prozeduren). ROLLBACK schlägt niemals fehl 
          und verursacht daher niemals Ausnahmen. Wenn die RETAIN-Klausel nicht verwendet wird, werden alle 
          Serverressourcen freigegeben, die der Arbeit der Transaktion zugeordnet sind.</para>

      <section id="fblangref25-transacs-rollback-options-de">
        <title><database>ROLLBACK</database> Options</title>
        <itemizedlist>
          <listitem>
            <para>Die optionale Klausel <database>TRANSACTION &lt;tr_name&gt;</database>, die nur in Embedded SQL 
            verfügbar ist, gibt den Namen der Transaktion an, die festgeschrieben werden soll. Ohne 
            die Klausel <database>TRANSACTION</database> wird COMMIT auf die Standardtransaktion angewendet.
              <note>
                <para>In ESQL-Anwendungen ermöglichen benannte Transaktionen die gleichzeitige Aktivierung mehrerer 
                    Transaktionen in einer Anwendung. Wenn benannte Transaktionen verwendet werden, muss eine hostspezifische 
                    Variable mit demselben Namen für jede benannte Transaktion deklariert und initialisiert werden. 
                    Dies ist eine Einschränkung, die die dynamische Angabe von Transaktionsnamen verhindert und daher die 
                    Transaktionsbenennung in DSQL ausschließt.</para>
              </note>
            </para>
          </listitem>

          <listitem>Das optionale Schlüsselwort <database>WORK</database> wird nur aus Kompatibilitätsgründen mit 
          anderen relationalen Datenbankverwaltungssystemen unterstützt, für die dies erforderlich ist.</listitem>

          <listitem>
            <para>Das Schlüsselwort RETAIN gibt an, dass der Transaktionskontext beibehalten werden soll, obwohl 
                die gesamte Arbeit der Transaktion rückgängig gemacht werden soll. Einige Serverressourcen bleiben 
                erhalten und die Transaktion wird transparent mit derselben Transaktions-ID neu gestartet. Der Status 
                von Zeilencaches und Cursorn wird beibehalten, wie er vor dem <quote> weichen </quote> Rollback war.</para>

            <para>Für Transaktionen, deren Isolationsstufe SNAPSHOT oder SNAPSHOT TABLE STABILITY ist, wird die Ansicht 
                des Datenbankstatus nicht durch das Soft-Rollback aktualisiert, um Änderungen durch andere Transaktionen 
                widerzuspiegeln. Der Benutzer der Anwendungsinstanz hat weiterhin dieselbe Ansicht wie beim ursprünglichen 
                Start der Transaktion. Änderungen, die während der Laufzeit der zurückbehaltenen Transaktion vorgenommen 
                und während dieser abgeschlossen wurden, sind natürlich für diese Transaktion sichtbar.</para>
          </listitem>
        </itemizedlist>

        <formalpara><title>Siehe auch</title>
          <para>&nbsp;<link linkend="fblangref25-transacs-settransac-de"><database>SET TRANSACTION</database></link>,
          <link linkend="fblangref25-transacs-commit-de"><database>COMMIT</database></link></para>
        </formalpara>

        <section id="fblangref25-transacs-rollback-tosavepoint-de">
          <title><database>ROLLBACK TO SAVEPOINT</database></title>
          <para>Die optionale Klausel <database>TO SAVEPOINT</database> in der Anweisung <database>ROLLBACK</database> 
          gibt den Namen eines Sicherungspunkts an, auf den die Änderungen zurückgesetzt werden sollen. Der Effekt 
          besteht darin, alle in der Transaktion vorgenommenen Änderungen rückgängig zu machen, und zwar vom erstellten 
          Sicherungspunkt bis zu dem Zeitpunkt, an dem <database>ROLLBACK TO SAVEPOINT</database> angefordert wird.</para>
          <para> <database>ROLLBACK TO SAVEPOINT</database> führt die folgenden Operationen aus:
            <itemizedlist>
              <listitem>Alle Datenbankmutationen, die seit der Erstellung des Sicherungspunkts ausgeführt wurden, werden 
                  rückgängig gemacht. Benutzervariablen, die mit RDB$SET_CONTEXT() gesetzt wurden, bleiben unverändert.</listitem>

              <listitem>Alle Sicherungspunkte, die nach dem Namen erstellt wurden, werden zerstört. Savepoints, die älter als der 
                  angegebene sind, werden zusammen mit dem benannten Savepoint selbst beibehalten. Wiederholte Rollbacks zum selben 
                  Savepoint sind somit erlaubt.</listitem>

              <listitem>Alle impliziten und expliziten Datensatzsperren, die seit dem Speichern des Punkts erfasst wurden, werden freigegeben. 
                  Andere Transaktionen, die Zugriff auf nach dem Sicherungspunkt gesperrte Zeilen angefordert haben, müssen warten, bis die 
                  Transaktion festgeschrieben oder zurückgesetzt wurde. Andere Transaktionen, die die Zeilen noch nicht angefordert haben, 
                  können die entsperrten Zeilen sofort anfordern und darauf zugreifen.</listitem>
            </itemizedlist>
          </para>

          <formalpara><title>Siehe auch</title>
            <para>&nbsp;<link linkend="fblangref25-transacs-savepoint-de"><database>SAVEPOINT</database></link>
            </para>
          </formalpara>
        </section> <!-- rollback to savepoint -->

      </section> <!-- rollback options -->
    </section> <!-- rollback -->

    <section id="fblangref25-transacs-savepoint-de">
      <title><database>SAVEPOINT</database></title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Creating a savepoint</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;DSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
SAVEPOINT sp_name
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-savepoint-de">
      <?dbfo keep-together='auto'?>
        <title>SAVEPOINT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sp_name</entry>
              <entry align="left">Name des Sicherungspunkts Nur in SQL verfügbar</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Die Anweisung <database>SAVEPOINT</database> erstellt einen SQL: 99-konformen 
      Sicherungspunkt, der als Marker im <quote>stack</quote> der Datenaktivitäten innerhalb 
      einer Transaktion fungiert. Anschließend können die im <quote> stack </quote> ausgeführten 
      Tasks an diesen Savepoint rückgängig gemacht werden, wobei die frühere Arbeit und ältere 
      Savepoints unberührt bleiben. Savepoint-Mechanismen werden manchmal als 
      <quote>verschachtelte Transaktionen</quote> bezeichnet.</para>
      <para>Wenn bereits ein Sicherungspunkt mit demselben Namen wie der für den neuen bereitgestellte 
          Name vorhanden ist, wird der vorhandene Sicherungspunkt gelöscht und ein neuer unter 
          Verwendung des angegebenen Namens erstellt.</para>
      <para>Um Änderungen auf den Sicherungspunkt zurückzuspielen, wird die Anweisung 
          <database>ROLLBACK TO SAVEPOINT</database> verwendet.</para>
      <note>
        <title><database>Überlegungen zum Speicher</database></title>
        <para>Der interne Mechanismus unterhalb der Sicherungspunkte kann große Speichermengen verbrauchen, 
            insbesondere wenn die gleichen Zeilen mehrere Aktualisierungen in einer Transaktion erhalten. 
            Wenn ein Sicherungspunkt nicht mehr benötigt wird, aber die Transaktion noch Arbeit verrichtet, 
            wird die Anweisung <link linkend="fblangref25-transacs-releasesp-de">
                <database>RELEASE SAVEPOINT</database></link> diesen löschen und somit die belegten Ressourcen
                freigeben.
        </para>
      </note>
      <formalpara>
        <title>Beispiel einer DSQL-Sitzung mit Savepoints</title>
        <blockquote><programlisting>
     CREATE TABLE TEST (ID INTEGER);
      COMMIT;
      INSERT INTO TEST VALUES (1);
      COMMIT;
      INSERT INTO TEST VALUES (2);
      SAVEPOINT Y;
      DELETE FROM TEST;
      SELECT * FROM TEST; -- returns no rows
      ROLLBACK TO Y;
      SELECT * FROM TEST; -- returns two rows
      ROLLBACK;
      SELECT * FROM TEST; -- returns one row
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-rollback-tosavepoint-de"><database>ROLLBACK TO SAVEPOINT</database></link>,
        <link linkend="fblangref25-transacs-releasesp-de"><database>RELEASE SAVEPOINT</database></link></para>
      </formalpara>
    </section> <!-- savepoint statement -->

    <section id="fblangref25-transacs-releasesp-de">
      <title>RELEASE SAVEPOINT</title>
      <formalpara><title>Benutzt für</title>
        <para>&nbsp;Einen Sicherungspunkt löschen</para>
      </formalpara>
      <formalpara><title>Verfügbar in</title>
        <para>&nbsp;DSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
RELEASE SAVEPOINT sp_name [ONLY]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-rlssavepoint-de">
      <?dbfo keep-together='auto'?>
        <title>RELEASE SAVEPOINT-Statement-Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Beschreibung</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sp_name</entry>
              <entry align="left">Name des Sicherungspunkts. Nur in SQL verfügbar</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Die Anweisung <database>RELEASE SAVEPOINT</database> löscht einen benannten Savepoint 
      und gibt damit alle Ressourcen frei. Standardmäßig werden alle Sicherungspunkte, die nach dem 
      benannten Sicherungspunkt erstellt wurden, ebenfalls freigegeben. Der Qualifier <database>ONLY</database> 
      weist die Engine an, nur den benannten Savepoint freizugeben.</para>
      <formalpara>
        <title>Siehe auch</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-savepoint-de"><database>SAVEPOINT</database></link>
        </para>
      </formalpara>
    </section> <!-- release savepoint -->

    <section id="fblangref25-transacs-internalsp-de">
      <title>Interne Sicherungspunkte</title>
      <para>Standardmäßig verwendet die Engine einen automatischen Sicherungspunkt auf Transaktionsebene, 
          um Transaktionsrollbacks durchzuführen. Wenn eine Anweisung <database>ROLLBACK</database> ausgeführt 
          wird, werden alle in dieser Transaktion ausgeführten Änderungen über einen Sicherungspunkt auf 
          Transaktionsebene zurückgesetzt, und die Transaktion wird dann festgeschrieben. Diese Logik reduziert 
          die Menge an aufzuräumenden Müll (Garbage Collection), der durch zurückgerollte Transaktionen 
          verursacht wird.</para>
      <para>Wenn der Umfang der unter einem Sicherungspunkt auf Transaktionsebene durchgeführten Änderungen groß 
          wird (ca. 50000 betroffene Datensätze), gibt die Engine den Sicherungspunkt auf Transaktionsebene frei 
          und verwendet die Transaktionsinventarseite (TIP) als Mechanismus, um die Transaktion bei Bedarf 
          zurückzusetzen.</para>
      <tip>
        <para>Wenn Sie erwarten, dass der Umfang der Änderungen in Ihrer Transaktion groß ist, können Sie die 
            Option <database>NO AUTO UNDO</database> in Ihrer SET TRANSACTION-Anweisung angeben, um die 
            Erstellung des Sicherungspunkts auf Transaktionsebene zu blockieren. Mit der API würden Sie 
            stattdessen das TPB-Flag <function>isc_tpb_no_auto_undo</function> setzen.</para>
      </tip>
    </section>

    <section id="fblangref25-transacs-psqlandsp-de">
      <title>Sicherungspunkte und PSQL</title>
      <para>Transaktionssteueranweisungen sind in PSQL nicht zulässig, da dies die Atomität der Anweisung, die die 
          Prozedur aufruft, aufheben würde. Firebird unterstützt jedoch das Auslösen und Behandeln von Ausnahmen 
          in PSQL, sodass Aktionen, die in gespeicherten Prozeduren und Triggern ausgeführt werden, selektiv 
          rückgängig gemacht werden können, ohne dass die gesamte Prozedur fehlschlägt.</para>
      <para>Intern werden automatische Sicherungspunkte verwendet, um:
        <itemizedlist>
          <listitem>alle Aktionen im Block <database>BEGIN ... END</database> rückgängig zu machen, 
          bei dem eine Exception auftritt</listitem>
          <listitem>alle Aktionen rückgängig machen, die von der Prozedur oder dem Trigger ausgeführt 
              wurden, oder für eine auswählbare Prozedur alle Aktionen, die seit dem letzten SUSPEND 
              ausgeführt wurden, wenn die Ausführung aufgrund eines nicht erfassten Fehlers oder einer 
              Ausnahme vorzeitig beendet wird</listitem>
        </itemizedlist>
      </para>
      <para>Jeder PSQL-Exception-Behandlungsblock ist auch durch automatische System-Savepoints begrenzt.</para>
      <note>
        <para>Ein <database>BEGIN ... END</database>-Block erstellt keinen automatischen Sicherungspunkt. 
        Ein Sicherungspunkt wird nur in Blöcken erstellt, die die WHEN-Anweisung zur Behandlung von Ausnahmen enthalten.</para>
      </note>
    </section>
  </section> <!-- Transaction statements -->
</chapter>
