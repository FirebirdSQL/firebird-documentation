<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="fbdevgd30-php">
  <title>Developing Web Applications with PHP and Firebird</title>
  <para>In this chapter, we are going to create a web application using the 
  PHP language with Firebird as the back-end.   It is assumed that you have a 
  web server, such as Apache HTTP Server or Nginx with PHP installed and active 
  and a Firebird server available in the stack and running.  A lightweight, 
  stand-alone package such as 
  <ulink url="http://www.zachsaw.com/?pg=quickphp_php_tester_debugger">QuickPHP</ulink> 
  would be enough for testing and debugging your project locally.</para>
  <para>If your server supports PHP, you just create your .php files, put them
  in your web directory and the server will automatically parse them for you. 
  PHP-enabled files are simply HTML files with a whole language of custom tags 
  embedded in them. There is nothing to compile.</para>

  <section id="fbdevgd30-php-iface">
    <title>Interfacing PHP and Firebird</title>
    <para>To communicate with a Firebird database, you will need a
    driver.</para>

    <section id="fbdevgd30-php-drivers">
      <title>PHP Drivers for Firebird</title>
      <para>Two free, downloadable drivers are available for interfacing
      with Firebird:
        <itemizedlist>
          <listitem><para>The Firebird/Interbase extension (<function>ibase_</function> functions)</para></listitem>
          <listitem><para>The PDO driver for Firebird</para></listitem>
        </itemizedlist>
      </para>

      <section id="fbdevgd30-php-drivers-fbclient">
        <title>Firebird Client Library</title>
        <para>Both drivers require that you have the <filename>fbclient.dll</filename>
        client library installed (<filename>fbclient.so</filename> for POSIX systems).
        Make sure it is for the correct CPU register width (32-bit or 64-bit) to match
        that of your web server/PHP installation. For example, if you have a 64-bit
        machine running 64-bit Firebird and 32-bit Apache/PHP then you need the
        32-bit driver.
          <note>
            <title>Note to Win32/Win64 users</title>
            <para>For the drivers to work with the Windows PATH system variable,
            the <filename>fbclient.dll</filename> DLL file must be available. Copying
            the DLL file from the PHP directory or a Firebird installation to the
            Windows system folder would work, because the system directory is in the
            PATH variable by default. However, it is not recommended. The more robust
            way to do it is to prepend the file path to the PATH variable explicitly
            yourself, using the Windows advanced administration tool.</para>
          </note>
        </para>
        <para>Make sure you have the matching release version of the Firebird client for your
        Firebird server.</para>
      </section>

      <section id="fbdevgd30-php-drivers-ibase">
        <title>The Firebird/InterBase Extension</title>
        <para>The Firebird/Interbase (<quote>Fb/IB</quote>) extension predates the PDO driver
        and is regarded as the more proven solution of the two.</para>
        <para>To install the extension, uncomment this line in the php.ini configuration file:
          <literallayout class="monospaced">
  extension=php_interbase.dll
          </literallayout>
        or this line on Linux and other POSIX systems:
          <literallayout class="monospaced">
extension=php_interbase.so
          </literallayout>
        </para>

        <section id="fbdevgd30-php-drivers-ibase-linux">
          <title>Installing the Fb/IB Extension on Linux</title>
          <para>In Linux, one of the following commands should work.  The one you use depends
          on the distribution package and the versions it supports:
            <literallayout class="monospaced">
  apt-get install php5-firebird

  rpm -ihv php5-firebird

  yum install php70w-interbase

  zypper install php5-firebird
            </literallayout>
          </para>
          <tip>
            <para>You might need to enable third party repositories if you find you have
            unresolvable dependency problems.</para>
          </tip>
        </section>

        <section id="fbdevgd30-php-drivers-ibase-style">
          <title>Programming Style</title>
          <para>The Firebird/InterBase extension uses a procedural approach to developing
          programs. Functions with the <classname>ibase_</classname> prefix can return
          or accept the identifier (ID) of a connection, transaction, prepared query or cursor
          (the result of the SELECT query) as one of their parameters. This identifier
          is a server-allocated resource which, like all allocated resources, should
          be released immediately it is no longer needed.</para>
          <para>The PHP functions will not be described in detail here.  You can study their
          descriptions at <ulink url="http://php.net/ibase">http://php.net/ibase</ulink>.
          Several small examples with comments will be provided instead.
            <programlisting>
&lt;?php
$db = 'localhost:example';
$username = 'SYSDBA';
$password = 'masterkey';
// Connect to database
$dbh = ibase_connect($db, $username, $password);
$sql = 'SELECT login, email FROM users';
// Execute query
$rc = ibase_query($dbh, $sql);
// Get the result row by row as object
while ($row = ibase_fetch_object($rc)) {
  echo $row-&gt;email, &quot;\n&quot;;
}
// Release the handle associated with the result of the query
ibase_free_result($rc);
// Release the handle associated with the connection
ibase_close($dbh);
            </programlisting>
          </para>
        </section> <!-- fbdevgd30-php-drivers-ibase-style -->

        <section id="fbdevgd30-php-drivers-ibase-connect">
          <title>The ibase_ Connect Functions</title>
          <para>The <classname>ibase_pconnect</classname> function, that creates so-called <quote>persistent
          connections</quote>, could be used instead of <classname>ibase_connect</classname>.
          A call to <classname>ibase_close</classname> on this style of connection does not close it
          but all resources allocated to it will be released. The default transaction is committed,
          while any others are rolled back. This type of connection can be re-used in another session
          if the connection parameters match.</para>
          <para>Persistent connections can increase the performance of a web application, sometimes
          considerably. It is especially noticeable if establishing a connection involves a lot of
          traffic. They allow a child process to use the same connection throughout its entire
          lifetime instead of creating a connection every time a page interacts with the Firebird
          server.  Persistent connections are not unlike working with a connection pool.</para>
          <para>You can find more details about persistent connections at
          <ulink url="http://php.net/persistent-connections">http://php.net/persistent-connections</ulink>.
          </para>
          <warning>
            <title>Need to know</title>
            <para>Many ibase_ functions cannot accommodate the identifier of a connection, transaction
            or prepared query. Those functions use the identifier of the last established connection
            or last started transaction instead of the relevant identifier. Ii is not a recommended
            practice, especially if your web application can use more than one connection.</para>
          </warning>
        </section>

        <section id="fbdevgd30-php-drivers-ibase-query">
          <title>ibase_query</title>
          <para>The ibase_query function executes an SQL query and returns the identifier of the
          result or True if the query returns no data set. Along with the connection or transaction
          ID and the text of the SQL query, this function can accept a variable number of parameters
          to populate the SQL query parameters. For example,
            <programlisting>
// &#x2026;
$sql = 'SELECT login, email FROM users WHERE id=?';
$id = 1;
// Execute query
$rc = ibase_query($dbh, $sql, $id);
// Get the result row by row as object
if ($row = ibase_fetch_object($rc)) {
  echo $row-&gt;email, &quot;\n&quot;;
}
// Release the handle associated with the result of the query
ibase_free_result($rc);
// &#x2026;
            </programlisting>
          </para>
          <para>Parameterized queries are typically used multiple times with fresh sets 
          of parameter values each time. Prepared queries are recommended for this style 
          of usage. The identifier of a query is returned by the function <classname>ibase_prepare</classname>
          and then the prepared query is executed using the function ibase_execute.
            <programlisting>
// &#x2026;
$sql = 'SELECT login, email FROM users WHERE id=?';
// Prepare statement
$sth = ibase_prepare($dbh, $sql);
$id = 1;
// Execute statement
$rc = ibase_execute($sth, $id);
// Get the result row by row as object
if ($row = ibase_fetch_object($rc)) {
  echo $row-&gt;email, &quot;\n&quot;;
}
// Release the handle associated with the result of the query
ibase_free_result($rc);
// Release the prepared statement
ibase_free_query($sth);
            </programlisting>
          </para>
          <para>Prepared queries are very often used when a large amount of data 
          input is anticipated.
            <programlisting>
// &#x2026;
$sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
// Prepare statement
$sth = ibase_prepare($dbh, $sql);
$users = [[&quot;user1&quot;, &quot;user1@gmail.com&quot;], [&quot;user2&quot;, &quot;user2@gmail.com&quot;]];
// Execute statement
foreach ($users as $user)) {
  ibase_execute($sth, $user[0], $user[1]);
}
// Release the prepared statement
ibase_free_query($sth);
// &#x2026;
            </programlisting>
          </para>
          <para>It is actually a disadvantage of this extension that functions can take a variable
          number of parameters.  It less than ideal for parameterized queries, as the last example
          demonstrates. It is especially noticeable if you try to write a universal class for
          executing any query. It would be much more useful to be able to send parameters in
          one array.</para>
          <para>This would be one way to get around it:
            <programlisting>
function fb_execute ($stmt, $data)
{
  if (!is_array($data))
    return ibase_execute($stmt, $data);
  array_unshift($data, $stmt);
  $rc = call_user_func_array('ibase_execute', $data);
  return $rc;
}
            </programlisting>
          </para>
          <para>The Fb/IB extension does not support named parameters in queries.</para>
        </section> <!-- fbdevgd30-php-drivers-ibase-query -->

        <section id="fbdevgd30-php-drivers-ibase-trans">
          <title>ibase_trans</title>
          <para>By default, the Fb/IB extension commits the transaction automatically after
          executing each SQL query, making it necessary to start a transaction with the
          function <classname>ibase_trans</classname> if you need to control transactions
          explicitly. An explicit transaction is started with the following parameters
          if none are provided: IBASE_WRITE | IBASE_CONCURRENCY | IBASE_WAIT.  You can
          find the description of predefined constants for specifying the parameters of a
          transaction <ulink url="http://php.net/manual/en/ibase.constants.php">here</ulink>.
          A transaction must be completed by either <classname>ibase_commit</classname> or
          <classname>ibase_rollback</classname>.</para>
          <para>This extension supports the COMMIT RETAIN and ROLLBACK RETAIN parameters
          directly if you use the functions <classname>ibase_commit</classname>_ret or
          <classname>ibase_rollback_ret</classname>, respectively, instead.</para>
          <note>
            <para>The default transaction parameters are good for most cases and it is
            really rarely that you need to change them. A connection to the database,
            along with all resources allocated to it, exists for no longer than it
            takes for the PHP script to complete. Even if you use persistent connections,
            all allocated resources will be released after the <classname>ibase_close</classname>
            function is called. Even so, I strongly recommend releasing all allocated
            resources explicitly by calling the corresponding ibase_ functions.</para>
            <para>I advise strongly against using the <classname>ibase_commit_ret</classname>
            and <classname>ibase_rollback_ret</classname> functions because they have
            no place in a web application. The purpose of COMMIT RETAIN and ROLLBACK
            RETAIN is to keep cursors open in desktop applications when a transaction
            ends.</para>
          </note>
          <programlisting>
$sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
// Prepare statement
$sth = ibase_prepare($dbh, $sql);
$users = [[&quot;user1&quot;, &quot;user1@gmail.com&quot;], [&quot;user2&quot;, &quot;user2@gmail.com&quot;]];
$trh = ibase_trans($dbh, IBASE_WRITE | IBASE_CONCURRENCY | IBASE_WAIT);
try {
  // Execute statement
  foreach ($users as $user)) {
    $r = ibase_execute($sth, $user[0], $user[1]);
    // If an error occurs, throw an exception
    if ($r === false)
      throw new \Exception(ibase_errmsg());
  }
  ibase_commit($trh);
}
catch(\Exception $e) {
  ibase_rollback($trh);
  echo $e-&gt;getMessage();
}
// Release the prepared statement
ibase_free_query($sth);
          </programlisting>
          <warning>
            <para>ibase_ functions raise no exception if an error occurs, although
            an error will cause some to return False. Note that it is essential to
            use the <code>===</code> strict relational operator to compare the
            result to False. Calling any ibase function could result in an error.</para>
            <para>The function <classname>ibase_errmsg</classname> is available to discover
            an error message and the function ibase_errcode can provide the error
            code.</para>
          </warning>
        </section> <!-- fbdevgd30-php-drivers-ibase-trans -->

        <section id="fbdevgd30-php-drivers-ibase-svcs">
          <title>Services API Calls</title>
          <para>The Fb/IB extension can interact with the Firebird server by way of
          functions that wrap calls to the Services API: <classname>ibase_service_attach,
          ibase_service_detach, ibase_server_info, ibase_maintain_db, ibase_db_info,
          ibase_backup, ibase_restore</classname>. They can return information about
          the Firebird server, initiate a backup or restore or get statistics.
          We are not examining them in detail, since they are required mainly to
          administer a database, a topic that is outside the scope of this project.</para>
        </section>

        <section id="fbdevgd30-php-drivers-ibase-events">
          <title>Firebird Events</title>
          <para>The Firebird/Interbase extension also supports working with Firebird
          events by means of a set of functions: <classname>ibase_set_event_handler,
          ibase_free_event_handler, ibase_wait_event</classname>.</para>
        </section>
      </section> <!-- fbdevgd30-php-drivers-ibase -->

      <section id="fbdevgd30-php-drivers-pdo">
        <title>The PDO (Firebird Driver)</title>
        <para>The PDO extension is a common interface for accessing various types of 
        databases. Each database driver that implements this interface can provide 
        database-specific features in the form of standard extension functions.</para>
        <para>PDO and all basic drivers are built into PHP as extensions. To use them, 
        just enable them by editing the php.ini file as follows:
          <literallayout class="monospaced">
  extension=php_pdo.dll
          </literallayout>
          <note>
            <para>This step is optional for PHP versions 5.3 and higher because DLLs 
            are no longer needed for PDO to work.</para>
          </note>
        </para>

      <section id="fbdevgd30-php-drivers-pdo-fbspec">
        <title>Firebird-specific Library</title>
        <para>The other requirement is for database-specific DLLs to be configured; or else 
        loaded during execution by means of the <classname>dl()</classname> function; 
        or else included in <filename>php.ini</filename> following php_pdo.dll. 
        For example:
          <literallayout class="monospaced">
  extension=php_pdo.dll
  extension=php_pdo_firebird.dll
            </literallayout>
          These DLLs must be in the directory <filename>extension_dir</filename>.</para>
          <para>In Linux, one of the following commands should work.  The one you use
          depends on the distribution package and the versions it supports:
          <literallayout class="monospaced">
  apt-get install php5-firebird

  rpm -ihv php5-firebird

  yum install php70w-firebird

  zypper install php5-firebird
            </literallayout>
          </para>  
        </section>

        <section id="fbdevgd30-php-drivers-pdo-style">
          <title>Programming Style</title>
          <para>PDO uses an object-oriented approach to developing programs. The DSN (Data 
          Source Name), a.k.a. connection string, determines which specific driver will be used in 
          PDO. The DSN consists of a prefix that determines the database type and a set of 
          parameters in the form of <function>&lt;key&gt;=&lt;value&gt;</function> separated 
          by semicolons. The valid set of parameters depends on the database type.</para>

          <para>To be able to work with Firebird, the connection string must start with the
          <code>firebird:</code> prefix and conform to the format described in the 
          <ulink url="http://php.net/manual/en/ref.pdo-firebird.connection.php">PDO_FIREBIRD DSN section</ulink> 
          of the documentation.</para>
        </section>

        <section id="fbdevgd30-php-drivers-pdo-connxn">
          <title>Making Connections</title>
          <para>Connections are established automatically during creation of the PDO from
          its abstract class. The class constructor accepts parameters to specify the data 
          source (DSN) and also the optional username and password, if any. A fourth 
          parameter can be used to pass an array of driver-specific connection settings 
          in the <function>key=value</function> format.
            <programlisting>
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Connect to database
  $dbh = new \PDO($dsn, $username, $password,
                  [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]);
  $sql = 'SELECT login, email FROM users';
  // Execute query
  $query = $dbh-&gt;query($sql);
  // Get the result row by row as object
  while ($row = $query-&gt;fetch(\PDO::FETCH_OBJ)) {
    echo $row-&gt;email, &quot;\n&quot;;
  }
  $query-&gt;closeCursor();
} catch (\PDOException $e) {
  echo $e-&gt;getMessage();
}
            </programlisting>
          </para>
          <note>
            <title>Persistent connections</title>
            <para>For PDO to use persistent connections, the array of attributes must
            be passed to the PDO constructor with <function>PDO::ATTR_PERSISTENT =&gt; true</function>.</para>
          </note>
        </section> <!-- fbdevgd30-php-drivers-pdo-connxn -->

        <section id="fbdevgd30-php-drivers-pdo-excptns">
          <title>Exception Handling</title>
          <para>The PDO driver is much more friendly than the Firebird/InterBase extension
          with respect to exception handling. Setting the <classname>\PDO::ATTR_ERRMODE</classname> 
          attribute to the value <classname>\PDO::ERRMODE_EXCEPTION</classname> 
          specifies a mode in which any error, including a database connection error, 
          will raise the exception <classname>\PDOException</classname>.</para>
          <para>This is superior to the laborious procedure of checking whether an error 
          has occurred each time an ibase_ function is called.</para>
        </section>

        <section id="fbdevgd30-php-drivers-pdo-querying">
          <title>Querying</title>
          <para>The <classname>query</classname> method executes an SQL query and returns 
          the result set in the form of a <classname>\PDOStatement</classname> object.
          A fetch to this method can return the result in more than one form: it could be a 
          column, an instance of the specified class, an object.</para> 
          <para>The various ways of calling query can be found in the 
          <ulink url="http://php.net/manual/en/pdo.query.php">documentation</ulink>.</para>

          <section id="fbdevgd30-php-drivers-pdo-exec">
            <title>Queries with No Data Set</title>
            <para>For executing an SQL query that returns no data set, you can use the
            <ulink url="http://php.net/manual/en/pdo.exec.php">exec method</ulink>
            that returns the number of affected rows.</para>
            <para>Executing prepared queries is not supported by <classname>exec</classname>.
            </para>
          </section>
          
          <section id="fbdevgd30-php-drivers-pdo-paramq1">
            <title>Parameterized Queries</title>
            <para>If there are parameters in the query, prepared queries must be used.
            For this, the <classname>prepare</classname> method is called instead of the 
            <classname>query</classname> method. The <classname>prepare</classname> method 
            returns an object of the <classname>\PDOStatement</classname> class that 
            encapsulates methods for working with prepared queries and their results. 
            Executing the query requires calling the <classname>execute</classname> 
            method that can accept as its parameter an array of named or unnamed 
            parameters.</para>
            <para>The result of executing a <database>SELECT</database> query can be obtained
            with one the following methods: <classname>fetch, fetchAll, fetchColumn, 
            fetchObject</classname>. The <classname>fetch</classname> and <classname>fetchAll</classname> 
            methods can return results in various forms: an associative array, an object 
            or an instance of a particular class. The class instance option is quite often 
            used in the MVC pattern during work with models.
              <programlisting>
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Connect to database
  $dbh = new \PDO($dsn, $username, $password,
                  [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
  $users = [
    [&quot;user1&quot;, &quot;user1@gmail.com&quot;],
    [&quot;user2&quot;, &quot;user2@gmail.com&quot;]
  ];
  // Prepare statement
  $query = $dbh-&gt;prepare($sql);
  // Execute statement
  foreach ($users as $user)) {
    $query-&gt;execute($user);
  }
} catch (\PDOException $e) {
  echo $e-&gt;getMessage();
}
              </programlisting>
            An example using named parameters:
              <programlisting>
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Connect to database
  $dbh = new \PDO($dsn, $username, $password,
                  [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(:login, :email)';
  $users = [
    [&quot;:login&quot; =&gt; &quot;user1&quot;, &quot;:email&quot; =&gt; &quot;user1@gmail.com&quot;],
    [&quot;:login&quot; =&gt; &quot;user2&quot;, &quot;:email&quot; =&gt; &quot;user2@gmail.com&quot;]
  ];
  // Prepare statement
  $query = $dbh-&gt;prepare($sql);
  // Execute statement
  foreach ($users as $user)) {
    $query-&gt;execute($user);
  }
} catch (\PDOException $e) {
  echo $e-&gt;getMessage();
}
              </programlisting>
              <note>
                <para>In order to support named parameters, PDO preprocesses the query and 
                replaces parameters of the :paramname type with &quot;?&quot;, retaining 
                the array of correspondence between the parameter names and their left-to-right 
                positions in the query. For that reason, the <database>EXECUTE BLOCK</database> 
                statement will not work if there are colon-prefixed variables. 
                Currently, PDO offers no workaround to support a parameterized EXECUTE 
                BLOCK statement, such as by specifying an alternative prefix for parameters 
                as has been implemented in some access components.</para>
              </note>
            </para>
            <section id="fbdevgd30-php-drivers-pdo-paramq2">
              <title>Another Way to Do It</title>
              <para>An alternative way to pass parameters to a query is by using 
              <quote>binding</quote>. The <classname>bindValue</classname> method binds a 
              value to a named or unnamed parameter. The <classname>bindParam</classname> 
              method binds a variable to a named or unnamed parameter. The 
              <classname>bindParam</classname> method is especially useful for stored 
              procedures that return a value via the OUT or IN OUT parameter, which is 
              different to the mechanism for returning values from stored procedures in 
              Firebird.
                <programlisting>
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Connect to database
  $dbh = new \PDO($dsn, $username, $password,
                  [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(:login, :email)';
  $users = [
    [&quot;user1&quot;, &quot;user1@gmail.com&quot;],
    [&quot;user2&quot;, &quot;user2@gmail.com&quot;]
  ];
  // Prepare statement
  $query = $dbh-&gt;prepare($sql);
  // Execute statement
  foreach ($users as $user)) {
    $query-&gt;bindValue(&quot;:login&quot;, $user[0]);
    $query-&gt;bindValue(&quot;:email&quot;, $user[1]);
    $query-&gt;execute();
  }
} catch (\PDOException $e) {
  echo $e-&gt;getMessage();
}
                </programlisting>
                <warning>
                  <title>Caution</title>
                  <para>The numbers associated with unnamed parameters for the bindParam 
                  and bindValue methods start from 1.</para>
                </warning>
              </para>
              <para>
                <programlisting>
$dsn = 'firebird:dbname=localhost:example;charset=utf8;';
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Connect to database
  $dbh = new \PDO($dsn, $username, $password,
                  [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]);
  $sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
  $users = [
    [&quot;user1&quot;, &quot;user1@gmail.com&quot;],
    [&quot;user2&quot;, &quot;user2@gmail.com&quot;]
  ];
  // Prepare statement
  $query = $dbh-&gt;prepare($sql);
  // Execute statement
  foreach ($users as $user)) {
    $query-&gt;bindValue(1, $user[0]);
    $query-&gt;bindValue(2, $user[1]);
    $query-&gt;execute();
  }
} catch (\PDOException $e) {
  echo $e-&gt;getMessage();
}
                </programlisting>
              </para>
            </section> <!-- fbdevgd30-php-drivers-pdo-paramq2 -->
          </section> <!-- fbdevgd30-php-drivers-pdo-paramq1 -->
        </section>  <!-- fbdevgd30-php-drivers-pdo-querying -->

        <section id="fbdevgd30-php-drivers-pdo-txn">
          <title>Transactions</title>
          <para>By default, PDO commits the transaction automatically after executing
          each SQL query.  If you want to control transactions explicitly, you need to
          start a transaction with the method <classname>\PDO::beginTransaction</classname>.
          By default, a transaction is started with the following parameters:
          CONCURRENCY | WAIT | READ_WRITE. A transaction can be ended with the
          <classname>\PDO::commit</classname> or <classname>\PDO::rollback</classname>
          method.
            <programlisting>
$username = 'SYSDBA';
$password = 'masterkey';
try {
  // Connect to database
  $dbh = new \PDO($dsn, $username, $password,
                  [\PDO::ATTR_ERRMODE =&gt; \PDO::ERRMODE_EXCEPTION]);
  // Start the transaction to ensure consistency between statements
  $dbh-&gt;beginTransaction();
  // Get users from one table
  $users_stmt = $dbh-&gt;prepare('SELECT login, email FROM old_users');
  $users_stmt-&gt;execute();
  $users = $users_stmt-&gt;fetchAll(\PDO::FETCH_OBJECT);
  $users_stmt-&gt;closeCursor();
  // And insert into another table
  $sql = 'INSERT INTO users(login, email) VALUES(?, ?)';
  // Prepapre statemenet
  $query = $dbh-&gt;prepare($sql);
  // Execute statememt
  foreach ($users as $user)) {
    $query-&gt;bindValue(1, $user-&gt;LOGIN);
    $query-&gt;bindValue(2, $user-&gt;EMAIL]);
    $query-&gt;execute();
  }
  // Commit transaction
  $dbh-&gt;commit();
} catch (\PDOException $e) {
  // Rollback transaction
  if ($dbh &amp;&amp; $dbh-&gt;inTransaction())
    $dbh-&gt;rollback();
  echo $e-&gt;getMessage();
}
            </programlisting>
          </para>
          <section id="fbdevgd30-php-drivers-pdo-txn-chg-params">
            <title>Changing Transaction Parameters</title>
            <para>Unfortunately, the <classname>beginTransaction</classname> method
            does not permit transaction parameters to be changed, but you can do the
            trick by specifying transaction parameters in the SQL statement
            <database>SET TRANSACTION</database>.
              <programlisting>
$dbh = new \PDO($dsn, $username, $password);
$dbh-&gt;setAttribute(\PDO::ATTR_AUTOCOMMIT, false);
$dbh-&gt;exec(&quot;SET TRANSACTION READ ONLY ISOLATION LEVEL READ COMMITTED NO WAIT&quot;);
// Perform actions in the transaction
// &#x2026;
$dbh-&gt;exec(&quot;COMMIT&quot;);
$dbh-&gt;setAttribute(\PDO::ATTR_AUTOCOMMIT, true);
              </programlisting>
            </para>
          </section>
        </section>  <!-- fbdevgd30-php-drivers-pdo-txn -->
      </section>  <!-- fbdevgd30-php-drivers-pdo -->
    </section> <!-- fbdevgd30-php-drivers -->
    
    <section id="fbdevgd30-php-drivers-compare">
      <title>Comparing the Drivers</title>
      <para>The following table summarises the capabilities offered by the two drivers 
      for working with Firebird.</para>
      <table id="fbdg30-php-tbl-drivers-compare">
      <?dbfo keep-together='auto'?>
        <title>Comparing the Firebird/InterBase and PDO Drivers</title>
        <tgroup cols="2">
          <colspec colname="colCap" colwidth="1*"></colspec>
          <colspec colname="colDriver1" colwidth="1*"></colspec>
          <colspec colname="colDriver2" colwidth="1*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Capability</entry>
              <entry align="center">Fb/IB Extension</entry>
              <entry align="center">PDO Extension</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="left">Programming paradigm</entry>
              <entry align="left">Procedural</entry>
              <entry align="left">Object-oriented</entry>
            </row>
            <row valign="middle">
              <entry align="left">Supported database engines</entry>
              <entry align="left">Firebird and InterBase; or clones of either</entry>
              <entry align="left">Any database engine for which there is a PDO driver, including Firebird</entry>
            </row>
            <row valign="middle">
              <entry align="left">Handling query parameters</entry>
              <entry align="left">Only unnamed parameters, not very convenient because
              the functions used allow the number of parameters to be variable</entry>
              <entry align="left">Can work with both named and unnamed parameters. Very convenient
              although some Firebird features (the EXECUTE BLOCK statement) do not work.</entry>
            </row>
            <row valign="middle">
              <entry align="left">Error handling</entry>
              <entry align="left">Requires checking the results of the ibase_errmsg,
              ibase_errcode functions. An error may occur after any ibase_ function call
              without raising any exception.</entry>
              <entry align="left">An optional mode is provided to raise exceptions on any error</entry>
            </row>
            <row valign="middle">
              <entry align="left">Transaction management</entry>
              <entry align="left">Allows transaction parameters to be specified</entry>
              <entry align="left">Does not allow transaction parameters to be specified.
              Workaround: execute the SQL statement SET TRANSACTION.</entry>
            </row>
            <row valign="middle">
              <entry align="left">Firebird-specific features</entry>
              <entry align="left">Supports work with the Services API (backup, restore,
              statistics, etc.) and with database events</entry>
              <entry align="left">Does not support any database-specific feature that
              cannot be implemented directly using an SQL statement</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>From these comparisons we can conclude that PDO is better equipped than the 
      FB/IB extension for most frameworks.</para>
    </section>   <!-- fbdevgd30-php-drivers-compare -->
  </section>  <!-- fbdevgd30-php-iface -->

  <section id="fbdevgd30-php-framework">
    <title>Choosing a Framework for Building a Web Application</title>
    <para>Small websites can be developed without using the MVC pattern. However, the 
    larger your website gets, the more complicated it becomes to maintain, especially if 
    more than one person is working on it. Hence, this is the  pattern we are going 
    to use for developing our web application.</para>
    <para>Having decided to use the MVC pattern, we do have a few issues to think about.
    Development of an application modeled on this pattern is not so easy as it may seem, 
    especially if we do not use third-party libraries. If you write everything on your 
    own, you will have to solve a lot of problems: automatically loading <filename>.php</filename> 
    files enabling the definition of classes, routing, and so on.</para>
    <para>Several frameworks have been created for solving these problems, such as Yii, 
    Laravel, Symphony, Kohana and many more. My personal preference is Laravel, so the 
    development of the application described here is going to use this framework.</para>
  </section>
  
  <section id="fbdevgd30-php-Laravel">
    <title>Installing Laravel</title>
    <para>Before installing Laravel, make sure that your system environment
    meets the requirements.
      <itemizedlist>
        <listitem><para>PHP &gt;= 5.5.9</para></listitem>
        <listitem><para>PDO extension</para></listitem>
        <listitem><para>MCrypt extension</para></listitem>
        <listitem><para>OpenSSL extension</para></listitem>
        <listitem><para>Mbstring extension</para></listitem>
        <listitem><para>Tokenizer extension</para></listitem>
      </itemizedlist>
    </para>

    <section id="fbdevgd30-php-composer">
      <title>Installing Composer</title>
      <para>Laravel uses <ulink url="https://getcomposer.org/">Composer</ulink> to
      manage dependencies. Install Composer first and then install Laravel.</para>
      <para>The easiest way to install Composer on Windows is by downloading and
      running the installation file:
      <ulink url="https://getcomposer.org/Composer-Setup.exe">Composer-Setup.exe</ulink>.
      The installation wizard will install Composer and configure PATH so that
      you can run Composer from the command line in any directory.</para>

      <para>If you need to install Composer manually, go to
      <ulink url="https://getcomposer.org/download/">https://getcomposer.org/download/</ulink>
      and pick up a fresh installation script that will do 
      as follows:
        <itemizedlist spacing="compact">
          <listitem><para>Downloads the installation file to the current directory</para></listitem>
          <listitem><para>Checks the installation file using SHA-384</para></listitem>
          <listitem><para>Runs the installation script</para></listitem>
          <listitem><para>Removes the installation script</para></listitem>
        </itemizedlist>
        <warning>
          <title>Caution</title>
          <para>Because this script changes with each new version of the installer, 
          you will always need to have the latest version when reinstalling.</para>
        </warning>
      </para>
      <para>After you run the script, the <filename>composer.phar</filename> file will appear.
      The <filename>.phar</filename> extension marks an archive but, actually, it is a PHP script
      that can understand only a few commands (install, update, ...) and can download and
      unpack libraries.</para>
      <note>
        <title>Windows</title>
        <para>If you are working in Windows, you can make it easier to work with Composer 
        by creating the <filename>composer.bat</filename> file. Run the following command:
          <literallayout class="monospaced">
  echo @php &quot;%~dp0composer.phar&quot; %*&gt;composer.bat
          </literallayout>
         Then set up your PATH so that you can just call <code>composer</code> from any 
         directory in your command shell. </para>
      </note>
      <para>More details about installing Composer are available 
      <ulink url="https://getcomposer.org/doc/00-intro.md">here</ulink>.</para>
    </section>

    <section id="fbdevgd30-php-Laravel-install">
      <title>Installing Laravel</title>
      <para>Now, to install Laravel:
        <literallayout class="monospaced">
  composer global require &quot;laravel/installer&quot;
        </literallayout>
      </para>
    </section>
  </section> <!-- fbdevgd30-php-Laravel -->

  <section id="fbdevgd30-php-Laravel-crt-project">
    <title>Creating a Project</title>
    <para>If the installation is successful, we can carry on with creating the
    project framework. Enter:
      <literallayout class="monospaced">
  laravel new fbexample
      </literallayout>
    Wait until it finishes creating the project framework. A description of the
    directory structure can be found in the
    <ulink url="http://laravel.su/docs/5.2/structure">Laravel documentation</ulink>.
    </para>

    <section id="fbdevgd30-php-Laravel-project-struct">
      <title>Our Project's Structure</title>
      <para>These are the directories we are most interested in:
        <itemizedlist>
          <listitem>
            <para><filename>app</filename>&#x2014;the main directory of our application. Models will be
            located in the root directory. The <filename>Http</filename> subdirectory contains
            everything that is related to working with the browser. The <filename>Http/Controllers</filename>
            subdirectory contains our controllers.</para>
          </listitem>
          <listitem>
            <para><filename>config</filename>&#x2014;the directory with configuration files. You will
            discover more details about the configuration process later.</para>
          </listitem>
          <listitem>
            <para><filename>public</filename>&#x2014;the root directory of the web application
            (DocumentRoot). It contains static files: css, js, images, etc.</para>
          </listitem>
          <listitem>
            <para><filename>resources</filename>&#x2014;contains views, localization files
            and, if any, LESS files, SASS and js applications on such frameworks as ReactJS,
            AngularJS or Ember that are later put together into the public folder with an
            external tool.</para>
          </listitem>
          <listitem>
            <para>The root directory of our application contains the <filename>composer.json</filename>
            file that describes the packages our application will need besides those that are already
            present in Laravel.</para>
            <para>We will need two such packages:
            <ulink url="https://github.com/zofe/rapyd-laravel">zofe/rapyd-laravel</ulink> for building
            a quick interface with grids and edit dialog boxes, and
            <ulink url="https://github.com/sim1984/laravel-firebird">sim1984/laravel-firebird</ulink>,
            an extension for working with Firebird databases.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>The <filename>sim1984/laravel-firebird</filename> package is the author's fork of the
      <filename>jacquestvanzuydam/laravel-firebird</filename> package. Its installation is a bit
      different. A description of how the package differs from the original is available in the 
      article 
  <ulink url="https://habrahabr.ru/post/312874/">Package for working with the Firebird DBMS in Laravel</ulink>
  if you can read Russian.  An English-language description of the packages and the changes from the
      original can be found in the readme.md document at this URL:
 <ulink url="https://github.com/sim1984/laravel-firebird">https://github.com/sim1984/laravel-firebird</ulink>.
      </para>
      <warning>
        <title>Caution</title>
        <para>Remember to set the minimum-stability parameter to 'dev' because the package is not
        stable enough to publish at https://packagist.org.  You will need to modify the
        composer.json file (see below) to add a reference to the gitHub repository.
        </para>
      </warning>

      <para>In the file <filename>composer.json</filename>:
        <literallayout class="monospaced">
  &quot;repositories&quot;: [
    {
      &quot;type&quot;: &quot;package&quot;,
      &quot;package&quot;: {
        &quot;version&quot;: &quot;dev-master&quot;,
        &quot;name&quot;: &quot;sim1984/laravel-firebird&quot;,
        &quot;source&quot;: {
          &quot;url&quot;: &quot;https://github.com/sim1984/laravel-firebird&quot;,
          &quot;type&quot;: &quot;git&quot;,
          &quot;reference&quot;: &quot;master&quot;
        },
        &quot;autoload&quot;: {
          &quot;classmap&quot;: [&quot;&quot;]
        }
      }
    }
  ],
        </literallayout>
      </para>
      <para>Use the <function>require</function> section to add the required packages
      in the following way:
        <literallayout class="monospaced">
  &quot;zofe/rapyd&quot;: &quot;2.2.*&quot;,
  &quot;sim1984/laravel-firebird&quot;: &quot;dev-master&quot;
        </literallayout>
      </para>
      <para>Now you can start updating the packages with the following command, which
      must be started in the root directory of the web application:
        <literallayout class="monospaced">
  composer update
        </literallayout>
      On completion of that command, the new packages will be installed in your
      application.</para>
    </section> <!-- fbdevgd30-php-Laravel-project-struct -->

    <section id="fbdevgd30-php-Laravel-project-config">
      <title>Configuration</title>
      <para>Now we can get down to configuration. To get it started, execute the following
      command to create additional configuration files for the zofe/rapyd package:
        <literallayout class="monospaced">
  php artisan vendor:publish
        </literallayout>
      </para>
      <para>We add two new providers to the file <filename>config/app.php</filename>
      by adding two new entries to the <function>providers</function> key:
        <literallayout class="monospaced">
  Zofe\Rapyd\RapydServiceProvider::class,
  Firebird\FirebirdServiceProvider::class,
        </literallayout>
      </para>
      <para>We proceed to the file <filename>config/databases.conf</filename> (not to be confused
      with databases.conf in your Firebird server root!) that contains the database connection
      settings. Add the following lines to the <function>connections</function> key:
          <literallayout class="monospaced">
  'firebird' =&gt; [
    'driver' =&gt; 'firebird',
    'host' =&gt; env('DB_HOST', 'localhost'),
    'port' =&gt; env('DB_PORT', '3050'),
    'database' =&gt; env('DB_DATABASE', 'examples'),
    'username' =&gt; env('DB_USERNAME', 'SYSDBA'),
    'password' =&gt; env('DB_PASSWORD', 'masterkey'),
    'charset' =&gt; env('DB_CHARSET', 'UTF8'),
    'engine_version' =&gt; '3.0.0',
  ],
        </literallayout>
      </para>
      <para>Since we will use our connection as the default connection, specify
      the following:
        <literallayout class="monospaced">
  'default' =&gt; env('DB_CONNECTION', 'firebird'),
        </literallayout>
      </para>
      <para>Pay attention to the <function>env</function> function that is used to read the
      environment variables of the application from the special <filename>.env</filename> file
      located in the root directory of the project. Correct the following lines in the .env file:
        <literallayout class="monospaced">
  DB_CONNECTION=firebird
  DB_HOST=localhost
  DB_PORT=3050
  DB_DATABASE=examples
  DB_USERNAME=SYSDBA
  DB_PASSWORD=masterkey
        </literallayout>
      </para>
      <para>Edit the <filename>config/rapyd.php</filename> configuration file to change
      the date and time formats to match those used in your locale:

        <literallayout class="monospaced">
  'fields' =&gt; [
    'attributes' =&gt; ['class' =&gt; 'form-control'],
    'date' =&gt; [
      'format' =&gt; 'Y-m-d',
    ],
    'datetime' =&gt; [
      'format'   =&gt; 'Y-m-d H:i:s',
      'store_as' =&gt; 'Y-m-d H:i:s',
    ],
  ],
        </literallayout>
      </para>
      <para>That completes the initial configuration. Now we can start building the
      logic of the web application.</para>
    </section> <!-- fbdevgd30-php-Laravel-project-config -->
  </section> <!-- fbdevgd30-php-Laravel-crt-project -->

  <section id="fbdevgd30-php-Laravel-project-models">
    <title>Creating Models</title>
    <para>The Laravel framework supports the Eloquent ORM, an elegant and simple implementation
    of the ActiveRecord pattern for working with a database. Each table has a corresponding
    class model that works with it. Models enable the application to read data from tables
    and write data to a table. The model we are going to work with complies fully with the
    one illustrated earlier, at the beginning of the
    <link linkend="fbdevgd30-database">Database chapter</link>.</para>

    <section id="fbdevgd30-php-Laravel-project-artisan">
      <title>A Tool for Model-making</title>
      <para>To create a model for our customer entity, Laravel offers the <function>artisan</function>
      command that makes it relatively easy. This is the command for creating a model template:
        <literallayout class="monospaced">
  php artisan make:model Customer
        </literallayout>
      </para>
      <para>We want to change the model so that it looks like this:
        <programlisting>
namespace App;

use Firebird\Eloquent\Model;

class Customer extends Model
{
  /**
   * Table associated with the model
   *
   * @var string
   */
  protected $table = 'CUSTOMER';

  /**
   * Primary key of the model
   *
   * @var string
   */
  protected $primaryKey = 'CUSTOMER_ID';
  /**
   * Our model does not have a timestamp
   *
   * @var bool
   */
  public $timestamps = false;

  /**
   * The name of the sequence for generating the primary key
   *
   * @var string
   */
  protected $sequence = 'GEN_CUSTOMER_ID';
}
        </programlisting>
      </para>
      <para>Notice that we use the modified Firebird\Eloquent\Model model from the
      <function>sim1984/laravel-firebird</function> package as the basis. It allows
      us to use the sequence specified in the <classname>$sequence</classname> attribute 
      to generate values for the primary key ID.</para>
      <para>We create a model for products&#x2014;Product&#x2014;in the same way.
        <programlisting>
namespace App;

use Firebird\Eloquent\Model;

class Product extends Model
{
  /**
   * Table associated with the model
   *
   * @var string
   */
  protected $table = 'PRODUCT';

  /**
   * Primary key of the model
   *
   * @var string
   */
  protected $primaryKey = 'PRODUCT_ID';

  /**
   * Our model does not have a timestamp
   *
   * @var bool
   */
  public $timestamps = false;

  /**
   * The name of the sequence for generating the primary key
   *
   * @var string
   */
  protected $sequence = 'GEN_PRODUCT_ID';
}
        </programlisting>
      </para>
      <para>Now, a model for the invoice header:
        <programlisting>
namespace App;

use Firebird\Eloquent\Model;

class Invoice extends Model {

  /**
   * Table associated with the model
   *
   * @var string
   */
  protected $table = 'INVOICE';

  /**
   * Primary key of the model
   *
   * @var string
   */
  protected $primaryKey = 'INVOICE_ID';

  /**
   * Our model does not have a timestamp
   *
   * @var bool
   */
  public $timestamps = false;

  /**
   * The name of the sequence for generating the primary key
   *
   * @var string
   */
  protected $sequence = 'GEN_INVOICE_ID';

  /**
   * Customer
   *
   * @return \App\Customer
   */
  public function customer() {
    return $this-&gt;belongsTo('App\Customer', 'CUSTOMER_ID');
  }
  /**
   * Invoice lines
   * @return \App\InvoiceLine[]
   */
  public function lines() {
    return $this-&gt;hasMany('App\InvoiceLine', 'INVOICE_ID');
  }

  /**
   * Payed
   */
  public function pay() {
    $connection = $this-&gt;getConnection();
    $attributes = $this-&gt;attributes;
    $connection-&gt;executeProcedure('SP_PAY_FOR_INOVICE',
                                  [$attributes['INVOICE_ID']]);
  }
}
        </programlisting>
      </para>
      <para>You'll observe some additional functions in this model. The <classname>customer</classname>
      function returns the customer that relates to the invoice header via the CUSTOMER_ID field.
      The <classname>belongsTo</classname> method is used for establishing this relation. The name
      of the model class and the name of the relation field are passed to this method.</para>
      <para>The function <classname>lines</classname> returns items from the invoice that are
      represented by a collection of <classname>InvoiceLine</classname> models, described
      later. To establish the one-to-many relation in the <classname>lines</classname> function,
      the name of the class model and the relation field are passed to the
      <classname>hasMany</classname> method.</para>

      <para>You can find more details about specifying relations between entities in the
      <ulink url="https://laravel.com/docs/5.2/eloquent-relationships">Relationships section
      of the Laravel documentation</ulink>.</para>
      <para>The <classname>pay</classname> function performs payment of an invoice by calling the
      stored procedure <database>SP_PAY_FOR_INVOICE</database>, passing the identifier of the
      invoice header. The value of any field (model attribute) can be obtained from the
      attribute <classname>attribute</classname>. The <classname>executeProcedure</classname>
      method calls the stored procedure.
        <note>
          <para>This method is available only when the <function>sim1984/laravel-firebird</function>
          extension is used.</para>
        </note>
      </para>
    </section> <!-- fbdevgd30-php-Laravel-project-models -->

    <section id="fbdevgd30-php-model-inv-items">
      <title>Invoice Items Model</title>
      <para>Now we are going to create a model for items in an invoice:
        <programlisting>
namespace App;

use Firebird\Eloquent\Model;
use Illuminate\Database\Eloquent\Builder;

class InvoiceLine extends Model {

  /**
   * Table associated with the model
   *
   * @var string
   */
  protected $table = 'INVOICE_LINE';

  /**
   * Primary key of the model
   *
   * @var string
   */
  protected $primaryKey = 'INVOICE_LINE_ID';

  /**
   * Our model does not have a timestamp
   *
   * @var bool
   */
  public $timestamps = false;

  /**
   * The name of the sequence for generating the primary key
   *
   * @var string
   */
  protected $sequence = 'GEN_INVOICE_LINE_ID';

  /**
   * Array of names of computed fields
   *
   * @var array
   */
  protected $appends = ['SUM_PRICE'];

  /**
   * Product
   *
   * @return \App\Product
   */
  public function product() {
    return $this-&gt;belongsTo('App\Product', 'PRODUCT_ID');
  }

  /**
   * Amount by item
   *
   * @return double
   */
  public function getSumPriceAttribute() {
    return $this-&gt;SALE_PRICE * $this-&gt;QUANTITY;
  }

  /**
   * Adding a model object to the database
   * Override this method, because in this case, we work with a stored procedure
   *
   * @param \Illuminate\Database\Eloquent\Builder $query
   * @param array $options
   * @return bool
   */
  protected function performInsert(Builder $query, array $options = []) {
    if ($this-&gt;fireModelEvent('creating') === false) {
      return false;
    }
    $connection = $this-&gt;getConnection();
    $attributes = $this-&gt;attributes;
    $connection-&gt;executeProcedure('SP_ADD_INVOICE_LINE', [
      $attributes['INVOICE_ID'],
      $attributes['PRODUCT_ID'],
      $attributes['QUANTITY']
    ]);
    // We will go ahead and set the exists property to true,
    // so that it is set when the created event is fired, just in case
    // the developer tries to update it during the event. This will allow
    // them to do so and run an update here.
    $this-&gt;exists = true;
    $this-&gt;wasRecentlyCreated = true;
    $this-&gt;fireModelEvent('created', false);
    return true;
  }

  /**
   * Saving changes to the current model instance in the database
   * Override this method, because in this case, we work with a stored procedure
   *
   * @param \Illuminate\Database\Eloquent\Builder $query
   * @param array $options
   * @return bool
   */
  protected function performUpdate(Builder $query, array $options = []) {
    $dirty = $this-&gt;getDirty();
    if (count($dirty) &gt; 0) {
      // If the updating event returns false, we will cancel
      // the update operation so developers can hook Validation systems
      // into their models and cancel this operation if the model does
      // not pass validation. Otherwise, we update.
      if ($this-&gt;fireModelEvent('updating') === false) {
        return false;
      }
      $connection = $this-&gt;getConnection();
      $attributes = $this-&gt;attributes;
      $connection-&gt;executeProcedure('SP_EDIT_INVOICE_LINE', [
        $attributes['INVOICE_LINE_ID'],
        $attributes['QUANTITY']
      ]);
      $this-&gt;fireModelEvent('updated', false);
    }
  }

  /**
   * Deleting the current model instance from the database
   * Override this method, because in this case, we work with a stored procedure
   *
   * @return void
   */
  protected function performDeleteOnModel() {
    $connection = $this-&gt;getConnection();
    $attributes = $this-&gt;attributes;
    $connection-&gt;executeProcedure('SP_DELETE_INVOICE_LINE',
      [$attributes['INVOICE_LINE_ID']]);
  }
}
        </programlisting>
      </para>
      <para>The <classname>product</classname> function in this model returns the product,
      actually the <classname>App/Product</classname> model that was specified as the invoice
      item. The relation is established through the PRODUCT_ID field by the <classname>belongsTo</classname>
      method.</para>
      <para>The <classname>SumPrice</classname> is a calculated field, calculated by the
      function <classname>getSumPriceAttribute</classname>. For a calculated field to be
      available in the model, its name must be specified in the <classname>$appends</classname> array
      that stores the names of calculated fields.</para>

      <section id="fbdevgd30-php-model-inv-items-ops">
        <title>Operations</title>
        <para>In this model, we redefined the insert, update and delete operations so that
        they are performed through stored procedures. Along with performing the insert,
        update and delete operations, these stored procedures recalculate the total
        in the invoice header. We could have avoided doing that, but then we would have had
        to modify several models in one transaction. Later, we will examine how to do it
        that way.</para>
      </section>
    </section> <!-- fbdevgd30-php-model-inv-items -->

    <section id="fbdevgd30-php-laravel-manages-data">
      <title>How Laravel Manages Data</title>
      <para>Now let us talk a bit about how to work in Laravel with models for
      retrieving, inserting, updating and deleting data. Laravel uses the <classname>query</classname>
      constructor to manage data. The full description of the syntax and capabilities of this constructor
      is available at
      <ulink url="https://laravel.com/docs/5.2/queries">https://laravel.com/docs/5.2/queries</ulink>.

      For example, you can execute the following query to retrieve all supplier rows:
        <programlisting>
$customers = DB::table('CUSTOMER')-&gt;get();
        </programlisting>
      This query constructor is quite a powerful tool for building and executing SQL
      queries. You can also direct it to filter, sort and merge tables. For example:
        <programlisting>
DB::table('users')
  -&gt;join('contacts', function ($join) {
    $join-&gt;on('users.id', '=', 'contacts.user_id')-&gt;orOn(...);
  })
  -&gt;get()
        </programlisting>
      </para>
      <para>Nevertheless, models are more convenient to work with. You can find the
      description of Eloquent ORM models and the syntax for querying them at
      <ulink url="https://laravel.com/docs/5.2/eloquent">https://laravel.com/docs/5.2/eloquent</ulink>.
      </para>
      <para>As an example, to retrieve all elements from the collection of customers
      would require executing the following query:
        <programlisting>
$customers = Customer::all();
        </programlisting>
        This query will return the first 20 customers sorted alphabetically:
        <programlisting>
$customers = App\Customer::select()
           -&gt;orderBy('name')
           -&gt;take(20)
           -&gt;get();
        </programlisting>
      </para>

      <section id="fbdevgd30-php-laravel-complex-models">
        <title>Complex Models</title>
        <para>When a model is more complex, its relationships or relationship collections
        can be retrieved via <firstterm>dynamic attributes</firstterm>. The following query,
        for example, returns the items of the invoice that has the identifier 1:
          <programlisting>
$lines = Invoice::find(1)-&gt;lines;
          </programlisting>
        </para>
        <para>Records are added by creating an instance of the model, initiating its
        attributes and saving the model using the <classname>save</classname> method:
          <programlisting>
$flight = new Flight;
$flight-&gt;name = $request-&gt;name;
$flight-&gt;save();
          </programlisting>
        </para>
        <para>Updating a record involves finding it, accepting changes to the appropriate
        attributes and saving it with the <classname>save</classname> method:
          <programlisting>
$flight = App\Flight::find(1);
$flight-&gt;name = 'New Flight Name';
$flight-&gt;save();
To delete a record, involves finding it and calling the delete method.
$flight = App\Flight::find(1);
$flight-&gt;delete();
          </programlisting>
        </para>
        <para>The <classname>destroy</classname> method allows a record to be deleted
        more rapidly by its key value, without needing to retrieve its instance:
          <programlisting>
App\Flight::destroy(1);
          </programlisting>
        </para>
        <para>There are other ways of deleting records, for instance, <quote>soft</quote>
        deletion. You can read more about deletion methods at
        <ulink url="https://laravel.com/docs/5.2/eloquent#deleting-models">https://laravel.com/docs/5.2/eloquent#deleting-models</ulink>.
        </para>
      </section>  <!-- fbdevgd30-php-laravel-complex-models -->
    </section> <!-- fbdevgd30-php-laravel-manages-data -->
  </section>  <!-- fbdevgd30-php-Laravel-project-models -->

  <section id="fbdevgd30-php-Laravel-transactions">
    <title>Transactions</title>
    <para>Now let us talk a little about transactions. Without going into the fine detail, I will 
    demonstrate how transactions and the Eloquent ORM can be used together.
      <programlisting>
DB::transaction(function () {
  // Create a new position in the invoice
  $line = new App\InvoiceLine();
  $line-&gt;CUSTOMER_ID = 45;
  $line-&gt;PRODUCT_ID = 342;
  $line-&gt;QUANTITY = 10;
  $line-&gt;COST = 12.45;
  $line-&gt;save();
  // add the sum of the line item to the amount of the invoice
  $invoice = App\Invoice::find($line-&gt;CUSTOMER_ID);
  $invoice-&gt;INVOICE_SUM += $line-&gt;SUM_PRICE;
  $invoice-&gt;save();
});
      </programlisting>
    </para>
    <para>Every parameter of the <classname>transaction</classname> method that is located
    inside the callback function is executed within one transaction.</para>
  </section>

  <section id="fbdevgd30-php-Laravel-controllers">
    <title>Creating Controllers and Configuring Routing</title>
    <para>The Laravel framework has a powerful routing subsystem. You can display your routes 
    both for simple callback functions and for the controller methods. The simplest sample 
    routes look like this:
      <programlisting>
Route::get('/', function () {
  return 'Hello World';
});

Route::post('foo/bar', function () {
  return 'Hello World';
});
      </programlisting>
    In the first example, we register the handler of the GET request for the website root
    for the POST request with the route <function>/foo/bar</function> in the second.
    </para>
    
    <para>You can register a route for several types of HTTP requests. For example:
      <programlisting>
Route::match(['get', 'post'], 'foo/bar', function () {
  return 'Hello World';
});
      </programlisting>
    </para>
    <para>You can extract some part of the URL from the route for use as a parameter in 
    the handling function:
          <programlisting>
Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
  //
});
      </programlisting>
    The parameters of a route are always enclosed in braces.
    </para>
    <para>You can find more details about routing configuration in the 
    <ulink url="https://laravel.ru/docs/v5/routing">Routing</ulink> chapter of the 
    documentation. Routes are configured in the <filename>app/Http/routes.php</filename> 
    file in Laravel 5.2 and in the <filename>routes/wep.php</filename> file 
    in Laravel 5.3.</para>
    
    <section id="fbdevgd30-php-Laravel-ctrlr-routing">
      <title>Using Controllers to Route Requests</title>
      <para>Instead of directing the processing of all requests from a single routing file, 
      we can use Controller classes to group related request handlers into separate classes. 
      Controllers are stored in the <filename>app/Http/Controllers</filename> folder.</para>
      <para>All Laravel controllers must extend the basic class of the 
      controller <filename>App\Http\Controllers\Controller</filename> that exists in Laravel 
      by default. You can read more details about writing controllers at 
      <ulink url="https://laravel.com/docs/5.2/controllers">https://laravel.com/docs/5.2/controllers</ulink>.
      </para>
    </section>

    <section id="fbdevgd30-php-Laravel-ctrlr-cust">
      <title>A Customer Controller</title>
      <para>First, we'll write our Customer controller.
        <programlisting>
&lt;?php

/*
* Customer controller
*/
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Customer;

class CustomerController extends Controller
{
  /**
   * Show customer list
   *
   * @return Response
   */
  public function showCustomers()
  {
    // get the first 20 customers
    // sorted alphabetically
    $customers = Customer::select()
               -&gt;orderBy('NAME')
               -&gt;take(20)
               -&gt;get();
    var_dump($customers);
  }
}
        </programlisting>
      </para>
      <para>Now we have to link the controller methods to the route. For this, add the following 
      line to <filename>routes.php</filename> (web.php):
        <literallayout class="monospaced">
Route::get('/customers', 'CustomerController@showCustomers');
        </literallayout>
      The controller name is separated from the method name with the @ character.
      </para>
      <para>To build a quick interface with grids and edit dialog boxes, we will use
      the <function>zofe/rapyd</function> package that was enabled earlier. Classes from
      the <function>zofe/rapyd</function> package take up the role of building standard
      queries to Eloquent ORM models. We will change the customer controller so that
      it shows data on the grid, allows filtering and record insertions, updates and
      deletes by way of the edit dialog boxes.
        <programlisting>
&lt;?php
/*
 * Customer Controller
 */
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Customer;

class CustomerController extends Controller {

  /**
   * Displays the list of customers
   *
   * @return Response
   */
  public function showCustomers() {
    // Connect widget for search
    $filter = \DataFilter::source(new Customer);
    // Search will be by the name of the supplier
    $filter-&gt;add('NAME', 'Name', 'text');
    // Set capture for search button
    $filter-&gt;submit('Search');
    // Add the filter reset button and assign it caption
    $filter-&gt;reset('Reset');
    // Create a grid to display the filtered data
    $grid = \DataGrid::source($filter);
    // output columns
    // Field, label, sorted
    $grid-&gt;add('NAME', 'Name', true);
    $grid-&gt;add('ADDRESS', 'Address');
    $grid-&gt;add('ZIPCODE', 'Zip Code');
    $grid-&gt;add('PHONE', 'Phone');
    // Add buttons to view, edit and delete records
    $grid-&gt;edit('/customer/edit', 'Edit', 'show|modify|delete');
    // Add the Add Customer button
    $grid-&gt;link('/customer/edit', &quot;Add customer&quot;, &quot;TR&quot;);
    $grid-&gt;orderBy('NAME', 'asc');
    // set the number of records per page
    $grid-&gt;paginate(10);
    // display the customer template and pass the filter and grid to it
    return view('customer', compact('filter', 'grid'));
  }

  /**
   * Add, edit and delete a customer
   *
   * @return Response
   */
  public function editCustomer() {
    if (\Input::get('do_delete') == 1)
      return &quot;not the first&quot;;
    // create an editor
    $edit = \DataEdit::source(new Customer());
    // Set title of the dialog, depending on the type of operation
    switch ($edit-&gt;status) {
      case 'create':
        $edit-&gt;label('Add customer');
        break;
      case 'modify':
        $edit-&gt;label('Edit customer');
        break;
      case 'do_delete':
        $edit-&gt;label('Delete customer');
        break;
      case 'show':
        $edit-&gt;label(&quot;Customer's card&quot;);
        // add a link to go back to the list of customers
        $edit-&gt;link('customers', 'Back', 'TR');
        break;
    }
    // set that after the operations of adding, editing and deleting,
    // you need to return to the list of customers
    $edit-&gt;back('insert|update|do_delete', 'customers');
    // We add editors of a certain type, assign them a label and
    // associate them with the attributes of the model
    $edit-&gt;add('NAME', 'Name', 'text')-&gt;rule('required|max:60');
    $edit-&gt;add('ADDRESS', 'Address', 'textarea')
         -&gt;attributes(['rows' =&gt; 3])
         -&gt;rule('max:250');
    $edit-&gt;add('ZIPCODE', 'Zip code', 'text')-&gt;rule('max:10');
    $edit-&gt;add('PHONE', 'Phone', 'text')-&gt;rule('max:14');
    // display the template customer_edit and pass it to the editor
    return $edit-&gt;view('customer_edit', compact('edit'));
  }
}
        </programlisting>
      </para>
      <section id="fbdevgd30-php-blade">
        <title><emphasis>blade</emphasis> Templates</title>
        <para>By default, Laravel uses the <firstterm>blade template engine</firstterm>.
        The <classname>view</classname> function finds the necessary template in the 
        <filename>resources/views</filename> directory, makes the necessary changes to
        it and returns the text of the HTML page, at the same time passing to it any 
        variables that are supplied in the template. You can find the description of 
        the <firstterm>blade</firstterm> template syntax at 
        <ulink url="https://laravel.com/docs/5.2/blade">https://laravel.com/docs/5.2/blade</ulink>.
        </para>
      </section>
      
      <section id="fbdevgd30-php-cust-display">
        <title>The Template for Displaying Customers</title>
        <para>The template for displaying customers looks like this:
          <programlisting>
@extends('example')

@section('title', 'Customers')

@section('body')
&lt;h1&gt;Customers&lt;/h1&gt;
&lt;p&gt;
  {!! $filter !!}
  {!! $grid !!}
&lt;/p&gt;
@stop
          </programlisting>
        </para>
        <para>This template is inherited from the example template and redefines its body 
        section. The $filter and $grid variables contain the HTML code for filtering and 
        displaying data on the grid. The example template is common for all pages.
          <programlisting>
@extends('master')
@section('title', 'Example of working with Firebird')

@section('body')
&lt;h1&gt;??????&lt;/h1&gt;
  @if(Session::has('message'))
  &lt;div class=&quot;alert alert-success&quot;&gt;
    {!! Session::get('message') !!}
  &lt;/div&gt;
  @endif
  &lt;p&gt;Example of working with Firebird.&lt;br/&gt;
  &lt;/p&gt;
@stop

@section('content')
@include('menu')
@yield('body')

@stop
          </programlisting>
        </para>
        <para>This template is itself inherited from the master template and also enables 
        the menu template. The menu is quite simple and consists of three items: Customers, 
        Products and Invoices.
          <programlisting>
&lt;nav class=&quot;navbar main&quot;&gt;
  &lt;div class=&quot;navbar-header&quot;&gt;
    &lt;button type=&quot;button&quot; class=&quot;navbar-toggle&quot;
            data-toggle=&quot;collapse&quot; data-target=&quot;.main-collapse&quot;&gt;
      &lt;span class=&quot;sr-only&quot;&gt;&lt;/span&gt;
      &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
      &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
      &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;
    &lt;/button&gt;
  &lt;/div&gt;
  &lt;div class=&quot;collapse navbar-collapse main-collapse&quot;&gt;
    &lt;ul class=&quot;nav nav-tabs&quot;&gt;
      &lt;li @if (Request::is('customer*'))
          class=&quot;active&quot;@endif&gt;{!! link_to(&quot;customers&quot;, &quot;Customers&quot;) !!}&lt;/li&gt;
      &lt;li @if (Request::is('product*'))
          class=&quot;active&quot;@endif&gt;{!! link_to(&quot;products&quot;, &quot;Products&quot;) !!}&lt;/li&gt;
      &lt;li @if (Request::is('invoice*'))
          class=&quot;active&quot;@endif&gt;{!! link_to(&quot;invoices&quot;, &quot;Invoices&quot;) !!}&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/nav&gt;
          </programlisting>
        </para>
        <para>The master template enables css styles and JavaScript files with libraries.
          <programlisting>
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;title&gt;@yield('title', 'An example of a Web application on Firebird')&lt;/title&gt;
  &lt;meta name=&quot;description&quot; content=&quot;@yield('description',
        'An example of a Web application on Firebird')&quot; /&gt;
  @section('meta', '')
  &lt;link href=&quot;http://fonts.googleapis.com/css?family=Bitter&quot; rel=&quot;stylesheet&quot;
        type=&quot;text/css&quot; /&gt;
  &lt;link href=&quot;//netdna.bootstrapcdn.com/bootstrap/3.2.0/css/bootstrap.min.css&quot;
        rel=&quot;stylesheet&quot;&gt;
  &lt;link href=&quot;//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css&quot;
        rel=&quot;stylesheet&quot;&gt;
  {!! Rapyd::styles(true) !!}
&lt;/head&gt;
&lt;body&gt;
  &lt;div id=&quot;wrap&quot;&gt;
    &lt;div class=&quot;container&quot;&gt;
      &lt;br /&gt;
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-sm-12&quot;&gt;
          @yield('content')
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div id=&quot;footer&quot;&gt;
  &lt;/div&gt;
  &lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js&quot;&gt;
  &lt;/script&gt;
  &lt;script src=&quot;//netdna.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js&quot;&gt;
  &lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/1.9.6/jquery.pjax.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/riot/2.2.4/riot+compiler.min.js&quot;&gt;&lt;/script&gt;
  {!! Rapyd::scripts() !!}
&lt;/body&gt;
&lt;/html&gt;
          </programlisting>
        </para>
        <para>The customer_edit template:
          <programlisting>
@extends('example')
@section('title', 'Edit customer')
@section('body')
  &lt;p&gt;
    {!! $edit !!}
  &lt;/p&gt;
@stop
          </programlisting>
        </para>
      </section> <!-- fbdevgd30-php-cust-display -->
    </section>  <!-- fbdevgd30-php-Laravel-ctrlr-cust -->

    <section id="fbdevgd30-php-Laravel-ctrlr-prod">
      <title>A Product Controller</title>
      <para>Implementation of the product controller is similar to what we did for 
      the customer controller:
        <programlisting>
&lt;?php

/*
 * Product Controller
 */
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Product;

class ProductController extends Controller {

  /**
   * Displays a list of products
   *
   * @return Response
   */
  public function showProducts() {
    // Connect widget for search
    $filter = \DataFilter::source(new Product);
    // The search will be by product name
    $filter-&gt;add('NAME', 'Name', 'text');
    $filter-&gt;submit('Search');
    $filter-&gt;reset('Reset');
    // Create a grid to display the filtered data
    $grid = \DataGrid::source($filter);
    // output grid columns
    // Field, label, sorting
    $grid-&gt;add('NAME', 'Name', true);
    // Set the format with 2 decimal places
    $grid-&gt;add('PRICE|number_format[2,., ]', 'Price');
    $grid-&gt;row(function($row) {
      // Press the money values to the right
      $row-&gt;cell('PRICE')-&gt;style(&quot;text-align: right&quot;);
    });
    // Add buttons to view, edit and delete records
    $grid-&gt;edit('/product/edit', 'Edit', 'show|modify|delete');
    // Add the Add product button
    $grid-&gt;link('/product/edit', &quot;?????????? ??????&quot;, &quot;TR&quot;);
    // set sorting
    $grid-&gt;orderBy('NAME', 'asc');
    // set the number of records per page
    $grid-&gt;paginate(10);
    // display the customer template and pass the filter and grid to it
    return view('product', compact('filter', 'grid'));
  }

  /**
   * Add, edit and delete products
   *
   * @return Response
   */
  public function editProduct() {
    if (\Input::get('do_delete') == 1)
      return &quot;not the first&quot;;
    // create editor
    $edit = \DataEdit::source(new Product());
    // Set the title of the dialog, depending on the type of operation
    switch ($edit-&gt;status) {
      case 'create':
        $edit-&gt;label('Add product');
        break;
      case 'modify':
        $edit-&gt;label('Edit product');
        break;
      case 'do_delete':
        $edit-&gt;label('Delete product');
        break;
      case 'show':
        $edit-&gt;label(&quot;Product's card&quot;);
        $edit-&gt;link('products', 'Back', 'TR');
        break;
    }
    // set that after the operations of adding, editing and deleting, 
    // you need to return to the list of products
    $edit-&gt;back('insert|update|do_delete', 'products');
    // We add editors of a certain type, assign them a label and 
    // associate them with the attributes of the model
    $edit-&gt;add('NAME', 'Name', 'text')-&gt;rule('required|max:100');
    $edit-&gt;add('PRICE', 'Price', 'text')-&gt;rule('max:19');
    $edit-&gt;add('DESCRIPTION', 'Description', 'textarea')
         -&gt;attributes(['rows' =&gt; 8])
         -&gt;rule('max:8192');
    // display the template product_edit and pass it to the editor
    return $edit-&gt;view('product_edit', compact('edit'));
  }
}
        </programlisting>
      </para>
    </section> <!-- fbdevgd30-php-Laravel-ctrlr-prod -->

    <section id="fbdevgd30-php-Laravel-ctrlr-inv">
      <title>A Controller for Invoices</title>
      <para>The invoice controller is more complex and includes an additional function 
      to pay an invoice. Paid invoices are highlighted in a different color. While viewing an 
      invoice, you can also see its items. While editing an invoice, you can edit its items 
      as well.  Here is the code for the controller with detailed comments.
        <programlisting>
&lt;?php
/*
 * Invoice controller
 */
namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Invoice;
use App\Customer;
use App\Product;
use App\InvoiceLine;

class InvoiceController extends Controller {

  /**
   * Show invoice list
   *
   * @return Response
   */
  public function showInvoices() {
    // The invoice model will also select the related suppliers
    $invoices = Invoice::with('customer');
    // Add a widget for search.
    $filter = \DataFilter::source($invoices);
    // Let's filter by date range
    $filter-&gt;add('INVOICE_DATE', 'Date', 'daterange');
    // and filter by customer name
    $filter-&gt;add('customer.NAME', 'Customer', 'text');
    $filter-&gt;submit('Search');
    $filter-&gt;reset('Reset');
    // Create a grid to display the filtered data
    $grid = \DataGrid::source($filter);
    // output grid columns
    // Field, caption, sorted
    // For the date we set an additional function that converts 
    // the date into a string
    $grid-&gt;add('INVOICE_DATE|strtotime|date[Y-m-d H:i:s]', 'Date', true);
    // for money we will set a format with two decimal places
    $grid-&gt;add('TOTAL_SALE|number_format[2,., ]', 'Amount');
    $grid-&gt;add('customer.NAME', 'Customer');
    // Boolean printed as Yes/No
    $grid-&gt;add('PAID', 'Paid')
         -&gt;cell(function( $value, $row) {
                  return $value ? 'Yes' : 'No';
                });
    // set the function of processing each row
    $grid-&gt;row(function($row) {
      // The monetary values are pressed to the right
      $row-&gt;cell('TOTAL_SALE')-&gt;style(&quot;text-align: right&quot;);
      // paint the paid waybills in a different color
      if ($row-&gt;cell('PAID')-&gt;value == 'Yes') {
        $row-&gt;style(&quot;background-color: #ddffee;&quot;);
      }
    });
    // Add buttons to view, edit and delete records
    $grid-&gt;edit('/invoice/edit', '??????????????', 'show|modify|delete');
    // Add the button for adding invoices
    $grid-&gt;link('/invoice/edit', &quot;?????????? ?????&quot;, &quot;TR&quot;);
    
    $grid-&gt;orderBy('INVOICE_DATE', 'desc');
    // set the number of records per page
    $grid-&gt;paginate(10);
    // display the customer template and pass the filter and grid to it
    return view('invoice', compact('filter', 'grid'));
  }

  /**
   * Add, edit and delete invoice
   *
   * @return Response
   */
  public function editInvoice() {
    // get the text of the saved error, if it was
    $error_msg = \Request::old('error_msg');
    // create an invoice invoice editor
    $edit = \DataEdit::source(new Invoice());
    // if the invoice is paid, then we generate an error when trying to edit it
    if (($edit-&gt;model-&gt;PAID) &amp;&amp; ($edit-&gt;status === 'modify')) {
      $edit-&gt;status = 'show';
      $error_msg = 'Editing is not possible. The account has already been paid.';
    }
    // if the invoice is paid, then we generate an error when trying to delete it
    if (($edit-&gt;model-&gt;PAID) &amp;&amp; ($edit-&gt;status === 'delete')) {
      $edit-&gt;status = 'show';
      $error_msg = 'Deleting is not possible. The account has already been paid.';
    }
    // Set the label of the dialog, depending on the type of operation
    switch ($edit-&gt;status) {
      case 'create':
        $edit-&gt;label('Add invoice');
        break;

      case 'modify':
        $edit-&gt;label('Edit invoice');
        break;

      case 'do_delete':
        $edit-&gt;label('Delete invoice');
        break;

      case 'show':
        $edit-&gt;label('Invoice');
        $edit-&gt;link('invoices', 'Back', 'TR');
        // If the invoice is not paid, we show the pay button
        if (!$edit-&gt;model-&gt;PAID)
          $edit-&gt;link('invoice/pay/' . $edit-&gt;model-&gt;INVOICE_ID,
                      'Pay', 'BL');
        break;
    }
    // set that after the operations of adding, editing and deleting, 
    // we return to the list of invoices
    $edit-&gt;back('insert|update|do_delete', 'invoices');
    // set the &quot;date&quot; field, that it is mandatory
    // The default is the current date
    $edit-&gt;add('INVOICE_DATE', '????', 'datetime')
         -&gt;rule('required')
         -&gt;insertValue(date('Y-m-d H:i:s'));
    // add a field for entering the customer. When typing a customer name, 
    // a list of prompts will be displayed
    $edit-&gt;add('customer.NAME', 'Customer', 'autocomplete')
         -&gt;rule('required')
         -&gt;options(Customer::lists('NAME', 'CUSTOMER_ID')
                           -&gt;all());
    // add a field that will display the invoice amount, read-only
    $edit-&gt;add('TOTAL_SALE', 'Amount', 'text')
         -&gt;mode('readonly')
         -&gt;insertValue('0.00');
    // add paid checkbox
    $paidCheckbox = $edit-&gt;add('PAID', 'Paid', 'checkbox')
                         -&gt;insertValue('0')
                         -&gt;mode('readonly');
    $paidCheckbox-&gt;checked_output = 'Yes';
    $paidCheckbox-&gt;unchecked_output = 'No';
    // create a grid to display the invoice line rows
    $grid = $this-&gt;getInvoiceLineGrid($edit-&gt;model, $edit-&gt;status);
    // we display the invoice_edit template and pass the editor and grid to 
    // it to display the invoice invoice items
    return $edit-&gt;view('invoice_edit', compact('edit', 'grid', 'error_msg'));
  }

  /**
   * Payment of invoice
   *
   * @return Response
   */
  public function payInvoice($id) {
    try {
      // find the invoice by ID
      $invoice = Invoice::findOrFail($id);
      // call the payment procedure
      $invoice-&gt;pay();
    } catch (\Illuminate\Database\QueryException $e) {
      // if an error occurs, select the exclusion text
      $pos = strpos($e-&gt;getMessage(), 'E_INVOICE_ALREADY_PAYED');
      if ($pos !== false) {
        // redirect to the editor page and display the error there
        return redirect('invoice/edit?show=' . $id)
             -&gt;withInput(['error_msg' =&gt; 'Invoice already paid']);
      } else
        throw $e;
    }
    // redirect to the editor page
    return redirect('invoice/edit?show=' . $id);
  }

  /**
   * Returns the grid for the invoice item
   * @param \App\Invoice $invoice
   * @param string $mode
   * @return \DataGrid
   */
  private function getInvoiceLineGrid(Invoice $invoice, $mode) {
    // Get invoice items
    // For each ivoice item, the associated product will be initialized
    $lines = InvoiceLine::with('product')
                -&gt;where('INVOICE_ID', $invoice-&gt;INVOICE_ID);
    // Create a grid for displaying invoice items
    $grid = \DataGrid::source($lines);
    // output grid columns
    // Field, caption, sorted
    $grid-&gt;add('product.NAME', 'Name');
    $grid-&gt;add('QUANTITY', 'Quantity');
    $grid-&gt;add('SALE_PRICE|number_format[2,., ]', 'Price')
         -&gt;style('min-width: 8em;');
    $grid-&gt;add('SUM_PRICE|number_format[2,., ]', 'Amount')
         -&gt;style('min-width: 8em;');
    // set the function of processing each row
    $grid-&gt;row(function($row) {
      $row-&gt;cell('QUANTITY')-&gt;style(&quot;text-align: right&quot;);
      // The monetary values are pressed to the right
      $row-&gt;cell('SALE_PRICE')-&gt;style(&quot;text-align: right&quot;);
      $row-&gt;cell('SUM_PRICE')-&gt;style(&quot;text-align: right&quot;);
    });
    if ($mode == 'modify') {
      // Add buttons to view, edit and delete records
      $grid-&gt;edit('/invoice/editline', '??????????????', 'modify|delete');
      // Add a button to add an invoice item
      $grid-&gt;link('/invoice/editline?invoice_id=' . $invoice-&gt;INVOICE_ID,
                  &quot;Add item&quot;, &quot;TR&quot;);
    }
    return $grid;
  }

  /**
   * Add, edit and delete invoice items
   *
   * @return Response
   */
  public function editInvoiceLine() {
    if (\Input::get('do_delete') == 1)
      return &quot;not the first&quot;;
    $invoice_id = null;
    // create the editor of the invoice item
    $edit = \DataEdit::source(new InvoiceLine());
    // Set the label of the dialog, depending on the type of operation
    switch ($edit-&gt;status) {
      case 'create':
        $edit-&gt;label('Add invoice item');
        $invoice_id = \Input::get('invoice_id');
        break;

      case 'modify':
        $edit-&gt;label('Edit invoice item');
        $invoice_id = $edit-&gt;model-&gt;INVOICE_ID;
        break;

      case 'delete':
        $invoice_id = $edit-&gt;model-&gt;INVOICE_ID;
        break;

      case 'do_delete':
        $edit-&gt;label('Delete invoice item');
        $invoice_id = $edit-&gt;model-&gt;INVOICE_ID;
        break;
    }
    // make url to go back
    $base = str_replace(\Request::path(), '', strtok(\Request::fullUrl(), '?'));
    $back_url = $base . 'invoice/edit?modify=' . $invoice_id;
    // set the page to go back
    $edit-&gt;back('insert|update|do_delete', $back_url);
    $edit-&gt;back_url = $back_url;
    // add a hidden field with an invoice code
    $edit-&gt;add('INVOICE_ID', '', 'hidden')
         -&gt;rule('required')
         -&gt;insertValue($invoice_id)
         -&gt;updateValue($invoice_id);
    // Add a field for entering the goods. When you type the product name, 
    // a list of prompts is displayed.
    $edit-&gt;add('product.NAME', 'Name', 'autocomplete')
         -&gt;rule('required')
         -&gt;options(Product::lists('NAME', 'PRODUCT_ID')-&gt;all());
    // Field for input quantity
    $edit-&gt;add('QUANTITY', 'Quantity', 'text')
         -&gt;rule('required');
    // display the template invoice_line_edit and pass it to the editor
    return $edit-&gt;view('invoice_line_edit', compact('edit'));
  }
}
        </programlisting>
      </para>
      <section id="fbdevgd30-php-Laravel-ctrlr-inv-edtr">
        <title>The Invoice Editor</title>
        <para>The invoice editor has a view that is not standard for 
        <function>zofe/rapyd</function> because we want to display a grid 
        with invoice items. To do that, we change the invoice_edit template 
        as follows:
          <programlisting>
@extends('example')

@section('title','Edit invoice')

@section('body')
  &lt;div class=&quot;container&quot;&gt;
    {!! $edit-&gt;header !!}
    @if($error_msg)
      &lt;div class=&quot;alert alert-danger&quot;&gt;
        &lt;strong&gt;??????!&lt;/strong&gt; {{ $error_msg }}
      &lt;/div&gt;
    @endif
    {!! $edit-&gt;message !!}
    @if(!$edit-&gt;message)
      &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-sm-4&quot;&gt;
          {!! $edit-&gt;render('INVOICE_DATE') !!}
          {!! $edit-&gt;render('customer.NAME') !!}
          {!! $edit-&gt;render('TOTAL_SALE') !!}
          {!! $edit-&gt;render('PAID') !!}
        &lt;/div&gt;
      &lt;/div&gt;
      {!! $grid !!}
    @endif
    {!! $edit-&gt;footer !!}
  &lt;/div&gt;
@stop
          </programlisting>
        </para>
      </section> <!-- fbdevgd30-php-Laravel-ctrlr-inv-edtr -->
    </section>  <!-- fbdevgd30-php-Laravel-ctrlr-inv -->

    <section id="fbdevgd30-php-Laravel-ctrlr-chg-routes">
      <title>Changing the Routes</title>
      <para>Now that all controllers are written, we are going to change the routes so 
      that our website opens the list of invoices on the start page. Be aware that routes 
      are configured in the file <filename>app/Http/routes.php</filename> in Laravel 5.2 
      and in <filename>routes/wep.php</filename> in Laravel 5.3.
        <programlisting>
Route::get('/', 'InvoiceController@showInvoices');
Route::get('/customers', 'CustomerController@showCustomers');
Route::any('/customer/edit', 'CustomerController@editCustomer');
Route::get('/products', 'ProductController@showProducts');
Route::any('/product/edit', 'ProductController@editProduct');
Route::get('/invoices', 'InvoiceController@showInvoices');
Route::any('/invoice/edit', 'InvoiceController@editInvoice');
Route::any('/invoice/pay/{id}', 'InvoiceController@payInvoice');
Route::any('/invoice/editline', 'InvoiceController@editInvoiceLine');
        </programlisting>
      Here the <filename>/invoice/pay/{id}</filename> route picks up the invoice 
      identifier from the URL and sends it to the <classname>payInvoice</classname> 
      method. The rest of the routes should be self-explanatory.
      </para>
    </section>
  </section> <!-- fbdevgd30-php-Laravel-controllers -->

  <section id="fbdevgd30-php-result">
    <title>The Result</title>
    <para>Some screenshots from the web application we developed in this project.
      <figure id="php-screenshot-1">
        <title>Invoices display</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 1259px X 786px -->
            <imagedata fileref="images/fbdevgd30_php_001_en.png" format="PNG"
             width="497px" depth="310px"
             scalefit="1" align="center" />  <!-- 39.5% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>

    <para>
      <figure id="php-screenshot-2">
        <title>Invoice editor</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 1275px X 699x -->
            <imagedata fileref="images/fbdevgd30_php_002_en.png" format="PNG"
             width="497px" depth="273px"
             scalefit="1" align="center" />  <!-- 39% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <section id="fbdevgd30-php-sourcecode">
      <title>Source Code</title>
      <para>You can download the source code for this project from 
      <ulink url="https://www.firebirdsql.org/file/documentation/reference_manuals/fbdevgd-en/code/phpfbexample.zip">phpfbexample.zip</ulink>
      </para>
    </section>
  </section>
</chapter>
