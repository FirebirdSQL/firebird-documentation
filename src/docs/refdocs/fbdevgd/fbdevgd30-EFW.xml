<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fbdevgd30-efw">
  <title>Developing Firebird Applications with Microsoft Entity Framework</title>
  <para>This chapter will describe the process of creating applications with a Firebird 
  database using the Microsoft&#8482;   Entity Framework&#8482; access components in the
  Visual Studio 2015&#8482; environment.</para>
  <para>ADO.NET Entity Framework (EF) combines an object-oriented data access technology
  with an object-relational mapping (ORM) solution for the Microsoft .NET Framework.
  It enables interaction with objects by means of both LINQ in the form of
  <command>LINQ to Entities</command> and with Entity SQL.</para>

  <section id="fbdg30-efw-methods">
    <title>Methods of Interacting with a Database</title>
    <para>Entity Framework assumes three possible methods for interacting with a database:
      <variablelist>
        <varlistentry>
          <term><command>Database first</command>:</term>
          <listitem>Entity Framework creates a set of classes that reflect the model
          of an existing database.</listitem>
        </varlistentry>
        <varlistentry>
          <term><command>Model first</command>:</term>
          <listitem>the developer creates a database model that Entity Framework
          later uses to create an actual database on the server.</listitem>
        </varlistentry>
        <varlistentry>
          <term><command>Code first</command>:</term>
          <listitem>the developer creates a class for the model of the data that will
          be stored in a database and then Entity Framework uses this model to generate
          the database and its tables</listitem>
        </varlistentry>
      </variablelist>
    Our sample application will use the <command>Code first</command> approach, but
    you could use one of the others just as easily.</para>
    <note>
      <para>As we already have a database, we will just write the code that would
      result in creating that database.</para>
    </note>
  </section>

  <section id="fbdg30-efw-vs-prepare">
    <title>Setting Up for Firebird in Visual Studio 2015</title>
    <para>To prepare for working with Firebird, you will need to install the following:
      <itemizedlist>
        <listitem>FirebirdSql.Data.FirebirdClient.dll</listitem>
        <listitem>the Firebird DDEX Provider for Visual Studio</listitem>
        <listitem>EntityFramework.Firebird.dll</listitem>
      </itemizedlist>
    </para>
    <para>There is nothing difficult in installing the first two. They are currently
    distributed and installed into a project by means of the
    <ulink url="https://www.nuget.org/">NuGet package manager</ulink>. The DDEX Provider
    library, designed for operating Visual Studio wizards, is not so easy to install
    and may take more time and effort.</para>
    <para>Efforts have been made to automate the installation process and include all
    components in a
    <ulink url="http://sourceforge.net/projects/firebird-4-8-0-ddex-installer/">single
    installer package</ulink>. However, you might need to install all of the components
    manually under some conditions. If so, you can download the following:
    <itemizedlist>
      <listitem>
      <ulink url="http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/FirebirdSql.Data.FirebirdClient-4.10.0.0.msi/download">FirebirdSql.Data.FirebirdClient-4.10.0.0.msi</ulink>
      </listitem>
      <listitem>
      <ulink url="http://sourceforge.net/projects/firebird/files/firebird-net-provider/4.10.0.0/EntityFramework.Firebird-4.10.0.0-NET45.7z/download">EntityFramework.Firebird-4.10.0.0-NET45.7z</ulink>
      </listitem>
      <listitem>
      <ulink url="http://sourceforge.net/projects/firebird/files/firebird-net-provider/DDEX%203.0.2/DDEXProvider-3.0.2.0.7z/download">DDEXProvider-3.0.2.0.7z</ulink>
      </listitem>
      <listitem>
      <ulink url="http://sourceforge.net/projects/firebird/files/firebird-netprovider/DDEX%203.0.2/DDEXProvider-3.0.2.0-src.7z/download">DDEXProvider-3.0.2.0-src.7z</ulink>
      </listitem>
    </itemizedlist>
    </para>

    <section id="fbdg30-efw-vs-install">
      <title>The Installation Process</title>
      <important>
        <title>Important!</title>
        <para>Because the installation involves operations in protected directories,
        you will need administrator privileges to do it.</para>
      </important>

      <section id="fbdg30-efw-vs-install-steps">
        <title>Steps</title>
        <orderedlist>
          <!-- 1 --><listitem>Install FirebirdSql.Data.FirebirdClient-4.10.0.0.msi</listitem>
          <!-- 2 --><listitem>
            <para>Unpack EntityFramework.Firebird-4.10.0.0-NET45.7z to the folder with the
            installed Firebird client. In my case, it is the folder
            <filename>c:\Program Files (x86)\FirebirdClient\</filename>.</para>
          </listitem>
          <!-- 3 --><listitem>
            <para>You need to install a Firebird build into the GAC. For your convenience,
            specify the path to the <classname>gacutil</classname> utility for .NET Framework
            4.5 in the environment variable <classname>%PATH%</classname>. In my case, the
            path is
            <filename>c:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools\</filename>
            </para>
          </listitem>
          <!-- 4 --><listitem>
            <para>Run the command shell cmd.exe as administrator and go to the directory
            with the installed client, e.g.,
              <literallayout class="monospaced">
  chdir "c:\Program Files (x86)\FirebirdClient"
              </literallayout>
            </para>
          </listitem>
          <!-- 5 --><listitem>
            <para>Now make sure that <filename>FirebirdSql.Data.FirebirdClient</filename> is
            installed into the GAC by typing the following command:
              <literallayout class="monospaced">
  gacutil /l FirebirdSql.Data.FirebirdClient
              </literallayout>
            If FirebirdSql.Data.FirebirdClient has not been installed into the GAC,
            use the following command to do it now:
              <literallayout class="monospaced">
  gacutil /i FirebirdSql.Data.FirebirdClient.dll
              </literallayout>
            </para>
          </listitem>
          <!-- 6 --><listitem>
            <para>Now install EntityFramework.Firebird into the GAC
              <literallayout class="monospaced">
  gacutil /i EntityFramework.Firebird.dll
              </literallayout>
            </para>
          </listitem>
          <!-- 7 --><listitem>
            <para>Unpack DDEXProvider-3.0.2.0.7z to a directory convenient for you.
            Mine was unpacked to <filename>c:\Program Files (x86)\FirebirdDDEX\</filename>.
           </para>
          </listitem>
          <!-- 8 --><listitem>
            <para>Unpack the contents of the <filename>/reg_files/VS2015</filename> subdirectory
            from the archive <filename>DDEXProvider-3.0.2.0-src.7z</filename> there as well.
              <note>
                <title>Author's remark</title>
                 <para>For some strange reason these files are absent from the archive
                  with the compiled dll libraries, but they are present in the source
                  code archive.</para>
              </note>
            </para>
          </listitem>
          <!-- 9 --><listitem>
            <para>Open the <filename>FirebirdDDEXProvider64.reg</filename> file in Notepad.
            Find the line that contains <classname>%path%</classname> and change it to the
            full path to the file <filename>FirebirdSql.VisualStudio.DataTools.dll</filename>, e.g.,
              <literallayout class="monospaced">
&quot;CodeBase&quot;=&quot;c:\\Program Files (x86)\\FirebirdDDEX\\FirebirdSql.VisualStudio.DataTools.dll&quot;
              </literallayout>
            </para>
          </listitem>

          <!-- 10 --><listitem>
            <para>Save this Registry file and run it. Click YES to the question about adding
            the information to the Registry.</para>
          </listitem>
          <!-- 11 --><listitem>
            <para>Now you need to edit the <filename>machine.config</filename> file.
            In my installation, the path is as follows:
              <literallayout class="monospaced">
  C:\Windows\Microsoft.NET\Framework\v4.0.30319\Config
              </literallayout>
            Open this file in Notepad. Find the following section:
              <literallayout class="monospaced">
  &lt;system.data&gt;
      &lt;DbProviderFactories&gt;
                    </literallayout>
                  Add the following lines to this section:
                    <literallayout class="monospaced">
&lt;add name=&quot;FirebirdClient Data Provider&quot;
     invariant=&quot;FirebirdSql.Data.FirebirdClient&quot;
     description=".Net Framework Data Provider for Firebird"
     type=&quot;FirebirdSql.Data.FirebirdClient.FirebirdClientFactory,
           FirebirdSql.Data.FirebirdClient, Version=4.10.0.0, Culture=neutral,
           PublicKeyToken=3750abcc3150b00c&quot; /&gt;
              </literallayout>
              <note>
                <para>The settings we have configured here are valid
                for version 4.10.0.</para>
              </note>
            </para>
            <para>Do the same for <filename>machine.config</filename> located at
            <filename>c:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\</filename>
            </para>
          </listitem>
        </orderedlist>
      </section> <!-- fbdg30-efw-vs-install-steps -->

      <para>This completes the installation.</para>

      <section id="fbdg30-efw-vs-install-testit">
        <title>Testing the Installation</title>
        <para>To make sure that everything has been installed successfully, start
        Visual Studio 2015. Find the Server Explorer and try to connect to an
        existing Firebird database.
          <figure id="efw-test-install">
            <title>Choose data source for testing installation</title>
            <mediaobject>
              <imageobject>
              <!-- actual image size is 504px X 341px -->
                <imagedata fileref="images/fbdevgd30_efw_001_en.png" format="PNG"
                width="428px" depth="290px"
                scalefit="1" align="center" />  <!-- 85% -->
              </imageobject>
            </mediaobject>
          </figure>
          <!-- -->
          <figure id="efw-database-locate">
            <title>Locate a database</title>
              <mediaobject>
                <imageobject>
                <!-- actual image size is 565px X 476px -->
                  <imagedata fileref="images/fbdevgd30_efw_002_en.png" format="PNG"
                  width="480px" depth="405px"
                  scalefit="1" align="center" />  <!-- 85% -->
              </imageobject>
            </mediaobject>
          </figure>
          <!-- -->
          <figure id="efw-data-src-test-confirm">
            <title>Test and confirm the connection</title>
            <mediaobject>
              <imageobject>
              <!-- actual image size is 251px X 165px -->
                <imagedata fileref="images/fbdevgd30_efw_003_en.png" format="PNG"
                width="213px" depth="140px"
                scalefit="1" align="center" />  <!-- 85% -->
              </imageobject>
            </mediaobject>
          </figure>
        </para>
      </section> <!-- fbdg30-efw-vs-install-testit -->
    </section> <!-- fbdg30-efw-vs-install -->
  </section> <!-- fbdg30-efw-vs-prepare -->

  <section id="fbdg30-efw-vs-crtproject">
    <title>Creating a Project</title>
    <para>For our example in this chapter, we will create a <classname>Windows Forms</classname> 
    application. Other types of applications differ from it, but the principles of working with 
    Firebird via Entity Framework remain the same.</para>

    <section id="fbdg30-efw-vs-crtproj-add-pkgs">
      <title>Adding Packages to the Project</title>
      <para>The first task after creating a Windows Forms project is to add the following packages
      to it, using the NuGet package manager:
        <itemizedlist spacing="compact">
          <listitem><filename>FirebirdSql.Data.FirebirdClient</filename></listitem>
          <listitem><filename>EntityFramework</filename></listitem>
          <listitem><filename>EntityFramework.Firebird</filename></listitem>
        </itemizedlist>
      Right-click the project name in Solution Explorer and select <classname>Manage
      NuGet Packages</classname> from the drop-down list.</para>
      <para>
        <figure id="efw-nuget-select-pkgs">
          <title>Solution Explorer&mdash;&gt;select NuGet packages</title>
          <mediaobject>
            <imageobject>
            <!-- actual image size is 502px X 467px (cropped) -->
              <imagedata fileref="images/fbdevgd30_efw_004_en.png" format="PNG"
              width="427px" depth="367px"
              scalefit="1" align="center" />  <!-- 85% -->
            </imageobject>
          </mediaobject>
        </figure>
      </para>
      <para>Find the packages listed above in the Nuget catalogue and install them in
      the package manager.
        <figure id="efw-nuget-install-pkgs">
          <title>Select and install packages from NuGet catalogue</title>
          <mediaobject>
            <imageobject>
            <!-- actual image size is 903px X 649px -->
              <imagedata fileref="images/fbdevgd30_efw_005_en.png" format="PNG"
              width="497px" depth="359px"
              scalefit="1" align="center" />  <!-- 85% -->
            </imageobject>
          </mediaobject>
        </figure>
      </para>
    </section>
  </section> <!-- fbdg30-efw-vs-crtproject -->

  <section id="fbdg30-efw-vs-crt-edm">
    <title>Creating an Entity Data Model (EDM)</title>
    <para>In our application, we will use the <classname>Code First</classname> approach.</para>

    <para>To create an EDM, right-click the project name in Solution Explorer and select
    <classname>Add&mdash;&gt;New Item</classname> from the menu.

      <figure id="efw-add-new-item">
        <title>Solution Explorer - Add&mdash;&gt;New Item</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 605px X 614px -->
            <imagedata fileref="images/fbdevgd30_efw_006_en.png" format="PNG"
            width="496px" depth="503px"
            scalefit="1" align="center" />  <!-- 82% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>

    <para>Next, in the <classname>Add New Item</classname> wizard, select <classname>ADO.NET Entity
    Data Model</classname>.
      <figure id="efw-select-ado-net">
        <title>Add New Item wizard - select ADO.NET Entity Data Model</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 941px X 484px  CROPPED-->
            <imagedata fileref="images/fbdevgd30_efw_007_en.png" format="PNG"
            width="499px" depth="257px"
            scalefit="1" align="center" />  <!-- 53% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>

    <para>Since we already have a database, we will generate the EDM from the database. Select the
    icon captioned <classname>Code First from database</classname>.
      <figure id="efw-select-code-first">
        <title>Add New Item wizard - select 'Code First from database'</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 617px X 399px  CROPPED-->
            <imagedata fileref="images/fbdevgd30_efw_008_en.png" format="PNG"
            width="499px" depth="323px"
            scalefit="1" align="center" />  <!-- 80.88%% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>

    <para>Now we need to to select the connection the model will be created from. If the
    connection does not exist, it will have to be created.
      <figure id="efw-choose-connection">
        <title>Add New Item wizard - choose Connection</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 617px X 560px -->
            <imagedata fileref="images/fbdevgd30_efw_009_en.png" format="PNG"
            width="494px" depth="448px"
            scalefit="1" align="center" /> <!-- 80% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <para>You might need to specify some advanced properties in addition to the main
    connection properties. You might want to set the transaction isolation, for example,
    to a level different from the default <classname>Read Committed</classname>, or to
    specify connection pooling, or something else that differs from defaults.
      <figure id="efw-conn-properties">
        <title>Add Connection wizard - Connection properties</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 565px X 476px -->
            <imagedata fileref="images/fbdevgd30_efw_010_en.png" format="PNG"
            width="458px" depth="386px"
            scalefit="1" align="center" /> <!-- 81% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>

    <para>
      <figure id="efw-adv-conn-props">
        <title>Add Connection wizard - Advanced connection properties</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 345px X 412px -->
            <imagedata fileref="images/fbdevgd30_efw_011_en.png" format="PNG"
            width="232px" depth="277px"
            scalefit="1" align="center" /> <!-- 67.23% -->
          </imageobject>
        </mediaobject>
      </figure>
      <tip>
        <para>Snapshot is the recommended isolation level because Entity Framework and
        ADO.NET both use disconnected data access&mdash;where each connection and each
        transaction is active only for a very short time.</para>
      </tip>
    </para>

    <para>Next, the Entity Data Model wizard will ask you how to store the connection string.
      <figure id="efw-conn-str-storage">
        <title>EDM wizard - connection string storage</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 617px X 559px -->
            <imagedata fileref="images/fbdevgd30_efw_012_en.png" format="PNG"
            width="494px" depth="447px"
            scalefit="1" align="center" /> <!-- 80% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>

    <para>For a web application or another three-tier architecture, where all users
    will be working with the database using a single account, select <command>Yes</command>.
    If your application is going to request authentication for connecting to the database,
    select <command>No</command>.
      <tip>
        <para>It is much more convenient to work with wizards if you select Yes for each
        property. You can always change the isolation level in the application when it is
        ready for testing and deployment by just editing the connection string in the
        <filename>&lt;AppName&gt;.exe.conf</filename> application configuration file.
        The connection string will be stored in the <classname>connectionStrings</classname>
        section and will look approximately like this:
          <literallayout class="monospaced">
&lt;add name="DbModel"
  connectionString="character set=UTF8; data source=localhost;
  initial catalog=examples; port number=3050;
  user id=sysdba; dialect=3; isolationlevel=Snapshot;
  pooling=True; password=masterkey;"
  providerName="FirebirdSql.Data.FirebirdClient" /&gt;
          </literallayout>
        </para>
        <para>For the configuration file to stop storing the confidential information,
        just delete this parameter from the connection string:
        <filename>password=masterkey;</filename>
        </para>
      </tip>
    </para>

    <important>
      <title>Firebird 3.0 Notes</title>
      <para>Unfortunately, the current ADO.Net provider for Firebird (version 5.9.0.0) does not
      support network traffic encryption, which is enabled by default in Firebird 3.0 and higher
      versions. If you want to work with Firebird 3.0, you need to change some settings in
      <filename>firebird.conf</filename> (or in <filename>databases.conf</filename> for a
      specific database) to make Firebird to work without trying to use network encryption.</para>
      <para>To do it, change the setting from the default
        <literallayout class="monospaced">
 # WireCrypt = Enabled
        </literallayout>
        to
        <literallayout class="monospaced">
 WireCrypt = Disabled
        </literallayout>
      making sure to delete the '#' comment marker.  Remember that you must restart the server
      for configuration changes to take effect.
      </para>
    </important>

     <para>Next, you will be asked which tables and views should be included in the model.
       <figure ide="efw-select-tables">
        <title>EDM wizard - select tables and views</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 617px X 559px -->
            <imagedata fileref="images/fbdevgd30_efw_013_en.png" format="PNG"
            width="494px" depth="447px"
            scalefit="1" align="center" /> <!-- 80% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <para>For our project, select the four tables that are checked in the screenshot.
    </para>

    <para>The basic EDM is now ready.</para>

    <section id="fbdg30-efw-vs-crt-edm-files">
      <title>The EDM Files</title>
      <para>When the wizard's work is finished, you should have five new files: a model
      file and four files each describing an entity in the model.</para>

      <section id="fbdg30-efw-vs-crt-edm-entityfile">
        <title>An Entity File</title>
        <para>Let's take a look at the generated file describing the INVOICE entity:
          <programlisting>
[Table("Firebird.INVOICE")]
public partial class INVOICE
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage",
"CA2214:DoNotCallOverridableMethodsInConstructors")]
    public INVOICE()
    {
      INVOICE_LINES = new HashSet&lt;INVOICE_LINE&gt;();
    }

    [Key]
    [DatabaseGenerated(DatabaseGeneratedOption.None)]
    public int INVOICE_ID { get; set; }

    public int CUSTOMER_ID { get; set; }

    public DateTime? INVOICE_DATE { get; set; }

    public decimal? TOTAL_SALE { get; set; }

    public short PAYED { get; set; }

    public virtual CUSTOMER CUSTOMER { get; set; }

    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage",
"CA2227:CollectionPropertiesShouldBeReadOnly")]
    public virtual ICollection&lt;INVOICE_LINE&gt; INVOICE_LINES { get; set; }
}
          </programlisting>
        The class contains properties for each field of the INVOICE table. Each of these
        properties has attributes that describe constraints. You can study the details of the
        various attributes in the Microsoft document,
        <ulink url="https://msdn.microsoft.com/en-us/data/jj591583">Code First Data Annotations</ulink>.
        </para>

        <section id="fbdg30-efw-vs-edm-files-navig">
          <title>Navigation Properties and <quote>Lazy Loading</quote></title>
          <para>Two navigation properties are generated: CUSTOMER and INVOICE_LINES. The first
          one contains a reference to the customer entity. The second contains a collection of
          invoice lines. It is generated because the INVOICE_LINE table has a foreign key to the
          INVOICE table. Of course, you can remove this property from the INVOICE entity, but
          it is not really necessary. The CUSTOMER and INVOICE_LINES properties use
          <quote>lazy loading</quote> which means that loading is not performed until the
          first access to an object.  That way, the loading of related data is avoided unless
          it is actually needed. Once the data are accessed via the navigation property, they will
          be loaded from the database automatically. </para>
          <important>
            <para>If lazy loading is in effect, classes that use it must be public and their
            properties must have the keywords <code role="bold">public</code>
            and <code role="bold">virtual</code>.</para>
          </important>
        </section>
      </section> <!-- fbdg30-efw-vs-crt-edm-entityfile -->

      <section id="fbdg30-efw-vs-crt-edm-dbmodelfile">
        <title>The DbModel File</title>
        <para>Next, we examine the <filename>DbModel.cs</filename> file that describes
        the overall model.
          <programlisting>
    public partial class DbModel : DbContext
    {
        public DbModel()
            : base("name=DbModel")
        {
        }

        public virtual DbSet&lt;CUSTOMER&gt; CUSTOMERS { get; set; }
        public virtual DbSet&lt;INVOICE&gt; INVOICES { get; set; }
        public virtual DbSet&lt;INVOICE_LINE&gt; INVOICE_LINES { get; set; }
        public virtual DbSet&lt;PRODUCT&gt; PRODUCTS { get; set; }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;CUSTOMER&gt;()
                .Property(e => e.ZIPCODE)
                .IsFixedLength();

            modelBuilder.Entity&lt;CUSTOMER&gt;()
                .HasMany(e => e.INVOICES)
                .WithRequired(e =&gt; e.CUSTOMER)
                .WillCascadeOnDelete(false);

            modelBuilder.Entity&lt;PRODUCT&gt;()
                .HasMany(e => e.INVOICE_LINES)
                .WithRequired(e =&gt; e.PRODUCT)
                .WillCascadeOnDelete(false);

            modelBuilder.Entity&lt;INVOICE&gt;()
                .HasMany(e => e.INVOICE_LINES)
                .WithRequired(e =&gt; e.INVOICE)
                .WillCascadeOnDelete(false);

        }
    }
          </programlisting>
        </para>
        <para>The properties coded here describe a dataset for each entity, along with advanced
        properties that are specified for creating a model with Fluent API. A complete description
        of the Fluent API can be found in the Microsoft document entitled
        <ulink url="https://msdn.microsoft.com/en-us/data/jj591617.aspx">Configuring/Mapping
        Properties and Types with the Fluent API</ulink>.</para>
        <para>We will use the Fluent API to specify precision and scale for properties of
        type DECIMAL in the <classname>OnModelCreating</classname> method, by adding the
        following lines:
          <programlisting>
            modelBuilder.Entity&lt;PRODUCT&gt;()
                .Property(p =&gt; p.PRICE)
                .HasPrecision(15, 2);
            modelBuilder.Entity&lt;INVOICE&gt;()
                .Property(p =&gt; p.TOTAL_SALE)
                .HasPrecision(15, 2);

            modelBuilder.Entity&lt;INVOICE_LINE&gt;()
                .Property(p =&gt; p.SALE_PRICE)
                .HasPrecision(15, 2);

            modelBuilder.Entity&lt;INVOICE_LINE&gt;()
                .Property(p =&gt; p.QUANTITY)
                .HasPrecision(15, 0);
          </programlisting>
        </para>
      </section> <!-- fbdg30-efw-vs-crt-edm-dbmodelfile -->
    </section> <!-- fbdg30-efw-vs-crt-edm-files -->
  </section> <!-- fbdg30-efw-vs-crt-edm -->

  <section id="fbdg30-efw-vs-crt-gui">
    <title>Creating a User Interface</title>
    <para>In our application, we will create interfaces for two primary entities: a form
    each for the product and the customer entities. Each form contains a DataGridView grid,
    a ToolStrip toolbar with buttons and also a BindingSource component that is used to
    bind data to the controls on the form.
      <figure id="efw-forn-cust-entty">
        <title>A form for the Customer entity</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 641px X 509px -->
            <imagedata fileref="images/fbdevgd30_efw_014_en.png" format="PNG"
            width="494px" depth="392px"
            scalefit="1" align="center" /> <!-- 77% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <para>Since both forms are similar in function and implementation, we will describe
    just one.</para>

    <section id="fbdg30-efw-vs-context">
      <title>Getting a Context</title>
      <para>To work with our model, we will need the method for getting a context (or a model).
      The following statement is sufficient for that purpose:
        <literallayout class="monospaced">
  DbModel dbContext = new DbModel();
        </literallayout>
      If no confidential data  are stored in the connection string&mdash;for example, the
      password is absent because it will be captured during the authentication process
      when the application is started&mdash;we will need a special method for storing and
      recovering the connection string or for storing the previously created context. For
      that, we will create a special class containing  some application-level global
      variables, along with a method for getting a context.</para>
      <para>A context might be  the start and end dates of  a work period, for example.</para>
      <programlisting>
static class AppVariables
{
    private static DbModel dbContext = null;

    /// &lt;summary&gt;
    /// Start date of the working period
    /// &lt;/summary&gt;
    public static DateTime StartDate { get; set; }

    /// &lt;summary&gt;
    /// End date of the working period
    /// &lt;/summary>
    public static DateTime FinishDate { get; set; }

    /// &lt;summary&gt;
    /// Returns an instance of the model (context)
    /// &lt;/summary&gt;
    /// &lt;returns&gt;Model&lt;/returns&gt;
    public static DbModel CreateDbContext() {
        dbContext = dbContext ?? new DbModel();
        return dbContext;
    }
}
      </programlisting>
      <para>The connection string itself is applied after the authentication process
      completes successfully during the application launch. We will add the following
      code to the <classname>Load</classname> event handler of the main form for that.
        <programlisting>
private void MainForm_Load(object sender, EventArgs e) {
    var dialog = new LoginForm();
    if (dialog.ShowDialog() == DialogResult.OK)
    {
        var dbContext = AppVariables.getDbContext();
        try
        {
            string s = dbContext.Database.Connection.ConnectionString;
            var builder = new FbConnectionStringBuilder(s);
            builder.UserID = dialog.UserName;
            builder.Password = dialog.Password;
            dbContext.Database.Connection.ConnectionString = builder.ConnectionString;
            // try connect
            dbContext.Database.Connection.Open();
        }
        catch (Exception ex)
        {
           // display error
           MessageBox.Show(ex.Message, "Error");
           Application.Exit();
        }
     }
     else
        Application.Exit();
}
        </programlisting>
      </para>
      <para>Now, to get a context, we use the static <classname>CreateDbContext</classname>
      method:
        <literallayout class="monospaced">
var dbContext = AppVariables.getDbContext();
        </literallayout>
      </para>
    </section> <!-- fbdg30-efw-vs-context -->
  </section> <!-- fbdg30-efw-vs-crt-gui -->

  <section id="fbdg30-efw-work-with-data">
    <title>Working with Data</title>
    <para>The entities in the model definition contain no data. The easiest way to to
    load data is to call the <classname>Load</classname> method.   For example,
      <programlisting>
private void LoadCustomersData()
{
    dbContext.CUSTOMERS.Load();
    var customers = dbContext.CUSTOMERS.Local;
    bindingSource.DataSource = customers.ToBindingList();
}

private void CustomerForm_Load(object sender, EventArgs e)
{
    LoadCustomersData();
    dataGridView.DataSource = bindingSource;
    dataGridView.Columns["CUSTOMER_ID"].Visible = false;
}
      </programlisting>
    </para>
    <para>However, this approach has a few drawbacks:
      <orderedlist>
        <listitem>The <classname>Load</classname> method loads all data from the CUSTOMER table
        to memory at once</listitem>
        <listitem>Although lazy properties (INVOICES) are not loaded immediately, but only once they
        are accessed, they will be loaded anyway when the records are shown in the grid and it will
        happen each time a group of records is shown</listitem>
        <listitem>Record ordering is not defined</listitem>
      </orderedlist>
    </para>

    <para>To get around these drawbacks, we will use a feature of the LINQ (Language Integrated
    Query) technology, <firstterm>LINQ to Entities</firstterm>. LINQ to Entities offers a simple
    and intuitive approach to getting data using C# statements that are syntactically similar
    to SQL query statements. You can read about the LINQ syntax in
    <ulink url="https://docs.microsoft.com/en-us/dotnet/framework/data/adonet/ef/language-reference/linq-to-entities">LINQ
    to Entities</ulink>.
    </para>

    <section id="fbdg30-efw-linq">
      <title>LINQ Extension Methods</title>
      <para>The LINQ extension methods can return two objects: <classname>IEnumerable</classname>
      and <classname>IQueryable</classname>. The <classname>IQueryable</classname> interface
      is inherited from <classname>IEnumerable</classname> so, theoretically, an
      <classname>IQueryable</classname> object is also an <classname>IEnumerable</classname>.
      In reality, they are distinctly different.</para>
      <para>The <classname>IEnumerable</classname> interface is in the
      <classname>System.Collections</classname> namespace. An <classname>IEnumerable</classname>
      object is a collection of data in memory that can be addressed only in a forward
      direction. During the query execution, <classname>IEnumerable</classname> loads
      all data.  Filtering, if required, is done on the client side.</para>
      <para>The <classname>IQueryable</classname> interface is in the
      <classname>System.Linq</classname> namespace. It provides remote access to the database
      and movement through the data can be bi-directional. During the process of creating a query
      that returns an <classname>IQueryable</classname> object, the query is optimized to
      minimise memory usage and network bandwidth.</para>
      <para>The <classname>Local</classname> property returns the IEnumerable interface,
      through which we can create LINQ queries.
        <programlisting>
private void LoadCustomersData()
{
    var dbContext = AppVariables.getDbContext();
    dbContext.CUSTOMERS.Load();
    var customers =
        from customer in dbContext.CUSTOMERS.Local
        orderby customer.NAME
        select new customer;
    bindingSource.DataSource = customers.ToBindingList();
}
        </programlisting>
      </para>
      <para>However, as this query will be executed on the data in memory, it is really
      useful only for small tables that do not need to be filtered beforehand.</para>
      <para>For a LINQ query to be converted into SQL and executed on the server, we
      need to access the dbContext.CUSTOMERS directly instead of accessing the
      <classname>dbContext.CUSTOMERS.Local</classname> property in the LINQ query.
      The prior call to <classname>dbContext.CUSTOMERS.Load();</classname> to load the
      collection to memory is not required.</para>

      <section id="fbdg30-efw-linq-bindinglist">
        <title>IQueryable and BindingList</title>
        <para><classname>IQueryable</classname> objects present a small problem:
        they cannot return BindingList. <classname>BindingList</classname> is a base
        class for creating a two-way data-binding mechanism. We can use the
        <classname>IQueryable</classname> interface to get a regular list by calling
        <classname>ToList</classname> but, this way, we lose handy features
        such as sorting in the grid and several more. The deficiency was fixed
        in .NET Framework 5 by creating a special extension. To do the same thing
        in FW4, we will create our own solution.
          <programlisting>
public static class DbExtensions
{
    // Internal class for map generator values to it
    private class IdResult
    {
        public int Id { get; set; }
    }

    // Cast IQueryable to BindingList
    public static BindingList&lt;T&gt; ToBindingList&lt;T&gt;
       (this IQueryable&lt;T&gt; source) where T : class
    {
        return (new ObservableCollection&lt;T&gt;(source)).ToBindingList();
    }

    // Get the next value of the sequence
    public static int NextValueFor(this DbModel dbContext, string genName)
    {
        string sql = String.Format(
          "SELECT NEXT VALUE FOR {0} AS Id FROM RDB$DATABASE", genName);
        return dbContext.Database.SqlQuery&lt;IdResult&gt;(sql).First().Id;
    }

    // Disconnect all objects from the DbSet collection from the context
    // Useful for updating the cache
    public static void DetachAll&lt;T&gt;(this DbModel dbContext, DbSet&lt;T&gt; dbSet)
       where T : class
    {
        foreach (var obj in dbSet.Local.ToList())
        {
            dbContext.Entry(obj).State = EntityState.Detached;
        }
    }

    // Update all changed objects in the collection
    public static void Refresh(this DbModel dbContext, RefreshMode mode,
        IEnumerable collection)
    {
        var objectContext = ((IObjectContextAdapter)dbContext).ObjectContext;
        objectContext.Refresh(mode, collection);
    }

    // Update the object
    public static void Refresh(this DbModel dbContext, RefreshMode mode,
        object entity)
    {
        var objectContext = ((IObjectContextAdapter)dbContext).ObjectContext;
        objectContext.Refresh(mode, entity);
    }
}
          </programlisting>
        </para>
      </section> <!-- fbdg30-efw-linq-bindinglist -->

      <section id="fbdg30-efw-linq-other-extensions">
        <title>Other Extensions</title>
        <para>There are several more extensions in the <classname>iQueryable</classname> interface:
          <variablelist>
            <varlistentry>
              <term>NextValueFor</term>
              <listitem>is used to get the next value from the generator.</listitem>
            </varlistentry>
            <varlistentry>
              <term>dbContext.Database.SqlQuery</term>
              <listitem>
              allows SQL queries to be executed directly and their results to be displayed
              on some entity (projection). <!-- NEEDS CLARIFICATION --></listitem>
            </varlistentry>
            <varlistentry>
              <term>DetachAll</term>
              <listitem>is used to detach all objects of the DBSet collection from the context.
              It is necessary to update the internal cache, because all retrieved data are cached
              and are not retrieved from the database again. However, that is not always useful
              because it makes it more difficult to get the latest version of  records that were
              modified in another context.
                  <note>
                    <para>In web applications, a context usually exists for a very short period.
                    A new context has an empty cache.</para>
                </note>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Refresh</term>
              <listitem>is used to update the properties of an entity object. It is useful
              for updating the properties of an object after it has been edited or added.</listitem>
            </varlistentry>
          </variablelist>
        </para>
      </section>

      <section id="fbdg30-efw-linq-load-code">
        <title>Code for Loading the Data</title>
        <para>Our code for loading data will look like this:
          <programlisting>
private void LoadCustomersData()
{
    var dbContext = AppVariables.getDbContext();
    // disconnect all loaded objects
    // this is necessary to update the internal cache
    // for the second and subsequent calls of this method
    dbContext.DetachAll(dbContext.CUSTOMERS);
    var customers =
        from customer in dbContext.CUSTOMERS
        orderby customer.NAME
        select customer;
    bindingSource.DataSource = customers.ToBindingList();
}

private void CustomerForm_Load(object sender, EventArgs e)
{
    LoadCustomersData();
    dataGridView.DataSource = bindingSource;
    dataGridView.Columns["INVOICES"].Visible = false;
    dataGridView.Columns["CUSTOMER_ID"].Visible = false;
    dataGridView.Columns["NAME"].HeaderText = "Name";
    dataGridView.Columns["ADDRESS"].HeaderText = "Address";
    dataGridView.Columns["ZIPCODE"].HeaderText = "ZipCode";
    dataGridView.Columns["PHONE"].HeaderText = "Phone";
}
          </programlisting>
        </para>
        <section id="fbdg30-efw-addcustomer">
          <title>Adding a Customer</title>
          <para>This is the code of the event handler for clicking the Add button:
            <programlisting>
private void btnAdd_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  // creating a new entity instance
  var customer = (CUSTOMER)bindingSource.AddNew();
  // create an editing form
  using (CustomerEditorForm editor = new CustomerEditorForm()) {
    editor.Text = "Add customer";
    editor.Customer = customer;
    // Form Close Handler
    editor.FormClosing += delegate (object fSender,
      FormClosingEventArgs fe) {
      if (editor.DialogResult == DialogResult.OK) {
        try {
          // get next sequence value
          // and assign it
          customer.CUSTOMER_ID = dbContext.NextValueFor("GEN_CUSTOMER_ID");
          // add a new customer
          dbContext.CUSTOMERS.Add(customer);
          // trying to save the changes
          dbContext.SaveChanges();
          // and update the current record
          dbContext.Refresh(RefreshMode.StoreWins, customer);
        }
        catch (Exception ex) {
          // display error
          MessageBox.Show(ex.Message, "Error");
          // Do not close the form to correct the error
          fe.Cancel = true;
        }
      }
      else
        bindingSource.CancelEdit();
    };
    // show the modal form
    editor.ShowDialog(this);
  }
}
            </programlisting>

          While adding the new record, we used the generator to get the value of the
          next identifier. We could have done it without applying the value of the
          identifier, leaving the BEFORE INSERT trigger to fetch the next value of the
          generator and apply it. However, that would leave us unable to update the
          added record.
          </para>
        </section>

        <section id="fbdg30-efw-editcustomer">
          <title>Editing a Customer</title>
          <para>The code of the event handler for clicking the Edit button is
          as follows:
            <programlisting>
private void btnEdit_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  // get instance
  var customer = (CUSTOMER)bindingSource.Current;
  // create an editing form
  using (CustomerEditorForm editor = new CustomerEditorForm()) {
    editor.Text = "Edit customer";
    editor.Customer = customer;
    // Form Close Handler
    editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
      if (editor.DialogResult == DialogResult.OK) {
        try {
          // trying to save the changes
          dbContext.SaveChanges();
          dbContext.Refresh(RefreshMode.StoreWins, customer);
          // update all related controls
          bindingSource.ResetCurrentItem();
        }
        catch (Exception ex) {
          // display error
          MessageBox.Show(ex.Message, "Error");
          // Do not close the form to correct the error
          fe.Cancel = true;
        }
      }
      else
        bindingSource.CancelEdit();
    };
    // show the modal form
    editor.ShowDialog(this);
  }
}
            </programlisting>
          The form for editing the customer looks like this:
            <figure id="efw-cust-edit-form">
              <title>Customer edit form</title>
              <mediaobject>
                <imageobject>
                <!-- actual image size is 385px X 311px -->
                  <imagedata fileref="images/fbdevgd30_efw_015_en.png" format="PNG"
                  width="308px" depth="249px"
                  scalefit="1" align="center" /> <!-- 80% -->
                </imageobject>
              </mediaobject>
            </figure>
          </para>

          <para>The code for binding to data is very simple.
            <programlisting>
public CUSTOMER Customer { get; set; }

private void CustomerEditorForm_Load(object sender, EventArgs e)
{
    edtName.DataBindings.Add("Text", this.Customer, "NAME");
    edtAddress.DataBindings.Add("Text", this.Customer, "ADDRESS");
    edtZipCode.DataBindings.Add("Text", this.Customer, "ZIPCODE");
    edtPhone.DataBindings.Add("Text", this.Customer, "PHONE");
}
            </programlisting>
          </para>
        </section> <!-- fbdg30-efw-editcustomer -->

        <section id="fbdg30-efw-dltcustomer">
          <title>Deleting a Customer</title>
          <para>The code of the event handler for clicking the Delete button
          is as follows:
            <programlisting>
private void btnDelete_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  var result = MessageBox.Show("Are you sure you want to delete the customer?",
    "Confirmation",
    MessageBoxButtons.YesNo,
    MessageBoxIcon.Question);
  if (result == DialogResult.Yes) {
    // get the entity
    var customer = (CUSTOMER)bindingSource.Current;
    try {
      dbContext.CUSTOMERS.Remove(customer);
      // trying to save the changes
      dbContext.SaveChanges();
      // remove from the linked list
      bindingSource.RemoveCurrent();
    }
    catch (Exception ex) {
      // display error
      MessageBox.Show(ex.Message, "Error");
    }
  }
}
            </programlisting>
          </para>
        </section> <!-- fbdg30-efw-dltcustomer -->
      </section> <!-- fbdg30-efw-linq-load-code -->
    </section> <!-- fbdg30-efw-linq -->
  </section> <!-- fbdg30-efw-work-with-data -->

  <section id="fbdg30-efw-secondary-modules">
    <title>Secondary Modules</title>
    <para>Our application will have only one secondary module, named <quote>Invoices</quote>.
    Secondary modules typically  contain larger numbers of records than primary ones
    and new records are added to them frequently.</para>

    <para>An invoice consists of a title where some general attributes are described (number, date,
    customer &hellip;) and invoice lines with the list of products, their quantities, prices, etc.
    It is convenient to have two grids for such documents: the main one showing the invoice header
    data and the detail one for the list of products sold. We will need one DataGridView component
    for each entity on the document form, binding the appropriate BindingSource to each.

      <figure id="efw-inv-form">
        <title>Invoice form</title>
         <mediaobject>
          <imageobject>
          <!-- actual image size is 791px X 529px -->
            <imagedata fileref="images/fbdevgd30_efw_016_en.png" format="PNG"
            width="554px" depth="370px"
            scalefit="1" align="center" /> <!-- 70% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>
    <section id="fbdg30-efw-filtering-data">
      <title>Filtering Data</title>
      <para>Most secondary entities contain a field with the document creation date. To reduce
      the amount of retrieved data, the concept of a work period is usually introduced to filter
      the data sent to the client. A work period is a range of dates for which the records
      are required. Since the application can have more than one secondary entity, it makes sense
      to add variables containing the start and end dates of a work period to the global
      <classname>AppVariables</classname> data module (see
      <link linkend="fbdg30-efw-vs-context">Getting a Context</link> that is used by all modules
      working with the database in one way or another. Once the application is started, the work
      period is usually defined by the dates when the current quarter starts and ends, although
      of course, other options are possible. While working with the application, the user can
      change the work period.</para>
      <para>Since the most recent records are the most requested, it makes sense to sort them by
      date in reverse order. As with the primary modules, we will use LINQ to retrieve data.
      </para>
    </section>

    <section id="fbdg30-efw-loading-inv-data">
      <title>Loading the Invoice Data</title>
      <para>The following method loads the invoice headers:
        <programlisting>
public void LoadInvoicesData() {
    var dbContext = AppVariables.getDbContext();

    var invoices =
        from invoice in dbContext.INVOICES
        where (invoice.INVOICE_DATE &gt;= AppVariables.StartDate) &amp;&amp;
              (invoice.INVOICE_DATE &lt;= AppVariables.FinishDate)
        orderby invoice.INVOICE_DATE descending
        select new InvoiceView
        {
            Id = invoice.INVOICE_ID,
            Cusomer_Id = invoice.CUSTOMER_ID,
            Customer = invoice.CUSTOMER.NAME,
            Date = invoice.INVOICE_DATE,
            Amount = invoice.TOTAL_SALE,
            Payed = (invoice.PAYED == 1) ? &quot;Yes&quot; : &quot;No&quot;
        };
    masterBinding.DataSource = invoices.ToBindingList();
}
        </programlisting>
      </para>

      <para>To simplify type casting, we define an <classname>InvoiceView</classname> class, rather
      than use some anonymous type.  The definition is as follows:
        <programlisting>
public class InvoiceView {
    public int Id { get; set; }

    public int Cusomer_Id { get; set; }

    public string Customer { get; set; }

    public DateTime? Date { get; set; }

    public decimal? Amount { get; set; }

    public string Payed { get; set; }

    public void Load(int Id) {
        var dbContext = AppVariables.getDbContext();
        var invoices =
            from invoice in dbContext.INVOICES
            where invoice.INVOICE_ID == Id
            select new InvoiceView
            {
                Id = invoice.INVOICE_ID,
                Cusomer_Id = invoice.CUSTOMER_ID,
                Customer = invoice.CUSTOMER.NAME,
                Date = invoice.INVOICE_DATE,
                Amount = invoice.TOTAL_SALE,
                Payed = (invoice.PAYED == 1) ? &quot;Yes&quot; : &quot;No&quot;
            };

        InvoiceView invoiceView = invoices.ToList().First();
        this.Id = invoiceView.Id;
        this.Cusomer_Id = invoiceView.Cusomer_Id;
        this.Customer = invoiceView.Customer;
        this.Date = invoiceView.Date;
        this.Amount = invoiceView.Amount;
        this.Payed = invoiceView.Payed;
    }
}
        </programlisting>
      The <classname>Load</classname> method allows us to update one added or
      updated record in the grid quickly, instead of completely reloading
      all records. Here is the code of the event handler for clicking the Add button:
        <programlisting>
private void btnAddInvoice_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  var invoice = dbContext.INVOICES.Create();
  using (InvoiceEditorForm editor = new InvoiceEditorForm()) {
    editor.Text = "Add invoice";
    editor.Invoice = invoice;
    // Form Close Handler
    editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
      if (editor.DialogResult == DialogResult.OK) {
        try {
          // get next sequence value
          invoice.INVOICE_ID = dbContext.NextValueFor("GEN_INVOICE_ID");
          // add a record
          dbContext.INVOICES.Add(invoice);
          // trying to save the changes
          dbContext.SaveChanges();
          // add the projection to the grid list
          ((InvoiceView)masterBinding.AddNew()).Load(invoice.INVOICE_ID);
        }
        catch (Exception ex) {
          // display error
          MessageBox.Show(ex.Message, "Error");
          // Do not close the form to correct the error
          fe.Cancel = true;
        }
      }
    };
    // show the modal form
    editor.ShowDialog(this);
  }
}
        </programlisting>
      </para>

      <para>In our primary modules, the similarly-named method called dbContext.Refresh
      but, here, a record is updated by by calling the <classname>Load</classname>
      method of the <classname>InvoiceView</classname> class. The reason for the difference
      is that <classname>dbContext.Refresh</classname> is used to update entity objects,
      not the objects that can be produced by complex LINQ queries.</para>

      <para>The code of the event handler for clicking the Edit button:
        <programlisting>
private void btnEditInvoice_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  // find entity by id
  var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
  if (invoice.PAYED == 1) {
    MessageBox.Show("The change is not possible, the invoice has already been paid.",
                    "Error");
    return;
  }
  using (InvoiceEditorForm editor = new InvoiceEditorForm()) {
    editor.Text = "Edit invoice";
    editor.Invoice = invoice;
    // Form Close Handler
    editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
      if (editor.DialogResult == DialogResult.OK) {
        try {
          // trying to save the changes
          dbContext.SaveChanges();
          // refresh
          CurrentInvoice.Load(invoice.INVOICE_ID);
          masterBinding.ResetCurrentItem();
        }
        catch (Exception ex) {
          // display error
          MessageBox.Show(ex.Message, "Error");
          // Do not close the form to correct the error
          fe.Cancel = true;
        }
      }
    };
    editor.ShowDialog(this);
  }
}
        </programlisting>
      Here we needed to find an entity by the identifier provided
      in the current record. The CurrentInvoice is used to retrieve the invoice
      selected in the grid. This is how we code it:
        <programlisting>
public InvoiceView CurrentInvoice {
    get {
        return (InvoiceView)masterBinding.Current;
    }
}
        </programlisting>
      </para>
      <para>Using the same approach, you can implement deleting the invoice
        header yourself.</para>

      <section id="fbdg30-efw-invoicepay">
        <title>Paying an Invoice</title>
        <para>Besides adding, editing and deleting, we want one more operation for
        invoices: payment. Here is code for a method implementing this operation:
          <programlisting>
private void btnInvoicePay_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
  try {
    if (invoice.PAYED == 1)
      throw new Exception("The change is not possible, the invoice has already been paid.");
    invoice.PAYED = 1;
    // trying to save the changes
    dbContext.SaveChanges();
    // refresh record
    CurrentInvoice.Load(invoice.INVOICE_ID);
    masterBinding.ResetCurrentItem();
  }
  catch (Exception ex) {
    // display error
    MessageBox.Show(ex.Message, "Error");
  }
}
          </programlisting>
        </para>
      </section> <!-- fbdg30-efw-invoicepay -->
    </section> <!-- efw-loading-inv-data -->

    <section id="fbdg30-efw-showinvoicelines">
      <title>Showing the Invoice Lines</title>
      <para>We have two choices for displaying the invoice lines:
        <orderedlist>
          <listitem>Getting data for each invoice from the INVOICE_LINE navigation property
          and displaying the contents of this complex property in the detail grid,
          probably with LINQ transformations</listitem>
          <listitem>Getting the data for each invoice with a separate LINQ query that will be
          re-executed when the cursor moves to another record in the master grid</listitem>
        </orderedlist>
      </para>
      <para>Either way has its advantages and drawbacks.</para>
      <para>The first one assumes that we want to retrieve all invoices at once for the
      specified period together with the bound data from the invoice lines
      when the invoice form is opened. Although it is done with one SQL query,
      it may take quite a while and requires a large amount of random-access memory.
      It is better suited to web applications where records are usually displayed
      page by page.</para>
      <para>The second one is a bit more difficult to implement, but it allows the
      invoice form to be opened quickly and requires less resource. However, each time
      the cursor in the master grid moves, an SQL query will be executed, generating
      network traffic, albeit with only a small volume of data.</para>
      <para>For our application we will use the second approach. We need an event
      handler for the BindingSource component for editing the current record:
        <programlisting>
private void masterBinding_CurrentChanged(object sender, EventArgs e) {
    LoadInvoiceLineData(this.CurrentInvoice.Id);
    detailGridView.DataSource = detailBinding;
}
        </programlisting>
      </para>
      <para>Now, the method for loading the invoice data:
        <programlisting>
private void LoadInvoiceLineData(int? id) {
  var dbContext = AppVariables.getDbContext();
  var lines =
      from line in dbContext.INVOICE_LINES
      where line.INVOICE_ID == id
      select new InvoiceLineView
      {
          Id = line.INVOICE_LINE_ID,
          Invoice_Id = line.INVOICE_ID,
          Product_Id = line.PRODUCT_ID,
          Product = line.PRODUCT.NAME,
          Quantity = line.QUANTITY,
          Price = line.SALE_PRICE,
          Total = Math.Round(line.QUANTITY * line.SALE_PRICE, 2)
      };
  detailBinding.DataSource = lines.ToBindingList();
}
        </programlisting>
      </para>
      <para>We use the InvoiceLineView class as an extension:
        <programlisting>
public class InvoiceLineView {
    public int Id { get; set; }
    public int Invoice_Id { get; set; }
    public int Product_Id { get; set; }
    public string Product { get; set; }
    public decimal Quantity { get; set; }
    public decimal Price { get; set; }
    public decimal Total { get; set; }
}
        </programlisting>
        <note>
          <para>Unlike the InvoiceView class, this one has no method for
          loading one current record. In our example, the speed of reloading
          the detail grid it is not crucial, because one document does not
          contain thousands of items. Implementing this method is optional.</para>
        </note>
      </para>
      <para>Now we will add a special property for retrieving the current line
      of the document selected in the detail grid.
        <programlisting>
public InvoiceLineView CurrentInvoiceLine {
    get {
        return (InvoiceLineView)detailBinding.Current;
    }
}
        </programlisting>
      </para>
    </section> <!-- fbdg30-efw-showinvoicelines -->

    <section id="fbdg30-efw-stored-procs">
      <title>Working with Stored Procedures</title>
      <para>The methods we will use for adding, editing and deleting illustrate
      how to work with stored procedures in Entity Framework. As an example, this
      is the method for adding a new record:
        <programlisting>
private void btnAddInvoiceLine_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  // get current invoice
  var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
  if (invoice.PAYED == 1) {
    MessageBox.Show("The change is not possible, the invoice has already been paid.", "Error");
    return;
  }
  // create invoice position
  var invoiceLine = dbContext.INVOICE_LINES.Create();
  invoiceLine.INVOICE_ID = invoice.INVOICE_ID;
  // create the position editor of the invoice
  using (InvoiceLineEditorForm editor = new InvoiceLineEditorForm()) {
    editor.Text = "Add invoice line";
    editor.InvoiceLine = invoiceLine;
    // Form Close Handler
    editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
      if (editor.DialogResult == DialogResult.OK) {
        try {
          // create SP parameters
          var invoiceIdParam = new FbParameter("INVOICE_ID",
                                               FbDbType.Integer);
          var productIdParam = new FbParameter("PRODUCT_ID",
                                               FbDbType.Integer);
          var quantityParam = new FbParameter("QUANTITY", FbDbType.Integer);
          // initial parameters values
          invoiceIdParam.Value = invoiceLine.INVOICE_ID;
          productIdParam.Value = invoiceLine.PRODUCT_ID;
          quantityParam.Value = invoiceLine.QUANTITY;
          // execute stored procedure
          dbContext.Database.ExecuteSqlCommand(
            "EXECUTE PROCEDURE SP_ADD_INVOICE_LINE("
          + "@INVOICE_ID, @PRODUCT_ID, @QUANTITY)",
             invoiceIdParam,
             productIdParam,
             quantityParam);
          // refresh grids
          // reload current invoice record
          CurrentInvoice.Load(invoice.INVOICE_ID);
          // reload all record in detail grid
          LoadInvoiceLineData(invoice.INVOICE_ID);
          // refresh all related data
          masterBinding.ResetCurrentItem();
        }
        catch (Exception ex) {
          // display error
          MessageBox.Show(ex.Message, "Error");
          // Do not close the form to correct the error
          fe.Cancel = true;
        }
      }
    };
    editor.ShowDialog(this);
  }
}
        </programlisting>
      </para>

      <para>With our example, an update of the master grid record will
      be needed because one of its fields (TotalSale) contains aggregated information
      derived from the detail lines of the document. This is how we do that:
        <programlisting>
private void btnEditInvoiceLine_Click(object sender, EventArgs e) {
  var dbContext = AppVariables.getDbContext();
  // get current invoice
  var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
  if (invoice.PAYED == 1) {
    MessageBox.Show("The change is not possible, the invoice has already been paid.",
                    "Error");
    return;
  }
  // get current invoice position
  var invoiceLine = invoice.INVOICE_LINES
         .Where(p => p.INVOICE_LINE_ID == this.CurrentInvoiceLine.Id)
         .First();
  // create invoice position editor
  using (InvoiceLineEditorForm editor = new InvoiceLineEditorForm()) {
    editor.Text = "Edit invoice line";
    editor.InvoiceLine = invoiceLine;
    // form close handler
    editor.FormClosing += delegate (object fSender, FormClosingEventArgs fe) {
      if (editor.DialogResult == DialogResult.OK) {
        try {
          // create parameters
          var idParam = new FbParameter("INVOICE_LINE_ID", FbDbType.Integer);
          var quantityParam = new FbParameter("QUANTITY", FbDbType.Integer);
          // initial parameters values
          idParam.Value = invoiceLine.INVOICE_LINE_ID;
          quantityParam.Value = invoiceLine.QUANTITY;
          // execute stored procedure
          dbContext.Database.ExecuteSqlCommand(
              "EXECUTE PROCEDURE SP_EDIT_INVOICE_LINE("
            + "@INVOICE_LINE_ID, @QUANTITY)",
              idParam,
              quantityParam);
          // refresh grids
          // reload current invoice record
          CurrentInvoice.Load(invoice.INVOICE_ID);
          // reload all records in detail grid
          LoadInvoiceLineData(invoice.INVOICE_ID);
          // refresh all related controls
          masterBinding.ResetCurrentItem();
        }
        catch (Exception ex) {
          // display error
          MessageBox.Show(ex.Message, "Error");
          // Do not close the form to correct the error
          fe.Cancel = true;
        }
      }
    };
    editor.ShowDialog(this);
  }
}
        </programlisting>
      </para>

      <section id="fbdg30-efw-dltinvoice">
        <title>Deleting an Invoice Detail Line</title>

        <para>The method for deleting a detail record is implemented as follows:
          <programlisting>
private void btnDeleteInvoiceLine_Click(object sender, EventArgs e) {
  var result = MessageBox.Show(
    " Are you sure you want to delete the invoice item?",
    "Confirmation",
    MessageBoxButtons.YesNo,
    MessageBoxIcon.Question);
  if (result == DialogResult.Yes) {
    var dbContext = AppVariables.getDbContext();
    // get current invoice
    var invoice = dbContext.INVOICES.Find(this.CurrentInvoice.Id);
    try {
      if (invoice.PAYED == 1)
        throw new Exception("It is not possible to delete the entry, the invoice is paid.");
      // create parameters
      var idParam = new FbParameter("INVOICE_LINE_ID", FbDbType.Integer);
      // initialize parameters values
      idParam.Value = this.CurrentInvoiceLine.Id;
      // execute stored procedure
      dbContext.Database.ExecuteSqlCommand(
        "EXECUTE PROCEDURE SP_DELETE_INVOICE_LINE(@INVOICE_LINE_ID)",
        idParam);
      // update grids
      // reload current invoice
      CurrentInvoice.Load(invoice.INVOICE_ID);
      // reload all records in detail grids
      LoadInvoiceLineData(invoice.INVOICE_ID);
      // refresh related controls
      masterBinding.ResetCurrentItem();
    }
    catch (Exception ex) {
      // display error
      MessageBox.Show(ex.Message, "Error");
    }
  }
}
          </programlisting>
        </para>
      </section> <!-- fbdg30-efw-dltinvoice -->
    </section> <!-- fbdg30-efw-stored-procs -->

    <section id="fbdg30-efw-showing-products">
      <title>Showing Products for Selection</title>
      <para>In the methods for adding and editing invoice lines we
      used the form. For displaying products, we will use a TextBox
      control.
        <figure id="efw-product-form">
          <title>Product form</title>
          <mediaobject>
            <imageobject>
            <!-- actual image size is 398px X 269px -->
              <imagedata fileref="images/fbdevgd30_efw_017_en.png" format="PNG"
              width="318px" depth="215px"
              scalefit="1" align="center" /> <!-- 80% -->
            </imageobject>
          </mediaobject>
        </figure>
      </para>
      <para>A click on the button next to the TextBox will open a modal form with a
      grid for selecting products. The same modal form created for displaying the
      products is used for selecting them. The click handler code for the
      embedded button that initiates the form is:
        <programlisting>
public partial class InvoiceLineEditorForm : Form {
    public InvoiceLineEditorForm() {
        InitializeComponent();
    }

    public INVOICE_LINE InvoiceLine { get; set; }

    private void InvoiceLineEditorForm_Load(object sender, EventArgs e) {
        if (this.InvoiceLine.PRODUCT != null) {
            edtProduct.Text = this.InvoiceLine.PRODUCT.NAME;
            edtPrice.Text = this.InvoiceLine.PRODUCT.PRICE.ToString("F2");
            btnChooseProduct.Click -= this.btnChooseProduct_Click;
        }
        if (this.InvoiceLine.QUANTITY == 0)
            this.InvoiceLine.QUANTITY = 1;
        edtQuantity.DataBindings.Add("Value", this.InvoiceLine, "QUANTITY");
    }

    private void btnChooseProduct_Click(object sender, EventArgs e) {
        GoodsForm goodsForm = new GoodsForm();
        if (goodsForm.ShowDialog() == DialogResult.OK) {
            InvoiceLine.PRODUCT_ID = goodsForm.CurrentProduct.Id;
            edtProduct.Text = goodsForm.CurrentProduct.Name;
            edtPrice.Text = goodsForm.CurrentProduct.Price.ToString("F2");
        }
    }
}
        </programlisting>
      </para>
    </section> <!-- fbdg30-efw-showing-products -->
  </section> <!-- fbdg30-efw-secondary-modules -->

  <section id="fbdg30-efw-transactions">
    <title>Working with Transactions</title>
    <para>Whenever we call the <classname>SaveChanges()</classname> method while adding,
    updating or deleting, Entity Framework starts and ends an implicit transaction. Since
    we use disconnected data access, all operations are carried out within one transaction.
    Entity Framework starts and ends a transaction automatically for each data retrieval.
    We will take the following example to illustrate how automatic transactions work.</para>
    <para>Suppose we need to make a discount on goods selected in the grid. Without explicit
    transaction management, the code would be as follows:
      <programlisting>
var dbContext = AppVariables.getDbContext();
foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
    int id = (int)gridRows.Cells["Id"].Value;
    // here there is an implicit start and the completion of the transaction
    var product = dbContext.PRODUCTS.Find(id);
    // discount 10%
    decimal discount = 10.0m;
    product.PRICE = product.PRICE * (100 - discount) /100;
}
// here there is an implicit start and the completion of the transaction
// all changes occur in one transaction
dbContext.SaveChanges();
      </programlisting>
    </para>
    <para>Let's say we select 10 products. Ten implicit transactions will be used
    for finding the products by their identifiers.  One more transaction will be used
    to save the changes.</para>
    <para>If we control transactions explicitly, we can use just one transaction for
    the same piece of work. For example:
      <programlisting>
var dbContext = AppVariables.getDbContext();
// explicit start of a default transaction
using (var dbTransaction = dbContext.Database.BeginTransaction()) {
  string sql =
    "UPDATE PRODUCT " +
    "SET PRICE = PRICE * ROUND((100 - @DISCOUNT)/100, 2) " +
    "WHERE PRODUCT_ID = @PRODUCT_ID";
  try {
    // create query parameters
    var idParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
    var discountParam = new FbParameter("DISCOUNT", FbDbType.Decimal);
    // create a SQL command to update records
    var sqlCommand = dbContext.Database.Connection.CreateCommand();
    sqlCommand.CommandText = sql;
    // specify which transaction to use
    sqlCommand.Transaction = dbTransaction.UnderlyingTransaction;
    sqlCommand.Parameters.Add(discountParam);
    sqlCommand.Parameters.Add(idParam);
    // prepare query
    sqlCommand.Prepare();
    // for all selected records in the grid
    foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
      int id = (int)gridRows.Cells["Id"].Value;
      // initialize query parameters
      idParam.Value = id;
      discountParam.Value = 10.0m; // discount 10%
      // execute sql statement
      sqlCommand.ExecuteNonQuery();
    }
    dbTransaction.Commit();
  }
  catch (Exception ex) {
    dbTransaction.Rollback();
    MessageBox.Show(ex.Message, "error");
  }
}
      </programlisting>
    </para>

    <para>Our code starts the transaction with the default parameters.
      To specify your own parameters for a transaction, you should use the
      <classname>UseTransaction</classname> method.
      <programlisting>
private void btnDiscount_Click(object sender, EventArgs e) {
  DiscountEditorForm editor = new DiscountEditorForm();
  editor.Text = "Enter discount";
  if (editor.ShowDialog() != DialogResult.OK)
    return;

  bool needUpdate = false;
  var dbContext = AppVariables.getDbContext();
  var connection = dbContext.Database.Connection;
  // explicit start of transaction
  using (var dbTransaction = connection.BeginTransaction(IsolationLevel.Snapshot)) {
    dbContext.Database.UseTransaction(dbTransaction);
    string sql =
      "UPDATE PRODUCT " +
      "SET PRICE = ROUND(PRICE * (100 - @DISCOUNT)/100, 2) " +
      "WHERE PRODUCT_ID = @PRODUCT_ID";
    try {
      // create query parameters
      var idParam = new FbParameter("PRODUCT_ID", FbDbType.Integer);
      var discountParam = new FbParameter("DISCOUNT", FbDbType.Decimal);
      // create a SQL command to update records
      var sqlCommand = connection.CreateCommand();
      sqlCommand.CommandText = sql;
      // specify which transaction to use
      sqlCommand.Transaction = dbTransaction;
      sqlCommand.Parameters.Add(discountParam);
      sqlCommand.Parameters.Add(idParam);
      // prepare statement
      sqlCommand.Prepare();
      // for all selected records in the grid
      foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
        int id = (int)gridRows.Cells["PRODUCT_ID"].Value;
        // initialize query parameters
        idParam.Value = id;
        discountParam.Value = editor.Discount;
        // execute SQL statement
        needUpdate = (sqlCommand.ExecuteNonQuery() > 0) || needUpdate;
      }
      dbTransaction.Commit();
    }
    catch (Exception ex) {
      dbTransaction.Rollback();
      MessageBox.Show(ex.Message, "error");
      needUpdate = false;
    }
  }
  // refresh grid
  if (needUpdate) {
    // for all selected records in the grid
    foreach (DataGridViewRow gridRows in dataGridView.SelectedRows) {
      var product = (PRODUCT)bindingSource.List[gridRows.Index];
      dbContext.Refresh(RefreshMode.StoreWins, product);
    }
    bindingSource.ResetBindings(false);
  }
}
      </programlisting>
    </para>
    <para>That's it. Now only one transaction is used for the entire set of updates
    and there are no unnecessary commands for finding data.</para>

    <para>All that is left to do is to add a dialog box for entering the value of the
    discount and code to update data in the grid. Try to do it on your own.
    </para>
  </section> <!--fbdg30-efw-transactions -->
  <section id="fbdg30-efw-result">
    <title>The Result</title>
    <para>
      <figure id="efw-project-result">
        <title>The result of the Entity Framework project</title>
        <mediaobject>
          <imageobject>
          <!-- actual image size is 815px X 612px -->
            <imagedata fileref="images/fbdevgd30_efw_018_en.png" format="PNG"
            width="497px" depth="373px"
            scalefit="1" align="center" /> <!-- 77% -->
          </imageobject>
        </mediaobject>
      </figure>
    </para>
  </section> <!-- fbdg30-efw-result -->
  <section id="fbdg30-efw-vs-project-sourcecode">
    <title>Source Code</title>
    <para>You can get the source code for the sample application using
    this link: <ulink url="https://www.firebirdsql.org/file/documentation/reference_manuals/fbdevgd-en/code/FBFormAppExample.zip">FBFormAppExample.zip</ulink>.
    </para>
  </section>

</chapter>

