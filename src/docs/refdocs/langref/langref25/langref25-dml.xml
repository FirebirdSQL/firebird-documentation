<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="langref25-dml">
  <title>DML statements</title>

  <section id="langref25-dml-delete">
    <title><database>DELETE</database></title>

    <!--DELETE is KLAAR, behalve voor wat "puntjes op de i"-vraagjes in de comments!-->

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para><database>DELETE</database> removes rows from a database table or
      from one or more tables underlying a view. <database>WHERE</database>
      and <database>ROWS</database> clauses can limit the number of rows
      deleted. If neither <database>WHERE</database> nor
      <database>ROWS</database> is present, <database>DELETE</database>
      removes all the rows in the relation.</para>

      <!--FIND OUT: Can you delete from a CTE? And from a derived table?-->
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>DELETE
   [TRANSACTION <replaceable>name</replaceable>]
   FROM {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <listitem>
                <para>The <database>TRANSACTION</database> directive is only
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>In a pure DSQL session, <database>WHERE CURRENT
                OF</database> isn't of much use, since there exists no DSQL
                statement to create a cursor.</para>
              </listitem>

              <listitem>
                <para>The <database>PLAN</database>, <database>ORDER
                BY</database> and <database>ROWS</database> clauses are not
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>The <database>RETURNING</database> clause is not
                available in ESQL.<!--Sure about that ?--></para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When returning values into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (write <database>NEW</database>, not
                <database>:NEW</database>).</para>
              </listitem>
            </itemizedlist>
          </note>

          <!--Are only 'loose' plan_items allowed, or also JOIN, SORT, MERGE ?-->
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-delete-alias-use">
      <title>Aliases</title>

      <formalpara>
        <title>Description</title>

        <para>An alias can represent a relation throughout the statement.
        Attention: the alias obscures the formal relation name. Once declared,
        you must use either the alias or nothing to qualify field names, as
        the examples show.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>Supported usage:</para>

            <programlisting>delete from Cities where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities where Cities.name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where C.name starting 'Alex'</programlisting>

            <para>Not possible:</para>

            <programlisting>delete from Cities C where Cities.name starting 'Alex'</programlisting>

            <!--TODO: an example where the alias is meaningful (nulti-table)-->
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-transaction">
      <title><database>TRANSACTION</database></title>

      <formalpara>
        <title>Available in</title>

        <para>ESQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The optional <database>TRANSACTION</database> clause specifies
        under which active transaction the statement should be
        executed.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>delete transaction tr_cleanup from Buses where date_endlife is not null</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-where">
      <title><database>WHERE</database></title>

      <formalpara>
        <title>Description</title>

        <para>A <database>WHERE</database> clause limits the deletion to the
        rows matching the search condition, or – in ESQL and PSQL only – to
        the current row of a named cursor.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from People where firstname &lt;&gt; 'Boris' and lastname &lt;&gt; 'Johnson'</programlisting>

            <programlisting>delete from Cities where current of Cur_Cities;  -- ESQL and PSQL only</programlisting>
          </blockquote></para>
      </formalpara>

      <para>A delete using <database>WHERE CURRENT OF</database> is called a
      <firstterm>positioned delete</firstterm>, because it deletes the record
      at the current position. A delete using
      <quote><database>WHERE</database>
      <replaceable>&lt;condition&gt;</replaceable></quote> is called a
      <firstterm>searched delete</firstterm>, because the engine has to search
      for the record(s) meeting the condition.</para>
    </section>

    <section id="langref25-dml-delete-plan">
      <title><database>PLAN</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>A <database>PLAN</database> clause allows the user to optimize
        the operation manually.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>delete from Submissions
  where date_entered &lt; '1-Jan-2002'
  plan (Submissions index ix_subm_date)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-orderby">
      <title><database>ORDER BY</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The <database>ORDER BY</database> clause orders the set before
        the actual deletion takes place. It only makes sense in combination
        with <database>ROWS</database>, but is also valid without it.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from Purchases order by date rows 1           -- deletes oldest purchase</programlisting>

            <programlisting>delete from Sales order by custno desc rows 1 to 10  -- deletes from highest custno(s)</programlisting>

            <programlisting>delete from Sales order by custno desc  -- deletes all sales, <database>ORDER BY</database> clause pointless</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-rows">
      <title><database>ROWS</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Limits the amount of rows deleted to a specified number or
        range.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
          </blockquote></para>
      </formalpara>

      <para>With a single argument <replaceable>m</replaceable>, the deletion
      is limited to the first <replaceable>m</replaceable> rows of the dataset
      defined by the table or view and the optional <database>WHERE</database>
      and <database>ORDER BY</database> clauses.</para>

      <para>Points to note:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, no rows are
          deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, the deletion is limited to rows
      <replaceable>m</replaceable> to <replaceable>n</replaceable>
      inclusively. Row numbers are 1-based.</para>

      <para>Points to note when using two arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, no rows are deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, no rows are deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from popgroups order by name desc rows 1  -- will probably delete ZZ Top</programlisting>

            <programlisting>delete from popgroups order by formed rows 5     -- deletes 5 oldest groups</programlisting>

            <programlisting>delete from popgroups rows 5 to 12      -- no ordering, may delete any 8 groups</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-returning">
      <title><database>RETURNING</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>A <database>DELETE</database> statement removing <emphasis>at
        most one row</emphasis> may optionally include a
        <database>RETURNING</database> clause in order to return values from
        the deleted row. The clause, if present, need not contain all the
        relation's columns and may also contain other columns or expressions.
        When returning into the <database>NEW</database> context variable
        within a trigger, the preceding colon must be omitted.</para>

        <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from Scholars
  where firstname = 'Henry' and lastname = 'Higgins'
  returning lastname, fullname, id</programlisting>

            <programlisting>delete from Dumbbells
  order by iq desc
  rows 1
  returning lastname, iq into :lname, :iq;</programlisting>

            <programlisting>delete from TempSales ts
  where ts.id = tempid
  returning ts.qty into new.qty;  -- <emphasis>not</emphasis> <quote>:new.qty</quote></programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>In DSQL, a statement with a <database>RETURNING</database>
              clause <emphasis role="">always</emphasis> returns exactly one
              row. If no record was actually deleted, the fields in this row
              are all <constant>NULL</constant>. This behaviour may change in
              a later version of Firebird.</para>
            </listitem>

            <listitem>
              <para>In PSQL, if no row was deleted, nothing is returned, and
              the target variables keep their existing values.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
  </section>

  <section id="langref25-dml-execblock">
    <title><database>EXECUTE BLOCK</database></title>

    <!--EXECUTE BLOCK is KLAAR!-->

    <formalpara>
      <title>Available in</title>

      <para>DSQL</para>

      <!--ESQL: no-->
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Executes a block of PSQL code as if it were a stored procedure,
      optionally with input and output parameters and variable declarations.
      This allows the user to perform <quote>on-the-fly</quote> PSQL within a
      DSQL context.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparams&gt;</replaceable>         ::=  <replaceable>&lt;param_decl&gt;</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable> ]
<replaceable>&lt;outparams&gt;</replaceable>        ::=  <replaceable>&lt;param_decl&gt;</replaceable>     [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;param_decl&gt;</replaceable>       ::=  <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
<replaceable>&lt;type&gt;</replaceable>             ::=  <replaceable>sql_datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>
<replaceable>&lt;declarations&gt;</replaceable>     ::=  See <link
              linkend="langref25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax
<replaceable>&lt;PSQL statements&gt;</replaceable>  ::=  See the <link
              linkend="langref25-psql"><citetitle>PSQL</citetitle></link> chapter</programlisting>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Examples</title>

      <para><blockquote>
          <para>This example injects the numbers 0 through 127 and their
          corresponding ASCII characters into the table
          <database>ASCIITABLE</database>:</para>

          <programlisting>execute block
as
declare i int = 0;
begin
  while (i &lt; 128) do
  begin
    insert into AsciiTable values (:i, ascii_char(:i));
    i = i + 1;
  end
end</programlisting>
        </blockquote><blockquote>
          <para>The next example calculates the geometric mean of two numbers
          and returns it to the user:</para>

          <programlisting>execute block (x double precision = ?, y double precision = ?)
returns (gmean double precision)
as
begin
  gmean = sqrt(x*y);
  suspend;
end</programlisting>

          <para>Because this block has input parameters, it has to be prepared
          first. Then the parameters can be set and the block executed. It
          depends on the client software how this must be done and even if it
          is possible at all – see the notes below.</para>

          <para>Our last example takes two integer values,
          <varname>smallest</varname> and <varname>largest</varname>. For all
          the numbers in the range <varname>smallest</varname> ..
          <varname>largest</varname>, the block outputs the number itself, its
          square, its cube and its fourth power.</para>

          <programlisting>execute block (smallest int = ?, largest int = ?)
returns (number int, square bigint, cube bigint, fourth bigint)
as
begin
  number = smallest;
  while (number &lt;= largest) do
  begin
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    suspend;
    number = number + 1;
  end
end</programlisting>

          <para>Again, it depends on the client software if and how you can
          set the parameter values.</para>
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-execblock-params">
      <title>Input and output parameters</title>

      <para>Executing a block without input parameters should be possible with
      every Firebird client that allows the user to enter his or her own DSQL
      statements. If there are input parameters, things get trickier: these
      parameters must get their values after the statement is prepared but
      before it is executed. This requires special provisions, which not every
      client application offers. (Firebird's own
      <application>isql</application>, for one, doesn't.)</para>

      <para>The server only accepts question marks
      (<quote><literal>?</literal></quote>) as placeholders for the input
      values, not <quote><literal>:a</literal></quote>,
      <quote><literal>:MyParam</literal></quote> etc., or literal values.
      Client software may support the <quote><literal>:xxx</literal></quote>
      form though, and will preprocess it before sending it to the
      server.</para>

      <para>If the block has output parameters, you <emphasis>must</emphasis>
      use <database>SUSPEND</database> or nothing will be returned.</para>

      <para>Output is always returned in the form of a result set, just as
      with a <database>SELECT</database> statement. You can't use
      <database>RETURNING_VALUES</database> or execute the block
      <database>INTO</database> some variables, even if there is only one
      result row.</para>

      <para>For more information about parameter and variable declarations,
      [<database>TYPE OF</database>] <replaceable>domain</replaceable>,
      <database>TYPE OF COLUMN</database> etc., consult the chapter on <link
      linkend="langref25-psql">Procedural SQL</link>, in particular <link
      linkend="langref25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>.</para>
    </section>

    <section id="langref25-dml-execblock-terms">
      <title>Statement terminators</title>

      <para>Some clients, especially those allowing the user to submit several
      statements at once, may require you to surround the <database>EXECUTE
      BLOCK</database> statement with <database>SET TERM</database> lines,
      like this:</para>

      <programlisting>set term #;
execute block (...)
as
begin
  statement1;
  statement2;
end
#
set term ;#</programlisting>

      <para>As an example, in Firebird's <application>isql</application>
      client you must set the terminator to something other than
      <quote><literal>;</literal></quote> before you type in the
      <database>EXECUTE BLOCK</database> statement. If you don't,
      <application>isql</application> will try to execute the part you have
      typed so far as soon as you hit Enter after a line with a
      semicolon.</para>
    </section>
  </section>

  <section id="langref25-dml-execproc">
    <title><database>EXECUTE PROCEDURE</database></title>

    <!--EXECUTE BLOCK is KLAAR, behalve voor de vraagjes in de comments.-->

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Executes a stored procedure (SP), optionally taking input
      parameters and/or returning output values.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <!--Both Borland LangRef and IBPhoenix LangRef say that TRANSACTION clause comes before proc name!
If this is correct, change LangRef Update(s) as well!-->

          <programlisting>EXECUTE PROCEDURE
   [TRANSACTION <replaceable>transaction</replaceable>]
   <replaceable>procname</replaceable>
   [<replaceable>&lt;in_item&gt;</replaceable> [, <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>   ::=  <replaceable>&lt;inparam&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable>  ::=  <replaceable>&lt;outvar&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;inparam&gt;</replaceable>   ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>    ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>   ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>

          <note>
            <title>Notes</title>

            <itemizedlist>
              <listitem>
                <para>In ESQL, input parameters must be literals or host
                language variables. For output parameters, host variables must
                be specified in the <database>RETURNING_VALUES</database>
                clause. <constant>NULL</constant> indicators must be host
                language variables of type integer, with less than zero
                indicating <constant>NULL</constant> and zero or greater
                indicating not <constant>NULL</constant> (which means that a
                proper value is present in the corresponding
                parameter).</para>
              </listitem>

              <listitem>
                <para>In PSQL, input parameters may be any expression that
                resolves to the expected type. For output parameters, local
                variables must be specified in the
                <database>RETURNING_VALUES</database> clause.</para>
              </listitem>

              <listitem>
                <para>In DSQL, input parameters may be any expression that
                resolves to the expected type. The handling of output
                parameters depends on the client software.</para>
              </listitem>

              <listitem>
                <para>In PSQL and DSQL, <constant>NULL</constant> indicators
                are neither valid nor necessary. <constant>NULL</constant>s
                are passed via the input/output parameters themselves.</para>
              </listitem>

              <listitem>
                <para><database>TRANSACTION</database> clauses are not
                supported in PSQL.</para>

                <!--And in DSQL they are? That would surprise me. Find out!-->
              </listitem>

              <listitem>
                <para>In ESQL, variable names used as parameters or outvars
                must be preceded by a colon (<quote>:</quote>). In PSQL the
                colon is generally optional, but forbidden for the trigger
                context variables <database>OLD</database> and
                <database>NEW</database>.</para>
              </listitem>
            </itemizedlist>
          </note>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Examples</title>

      <para><blockquote>
          <para>In PSQL (with optional colons):</para>

          <programlisting>execute procedure MakeFullName
  :FirstName, :MiddleName, :LastName
  returning_values :FullName;</programlisting>

          <para>The same call in ESQL (with obligatory colons):</para>

          <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :MiddleName, :LastName
    returning_values :FullName;</programlisting>

          <para>...and in Firebird's command-line utility
          <application>isql</application> (with literal parameters):</para>

          <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>

          <para><emphasis role="bold">Note:</emphasis> In isql, don't use
          <database>RETURNING_VALUES</database>. Any output values are shown
          automatically.</para>

          <para>Finally, a PSQL example with expression parameters:</para>

          <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, MiddleName, upper(LastName)
  returning_values FullName;</programlisting>
        </blockquote></para>
    </formalpara>
  </section>

  <section id="langref25-dml-insert">
    <title><database>INSERT</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Adds rows to a database table or to one or more tables underlying
      a view. If the field values are given in a <database>VALUES</database>
      clause, exactly one row is inserted. The values may also be provided by
      a <database>SELECT</database> statement, in which case zero to many rows
      may be inserted. With the <database>DEFAULT VALUES</database> clause, no
      values are provided at all and exactly one row is inserted.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>INSERT [TRANSACTION <replaceable>name</replaceable>]
   INTO {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
   {DEFAULT VALUES | [(<replaceable>&lt;column_list&gt;</replaceable>)] <replaceable>&lt;value_source&gt;</replaceable>}
   [RETURNING <replaceable>&lt;value_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;column_list&gt;</replaceable>   ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;value_source&gt;</replaceable>  ::=  VALUES (<replaceable>&lt;value_list&gt;</replaceable>) | <replaceable>&lt;select_stmt&gt;</replaceable>
<replaceable>&lt;value_list&gt;</replaceable>    ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>     ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
<replaceable>&lt;select_stmt&gt;</replaceable>   ::=  a <database>SELECT</database> or UNION whose result set fits the target columns</programlisting>

          <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <!--I suppose DEFAULT VALUES not available in ESQL. Check.-->

              <listitem>
                <para>The <database>TRANSACTION</database> directive is only
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>The <database>RETURNING</database> clause is not
                available in ESQL.<!--still not in 2.1 ?--></para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When returning values into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (<quote><literal>:</literal></quote>).</para>
              </listitem>

              <listitem>
                <para>No column may appear more than once in the column
                list.</para>
              </listitem>
            </itemizedlist>
          </note>
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-insert-values">
      <title><database>INSERT</database> ...
      <database>VALUES</database></title>

      <para>The <database>VALUES</database> list must provide a value for
      every column in the column list, in the same order and of the correct
      type. If the column list is absent, values must be provided for every
      column in the table or view (computed columns excluded).</para>

      <para>String literals may optionally be preceded by a character set
      name, using <firstterm>introducer syntax</firstterm>, in order to let
      the engine know how to interpret the input.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>insert into cars (make, model, year)
  values ('Ford', 'T', 1908)</programlisting>

            <programlisting>insert into cars
  values ('Ford', 'T', 1908, 'USA', 850)

/* assuming that the columns of table Cars are: make, model, year, country, price */</programlisting>

            <programlisting>insert into People
  values (_ISO8859_1 'Hans-Jörg Schäfer')  -- notice the '_' prefix</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-insert-select">
      <title><database>INSERT</database> ...
      <database>SELECT</database></title>

      <para>Here, the output columns of the SELECT statement must provide a
      value for every target column in the column list, in the same order and
      of the correct type. If the column list is absent, values must be
      provided for every column in the table or view (computed columns
      excluded).</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>insert into cars (make, model, year)
  select (make, model, year) from new_cars</programlisting>

            <programlisting>insert into cars
  select * from new_cars

/* assuming that table New_cars has the exact same columns as table Cars */</programlisting>

            <programlisting>insert into Members (number, name)
  select number, name from NewMembers where Accepted = 1
    union
  select number, name from SuspendedMembers where Vindicated = 1</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Of course, the column names in the source table need not be the
      same as those in the target table. Any type of
      <database>SELECT</database> statement is permitted, as long as its
      output columns exactly match the insert columns in number, order and
      type. Types need not be exactly the same, but they must be
      assignment-compatible.</para>
    </section>

    <section id="langref25-dml-insert-defaults">
      <title><database>INSERT</database> ... <database>DEFAULT
      VALUES</database></title>

      <!--Available in ESQL?-->

      <para>The <database>DEFAULT VALUES</database> clause allows insertion of
      a record without providing any values at all, neither directly nor from
      a <database>SELECT</database> statement. This is only possible if every
      <database>NOT NULL</database> or <database>CHECK</database>ed column in
      the table either has a valid default declared or gets such a value from
      a <database>BEFORE INSERT</database> trigger. Furthermore, triggers
      providing required field values must not depend on the presence of input
      values.</para>

      <!--About CHECK constraints: they let NULL pass, so perhaps the statement above is incorrect here.-->

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>insert into journal default values
  returning entry_id</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-insert-returning">
      <title>The <database>RETURNING</database> clause</title>

      <para>An <database>INSERT</database> statement adding <emphasis>at most
      one row</emphasis> may optionally include a
      <database>RETURNING</database> clause in order to return values from the
      inserted row. The clause, if present, need not contain all of the insert
      columns and may also contain other columns or expressions. The returned
      values reflect any changes that may have been made in
      <database>BEFORE</database> triggers, but not those in
      <database>AFTER</database> triggers.</para>

      <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>insert into Scholars (firstname, lastname, address, phone, email)
  values ('Henry', 'Higgins', '27A Wimpole Street', '3231212', null)
  returning lastname, fullname, id</programlisting>

            <programlisting>insert into Dumbbells (firstname, lastname, iq)
  select fname, lname, iq from Friends order by iq rows 1
  returning id, firstname, iq into :id, :fname, :iq;</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para><database>RETURNING</database> is only supported for
              <database>VALUES</database> inserts and singleton
              <database>SELECT</database> inserts.</para>

              <!--Test if it also works with DEFAULT VALUES-->
            </listitem>

            <listitem>
              <para>In DSQL, a statement with a <database>RETURNING</database>
              clause <emphasis role="">always</emphasis> returns exactly one
              row. If no record was actually inserted, the fields in this row
              are all <constant>NULL</constant>. This behaviour may change in
              a later version of Firebird. In PSQL, if no row was inserted,
              nothing is returned, and the target variables keep their
              existing values.</para>
            </listitem>

            <listitem>
              <para>The <database>RETURNING</database> clause is not available
              in ESQL.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langref25-dml-insert-blobs">
      <title>Inserting into <database>BLOB</database> columns</title>

      <para>Inserting into <database>BLOB</database> columns is only possible
      under the following circumstances:</para>

      <orderedlist>
        <listitem>
          <para>The client application has made special provisions for such
          inserts, using the Firebird API. In this case, the modus operandi is
          application-specific and outside the scope of this manual.</para>
        </listitem>

        <listitem>
          <para>The value inserted is a text string of at most 32767 bytes.
          Please notice: if the value is not a string literal, beware of
          concatenations, as these may exceed the maximum length.</para>
        </listitem>

        <listitem>
          <para>You are using the <quote><database>INSERT</database> ...
          <database>SELECT</database></quote> form and one or more columns in
          the result set are <database>BLOB</database>s.</para>
        </listitem>

        <listitem>
          <para>You use the <link
          linkend="langref25-dml-insert_cursor"><database>INSERT
          CURSOR</database></link> statement (ESQL only).</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section id="langref25-dml-insert_cursor">
    <title><database>INSERT CURSOR</database></title>

    <formalpara>
      <title>Available in</title>

      <para>ESQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>In Embedded SQL only, you can insert data, in segment-sized
      chunks, into a <database>BLOB</database> through a special
      <database>BLOB</database> cursor. As you can only write one segment at a
      time, this is usually done in a (host language) loop.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>INSERT CURSOR <replaceable>blobcursor</replaceable> VALUES (:<replaceable>buf</replaceable> [INDICATOR] :size)

<replaceable>blobcursor</replaceable>  ::=  an opened <database>BLOB</database> insert cursor
<replaceable>buf</replaceable>         ::=  host variable containing the data segment
<replaceable>size</replaceable>        ::=  data size in bytes; must be less than or equal to the segment length</programlisting>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Example</title>

      <para><blockquote>
          <programlisting>exec sql
  insert cursor cur_jpeg values (:imgbuf indicator :seglen);</programlisting>
        </blockquote></para>
    </formalpara>

    <para>Please notice that, unlike <link
    linkend="langref25-dml-insert"><database>INSERT</database></link>,
    <database>INSERT CURSOR</database> does not write anything to the table
    itself. The segments are written to a <database>BLOB</database> structure
    which, at that time, <quote>floats</quote> freely in the database,
    unconnected to any other object.</para>

    <para>After inserting all the segments in this manner, you must close the
    <database>BLOB</database> cursor and perform a regular
    <database>INSERT</database> statement to insert the
    <database>BLOB</database> ID (and possibly other fields) into the
    table.</para>

    <para>Updating <database>BLOB</database> fields is done in the same way,
    except that you finalize the entire operation by issuing a regular
    <database>UPDATE</database> statement instead of an
    <database>INSERT</database> statement.</para>

    <para>A complete discussion of ESQL statements is outside the scope of
    this document. For more information about ESQL, please consult the
    <citetitle>InterBase 6 Embedded SQL Guide</citetitle> (google for
    <filename>60EmbedSQL.zip</filename>).</para>
  </section>

  <section id="langref25-dml-merge">
    <title><database>MERGE</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, PSQL<!--ESQL... guess not--></para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Merges data into a table or updatable view. The source may a
      table, view or <quote>anything you can <database>SELECT</database>
      from</quote> in general. Each source record will be used to update one
      or more target records, insert a new record in the target table, or
      neither. The action taken depends on the provided condition and the
      <database>WHEN</database> clause(s). The condition will typically
      contain a comparison of fields in the source and target
      relations.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>MERGE INTO <replaceable>target</replaceable> [[AS] <replaceable>target-alias</replaceable>]
   USING <replaceable>source</replaceable> [[AS] <replaceable>source-alias</replaceable>]
   ON <replaceable>condition</replaceable>
   WHEN MATCHED THEN UPDATE SET <replaceable>colname</replaceable> = <replaceable>value</replaceable> [, <replaceable>colname</replaceable> = <replaceable>value</replaceable> ...]
   WHEN NOT MATCHED THEN INSERT [(<replaceable>&lt;columns&gt;</replaceable>)] VALUES (<replaceable>&lt;values&gt;</replaceable>)

<replaceable>target</replaceable>     ::=  a table or updatable view
<replaceable>source</replaceable>     ::=  a table, GTT, view, selectable SP, derived table or CTE
<replaceable>&lt;columns&gt;</replaceable>  ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;values&gt;</replaceable>   ::=  <replaceable>value</replaceable>   [, <replaceable>value</replaceable>   ...]

<emphasis role="bold">Note:</emphasis> It is allowed to provide only one of the WHEN clauses</programlisting>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Examples</title>

      <para><blockquote>
          <programlisting>merge into books b
  using purchases p
  on p.title = b.title and p.type = 'bk'
  when matched then
    update set b.desc = b.desc || '; ' || p.desc
  when not matched then
    insert (title, desc, bought) values (p.title, p.desc, p.bought)</programlisting>

          <programlisting>merge into customers c
  using (select * from customers_delta where id &gt; 10) cd
  on (c.id = cd.id)
  when matched then update set name = cd.name
  when not matched then insert (id, name) values (cd.id, cd.name)</programlisting>

          <!--Second example provided by Adriano!-->
        </blockquote></para>
    </formalpara>

    <note>
      <para><database>WHEN NOT MATCHED</database> should be seen from the
      point of view of the <emphasis>source</emphasis> (the relation in the
      <database>USING</database> clause). That is: if a source record doesn't
      have a match in the target table, the <database>INSERT</database> clause
      is executed. Conversely, records in the target table without a matching
      source record don't cause anything to happen.</para>
    </note>

    <warning>
      <para>If the <database>WHEN MATCHED</database> clause is present and
      multiple source records match the same record(s) in the target table,
      the <database>UPDATE</database> clause is executed for all the matching
      source records, each update overwriting the previous one. This is
      non-standard behaviour: SQL-2003 specifies that an exception must be
      raised in such cases.<!--http://tracker.firebirdsql.org/browse/CORE-2274--></para>
    </warning>
  </section>

  <section id="langref25-dml-select">
    <title><database>SELECT</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <para>The <database>SELECT</database> statement retrieves data from the
    database and hands them to the application or the enclosing SQL statement.
    Data are returned in zero or more <firstterm>rows</firstterm>, each
    containing one or more <firstterm>columns</firstterm> or
    <firstterm>fields</firstterm>. The total of rows returned is the
    <firstterm>result set</firstterm> of the statement.</para>

    <formalpara>
      <title>Global syntax</title>

      <para><blockquote>
          <programlisting>SELECT
   [TRANSACTION <replaceable>name</replaceable>]
   [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
   [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>
   [INTO <replaceable>&lt;host-varlist&gt;</replaceable>]
   FROM <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>]
   [<replaceable>&lt;joins&gt;</replaceable>]
   [WHERE <replaceable>&lt;condition&gt;</replaceable>]
   [GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>
     [HAVING <replaceable>&lt;aggregate-condition&gt;</replaceable>]]
   [PLAN <replaceable>&lt;plan-expr&gt;</replaceable>]
   [UNION [DISTINCT | ALL] <replaceable>&lt;other-select&gt;</replaceable>]
   [ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>]
   [ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]
   [FOR UPDATE [OF <replaceable>&lt;columns&gt;</replaceable>]]
   [WITH LOCK]
   [INTO <replaceable>&lt;PSQL-varlist&gt;</replaceable>]</programlisting>
        </blockquote></para>
    </formalpara>

    <para>The only mandatory parts of the <database>SELECT</database>
    statement are:</para>

    <itemizedlist>
      <listitem>
        <para>The SELECT keyword, followed by a columns list. This part
        specifies <emphasis>what</emphasis> you want to retrieve.</para>
      </listitem>

      <listitem>
        <para>The <database>FROM</database> keyword, followed by a selectable
        object. This tells the engine <emphasis>where</emphasis> you want to
        get it <emphasis>from</emphasis>.</para>
      </listitem>
    </itemizedlist>

    <para>In its most basic form, <database>SELECT</database> retrieves a
    number of columns from a single table or view, like this:</para>

    <blockquote>
      <programlisting>select id, name, address
  from contacts</programlisting>
    </blockquote>

    <para>Or, to retrieve all the columns:</para>

    <blockquote>
      <programlisting>select * from sales</programlisting>
    </blockquote>

    <para>In practice, the rows retrieved are often limited by a
    <database>WHERE</database> clause. The result set may be sorted by an
    <database>ORDER BY</database> clause, and <database>FIRST</database>,
    <database>SKIP</database> or <database>ROWS</database> may further limit
    the number of output rows. The column list may contain all kinds of
    expressions instead of just column names, and the source need not be a
    table or view: it may also be a derived table, a common table expression
    (CTE) or a selectable stored procedure (SP). Multiple sources may be
    combined in a <database>JOIN</database>, and multiple result sets may be
    combined in a <database>UNION</database>.</para>

    <para>The following sections discuss the available
    <database>SELECT</database> subclauses and their usage in detail.</para>

    <section id="langref25-dml-select-transaction">
      <title>The <database>TRANSACTION</database> directive</title>

      <formalpara>
        <title>Available in</title>

        <para>ESQL</para>
      </formalpara>

      <para>This ESQL-only directive tells the engine to execute the statement
      under the specified transaction, which must have been previously
      declared and opened, e.g.:</para>

      <blockquote>
        <programlisting>select transaction tr_getsales
  partno, desc, price, amount
  from v_sales
  where custno = 101</programlisting>
      </blockquote>
    </section>

    <section id="langref25-dml-select-first-skip-rows">
      <title><database>FIRST</database>, <database>SKIP</database> and
      <database>ROWS</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
   FROM ...
   ...

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  <replaceable>integer-literal</replaceable> | <replaceable>query-parameter</replaceable> | (<replaceable>integer-expression</replaceable>)</programlisting>

            <para>or</para>

            <programlisting>SELECT
   ...
   FROM ...
   ...
   ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]

<replaceable>m</replaceable>, <replaceable>n</replaceable>  ::=  <replaceable>integer-expression</replaceable></programlisting>

            <para><emphasis>Please notice:</emphasis>
            <database>FIRST</database> and <database>SKIP</database> are
            Firebird-specific, non-SQL-compliant keywords. You are adviced to
            use the <database>ROWS</database> syntax wherever possible.</para>
          </blockquote></para>
      </formalpara>

      <para><database>FIRST</database> limits the output of a query to the
      first so-many rows. <database>SKIP</database> will suppress the given
      number of rows before starting to return output.</para>

      <para><database>FIRST</database> and <database>SKIP</database> are both
      optional. When used together as in <quote><database>FIRST</database>
      <replaceable>m</replaceable> <database>SKIP</database>
      <replaceable>n</replaceable></quote>, the <replaceable>n</replaceable>
      topmost rows of the output set are discarded and the first
      <replaceable>m</replaceable> rows of the remainder are returned.</para>

      <para><database>SKIP</database> 0 is allowed, but of course rather
      pointless. <database>FIRST</database> 0 is also allowed and returns an
      empty set. Negative <database>SKIP</database> and/or
      <database>FIRST</database> values result in an error.</para>

      <para>If a <database>SKIP</database> lands past the end of the dataset,
      an empty set is returned. If the number of rows in the dataset (or the
      remainder after a <database>SKIP</database>) is less than the value
      given after <database>FIRST</database>, that smaller number of rows is
      returned. These are valid results, not error conditions.</para>

      <para>Any argument to <database>FIRST</database> and
      <database>SKIP</database> that is not an integer literal or an SQL
      parameter must be enclosed in parentheses. This implies that a subselect
      must be enclosed in <emphasis>two</emphasis> pairs of
      parentheses.</para>

      <bridgehead>Examples</bridgehead>

      <para>The following query will return the first 10 names from the People
      table:</para>

      <blockquote>
        <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>The following query will return everything
      <emphasis>but</emphasis> the first 10 names:</para>

      <blockquote>
        <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>And this one returns the last 10 rows. Notice the double
      parentheses:</para>

      <blockquote>
        <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>This query returns rows 81–100 of the People table:</para>

      <blockquote>
        <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>As said, <database>FIRST</database> and <database>SKIP</database>
      are not standard SQL. In new code, it's better to use the
      standards-compliant <database>ROWS</database> keyword.</para>

      <para>Contrary to <database>FIRST</database> and
      <database>SKIP</database>, <database>ROWS</database> accepts any kind of
      integer expression as argument without parentheses. (Of course,
      parentheses may be necessary <emphasis>within</emphasis> the expression,
      and a subselect still needs to be parenthesized.)</para>

      <para>With a single argument <replaceable>m</replaceable>,
      <database>ROWS</database> returns the first <replaceable>m</replaceable>
      rows of the dataset.</para>

      <para>Points to note:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, an empty set is
          returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, rows <replaceable>m</replaceable> to
      <replaceable>n</replaceable> of the dataset are returned, inclusively.
      Row numbers are 1-based.</para>

      <para>Points to note when using two arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, an empty set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, an empty set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->

      <para>The SQL-compliant <database>ROWS</database> syntax obviates the
      need for <database>FIRST</database> and <database>SKIP</database>,
      except in one case: a <database>SKIP</database> without
      <database>FIRST</database>, which returns the entire remainder of the
      set after skipping a given number of rows. (Well, this is not entirely
      true. You can supply a second argument that you know is bigger than the
      number of rows in the set, or request <database>COUNT</database>(*) with
      a subselect. But <database>SKIP</database> is simpler and clearer
      here.)</para>

      <para>You cannot use <database>ROWS</database> together with
      <database>FIRST</database> and/or <database>SKIP</database> in a single
      <database>SELECT</database> statement, but you can use one form in the
      top-level statement and the other in subselects, or use the two syntaxes
      in different subselects.</para>

      <para>When used with a <database>UNION</database>, the
      <database>ROWS</database> subclause applies to the UNION as a whole and
      must be placed after the last <database>SELECT</database>. If you want
      to limit the output of one or more individual
      <database>SELECT</database>s within the <database>UNION</database>, you
      have two options: either use
      <database>FIRST</database>/<database>SKIP</database> on those
      <database>SELECT</database> statements (probably of limited use, as you
      can't use <database>ORDER BY</database> on individual selects within a
      union), or convert them to <link
      linkend="langref25-dml-derived-tables">derived tables</link> with
      <database>ROWS</database> clauses.</para>

      <para>Below are the previous examples rewritten using
      <database>ROWS</database>. Notice that <database>ROWS</database> is
      placed at or near the end of the statement, whereas
      <database>FIRST</database> and <database>SKIP</database> come even
      before the columns list.</para>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows 1 to 10</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows 11 to (select count(*) from People)</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows (select count(*) - 9 from People)
    to (select count(*) from People)</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows 81 to 100</programlisting>
      </blockquote>

      <para>Both <database>FIRST</database>/<database>SKIP</database> and
      <database>ROWS</database> can be used without an <database>ORDER
      BY</database> clause, but this rarely makes sense, unless you want to
      just <quote>get an idea</quote> about a table without being interested
      in the actual data. In that case, a statement like <quote>select * from
      UnknownTable rows 20</quote> may give you a quick insight without
      risking lots of network traffic and thousands of data rows flying across
      your screen.</para>
    </section>

    <section id="langref25-dml-select-column-list">
      <title>The column list</title>

      <para>The column list contains one or more comma-separated value
      expressions. Each expression provides a value for one output column,
      except <literal>*</literal> (<quote>star</quote>), which stands for all
      the columns in a relation (i.e. a table, view or selectable stored
      procedure).</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   [...]
   [DISTINCT | ALL] <replaceable>&lt;output-column&gt;</replaceable> [, <replaceable>&lt;output-column&gt;</replaceable> ...]
   [...]
   FROM ...

<replaceable>&lt;output-column&gt;</replaceable>     ::=  [<replaceable>qualifier</replaceable>.]*
                           | <replaceable>&lt;value-expression&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;value-expression&gt;</replaceable>  ::=  [<replaceable>qualifier</replaceable>.]<replaceable>table-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>view-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>selectable-SP-outparm</replaceable>
                           | <replaceable>constant</replaceable>
                           | <replaceable>context-variable</replaceable> 
                           | <replaceable>function-call</replaceable>
                           | <replaceable>single-value-subselect</replaceable>
                           | <emphasis><database>CASE</database>-construct</emphasis>
                           | <quote>any other expression returning a single
                                value of a Firebird data type or <database>NULL</database></quote>

<replaceable>qualifier</replaceable>           ::=  a relation name or alias
<replaceable>collation</replaceable>           ::=  a valid collation name (only for character type columns)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>It is always valid to qualify a column name (or
      <quote><literal>*</literal></quote>) with the name or alias of the
      table, view or selectable SP to which it belongs, followed by a dot.
      Qualifying becomes mandatory if the column name occurs in more than one
      relation taking part in a join. Qualifying
      <quote><literal>*</literal></quote> is mandatory if it isn't the only
      item in the column list.</para>

      <para>Please notice that aliases obfuscate the original relation name:
      once a table, view or SP has been aliased, you can only use the alias as
      a qualifier; the relation name itself has become unavailable.</para>

      <para>The column list may optionally be preceded by one of the keywords
      <database>DISTINCT</database> or <database>ALL</database>.
      <database>DISTINCT</database> filters out any duplicate rows. That is,
      if two or more rows have the same values in every corresponding column,
      only one of them is included in the result set. <database>ALL</database>
      shows all the rows including duplicates. <database>ALL</database> is the
      default and therefore rarely used; it is supported for reasons of SQL
      compliance.</para>

      <para>A <database>COLLATE</database> clause will not change the
      appearance of the column as such. However, if the specified collation
      changes the case or accent sensitivity of the column, it may
      influence:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>The ordering, if an <database>ORDER BY</database> clause is
          also present and the column is involved in it.</para>
        </listitem>

        <listitem>
          <para>Grouping, if the column is part of a <database>GROUP
          BY</database> clause.</para>
        </listitem>

        <listitem>
          <para>The rows retrieved (and hence the total number of rows in the
          result set), if <database>DISTINCT</database> is used.</para>
        </listitem>
      </itemizedlist>

      <bridgehead>Examples of <database>SELECT</database> queries with
      different types of column lists</bridgehead>

      <para>A simple <database>SELECT</database> using only column
      names:</para>

      <blockquote>
        <programlisting>select cust_id, cust_name, phone
  from customers
  where city = 'London'</programlisting>
      </blockquote>

      <para>A query featuring a concatenation expression and a function call
      in the columns list:</para>

      <blockquote>
        <programlisting>select 'Mr./Mrs. ' || lastname, street, zip, upper(city)
  from contacts
  where date_last_purchase(id) = current_date</programlisting>
      </blockquote>

      <para>A query with two subselects:</para>

      <blockquote>
        <programlisting>select p.fullname,
       (select name from classes c where c.id = p.class) as class,
       (select name from mentors m where m.id = p.mentor) as mentor
from pupils p</programlisting>
      </blockquote>

      <para>The following query accomplishes the same as the previous one
      using joins instead of subselects:</para>

      <blockquote>
        <programlisting>select p.fullname,
       c.name as class,
       m.name as mentor
from pupils p
  join classes c on c.id = p.class
  join mentors m on m.id = p.mentor</programlisting>
      </blockquote>

      <para>This query uses a <database>CASE</database> construct to determine
      the correct title, e.g. when sending mail to a person:</para>

      <blockquote>
        <programlisting>select <emphasis role="bold">case upper(sex)
         when 'F' then 'Mrs.'
         when 'M' then 'Mr.'
         else ''
       end</emphasis> as title,
       lastname,
       address
from employees</programlisting>
      </blockquote>

      <para>Querying a selectable stored procedure:</para>

      <blockquote>
        <programlisting>select * from interesting_transactions(2010, 3, 'S')
  order by amount</programlisting>
      </blockquote>

      <para>Selecting from columns of a derived table. A derived table is a
      parenthesized <database>SELECT</database> statement whose result set is
      used in an enclosing query as if it were a regular table or view. The
      derived table is shown in bold here:</para>

      <!--Kan dit voorbeeld niet beter bij het bespreken van derived tables in de FROM-claus?-->

      <blockquote>
        <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>
      </blockquote>

      <para>Asking the time through a context variable
      (<database>CURRENT_TIME</database>):</para>

      <blockquote>
        <programlisting>select current_time from rdb$database</programlisting>
      </blockquote>

      <para>For those not familiar with <database>RDB$DATABASE</database>:
      this is a system table that is present in all Firebird databases and is
      guaranteed to contain exactly one row. Although it wasn't created for
      this purpose, it has become standard practice among Firebird programmers
      to select from this table if you want to select <quote>from
      nothing</quote>, i.e., if you need data that are not bound to a any
      table or view, but can be derived from the expressions in the output
      columns alone. Another example is:</para>

      <blockquote>
        <programlisting>select power(12, 2) as twelve_squared, power(12, 3) as twelve_cubed
  from rdb$database</programlisting>
      </blockquote>

      <para>Finally, an example where you select some meaningful information
      from <database>RDB$DATABASE</database> itself:</para>

      <blockquote>
        <programlisting>select rdb$character_set_name from rdb$database</programlisting>
      </blockquote>

      <para>As you may have guessed, this will give you the default character
      set of the database.</para>
    </section>

    <section id="langref25-dml-select-into">
      <title>Selecting <database>INTO</database> variables<!--Better move this to the end?--></title>

      <formalpara>
        <title>Available in</title>

        <para>ESQL, PSQL</para>
      </formalpara>

      <para>In PSQL code or embedded SQL, the results of a
      <database>SELECT</database> statement may be loaded – on a row-by-row
      basis – into local variables (PSQL) or host languages variables (ESQL).
      In fact, this is often the only way to do anything with the returned
      values at all. The number, order and types of the variables must match
      the columns in the output row.</para>

      <para>A <quote>plain</quote> <database>SELECT</database> statement can
      only be used in ESQL or PSQL if it returns at most one row – in other
      words, if it is a <emphasis>singleton</emphasis> select. For multirow
      selects, PSQL provides the <database>FOR SELECT</database> loop, which
      is discussed in the PSQL chapter. In addition, both PSQL and ESQL
      support the <database>DECLARE CURSOR</database> statement, which binds a
      named cursor to a <database>SELECT</database> statement. The cursor can
      then be used to walk the result set.</para>

      <formalpara>
        <title>Syntax</title>

        <para>In embedded SQL, the <database>INTO</database> clause is placed
        between the column list and the <database>FROM</database>
        keyword:<blockquote>
            <programlisting>SELECT
   [...]
   <replaceable>&lt;column-list&gt;</replaceable>
   [INTO <replaceable>&lt;variable-list&gt;</replaceable>]
   FROM ...
   [...]

<replaceable>&lt;variable-list&gt;</replaceable>  ::=  :<replaceable>hostvar</replaceable> [, :<replaceable>hostvar</replaceable> ...]</programlisting>
          </blockquote>In PSQL, the <database>INTO</database> clause must
        appear at the very end of the statement:<blockquote>
            <programlisting>SELECT
   [...]
   <replaceable>&lt;column-list&gt;</replaceable>
   FROM ...
   [...]
   [INTO <replaceable>&lt;variable-list&gt;</replaceable>]

<replaceable>&lt;variable-list&gt;</replaceable>  ::=  [:]<replaceable>psqlvar</replaceable> [, [:]<replaceable>psqlvar</replaceable> ...]</programlisting>
          </blockquote>Notice that in PSQL, the colons before the variable
        names are optional.</para>
      </formalpara>

      <bridgehead>Examples</bridgehead>

      <para>In ESQL, with <varname>min_amt</varname>,
      <varname>avg_amt</varname> and <varname>max_amt</varname> host language
      (e.g. C) variables:</para>

      <blockquote>
        <programlisting>select min(amount), avg(cast(amount as float)), max(amount)
  into :min_amt, :avg_amt, :max_amt
  from orders
  where artno = 372218;</programlisting>
      </blockquote>

      <para>In PSQL, with <varname>min_amt</varname>,
      <varname>avg_amt</varname> and <varname>max_amt</varname> previously
      defined PSQL variables or output parameters:</para>

      <blockquote>
        <programlisting>select min(amount), avg(cast(amount as float)), max(amount)
  from orders
  where artno = 372218
  into min_amt, avg_amt, max_amt;</programlisting>
      </blockquote>

      <para>(The <database>CAST</database> serves to make the average a broken
      number. Otherwise – since <systemitem>amount</systemitem> is presumably
      an integer field – it would be truncated to the nearest lower
      integer.)</para>

      <para>In a PSQL trigger:</para>

      <blockquote>
        <programlisting>select list(name, ', ')
  from persons p
  where p.id in (new.father, new.mother)
  into new.parentnames;</programlisting>
      </blockquote>
    </section>

    <section id="langref25-dml-select-from">
      <title>The <database>FROM</database> clause</title>

      <para>The <database>FROM</database> clause specifies the source(s) from
      which the data are to be retrieved. In its simplest form, this is just a
      single table or view. But the source can also be a selectable stored
      procedure, a derived table or a common table expression. Multiple
      sources can be combined using various types of joins.</para>

      <para>This section concentrates on single-source selects. Joins are
      discussed in the next section.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>&lt;derived-table&gt;</replaceable>
                          | <replaceable>&lt;common-table-expression&gt;</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;derived-table&gt;</replaceable>   ::=  (<replaceable>select-statement</replaceable>) [[AS] <replaceable>alias</replaceable>]
                         [(<replaceable>&lt;column-aliases&gt;</replaceable>)]

<replaceable>&lt;common-table-expression&gt;</replaceable>
                  ::=  WITH [RECURSIVE] <replaceable>&lt;cte-def&gt;</replaceable> [, <replaceable>&lt;cte-def&gt;</replaceable> ...]
                       <replaceable>select-statement</replaceable>

<replaceable>&lt;cte-def&gt;</replaceable>         ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-aliases&gt;</replaceable>)] AS (<replaceable>select-statement</replaceable>)

<replaceable>&lt;column-aliases&gt;</replaceable>  ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langref25-dml-select-from-table-view">
        <title>Selecting from a table or view</title>

        <para>When selecting from a single table or view, the
        <database>FROM</database> clause need not contain anything more than
        the name. An alias may be useful or even necessary if there are
        subselects that refer to the main select statement (as they often do –
        subqueries like this are called <firstterm>correlated
        subqueries</firstterm>).</para>

        <bridgehead>Examples</bridgehead>

        <blockquote>
          <programlisting>select id, name, sex, age from actors
  where state = 'Ohio'</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from birds
  where type = 'flightless'
  order by family, genus, species</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select firstname,
       middlename,
       lastname,
       date_of_birth,
       (select name from schools s where p.school = s.id) schoolname
from pupils p
where year_started = '2012'
order by schoolname, date_of_birth</programlisting>
        </blockquote>
      </section>

      <section id="langref25-dml-select-sp">
        <title>Selecting from a stored procedure</title>

        <para>A <firstterm>selectable stored procedure</firstterm> is a
        procedure that:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>contains at least one output parameter, and</para>
          </listitem>

          <listitem>
            <para>utilizes the <database>SUSPEND</database> keyword so the
            caller can fetch the output rows one by one, just as when
            selecting from a table or view.</para>
          </listitem>
        </itemizedlist>

        <para>The output parameters of a selectable stored procedure
        correspond to the columns of a regular table.</para>

        <para>Selecting from a stored procedure without input parameters is
        just like selecting from a table or view:</para>

        <blockquote>
          <programlisting>select * from suspicious_transactions
  where assignee = 'John'</programlisting>
        </blockquote>

        <para>Any required input parameters must be specified after the
        procedure name, enclosed in parentheses:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
  where alt &gt;= 20
  order by az, alt</programlisting>
        </blockquote>

        <para>Values for optional parameters (that is, parameters for which
        default values have been defined) may be omitted or provided. However,
        if you provide them only partly, the parameters you omit must all be
        at the tail end.</para>

        <para>Supposing that the procedure
        <systemitem>visible_stars</systemitem> from the previous example has
        two optional parameters: <parameter>min_magn</parameter>
        (numeric(3,1)) and <parameter>spectral_class</parameter>
        (varchar(12)), the following queries are all valid:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0)
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0, 'G')</programlisting>
        </blockquote>

        <para>But this one isn't, because there's a <quote>hole</quote> in the
        parameter list:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30', 'G')</programlisting>
        </blockquote>

        <para>An alias for a selectable stored procedure is specified
        <emphasis>after</emphasis> the parameter list:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = gw.number)
from get_winners('#34517', 'AMS') gw</programlisting>
        </blockquote>

        <para>If you qualify a column (output parameter) with the full
        procedure name, don't include the parameter list:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = get_winners.number)
from get_winners('#34517', 'AMS')</programlisting>
        </blockquote>
      </section>

      <section id="langref25-dml-select-from-dt">
        <title>Selecting from a derived table</title>

        <para>A derived table is a valid <database>SELECT</database> statement
        enclosed in parentheses, optionally followed by a table alias and/or
        column aliases. The result set of the statement acts as a virtual
        table which the enclosing statement can query.</para>

        <para>Derived tables are discussed in detail in the section <link
        linkend="langref25-dml-derived-tables"><citetitle>Derived tables
        (<quote><database>SELECT FROM
        SELECT</database></quote>)</citetitle></link>. Here, we only give an
        example.</para>

        <para>Suppose we have a table <database>COEFFS</database> which
        contains the coefficients of a number of quadratic equations we have
        to solve. It has been defined like this:</para>

        <blockquote>
          <programlisting>create table coeffs (
  a double precision not null,
  b double precision not null,
  c double precision not null,
  constraint chk_a_not_zero check (a &lt;&gt; 0)
)</programlisting>
        </blockquote>

        <para>Depending on the values of <replaceable>a</replaceable>,
        <replaceable>b</replaceable> and <replaceable>c</replaceable>, each
        equation may have zero, one or two solutions in ℝ. It is possible to
        find these solutions with a single-level query on table
        <database>COEFFS</database>, but the code will look rather messy and
        several values (like the discriminant) will have to be calculated
        multiple times per row. A derived table can help keep things clean
        here:</para>

        <blockquote>
          <programlisting>select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select b, b*b - 4*a*c, 2*a from coeffs) (b, D, denom)</programlisting>
        </blockquote>

        <para>If we want to show the coefficients next to the solutions (which
        may not be a bad idea), we can alter the query like this:</para>

        <blockquote>
          <programlisting>select
  a, b, c,
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select a, b, c, b*b - 4*a*c as D, 2*a as denom
     from coeffs)</programlisting>
        </blockquote>

        <para>Notice that whereas the first query used a column aliases list
        for the derived table, the second adds aliases internally where
        needed. Both methods work, as long as every column is guaranteed to
        have a name.</para>
      </section>

      <section id="langref25-dml-select-from-cte">
        <title>Selecting from a CTE</title>

        <para>A common table expression or <database>CTE</database> is a more
        complex, but also more powerful type of derived table. A preamble,
        starting with the keyword <database>WITH</database>, defines one or
        more named <database>CTE</database>'s, each optionally with a column
        aliases list. The main query, which follows the preamble, can then
        access these <database>CTE</database>'s as if they were regular tables
        or views. Once the main query has run to completion, the
        <database>CTE</database>'s go out of scope.</para>

        <para>For a full discussion of <database>CTE</database>'s, please
        refer to the section <link
        linkend="langref25-dml-select-cte"><citetitle>Common Table Expressions
        (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</citetitle></link>.</para>

        <para>The following is a rewrite of our derived table example as a
        <database>CTE</database>:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
)
select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
from vars</programlisting>
        </blockquote>

        <para>Except for the fact that the calculations that have to be made
        first are now at the beginning, this isn't a great improvement over
        the derived table version. But we can now also eliminate the double
        calculation of sqrt(D) for every row:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
),
vars2 (b, D, denom, sqrtD) as (
  select b, D, denom, iif (D &gt;= 0, sqrt(D), null) from vars
)
select
  iif (D &gt;= 0, (-b - sqrtD) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrtD) / denom, null) sol_2
from vars2</programlisting>
        </blockquote>

        <para>The code is a little more complicated now, but it might execute
        more efficiently (depending on what takes more time: executing the
        <database>SQRT</database> function or passing the values of
        <replaceable>b</replaceable>, <replaceable>D</replaceable> and
        <replaceable>denom</replaceable> through an extra
        <database>CTE</database>). Incidentally, we could have done the same
        with derived tables, but that would involve nesting.</para>
      </section>
    </section>

    <section id="langref25-dml-select-joins">
      <title>Joins</title>

      <para>Joins combine data from two sources into a single set. This is
      done on a row-by-row basis and usually involves the checking of a
      <firstterm>join condition</firstterm> in order to determine which rows
      should be merged and appear in the resulting dataset. There are several
      types (<database>INNER</database>, <database>OUTER</database>) and
      classes (qualified, natural, etc.) of joins, each with their own syntax
      and rules.</para>

      <para>Since joins can be chained, the datasets involved in a join may
      themselves be joined sets.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>derived-table</replaceable>
                          | <replaceable>common-table-expression</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;joins&gt;      </replaceable>     ::=  <replaceable>&lt;join&gt;</replaceable> [<replaceable>&lt;join&gt;</replaceable> ...]

<replaceable>&lt;join&gt;</replaceable>            ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>
                         | NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>
                         | {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langref25-dml-select-joins-types">
        <title>Inner vs. outer joins</title>

        <para>A join always combines data rows from two sets (usually referred
        to as the left set and the right set). By default, only rows that meet
        the join condition (i.e., that match at least one row in the other set
        when the join condition is applied) make it into the result set. This
        default type of join is called an <firstterm>inner join</firstterm>.
        Suppose we have the following two tables:</para>

        <blockquote>
          <para>Table A:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Table B:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>If we join these tables like this:</para>

        <blockquote>
          <programlisting>select *
  from A
  join B on A.id = B.code</programlisting>
        </blockquote>

        <para>then the result set will be:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>The first row of A has been joined with the second row of B
        because together they met the condition <quote>A.id = B.code</quote>.
        The other rows from the source tables have no match in the opposite
        set and are therefore not included in the join. Remember, this is an
        <database>INNER</database> join. We can make that fact explicit by
        writing:</para>

        <blockquote>
          <programlisting>select *
  from A
  inner join B on A.id = B.code</programlisting>
        </blockquote>

        <para>However, since <database>INNER</database> is the default, this
        is rarely done.</para>

        <para>It is perfectly possible that a row in the left set matches
        several rows from the right set or vice versa. In that case, all those
        combinations are included, and we can get results like:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>-1.0</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Still don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>I give up</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>Sometimes we want (or need) <emphasis>all</emphasis> the rows of
        one or both of the sources to appear in the joined set, regardless of
        whether they match a record in the other source. This is where outer
        joins come in. A <database>LEFT</database> outer join includes all the
        records from the left set, but only matching records from the right
        set. In a <database>RIGHT</database> outer join it's the other way
        around. <database>FULL</database> outer joins include all the records
        from both sets. In all outer joins, the <quote>holes</quote> (the
        places where an included source record doesn't have a match in the
        other set) are filled up with <database>NULL</database>s.</para>

        <para>In order to make an outer join, you must specify
        <database>LEFT</database>, <database>RIGHT</database> or
        <database>FULL</database>, optionally followed by the keyword
        <database>OUTER</database>.</para>

        <para>Below are the results of the various outer joins when applied to
        our original tables <database>A</database> and
        <database>B</database>:</para>

        <blockquote>
          <programlisting>select *
  from A
  left [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  right [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  full [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>
      </section>

      <section id="langref25-dml-select-joins-qualified">
        <title>Qualified joins</title>

        <para>Qualified joins specify conditions for the combining of rows.
        This happens either explicitly in an <database>ON</database> clause or
        implicitly in a <database>USING</database> clause.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;qualified-join&gt;</replaceable>  ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
            </blockquote></para>
        </formalpara>

        <section>
          <title>Explicit-condition joins</title>

          <para>Most qualified joins have an <database>ON</database> clause,
          with an explicit condition that can be any valid boolean expression
          but usually involves some comparison between the two sources
          involved.</para>

          <para>Quite often, the condition is an equality test (or a number of
          <database>AND</database>ed equality tests) using the
          <quote><literal>=</literal></quote> operator. Joins like these are
          called <firstterm>equi-joins</firstterm>. (The examples in the
          section on inner and outer joins were al equi-joins.)</para>

          <para>Examples of joins with an explicit condition:</para>

          <blockquote>
            <programlisting>/* Select all Detroit customers who made a purchase
   in 2013, along with the purchase details: */
select * from customers c
  join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>
          </blockquote>

          <blockquote>
            <programlisting>/* Same as above, but include non-buying customers: */
select * from customers c
  left join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>

            <programlisting>/* For each man, select the women who are taller than he.
   Men for whom no such woman exists are not included. */
select m.fullname as man, f.fullname as woman
  from males m
  join females f on f.height &gt; m.height</programlisting>

            <programlisting>/* Select all pupils with their class and mentor.
   Pupils without a mentor are also included.
   Pupils without a class are not included. */
select p.firstname, p.middlename, p.lastname,
       c.name, m.name
  from pupils p
  join classes c on c.id = p.class
  left join mentors m on m.id = p.mentor</programlisting>
          </blockquote>
        </section>

        <section id="langref25-dml-select-joins-named-columns">
          <title>Named columns joins</title>

          <para>Equi-joins often compare columns that have the same name in
          both tables. If this is the case, we can also use the second type of
          qualified join: the <firstterm>named columns join</firstterm>. Named
          columns joins have a <database>USING</database> clause which states
          just the column names. So instead of this:</para>

          <blockquote>
            <programlisting>select * from flotsam f
  join jetsam j
  on f.sea = j.sea
  and f.ship = j.ship</programlisting>
          </blockquote>

          <para>we can also write:</para>

          <blockquote>
            <programlisting>select * from flotsam
  join jetsam using (sea, ship)</programlisting>
          </blockquote>

          <para>which is considerably shorter. The result set is a little
          different though – at least when using
          <quote><database>SELECT</database> *</quote>:</para>

          <itemizedlist>
            <listitem>
              <para>The explicit-condtion join – with the
              <database>ON</database> clause – will contain each of the
              columns <database>SEA</database> and <database>SHIP</database>
              twice: once from table <database>FLOTSAM</database>, and once
              from table <database>JETSAM</database>. Obviously, they will
              have the same values.</para>
            </listitem>

            <listitem>
              <para>The named columns join – with the
              <database>USING</database> clause – will contain these columns
              only once.</para>
            </listitem>
          </itemizedlist>

          <para>If you want all the columns in the result set of the named
          columns join, set up your query like this:</para>

          <blockquote>
            <programlisting>select f.*, j.*
  from flotsam f
  join jetsam j using (sea, ship)</programlisting>
          </blockquote>

          <para>This will give you the exact same result set as the
          explicit-condition join.</para>

          <para>For an <database>OUTER</database> named columns join, there's
          an additional twist when using <quote><database>SELECT</database>
          *</quote> or an unqualified column name from the
          <database>USING</database> list:</para>

          <para>If a row from one source set doesn't have a match in the other
          but must still be included because of the <database>LEFT</database>,
          <database>RIGHT</database> or <database>FULL</database> directive,
          the merged column in the joined set gets the
          non-<database>NULL</database> value. That is fair enough, but now
          you can't tell whether this value came from the left set, the right
          set, or both. This can be especially deceiving when the value came
          from the right hand set, because <quote><literal>*</literal></quote>
          always shows combined columns in the left hand part – even in the
          case of a <database>RIGHT</database> join.</para>

          <para>Whether this is a problem or not depends on the situation. If
          it is, use the <quote><literal>a</literal>.<literal>*</literal>,
          <literal>b</literal>.<literal>*</literal></quote> approach shown
          above, with <literal>a</literal> and <literal>b</literal> the names
          or aliases of the two sources. Or better yet, avoid
          <quote><literal>*</literal></quote> altogether in your serious
          queries and qualify all column names in joined sets. This has the
          additional benefit that it forces you to think about which data you
          want to retrieve and where from.</para>

          <para>It is your responsibility to make sure that the column names
          in the <database>USING</database> list are of compatible types
          between the two sources. If the types are compatible but not equal,
          the engine converts them to the type with the broadest range of
          values before comparing the values. This will also be the data type
          of the merged column that shows up in the result set if
          <quote><database>SELECT</database> *</quote> or the unqualified
          column name is used. Qualified columns on the other hand will always
          retain their original data type.</para>
        </section>
      </section>

      <section id="langref25-dml-select-joins-natural">
        <title>Natural joins</title>

        <para>Taking the idea of the named columns join a step further, a
        <firstterm>natural join</firstterm> performs an automatic equi-join on
        all the columns that have the same name in the left and right table.
        The data types of these columns must be compatible.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;natural-join&gt;</replaceable>  ::=  NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>     ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Given these two tables:</para>

        <blockquote>
          <programlisting>create table TA (
  a bigint,
  s varchar(12),
  ins_date date
)</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>create table TB (
  a bigint,
  descr varchar(12),
  x float,
  ins_date date
)</programlisting>
        </blockquote>

        <para>a natural join on <database>TA</database> and
        <database>TB</database> would involve the columns
        <replaceable>a</replaceable> and <replaceable>ins_date</replaceable>,
        and the following two statements would have the same effect:</para>

        <blockquote>
          <programlisting>select * from TA
  natural join TB</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from TA
  join TB using (a, ins_date)</programlisting>
        </blockquote>

        <para>Like all joins, natural joins are inner joins by default, but
        you can turn them into outer joins by specifying
        <database>LEFT</database>, <database>RIGHT</database> or
        <database>FULL</database> before the <database>JOIN</database>
        keyword.</para>

        <para>Caution: if there are no columns with the same name in the two
        source relations, a <database>CROSS JOIN</database> is performed.
        We'll get to this type of join in a minute.</para>
      </section>

      <section id="langref25-dml-select-joins-equality">
        <title>A note on equality</title>

        <para>The <quote><literal>=</literal></quote> operator, which is
        explicitly used in many conditional joins and implicitly in named
        column joins and natural joins, only matches values to values.
        According to the SQL standard, <database>NULL</database> is not a
        value and hence two <database>NULL</database>s are neither equal nor
        unequal to one another. If you need <database>NULL</database>s to
        match each other in a join, use the <database>IS NOT DISTINCT
        FROM</database> operator. This operator returns true if the operands
        have the same value <emphasis>or</emphasis> if they are both
        <database>NULL</database>.</para>

        <blockquote>
          <programlisting>select *
  from A join B
  on A.id is not distinct from B.code</programlisting>
        </blockquote>

        <para>Likewise, in the – extremely rare – cases where you want to join
        on <emphasis>in</emphasis>equality, use <database>IS DISTINCT
        FROM</database>, not <quote><literal>&lt;&gt;</literal></quote>, if
        you want <database>NULL</database> to be considered different from any
        value and two <database>NULL</database>s considered equal:</para>

        <blockquote>
          <programlisting>select *
  from A join B
  on A.id is distinct from B.code</programlisting>
        </blockquote>

        <para>This note about equality and inequality operators applies
        everywhere in Firebird SQL, not only in join conditions.</para>
      </section>

      <section id="langref25-dml-select-joins-cross">
        <title>Cross joins</title>

        <para>A cross join produces the full set product of the two data
        sources. This means that it successfully matches every row in the left
        source to every row in the right source.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;cross-join&gt;</replaceable>  ::=  {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <para>Please notice that the comma syntax is deprecated! It is only
        supported to keep legacy code working and may disappear in some future
        version.</para>

        <para>Cross-joining two sets is equivalent to joining them on a
        tautology (a condition that is always true). The following two
        statements have the same effect:</para>

        <blockquote>
          <programlisting>select * from TA
  cross join TB</programlisting>

          <programlisting>select * from TA
  join TB on 1 = 1</programlisting>
        </blockquote>

        <para>Cross joins are inner joins, because they only include matching
        records – it just so happens that <emphasis>every</emphasis> record
        matches! An outer cross join, if it existed, wouldn't add anything to
        the result, because what outer joins add are non-matching records, and
        these don't exist in cross joins.</para>

        <para>Cross joins are seldom useful, except if you want to list all
        the possible combinations of two or more variables. Suppose you are
        selling a product that comes in different sizes, different colors and
        different materials. If these variables are each listed in a table of
        their own, this query would return all the combinations:</para>

        <blockquote>
          <programlisting>select m.name, s.size, c.name
  from materials m
  cross join sizes s
  cross join colors c</programlisting>
        </blockquote>
      </section>

      <section id="langref25-dml-select-joins-ambiguity">
        <title>Ambiguous field names in joins</title>

        <para>Firebird rejects unqualified field names in a query if these
        field names exist in more than one dataset involved in a join. This is
        even true for inner equi-joins where the field name figures in the
        <database>ON</database> clause like this:</para>

        <blockquote>
          <programlisting>select a, b, c
  from TA
  join TB on TA.a = TB.a</programlisting>
        </blockquote>

        <para>There is one exception to this rule: with named columns joins
        and natural joins, the unqualified field name of a column taking part
        in the matching process may be used legally and refers to the merged
        column of the same name. For named columns joins, these are the
        columns listed in the <database>USING</database> clause. For natural
        joins, they are the columns that have the same name in both relations.
        But please notice again that, especially in outer joins, plain
        <replaceable>colname</replaceable> isn't always the same as
        <replaceable>left</replaceable>.<replaceable>colname</replaceable> or
        <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
        Types may differ, and one of the qualified columns may be
        <database>NULL</database> while the other isn't. In that case, the
        value in the merged, unqualified column may mask the fact that one of
        the source values is absent.</para>
      </section>
    </section>

    <section id="langref25-dml-select-where">
      <title>The <database>WHERE</database> clause</title>

      <para>The <database>WHERE</database> clause serves to limit the rows
      returned to the ones that the caller is interested in. The condition
      following the keyword <database>WHERE</database> can be as simple as a
      check like <quote><database>AMOUNT</database> = 3</quote> or it can be a
      multilayered, convoluted expression containing subselects, predicates,
      function calls, mathematical and logical operators, context variables
      and more.</para>

      <para>The condition in the <database>WHERE</database> clause is often
      called the <firstterm>search condition</firstterm>, the
      <firstterm>search expression</firstterm> or simply the
      <firstterm>search</firstterm>.</para>

      <para>In DSQL and ESQL, the search expression may contain parameters.
      This is useful if a query has to be repeated a number of times with
      different input values. In the SQL string as it is passed to the server,
      question marks are used as placeholders for the parameters. They are
      called <firstterm>positional parameters</firstterm> because they can
      only be told apart by their position in the string. Connectivity
      libraries often support <firstterm>named parameters</firstterm> of the
      form <parameter>:id</parameter>, <parameter>:amount</parameter>,
      <parameter>:a</parameter> etc. These are more user-friendly; the library
      takes care of translating the named parameters to positional parameters
      before passing the statement to the server.</para>

      <para>The search condition may also contain local (PSQL) or host (ESQL)
      variable names, preceded by a colon.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ...
   FROM ...
   [...]
   WHERE <replaceable>&lt;search-condition&gt;</replaceable>
   [...]

<replaceable>&lt;search-condition&gt;</replaceable>  ::=  a boolean expression returning
                         <constant>TRUE</constant>, <constant>FALSE</constant> or possibly <constant>UNKNOWN</constant> (<constant>NULL</constant>)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Only those rows for which the search condition evaluates to
      <constant>TRUE</constant> are included in the result set. Be careful
      with possible <constant>NULL</constant> outcomes: if you negate a
      <constant>NULL</constant> expression with <database>NOT</database>, the
      result will still be <constant>NULL</constant> and the row will not
      pass. This is demonstrated in one of the examples below.</para>

      <bridgehead>Examples</bridgehead>

      <blockquote>
        <programlisting>select genus, species from mammals
  where family = 'Felidae'
  order by genus</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from persons
  where birthyear in (1880, 1881) 
     or birthyear between 1891 and 1898</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select name, street, borough, phone
  from schools s
  where exists (select * from pupils p where p.school = s.id)
  order by borough, street</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from employees
  where salary &gt;= 10000 and position &lt;&gt; 'Manager'</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select name from wrestlers
  where region = 'Europe'
    and weight &gt; all (select weight from shot_putters
                      where region = 'Africa')</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from players
  where team_id = (select id from teams where name = 'Buffaloes')</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select sum (population) from towns
  where name like '%dam'
  and province containing 'land'</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select password from usertable
  where username = current_user</programlisting>
      </blockquote>

      <para>The following example shows what can happen if the search
      condition evaluates to <constant>NULL</constant>.</para>

      <para>Suppose you have a table listing some children's names and the
      number of marbles they possess. At a certain moment, the table contains
      these data:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>CHILD</entry>

                <entry>MARBLES</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Anita</entry>

                <entry>23</entry>
              </row>

              <row>
                <entry>Bob E.</entry>

                <entry>12</entry>
              </row>

              <row>
                <entry>Chris</entry>

                <entry><emphasis>&lt;null&gt;</emphasis></entry>
              </row>

              <row>
                <entry>Deirdre</entry>

                <entry>1</entry>
              </row>

              <row>
                <entry>Eve</entry>

                <entry>17</entry>
              </row>

              <row>
                <entry>Fritz</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>Gerry</entry>

                <entry>21</entry>
              </row>

              <row>
                <entry>Hadassah</entry>

                <entry><emphasis>&lt;null&gt;</emphasis></entry>
              </row>

              <row>
                <entry>Isaac</entry>

                <entry>6</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>First, please notice the difference between
      <constant>NULL</constant> and 0: Fritz is <emphasis>known</emphasis> to
      have no marbles at all, Chris's and Hadassah's marble counts are
      unknown.</para>

      <para>Now, if you issue this SQL statement:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &gt; 10</programlisting>
      </blockquote>

      <para>you will get the names Anita, Bob E., Eve and Gerry. These
      children all have more than 10 marbles.</para>

      <para>If you negate the expression:<blockquote>
          <programlisting>select list(child) from marbletable where not marbles &gt; 10</programlisting>
        </blockquote></para>

      <para>it's the turn of Deirdre, Fritz and Isaac to fill the list. Chris
      and Hadassah are not included, because they aren't
      <emphasis>known</emphasis> to have ten marbles or less. Should you
      change that last query to:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &lt;= 10</programlisting>
      </blockquote>

      <para>the result will still be the same, because the expression
      <constant>NULL</constant> <literal>&lt;=</literal> <literal>10</literal>
      yields <constant>UNKNOWN</constant>. This is not the same as
      <constant>TRUE</constant>, so Chris and Hadassah are not listed. If you
      want them listed with the <quote>poor</quote> children, change the query
      to:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &lt;= 10 or marbles is null</programlisting>
      </blockquote>

      <para>Now the search condition becomes true for Chris and Hadassah,
      because <quote><literal>marbles is null</literal></quote> obviously
      returns <constant>TRUE</constant> in their case. In fact, the search
      condition cannot be <constant>NULL</constant> for anybody now.</para>

      <para>Lastly, two examples of <database>SELECT</database> queries with
      parameters in the search. It depends on the application how you should
      define query parameters and even if it is possible at all. Notice that
      queries like these cannot be executed immediately: they have to be
      <emphasis>prepared</emphasis> first. Once a parameterized query has been
      prepared, the user (or calling code) can supply values for the
      parameters and have it executed many times, entering new values before
      every call. How the values are entered and the execution started is up
      to the application. In a GUI environment, the user typically types the
      parameter values in one or more text boxes and then clicks an
      <quote>Execute</quote>, <quote>Run</quote> or <quote>Refresh</quote>
      button.</para>

      <blockquote>
        <programlisting>select name, address, phone frome stores
  where city = ? and class = ?</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from pants
  where model = :model and size = :size and color = :col</programlisting>
      </blockquote>

      <para>The last query cannot be passed directly to the engine; the
      application must convert it to the other format first, mapping named
      parameters to positional parameters.</para>
    </section>

    <section id="langref25-dml-select-groupby">
      <title>The <database>GROUP BY</database> clause</title>

      <para><database>GROUP BY</database> merges output rows that have the
      same combination of values in its item list into a single row. Aggregate
      functions in the select list are applied to each group individually
      instead of to the dataset as a whole.</para>

      <para>If the select list only contains aggregate columns – or, more
      generally, columns whose values don't depend on individual rows in the
      underlying set – <database>GROUP BY</database> is optional. When
      omitted, the final result set of will consist of a single row (provided
      that at least one aggregated column is present).</para>

      <para>If the select list contains both aggregate columns and columns
      whose values may vary per row, the <database>GROUP BY</database> clause
      becomes mandatory.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;grouping-item&gt;</replaceable> [, <replaceable>&lt;grouping-item&gt;</replaceable> ...]
   [HAVING <replaceable>&lt;grouped-row-condition&gt;</replaceable>]
   ...

<replaceable>&lt;grouping-item&gt;</replaceable>         ::=  <replaceable>&lt;non-aggr-select-item&gt;</replaceable>
                               | <replaceable>&lt;non-aggr-expression&gt;</replaceable>

<replaceable>&lt;non-aggr-select-item&gt;</replaceable>  ::=  <replaceable>column-copy</replaceable>
                               | <replaceable>column-alias</replaceable>
                               | <replaceable>column-position</replaceable>

<replaceable>&lt;non-aggr-expression&gt;</replaceable>   ::=  any non-aggregate expression that is not
                             in the select list, e.g. unselected columns
                             from the source set or expressions that
                             don't depend on the data in the set at all</programlisting>
          </blockquote></para>
      </formalpara>

      <para>A general rule of thumb is that every non-aggregate item in the
      <database>SELECT</database> list must also be in the <database>GROUP
      BY</database> list. You can do this in three ways:</para>

      <orderedlist>
        <listitem>
          <para>By copying the item verbatim from the select list, e.g.
          <quote><literal>class</literal></quote> or
          <quote><literal>'D:'</literal> <literal>||</literal>
          <literal>upper(doccode)</literal></quote>.</para>
        </listitem>

        <listitem>
          <para>By specifying the column alias, if it exists.</para>
        </listitem>

        <listitem>
          <para>By specifying the column position as an integer
          <emphasis>literal</emphasis> between 1 and the number of columns.
          Integer values resulting from expressions or parameter substitutions
          are simply invariables and will be used as such in the grouping.
          They will have no effect though, as their value is the same for each
          row.</para>
        </listitem>
      </orderedlist>

      <para>Please notice: If you group by a column position, the expression
      at that position is copied internally from the select list. If it
      concerns a subquery, that subquery will be executed at least twice.<!--I suppose the same goes for grouping by aliases? And not only for subqueries but also function calls? TEST USING GENERATORS--></para>

      <para>In addition to the required items, the grouping list may also
      contain:</para>

      <itemizedlist>
        <listitem>
          <para>Columns from the source table that are not in the select list,
          or non-aggregate expressions based on such columns. Adding such
          columns may further subdivide the groups. But since these columns
          are not in the select list, you can't tell which aggregated row
          corresponds to which value in the column. So, in general, if you are
          interested in this information, you also include the column or
          expression in the select list – which brings you back to the
          standard <quote>every non-aggregate column in the select list must
          also be in the grouping list</quote> mantra.</para>
        </listitem>

        <listitem>
          <para>Expressions that aren't dependent on the data in the
          underlying set, e.g. constants, context variables, single-value
          non-correlated subselects etc. This is only mentioned for
          completeness, as adding such items is utterly pointless: they don't
          affect the grouping at all. <quote>Harmless but useless</quote>
          items like these may also figure in the select list without being
          copied to the grouping list.</para>
        </listitem>
      </itemizedlist>

      <bridgehead>Examples</bridgehead>

      <para>When the select list only contains aggregate columns,
      <database>GROUP BY</database> is not mandatory:</para>

      <blockquote>
        <programlisting>select count(*), avg(age) from students
  where sex = 'M'</programlisting>
      </blockquote>

      <para>This will return a single row listing the number of male students
      and their average age. Adding expressions that don't depend on values in
      individual rows of table <database>STUDENTS</database> doesn't change
      that:</para>

      <blockquote>
        <programlisting>select count(*), avg(age), current_date from students
  where sex = 'M'</programlisting>
      </blockquote>

      <para>The row will now have an extra column showing the current date,
      but other than that, nothing fundamental has changed. A <database>GROUP
      BY</database> clause is still not required.</para>

      <para>However, in both the above examples it is
      <emphasis>allowed</emphasis>. This is perfectly valid:</para>

      <blockquote>
        <programlisting>select count(*), avg(age) from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>and will return a row for each class that has boys in it, listing
      the number of boys and their average age in that particular class. (If
      you also leave the <literal>current_date</literal> field in, this value
      will be repeated on every row, which is not very exciting.)</para>

      <para>The above query has a major drawback though: it gives you
      information about the different classes, but it doesn't tell you which
      row applies to which class. In order to get that extra bit of
      information, the non-aggregate column <database>CLASS</database> must be
      added to the select list:</para>

      <blockquote>
        <programlisting>select class, count(*), avg(age) from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>Now we have a useful query. Notice that the addition of column
      <database>CLASS</database> also makes the <database>GROUP BY</database>
      clause mandatory. We can't drop that clause anymore, unless we also
      remove <database>CLASS</database> from the column list.</para>

      <para>The output of our last query may look something like this:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>CLASS</entry>

                <entry>COUNT</entry>

                <entry>AVG</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2A</entry>

                <entry>12</entry>

                <entry>13.5</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>9</entry>

                <entry>13.9</entry>
              </row>

              <row>
                <entry>3A</entry>

                <entry>11</entry>

                <entry>14.6</entry>
              </row>

              <row>
                <entry>3B</entry>

                <entry>12</entry>

                <entry>14.4</entry>
              </row>

              <row>
                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>The headings <quote>COUNT</quote> and <quote>AVG</quote> are not
      very informative. In a simple case like this, you might get away with
      that, but in general you should give aggregate columns a meaningful name
      by aliasing them:</para>

      <blockquote>
        <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>As you may recall from the formal syntax of the columns list, the
      <database>AS</database> keyword is optional.</para>

      <para>Adding more non-aggregate (or rather: row-dependent) columns
      requires adding them to the <database>GROUP BY</database> clause too.
      For instance, you might want to see the above information for girls as
      well; and you may also want to differentiate between boarding and day
      students:</para>

      <blockquote>
        <programlisting>select class,
       sex,
       boarding_type,
       count(*) as number,
       avg(age) as avg_age
  from students
  group by class, sex, boarding_type</programlisting>
      </blockquote>

      <para>This may give you the following result:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="5">
            <thead>
              <row>
                <entry>CLASS</entry>

                <entry>SEX</entry>

                <entry>BOARDING_TYPE</entry>

                <entry>NUMBER</entry>

                <entry>AVG_AGE</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2A</entry>

                <entry>F</entry>

                <entry>BOARDING</entry>

                <entry>9</entry>

                <entry>13.3</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>F</entry>

                <entry>DAY</entry>

                <entry>6</entry>

                <entry>13.5</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>M</entry>

                <entry>BOARDING</entry>

                <entry>7</entry>

                <entry>13.6</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>M</entry>

                <entry>DAY</entry>

                <entry>5</entry>

                <entry>13.4</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>F</entry>

                <entry>BOARDING</entry>

                <entry>11</entry>

                <entry>13.7</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>F</entry>

                <entry>DAY</entry>

                <entry>5</entry>

                <entry>13.7</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>M</entry>

                <entry>BOARDING</entry>

                <entry>6</entry>

                <entry>13.8</entry>
              </row>

              <row>
                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>Each row in the result set corresponds to one particular
      combination of the variables class, sex and boarding type. The aggregate
      results – number and average age – are given for each of these rather
      specific groups individually. In a query like this, you don't see a
      total for boys as a whole, or day students as a whole. That's the
      tradeoff: the more non-aggregate columns you add, the more you can
      pinpoint very specific groups, but the more you also lose sight of the
      general picture. Of course you can still obtain the
      <quote>coarser</quote> aggregates through separate queries.</para>

      <section id="langref25-dml-select-groupby-having">
        <title><database>HAVING</database></title>

        <para>Just as a <database>WHERE</database> clause limits the rows in a
        dataset to those that meet the search condition, so the
        <database>HAVING</database> subclause imposes restrictions on the
        aggregated rows in a grouped set. <database>HAVING</database> is
        optional, and can only be used in conjunction with <database>GROUP
        BY</database>.</para>

        <para>The condition(s) in the <database>HAVING</database> clause can
        refer to:</para>

        <itemizedlist>
          <listitem>
            <para>Any aggregated column in the select list. This is the most
            widely used alternative.</para>
          </listitem>

          <listitem>
            <para>Any aggregated expression that is not in the select list,
            but allowed in the context of the query. This is sometimes useful
            too.</para>
          </listitem>

          <listitem>
            <para>Any column in the <database>GROUP BY</database> list. While
            legal, it is more efficient to filter on these non-aggregated data
            at an earlier stage: in the <database>WHERE</database>
            clause.</para>
          </listitem>

          <listitem>
            <para>Any expression whose value doesn't depend on the contents of
            the dataset (like a constant or a context variable). This is valid
            but utterly pointless, because it will either suppress the entire
            set or leave it untouched, based on conditions that have nothing
            to do with the set itself.</para>
          </listitem>
        </itemizedlist>

        <para>A <database>HAVING</database> clause can
        <emphasis>not</emphasis> contain:</para>

        <itemizedlist>
          <listitem>
            <para>Non-aggregated column expressions that are not in the
            <database>GROUP BY</database> list.</para>
          </listitem>

          <listitem>
            <para>Column positions. An integer in the
            <database>HAVING</database> clause is just an integer.</para>
          </listitem>

          <listitem>
            <para>Column aliases – not even if they appear in the
            <database>GROUP BY</database> clause!<!--Is that by design? Test also in 2.5--></para>
          </listitem>
        </itemizedlist>

        <bridgehead>Examples</bridgehead>

        <para>Building on our earlier examples, this could be used to skip
        small groups of students:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having count(*) &gt;= 5</programlisting>
        </blockquote>

        <para>To select only groups that have a minimum age spread:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having max(age) - min(age) &gt; 1.2</programlisting>
        </blockquote>

        <para>Notice that if you're really interested in this information,
        you'd normally include <literal>min(age)</literal> and
        <literal>max(age)</literal> – or the expression
        <quote><literal>max(age)</literal> <literal>-</literal>
        <literal>min(age)</literal></quote> – in the select list as
        well!</para>

        <para>To include only 3rd classes:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having class starting with '3'</programlisting>
        </blockquote>

        <para>Better would be to move this condition to the
        <database>WHERE</database> clause:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M' and class starting with '3'
  group by class</programlisting>
        </blockquote>
      </section>
    </section>

    <section id="langref25-dml-select-plan">
      <title>The <database>PLAN</database> clause</title>

      <para>The <database>PLAN</database> clause enables the user to submit a
      data retrieval plan, thus overriding the plan that the optimizer would
      have generated automatically.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <para><programlisting>PLAN <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;plan-expr&gt;</replaceable>    ::=  (<replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])
                    | <replaceable>&lt;sorted-item&gt;</replaceable>
                    | <replaceable>&lt;joined-item&gt;</replaceable>
                    | <replaceable>&lt;merged-item&gt;</replaceable>

<replaceable>&lt;sorted-item&gt;</replaceable>  ::=  SORT (<replaceable>&lt;plan-item&gt;</replaceable>)

<replaceable>&lt;joined-item&gt;</replaceable>  ::=  JOIN (<replaceable>&lt;plan-item&gt;</replaceable>, <replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])

<replaceable>&lt;merged-item&gt;</replaceable>  ::=  [SORT] MERGE (<replaceable>&lt;sorted-item&gt;</replaceable>, <replaceable>&lt;sorted-item&gt;</replaceable> [, <replaceable>&lt;sorted-item&gt;</replaceable> ...])

<replaceable>&lt;plan-item&gt;</replaceable>    ::=  <replaceable>&lt;basic-item&gt;</replaceable> | <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;basic-item&gt;</replaceable>   ::=  <replaceable>&lt;relation&gt;</replaceable>
                    {NATURAL
                     | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)
                     | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;relation&gt;</replaceable>     ::=  <replaceable>table</replaceable> 
                    | <replaceable>view</replaceable> [<replaceable>table</replaceable>]                                           <emphasis>-- en een SP, CTE of derived table?</emphasis>

<replaceable>&lt;indexlist&gt;</replaceable>    ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]

<replaceable>table</replaceable>, <replaceable>view</replaceable>    ::=  name or alias</programlisting></para>
          </blockquote></para>
      </formalpara>

      <para>Every time a user submits a query to the Firebird engine, the
      optimizer computes a data retrieval strategy. Most Firebird clients can
      make this retrieval plan visible to the user. In Firebird's own
      <application>isql</application> utility, this is done with the command
      <database>SET PLAN ON</database>. If you are studying query plans rather
      than running queries, <database>SET PLANONLY ON</database> will show the
      plan without executing the query.</para>

      <para>In most situations, you can trust that Firebird will select the
      optimal query plan for you. However, if you have complicated queries
      that seem to be underperforming, it may very well be worth your while to
      examine the plan and see if you can improve on it.</para>

      <section id="langref25-dml-select-plan-simple">
        <title>Simple plans</title>

        <para>The simplest plans consist of just a relation name followed by a
        retrieval method. E.g., for an unsorted single-table select without a
        <database>WHERE</database> clause:</para>

        <blockquote>
          <programlisting>select * from students
  plan (students natural)</programlisting>
        </blockquote>

        <para>If there's a <database>WHERE</database> or a
        <database>HAVING</database> clause, you can specify the index to be
        used for finding matches:</para>

        <blockquote>
          <programlisting>select * from students
  where class = '3C'
  plan (students index (ix_stud_class))</programlisting>
        </blockquote>

        <para>The <database>INDEX</database> directive is also used for join
        conditions (to be discussed a little later). It can contain a list of
        indexes, separated by commas.</para>

        <para><database>ORDER</database> specifies the index for sorting the
        set if an <database>ORDER BY</database> or <database>GROUP
        BY</database> clause is present:</para>

        <blockquote>
          <programlisting>select * from students
  plan (students order pk_students)
  order by id</programlisting>
        </blockquote>

        <para><database>ORDER</database> and <database>INDEX</database> can be
        combined:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan (students order pk_students index (ix_stud_class))
  order by id</programlisting>
        </blockquote>

        <para>It is perfectly OK if <database>ORDER</database> and
        <database>INDEX</database> specify the same index:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan (students order ix_stud_class index (ix_stud_class))
  order by class</programlisting>
        </blockquote>

        <para>For sorting sets when there's no usable index available (or if
        you want to suppress its use), leave out <database>ORDER</database>
        and prepend the plan expression with <database>SORT</database>:</para>

        <blockquote>
          <programlisting>select * from students
  plan sort (students natural)
  order by name</programlisting>
        </blockquote>

        <para>Or when an index is used for the search:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan sort (students index (ix_stud_class))
  order by name</programlisting>
        </blockquote>

        <para>Notice that <database>SORT</database>, unlike
        <database>ORDER</database>, is outside the parentheses. This reflects
        the fact that the data rows are retrieved unordered and sorted
        afterwards by the engine.</para>

        <para>When selecting from a view, specify the view and the table
        involved. For instance, if you have a view
        <database>FRESHMEN</database> that selects just the first-year
        students:</para>

        <blockquote>
          <programlisting>select * from freshmen
  plan (freshmen students natural)</programlisting>
        </blockquote>

        <para>Or, for instance:</para>

        <blockquote>
          <programlisting>select * from freshmen
  where id &gt; 10
  plan sort (freshmen students index (pk_students))
  order by name desc</programlisting>
        </blockquote>

        <!--Vraag Dmitry of weglaten tabelnaam ongewenst is!-->

        <para>Please notice: if you have aliased a table or view, you must use
        the alias name, not the original name, in the
        <database>PLAN</database> clause.</para>
      </section>

      <section id="langref25-dml-select-plan-composite">
        <title>Composite plans</title>

        <para>When a join is made, you can specify the index which is to be
        used for matching. You must also use the <database>JOIN</database>
        directive on the two streams in the plan:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan join (s natural, c index (pk_classes))</programlisting>
        </blockquote>

        <para>The same join, sorted on an indexed column:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan join (s order pk_students, c index (pk_classes))
  order by s.id</programlisting>
        </blockquote>

        <para>And on a non-indexed column:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan sort (join (s natural, c index (pk_classes)))
  order by s.name</programlisting>
        </blockquote>

        <para>With a search added:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  where s.class &lt;= '2'
  plan sort (join (s index (fk_student_class), c index (pk_classes)))
  order by s.name</programlisting>
        </blockquote>

        <para>As a left outer join:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from classes c
  left join students s on c.name = s.class
  where s.class &lt;= '2'
  plan sort (join (c natural, s index (fk_student_class)))
  order by s.name</programlisting>
        </blockquote>

        <para>If there is no index available to match the join criteria (or if
        you don't want to use it), the plan must first sort both streams on
        their join column(s) and then merge them. This is achieved with the
        <database>SORT</database> directive (which we've already met) and
        <database>MERGE</database> instead of
        <database>JOIN</database>:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  plan merge (sort (c natural), sort (s natural))</programlisting>
        </blockquote>

        <para>Adding an <database>ORDER BY</database> clause means the result
        of the merge must also be sorted:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  plan sort (merge (sort (c natural), sort (s natural)))
  order by c.name, s.id</programlisting>
        </blockquote>

        <para>Finally, we add a search condition on two indexable colums of
        table <database>STUDENTS</database>:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  where s.id &lt; 10 and s.class &lt;= '2'
  plan sort (merge (sort (c natural),
                    sort (s index (pk_students, fk_student_class))))
  order by c.name, s.id</programlisting>
        </blockquote>

        <para>As follows from the formal syntax definition,
        <database>JOIN</database>s and <database>MERGE</database>s in the plan
        may combine more than two streams. Also, every plan expression may be
        used as a plan item in an encompassing plan. This means that plans of
        certain complicated queries may have various nesting levels.</para>

        <para>Finally, instead of <database>MERGE</database> you may also
        write <database>SORT MERGE</database>. As this makes absolutely no
        difference and may create confusion with <quote>real</quote>
        <database>SORT</database> directives (the ones that
        <emphasis>do</emphasis> make a difference), it's probably best to
        stick to plain <database>MERGE</database>.</para>

        <!--Uit mailwisseling met Dmitry, mei 2014:

> But the engine happily accepts a user plan like:
>
>    MERGE (unsorted stream, unsorted stream)
>
> (It doesn't follow it, at least not the ones I tried, but it also doesn't return an error like it does with other invalid plans.)

There are more cases when the engine doesn't follow user-specified plans. Sigh. Therefore I treat them as deprecated.

**> Gebruiker hiervoor waarschuwen in de LangRef!-->
      </section>
    </section>

    <section id="langref25-dml-select-union">
      <title><database>UNION</database></title>

      <para>A <database>UNION</database> concatenates two or more datasets,
      thus increasing the number of rows but not the number of columns.
      Datasets taking part in a <database>UNION</database> must have the same
      number of columns, and columns at corresponding positions must be of the
      same type. Other than that, they may be totally unrelated.</para>

      <para>By default, a union suppresses duplicate rows. <database>UNION
      ALL</database> shows all rows, including any duplicates. The optional
      <database>DISTINCT</database> keyword makes the default behaviour
      explicit.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting><replaceable>&lt;union&gt;</replaceable>               ::=  <replaceable>&lt;individual-select&gt;</replaceable>
                           UNION [DISTINCT | ALL]
                           <replaceable>&lt;individual-select&gt;</replaceable>
                           [UNION [DISTINCT | ALL]
                            <replaceable>&lt;individual-select&gt;</replaceable>
                            ...]
                           [<replaceable>&lt;union-wide-clauses&gt;</replaceable>] 

<replaceable>&lt;individual-select&gt;</replaceable>   ::=  SELECT 
                           [TRANSACTION <replaceable>name</replaceable>]
                           [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
                           [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>
                           [INTO <replaceable>&lt;host-varlist&gt;</replaceable>]
                           FROM <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>]
                           [<replaceable>&lt;joins&gt;</replaceable>]
                           [WHERE <replaceable>&lt;condition&gt;</replaceable>]
                           [GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>
                           [HAVING <replaceable>&lt;aggregate-condition&gt;</replaceable>]]
                           [PLAN <replaceable>&lt;plan-expr&gt;</replaceable>]

<replaceable>&lt;union-wide-clauses&gt;</replaceable>  ::=  [ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>]
                           [ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]
                           [FOR UPDATE [OF <replaceable>&lt;columns&gt;</replaceable>]]
                           [WITH LOCK]
                           [INTO <replaceable>&lt;PSQL-varlist&gt;</replaceable>]</programlisting>
          </blockquote></para>
      </formalpara>

      <!--1: Volgens Helens boek *moeten*, als twee of meer selects binnen een union uit dezelfde tabel selecteren, table aliases worden gebruikt,
al hoeven de kolomnamen niet gekwalificeerd te worden. Klopt dat? NEE!-->

      <!--
2: Is FOR UPDATE OF toegestaan in een UNION? In 2.5 onder FlameRobin krijg ik dan "attempt to fetch past last record in stream".
maar dat was dan ook wel bij een lege set. Bij een set met 3 records: multiple rows in singleton select.
Bij een set met 1 record: no statement had been executed or no result set available.

Ja, maar kan er ook echt ge-update worden in een UNION?

3: En WITH LOCK?
In FR: Token Unknown: WITH LOCK

4: Is INTO <host-varlist> toegestaan in selects binnen een UNION in ESQL?
Zo ja: wat als de varlists tussen de selects verschillen?
Zo nee, hoe kun je dan de resultaten in variabelen opslaan?-->

      <para>Unions take their column names from the <emphasis>first</emphasis>
      select query. If you want to alias union columns, do so in the column
      list of the topmost <database>SELECT</database>. Aliases in other
      participating selects are allowed and may even be useful, but will not
      propagate to the union level.</para>

      <para>If a union has an <database>ORDER BY</database> clause, the only
      allowed sort items are integer literals indicating 1-based column
      positions, optionally followed by an
      <database>ASC</database>/<database>DESC</database> and/or a
      <database>NULLS</database>
      <database>FIRST</database>/<database>LAST</database> directive. This
      also implies that you cannot order a union by anything that isn't a
      column in the union. (You can, however, wrap it in a derived table,
      which gives you back all the usual sort options.)</para>

      <para>Unions are allowed in subqueries of any kind and can themselves
      contain subqueries. They can also contain joins, and can take part in a
      join when wrapped in a derived table.</para>

      <bridgehead>Examples</bridgehead>

      <para>This query presents information from different music collections
      in one dataset using unions:</para>

      <blockquote>
        <programlisting>select id, title, artist, length, 'CD' as medium
  from cds
union
select id, title, artist, length, 'LP'
  from records
union
select id, title, artist, length, 'MC'
  from cassettes
order by 3, 2  -- artist, title</programlisting>
      </blockquote>

      <para>If <literal>id</literal>, <literal>title</literal>,
      <literal>artist</literal> and <literal>length</literal> are the only
      fields in the tables involved, the query can also be written as:</para>

      <blockquote>
        <programlisting>select c.*, 'CD' as medium
  from cds c
union
select r.*, 'LP'
  from records r
union
select c.*, 'MC'
  from cassettes c
order by 3, 2  -- artist, title</programlisting>
      </blockquote>

      <para>Qualifying the <quote>stars</quote> is necessary here because they
      aren't the only item in the column list. Notice how the <quote>c</quote>
      aliases in the first and third select don't bite each other; they don't
      have union scope, but only apply to their individual select
      query.</para>

      <para>The next query retrieves names and phone numbers from translators
      and proofreaders. Translators who also work as proofreaders will show up
      only once in the result set, provided their phone number is the same in
      both tables. The same result can be obtained without
      <database>DISTINCT</database>. With <database>ALL</database>, these
      people would appear twice.</para>

      <blockquote>
        <programlisting>select name, phone from translators
  union distinct
select name, telephone from proofreaders</programlisting>
      </blockquote>

      <para>A <database>UNION</database> within a subquery:</para>

      <blockquote>
        <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
      </blockquote>
    </section>

    <section id="langref25-MATERIAL-FROM-LRU">
      <title>MATERIAL COPIED FROM THE LRU</title>

      <para>The sections contained herein have been copied from the Firebird
      2.5 LRU (Language Reference Update). Some of them can be deleted, others
      extended to become Language Reference sections, yet others contain
      material that should be merged with the LR sections above.</para>

      <section id="langref25-dml-aggregates">
        <title>FROM LRU: Aggregate functions: Extended functionality</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Several types of mixing and nesting aggregate functions are
          supported since Firebird 1.5. They will be discussed in the
          following subsections. To get the complete picture, also look at the
          <database>SELECT</database> :: <database>GROUP BY</database>
          sections.</para>
        </formalpara>

        <section id="langref25-dml-aggregates-mix">
          <title>Mixing aggregate functions from different contexts</title>

          <para>Firebird 1.5 and up allow the use of aggregate functions from
          different contexts inside a single expression.</para>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
              </blockquote></para>
          </formalpara>

          <para>This admittedly rather contrived query shows, in the second
          column, the maximum index selectivity of any index defined on a
          table, followed by the table's field count between parentheses. Of
          course you would normally display the field count in a separate
          column, or in the column with the table name, but the purpose here
          is to demonstrate that you can combine aggregates from different
          contexts in a single expression.</para>

          <warning>
            <para>Firebird 1.0 also executes this type of query, but gives the
            wrong results!</para>
          </warning>
        </section>

        <section id="langref25-dml-aggregates-in-subqueries">
          <title>Aggregate functions and <database>GROUP BY</database> items
          inside subqueries</title>

          <para>Since Firebird 1.5 it is possible to use aggregate functions
          and/or expressions contained in the <database>GROUP BY</database>
          clause inside a subquery.</para>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>This query returns each table's ID and field count. The
                subquery refers to
                <literal><systemitem>flds.rdb$relation_name</systemitem></literal>,
                which is also a <database>GROUP BY</database> item:</para>

                <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>

                <para>The next query shows the last field from each table and
                its 1-based position. It uses the aggregate function
                <database>MAX</database> in a subquery.</para>

                <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>

                <para>The subquery also contains the <database>GROUP
                BY</database> item
                <systemitem>flds.rdb$relation_name</systemitem>, but that's
                not immediately obvious because in this case the
                <database>GROUP BY</database> clause uses the column
                number.</para>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-subqueries-in-aggregates">
          <title>Subqueries inside aggregate functions</title>

          <para>Using a singleton subselect inside (or as) an aggregate
          function argument is supported in Firebird 1.5 and up.</para>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>

                <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-aggregates-nesting">
          <title>Nesting aggregate function calls</title>

          <para>Firebird 1.5 allows the indirect nesting of aggregate
          functions, provided that the inner function is from a lower SQL
          context. Direct nesting of aggregate function calls, as in
          <quote><database>COUNT</database>( <database>MAX</database>( price )
          )</quote>, is still forbidden and punishable by exception.</para>

          <formalpara>
            <title>Example</title>

            <para>See under <link
            linkend="langref25-dml-subqueries-in-aggregates"><citetitle>Subqueries
            inside aggregate functions</citetitle></link>, where
            <database>COUNT()</database> is used inside a
            <database>SUM()</database>.</para>
          </formalpara>

          <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
        </section>

        <section id="langref25-dml-aggregates-having-orderby">
          <title>Aggregate statements: Stricter <database>HAVING</database>
          and <database>ORDER BY</database></title>

          <para>Firebird 1.5 and above are stricter than previous versions
          about what can be included in the <database>HAVING</database> and
          <database>ORDER BY</database> clauses. If, in the context of an
          aggregate statement, an operand in a <database>HAVING</database> or
          <database>ORDER BY</database> item contains a column name,<!--This should probably be: ...contains a column name from the query context (i.e. from the table or join in the FROM clause).-->
          it is only accepted if one of the following is true:</para>

          <itemizedlist>
            <listitem>
              <para>The column name appears in an aggregate function call
              (e.g. <quote><code>HAVING MAX(SALARY) &gt;
              10000</code></quote>).</para>
            </listitem>

            <listitem>
              <para>The operand equals or is based upon a non-aggregate column
              that appears in the <database>GROUP BY</database> list (by name
              or position).</para>
            </listitem>

            <!--This listitem commented out for now, needs research:
  o  The operand equals or is based upon a subquery, whether or not it is also a GROUP BY item.-->

            <!--See also under GROUP BY. Check if it is possible to include a non-aggregated subquery in the HAVING / ORDER BY
if that subquery contains columns not present in the GROUP BY.
And if this is possible, also look what happens if that subquery returns different values within a group.-->
          </itemizedlist>

          <para><quote>Is based upon</quote> means that the operand need not
          be exactly the same as the column name. Suppose there's a
          non-aggregate column <quote><database>STR</database></quote> in the
          select list. Then it's OK to use expressions like
          <quote><database>UPPER(STR)</database></quote>, <quote><database>STR
          || '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4
          FOR 2)</database></quote> in the <database>HAVING</database> clause
          – even if these expressions don't appear as such in the
          <database>SELECT</database> or <database>GROUP BY</database>
          list.</para>

          <!--If and when the subquery thing gets mentioned again, the above para must also be changed: ("...as the column name or subquery." etc.)-->
        </section>

        <!--1.5 Rlsnotes say:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used in the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->

        <!--*******

Maybe the entire GROUP BY thing should become something like this:

Every column that is present - in non-aggregrated form - on the highest (outermost?) level in the context of an aggregated query
(i.e., is a column of the relation(s) in the FROM clause)
*must* be included in the GROUP BY clause.

Question: If such a column is present in a subquery, but with the table alias as defined in the outermost query context,
must it go in the GROUP BY? I think yes, but test!
Question 2: As above, but this time with its own alias, belonging to the subselect?
I think it doesn't have to go in the GROUP BY then, but test.
Question 3: If a relation does not have an alias in the uppermost FROM, and it is used in a subselect
also without an alias, does that mean they have the same context? I hope not...-->
      </section>

      <section id="langref25-dml-as-relationalias">
        <title>FROM LRU: [<database>AS</database>] before relation
        alias</title>

        <formalpara>
          <title>Added in</title>

          <para>IB</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>The keyword <database>AS</database> can optionally be placed
          before a relation alias, just as it can be placed before a column
          alias. This feature dates back to InterBase times, but wasn't
          documented in the IB Language Reference.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>&lt;relation&gt;</replaceable> [AS] <replaceable>alias</replaceable>

<replaceable>&lt;relation&gt;</replaceable>  ::=  A table, view, or selectable SP</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <programlisting>select order_no, total, fullname
  from orders <emphasis role="bold">as</emphasis> o join customers <emphasis
                  role="bold">as</emphasis> c on o.cust_id = c.cust_id</programlisting>

              <programlisting>select order_no, total, fullname
  from orders o join customers c on o.cust_id = c.cust_id</programlisting>

              <para>The two queries are fully equivalent.</para>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-select-collate">
        <title>FROM LRU: <database>COLLATE</database> subclause for text
        <database>BLOB</database> columns</title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>COLLATE</database> subclauses are now also supported
          for text <database>BLOB</database>s.</para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-select-cte">
        <title>FROM LRU: Common Table Expressions (<quote><database>WITH ...
        AS ... SELECT</database></quote>)</title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL? Suppose not, but do find out / ask-->
        </formalpara>

        <para>A common table expression or <database>CTE</database> can be
        described as a virtual table or view, defined in a preamble to a main
        query, and going out of scope after the main query's execution. The
        main query can reference any <database>CTE</database>s defined in the
        preamble as if they were regular tables or views.
        <database>CTE</database>s can be recursive, i.e. self-referencing, but
        they cannot be nested.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;cte-construct&gt;</replaceable>  ::=  <replaceable>&lt;cte-defs&gt;</replaceable>
                      <replaceable>&lt;main-query&gt;</replaceable>

<replaceable>&lt;cte-defs&gt;</replaceable>       ::=  WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]

<replaceable>&lt;cte&gt;</replaceable>            ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-stmt&gt;</replaceable>)

<replaceable>&lt;column-list&gt;</replaceable>    ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]

<replaceable>&lt;cte-stmt&gt;</replaceable>       ::=  any <database>SELECT</database> statement or <database>UNION</database>

<replaceable>&lt;main-query&gt;</replaceable>     ::=  the main <database>SELECT</database> statement, which can refer to the
                      <database>CTE</database>s defined in the preamble</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting><emphasis role="bold">with dept_year_budget as (
  select fiscal_year,
         dept_no,
         sum(projected_budget) as budget
  from proj_dept_budget
  group by fiscal_year, dept_no
)</emphasis>
select d.dept_no,
       d.department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from department d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009
where exists (
  select * from proj_dept_budget b
  where d.dept_no = b.dept_no
)</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>A <database>CTE</database> definition can contain any
                legal <database>SELECT</database> statement, as long as it
                doesn't have a <quote><database>WITH...</database></quote>
                preamble of its own (no nesting).</para>
              </listitem>

              <listitem>
                <para><database>CTE</database>s defined for the same main
                query can reference each other, but care should be taken to
                avoid loops.</para>

                <!--Can a CTE also refer to another one that comes *after* it in the WITH clause?-->
              </listitem>

              <listitem>
                <para><database>CTE</database>s can be referenced from
                anywhere in the main query.</para>
              </listitem>

              <listitem>
                <para>Each <database>CTE</database> can be referenced multiple
                times in the main query, possibly with different
                aliases.</para>
              </listitem>

              <listitem>
                <para>When enclosed in parentheses, <database>CTE</database>
                constructs can be used as subqueries in
                <database>SELECT</database> statements, but also in
                <database>UPDATE</database>s, <database>MERGE</database>s
                etc.</para>
              </listitem>

              <listitem>
                <para>In PSQL, <database>CTE</database>s are also supported in
                <database>FOR</database> loop headers:</para>

                <programlisting>for <emphasis role="bold">with my_rivers as (select * from rivers where owner = 'me')</emphasis>
    select name, length from my_rivers into :rname, :rlen
do
begin
  ..
end</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <section id="langref25-dml-select-cte-recursive">
          <title>Recursive <database>CTE</database>s</title>

          <para>A recursive (self-referencing) <database>CTE</database> is a
          <database>UNION</database> which must have at least one
          non-recursive member, called the <firstterm>anchor</firstterm>. The
          non-recursive member(s) must be placed before the recursive
          member(s). Recursive members are linked to each other and to their
          non-recursive neighbour by <database>UNION ALL</database> operators.
          The unions between non-recursive members may be of any type.</para>

          <para>Recursive <database>CTE</database>s require the
          <database>RECURSIVE</database> keyword to be present right after
          <database>WITH</database>. Each recursive union member may reference
          itself only once, and it must do so in a <database>FROM</database>
          clause.</para>

          <para>A great benefit of recursive <database>CTE</database>s is that
          they use far less memory and CPU cycles than an equivalent recursive
          stored procedure.</para>

          <!--Find out:
- May the recursive reference occur in any FROM clause in the recursive union member, or only
  in the member's main (outermost) FROM clause?
- Can the RECURSIVE keyword be repeated before each (recursive) CTE?-->

          <para>The execution pattern of a recursive <database>CTE</database>
          is as follows:</para>

          <itemizedlist>
            <listitem>
              <para>The engine begins execution from a non-recursive
              member.</para>
            </listitem>

            <listitem>
              <para>For each row evaluated, it starts executing each recursive
              member one by one, using the current values from the outer row
              as parameters.</para>
            </listitem>

            <listitem>
              <para>If the currently executing instance of a recursive member
              produces no rows, execution loops back one level and gets the
              next row from the outer result set.</para>
            </listitem>
          </itemizedlist>

          <!--I wonder if this is entirely correct. Don't all the recursive union members each present a next lower level in the execution pattern?
Also, to whom should I give credit for this text (if I use it): Vlad or Paul?-->

          <formalpara>
            <title>Example with a recursive <database>CTE</database></title>

            <para><blockquote>
                <programlisting><emphasis role="bold">with recursive
  dept_year_budget as (
    select fiscal_year,
           dept_no,
           sum(projected_budget) as budget
    from proj_dept_budget
    group by fiscal_year, dept_no
  ),
  dept_tree as (
    select dept_no,
           head_dept,
           department,
           cast('' as varchar(255)) as indent
    from department
    where head_dept is null
    union all
    select d.dept_no,
           d.head_dept,
           d.department,
           h.indent || '  '
    from department d
         join dept_tree h on d.head_dept = h.dept_no
  )</emphasis>
select d.dept_no,
       d.indent || d.department as department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from <emphasis role="bold">dept_tree</emphasis> d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes on recursive <database>CTE</database>s</title>

            <para><itemizedlist>
                <listitem>
                  <para>Aggregates (<database>DISTINCT</database>,
                  <database>GROUP BY</database>, <database>HAVING</database>)
                  and aggregate functions (<database>SUM</database>,
                  <database>COUNT</database>, <database>MAX</database> etc)
                  are not allowed in recursive union members.</para>
                </listitem>

                <listitem>
                  <para>A recursive reference cannot participate in an outer
                  join.</para>
                </listitem>

                <listitem>
                  <para>The maximum recursion depth is 1024.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>

      <section id="langref25-dml-derived-tables">
        <title>FROM LRU: Derived tables (<quote><database>SELECT FROM
        SELECT</database></quote>)</title>

        <para>A derived table is the result set of a
        <database>SELECT</database> query, used in an outer
        <database>SELECT</database> as if it were an ordinary table. Put
        another way, it is a subquery in the <database>FROM</database>
        clause.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>(<replaceable>select-query</replaceable>)
   [[AS] <replaceable>derived-table-alias</replaceable>]
   [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

<replaceable>&lt;derived-column-aliases&gt;</replaceable>  ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>The derived table in the query below (shown in boldface)
              contains all the relation names in the database followed by
              their field count. The outer <database>SELECT</database>
              produces, for each existing field count, the number of relations
              having that field count.</para>

              <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>

              <para>A trivial example demonstrating the use of a derived table
              alias and column aliases list (both are optional):</para>

              <programlisting>select dbinfo.descr,
       dbinfo.def_charset
from   <emphasis role="bold">(select * from rdb$database) dbinfo
         (descr, rel_id, sec_class, def_charset)</emphasis></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>Derived tables can be nested.</para>
              </listitem>

              <listitem>
                <para>Derived tables can be unions and can be used in unions.
                They can contain aggregate functions, subselects and joins,
                and can themselves be used in aggregate functions, subselects
                and joins. They can also be or contain queries on selectable
                stored procedures. They can have <database>WHERE</database>,
                <database>ORDER BY</database> and <database>GROUP
                BY</database> clauses, <database>FIRST</database>,
                <database>SKIP</database> or <database>ROWS</database>
                directives, etc. etc.</para>
              </listitem>

              <listitem>
                <para>Every column in a derived table
                <emphasis>must</emphasis> have a name. If it doesn't have one
                by nature (e.g. because it's a constant) it must either be
                given an alias in the usual way, or a column aliases list must
                be added to the derived table specification.</para>
              </listitem>

              <listitem>
                <para>The column aliases list is optional, but if it is used
                it must be complete. That is: it must contain an alias for
                every column in the derived table.</para>
              </listitem>

              <listitem>
                <para>The optimizer can handle a derived table very
                efficiently. However, if the derived table is involved in an
                inner join and contains a subquery, then no join order can be
                made.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>

      <section id="langref25-dml-first-skip">
        <title><database>FROM LRU: FIRST</database> and
        <database>SKIP</database></title>

        <!--Seem unavailable in ESQL. But Dmitry writes to me: "Available since v1.0, I believe."
Checked again in gpre source (using SKIP search), and it really really really isn't there. So:-->

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.0</para>
        </formalpara>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Better alternative</title>

          <para><link
          linkend="langref25-dml-select-rows"><database>ROWS</database></link></para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>FIRST</database> limits the output of a query to the
          first so-many rows. <database>SKIP</database> will suppress the
          given number of rows before starting to return output.<tip>
              <para>In Firebird 2.0 and up, use the SQL-compliant <link
              linkend="langref25-dml-select-rows"><database>ROWS</database></link>
              syntax instead.</para>
            </tip></para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>

              <note>
                <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an
                integer literal or a query parameter, the
                <quote><literal>()</literal></quote> may be omitted.
                Subselects on the other hand require an extra pair of
                parentheses.</para>
              </note>
            </blockquote></para>
        </formalpara>

        <para><database>FIRST</database> and <database>SKIP</database> are
        both optional. When used together as in
        <quote><database>FIRST</database> <replaceable>m</replaceable>
        <database>SKIP</database> <replaceable>n</replaceable></quote>, the
        <replaceable>n</replaceable> topmost rows of the output set are
        discarded and the first <replaceable>m</replaceable> rows of the
        remainder are returned.</para>

        <para><database>SKIP</database> 0 is allowed, but of course rather
        pointless. <database>FIRST</database> 0 is allowed in version 1.5 and
        up, where it returns an empty set. In 1.0.x,
        <database>FIRST</database> 0 causes an error. Negative
        <database>SKIP</database> and/or <database>FIRST</database> values
        always result in an error.</para>

        <para>If a <database>SKIP</database> lands past the end of the
        dataset, an empty set is returned. If the number of rows in the
        dataset (or the remainder after a <database>SKIP</database>) is less
        than the value given after <database>FIRST</database>, that smaller
        number of rows is returned. These are valid results, not error
        situations.</para>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>The following query will return the first 10 names from
              the People table:</para>

              <programlisting>select first 10 id, name from People
  order by name asc</programlisting>

              <para>The following query will return everything
              <emphasis>but</emphasis> the first 10 names:</para>

              <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>

              <para>And this one returns the last 10 rows. Notice the double
              parentheses:</para>

              <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>

              <para>This query returns rows 81–100 of the People table:</para>

              <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
            </blockquote></para>
        </formalpara>

        <caution>
          <title>Two Gotchas with <database>FIRST</database> in
          subselects</title>

          <itemizedlist>
            <listitem>
              <para>This:</para>

              <blockquote>
                <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
              </blockquote>

              <para>will delete all of the rows in the table. Ouch! The
              sub-select is evaluating each 10 candidate rows for deletion,
              deleting them, slipping forward 10 more... ad infinitum, until
              there are no rows left. Beware! Or better: use the
              <database>ROWS</database> syntax, available since Firebird
              2.0.</para>
            </listitem>

            <listitem>
              <para>Queries like:</para>

              <blockquote>
                <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
              </blockquote>

              <para>won't work as expected, because the optimization performed
              by the engine transforms the <database>IN</database> predicate
              to the correlated <database>EXISTS</database> predicate shown
              below. It's obvious that in this case <database>FIRST</database>
              <replaceable>N</replaceable> doesn't make any sense:</para>

              <blockquote>
                <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
              </blockquote>

              <!--This still so with ROWS? BTW, I think this is a grave error in the optimizer!-->
            </listitem>
          </itemizedlist>
        </caution>
      </section>

      <section id="langref25-dml-groupby">
        <title><database>FROM LRU: GROUP BY</database></title>

        <formalpara>
          <title>Description</title>

          <para><database>GROUP BY</database> merges rows that have the same
          combination of values and/or <constant>NULL</constant>s in the item
          list into a single row. Any aggregate functions in the select list
          are applied to each group individually instead of to the dataset as
          a whole.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>  ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
               | <replaceable>column-alias</replaceable>
               | <replaceable>column-position</replaceable>
               | <replaceable>expression</replaceable></programlisting>

              <itemizedlist>
                <listitem>
                  <para>Only non-negative integer
                  <emphasis>literals</emphasis> will be interpreted as column
                  positions. If they are outside the range from 1 to the
                  number of columns, an error is raised. Integer values
                  resulting from expressions or parameter substitutions are
                  simply invariables and will be used as such in the grouping.
                  They will have no effect though, as their value is the same
                  for each row.</para>
                </listitem>

                <listitem>
                  <para>A <database>GROUP BY</database> item cannot be a
                  reference to an aggregate function (including one that is
                  buried inside an expression) from the same context.</para>
                </listitem>

                <listitem>
                  <para>The select list may not contain expressions that can
                  have different values within a group. To avoid this, the
                  rule of thumb is to include each non-aggregate item from the
                  select list in the <database>GROUP BY</database> list
                  (whether by copying, alias or position).</para>

                  <!--Some exceptions and variations are possible, but they could be discussed
later in notes. For instance, a GROUP BY item may be 'narrower' than the
corresponding select item (SELECT upper(ColA) GROUP BY ColA is fine, but
the reverse isn't). Also think of certain subselects, and items that don't
refer to the current context.-->
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Note</title>

          <para>If you group by a column position, the expression at that
          position is copied internally from the select list. If it concerns a
          subquery, that subquery will be executed at least twice.<!--I suppose the same goes for grouping by aliases? And not only for subqueries but also function calls? TEST USING GENERATORS--></para>
        </formalpara>

        <section id="langref25-dml-groupby-extensions">
          <title>Grouping by alias, position and expressions</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0, 1.5, 2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In addition to column names, Firebird 2 allows column
            aliases, column positions and arbitrary valid expressions as
            <database>GROUP BY</database> items.</para>
          </formalpara>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>These three queries all achieve the same result:</para>

                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by len_name</programlisting>

                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by 1</programlisting>

                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by strlen(lastname)</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>History</title>

            <para>Grouping by UDF results was added in Firebird 1. Grouping by
            column positions, <database>CASE</database> outcomes and a limited
            number of internal functions in Firebird 1.5. Firebird 2 added
            column aliases and expressions in general as valid <database>GROUP
            BY</database> items (<quote>expressions in general</quote>
            absorbing the UDF, <database>CASE</database> and internal
            functions lot).</para>
          </formalpara>
        </section>
      </section>

      <section id="langref25-dml-having-stricter">
        <title><database>FROM LRU: HAVING</database>: Stricter rules</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>See <link
          linkend="langref25-dml-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>

      <section id="langref25-dml-join">
        <title><database>FROM LRU: JOIN</database></title>

        <section id="langref25-dml-join-amb-fields">
          <title>Ambiguous field names rejected</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>InterBase 6 accepts and executes statements like the one
            below, which refers to an unqualified column name even though that
            name exists in both tables participating in the
            <database>JOIN</database>:</para>
          </formalpara>

          <blockquote>
            <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
          </blockquote>

          <para>The results of such a query are unpredictable. Firebird
          Dialect 3 returns an error if there are ambiguous field names in
          <database>JOIN</database> statements. Dialect 1 gives a warning but
          will execute the query anyway.</para>
        </section>

        <section id="langref25-dml-join-crossjoin">
          <title><database>CROSS JOIN</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2.0 and up support <database>CROSS JOIN</database>,
            which performs a full set multiplication on the tables involved.
            Previously you had to achieve this by joining on a tautology (a
            condition that is always true) or by using the comma syntax, now
            deprecated.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> CROSS JOIN <replaceable>&lt;relation&gt;</replaceable>
   ...

<replaceable>&lt;relation&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
</programlisting>

                <para><emphasis role="bold">Note:</emphasis> If you use
                <database>CROSS JOIN</database>, you can't use
                <database>ON</database>.</para>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select * from Men cross join Women
order by Men.age, Women.age

-- old syntax:
--   select * from Men join Women on 1 = 1
--   order by Men.age, Women.age

-- comma syntax:
--   select * from Men, Women
--   order by Men.age, Women.age</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-join-namedcolsjoin">
          <title>Named columns <database>JOIN</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>A named columns join is an equi-join on the columns named in
            the <database>USING</database> clause. These columns must exist in
            both relations.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> [<replaceable>&lt;join_type&gt;</replaceable>] JOIN <replaceable>&lt;relation&gt;</replaceable>
   USING (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
   ...

<replaceable>&lt;relation&gt;</replaceable>   ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
<replaceable>&lt;join_type&gt;</replaceable>  ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select *
  from books join shelves
  using (shelf, bookcase)</programlisting>

                <para>The equivalent in traditional syntax:</para>

                <programlisting>select *
  from books b join shelves s
  on b.shelf = s.shelf and b.bookcase = s.bookcase</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>The columns in the USING clause can be selected
                  without qualifier. Be aware, however, that doing so in outer
                  joins doesn't always give the same result as selecting
                  <replaceable>left</replaceable>.<replaceable>colname</replaceable>
                  or
                  <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
                  One of the latter may be <constant>NULL</constant> while the
                  other isn't; plain <replaceable>colname</replaceable> always
                  returns the non-<constant>NULL</constant> alternative in
                  such cases.</para>
                </listitem>

                <listitem>
                  <para><database>SELECT</database> * from a named columns
                  join returns each <database>USING</database> column only
                  once. In outer joins, such a column always contains the
                  non-<constant>NULL</constant> alternative except for rows
                  where the field is <constant>NULL</constant> in both
                  tables.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>

        <section id="langref25-dml-join-natural">
          <title>Natural <database>JOIN</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>A natural join is an automatic equi-join on all the columns
            that exist in both relations. If there are no common column names,
            a <link linkend="langref25-dml-join-crossjoin"><database>CROSS
            JOIN</database></link> is produced.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> NATURAL [<replaceable>&lt;join_type&gt;</replaceable>] JOIN <replaceable>&lt;relation&gt;</replaceable>
   ...

<replaceable>&lt;relation&gt;</replaceable>   ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
<replaceable>&lt;join_type&gt;</replaceable>  ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select * from Pupils natural left join Tutors</programlisting>

                <para>Assuming that the Pupils and Tutors tables have two
                field names in common: <database>TUTOR</database> and
                <database>CLASS</database>, the equivalent traditional syntax
                is:</para>

                <programlisting>select * from Pupils p left join Tutors t
  on p.tutor = t.tutor and p.class = t.class</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>Common columns can be selected from a natural join
                  without qualifier. Beware, however, that doing so in outer
                  joins doesn't always gives the same result as selecting
                  <replaceable>left</replaceable>.<replaceable>colname</replaceable>
                  or
                  <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
                  One of the latter may be <constant>NULL</constant> while the
                  other isn't; plain <replaceable>colname</replaceable> always
                  returns the non-<constant>NULL</constant> alternative in
                  such cases.</para>
                </listitem>

                <listitem>
                  <para><database>SELECT</database> * from a natural join
                  returns each common column only once. In outer joins, such a
                  column always contains the non-<constant>NULL</constant>
                  alternative except for rows where the field is
                  <constant>NULL</constant> in both tables.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>

      <section id="langref25-dml-orderby">
        <title><database>FROM LRU: ORDER BY</database></title>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
            </blockquote></para>
        </formalpara>

        <section id="langref25-dml-orderby-alias">
          <title>Order by column alias</title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2.0 and above support ordering by column
            alias.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select rdb$character_set_id as charset_id,
       rdb$collation_id as coll_id,
       rdb$collation_name as name
from rdb$collations
order by charset_id, coll_id</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-order-star-by-colpos">
          <title>Ordering by column position causes * expansion</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>If you order by column position in a
            <quote><database>SELECT</database> *</quote> query, the engine
            will now expand the * to determine the sort column(s).</para>
          </formalpara>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>The following wasn't possible in pre-2.0
                versions:</para>

                <programlisting>select * from rdb$collations
order by 3, 2</programlisting>

                <para>The following would sort the output set on
                <literal>Films.Director</literal> in previous versions. In
                Firebird 2 and up, it will sort on the second column of
                <literal>Books</literal>:</para>

                <programlisting>select Books.*, Films.Director from Books, Films
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-orderby-expr">
          <title>Ordering by expressions</title>

          <formalpara>
            <title>Added in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 1.5 introduced the possibility to use expressions
            as ordering items. Please note that expressions consisting of a
            single non-negative whole number will be interpreted as column
            positions and cause an exception if they're not in the range from
            1 to the number of columns.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select x, y, note from Pairs
order by x+y desc</programlisting>
              </blockquote></para>
          </formalpara>

          <note>
            <para>The number of function or procedure invocations resulting
            from a sort based on a UDF or stored procedure is unpredictable,
            regardless whether the ordering is specified by the expression
            itself or by the column position number.</para>
          </note>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>The number of function or procedure invocations
                  resulting from a sort based on a UDF or stored procedure is
                  unpredictable, regardless whether the ordering is specified
                  by the expression itself or by the column position
                  number.</para>
                </listitem>

                <listitem>
                  <para>Only non-negative whole number
                  <emphasis>literals</emphasis> are interpreted as column
                  positions. A whole number resulting from an expression
                  evaluation or parameter substitution is seen as an integer
                  invariable and will lead to a dummy sort, since its value is
                  the same for each row.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->

          <!--Rlsnotes 1.5 say (by Nickolay):

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice? Maybe with ARRAYs?-->
        </section>

        <section id="langref25-dml-orderby-nulls">
          <title><constant>NULL</constant>s placement</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5, 2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 1.5 has introduced the per-column <database>NULLS
            FIRST</database> and <database>NULLS LAST</database> directives to
            specify where <constant>NULL</constant>s appear in the sorted
            column. Firebird 2.0 has changed the default placement of
            <constant>NULL</constant>s.</para>
          </formalpara>

          <para>Unless overridden by <database>NULLS FIRST</database> or
          <database>NULLS LAST</database>, <constant>NULL</constant>s in
          ordered columns are placed as follows:</para>

          <itemizedlist>
            <listitem>
              <para>In Firebird 1.0 and 1.5: at the end of the sort,
              regardless whether the order is ascending or descending.</para>
            </listitem>

            <listitem>
              <para>In Firebird 2.0 and up: at the <emphasis>start</emphasis>
              of ascending orderings and at the <emphasis>end</emphasis> of
              descending orderings.</para>
            </listitem>
          </itemizedlist>

          <para>See also the table below for an overview of the different
          versions.</para>

          <table id="langref25-dml-tbl-null-placement">
            <title><constant>NULL</constant>s placement in ordered
            columns</title>

            <tgroup cols="4">
              <colspec colname="colStatement" colwidth="2*"/>

              <colspec colname="colPlac10" colwidth="1*"/>

              <colspec colname="colPlac15" colwidth="1*"/>

              <colspec colname="colPlac2" colwidth="1*"/>

              <thead>
                <row valign="top">
                  <entry morerows="1">Ordering</entry>

                  <entry align="center" nameend="colPlac2"
                  namest="colPlac10"><constant>NULL</constant>s
                  placement</entry>
                </row>

                <row valign="top">
                  <entry align="center">Firebird 1</entry>

                  <entry align="center">Firebird 1.5</entry>

                  <entry align="center">Firebird 2</entry>
                </row>
              </thead>

              <tbody>
                <row valign="top">
                  <entry>order by Field [asc]</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>

                  <entry>top</entry>
                </row>

                <row valign="top">
                  <entry>order by Field desc</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>
                </row>

                <row valign="top">
                  <entry>order by Field [asc | desc] nulls first</entry>

                  <entry>—</entry>

                  <entry>top</entry>

                  <entry>top</entry>
                </row>

                <row valign="top">
                  <entry>order by Field [asc | desc] nulls last</entry>

                  <entry>—</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <note>
            <title>Notes</title>

            <itemizedlist>
              <listitem>
                <para>Pre-existing databases may need a backup-restore cycle
                before they show the correct <constant>NULL</constant>
                ordering behaviour under Firebird 2.0 and up.</para>

                <!--CHECK! Is this always true, or only when the column is indexed?-->
              </listitem>

              <listitem>
                <para>No index will be used on columns for which a non-default
                <constant>NULLS</constant> placement is chosen. In Firebird
                1.5, that is the case with <database>NULLS FIRST</database>.
                In 2.0 and higher, with <database>NULLS LAST</database> on
                ascending and <database>NULLS FIRST</database> on descending
                sorts.</para>
              </listitem>
            </itemizedlist>
          </note>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>

                <programlisting>select * from document
  order by strlen(description) desc
  rows 10</programlisting>

                <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-orderby-stricter">
          <title>Stricter ordering rules with aggregate statements</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>See <link
            linkend="langref25-dml-aggregates-having-orderby"><citetitle>Aggregate
            statements: Stricter <database>HAVING</database> and
            <database>ORDER BY</database></citetitle></link>.</para>
          </formalpara>
        </section>
      </section>

      <section id="langref25-dml-select-plan2">
        <title><database>FROM LRU: PLAN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL, PSQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Specifies a user plan for the data retrieval, overriding the
          plan that the optimizer would have generated automatically.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <para><programlisting>PLAN <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;plan-expr&gt;</replaceable>    ::=  (<replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])
                    | <replaceable>&lt;sorted-item&gt;</replaceable>
                    | <replaceable>&lt;joined-item&gt;</replaceable>
                    | <replaceable>&lt;merged-item&gt;</replaceable>

<replaceable>&lt;sorted-item&gt;</replaceable>  ::=  SORT (<replaceable>&lt;plan-item&gt;</replaceable>)

<replaceable>&lt;joined-item&gt;</replaceable>  ::=  JOIN (<replaceable>&lt;plan-item&gt;</replaceable>, <replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])

<replaceable>&lt;merged-item&gt;</replaceable>  ::=  [SORT] MERGE (<replaceable>&lt;sorted-item&gt;</replaceable>, <replaceable>&lt;sorted-item&gt;</replaceable> [, <replaceable>&lt;sorted-item&gt;</replaceable> ...])

<replaceable>&lt;plan-item&gt;</replaceable>    ::=  <replaceable>&lt;basic-item&gt;</replaceable> | <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;basic-item&gt;</replaceable>   ::=  <replaceable>&lt;relation&gt;</replaceable>
                    {NATURAL                                 -- natural scan      (fetch in storage order)
                     | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)                   -- indexed retrieval (index to match search)
                     | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}    -- navigational scan (index for ordering)

<replaceable>&lt;relation&gt;</replaceable>     ::=  <replaceable>table</replaceable> 
                    | <replaceable>view</replaceable> [<replaceable>table</replaceable>]                           -- en een SP, CTE of derived table?

<replaceable>&lt;indexlist&gt;</replaceable>    ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]

<replaceable>table</replaceable>, <replaceable>view</replaceable>    ::=  name or alias</programlisting></para>
            </blockquote></para>
        </formalpara>

        <section id="langref25-dml-select-plan-improved">
          <title>Handling of user <database>PLAN</database>s improved</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2 has implemented the following improvements in the
            handling of user-specified
            <database>PLAN</database>s:<itemizedlist>
                <listitem>
                  <para>Plan fragments are propagated to nested levels of
                  joins, enabling manual optimization of complex outer
                  joins.</para>
                </listitem>

                <listitem>
                  <para>User-supplied plans will be checked for correctness in
                  outer joins.</para>
                </listitem>

                <listitem>
                  <para>Short-circuit optimization for user-supplied plans has
                  been added.</para>
                </listitem>

                <listitem>
                  <para>A user-specified access path can be supplied for any
                  <database>SELECT</database>-based statement or
                  clause.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>

        <section id="langref25-dml-select-plan-order-index">
          <title><database>ORDER</database> with
          <database>INDEX</database></title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>A single plan item can now contain both an
            <database>ORDER</database> and an <database>INDEX</database>
            directive (in that order).</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>plan (MyTable order ix_myfield index (ix_this, ix_that))</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-select-plan-alltables">
          <title><database>PLAN</database> must include all tables</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2 and up, a <database>PLAN</database> clause
            must handle all the tables in the query. Previous versions
            sometimes accepted incomplete plans, but this is no longer the
            case.</para>
          </formalpara>
        </section>
      </section>

      <section id="langref25-dml-select-alias-use">
        <title>FROM LRU: Relation alias makes real name unavailable</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>If you give a table or view an alias in a Firebird 2.0 or
          above statement, you <emphasis>must</emphasis> use the alias, not
          the table name, if you want to qualify fields from that
          relation.</para>
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>Correct usage:</para>

              <programlisting>select pears from Fruit</programlisting>

              <programlisting>select Fruit.pears from Fruit</programlisting>

              <programlisting>select pears from Fruit F</programlisting>

              <programlisting>select F.pears from Fruit F</programlisting>

              <para>No longer possible:</para>

              <programlisting>select Fruit.pears from Fruit F</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-select-rows">
        <title><database>FROM LRU: ROWS</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Limits the amount of rows returned by the
          <database>SELECT</database> statement to a specified number or
          range.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <para>With a single <database>SELECT</database>:</para>

              <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;columns&gt;</replaceable>  ::=  The usual output column specifications.
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>   ::=  Any expression evaluating to an integer.</programlisting>

              <para>With a <database>UNION</database>:</para>

              <programlisting>SELECT [FIRST <replaceable>p</replaceable>] [SKIP <replaceable>q</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ... [WHERE ...]
UNION [ALL | DISTINCT]
SELECT [FIRST <replaceable>r</replaceable>] [SKIP <replaceable>s</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ... [WHERE ...]
[ORDER BY ...]
ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>

        <para>With a single argument <replaceable>m</replaceable>, the first
        <replaceable>m</replaceable> rows of the dataset are returned.</para>

        <para>Points to note:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of
            rows in the dataset, the entire set is returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> = 0, an empty set is
            returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is
            raised.</para>
          </listitem>
        </itemizedlist>

        <para>With two arguments <replaceable>m</replaceable> and
        <replaceable>n</replaceable>, rows <replaceable>m</replaceable> to
        <replaceable>n</replaceable> of the dataset are returned, inclusively.
        Row numbers are 1-based.</para>

        <para>Points to note when using two arguments:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of
            rows in the dataset, an empty set is returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from
            <replaceable>m</replaceable> to the end of the set are
            returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or
            <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> =
            <replaceable>m</replaceable>-1, an empty set is returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> &lt;
            <replaceable>m</replaceable>-1, an error is raised.</para>
          </listitem>
        </itemizedlist>

        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->

        <para>The SQL-compliant <database>ROWS</database> syntax obviates the
        need for <link
        linkend="langref25-dml-first-skip"><database>FIRST</database> and
        <database>SKIP</database></link>, except in one case: a
        <database>SKIP</database> without <database>FIRST</database>, which
        returns the entire remainder of the set after skipping a given number
        of rows. (You can often <quote>fake it</quote> though, by supplying a
        second argument that you know to be bigger than the number of rows in
        the set.)</para>

        <para>You cannot use <database>ROWS</database> together with
        <database>FIRST</database> and/or <database>SKIP</database> in a
        single <database>SELECT</database> statement, but is it valid to use
        one form in the top-level statement and the other in subselects, or to
        use the two syntaxes in different subselects.</para>

        <para>When used with a <database>UNION</database>, the
        <database>ROWS</database> subclause applies to the UNION as a whole
        and must be placed after the last <database>SELECT</database>. If you
        want to limit the output of one or more individual
        <database>SELECT</database>s within the <database>UNION</database>,
        you have two options: either use
        <database>FIRST</database>/<database>SKIP</database> on those
        <database>SELECT</database> statements (probably of limited use, as
        you can't use <database>ORDER BY</database> on individual selects
        within a union), or convert them to <link
        linkend="langref25-dml-derived-tables">derived tables</link> with
        <database>ROWS</database> clauses.</para>

        <!--Dmitry's SELECT syntax in the 2.0 Rlsnotes is incorrect here, as it states that you can use ROWS on every SELECT in a UNION. Let him know!-->

        <para><database>ROWS</database> can also be used with the <link
        linkend="langref25-dml-update"><database>UPDATE</database></link> and
        <link
        linkend="langref25-dml-delete"><database>DELETE</database></link>
        statements.</para>

        <!--SKIP and FIRST can be used - and could already in 1.5 - with UNIONs and in subqueries, even though the 2.0 RlsNotes seem to suggest otherwise.-->
      </section>

      <section id="langref25-dml-union">
        <title><database>FROM LRU: UNION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL, PSQL</para>
        </formalpara>

        <section id="langref25-dml-union-in-subqueries">
          <title><database>UNION</database>s in subqueries</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para><database>UNION</database>s are now allowed in subqueries.
            This applies not only to column-level subqueries in a
            <database>SELECT</database> list, but also to subqueries in
            <database>ANY</database>|<database>SOME</database>,
            <database>ALL</database> and <database>IN</database> predicates,
            as well as the optional <database>SELECT</database> expression
            that feeds an <database>INSERT</database>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langref25-dml-union-distinct">
          <title><database>UNION DISTINCT</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>You can now use the optional <database>DISTINCT</database>
            keyword when defining a <database>UNION</database>. This will show
            duplicate rows only once instead of every time they occur in one
            of the tables. Since <database>DISTINCT</database>, being the
            opposite of <database>ALL</database>, is the default mode anyway,
            this doesn't add any new functionality.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>SELECT (...) FROM (...)
UNION [DISTINCT | ALL]
SELECT (...) FROM (...)</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select name, phone from translators
  union distinct
select name, phone from proofreaders</programlisting>

                <para>Translators who also work as proofreaders (a not
                uncommon combination) will show up only once in the result
                set, provided their phone number is the same in both tables.
                The same result would have been obtained without
                <database>DISTINCT</database>. With <database>ALL</database>,
                they would appear twice.</para>
              </blockquote></para>
          </formalpara>
        </section>
      </section>

      <section id="langref25-dml-with-lock">
        <title><database>FROM LRU: WITH LOCK</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description:</title>

          <para><database>WITH LOCK</database> provides a limited explicit
          pessimistic locking capability for cautious use in conditions where
          the affected row set is:<orderedlist numeration="loweralpha"
              spacing="compact">
              <listitem>
                <para>extremely small (ideally, a singleton),
                <emphasis>and</emphasis></para>
              </listitem>

              <listitem>
                <para>precisely controlled by the application code.</para>
              </listitem>
            </orderedlist></para>
        </formalpara>

        <caution>
          <title>This is for experts only!</title>

          <para>The need for a pessimistic lock in Firebird is very rare
          indeed and should be well understood before use of this extension is
          considered.</para>

          <para>It is essential to understand the effects of transaction
          isolation and other transaction attributes before attempting to
          implement explicit locking in your application.</para>
        </caution>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
            </blockquote></para>
        </formalpara>

        <para>If the <database>WITH LOCK</database> clause succeeds, it will
        secure a lock on the selected rows and prevent any other transaction
        from obtaining write access to any of those rows, or their dependants,
        until your transaction ends.</para>

        <para>If the <database>FOR UPDATE</database> clause is included, the
        lock will be applied to each row, one by one, as it is fetched into
        the server-side row cache. It becomes possible, then, that a lock
        which appeared to succeed when requested will nevertheless
        <emphasis>fail subsequently</emphasis>, when an attempt is made to
        fetch a row which becomes locked by another transaction.</para>

        <para><database>WITH LOCK</database> can only be used with a
        top-level, single-table <database>SELECT</database> statement. It is
        <emphasis>not</emphasis> available:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>in a subquery specification;</para>
          </listitem>

          <listitem>
            <para>for joined sets;</para>
          </listitem>

          <listitem>
            <para>with the <database>DISTINCT</database> operator, a
            <database>GROUP BY</database> clause or any other aggregating
            operation;</para>
          </listitem>

          <listitem>
            <para>with a view;</para>
          </listitem>

          <listitem>
            <para>with the output of a selectable stored procedure;</para>
          </listitem>

          <listitem>
            <para>with an external table.</para>
          </listitem>

          <!--With a UNION, in my experience-->
        </itemizedlist>

        <para>A lengthier, more in-depth discussion of <quote><database>SELECT
        ... WITH LOCK</database></quote> is included in the <link
        linkend="langref25-notes-withlock">Notes</link>. It is a must-read for
        everybody who considers using this feature.</para>
      </section>
    </section>
  </section>

  <section id="langref25-dml-update">
    <title><database>UPDATE</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Changes values in a table or in one or more tables underlying a
      view. The columns affected are specified in the <database>SET</database>
      clause; the rows affected may be limited by the
      <database>WHERE</database> and <database>ROWS</database> clauses. If
      neither <database>WHERE</database> nor <database>ROWS</database> is
      present, all the records in the table will be updated.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>UPDATE [TRANSACTION <replaceable>name</replaceable>] <replaceable>target</replaceable> [[AS] <replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>target</replaceable>       ::=  A table or updatable view
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <listitem>
                <para>The <database>TRANSACTION</database> directive is only
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>In a pure DSQL session, <database>WHERE CURRENT
                OF</database> isn't of much use, since there exists no DSQL
                statement to create a cursor.</para>
              </listitem>

              <listitem>
                <para>No column may be <database>SET</database> more than once
                in the same <database>UPDATE</database> statement.</para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When returning values into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (<quote><literal>:</literal></quote>).</para>
              </listitem>

              <listitem>
                <para>The <database>PLAN</database>, <database>ORDER
                BY</database>, <database>ROWS</database> and
                <database>RETURNING</database> clauses are not available in
                ESQL.</para>
              </listitem>
            </itemizedlist>
          </note>

          <!--Are only loose plan_items allowed, or also JOIN, SORT, MERGE ?-->
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-update-alias-use">
      <title>Using an alias</title>

      <para>If you give a table or view an alias, you
      <emphasis>must</emphasis> use the alias, not the table name, if you want
      to qualify fields from that relation.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>Correct usage:</para>

            <programlisting>update Fruit set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit set Fruit.soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set F.soort = 'pisang' where ...</programlisting>

            <para>Not possible:</para>

            <programlisting>update Fruit F set Fruit.soort = 'pisang' where ...</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-update-set">
      <title>The <database>SET</database> clause</title>

      <para>The <database>SET</database> clause specifies the values to be
      written to the affected row(s). It is a comma-separated list of
      assignments, each with a column name on the left hand side and a value
      expression on the right hand side.</para>

      <para>String literals may optionally be preceded by a character set
      name, using <firstterm>introducer syntax</firstterm>, in order to let
      the engine know how to interpret the input.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>update addresses
  set city = 'Saint Petersburg', citycode = 'PET'
  where city = 'Leningrad'</programlisting>

            <programlisting>update employees
  set salary = 2.5 * salary
  where title = 'CEO'</programlisting>

            <programlisting>update People
  set name = _ISO8859_1 'Hans-Jörg Schäfer'  -- notice the '_' prefix
  where id = 53662</programlisting>
          </blockquote></para>
      </formalpara>

      <para>It is perfectly legal to include target columns in the value
      expressions on the right hand side, providing values for themselves
      and/or other columns. If this is done, the value used on the right hand
      side will always be the <emphasis>old</emphasis> column value, even if
      an assignment has already been made to the same column earlier in the
      list. The following example illustrates this.</para>

      <para>Given table <database>TSET</database>:</para>

      <blockquote>
        <programlisting>A  B
----
1  0
2  0</programlisting>
      </blockquote>

      <para>the following statement:</para>

      <blockquote>
        <programlisting>update tset set a=5, b=a</programlisting>
      </blockquote>

      <para>will change its state to</para>

      <blockquote>
        <programlisting>A  B
----
5  1
5  2</programlisting>
      </blockquote>

      <para>Notice how the old values of <varname>a</varname> (1 and 2) are
      used for the update of <varname>b</varname>, even though
      <varname>a</varname> itself has already been assigned a new value
      (5).</para>

      <note>
        <para>This has not always been the case. In pre-2.5 versions of
        Firebird, new column values became immediately available for
        subsequent assignments in the list. This is non-standard behaviour;
        hence it has been changed.</para>

        <para>However, if the <parameter>OldSetClauseSemantics</parameter>
        parameter in <filename>firebird.conf</filename> has been set to 1,
        Firebird will continue to show the old behaviour. This parameter will
        be deprecated and removed somewhere in the future.</para>
      </note>
    </section>

    <section id="langref25-dml-update-where">
      <title>The <database>WHERE</database> clause</title>

      <para>A <database>WHERE</database> clause limits the update action to
      the rows matching the search condition, or – in ESQL and PSQL only – to
      the current row of a named cursor.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>update People set firstname = 'Boris' where lastname = 'Johnson'</programlisting>

            <programlisting>update Cities set name = :arg_name where current of Cur_Cities;  -- ESQL and PSQL only</programlisting>
          </blockquote></para>
      </formalpara>

      <para>An update using <database>WHERE CURRENT OF</database> is called a
      <firstterm>positioned update</firstterm>, because it updates the record
      at the current position. An update using
      <quote><database>WHERE</database>
      <replaceable>&lt;condition&gt;</replaceable></quote> is called a
      <firstterm>searched update</firstterm>, because the engine has to search
      for the record(s) meeting the condition.</para>
    </section>

    <section id="langref25-dml-update-orderby-rows">
      <title><database>ORDER BY</database> and
      <database>ROWS</database></title>

      <para>If at all, <database>ORDER BY</database> and
      <database>ROWS</database> only make sense when used together. However,
      they are also valid separately.</para>

      <para>With a single argument <replaceable>m</replaceable>,
      <database>ROWS</database> limits the update to the first
      <replaceable>m</replaceable> rows of the dataset defined by the table or
      view and the optional <database>WHERE</database> and <database>ORDER
      BY</database> clauses.</para>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, the update is limited to rows
      <replaceable>m</replaceable> to <replaceable>n</replaceable>
      inclusively. Row numbers are 1-based.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>-- give the 20 poorest guys a break:
update employees
  set salary = salary + 50
  order by salary asc
  rows 20</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Points to note when using <database>ROWS</database> with one
      argument:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, no rows are
          updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>Points to note when using <database>ROWS</database> with two
      arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, no rows are updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, no rows are updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
    </section>

    <section id="langref25-dml-update-returning">
      <title><database>RETURNING</database></title>

      <para>An <database>UPDATE</database> statement modifying <emphasis>at
      most one row</emphasis> may optionally include a
      <database>RETURNING</database> clause in order to return values from the
      updated row. The clause, if present, need not contain all the modified
      columns and may also contain other columns or expressions. The returned
      values reflect any changes that may have been made in
      <database>BEFORE</database> triggers, but not those in
      <database>AFTER</database> triggers.
      <database>OLD</database>.<replaceable>fieldname</replaceable> and
      <database>NEW</database>.<replaceable>fieldname</replaceable> may both
      be used in the list of columns to return; for field names not preceded
      by either of these, the new value is returned.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>update Scholars
  set firstname = 'Hugh', lastname = 'Pickering'
  where firstname = 'Henry' and lastname = 'Higgins'
  returning id, old.lastname, new.lastname</programlisting>
          </blockquote></para>
      </formalpara>

      <para>In DSQL, a statement with a <database>RETURNING</database> clause
      <emphasis role="">always</emphasis> returns exactly one row. If no
      record was actually updated, the fields in this row are all
      <constant>NULL</constant>. This behaviour may change in a later version
      of Firebird. In PSQL, if no row was updated, nothing is returned, and
      the target variables keep their existing values.</para>
    </section>

    <section id="langref25-dml-update-blob">
      <title>Updating <database>BLOB</database> columns</title>

      <para>Updating a <database>BLOB</database> column always replaces the
      entire contents. Even the <database>BLOB</database> ID, the
      <quote>handle</quote> that is stored directly in the column, is changed.
      <database>BLOB</database>s can be updated if:</para>

      <orderedlist>
        <listitem>
          <para>The client application has made special provisions for this
          operation, using the Firebird API. In this case, the modus operandi
          is application-specific and outside the scope of this manual.</para>
        </listitem>

        <listitem>
          <para>The new value is a text string of at most 32767 bytes. Please
          notice: if the value is not a string literal, beware of
          concatenations, as these may exceed the maximum length.</para>
        </listitem>

        <listitem>
          <para>The source is itself a <database>BLOB</database> column or,
          more generally, an expression that returns a
          <database>BLOB</database>.</para>
        </listitem>

        <listitem>
          <para>You use the <link
          linkend="langref25-dml-insert_cursor"><database>INSERT
          CURSOR</database></link> statement (ESQL only).</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section id="langref25-dml-update-or-insert">
    <title><database>UPDATE OR INSERT</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, PSQL</para>

      <!--ESQL ? Guess not, readme says: Scope: DSQL, PSQL-->
    </formalpara>

    <para><database>UPDATE OR INSERT</database> inserts a new record or
    updates one or more existing records. The action taken depends on the
    values provided for the columns in the <database>MATCHING</database>
    clause (or, if the latter is absent, in the primary key). If there are
    records found matching those values, they are updated. If not, a new
    record is inserted.</para>

    <para>A match only counts if all the values in the
    <database>MATCHING</database> or <database>PK</database> columns are
    equal. Matching is done with the <link
    linkend="langref25-distinct"><database>IS NOT DISTINCT</database></link>
    operator, so one <constant>NULL</constant> matches another.</para>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>UPDATE OR INSERT INTO
   {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [(<replaceable>&lt;columns&gt;</replaceable>)]
   VALUES (<replaceable>&lt;values&gt;</replaceable>)
   [MATCHING (<replaceable>&lt;columns&gt;</replaceable>)]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;columns&gt;</replaceable>      ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;values&gt;</replaceable>       ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>    ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

          <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <listitem>
                <para>If the table has no <database>PK</database>, the
                <database>MATCHING</database> clause becomes mandatory.</para>
              </listitem>

              <listitem>
                <para>In the <database>MATCHING</database> list as well as in
                the update/insert column list, each column name may occur only
                once.</para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When values are returned into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (<quote><literal>:</literal></quote>).</para>
              </listitem>
            </itemizedlist>
          </note>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Example</title>

      <para><blockquote>
          <programlisting>update or insert into Cows (Name, Number, Location)
  values ('Suzy Creamcheese', 3278823, 'Green Pastures')
  matching (Number)
  returning rec_id into :id;</programlisting>
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-update-or-insert-returning">
      <title>The <database>RETURNING</database> clause</title>

      <para>The optional <database>RETURNING</database> clause, if present,
      need not contain all the columns mentioned in the statement and may also
      contain other columns or expressions. The returned values reflect any
      changes that may have been made in <database>BEFORE</database> triggers,
      but not those in <database>AFTER</database> triggers.
      <database>OLD</database>.<replaceable>fieldname</replaceable> and
      <database>NEW</database>.<replaceable>fieldname</replaceable> may both
      be used in the list of columns to return; for field names not preceded
      by either of these, the new value is returned.</para>

      <para>In DSQL, a statement with a <database>RETURNING</database> clause
      <emphasis role="">always</emphasis> returns exactly one row. If a
      <database>RETURNING</database> clause is present and more than one
      matching record is found, an error is raised. This behaviour may change
      in a later version of Firebird.</para>
    </section>
  </section>
</chapter>
