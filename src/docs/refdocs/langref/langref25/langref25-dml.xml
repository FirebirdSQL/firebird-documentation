<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="langref25-dml">
  <title>DML statements</title>

  <section id="langref25-dml-delete">
    <title><database>DELETE</database></title>

    <!--DELETE is KLAAR, behalve voor wat "puntjes op de i"-vraagjes in de comments!-->

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para><database>DELETE</database> removes rows from a database table or
      from one or more tables underlying a view. <database>WHERE</database>
      and <database>ROWS</database> clauses can limit the number of rows
      deleted. If neither <database>WHERE</database> nor
      <database>ROWS</database> is present, <database>DELETE</database>
      removes all the rows in the relation.</para>

      <!--FIND OUT: Can you delete from a CTE? And from a derived table?-->
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>DELETE
   [TRANSACTION <replaceable>name</replaceable>]
   FROM {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <listitem>
                <para>The <database>TRANSACTION</database> directive is only
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>In a pure DSQL session, <database>WHERE CURRENT
                OF</database> isn't of much use, since there exists no DSQL
                statement to create a cursor.</para>
              </listitem>

              <listitem>
                <para>The <database>PLAN</database>, <database>ORDER
                BY</database> and <database>ROWS</database> clauses are not
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>The <database>RETURNING</database> clause is not
                available in ESQL.<!--Sure about that ?--></para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When returning values into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (write <database>NEW</database>, not
                <database>:NEW</database>).</para>
              </listitem>
            </itemizedlist>
          </note>

          <!--Are only 'loose' plan_items allowed, or also JOIN, SORT, MERGE ?-->
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-delete-alias-use">
      <title>Aliases</title>

      <formalpara>
        <title>Description</title>

        <para>An alias can represent a relation throughout the statement.
        Attention: the alias obscures the formal relation name. Once declared,
        you must use either the alias or nothing to qualify field names, as
        the examples show.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>Supported usage:</para>

            <programlisting>delete from Cities where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities where Cities.name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where C.name starting 'Alex'</programlisting>

            <para>Not possible:</para>

            <programlisting>delete from Cities C where Cities.name starting 'Alex'</programlisting>

            <!--TODO: an example where the alias is meaningful (nulti-table)-->
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-transaction">
      <title><database>TRANSACTION</database></title>

      <formalpara>
        <title>Available in</title>

        <para>ESQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The optional <database>TRANSACTION</database> clause specifies
        under which active transaction the statement should be
        executed.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>delete transaction tr_cleanup from Buses where date_endlife is not null</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-where">
      <title><database>WHERE</database></title>

      <formalpara>
        <title>Description</title>

        <para>A <database>WHERE</database> clause limits the deletion to the
        rows matching the search condition, or – in ESQL and PSQL only – to
        the current row of a named cursor.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from People where firstname &lt;&gt; 'Boris' and lastname &lt;&gt; 'Johnson'</programlisting>

            <programlisting>delete from Cities where current of Cur_Cities;  -- ESQL and PSQL only</programlisting>
          </blockquote></para>
      </formalpara>

      <para>A delete using <database>WHERE CURRENT OF</database> is called a
      <firstterm>positioned delete</firstterm>, because it deletes the record
      at the current position. A delete using
      <quote><database>WHERE</database>
      <replaceable>&lt;condition&gt;</replaceable></quote> is called a
      <firstterm>searched delete</firstterm>, because the engine has to search
      for the record(s) meeting the condition.</para>
    </section>

    <section id="langref25-dml-delete-plan">
      <title><database>PLAN</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>A <database>PLAN</database> clause allows the user to optimize
        the operation manually.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>delete from Submissions
  where date_entered &lt; '1-Jan-2002'
  plan (Submissions index ix_subm_date)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-orderby">
      <title><database>ORDER BY</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The <database>ORDER BY</database> clause orders the set before
        the actual deletion takes place. It only makes sense in combination
        with <database>ROWS</database>, but is also valid without it.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from Purchases order by date rows 1           -- deletes oldest purchase</programlisting>

            <programlisting>delete from Sales order by custno desc rows 1 to 10  -- deletes from highest custno(s)</programlisting>

            <programlisting>delete from Sales order by custno desc  -- deletes all sales, <database>ORDER BY</database> clause pointless</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-rows">
      <title><database>ROWS</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Limits the amount of rows deleted to a specified number or
        range.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
          </blockquote></para>
      </formalpara>

      <para>With a single argument <replaceable>m</replaceable>, the deletion
      is limited to the first <replaceable>m</replaceable> rows of the dataset
      defined by the table or view and the optional <database>WHERE</database>
      and <database>ORDER BY</database> clauses.</para>

      <para>Points to note:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, no rows are
          deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, the deletion is limited to rows
      <replaceable>m</replaceable> to <replaceable>n</replaceable>
      inclusively. Row numbers are 1-based.</para>

      <para>Points to note when using two arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, no rows are deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, no rows are deleted.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from popgroups order by name desc rows 1  -- will probably delete ZZ Top</programlisting>

            <programlisting>delete from popgroups order by formed rows 5     -- deletes 5 oldest groups</programlisting>

            <programlisting>delete from popgroups rows 5 to 12      -- no ordering, may delete any 8 groups</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-delete-returning">
      <title><database>RETURNING</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>A <database>DELETE</database> statement removing <emphasis>at
        most one row</emphasis> may optionally include a
        <database>RETURNING</database> clause in order to return values from
        the deleted row. The clause, if present, need not contain all the
        relation's columns and may also contain other columns or expressions.
        When returning into the <database>NEW</database> context variable
        within a trigger, the preceding colon must be omitted.</para>

        <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>delete from Scholars
  where firstname = 'Henry' and lastname = 'Higgins'
  returning lastname, fullname, id</programlisting>

            <programlisting>delete from Dumbbells
  order by iq desc
  rows 1
  returning lastname, iq into :lname, :iq;</programlisting>

            <programlisting>delete from TempSales ts
  where ts.id = tempid
  returning ts.qty into new.qty;  -- <emphasis>not</emphasis> <quote>:new.qty</quote></programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>In DSQL, a statement with a <database>RETURNING</database>
              clause <emphasis role="">always</emphasis> returns exactly one
              row. If no record was actually deleted, the fields in this row
              are all <constant>NULL</constant>. This behaviour may change in
              a later version of Firebird.</para>
            </listitem>

            <listitem>
              <para>In PSQL, if no row was deleted, nothing is returned, and
              the target variables keep their existing values.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
  </section>

  <section id="langref25-dml-execblock">
    <title><database>EXECUTE BLOCK</database></title>

    <!--EXECUTE BLOCK is KLAAR!-->

    <formalpara>
      <title>Available in</title>

      <para>DSQL</para>

      <!--ESQL: no-->
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Executes a block of PSQL code as if it were a stored procedure,
      optionally with input and output parameters and variable declarations.
      This allows the user to perform <quote>on-the-fly</quote> PSQL within a
      DSQL context.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparams&gt;</replaceable>         ::=  <replaceable>&lt;param_decl&gt;</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable> ]
<replaceable>&lt;outparams&gt;</replaceable>        ::=  <replaceable>&lt;param_decl&gt;</replaceable>     [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;param_decl&gt;</replaceable>       ::=  <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
<replaceable>&lt;type&gt;</replaceable>             ::=  <replaceable>sql_datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>
<replaceable>&lt;declarations&gt;</replaceable>     ::=  See <link
              linkend="langref25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax
<replaceable>&lt;PSQL statements&gt;</replaceable>  ::=  See the <link
              linkend="langref25-psql"><citetitle>PSQL</citetitle></link> chapter</programlisting>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Examples</title>

      <para><blockquote>
          <para>This example injects the numbers 0 through 127 and their
          corresponding ASCII characters into the table
          <database>ASCIITABLE</database>:</para>

          <programlisting>execute block
as
declare i int = 0;
begin
  while (i &lt; 128) do
  begin
    insert into AsciiTable values (:i, ascii_char(:i));
    i = i + 1;
  end
end</programlisting>
        </blockquote><blockquote>
          <para>The next example calculates the geometric mean of two numbers
          and returns it to the user:</para>

          <programlisting>execute block (x double precision = ?, y double precision = ?)
returns (gmean double precision)
as
begin
  gmean = sqrt(x*y);
  suspend;
end</programlisting>

          <para>Because this block has input parameters, it has to be prepared
          first. Then the parameters can be set and the block executed. It
          depends on the client software how this must be done and even if it
          is possible at all – see the notes below.</para>

          <para>Our last example takes two integer values,
          <varname>smallest</varname> and <varname>largest</varname>. For all
          the numbers in the range <varname>smallest</varname> ..
          <varname>largest</varname>, the block outputs the number itself, its
          square, its cube and its fourth power.</para>

          <programlisting>execute block (smallest int = ?, largest int = ?)
returns (number int, square bigint, cube bigint, fourth bigint)
as
begin
  number = smallest;
  while (number &lt;= largest) do
  begin
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    suspend;
    number = number + 1;
  end
end</programlisting>

          <para>Again, it depends on the client software if and how you can
          set the parameter values.</para>
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-execblock-params">
      <title>Input and output parameters</title>

      <para>Executing a block without input parameters should be possible with
      every Firebird client that allows the user to enter his or her own DSQL
      statements. If there are input parameters, things get trickier: these
      parameters must get their values after the statement is prepared but
      before it is executed. This requires special provisions, which not every
      client application offers. (Firebird's own
      <application>isql</application>, for one, doesn't.)</para>

      <para>The server only accepts question marks
      (<quote><literal>?</literal></quote>) as placeholders for the input
      values, not <quote><literal>:a</literal></quote>,
      <quote><literal>:MyParam</literal></quote> etc., or literal values.
      Client software may support the <quote><literal>:xxx</literal></quote>
      form though, and will preprocess it before sending it to the
      server.</para>

      <para>If the block has output parameters, you <emphasis>must</emphasis>
      use <database>SUSPEND</database> or nothing will be returned.</para>

      <para>Output is always returned in the form of a result set, just as
      with a <database>SELECT</database> statement. You can't use
      <database>RETURNING_VALUES</database> or execute the block
      <database>INTO</database> some variables, even if there is only one
      result row.</para>

      <para>For more information about parameter and variable declarations,
      [<database>TYPE OF</database>] <replaceable>domain</replaceable>,
      <database>TYPE OF COLUMN</database> etc., consult the chapter on <link
      linkend="langref25-psql">Procedural SQL</link>, in particular <link
      linkend="langref25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>.</para>
    </section>

    <section id="langref25-dml-execblock-terms">
      <title>Statement terminators</title>

      <para>Some clients, especially those allowing the user to submit several
      statements at once, may require you to surround the <database>EXECUTE
      BLOCK</database> statement with <database>SET TERM</database> lines,
      like this:</para>

      <programlisting>set term #;
execute block (...)
as
begin
  statement1;
  statement2;
end
#
set term ;#</programlisting>

      <para>As an example, in Firebird's <application>isql</application>
      client you must set the terminator to something other than
      <quote><literal>;</literal></quote> before you type in the
      <database>EXECUTE BLOCK</database> statement. If you don't,
      <application>isql</application> will try to execute the part you have
      typed so far as soon as you hit Enter after a line with a
      semicolon.</para>
    </section>
  </section>

  <section id="langref25-dml-execproc">
    <title><database>EXECUTE PROCEDURE</database></title>

    <!--EXECUTE BLOCK is KLAAR, behalve voor de vraagjes in de comments.-->

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Executes a stored procedure (SP), optionally taking input
      parameters and/or returning output values.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <!--Both Borland LangRef and IBPhoenix LangRef say that TRANSACTION clause comes before proc name!
If this is correct, change LangRef Update(s) as well!-->

          <programlisting>EXECUTE PROCEDURE
   [TRANSACTION <replaceable>transaction</replaceable>]
   <replaceable>procname</replaceable>
   [<replaceable>&lt;in_item&gt;</replaceable> [, <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>   ::=  <replaceable>&lt;inparam&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable>  ::=  <replaceable>&lt;outvar&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;inparam&gt;</replaceable>   ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>    ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>   ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>

          <note>
            <title>Notes</title>

            <itemizedlist>
              <listitem>
                <para>In ESQL, input parameters must be literals or host
                language variables. For output parameters, host variables must
                be specified in the <database>RETURNING_VALUES</database>
                clause. <constant>NULL</constant> indicators must be host
                language variables of type integer, with less than zero
                indicating <constant>NULL</constant> and zero or greater
                indicating not <constant>NULL</constant> (which means that a
                proper value is present in the corresponding
                parameter).</para>
              </listitem>

              <listitem>
                <para>In PSQL, input parameters may be any expression that
                resolves to the expected type. For output parameters, local
                variables must be specified in the
                <database>RETURNING_VALUES</database> clause.</para>
              </listitem>

              <listitem>
                <para>In DSQL, input parameters may be any expression that
                resolves to the expected type. The handling of output
                parameters depends on the client software.</para>
              </listitem>

              <listitem>
                <para>In PSQL and DSQL, <constant>NULL</constant> indicators
                are neither valid nor necessary. <constant>NULL</constant>s
                are passed via the input/output parameters themselves.</para>
              </listitem>

              <listitem>
                <para><database>TRANSACTION</database> clauses are not
                supported in PSQL.</para>

                <!--And in DSQL they are? That would surprise me. Find out!-->
              </listitem>

              <listitem>
                <para>In ESQL, variable names used as parameters or outvars
                must be preceded by a colon (<quote>:</quote>). In PSQL the
                colon is generally optional, but forbidden for the trigger
                context variables <database>OLD</database> and
                <database>NEW</database>.</para>
              </listitem>
            </itemizedlist>
          </note>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Examples</title>

      <para><blockquote>
          <para>In PSQL (with optional colons):</para>

          <programlisting>execute procedure MakeFullName
  :FirstName, :MiddleName, :LastName
  returning_values :FullName;</programlisting>

          <para>The same call in ESQL (with obligatory colons):</para>

          <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :MiddleName, :LastName
    returning_values :FullName;</programlisting>

          <para>...and in Firebird's command-line utility
          <application>isql</application> (with literal parameters):</para>

          <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>

          <para><emphasis role="bold">Note:</emphasis> In isql, don't use
          <database>RETURNING_VALUES</database>. Any output values are shown
          automatically.</para>

          <para>Finally, a PSQL example with expression parameters:</para>

          <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, MiddleName, upper(LastName)
  returning_values FullName;</programlisting>
        </blockquote></para>
    </formalpara>
  </section>

  <section id="langref25-dml-insert">
    <title><database>INSERT</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Adds rows to a database table or to one or more tables underlying
      a view. If the field values are given in a <database>VALUES</database>
      clause, exactly one row is inserted. The values may also be provided by
      a <database>SELECT</database> statement, in which case zero to many rows
      may be inserted. With the <database>DEFAULT VALUES</database> clause, no
      values are provided at all and exactly one row is inserted.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>INSERT [TRANSACTION <replaceable>name</replaceable>]
   INTO {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
   {DEFAULT VALUES | [(<replaceable>&lt;column_list&gt;</replaceable>)] <replaceable>&lt;value_source&gt;</replaceable>}
   [RETURNING <replaceable>&lt;value_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;column_list&gt;</replaceable>   ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;value_source&gt;</replaceable>  ::=  VALUES (<replaceable>&lt;value_list&gt;</replaceable>) | <replaceable>&lt;select_stmt&gt;</replaceable>
<replaceable>&lt;value_list&gt;</replaceable>    ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>     ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
<replaceable>&lt;select_stmt&gt;</replaceable>   ::=  a <database>SELECT</database> or UNION whose result set fits the target columns</programlisting>

          <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <!--I suppose DEFAULT VALUES not available in ESQL. Check.-->

              <listitem>
                <para>The <database>TRANSACTION</database> directive is only
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>The <database>RETURNING</database> clause is not
                available in ESQL.<!--still not in 2.1 ?--></para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When returning values into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (<quote><literal>:</literal></quote>).</para>
              </listitem>

              <listitem>
                <para>No column may appear more than once in the column
                list.</para>
              </listitem>
            </itemizedlist>
          </note>
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-insert-values">
      <title><database>INSERT</database> ...
      <database>VALUES</database></title>

      <para>The <database>VALUES</database> list must provide a value for
      every column in the column list, in the same order and of the correct
      type. If the column list is absent, values must be provided for every
      column in the table or view (computed columns excluded).</para>

      <para>String literals may optionally be preceded by a character set
      name, using <firstterm>introducer syntax</firstterm>, in order to let
      the engine know how to interpret the input.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>insert into cars (make, model, year)
  values ('Ford', 'T', 1908)</programlisting>

            <programlisting>insert into cars
  values ('Ford', 'T', 1908, 'USA', 850)

/* assuming that the columns of table Cars are: make, model, year, country, price */</programlisting>

            <programlisting>insert into People
  values (_ISO8859_1 'Hans-Jörg Schäfer')  -- notice the '_' prefix</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-insert-select">
      <title><database>INSERT</database> ...
      <database>SELECT</database></title>

      <para>Here, the output columns of the SELECT statement must provide a
      value for every target column in the column list, in the same order and
      of the correct type. If the column list is absent, values must be
      provided for every column in the table or view (computed columns
      excluded).</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>insert into cars (make, model, year)
  select (make, model, year) from new_cars</programlisting>

            <programlisting>insert into cars
  select * from new_cars

/* assuming that table New_cars has the exact same columns as table Cars */</programlisting>

            <programlisting>insert into Members (number, name)
  select number, name from NewMembers where Accepted = 1
    union
  select number, name from SuspendedMembers where Vindicated = 1</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Of course, the column names in the source table need not be the
      same as those in the target table. Any type of
      <database>SELECT</database> statement is permitted, as long as its
      output columns exactly match the insert columns in number, order and
      type. Types need not be exactly the same, but they must be
      assignment-compatible.</para>
    </section>

    <section id="langref25-dml-insert-defaults">
      <title><database>INSERT</database> ... <database>DEFAULT
      VALUES</database></title>

      <!--Available in ESQL?-->

      <para>The <database>DEFAULT VALUES</database> clause allows insertion of
      a record without providing any values at all, neither directly nor from
      a <database>SELECT</database> statement. This is only possible if every
      <database>NOT NULL</database> or <database>CHECK</database>ed column in
      the table either has a valid default declared or gets such a value from
      a <database>BEFORE INSERT</database> trigger. Furthermore, triggers
      providing required field values must not depend on the presence of input
      values.</para>

      <!--About CHECK constraints: they let NULL pass, so perhaps the statement above is incorrect here.-->

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>insert into journal default values
  returning entry_id</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-insert-returning">
      <title>The <database>RETURNING</database> clause</title>

      <para>An <database>INSERT</database> statement adding <emphasis>at most
      one row</emphasis> may optionally include a
      <database>RETURNING</database> clause in order to return values from the
      inserted row. The clause, if present, need not contain all of the insert
      columns and may also contain other columns or expressions. The returned
      values reflect any changes that may have been made in
      <database>BEFORE</database> triggers, but not those in
      <database>AFTER</database> triggers.</para>

      <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>insert into Scholars (firstname, lastname, address, phone, email)
  values ('Henry', 'Higgins', '27A Wimpole Street', '3231212', null)
  returning lastname, fullname, id</programlisting>

            <programlisting>insert into Dumbbells (firstname, lastname, iq)
  select fname, lname, iq from Friends order by iq rows 1
  returning id, firstname, iq into :id, :fname, :iq;</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para><database>RETURNING</database> is only supported for
              <database>VALUES</database> inserts and singleton
              <database>SELECT</database> inserts.</para>

              <!--Test if it also works with DEFAULT VALUES-->
            </listitem>

            <listitem>
              <para>In DSQL, a statement with a <database>RETURNING</database>
              clause <emphasis role="">always</emphasis> returns exactly one
              row. If no record was actually inserted, the fields in this row
              are all <constant>NULL</constant>. This behaviour may change in
              a later version of Firebird. In PSQL, if no row was inserted,
              nothing is returned, and the target variables keep their
              existing values.</para>
            </listitem>

            <listitem>
              <para>The <database>RETURNING</database> clause is not available
              in ESQL.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langref25-dml-insert-blobs">
      <title>Inserting into <database>BLOB</database> columns</title>

      <para>Inserting into <database>BLOB</database> columns is only possible
      under the following circumstances:</para>

      <orderedlist>
        <listitem>
          <para>The client application has made special provisions for such
          inserts, using the Firebird API. In this case, the modus operandi is
          application-specific and outside the scope of this manual.</para>
        </listitem>

        <listitem>
          <para>The value inserted is a text string of at most 32767 bytes.
          Please notice: if the value is not a string literal, beware of
          concatenations, as these may exceed the maximum length.</para>
        </listitem>

        <listitem>
          <para>You are using the <quote><database>INSERT</database> ...
          <database>SELECT</database></quote> form and one or more columns in
          the result set are <database>BLOB</database>s.</para>
        </listitem>

        <listitem>
          <para>You use the <link
          linkend="langref25-dml-insert_cursor"><database>INSERT
          CURSOR</database></link> statement (ESQL only).</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section id="langref25-dml-insert_cursor">
    <title><database>INSERT CURSOR</database></title>

    <formalpara>
      <title>Available in</title>

      <para>ESQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>In Embedded SQL only, you can insert data, in segment-sized
      chunks, into a <database>BLOB</database> through a special
      <database>BLOB</database> cursor. As you can only write one segment at a
      time, this is usually done in a (host language) loop.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>INSERT CURSOR <replaceable>blobcursor</replaceable> VALUES (:<replaceable>buf</replaceable> [INDICATOR] :size)

<replaceable>blobcursor</replaceable>  ::=  an opened <database>BLOB</database> insert cursor
<replaceable>buf</replaceable>         ::=  host variable containing the data segment
<replaceable>size</replaceable>        ::=  data size in bytes; must be less than or equal to the segment length</programlisting>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Example</title>

      <para><blockquote>
          <programlisting>exec sql
  insert cursor cur_jpeg values (:imgbuf indicator :seglen);</programlisting>
        </blockquote></para>
    </formalpara>

    <para>Please notice that, unlike <link
    linkend="langref25-dml-insert"><database>INSERT</database></link>,
    <database>INSERT CURSOR</database> does not write anything to the table
    itself. The segments are written to a <database>BLOB</database> structure
    which, at that time, <quote>floats</quote> freely in the database,
    unconnected to any other object.</para>

    <para>After inserting all the segments in this manner, you must close the
    <database>BLOB</database> cursor and perform a regular
    <database>INSERT</database> statement to insert the
    <database>BLOB</database> ID (and possibly other fields) into the
    table.</para>

    <para>Updating <database>BLOB</database> fields is done in the same way,
    except that you finalize the entire operation by issuing a regular
    <database>UPDATE</database> statement instead of an
    <database>INSERT</database> statement.</para>

    <para>A complete discussion of ESQL statements is outside the scope of
    this document. For more information about ESQL, please consult the
    <citetitle>InterBase 6 Embedded SQL Guide</citetitle> (google for
    <filename>60EmbedSQL.zip</filename>).</para>
  </section>

  <section id="langref25-dml-merge">
    <title><database>MERGE</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, PSQL<!--ESQL... guess not--></para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Merges data into a table or updatable view. The source may a
      table, view or <quote>anything you can <database>SELECT</database>
      from</quote> in general. Each source record will be used to update one
      or more target records, insert a new record in the target table, or
      neither. The action taken depends on the provided condition and the
      <database>WHEN</database> clause(s). The condition will typically
      contain a comparison of fields in the source and target
      relations.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>MERGE INTO <replaceable>target</replaceable> [[AS] <replaceable>target-alias</replaceable>]
   USING <replaceable>source</replaceable> [[AS] <replaceable>source-alias</replaceable>]
   ON <replaceable>condition</replaceable>
   WHEN MATCHED THEN UPDATE SET <replaceable>colname</replaceable> = <replaceable>value</replaceable> [, <replaceable>colname</replaceable> = <replaceable>value</replaceable> ...]
   WHEN NOT MATCHED THEN INSERT [(<replaceable>&lt;columns&gt;</replaceable>)] VALUES (<replaceable>&lt;values&gt;</replaceable>)

<replaceable>target</replaceable>     ::=  a table or updatable view
<replaceable>source</replaceable>     ::=  a table, GTT, view, selectable SP, derived table or CTE
<replaceable>&lt;columns&gt;</replaceable>  ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;values&gt;</replaceable>   ::=  <replaceable>value</replaceable>   [, <replaceable>value</replaceable>   ...]

<emphasis role="bold">Note:</emphasis> It is allowed to provide only one of the WHEN clauses</programlisting>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Examples</title>

      <para><blockquote>
          <programlisting>merge into books b
  using purchases p
  on p.title = b.title and p.type = 'bk'
  when matched then
    update set b.desc = b.desc || '; ' || p.desc
  when not matched then
    insert (title, desc, bought) values (p.title, p.desc, p.bought)</programlisting>

          <programlisting>merge into customers c
  using (select * from customers_delta where id &gt; 10) cd
  on (c.id = cd.id)
  when matched then update set name = cd.name
  when not matched then insert (id, name) values (cd.id, cd.name)</programlisting>

          <!--Second example provided by Adriano!-->
        </blockquote></para>
    </formalpara>

    <note>
      <para><database>WHEN NOT MATCHED</database> should be seen from the
      point of view of the <emphasis>source</emphasis> (the relation in the
      <database>USING</database> clause). That is: if a source record doesn't
      have a match in the target table, the <database>INSERT</database> clause
      is executed. Conversely, records in the target table without a matching
      source record don't cause anything to happen.</para>
    </note>

    <warning>
      <para>If the <database>WHEN MATCHED</database> clause is present and
      multiple source records match the same record(s) in the target table,
      the <database>UPDATE</database> clause is executed for all the matching
      source records, each update overwriting the previous one. This is
      non-standard behaviour: SQL-2003 specifies that an exception must be
      raised in such cases.<!--http://tracker.firebirdsql.org/browse/CORE-2274--></para>
    </warning>
  </section>

  <section id="langref25-dml-select">
    <title><database>SELECT</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <para>The <database>SELECT</database> statement retrieves data from the
    database and hands them to the application or the enclosing SQL statement.
    Data are returned in zero or more <firstterm>rows</firstterm>, each
    containing one or more <firstterm>columns</firstterm> or
    <firstterm>fields</firstterm>. The total of rows returned is the
    <firstterm>result set</firstterm> of the statement.</para>

    <formalpara>
      <title>Global syntax</title>

      <para><blockquote>
          <programlisting>SELECT
   [TRANSACTION <replaceable>name</replaceable>]
   [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
   [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>
   [INTO <replaceable>&lt;host-varlist&gt;</replaceable>]
   FROM <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>]
   [<replaceable>&lt;joins&gt;</replaceable>]
   [WHERE <replaceable>&lt;conditions&gt;</replaceable>]
   [GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>]
   [HAVING <replaceable>&lt;aggregate-conditions&gt;</replaceable>]
   [UNION [DISTINCT | ALL] <replaceable>&lt;other-select&gt;</replaceable>]
   [PLAN <replaceable>&lt;plan-items&gt;</replaceable>]
   [ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>]
   [ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]
   [FOR UPDATE [OF <replaceable>&lt;columns&gt;</replaceable>]]
   [WITH LOCK]
   [INTO <replaceable>&lt;PSQL-varlist&gt;</replaceable>]</programlisting>
        </blockquote></para>
    </formalpara>

    <para>The only mandatory parts of the <database>SELECT</database>
    statement are:</para>

    <itemizedlist>
      <listitem>
        <para>The SELECT keyword, followed by a columns list. This part
        specifies <emphasis>what</emphasis> you want to retrieve.</para>
      </listitem>

      <listitem>
        <para>The <database>FROM</database> keyword, followed by a selectable
        object. This tells the engine <emphasis>where</emphasis> you want to
        get it <emphasis>from</emphasis>.</para>
      </listitem>
    </itemizedlist>

    <para>In its most basic form, <database>SELECT</database> retrieves a
    number of columns from a single table or view, like this:</para>

    <blockquote>
      <programlisting>select id, name, address
  from contacts</programlisting>
    </blockquote>

    <para>Or, to retrieve all the columns:</para>

    <blockquote>
      <programlisting>select * from sales</programlisting>
    </blockquote>

    <para>In practice, the rows retrieved are often limited by a
    <database>WHERE</database> clause. The result set may be sorted by an
    <database>ORDER BY</database> clause, and <database>FIRST</database>,
    <database>SKIP</database> or <database>ROWS</database> may further limit
    the number of output rows. The column list may contain all kinds of
    expressions instead of just column names, and the source need not be a
    table or view: it may also be a derived table, a common table expression
    (CTE) or a selectable stored procedure (SP). Multiple sources may be
    combined in a <database>JOIN</database>, and multiple result sets may be
    combined in a <database>UNION</database>.</para>

    <para>The following sections discuss the possible
    <database>SELECT</database> subclauses and their usage.</para>

    <section id="langref25-dml-select-transaction">
      <title>The <database>TRANSACTION</database> directive</title>

      <formalpara>
        <title>Available in</title>

        <para>ESQL</para>
      </formalpara>

      <para>This ESQL-only directive tells the engine to execute the statement
      under the specified transaction, which must have been previously
      declared and opened, e.g.:</para>

      <blockquote>
        <programlisting>select transaction tr_getsales
  partno, desc, price, amount
  from v_sales
  where custno = 101</programlisting>
      </blockquote>
    </section>

    <section id="langref25-dml-select-first-skip-rows">
      <title><database>FIRST</database>, <database>SKIP</database> and
      <database>ROWS</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
   FROM ...
   ...

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  <replaceable>integer-literal</replaceable> | <replaceable>query-parameter</replaceable> | (<replaceable>integer-expression</replaceable>)</programlisting>

            <para>or</para>

            <programlisting>SELECT
   ...
   FROM ...
   ...
   ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]

<replaceable>m</replaceable>, <replaceable>n</replaceable>  ::=  <replaceable>integer-expression</replaceable></programlisting>

            <para><emphasis>Please notice:</emphasis>
            <database>FIRST</database> and <database>SKIP</database> are
            Firebird-specific, non-SQL-compliant keywords. You are adviced to
            use the <database>ROWS</database> syntax wherever possible.</para>
          </blockquote></para>
      </formalpara>

      <para><database>FIRST</database> limits the output of a query to the
      first so-many rows. <database>SKIP</database> will suppress the given
      number of rows before starting to return output.</para>

      <para><database>FIRST</database> and <database>SKIP</database> are both
      optional. When used together as in <quote><database>FIRST</database>
      <replaceable>m</replaceable> <database>SKIP</database>
      <replaceable>n</replaceable></quote>, the <replaceable>n</replaceable>
      topmost rows of the output set are discarded and the first
      <replaceable>m</replaceable> rows of the remainder are returned.</para>

      <para><database>SKIP</database> 0 is allowed, but of course rather
      pointless. <database>FIRST</database> 0 is also allowed and returns an
      empty set. Negative <database>SKIP</database> and/or
      <database>FIRST</database> values result in an error.</para>

      <para>If a <database>SKIP</database> lands past the end of the dataset,
      an empty set is returned. If the number of rows in the dataset (or the
      remainder after a <database>SKIP</database>) is less than the value
      given after <database>FIRST</database>, that smaller number of rows is
      returned. These are valid results, not error conditions.</para>

      <para>Any argument to <database>FIRST</database> and
      <database>SKIP</database> that is not an integer literal or an SQL
      parameter must be enclosed in parentheses. This implies that a subselect
      must be enclosed in <emphasis>two</emphasis> pairs of
      parentheses.</para>

      <bridgehead>Examples</bridgehead>

      <para>The following query will return the first 10 names from the People
      table:</para>

      <blockquote>
        <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>The following query will return everything
      <emphasis>but</emphasis> the first 10 names:</para>

      <blockquote>
        <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>And this one returns the last 10 rows. Notice the double
      parentheses:</para>

      <blockquote>
        <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>This query returns rows 81–100 of the People table:</para>

      <blockquote>
        <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>As said, <database>FIRST</database> and <database>SKIP</database>
      are not standard SQL. In new code, it's better to use the
      standards-compliant <database>ROWS</database> keyword.</para>

      <para>Contrary to <database>FIRST</database> and
      <database>SKIP</database>, <database>ROWS</database> accepts any kind of
      integer expression as argument without parentheses. (Of course,
      parentheses may be necessary <emphasis>within</emphasis> the expression,
      and a subselect still needs to be parenthesized.)</para>

      <para>With a single argument <replaceable>m</replaceable>,
      <database>ROWS</database> returns the first <replaceable>m</replaceable>
      rows of the dataset.</para>

      <para>Points to note:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, an empty set is
          returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, rows <replaceable>m</replaceable> to
      <replaceable>n</replaceable> of the dataset are returned, inclusively.
      Row numbers are 1-based.</para>

      <para>Points to note when using two arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, an empty set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, an empty set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->

      <para>The SQL-compliant <database>ROWS</database> syntax obviates the
      need for <database>FIRST</database> and <database>SKIP</database>,
      except in one case: a <database>SKIP</database> without
      <database>FIRST</database>, which returns the entire remainder of the
      set after skipping a given number of rows. (Well, this is not entirely
      true. You can supply a second argument that you know is bigger than the
      number of rows in the set, or request <database>COUNT</database>(*) with
      a subselect. But <database>SKIP</database> is simpler and clearer
      here.)</para>

      <para>You cannot use <database>ROWS</database> together with
      <database>FIRST</database> and/or <database>SKIP</database> in a single
      <database>SELECT</database> statement, but you can use one form in the
      top-level statement and the other in subselects, or use the two syntaxes
      in different subselects.</para>

      <para>When used with a <database>UNION</database>, the
      <database>ROWS</database> subclause applies to the UNION as a whole and
      must be placed after the last <database>SELECT</database>. If you want
      to limit the output of one or more individual
      <database>SELECT</database>s within the <database>UNION</database>, you
      have two options: either use
      <database>FIRST</database>/<database>SKIP</database> on those
      <database>SELECT</database> statements (probably of limited use, as you
      can't use <database>ORDER BY</database> on individual selects within a
      union), or convert them to <link
      linkend="langref25-dml-derived-tables">derived tables</link> with
      <database>ROWS</database> clauses.</para>

      <para>Below are the previous examples rewritten using
      <database>ROWS</database>. Notice that <database>ROWS</database> is
      placed at or near the end of the statement, whereas
      <database>FIRST</database> and <database>SKIP</database> come even
      before the columns list.</para>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows 1 to 10</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows 11 to (select count(*) from People)</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows (select count(*) - 9 from People)
    to (select count(*) from People)</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from People
  order by name asc
  rows 81 to 100</programlisting>
      </blockquote>

      <para>Both <database>FIRST</database>/<database>SKIP</database> and
      <database>ROWS</database> can be used without an <database>ORDER
      BY</database> clause, but this rarely makes sense, unless you want to
      just <quote>get an idea</quote> about a table without being interested
      in the actual data. In that case, a statement like <quote>select * from
      UnknownTable rows 20</quote> may give you a quick insight without
      risking lots of network traffic and thousands of data rows flying across
      your screen.</para>
    </section>

    <section id="langref25-dml-select-column-list">
      <title>The column list</title>

      <para>The column list contains one or more comma-separated value
      expressions. Each expression provides a value for one output column,
      except <literal>*</literal> (<quote>star</quote>), which stands for all
      the columns in a relation (i.e. a table, view or selectable stored
      procedure).</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   [...]
   [DISTINCT | ALL] <replaceable>&lt;output-column&gt;</replaceable> [, <replaceable>&lt;output-column&gt;</replaceable> ...]
   [...]
   FROM ...

<replaceable>&lt;output-column&gt;</replaceable>     ::=  [<replaceable>qualifier</replaceable>.]*
                           | <replaceable>&lt;value-expression&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;value-expression&gt;</replaceable>  ::=  [<replaceable>qualifier</replaceable>.]<replaceable>table-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>view-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>selectable-SP-outparm</replaceable>
                           | <replaceable>constant</replaceable>
                           | <replaceable>context-variable</replaceable> 
                           | <replaceable>function-call</replaceable>
                           | <replaceable>single-value-subselect</replaceable>
                           | <emphasis><database>CASE</database>-construct</emphasis>
                           | <quote>any other expression returning a single
                                value of a Firebird data type or <database>NULL</database></quote>

<replaceable>qualifier</replaceable>           ::=  a relation name or alias
<replaceable>collation</replaceable>           ::=  a valid collation name (only for character type columns)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>It is always valid to qualify a column name (or
      <quote><literal>*</literal></quote>) with the name or alias of the
      table, view or selectable SP to which it belongs, followed by a dot.
      Qualifying becomes mandatory if the column name occurs in more than one
      relation taking part in a join. Notice that aliases obfuscate the
      original relation name: once a table, view or SP has been aliased, you
      can only use the alias as a qualifier; the relation name itself has
      become unavailable.</para>

      <para>The column list may optionally be preceded by one of the keywords
      <database>DISTINCT</database> or <database>ALL</database>.
      <database>DISTINCT</database> filters out any duplicate rows. That is,
      if two or more rows have the same values in every corresponding column,
      only one of them is included in the result set. <database>ALL</database>
      shows all the rows including duplicates. <database>ALL</database> is the
      default and therefore rarely used; it is supported for reasons of SQL
      compliance.</para>

      <para>A <database>COLLATE</database> clause will not change the
      appearance of the column as such. However, if the specified collation
      changes the case or accent sensitivity of the column, it may
      influence:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>The ordering, if an <database>ORDER BY</database> clause is
          also present and the column is involved in it.</para>
        </listitem>

        <listitem>
          <para>Grouping, if the column is part of a <database>GROUP
          BY</database> clause.</para>
        </listitem>

        <listitem>
          <para>The rows retrieved (and hence the total number of rows in the
          result set), if <database>DISTINCT</database> is used.</para>
        </listitem>
      </itemizedlist>

      <bridgehead>Examples of <database>SELECT</database> queries with
      different types of column lists</bridgehead>

      <para>A simple <database>SELECT</database> using only column
      names:</para>

      <blockquote>
        <programlisting>select cust_id, cust_name, phone
  from customers
  where city = 'London'</programlisting>
      </blockquote>

      <para>A query featuring a concatenation expression and a function call
      in the columns list:</para>

      <blockquote>
        <programlisting>select 'Mr./Mrs. ' || lastname, street, zip, upper(city)
  from contacts
  where date_last_purchase(id) = current_date</programlisting>
      </blockquote>

      <para>A query with two subselects:</para>

      <blockquote>
        <programlisting>select p.fullname,
       (select name from classes c where c.id = p.class) as class,
       (select name from mentors m where m.id = p.mentor) as mentor
from pupils p</programlisting>
      </blockquote>

      <para>The following query accomplishes the same as the previous one
      using joins instead of subselects:</para>

      <blockquote>
        <programlisting>select p.fullname,
       c.name as class,
       m.name as mentor
from pupils p
  join classes c on c.id = p.class
  join mentors m on m.id = p.mentor</programlisting>
      </blockquote>

      <para>This query uses a <database>CASE</database> construct to determine
      the correct title, e.g. when sending mail to a person:</para>

      <blockquote>
        <programlisting>select <emphasis role="bold">case upper(sex)
         when 'F' then 'Mrs.'
         when 'M' then 'Mr.'
         else ''
       end</emphasis> as title,
       lastname,
       address
from employees</programlisting>
      </blockquote>

      <para>Querying a selectable stored procedure:</para>

      <blockquote>
        <programlisting>select * from interesting_transactions(2010, 3, 'S')
  order by amount</programlisting>
      </blockquote>

      <para>Selecting from columns of a derived table. A derived table is a
      parenthesized <database>SELECT</database> statement whose result set is
      used in an enclosing query as if it were a regular table or view. The
      derived table is shown in bold here:</para>

      <!--Kan dit voorbeeld niet beter bij het bespreken van derived tables in de FROM-claus?-->

      <blockquote>
        <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>
      </blockquote>

      <para>Asking the time through a context variable
      (<database>CURRENT_TIME</database>):</para>

      <blockquote>
        <programlisting>select current_time from rdb$database</programlisting>
      </blockquote>

      <para>For those not familiar with <database>RDB$DATABASE</database>:
      this is a system table that is present in all Firebird databases and is
      guaranteed to contain exactly one row. Although it wasn't created for
      this purpose, it has become standard practice among Firebird programmers
      to select from this table if you want to select <quote>from
      nothing</quote>, i.e., if you need data that are not bound to a any
      table or view, but can be derived from the expressions in the output
      columns alone. Another example is:</para>

      <blockquote>
        <programlisting>select power(12, 2) as twelve_squared, power(12, 3) as twelve_cubed
  from rdb$database</programlisting>
      </blockquote>

      <para>Finally, an example where you select some meaningful information
      from <database>RDB$DATABASE</database> itself:</para>

      <blockquote>
        <programlisting>select rdb$character_set_name from rdb$database</programlisting>
      </blockquote>

      <para>As you may have guessed, this will give you the default character
      set of the database.</para>
    </section>

    <section id="langref25-dml-select-into">
      <title>Selecting <database>INTO</database> variables</title>

      <formalpara>
        <title>Available in</title>

        <para>ESQL, PSQL</para>
      </formalpara>

      <para>In PSQL code or embedded SQL, the results of a
      <database>SELECT</database> statement may be loaded – on a row-by-row
      basis – into local variables (PSQL) or host languages variables (ESQL).
      In fact, this is often the only way to do anything with the returned
      values at all. The number, order and types of the variables must match
      the columns in the output row.</para>

      <para>A <quote>plain</quote> <database>SELECT</database> statement can
      only be used in ESQL or PSQL if it returns at most one row – in other
      words, if it is a <emphasis>singleton</emphasis> select. For multirow
      selects, PSQL provides the <database>FOR SELECT</database> loop, which
      is discussed in the PSQL chapter. In addition, both PSQL and ESQL
      support the <database>DECLARE CURSOR</database> statement, which binds a
      named cursor to a <database>SELECT</database> statement. The cursor can
      then be used to walk the result set.</para>

      <formalpara>
        <title>Syntax</title>

        <para>In embedded SQL, the <database>INTO</database> clause is placed
        between the column list and the <database>FROM</database>
        keyword:<blockquote>
            <programlisting>SELECT
   [...]
   <replaceable>&lt;column-list&gt;</replaceable>
   [INTO <replaceable>&lt;variable-list&gt;</replaceable>]
   FROM ...
   [...]

<replaceable>&lt;variable-list&gt;</replaceable>  ::=  :<replaceable>hostvar</replaceable> [, :<replaceable>hostvar</replaceable> ...]</programlisting>
          </blockquote>In PSQL, the <database>INTO</database> clause must
        appear at the very end of the statement:<blockquote>
            <programlisting>SELECT
   [...]
   <replaceable>&lt;column-list&gt;</replaceable>
   FROM ...
   [...]
   [INTO <replaceable>&lt;variable-list&gt;</replaceable>]

<replaceable>&lt;variable-list&gt;</replaceable>  ::=  [:]<replaceable>psqlvar</replaceable> [, [:]<replaceable>psqlvar</replaceable> ...]</programlisting>
          </blockquote>Notice that in PSQL, the colons before the variable
        names are optional.</para>
      </formalpara>

      <bridgehead>Examples</bridgehead>

      <para>In ESQL, with <varname>min_amt</varname>,
      <varname>avg_amt</varname> and <varname>max_amt</varname> host language
      (e.g. C) variables:</para>

      <blockquote>
        <programlisting>select min(amount), avg(cast(amount as float)), max(amount)
  into :min_amt, :avg_amt, :max_amt
  from orders
  where artno = 372218;</programlisting>
      </blockquote>

      <para>In PSQL, with <varname>min_amt</varname>,
      <varname>avg_amt</varname> and <varname>max_amt</varname> previously
      defined PSQL variables or output parameters:</para>

      <blockquote>
        <programlisting>select min(amount), avg(cast(amount as float)), max(amount)
  from orders
  where artno = 372218
  into min_amt, avg_amt, max_amt;</programlisting>
      </blockquote>

      <para>(The <database>CAST</database> serves to make the average a broken
      number. Otherwise – since <systemitem>amount</systemitem> is presumably
      an integer field – it would be truncated to the nearest lower
      integer.)</para>

      <para>In a PSQL trigger:</para>

      <blockquote>
        <programlisting>select list(name, ', ')
  from persons p
  where p.id in (new.father, new.mother)
  into new.parentnames;</programlisting>
      </blockquote>
    </section>

    <section id="langref25-dml-select-from">
      <title>The <database>FROM</database> clause</title>

      <para>The <database>FROM</database> clause specifies the source(s) from
      which the data are to be retrieved. In its simplest form, this is just a
      single table or view. But the source can also be a selectable stored
      procedure, a derived table or a common table expression. Multiple
      sources can be combined using various types of joins.</para>

      <para>This section concentrates on single-source selects. Joins are
      discussed in the next section.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>&lt;derived-table&gt;</replaceable>
                          | <replaceable>&lt;common-table-expression&gt;</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;derived-table&gt;</replaceable>   ::=  (<replaceable>select-statement</replaceable>) [[AS] <replaceable>alias</replaceable>]
                         [(<replaceable>&lt;column-aliases&gt;</replaceable>)]

<replaceable>&lt;common-table-expression&gt;</replaceable>
                  ::=  WITH [RECURSIVE] <replaceable>&lt;cte-def&gt;</replaceable> [, <replaceable>&lt;cte-def&gt;</replaceable> ...]
                       <replaceable>select-statement</replaceable>

<replaceable>&lt;cte-def&gt;</replaceable>         ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-aliases&gt;</replaceable>)] AS (<replaceable>select-statement</replaceable>)

<replaceable>&lt;column-aliases&gt;</replaceable>  ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langref25-dml-select-from-table-view">
        <title>Selecting from a table or view</title>

        <para>When selecting from a single table or view, the
        <database>FROM</database> clause need not contain anything more than
        the name. An alias may be useful or even necessary if there are
        subselects that refer to the main select statement (as they often do –
        subqueries like this are called <firstterm>correlated
        subqueries</firstterm>).</para>

        <bridgehead>Examples</bridgehead>

        <blockquote>
          <programlisting>select id, name, sex, age from actors
  where state = 'Ohio'</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from birds
  where type = 'flightless'
  order by family, genus, species</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select firstname,
       middlename,
       lastname,
       date_of_birth,
       (select name from schools s where p.school = s.id) schoolname
from pupils p
where year_started = '2012'
order by schoolname, date_of_birth</programlisting>
        </blockquote>
      </section>

      <section id="langref25-dml-select-sp">
        <title>Selecting from a stored procedure</title>

        <para>A <firstterm>selectable stored procedure</firstterm> is a
        procedure that:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>contains at least one output parameter, and</para>
          </listitem>

          <listitem>
            <para>utilizes the <database>SUSPEND</database> keyword so the
            caller can fetch the output rows one by one, just as when
            selecting from a table or view.</para>
          </listitem>
        </itemizedlist>

        <para>The output parameters of a selectable stored procedure
        correspond to the columns of a regular table.</para>

        <para>Selecting from a stored procedure without input parameters is
        just like selecting from a table or view:</para>

        <blockquote>
          <programlisting>select * from suspicious_transactions
  where assignee = 'John'</programlisting>
        </blockquote>

        <para>Any required input parameters must be specified after the
        procedure name, enclosed in parentheses:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
  where alt &gt;= 20
  order by az, alt</programlisting>
        </blockquote>

        <para>Values for optional parameters (that is, parameters for which
        default values have been defined) may be omitted or provided. However,
        if you provide them only partly, the parameters you omit must all be
        at the tail end.</para>

        <para>Supposing that the procedure
        <systemitem>visible_stars</systemitem> from the previous example has
        two optional parameters: <parameter>min_magn</parameter>
        (numeric(3,1)) and <parameter>spectral_class</parameter>
        (varchar(12)), the following queries are all valid:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0)
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0, 'G')</programlisting>
        </blockquote>

        <para>But this one isn't, because there's a <quote>hole</quote> in the
        parameter list:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30', 'G')</programlisting>
        </blockquote>

        <para>An alias for a selectable stored procedure is specified
        <emphasis>after</emphasis> the parameter list:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = gw.number)
from get_winners('#34517', 'AMS') gw</programlisting>
        </blockquote>

        <para>If you qualify a column (output parameter) with the full
        procedure name, don't include the parameter list:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = get_winners.number)
from get_winners('#34517', 'AMS')</programlisting>
        </blockquote>
      </section>

      <section id="langref25-dml-select-from-dt">
        <title>Derived tables</title>

        <para>A derived table is a valid <database>SELECT</database> statement
        enclosed in parentheses, optionally followed by a table alias and/or
        column aliases. The result set of the statement acts as a virtual
        table which the enclosing statement can query.</para>

        <para>Derived tables are discussed in detail in the section <link
        linkend="langref25-dml-derived-tables"><citetitle>Derived tables
        (<quote><database>SELECT FROM
        SELECT</database></quote>)</citetitle></link>. Here, we only give an
        example.</para>

        <para>Suppose we have a table <database>COEFFS</database> which
        contains the coefficients of a number of quadratic equations we have
        to solve. It has been defined like this:</para>

        <blockquote>
          <programlisting>create table coeffs (
  a double precision not null,
  b double precision not null,
  c double precision not null,
  constraint chk_a_not_zero check (a &lt;&gt; 0)
)</programlisting>
        </blockquote>

        <para>Depending on the values of <replaceable>a</replaceable>,
        <replaceable>b</replaceable> and <replaceable>c</replaceable>, each
        equation may have zero, one or two solutions in ℝ. It is possible to
        find these solutions with a single-level query on table
        <database>COEFFS</database>, but the code will look rather messy and
        several values (like the discriminant) will have to be calculated
        multiple times per row. A derived table can help keep things clean
        here:</para>

        <blockquote>
          <programlisting>select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select b, b*b - 4*a*c, 2*a from coeffs) (b, D, denom)</programlisting>
        </blockquote>

        <para>If we want to show the coefficients next to the solutions (which
        may not be a bad idea), we can alter the query like this:</para>

        <blockquote>
          <programlisting>select
  a, b, c,
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select a, b, c, b*b - 4*a*c as D, 2*a as denom
     from coeffs)</programlisting>
        </blockquote>

        <para>Notice that whereas the first query used a column aliases list
        for the derived table, the second adds aliases internally where
        needed. Both methods work, as long as every column is guaranteed to
        have a name.</para>
      </section>

      <section id="langref25-dml-select-from-cte">
        <title>Common table expressions</title>

        <para>A common table expression or <database>CTE</database> is a more
        complex, but also more powerful type of derived table. A preamble,
        starting with the keyword <database>WITH</database>, defines one or
        more named <database>CTE</database>'s, each optionally with a column
        aliases list. The main query, which follows the preamble, can then
        access these <database>CTE</database>'s as if they were regular tables
        or views. Once the main query has run to completion, the
        <database>CTE</database>'s go out of scope.</para>

        <para>For a full discussion of <database>CTE</database>'s, please
        refer to the section <link
        linkend="langref25-dml-select-cte"><citetitle>Common Table Expressions
        (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</citetitle></link>.</para>

        <para>The following is a rewrite of our derived table example as a
        <database>CTE</database>:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
)
select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
from vars</programlisting>
        </blockquote>

        <para>Except for the fact that the calculations that have to be made
        first are now at the beginning, this isn't a great improvement over
        the derived table version. But we can now also eliminate the double
        calculation of sqrt(D) for every row:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
),
vars2 (b, D, denom, sqrtD) as (
  select b, D, denom, iif (D &gt;= 0, sqrt(D), null) from vars
)
select
  iif (D &gt;= 0, (-b - sqrtD) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrtD) / denom, null) sol_2
from vars2</programlisting>
        </blockquote>

        <para>The code is a little more complicated now, but it might execute
        more efficiently (depending on what takes more time: executing the
        <database>SQRT</database> function or passing the values of
        <replaceable>b</replaceable>, <replaceable>D</replaceable> and
        <replaceable>denom</replaceable> through an extra
        <database>CTE</database>). Incidentally, we could have done the same
        with derived tables, but that would involve nesting.</para>
      </section>
    </section>

    <section id="langref25-dml-select-joins">
      <title>Joins</title>

      <para>Joins combine data from two sources into a single set. This is
      done on a row-by-row basis and usually involves the checking of a
      <firstterm>join condition</firstterm> in order to determine which rows
      should be linked together and appear in the resulting dataset. There are
      several types (<database>INNER</database>, <database>OUTER</database>)
      and classes (qualified, natural, etc.) of joins, each with their own
      syntax and rules.</para>

      <para>Since joins can be chained, the datasets involved in a join may
      themselves be joined sets.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>derived-table</replaceable>
                          | <replaceable>common-table-expression</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;joins&gt;      </replaceable>     ::=  <replaceable>&lt;join&gt;</replaceable> [<replaceable>&lt;join&gt;</replaceable> ...]

<replaceable>&lt;join&gt;</replaceable>            ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>
                         | NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>
                         | {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langref25-dml-select-joins-types">
        <title>Inner vs. outer joins</title>

        <para>A join always combines data rows from two sets, the
        <emphasis>left</emphasis> set and the <emphasis>right</emphasis> set.
        By default, only rows that meet the join condition (i.e., that match
        at least one row in the other set when the join condition is applied)
        make it into the result set. This default type of join is called an
        <firstterm>inner join</firstterm>. Suppose we have two tables
        <database>A</database> and <database>B</database>:</para>

        <blockquote>
          <para>Table A:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Table B:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>If we join these tables like this:</para>

        <blockquote>
          <programlisting>select *
  from A
  join B on A.id = B.code</programlisting>
        </blockquote>

        <para>then the result set will be:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>The first row of A has been joined with the second row of B
        because together they met the condition <quote>A.id = B.code</quote>.
        The other rows from the source tables have no match in the opposite
        set and are therefore not included in the join. Remember, this is an
        <database>INNER</database> join. We can make that fact explicit by
        writing:</para>

        <blockquote>
          <programlisting>select *
  from A
  inner join B on A.id = B.code</programlisting>
        </blockquote>

        <para>However, since <database>INNER</database> is the default, this
        is rarely done.</para>

        <para>It is perfectly possible that a row in the left set matches
        several rows from the right set or vice versa. In that case, all those
        combinations are included, and we can get results like:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>-1.0</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Still don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>I give up</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>Sometimes we want (or need) <emphasis>all</emphasis> the rows of
        one or both of the sources to appear in the joined set, regardless of
        whether they match a record in the other source. This is where outer
        joins come in. A <database>LEFT</database> outer join includes all the
        records from the left set, but only matching records from the right
        set. In a <database>RIGHT</database> outer join, it's the other way
        around. <database>FULL</database> outer joins include all the records
        from both sets. In all outer joins, the <quote>holes</quote> (the
        places where an included source record doesn't have a match in the
        other set) are filled up with <database>NULL</database>s.</para>

        <para>In order to make an outer join, you must specify
        <database>LEFT</database>, <database>RIGHT</database> or
        <database>FULL</database>, optionally followed by the keyword
        <database>OUTER</database>.</para>

        <para>Below are the results of the various outer joins when applied to
        our original tables <database>A</database> and
        <database>B</database>:</para>

        <blockquote>
          <programlisting>select *
  from A
  left [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  right [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  full [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>
      </section>

      <section id="langref25-dml-select-joins-qualified">
        <title>Qualified joins</title>

        <para>Qualified joins specify explicit conditions for the combining of
        rows. This happens in an <database>ON</database> clause or a
        <database>USING</database> clause.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;qualified-join&gt;</replaceable>  ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Most qualified joins have an <database>ON</database> clause,
        with a condition that can be any valid boolean expression but usually
        involves some comparison between the two sources involved. This
        comparison is often an equality test with the
        <quote><literal>=</literal></quote> operator. Joins like these are
        called <firstterm>equi-joins</firstterm>. (The examples in the
        previous section were al equi-joins.)</para>

        <para>Some examples of qualified joins with an <database>ON</database>
        clause:</para>

        <blockquote>
          <programlisting>/* Select all Detroit customers who made a purchase
   in 2013, along with the purchase details: */
select * from customers c
  join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>/* Same as above, but include non-buying customers: */
select * from customers c
  left join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>

          <programlisting>/* For each man, select the women who are taller than he.
   Men for whom no such woman exists are not included. */
select m.fullname as man, f.fullname as woman
  from males m
  join females f on f.height &gt; m.height</programlisting>

          <programlisting>/* Select all pupils with their class and mentor.
   Pupils without a mentor are also included.
   Pupils without a class are not included. */
select p.firstname, p.middlename, p.lastname,
       c.name, m.name
  from pupils p
  join classes c on c.id = p.class
  left join mentors m on m.id = p.mentor</programlisting>
        </blockquote>

        <para>Quite often, equi-joins compare columns that have the same name
        in both tables. If this is the case, we can also use the second type
        of qualified join: the <firstterm>named columns join</firstterm>.
        Named columns joins have a <database>USING</database> clause which
        states just the column names. Instead of this:</para>

        <blockquote>
          <programlisting>select * from flotsam f
  join jetsam j
  on f.sea = j.sea
  and f.ship = j.ship</programlisting>
        </blockquote>

        <para>we can also write:</para>

        <blockquote>
          <programlisting>select * from flotsam
  join jetsam using (sea, ship)</programlisting>
        </blockquote>

        <para>which is considerably shorter. The result set is a little
        different though:</para>

        <itemizedlist>
          <listitem>
            <para>The conditional join – with the <database>ON</database>
            clause – will contain each of the columns <database>SEA</database>
            and <database>SHIP</database> twice: once from table
            <database>FLOTSAM</database>, and once from table
            <database>JETSAM</database>. Obviously, they will contain the same
            data.</para>
          </listitem>

          <listitem>
            <para>The named columns join – with the <database>USING</database>
            clause – will contain these columns only once.</para>
          </listitem>
        </itemizedlist>

        <para>If, for some reason, you insist on having all the columns in the
        result set of the named columns join, you must specify them explicitly
        instead of using <quote><literal>*</literal></quote>:</para>

        <blockquote>
          <programlisting>select
  f.id, f.sea, f.ship, f.description,
  j.id, j.sea, j.ship, j.description
from flotsam f
  join jetsam j using (sea, ship)</programlisting>
        </blockquote>

        <para>This will give you the exact same result set as the conditional
        join.</para>

        <para>For an <database>OUTER</database> named columns join, there's an
        additional twist when using <quote><database>SELECT</database>
        *</quote> or an unqualified column name from the
        <database>USING</database> list:</para>

        <para>If a row from one source set doesn't have a match in the other
        but must still be included because of the <database>LEFT</database>,
        <database>RIGHT</database> or <database>FULL</database> directive, the
        column in the joined set gets the non-<database>NULL</database> value.
        That stands to reason, but now you can't tell whether this value came
        from the left set, the right set, or both. This can be especially
        deceiving when the value came from the right hand set, because
        <quote><literal>*</literal></quote> always shows combined columns in
        the left hand set – even in the case of a <database>RIGHT</database>
        join. Whether this is a problem or not depends on the situation. If it
        is, specify the output columns explicitly <emphasis>and qualify at
        least all common columns with the name or alias of the source
        relation</emphasis>. Better yet, avoid
        <quote><literal>*</literal></quote> altogether in your serious queries
        and qualify all column names (or at least all common column names) in
        joined sets. This has the addional benefit that it forces you to think
        about which data you want to retrieve and where from.</para>

        <para>It is your responsibility to make sure that the column names in
        the <database>USING</database> list are of compatible types between
        the two sources. If the types are compatible but not equal, the engine
        converts them to the type with the broadest range of values before
        comparing the values. This will also be the data type of the
        <quote>merged</quote> column that shows up in the result set if
        <quote><database>SELECT</database> *</quote> or the unqualified column
        name is used. Qualified columns on the other hand will always retain
        their original data type.</para>

        <note>
          <para>The <quote><literal>=</literal></quote> operator, which is
          explicitly used in many conditional joins and implicitly in named
          column joins, only matches values to values. According to the SQL
          standard, <database>NULL</database> is not a value and hence two
          <database>NULL</database>s are neither equal nor unequal to one
          another. If you need <database>NULL</database>s to match each other
          in a join, use the <database>IS NOT DISTINCT FROM</database>
          operator. This operator returns true if the operands have the same
          value <emphasis>or</emphasis> if they are both
          <database>NULL</database>.</para>

          <programlisting>select *
  from A join B
  on A.id is not distinct from B.code</programlisting>
        </note>
      </section>

      <section id="langref25-dml-select-joins-natural">
        <title>Natural joins</title>

        <para>Taking the idea of the named columns join a step further, a
        <firstterm>natural join</firstterm> performs an automatic equi-join on
        all the columns that have the same name in the left and right table.
        The data types of these columns must be compatible.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;natural-join&gt;</replaceable>  ::=  NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>     ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Given these two tables:</para>

        <blockquote>
          <programlisting>create table TA (
  a bigint,
  s varchar(12),
  ins_date date
)</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>create table TB (
  a bigint,
  descr varchar(12),
  x float,
  ins_date date
)</programlisting>
        </blockquote>

        <para>a natural join on <database>TA</database> and
        <database>TB</database> would involve the columns
        <replaceable>a</replaceable> and <replaceable>ins_date</replaceable>,
        and the following two statements would have the same effect:</para>

        <blockquote>
          <programlisting>select * from TA
  natural join TB</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from TA
  join TB using (a, ins_date)</programlisting>
        </blockquote>

        <para>Like all joins, natural joins are inner joins by default, but
        you can turn them into outer joins by specifying
        <database>LEFT</database>, <database>RIGHT</database> or
        <database>FULL</database> before the <database>JOIN</database>
        keyword.</para>

        <para>Caution! If there are no columns with the same name in the two
        source relations, a <database>CROSS JOIN</database> is
        performed.</para>
      </section>

      <section id="langref25-dml-select-joins-cross">
        <title>Cross joins</title>

        <para>A cross join produces the full set product of the two data
        sources. This means that it successfully matches every row in the left
        source to every row in the right source.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;cross-join&gt;</replaceable>  ::=  {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <para>Please notice that the comma syntax is deprecated! It is only
        supported to keep legacy code working, and it may disappear in some
        future version.</para>

        <para>Cross-joining two sets is equivalent to joining them on a
        tautology (a condition that is always true). The following two
        statements have the same effect:</para>

        <blockquote>
          <programlisting>select * from TA
  cross join TB</programlisting>

          <programlisting>select * from TA
  join TB on 1 = 1</programlisting>
        </blockquote>

        <para>Cross joins are inner joins, because they only include matching
        records – it just so happens that <emphasis>every</emphasis> record
        matches! An outer cross join, if it existed, wouldn't add anything to
        the result, because what outer joins add are non-matching records, and
        these don't exist in cross joins.</para>

        <para>Cross joins are rarely useful, except if you want to list all
        the possible combinations of two or more variables. Suppose you are
        selling a product that comes in different sizes, different colors and
        different materials. If these variables are each listed in a table of
        their own, this query would return all the combinations:</para>

        <blockquote>
          <programlisting>select m.name, s.size, c.name
  from materials m
  cross join sizes s
  cross join colors c</programlisting>
        </blockquote>
      </section>

      <section id="langref25-dml-select-joins-ambiguity">
        <title>Ambiguous field names in joins</title>

        <para>Firebird rejects unqualified field names in a query if these
        field names exist in more than one dataset involved in a join. This is
        even true for inner equi-joins where the field name figures in the
        <database>ON</database> clause like this:</para>

        <blockquote>
          <programlisting>select a, b, c
  from TA
  join TB on TA.a = TB.a</programlisting>
        </blockquote>

        <para>There is one exception to this rule: with named columns joins
        and natural joins, the unqualified field name of a column taking part
        in the matching process may be used legally and refers to the merged
        column of the same name. For named columns joins, these are the
        columns listed in the <database>USING</database> clause. For natural
        joins, they are the columns that have the same name in both relations.
        But please notice again that, especially in outer joins, plain
        <replaceable>colname</replaceable> isn't always the same as
        <replaceable>left</replaceable>.<replaceable>colname</replaceable> or
        <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
        Types may differ, and one of the qualified columns may be
        <database>NULL</database> while the other isn't. In that case, the
        value in the merged, unqualified column may mask the fact that one of
        the source values is absent.</para>
      </section>
    </section>

    <section id="langref25-dml-aggregates">
      <title>Aggregate functions: Extended functionality</title>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Several types of mixing and nesting aggregate functions are
        supported since Firebird 1.5. They will be discussed in the following
        subsections. To get the complete picture, also look at the
        <database>SELECT</database> :: <database>GROUP BY</database>
        sections.</para>
      </formalpara>

      <section id="langref25-dml-aggregates-mix">
        <title>Mixing aggregate functions from different contexts</title>

        <para>Firebird 1.5 and up allow the use of aggregate functions from
        different contexts inside a single expression.</para>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
            </blockquote></para>
        </formalpara>

        <para>This admittedly rather contrived query shows, in the second
        column, the maximum index selectivity of any index defined on a table,
        followed by the table's field count between parentheses. Of course you
        would normally display the field count in a separate column, or in the
        column with the table name, but the purpose here is to demonstrate
        that you can combine aggregates from different contexts in a single
        expression.</para>

        <warning>
          <para>Firebird 1.0 also executes this type of query, but gives the
          wrong results!</para>
        </warning>
      </section>

      <section id="langref25-dml-aggregates-in-subqueries">
        <title>Aggregate functions and <database>GROUP BY</database> items
        inside subqueries</title>

        <para>Since Firebird 1.5 it is possible to use aggregate functions
        and/or expressions contained in the <database>GROUP BY</database>
        clause inside a subquery.</para>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>This query returns each table's ID and field count. The
              subquery refers to
              <literal><systemitem>flds.rdb$relation_name</systemitem></literal>,
              which is also a <database>GROUP BY</database> item:</para>

              <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>

              <para>The next query shows the last field from each table and
              its 1-based position. It uses the aggregate function
              <database>MAX</database> in a subquery.</para>

              <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>

              <para>The subquery also contains the <database>GROUP
              BY</database> item
              <systemitem>flds.rdb$relation_name</systemitem>, but that's not
              immediately obvious because in this case the <database>GROUP
              BY</database> clause uses the column number.</para>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-subqueries-in-aggregates">
        <title>Subqueries inside aggregate functions</title>

        <para>Using a singleton subselect inside (or as) an aggregate function
        argument is supported in Firebird 1.5 and up.</para>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>

              <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-aggregates-nesting">
        <title>Nesting aggregate function calls</title>

        <para>Firebird 1.5 allows the indirect nesting of aggregate functions,
        provided that the inner function is from a lower SQL context. Direct
        nesting of aggregate function calls, as in
        <quote><database>COUNT</database>( <database>MAX</database>( price )
        )</quote>, is still forbidden and punishable by exception.</para>

        <formalpara>
          <title>Example</title>

          <para>See under <link
          linkend="langref25-dml-subqueries-in-aggregates"><citetitle>Subqueries
          inside aggregate functions</citetitle></link>, where
          <database>COUNT()</database> is used inside a
          <database>SUM()</database>.</para>
        </formalpara>

        <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
      </section>

      <section id="langref25-dml-aggregates-having-orderby">
        <title>Aggregate statements: Stricter <database>HAVING</database> and
        <database>ORDER BY</database></title>

        <para>Firebird 1.5 and above are stricter than previous versions about
        what can be included in the <database>HAVING</database> and
        <database>ORDER BY</database> clauses. If, in the context of an
        aggregate statement, an operand in a <database>HAVING</database> or
        <database>ORDER BY</database> item contains a column name,<!--This should probably be: ...contains a column name from the query context (i.e. from the table or join in the FROM clause).-->
        it is only accepted if one of the following is true:</para>

        <itemizedlist>
          <listitem>
            <para>The column name appears in an aggregate function call (e.g.
            <quote><code>HAVING MAX(SALARY) &gt; 10000</code></quote>).</para>
          </listitem>

          <listitem>
            <para>The operand equals or is based upon a non-aggregate column
            that appears in the <database>GROUP BY</database> list (by name or
            position).</para>
          </listitem>

          <!--This listitem commented out for now, needs research:
  o  The operand equals or is based upon a subquery, whether or not it is also a GROUP BY item.-->

          <!--See also under GROUP BY. Check if it is possible to include a non-aggregated subquery in the HAVING / ORDER BY
if that subquery contains columns not present in the GROUP BY.
And if this is possible, also look what happens if that subquery returns different values within a group.-->
        </itemizedlist>

        <para><quote>Is based upon</quote> means that the operand need not be
        exactly the same as the column name. Suppose there's a non-aggregate
        column <quote><database>STR</database></quote> in the select list.
        Then it's OK to use expressions like
        <quote><database>UPPER(STR)</database></quote>, <quote><database>STR
        || '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4 FOR
        2)</database></quote> in the <database>HAVING</database> clause – even
        if these expressions don't appear as such in the
        <database>SELECT</database> or <database>GROUP BY</database>
        list.</para>

        <!--If and when the subquery thing gets mentioned again, the above para must also be changed: ("...as the column name or subquery." etc.)-->
      </section>

      <!--1.5 Rlsnotes say:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used in the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->

      <!--*******

Maybe the entire GROUP BY thing should become something like this:

Every column that is present - in non-aggregrated form - on the highest (outermost?) level in the context of an aggregated query
(i.e., is a column of the relation(s) in the FROM clause)
*must* be included in the GROUP BY clause.

Question: If such a column is present in a subquery, but with the table alias as defined in the outermost query context,
must it go in the GROUP BY? I think yes, but test!
Question 2: As above, but this time with its own alias, belonging to the subselect?
I think it doesn't have to go in the GROUP BY then, but test.
Question 3: If a relation does not have an alias in the uppermost FROM, and it is used in a subselect
also without an alias, does that mean they have the same context? I hope not...-->
    </section>

    <section id="langref25-dml-as-relationalias">
      <title>[<database>AS</database>] before relation alias</title>

      <formalpara>
        <title>Added in</title>

        <para>IB</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The keyword <database>AS</database> can optionally be placed
        before a relation alias, just as it can be placed before a column
        alias. This feature dates back to InterBase times, but wasn't
        documented in the IB Language Reference.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM <replaceable>&lt;relation&gt;</replaceable> [AS] <replaceable>alias</replaceable>

<replaceable>&lt;relation&gt;</replaceable>  ::=  A table, view, or selectable SP</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select order_no, total, fullname
  from orders <emphasis role="bold">as</emphasis> o join customers <emphasis
                role="bold">as</emphasis> c on o.cust_id = c.cust_id</programlisting>

            <programlisting>select order_no, total, fullname
  from orders o join customers c on o.cust_id = c.cust_id</programlisting>

            <para>The two queries are fully equivalent.</para>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-select-collate">
      <title><database>COLLATE</database> subclause for text
      <database>BLOB</database> columns</title>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>COLLATE</database> subclauses are now also supported
        for text <database>BLOB</database>s.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-select-cte">
      <title>Common Table Expressions (<quote><database>WITH ... AS ...
      SELECT</database></quote>)</title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL? Suppose not, but do find out / ask-->
      </formalpara>

      <para>A common table expression or <database>CTE</database> can be
      described as a virtual table or view, defined in a preamble to a main
      query, and going out of scope after the main query's execution. The main
      query can reference any <database>CTE</database>s defined in the
      preamble as if they were regular tables or views.
      <database>CTE</database>s can be recursive, i.e. self-referencing, but
      they cannot be nested.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting><replaceable>&lt;cte-construct&gt;</replaceable>  ::=  <replaceable>&lt;cte-defs&gt;</replaceable>
                      <replaceable>&lt;main-query&gt;</replaceable>

<replaceable>&lt;cte-defs&gt;</replaceable>       ::=  WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]

<replaceable>&lt;cte&gt;</replaceable>            ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-stmt&gt;</replaceable>)

<replaceable>&lt;column-list&gt;</replaceable>    ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]

<replaceable>&lt;cte-stmt&gt;</replaceable>       ::=  any <database>SELECT</database> statement or <database>UNION</database>

<replaceable>&lt;main-query&gt;</replaceable>     ::=  the main <database>SELECT</database> statement, which can refer to the
                      <database>CTE</database>s defined in the preamble</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting><emphasis role="bold">with dept_year_budget as (
  select fiscal_year,
         dept_no,
         sum(projected_budget) as budget
  from proj_dept_budget
  group by fiscal_year, dept_no
)</emphasis>
select d.dept_no,
       d.department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from department d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009
where exists (
  select * from proj_dept_budget b
  where d.dept_no = b.dept_no
)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>A <database>CTE</database> definition can contain any
              legal <database>SELECT</database> statement, as long as it
              doesn't have a <quote><database>WITH...</database></quote>
              preamble of its own (no nesting).</para>
            </listitem>

            <listitem>
              <para><database>CTE</database>s defined for the same main query
              can reference each other, but care should be taken to avoid
              loops.</para>

              <!--Can a CTE also refer to another one that comes *after* it in the WITH clause?-->
            </listitem>

            <listitem>
              <para><database>CTE</database>s can be referenced from anywhere
              in the main query.</para>
            </listitem>

            <listitem>
              <para>Each <database>CTE</database> can be referenced multiple
              times in the main query, possibly with different aliases.</para>
            </listitem>

            <listitem>
              <para>When enclosed in parentheses, <database>CTE</database>
              constructs can be used as subqueries in
              <database>SELECT</database> statements, but also in
              <database>UPDATE</database>s, <database>MERGE</database>s
              etc.</para>
            </listitem>

            <listitem>
              <para>In PSQL, <database>CTE</database>s are also supported in
              <database>FOR</database> loop headers:</para>

              <programlisting>for <emphasis role="bold">with my_rivers as (select * from rivers where owner = 'me')</emphasis>
    select name, length from my_rivers into :rname, :rlen
do
begin
  ..
end</programlisting>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <section id="langref25-dml-select-cte-recursive">
        <title>Recursive <database>CTE</database>s</title>

        <para>A recursive (self-referencing) <database>CTE</database> is a
        <database>UNION</database> which must have at least one non-recursive
        member, called the <firstterm>anchor</firstterm>. The non-recursive
        member(s) must be placed before the recursive member(s). Recursive
        members are linked to each other and to their non-recursive neighbour
        by <database>UNION ALL</database> operators. The unions between
        non-recursive members may be of any type.</para>

        <para>Recursive <database>CTE</database>s require the
        <database>RECURSIVE</database> keyword to be present right after
        <database>WITH</database>. Each recursive union member may reference
        itself only once, and it must do so in a <database>FROM</database>
        clause.</para>

        <para>A great benefit of recursive <database>CTE</database>s is that
        they use far less memory and CPU cycles than an equivalent recursive
        stored procedure.</para>

        <!--Find out:
- May the recursive reference occur in any FROM clause in the recursive union member, or only
  in the member's main (outermost) FROM clause?
- Can the RECURSIVE keyword be repeated before each (recursive) CTE?-->

        <para>The execution pattern of a recursive <database>CTE</database> is
        as follows:</para>

        <itemizedlist>
          <listitem>
            <para>The engine begins execution from a non-recursive
            member.</para>
          </listitem>

          <listitem>
            <para>For each row evaluated, it starts executing each recursive
            member one by one, using the current values from the outer row as
            parameters.</para>
          </listitem>

          <listitem>
            <para>If the currently executing instance of a recursive member
            produces no rows, execution loops back one level and gets the next
            row from the outer result set.</para>
          </listitem>
        </itemizedlist>

        <!--I wonder if this is entirely correct. Don't all the recursive union members each present a next lower level in the execution pattern?
Also, to whom should I give credit for this text (if I use it): Vlad or Paul?-->

        <formalpara>
          <title>Example with a recursive <database>CTE</database></title>

          <para><blockquote>
              <programlisting><emphasis role="bold">with recursive
  dept_year_budget as (
    select fiscal_year,
           dept_no,
           sum(projected_budget) as budget
    from proj_dept_budget
    group by fiscal_year, dept_no
  ),
  dept_tree as (
    select dept_no,
           head_dept,
           department,
           cast('' as varchar(255)) as indent
    from department
    where head_dept is null
    union all
    select d.dept_no,
           d.head_dept,
           d.department,
           h.indent || '  '
    from department d
         join dept_tree h on d.head_dept = h.dept_no
  )</emphasis>
select d.dept_no,
       d.indent || d.department as department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from <emphasis role="bold">dept_tree</emphasis> d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes on recursive <database>CTE</database>s</title>

          <para><itemizedlist>
              <listitem>
                <para>Aggregates (<database>DISTINCT</database>,
                <database>GROUP BY</database>, <database>HAVING</database>)
                and aggregate functions (<database>SUM</database>,
                <database>COUNT</database>, <database>MAX</database> etc) are
                not allowed in recursive union members.</para>
              </listitem>

              <listitem>
                <para>A recursive reference cannot participate in an outer
                join.</para>
              </listitem>

              <listitem>
                <para>The maximum recursion depth is 1024.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>

    <section id="langref25-dml-derived-tables">
      <title>Derived tables (<quote><database>SELECT FROM
      SELECT</database></quote>)</title>

      <para>A derived table is the result set of a <database>SELECT</database>
      query, used in an outer <database>SELECT</database> as if it were an
      ordinary table. Put another way, it is a subquery in the
      <database>FROM</database> clause.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>(<replaceable>select-query</replaceable>)
   [[AS] <replaceable>derived-table-alias</replaceable>]
   [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

<replaceable>&lt;derived-column-aliases&gt;</replaceable>  ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>The derived table in the query below (shown in boldface)
            contains all the relation names in the database followed by their
            field count. The outer <database>SELECT</database> produces, for
            each existing field count, the number of relations having that
            field count.</para>

            <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>

            <para>A trivial example demonstrating the use of a derived table
            alias and column aliases list (both are optional):</para>

            <programlisting>select dbinfo.descr,
       dbinfo.def_charset
from   <emphasis role="bold">(select * from rdb$database) dbinfo
         (descr, rel_id, sec_class, def_charset)</emphasis></programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Derived tables can be nested.</para>
            </listitem>

            <listitem>
              <para>Derived tables can be unions and can be used in unions.
              They can contain aggregate functions, subselects and joins, and
              can themselves be used in aggregate functions, subselects and
              joins. They can also be or contain queries on selectable stored
              procedures. They can have <database>WHERE</database>,
              <database>ORDER BY</database> and <database>GROUP BY</database>
              clauses, <database>FIRST</database>, <database>SKIP</database>
              or <database>ROWS</database> directives, etc. etc.</para>
            </listitem>

            <listitem>
              <para>Every column in a derived table <emphasis>must</emphasis>
              have a name. If it doesn't have one by nature (e.g. because it's
              a constant) it must either be given an alias in the usual way,
              or a column aliases list must be added to the derived table
              specification.</para>
            </listitem>

            <listitem>
              <para>The column aliases list is optional, but if it is used it
              must be complete. That is: it must contain an alias for every
              column in the derived table.</para>
            </listitem>

            <listitem>
              <para>The optimizer can handle a derived table very efficiently.
              However, if the derived table is involved in an inner join and
              contains a subquery, then no join order can be made.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langref25-dml-first-skip">
      <title><database>FIRST</database> and <database>SKIP</database></title>

      <!--Seem unavailable in ESQL. But Dmitry writes to me: "Available since v1.0, I believe."
Checked again in gpre source (using SKIP search), and it really really really isn't there. So:-->

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Better alternative</title>

        <para><link
        linkend="langref25-dml-select-rows"><database>ROWS</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>FIRST</database> limits the output of a query to the
        first so-many rows. <database>SKIP</database> will suppress the given
        number of rows before starting to return output.<tip>
            <para>In Firebird 2.0 and up, use the SQL-compliant <link
            linkend="langref25-dml-select-rows"><database>ROWS</database></link>
            syntax instead.</para>
          </tip></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>

            <note>
              <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an
              integer literal or a query parameter, the
              <quote><literal>()</literal></quote> may be omitted. Subselects
              on the other hand require an extra pair of parentheses.</para>
            </note>
          </blockquote></para>
      </formalpara>

      <para><database>FIRST</database> and <database>SKIP</database> are both
      optional. When used together as in <quote><database>FIRST</database>
      <replaceable>m</replaceable> <database>SKIP</database>
      <replaceable>n</replaceable></quote>, the <replaceable>n</replaceable>
      topmost rows of the output set are discarded and the first
      <replaceable>m</replaceable> rows of the remainder are returned.</para>

      <para><database>SKIP</database> 0 is allowed, but of course rather
      pointless. <database>FIRST</database> 0 is allowed in version 1.5 and
      up, where it returns an empty set. In 1.0.x, <database>FIRST</database>
      0 causes an error. Negative <database>SKIP</database> and/or
      <database>FIRST</database> values always result in an error.</para>

      <para>If a <database>SKIP</database> lands past the end of the dataset,
      an empty set is returned. If the number of rows in the dataset (or the
      remainder after a <database>SKIP</database>) is less than the value
      given after <database>FIRST</database>, that smaller number of rows is
      returned. These are valid results, not error situations.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>The following query will return the first 10 names from the
            People table:</para>

            <programlisting>select first 10 id, name from People
  order by name asc</programlisting>

            <para>The following query will return everything
            <emphasis>but</emphasis> the first 10 names:</para>

            <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>

            <para>And this one returns the last 10 rows. Notice the double
            parentheses:</para>

            <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>

            <para>This query returns rows 81–100 of the People table:</para>

            <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
          </blockquote></para>
      </formalpara>

      <caution>
        <title>Two Gotchas with <database>FIRST</database> in
        subselects</title>

        <itemizedlist>
          <listitem>
            <para>This:</para>

            <blockquote>
              <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
            </blockquote>

            <para>will delete all of the rows in the table. Ouch! The
            sub-select is evaluating each 10 candidate rows for deletion,
            deleting them, slipping forward 10 more... ad infinitum, until
            there are no rows left. Beware! Or better: use the
            <database>ROWS</database> syntax, available since Firebird
            2.0.</para>
          </listitem>

          <listitem>
            <para>Queries like:</para>

            <blockquote>
              <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
            </blockquote>

            <para>won't work as expected, because the optimization performed
            by the engine transforms the <database>IN</database> predicate to
            the correlated <database>EXISTS</database> predicate shown below.
            It's obvious that in this case <database>FIRST</database>
            <replaceable>N</replaceable> doesn't make any sense:</para>

            <blockquote>
              <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
            </blockquote>

            <!--This still so with ROWS? BTW, I think this is a grave error in the optimizer!-->
          </listitem>
        </itemizedlist>
      </caution>
    </section>

    <section id="langref25-dml-groupby">
      <title><database>GROUP BY</database></title>

      <formalpara>
        <title>Description</title>

        <para><database>GROUP BY</database> merges rows that have the same
        combination of values and/or <constant>NULL</constant>s in the item
        list into a single row. Any aggregate functions in the select list are
        applied to each group individually instead of to the dataset as a
        whole.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>  ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
               | <replaceable>column-alias</replaceable>
               | <replaceable>column-position</replaceable>
               | <replaceable>expression</replaceable></programlisting>

            <itemizedlist>
              <listitem>
                <para>Only non-negative integer <emphasis>literals</emphasis>
                will be interpreted as column positions. If they are outside
                the range from 1 to the number of columns, an error is raised.
                Integer values resulting from expressions or parameter
                substitutions are simply invariables and will be used as such
                in the grouping. They will have no effect though, as their
                value is the same for each row.</para>
              </listitem>

              <listitem>
                <para>A <database>GROUP BY</database> item cannot be a
                reference to an aggregate function (including one that is
                buried inside an expression) from the same context.</para>
              </listitem>

              <listitem>
                <para>The select list may not contain expressions that can
                have different values within a group. To avoid this, the rule
                of thumb is to include each non-aggregate item from the select
                list in the <database>GROUP BY</database> list (whether by
                copying, alias or position).</para>

                <!--Some exceptions and variations are possible, but they could be discussed
later in notes. For instance, a GROUP BY item may be 'narrower' than the
corresponding select item (SELECT upper(ColA) GROUP BY ColA is fine, but
the reverse isn't). Also think of certain subselects, and items that don't
refer to the current context.-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Note</title>

        <para>If you group by a column position, the expression at that
        position is copied internally from the select list. If it concerns a
        subquery, that subquery will be executed at least twice.<!--I suppose the same goes for grouping by aliases?--></para>
      </formalpara>

      <section id="langref25-dml-groupby-extensions">
        <title>Grouping by alias, position and expressions</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.0, 1.5, 2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>In addition to column names, Firebird 2 allows column aliases,
          column positions and arbitrary valid expressions as <database>GROUP
          BY</database> items.</para>
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>These three queries all achieve the same result:</para>

              <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by len_name</programlisting>

              <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by 1</programlisting>

              <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by strlen(lastname)</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>History</title>

          <para>Grouping by UDF results was added in Firebird 1. Grouping by
          column positions, <database>CASE</database> outcomes and a limited
          number of internal functions in Firebird 1.5. Firebird 2 added
          column aliases and expressions in general as valid <database>GROUP
          BY</database> items (<quote>expressions in general</quote> absorbing
          the UDF, <database>CASE</database> and internal functions
          lot).</para>
        </formalpara>
      </section>
    </section>

    <section id="langref25-dml-having-stricter">
      <title><database>HAVING</database>: Stricter rules</title>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>See <link
        linkend="langref25-dml-aggregates-having-orderby"><citetitle>Aggregate
        statements: Stricter <database>HAVING</database> and <database>ORDER
        BY</database></citetitle></link>.</para>
      </formalpara>
    </section>

    <section id="langref25-dml-join">
      <title><database>JOIN</database></title>

      <section id="langref25-dml-join-amb-fields">
        <title>Ambiguous field names rejected</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>InterBase 6 accepts and executes statements like the one
          below, which refers to an unqualified column name even though that
          name exists in both tables participating in the
          <database>JOIN</database>:</para>
        </formalpara>

        <blockquote>
          <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
        </blockquote>

        <para>The results of such a query are unpredictable. Firebird Dialect
        3 returns an error if there are ambiguous field names in
        <database>JOIN</database> statements. Dialect 1 gives a warning but
        will execute the query anyway.</para>
      </section>

      <section id="langref25-dml-join-crossjoin">
        <title><database>CROSS JOIN</database></title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Firebird 2.0 and up support <database>CROSS JOIN</database>,
          which performs a full set multiplication on the tables involved.
          Previously you had to achieve this by joining on a tautology (a
          condition that is always true) or by using the comma syntax, now
          deprecated.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> CROSS JOIN <replaceable>&lt;relation&gt;</replaceable>
   ...

<replaceable>&lt;relation&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
</programlisting>

              <para><emphasis role="bold">Note:</emphasis> If you use
              <database>CROSS JOIN</database>, you can't use
              <database>ON</database>.</para>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select * from Men cross join Women
order by Men.age, Women.age

-- old syntax:
--   select * from Men join Women on 1 = 1
--   order by Men.age, Women.age

-- comma syntax:
--   select * from Men, Women
--   order by Men.age, Women.age</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-join-namedcolsjoin">
        <title>Named columns <database>JOIN</database></title>

        <formalpara>
          <title>Added in</title>

          <para>2.1</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A named columns join is an equi-join on the columns named in
          the <database>USING</database> clause. These columns must exist in
          both relations.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> [<replaceable>&lt;join_type&gt;</replaceable>] JOIN <replaceable>&lt;relation&gt;</replaceable>
   USING (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
   ...

<replaceable>&lt;relation&gt;</replaceable>   ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
<replaceable>&lt;join_type&gt;</replaceable>  ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select *
  from books join shelves
  using (shelf, bookcase)</programlisting>

              <para>The equivalent in traditional syntax:</para>

              <programlisting>select *
  from books b join shelves s
  on b.shelf = s.shelf and b.bookcase = s.bookcase</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>The columns in the USING clause can be selected without
                qualifier. Be aware, however, that doing so in outer joins
                doesn't always give the same result as selecting
                <replaceable>left</replaceable>.<replaceable>colname</replaceable>
                or
                <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
                One of the latter may be <constant>NULL</constant> while the
                other isn't; plain <replaceable>colname</replaceable> always
                returns the non-<constant>NULL</constant> alternative in such
                cases.</para>
              </listitem>

              <listitem>
                <para><database>SELECT</database> * from a named columns join
                returns each <database>USING</database> column only once. In
                outer joins, such a column always contains the
                non-<constant>NULL</constant> alternative except for rows
                where the field is <constant>NULL</constant> in both
                tables.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>

      <section id="langref25-dml-join-natural">
        <title>Natural <database>JOIN</database></title>

        <formalpara>
          <title>Added in</title>

          <para>2.1</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A natural join is an automatic equi-join on all the columns
          that exist in both relations. If there are no common column names, a
          <link linkend="langref25-dml-join-crossjoin"><database>CROSS
          JOIN</database></link> is produced.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> NATURAL [<replaceable>&lt;join_type&gt;</replaceable>] JOIN <replaceable>&lt;relation&gt;</replaceable>
   ...

<replaceable>&lt;relation&gt;</replaceable>   ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
<replaceable>&lt;join_type&gt;</replaceable>  ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select * from Pupils natural left join Tutors</programlisting>

              <para>Assuming that the Pupils and Tutors tables have two field
              names in common: <database>TUTOR</database> and
              <database>CLASS</database>, the equivalent traditional syntax
              is:</para>

              <programlisting>select * from Pupils p left join Tutors t
  on p.tutor = t.tutor and p.class = t.class</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>Common columns can be selected from a natural join
                without qualifier. Beware, however, that doing so in outer
                joins doesn't always gives the same result as selecting
                <replaceable>left</replaceable>.<replaceable>colname</replaceable>
                or
                <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
                One of the latter may be <constant>NULL</constant> while the
                other isn't; plain <replaceable>colname</replaceable> always
                returns the non-<constant>NULL</constant> alternative in such
                cases.</para>
              </listitem>

              <listitem>
                <para><database>SELECT</database> * from a natural join
                returns each common column only once. In outer joins, such a
                column always contains the non-<constant>NULL</constant>
                alternative except for rows where the field is
                <constant>NULL</constant> in both tables.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>

    <section id="langref25-dml-orderby">
      <title><database>ORDER BY</database></title>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langref25-dml-orderby-alias">
        <title>Order by column alias</title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Firebird 2.0 and above support ordering by column
          alias.</para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select rdb$character_set_id as charset_id,
       rdb$collation_id as coll_id,
       rdb$collation_name as name
from rdb$collations
order by charset_id, coll_id</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-order-star-by-colpos">
        <title>Ordering by column position causes * expansion</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>If you order by column position in a
          <quote><database>SELECT</database> *</quote> query, the engine will
          now expand the * to determine the sort column(s).</para>
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>The following wasn't possible in pre-2.0 versions:</para>

              <programlisting>select * from rdb$collations
order by 3, 2</programlisting>

              <para>The following would sort the output set on
              <literal>Films.Director</literal> in previous versions. In
              Firebird 2 and up, it will sort on the second column of
              <literal>Books</literal>:</para>

              <programlisting>select Books.*, Films.Director from Books, Films
order by 2</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-orderby-expr">
        <title>Ordering by expressions</title>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Firebird 1.5 introduced the possibility to use expressions as
          ordering items. Please note that expressions consisting of a single
          non-negative whole number will be interpreted as column positions
          and cause an exception if they're not in the range from 1 to the
          number of columns.</para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select x, y, note from Pairs
order by x+y desc</programlisting>
            </blockquote></para>
        </formalpara>

        <note>
          <para>The number of function or procedure invocations resulting from
          a sort based on a UDF or stored procedure is unpredictable,
          regardless whether the ordering is specified by the expression
          itself or by the column position number.</para>
        </note>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>The number of function or procedure invocations
                resulting from a sort based on a UDF or stored procedure is
                unpredictable, regardless whether the ordering is specified by
                the expression itself or by the column position number.</para>
              </listitem>

              <listitem>
                <para>Only non-negative whole number
                <emphasis>literals</emphasis> are interpreted as column
                positions. A whole number resulting from an expression
                evaluation or parameter substitution is seen as an integer
                invariable and will lead to a dummy sort, since its value is
                the same for each row.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>

        <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->

        <!--Rlsnotes 1.5 say (by Nickolay):

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice? Maybe with ARRAYs?-->
      </section>

      <section id="langref25-dml-orderby-nulls">
        <title><constant>NULL</constant>s placement</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5, 2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Firebird 1.5 has introduced the per-column <database>NULLS
          FIRST</database> and <database>NULLS LAST</database> directives to
          specify where <constant>NULL</constant>s appear in the sorted
          column. Firebird 2.0 has changed the default placement of
          <constant>NULL</constant>s.</para>
        </formalpara>

        <para>Unless overridden by <database>NULLS FIRST</database> or
        <database>NULLS LAST</database>, <constant>NULL</constant>s in ordered
        columns are placed as follows:</para>

        <itemizedlist>
          <listitem>
            <para>In Firebird 1.0 and 1.5: at the end of the sort, regardless
            whether the order is ascending or descending.</para>
          </listitem>

          <listitem>
            <para>In Firebird 2.0 and up: at the <emphasis>start</emphasis> of
            ascending orderings and at the <emphasis>end</emphasis> of
            descending orderings.</para>
          </listitem>
        </itemizedlist>

        <para>See also the table below for an overview of the different
        versions.</para>

        <table id="langref25-dml-tbl-null-placement">
          <title><constant>NULL</constant>s placement in ordered
          columns</title>

          <tgroup cols="4">
            <colspec colname="colStatement" colwidth="2*"/>

            <colspec colname="colPlac10" colwidth="1*"/>

            <colspec colname="colPlac15" colwidth="1*"/>

            <colspec colname="colPlac2" colwidth="1*"/>

            <thead>
              <row valign="top">
                <entry morerows="1">Ordering</entry>

                <entry align="center" nameend="colPlac2"
                namest="colPlac10"><constant>NULL</constant>s
                placement</entry>
              </row>

              <row valign="top">
                <entry align="center">Firebird 1</entry>

                <entry align="center">Firebird 1.5</entry>

                <entry align="center">Firebird 2</entry>
              </row>
            </thead>

            <tbody>
              <row valign="top">
                <entry>order by Field [asc]</entry>

                <entry>bottom</entry>

                <entry>bottom</entry>

                <entry>top</entry>
              </row>

              <row valign="top">
                <entry>order by Field desc</entry>

                <entry>bottom</entry>

                <entry>bottom</entry>

                <entry>bottom</entry>
              </row>

              <row valign="top">
                <entry>order by Field [asc | desc] nulls first</entry>

                <entry>—</entry>

                <entry>top</entry>

                <entry>top</entry>
              </row>

              <row valign="top">
                <entry>order by Field [asc | desc] nulls last</entry>

                <entry>—</entry>

                <entry>bottom</entry>

                <entry>bottom</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <note>
          <title>Notes</title>

          <itemizedlist>
            <listitem>
              <para>Pre-existing databases may need a backup-restore cycle
              before they show the correct <constant>NULL</constant> ordering
              behaviour under Firebird 2.0 and up.</para>

              <!--CHECK! Is this always true, or only when the column is indexed?-->
            </listitem>

            <listitem>
              <para>No index will be used on columns for which a non-default
              <constant>NULLS</constant> placement is chosen. In Firebird 1.5,
              that is the case with <database>NULLS FIRST</database>. In 2.0
              and higher, with <database>NULLS LAST</database> on ascending
              and <database>NULLS FIRST</database> on descending sorts.</para>
            </listitem>
          </itemizedlist>
        </note>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>

              <programlisting>select * from document
  order by strlen(description) desc
  rows 10</programlisting>

              <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-orderby-stricter">
        <title>Stricter ordering rules with aggregate statements</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>See <link
          linkend="langref25-dml-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
    </section>

    <section id="langref25-dml-select-plan">
      <title><database>PLAN</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Specifies a user plan for the data retrieval, overriding the
        plan that the optimizer would have generated automatically.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <para><!--This is (a modified view of) the syntax as given in the IB6 LangRef, with the
Fb 2.0 extension of optionally providing an INDEX list after ORDER:--><programlisting>PLAN <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;plan_expr&gt;</replaceable>   ::=  [JOIN | [SORT] [MERGE]] (<replaceable>&lt;plan_item&gt;</replaceable> [, <replaceable>&lt;plan_item&gt;</replaceable> ...])

<replaceable>&lt;plan_item&gt;</replaceable>   ::=  <replaceable>&lt;basic_item&gt;</replaceable> | <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;basic_item&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>alias</replaceable>}
                   {NATURAL
                    | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>))
                    | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;indexlist&gt;</replaceable>   ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]</programlisting><!--The syntax given in the 2.0 Rlsnotes differs considerably, but contains at
least some errors. However, the same is probably true for the above.
Points to investigate wrt syntax in Rlsnotes 2.0:
- Must MERGE always take place on *exactly* 2 streams?
- Must MERGE always take place on explicitly SORTed streams?

Points to improve in the syntax above (either in the syntax itself, or
in notes):
- With JOIN and MERGE, the number of plan_items must be at least 2.--></para>
          </blockquote></para>
      </formalpara>

      <section id="langref25-dml-select-plan-improved">
        <title>Handling of user <database>PLAN</database>s improved</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Firebird 2 has implemented the following improvements in the
          handling of user-specified <database>PLAN</database>s:<itemizedlist>
              <listitem>
                <para>Plan fragments are propagated to nested levels of joins,
                enabling manual optimization of complex outer joins.</para>
              </listitem>

              <listitem>
                <para>User-supplied plans will be checked for correctness in
                outer joins.</para>
              </listitem>

              <listitem>
                <para>Short-circuit optimization for user-supplied plans has
                been added.</para>
              </listitem>

              <listitem>
                <para>A user-specified access path can be supplied for any
                <database>SELECT</database>-based statement or clause.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>

      <section id="langref25-dml-select-plan-order-index">
        <title><database>ORDER</database> with
        <database>INDEX</database></title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A single plan item can now contain both an
          <database>ORDER</database> and an <database>INDEX</database>
          directive (in that order).</para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>plan (MyTable order ix_myfield index (ix_this, ix_that))</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-select-plan-alltables">
        <title><database>PLAN</database> must include all tables</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>In Firebird 2 and up, a <database>PLAN</database> clause must
          handle all the tables in the query. Previous versions sometimes
          accepted incomplete plans, but this is no longer the case.</para>
        </formalpara>
      </section>
    </section>

    <section id="langref25-dml-select-alias-use">
      <title>Relation alias makes real name unavailable</title>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>If you give a table or view an alias in a Firebird 2.0 or above
        statement, you <emphasis>must</emphasis> use the alias, not the table
        name, if you want to qualify fields from that relation.</para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>Correct usage:</para>

            <programlisting>select pears from Fruit</programlisting>

            <programlisting>select Fruit.pears from Fruit</programlisting>

            <programlisting>select pears from Fruit F</programlisting>

            <programlisting>select F.pears from Fruit F</programlisting>

            <para>No longer possible:</para>

            <programlisting>select Fruit.pears from Fruit F</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-select-rows">
      <title><database>ROWS</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Limits the amount of rows returned by the
        <database>SELECT</database> statement to a specified number or
        range.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <para>With a single <database>SELECT</database>:</para>

            <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;columns&gt;</replaceable>  ::=  The usual output column specifications.
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>   ::=  Any expression evaluating to an integer.</programlisting>

            <para>With a <database>UNION</database>:</para>

            <programlisting>SELECT [FIRST <replaceable>p</replaceable>] [SKIP <replaceable>q</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ... [WHERE ...]
UNION [ALL | DISTINCT]
SELECT [FIRST <replaceable>r</replaceable>] [SKIP <replaceable>s</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ... [WHERE ...]
[ORDER BY ...]
ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]</programlisting>
          </blockquote></para>
      </formalpara>

      <para>With a single argument <replaceable>m</replaceable>, the first
      <replaceable>m</replaceable> rows of the dataset are returned.</para>

      <para>Points to note:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, an empty set is
          returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, rows <replaceable>m</replaceable> to
      <replaceable>n</replaceable> of the dataset are returned, inclusively.
      Row numbers are 1-based.</para>

      <para>Points to note when using two arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, an empty set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, an empty set is returned.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->

      <para>The SQL-compliant <database>ROWS</database> syntax obviates the
      need for <link
      linkend="langref25-dml-first-skip"><database>FIRST</database> and
      <database>SKIP</database></link>, except in one case: a
      <database>SKIP</database> without <database>FIRST</database>, which
      returns the entire remainder of the set after skipping a given number of
      rows. (You can often <quote>fake it</quote> though, by supplying a
      second argument that you know to be bigger than the number of rows in
      the set.)</para>

      <para>You cannot use <database>ROWS</database> together with
      <database>FIRST</database> and/or <database>SKIP</database> in a single
      <database>SELECT</database> statement, but is it valid to use one form
      in the top-level statement and the other in subselects, or to use the
      two syntaxes in different subselects.</para>

      <para>When used with a <database>UNION</database>, the
      <database>ROWS</database> subclause applies to the UNION as a whole and
      must be placed after the last <database>SELECT</database>. If you want
      to limit the output of one or more individual
      <database>SELECT</database>s within the <database>UNION</database>, you
      have two options: either use
      <database>FIRST</database>/<database>SKIP</database> on those
      <database>SELECT</database> statements (probably of limited use, as you
      can't use <database>ORDER BY</database> on individual selects within a
      union), or convert them to <link
      linkend="langref25-dml-derived-tables">derived tables</link> with
      <database>ROWS</database> clauses.</para>

      <!--Dmitry's SELECT syntax in the 2.0 Rlsnotes is incorrect here, as it states that you can use ROWS on every SELECT in a UNION. Let him know!-->

      <para><database>ROWS</database> can also be used with the <link
      linkend="langref25-dml-update"><database>UPDATE</database></link> and
      <link linkend="langref25-dml-delete"><database>DELETE</database></link>
      statements.</para>

      <!--SKIP and FIRST can be used - and could already in 1.5 - with UNIONs and in subqueries, even though the 2.0 RlsNotes seem to suggest otherwise.-->
    </section>

    <section id="langref25-dml-union">
      <title><database>UNION</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <section id="langref25-dml-union-in-subqueries">
        <title><database>UNION</database>s in subqueries</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>UNION</database>s are now allowed in subqueries.
          This applies not only to column-level subqueries in a
          <database>SELECT</database> list, but also to subqueries in
          <database>ANY</database>|<database>SOME</database>,
          <database>ALL</database> and <database>IN</database> predicates, as
          well as the optional <database>SELECT</database> expression that
          feeds an <database>INSERT</database>.</para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langref25-dml-union-distinct">
        <title><database>UNION DISTINCT</database></title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>You can now use the optional <database>DISTINCT</database>
          keyword when defining a <database>UNION</database>. This will show
          duplicate rows only once instead of every time they occur in one of
          the tables. Since <database>DISTINCT</database>, being the opposite
          of <database>ALL</database>, is the default mode anyway, this
          doesn't add any new functionality.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT (...) FROM (...)
UNION [DISTINCT | ALL]
SELECT (...) FROM (...)</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select name, phone from translators
  union distinct
select name, phone from proofreaders</programlisting>

              <para>Translators who also work as proofreaders (a not uncommon
              combination) will show up only once in the result set, provided
              their phone number is the same in both tables. The same result
              would have been obtained without <database>DISTINCT</database>.
              With <database>ALL</database>, they would appear twice.</para>
            </blockquote></para>
        </formalpara>
      </section>
    </section>

    <section id="langref25-dml-with-lock">
      <title><database>WITH LOCK</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no support found in sources-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description:</title>

        <para><database>WITH LOCK</database> provides a limited explicit
        pessimistic locking capability for cautious use in conditions where
        the affected row set is:<orderedlist numeration="loweralpha"
            spacing="compact">
            <listitem>
              <para>extremely small (ideally, a singleton),
              <emphasis>and</emphasis></para>
            </listitem>

            <listitem>
              <para>precisely controlled by the application code.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>

      <caution>
        <title>This is for experts only!</title>

        <para>The need for a pessimistic lock in Firebird is very rare indeed
        and should be well understood before use of this extension is
        considered.</para>

        <para>It is essential to understand the effects of transaction
        isolation and other transaction attributes before attempting to
        implement explicit locking in your application.</para>
      </caution>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
          </blockquote></para>
      </formalpara>

      <para>If the <database>WITH LOCK</database> clause succeeds, it will
      secure a lock on the selected rows and prevent any other transaction
      from obtaining write access to any of those rows, or their dependants,
      until your transaction ends.</para>

      <para>If the <database>FOR UPDATE</database> clause is included, the
      lock will be applied to each row, one by one, as it is fetched into the
      server-side row cache. It becomes possible, then, that a lock which
      appeared to succeed when requested will nevertheless <emphasis>fail
      subsequently</emphasis>, when an attempt is made to fetch a row which
      becomes locked by another transaction.</para>

      <para><database>WITH LOCK</database> can only be used with a top-level,
      single-table <database>SELECT</database> statement. It is
      <emphasis>not</emphasis> available:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification;</para>
        </listitem>

        <listitem>
          <para>for joined sets;</para>
        </listitem>

        <listitem>
          <para>with the <database>DISTINCT</database> operator, a
          <database>GROUP BY</database> clause or any other aggregating
          operation;</para>
        </listitem>

        <listitem>
          <para>with a view;</para>
        </listitem>

        <listitem>
          <para>with the output of a selectable stored procedure;</para>
        </listitem>

        <listitem>
          <para>with an external table.</para>
        </listitem>

        <!--With a UNION, in my experience-->
      </itemizedlist>

      <para>A lengthier, more in-depth discussion of <quote><database>SELECT
      ... WITH LOCK</database></quote> is included in the <link
      linkend="langref25-notes-withlock">Notes</link>. It is a must-read for
      everybody who considers using this feature.</para>
    </section>
  </section>

  <section id="langref25-dml-update">
    <title><database>UPDATE</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Description</title>

      <para>Changes values in a table or in one or more tables underlying a
      view. The columns affected are specified in the <database>SET</database>
      clause; the rows affected may be limited by the
      <database>WHERE</database> and <database>ROWS</database> clauses. If
      neither <database>WHERE</database> nor <database>ROWS</database> is
      present, all the records in the table will be updated.</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>UPDATE [TRANSACTION <replaceable>name</replaceable>] <replaceable>target</replaceable> [[AS] <replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>target</replaceable>       ::=  A table or updatable view
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <listitem>
                <para>The <database>TRANSACTION</database> directive is only
                available in ESQL.</para>
              </listitem>

              <listitem>
                <para>In a pure DSQL session, <database>WHERE CURRENT
                OF</database> isn't of much use, since there exists no DSQL
                statement to create a cursor.</para>
              </listitem>

              <listitem>
                <para>No column may be <database>SET</database> more than once
                in the same <database>UPDATE</database> statement.</para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When returning values into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (<quote><literal>:</literal></quote>).</para>
              </listitem>

              <listitem>
                <para>The <database>PLAN</database>, <database>ORDER
                BY</database>, <database>ROWS</database> and
                <database>RETURNING</database> clauses are not available in
                ESQL.</para>
              </listitem>
            </itemizedlist>
          </note>

          <!--Are only loose plan_items allowed, or also JOIN, SORT, MERGE ?-->
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-update-alias-use">
      <title>Using an alias</title>

      <para>If you give a table or view an alias, you
      <emphasis>must</emphasis> use the alias, not the table name, if you want
      to qualify fields from that relation.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>Correct usage:</para>

            <programlisting>update Fruit set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit set Fruit.soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set F.soort = 'pisang' where ...</programlisting>

            <para>Not possible:</para>

            <programlisting>update Fruit F set Fruit.soort = 'pisang' where ...</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langref25-dml-update-set">
      <title>The <database>SET</database> clause</title>

      <para>The <database>SET</database> clause specifies the values to be
      written to the affected row(s). It is a comma-separated list of
      assignments, each with a column name on the left hand side and a value
      expression on the right hand side.</para>

      <para>String literals may optionally be preceded by a character set
      name, using <firstterm>introducer syntax</firstterm>, in order to let
      the engine know how to interpret the input.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>update addresses
  set city = 'Saint Petersburg', citycode = 'PET'
  where city = 'Leningrad'</programlisting>

            <programlisting>update employees
  set salary = 2.5 * salary
  where title = 'CEO'</programlisting>

            <programlisting>update People
  set name = _ISO8859_1 'Hans-Jörg Schäfer'  -- notice the '_' prefix
  where id = 53662</programlisting>
          </blockquote></para>
      </formalpara>

      <para>It is perfectly legal to include target columns in the value
      expressions on the right hand side, providing values for themselves
      and/or other columns. If this is done, the value used on the right hand
      side will always be the <emphasis>old</emphasis> column value, even if
      an assignment has already been made to the same column earlier in the
      list. The following example illustrates this.</para>

      <para>Given table <database>TSET</database>:</para>

      <blockquote>
        <programlisting>A  B
----
1  0
2  0</programlisting>
      </blockquote>

      <para>the following statement:</para>

      <blockquote>
        <programlisting>update tset set a=5, b=a</programlisting>
      </blockquote>

      <para>will change its state to</para>

      <blockquote>
        <programlisting>A  B
----
5  1
5  2</programlisting>
      </blockquote>

      <para>Notice how the old values of <varname>a</varname> (1 and 2) are
      used for the update of <varname>b</varname>, even though
      <varname>a</varname> itself has already been assigned a new value
      (5).</para>

      <note>
        <para>This has not always been the case. In pre-2.5 versions of
        Firebird, new column values became immediately available for
        subsequent assignments in the list. This is non-standard behaviour;
        hence it has been changed.</para>

        <para>However, if the <parameter>OldSetClauseSemantics</parameter>
        parameter in <filename>firebird.conf</filename> has been set to 1,
        Firebird will continue to show the old behaviour. This parameter will
        be deprecated and removed somewhere in the future.</para>
      </note>
    </section>

    <section id="langref25-dml-update-where">
      <title>The <database>WHERE</database> clause</title>

      <para>A <database>WHERE</database> clause limits the update action to
      the rows matching the search condition, or – in ESQL and PSQL only – to
      the current row of a named cursor.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>update People set firstname = 'Boris' where lastname = 'Johnson'</programlisting>

            <programlisting>update Cities set name = :arg_name where current of Cur_Cities;  -- ESQL and PSQL only</programlisting>
          </blockquote></para>
      </formalpara>

      <para>An update using <database>WHERE CURRENT OF</database> is called a
      <firstterm>positioned update</firstterm>, because it updates the record
      at the current position. An update using
      <quote><database>WHERE</database>
      <replaceable>&lt;condition&gt;</replaceable></quote> is called a
      <firstterm>searched update</firstterm>, because the engine has to search
      for the record(s) meeting the condition.</para>
    </section>

    <section id="langref25-dml-update-orderby-rows">
      <title><database>ORDER BY</database> and
      <database>ROWS</database></title>

      <para>If at all, <database>ORDER BY</database> and
      <database>ROWS</database> only make sense when used together. However,
      they are also valid separately.</para>

      <para>With a single argument <replaceable>m</replaceable>,
      <database>ROWS</database> limits the update to the first
      <replaceable>m</replaceable> rows of the dataset defined by the table or
      view and the optional <database>WHERE</database> and <database>ORDER
      BY</database> clauses.</para>

      <para>With two arguments <replaceable>m</replaceable> and
      <replaceable>n</replaceable>, the update is limited to rows
      <replaceable>m</replaceable> to <replaceable>n</replaceable>
      inclusively. Row numbers are 1-based.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>-- give the 20 poorest guys a break:
update employees
  set salary = salary + 50
  order by salary asc
  rows 20</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Points to note when using <database>ROWS</database> with one
      argument:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, the entire set is updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> = 0, no rows are
          updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 0, an error is
          raised.</para>
        </listitem>
      </itemizedlist>

      <para>Points to note when using <database>ROWS</database> with two
      arguments:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If <replaceable>m</replaceable> &gt; the total number of rows
          in the dataset, no rows are updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> lies within the set but
          <replaceable>n</replaceable> doesn't, the rows from
          <replaceable>m</replaceable> to the end of the set are
          updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>m</replaceable> &lt; 1 or
          <replaceable>n</replaceable> &lt; 1, an error is raised.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> =
          <replaceable>m</replaceable>-1, no rows are updated.</para>
        </listitem>

        <listitem>
          <para>If <replaceable>n</replaceable> &lt;
          <replaceable>m</replaceable>-1, an error is raised.</para>
        </listitem>
      </itemizedlist>

      <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
    </section>

    <section id="langref25-dml-update-returning">
      <title><database>RETURNING</database></title>

      <para>An <database>UPDATE</database> statement modifying <emphasis>at
      most one row</emphasis> may optionally include a
      <database>RETURNING</database> clause in order to return values from the
      updated row. The clause, if present, need not contain all the modified
      columns and may also contain other columns or expressions. The returned
      values reflect any changes that may have been made in
      <database>BEFORE</database> triggers, but not those in
      <database>AFTER</database> triggers.
      <database>OLD</database>.<replaceable>fieldname</replaceable> and
      <database>NEW</database>.<replaceable>fieldname</replaceable> may both
      be used in the list of columns to return; for field names not preceded
      by either of these, the new value is returned.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>update Scholars
  set firstname = 'Hugh', lastname = 'Pickering'
  where firstname = 'Henry' and lastname = 'Higgins'
  returning id, old.lastname, new.lastname</programlisting>
          </blockquote></para>
      </formalpara>

      <para>In DSQL, a statement with a <database>RETURNING</database> clause
      <emphasis role="">always</emphasis> returns exactly one row. If no
      record was actually updated, the fields in this row are all
      <constant>NULL</constant>. This behaviour may change in a later version
      of Firebird. In PSQL, if no row was updated, nothing is returned, and
      the target variables keep their existing values.</para>
    </section>

    <section id="langref25-dml-update-blob">
      <title>Updating <database>BLOB</database> columns</title>

      <para>Updating a <database>BLOB</database> column always replaces the
      entire contents. Even the <database>BLOB</database> ID, the
      <quote>handle</quote> that is stored directly in the column, is changed.
      <database>BLOB</database>s can be updated if:</para>

      <orderedlist>
        <listitem>
          <para>The client application has made special provisions for this
          operation, using the Firebird API. In this case, the modus operandi
          is application-specific and outside the scope of this manual.</para>
        </listitem>

        <listitem>
          <para>The new value is a text string of at most 32767 bytes. Please
          notice: if the value is not a string literal, beware of
          concatenations, as these may exceed the maximum length.</para>
        </listitem>

        <listitem>
          <para>The source is itself a <database>BLOB</database> column or,
          more generally, an expression that returns a
          <database>BLOB</database>.</para>
        </listitem>

        <listitem>
          <para>You use the <link
          linkend="langref25-dml-insert_cursor"><database>INSERT
          CURSOR</database></link> statement (ESQL only).</para>
        </listitem>
      </orderedlist>
    </section>
  </section>

  <section id="langref25-dml-update-or-insert">
    <title><database>UPDATE OR INSERT</database></title>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, PSQL</para>

      <!--ESQL ? Guess not, readme says: Scope: DSQL, PSQL-->
    </formalpara>

    <para><database>UPDATE OR INSERT</database> inserts a new record or
    updates one or more existing records. The action taken depends on the
    values provided for the columns in the <database>MATCHING</database>
    clause (or, if the latter is absent, in the primary key). If there are
    records found matching those values, they are updated. If not, a new
    record is inserted.</para>

    <para>A match only counts if all the values in the
    <database>MATCHING</database> or <database>PK</database> columns are
    equal. Matching is done with the <link
    linkend="langref25-distinct"><database>IS NOT DISTINCT</database></link>
    operator, so one <constant>NULL</constant> matches another.</para>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>UPDATE OR INSERT INTO
   {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [(<replaceable>&lt;columns&gt;</replaceable>)]
   VALUES (<replaceable>&lt;values&gt;</replaceable>)
   [MATCHING (<replaceable>&lt;columns&gt;</replaceable>)]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;columns&gt;</replaceable>      ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;values&gt;</replaceable>       ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>    ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

          <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->

          <note>
            <title>Restrictions</title>

            <itemizedlist spacing="compact">
              <listitem>
                <para>If the table has no <database>PK</database>, the
                <database>MATCHING</database> clause becomes mandatory.</para>
              </listitem>

              <listitem>
                <para>In the <database>MATCHING</database> list as well as in
                the update/insert column list, each column name may occur only
                once.</para>
              </listitem>

              <listitem>
                <para>The <quote><database>INTO</database>
                <replaceable>&lt;variables&gt;</replaceable></quote> subclause
                is only available in PSQL.</para>
              </listitem>

              <listitem>
                <para>When values are returned into the context variable
                <database>NEW</database>, this name must not be preceded by a
                colon (<quote><literal>:</literal></quote>).</para>
              </listitem>
            </itemizedlist>
          </note>
        </blockquote></para>
    </formalpara>

    <formalpara>
      <title>Example</title>

      <para><blockquote>
          <programlisting>update or insert into Cows (Name, Number, Location)
  values ('Suzy Creamcheese', 3278823, 'Green Pastures')
  matching (Number)
  returning rec_id into :id;</programlisting>
        </blockquote></para>
    </formalpara>

    <section id="langref25-dml-update-or-insert-returning">
      <title>The <database>RETURNING</database> clause</title>

      <para>The optional <database>RETURNING</database> clause, if present,
      need not contain all the columns mentioned in the statement and may also
      contain other columns or expressions. The returned values reflect any
      changes that may have been made in <database>BEFORE</database> triggers,
      but not those in <database>AFTER</database> triggers.
      <database>OLD</database>.<replaceable>fieldname</replaceable> and
      <database>NEW</database>.<replaceable>fieldname</replaceable> may both
      be used in the list of columns to return; for field names not preceded
      by either of these, the new value is returned.</para>

      <para>In DSQL, a statement with a <database>RETURNING</database> clause
      <emphasis role="">always</emphasis> returns exactly one row. If a
      <database>RETURNING</database> clause is present and more than one
      matching record is found, an error is raised. This behaviour may change
      in a later version of Firebird.</para>
    </section>
  </section>
</chapter>
