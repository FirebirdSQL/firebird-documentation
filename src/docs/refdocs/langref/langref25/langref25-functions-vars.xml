<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="langref25-functions">
  <title>Built-in functions and variables</title>
  <section id="langref25-functions-contextvars">
    <title>Context variables</title>
  

		<section id="langref25-contextvars-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_CONNECTION</varname> contains the unique identifier of the current
        connection.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page
      and reset to 0 upon restore. Since version 2.1, it is incremented upon every new connection.
      (In previous versions, it was only incremented if the client read it during a session.) As a
      result, <varname>CURRENT_CONNECTION</varname> now indicates the number of connections since
      the creation – or most recent restoration – of the database.</para>
    </section>
    <section id="langref25-contextvars-current_date">
      <title><varname>CURRENT_DATE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_DATE</varname> returns the current server date.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>DATE</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_DATE</programlisting>
        </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_date from rdb$database
-- returns e.g. 2011-10-03</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_DATE</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langref25-contextvars-today"><literal>'TODAY'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

		<section id="langref25-contextvars-current_role">
		  <title><varname>CURRENT_ROLE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the
        currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is
        <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><varname>CURRENT_ROLE</varname> always represents a valid role or
      <database>NONE</database>. If a user connects with a non-existing role, the engine silently
      resets it to <database>NONE</database> without returning an error.</para>
		</section>

    <section id="langref25-contextvars-current_time">
      <title><varname>CURRENT_TIME</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIME</varname> returns the current server time. In versions prior to
        2.0, the fractional part used to be always <quote><literal>.0000</literal></quote>, giving
        an effective precision of 0 decimals. From Firebird 2.0 onward you can specify a precision
        when polling this variable. The default is still 0 decimals, i.e. seconds precision.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIME</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIME [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_time from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select current_time(2) from rdb$database
-- returns e.g. 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Unlike <varname>CURRENT_TIME</varname>, the default precision of
              <varname>CURRENT_TIMESTAMP</varname> has changed to 3 decimals. As a result,
              <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum of
              <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIME</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langref25-contextvars-now"><literal>'NOW'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-current_timestamp">
      <title><varname>CURRENT_TIMESTAMP</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIMESTAMP</varname> returns the current server date and time. In
        versions prior to 2.0, the fractional part used to be always
        <quote><literal>.0000</literal></quote>, giving an effective precision of 0 decimals. From
        Firebird 2.0 onward you can specify a precision when polling this variable. The default is 3
        decimals, i.e. milliseconds precision.<!--This new functionality also available in ESQL? Dimtry says about the new ms precision:
"I believe it should be supported automagically." About the precision arg: "Not supported."--></para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIMESTAMP [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_timestamp from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <programlisting>select current_timestamp(2) from rdb$database
-- returns e.g. 2008-08-13 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The default precision of <varname>CURRENT_TIME</varname> is still 0 decimals, so
              in Firebird 2.0 and up <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum
              of <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIMESTAMP</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langref25-contextvars-now"><literal>'NOW'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TRANSACTION</varname> contains the unique identifier of the current
        transaction.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header
      page and reset to 0 upon restore. It is incremented with every new transaction.</para>
    </section>
    <section id="langref25-contextvars-current_user">
      <title><varname>CURRENT_USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <link linkend="langref25-contextvars-user"><database>USER</database></link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-deleting">
      <title><varname>DELETING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired
        because of a <database>DELETE</database> operation. Intended for use in <link
        linkend="langref25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-gdscode">
      <title><varname>GDSCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>GDSCODE</varname> context variable contains the numerical representation of the
        current Firebird error code. Prior to Firebird 2.0, <varname>GDSCODE</varname> was only set
        in <database>WHEN GDSCODE</database> handlers. Now it may also be non-zero in <database>WHEN
        ANY</database>, <database>WHEN SQLCODE</database> and <database>WHEN EXCEPTION</database>
        blocks, provided that the condition raising the error corresponds with a Firebird error
        code. Outside error handlers, <varname>GDSCODE</varname> is always 0. Outside PSQL it
        doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when gdscode grant_obj_notfound, gdscode grant_fld_notfound,
     gdscode grant_nopriv, gdscode grant_nopriv_on_base
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Please notice: After <database>WHEN GDSCODE</database>, you must use symbolic names like
      <errorcode>grant_obj_notfound</errorcode> etc. But the <varname>GDSCODE</varname> context
      variable is an <database>INTEGER</database>. If you want to compare it against a certain
      error, you have to use the numeric value, e.g. 335544551 for
      <errorcode>grant_obj_notfound</errorcode>.</para>
    </section>
    <section id="langref25-contextvars-inserting">
      <title><varname>INSERTING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger
        fired because of an <database>INSERT</database> operation. Intended for use in <link
        linkend="langref25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-new">
      <title><varname>NEW</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>NEW</varname> contains the new version of a database record that has just
        been inserted or updated. Starting with Firebird 2.0 it is read-only in
        <database>AFTER</database> triggers.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>NEW</varname> is
        always available. But if the trigger is fired by a <database>DELETE</database>, there will
        be no new version of the record. In that situation, reading from <varname>NEW</varname> will
        always return <constant>NULL</constant>; writing to it will cause a runtime
        exception.</para>
      </note>
    </section>
    <section id="langref25-contextvars-now">
      <title><literal>'NOW'</literal></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><literal>'NOW'</literal> is not a variable but a string literal. It is, however,
        special in the sense that when you <database>CAST()</database> it to a date/time type, you
        will get the current date and/or time. The fractional part of the time used to be always
        <quote><literal>.0000</literal></quote>, giving an effective seconds precision. Since
        Firebird 2.0 the precision is 3 decimals, i.e. milliseconds. <literal>'NOW'</literal> is
        case-insensitive, and the engine ignores leading or trailing spaces when casting.</para>
	      <formalpara>
	        <title>Note</title>
	        <para>Please be advised that these shorthand expressions are evaluated immediately at parse
	        time and stay the same as long as the statement remains prepared. Thus, even if a query is
	        executed multiple times, the value for e.g. <quote>timestamp 'now'</quote> won't change, no
	        matter how much time passes. If you need the value to progress (i.e. be evaluated upon every
	        call), use a full cast.</para>
	      </formalpara>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(3)</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select 'Now' from rdb$database
-- returns 'Now'</programlisting>
            <programlisting>select cast('Now' as date) from rdb$database
-- returns e.g. 2008-08-13</programlisting>
            <programlisting>select cast('now' as time) from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select cast('NOW' as timestamp) from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <para><link linkend="langref25-shorthandcast">Shorthand syntax</link> for the last
            three statements:</para>
            <programlisting>select date 'Now' from rdb$database
select time 'now' from rdb$database
select timestamp 'NOW' from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><literal>'NOW'</literal> always returns the actual date/time, even in PSQL
              modules, where <varname>CURRENT_DATE</varname>, <link
              linkend="langref25-contextvars-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langref25-contextvars-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              return the same value throughout the duration of the outermost routine. This makes
              <literal>'NOW'</literal> useful for measuring time intervals in triggers, procedures
              and executable blocks.</para>
            </listitem>
            <listitem>
              <para>Except in the situation mentioned above, reading
              <varname>CURRENT_DATE</varname>, <link
              linkend="langref25-contextvars-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langref25-contextvars-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              is generally preferable to casting <literal>'NOW'</literal>. Be aware though that
              <varname>CURRENT_TIME</varname> defaults to seconds precision; to get milliseconds
              precision, use <varname>CURRENT_TIME</varname>(<parameter>3</parameter>).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-old">
      <title><varname>OLD</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>OLD</varname> contains the existing version of a database record just before
        a deletion or update. Starting with Firebird 2.0 it is read-only.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>OLD</varname> is
        always available. But if the trigger is fired by an <database>INSERT</database>, there is
        obviously no pre-existing version of the record. In that situation, reading from
        <varname>OLD</varname> will always return <constant>NULL</constant>; writing to it will
        cause a runtime exception.</para>
      </note>
    </section>
    <section id="langref25-contextvars-row_count">
      <title><varname>ROW_COUNT</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <varname>ROW_COUNT</varname> context variable contains the number of rows affected
        by the most recent DML statement (<database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database>, <database>SELECT</database> or <database>FETCH</database>) in
        the current trigger, stored procedure or executable block.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Behaviour with <database>SELECT</database> and <database>FETCH<!--Better make this a table!--></database></title>
        <para><itemizedlist>
            <listitem>
              <para>After a singleton <database>SELECT</database>, <varname>ROW_COUNT</varname> is 1
              if a data row was retrieved and 0 otherwise.</para>
            </listitem>
            <listitem>
              <para>In a <database>FOR SELECT</database> loop, <varname>ROW_COUNT</varname> is
              incremented with every iteration (starting at 0 before the first).</para>
            </listitem>
            <listitem>
              <para>After a <database>FETCH</database> from a cursor, <varname>ROW_COUNT</varname>
              is 1 if a data row was retrieved and 0 otherwise. Fetching more records from the same
              cursor does <emphasis>not</emphasis> increment <varname>ROW_COUNT</varname> beyond
              1.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.<replaceable>x</replaceable>, <varname>ROW_COUNT</varname> is 0
              after any type of <database>SELECT</database> statement.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <note>
        <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows affected
        by an <database>EXECUTE STATEMENT</database> or <database>EXECUTE PROCEDURE
        </database>command.</para>
      </note>
    </section>
    <section id="langref25-contextvars-sqlcode">
      <title><varname>SQLCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Deprecated in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>SQLCODE</varname> context variable contains the current SQL error code. Prior to
        Firebird 2.0, <varname>SQLCODE</varname> was only set in <database>WHEN SQLCODE</database>
        and <database>WHEN ANY</database> handlers. Now it may also be non-zero in <database>WHEN
        GDSCODE</database> and <database>WHEN EXCEPTION</database> blocks, provided that the
        condition raising the error corresponds with an SQL error code. Outside error handlers,
        <varname>SQLCODE</varname> is always 0. Outside PSQL it doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Important notice</title>
        <para><varname>SQLCODE</varname> is now deprecated in favour of the SQL-2003-compliant <link
        linkend="langref25-contextvars-sqlstate"><citetitle><varname>SQLSTATE</varname></citetitle></link>
        status code. Support for <varname>SQLCODE</varname> and <database>WHEN SQLCODE</database>
        will be discontinued in some future version of Firebird.</para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-sqlstate">
      <title><varname>SQLSTATE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handler, the
        <varname>SQLSTATE</varname> context variable contains the 5-character, SQL-2003-compliant
        status code resulting from the statement that raised the error. Outside error handlers,
        <varname>SQLSTATE</varname> is always '00000'. Outside PSQL it is not available at
        all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  Msg = case sqlstate
          when '22003' then 'Numeric value out of range.'
          when '22012' then 'Division by zero.'
          when '23000' then 'Integrity constraint violation.'
          else 'Something bad happened! SQLSTATE = ' || sqlstate
        end;  
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><database>SQLSTATE</database> is destined to replace
              <database>SQLCODE</database>. The latter is now deprecated in Firebird and will
              disappear in some future version.</para>
            </listitem>
            <listitem>
              <para>Firebird does not (yet) support the syntax <quote><database>WHEN SQLSTATE ...
              DO</database></quote>. You have to use <database>WHEN ANY</database> and test the
              <varname>SQLSTATE</varname> variable within the handler.</para>
              <!--Request for improvement CORE-3526-->
            </listitem>
            <listitem>
              <para>Each <database>SQLSTATE</database> code is the concatenation of a 2-character
              class and a 3-character subclass. Classes 00 (successful completion), 01 (warning) and
              02 (no data) represent <firstterm>completion conditions</firstterm>. Every status code
              outside these classes is an <firstterm>exception</firstterm>. Because classes 00, 01
              and 02 don't raise an error, they won't ever show up in the
              <varname>SQLSTATE</varname> variable.</para>
            </listitem>
            <listitem>
              <para>For a complete listing of <database>SQLSTATE</database> codes, consult the
              <ulink
              url="http://www.firebirdsql.org/rlsnotesh/rlsnotes25.html#rnfb25-appx-sqlstates"><citetitle>Appendix
              to the Firebird 2.5 Release Notes</citetitle></ulink>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
		<section id="langref25-contextvars-today">
		  <title><literal>'TODAY'</literal></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL, ESQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><literal>'TODAY'</literal> is not a variable but a string literal. It is, however,
		    special in the sense that when you <database>CAST()</database> it to a date/time type, you
		    will get the current date. 
		<literal>'TODAY'</literal> is case-insensitive, and the engine ignores leading or trailing spaces when casting.</para>
		  </formalpara>
		  <formalpara>
		    <title>Type</title>
		    <para><database>CHAR(5)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select 'Today' from rdb$database
		-- returns 'Today'</programlisting>
		        <programlisting>select cast('Today' as date) from rdb$database
		-- returns e.g. 2011-10-03</programlisting>
		        <programlisting>select cast('TODAY' as timestamp) from rdb$database
		-- returns e.g. 2011-10-03 00:00:00.0000</programlisting>
		        <para><link linkend="langref25-shorthandcast">Shorthand syntax</link> for the last
		        two statements:</para>
		        <programlisting>select date 'Today' from rdb$database
		select timestamp 'TODAY' from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Notes</title>
		    <para><itemizedlist>
		        <listitem>
		          <para><literal>'TODAY'</literal> always returns the actual date, even in PSQL
		          modules, where <varname>CURRENT_DATE</varname>, <link
		          linkend="langref25-contextvars-current_time"><varname>CURRENT_TIME</varname></link> and <link
		          linkend="langref25-contextvars-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
		          return the same value throughout the duration of the outermost routine. This makes
		          <literal>'TODAY'</literal> useful for measuring time intervals in triggers, procedures
		          and executable blocks (at least if your procedures are running for days).</para>
		        </listitem>
		        <listitem>
		          <para>Except in the situation mentioned above, reading
		          <varname>CURRENT_DATE</varname>, is generally preferable to casting <literal>'NOW'</literal>. </para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		</section>
		<section id="langref25-contextvars-tomorrow">
		  <title><literal>'TOMORROW'</literal></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL, ESQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><literal>'TOMORROW'</literal> is not a variable but a string literal. It is, however,
		    special in the sense that when you <database>CAST()</database> it to a date/time type, you
		    will get the date of the next day. See also <link
        linkend="langref25-contextvars-today"><varname>'TODAY'</varname></link>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Type</title>
		    <para><database>CHAR(8)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select 'Tomorrow' from rdb$database
		-- returns 'Tomorrow'</programlisting>
		        <programlisting>select cast('Tomorrow' as date) from rdb$database
		-- returns e.g. 2011-10-04</programlisting>
		        <programlisting>select cast('TOMORROW' as timestamp) from rdb$database
		-- returns e.g. 2011-10-04 00:00:00.0000</programlisting>
		        <para><link linkend="langref25-shorthandcast">Shorthand syntax</link> for the last
		        two statements:</para>
		        <programlisting>select date 'Tomorrow' from rdb$database
		select timestamp 'TOMORROW' from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>		
    <section id="langref25-contextvars-updating">
      <title><varname>UPDATING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired
        because of an <database>UPDATE</database> operation. Intended for use in <link
        linkend="langref25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
		<section id="langref25-contextvars-yesterday">
		  <title><literal>'YESTERDAY'</literal></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL, ESQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><literal>'YESTERDAY'</literal> is not a variable but a string literal. It is, however,
		    special in the sense that when you <database>CAST()</database> it to a date/time type, you
		    will get the date of the day before. See also <link
        linkend="langref25-contextvars-today"><varname>'TODAY'</varname></link>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Type</title>
		    <para><database>CHAR(9)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select 'Yesterday' from rdb$database
		-- returns 'Tomorrow'</programlisting>
		        <programlisting>select cast('Yesterday as date) from rdb$database
		-- returns e.g. 2011-10-02</programlisting>
		        <programlisting>select cast('YESTERDAY' as timestamp) from rdb$database
		-- returns e.g. 2011-10-02 00:00:00.0000</programlisting>
		        <para><link linkend="langref25-shorthandcast">Shorthand syntax</link> for the last
		        two statements:</para>
		        <programlisting>select date 'Yesterday' from rdb$database
		select timestamp 'YESTERDAY' from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>		
    <section id="langref25-contextvars-user">
      <title><varname>USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>InterBase</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <link linkend="langref25-contextvars-current_user"><database>CURRENT_USER</database></link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

  </section>
  <section id="langref25-functions-scalarfuncs">
	<title>Scalar functions</title>
		<section id="langref25-functions-scalarfuncs-abs">
		  <title><database>ABS()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the absolute value of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Numerical</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ABS (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-abs">external function
		    <function>ABS</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-acos">
		  <title><database>ACOS()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the arc cosine of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ACOS (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The result is an angle in the range [0, π].</para>
		          </listitem>
		          <listitem>
		            <para>If the argument is outside the range [-1, 1], NaN is returned.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-acos">external function
		    <function>ACOS</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-ascii_char">
		  <title><database>ASCII_CHAR()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the ASCII character corresponding to the number passed in the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>[VAR]CHAR(1) CHARACTER SET NONE</database><!--VARCHAR when arg is NULL--></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ASCII_CHAR (<replaceable>&lt;code&gt;</replaceable>)

		<replaceable>&lt;code&gt;</replaceable>  ::=  an integer in the range [0..255]</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <itemizedlist>
		      <listitem>
		        <para>If the <link linkend="langrefupd25-udf-ascii_char">external function
		        <function>ASCII_CHAR</function></link> is declared in your database, it will override
		        the internal function. To make the internal function available, <link
		        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		        function (UDF).</para>
		      </listitem>
		      <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		      <listitem>
		        <para>If you are used to the behaviour of the <function>ASCII_CHAR</function> UDF, which
		        returns an empty string if the argument is 0, please notice that the internal function
		        correctly returns a character with ASCII code 0 here.</para>
		      </listitem>
		    </itemizedlist>
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-ascii_val">
		  <title><database>ASCII_VAL()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the ASCII code of the character passed in.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>SMALLINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ASCII_VAL (<replaceable>ch</replaceable>)

		<replaceable>ch</replaceable>  ::=  a [<database>VAR</database>]<database>CHAR</database> or text <database>BLOB</database> of max. 32767 bytes</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>If the argument is a string with more than one character, the ASCII code of
		            the first character is returned.</para>
		          </listitem>
		          <listitem>
		            <para>If the argument is an empty string, 0 is returned.</para>
		          </listitem>
		          <listitem>
		            <para>If the argument is <constant>NULL</constant>, <constant>NULL</constant> is
		            returned.</para>
		            <!--Should that be mentioned? It is the expected behaviour.-->
		          </listitem>
		          <listitem>
		            <para>If the first character of the argument string is multi-byte, an error is
		            raised. (A bug in Firebird 2.1–2.1.3 and 2.5 causes an error to be raised if
		            <emphasis>any</emphasis> character in the string is multi-byte. This is fixed in
		            versions 2.1.4 and 2.5.1.)</para>
		            <!--RlsNotes say: Error if *first* char is multibyte. Entered bug CORE-3227. Fixed for 2.1.4, 2.5.1, 3.0-->
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-ascii_val">external function
		    <function>ASCII_VAL</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-asin">
		  <title><database>ASIN()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the arc sine of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ASIN (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The result is an angle in the range [-π/2, π/2].</para>
		          </listitem>
		          <listitem>
		            <para>If the argument is outside the range [-1, 1], NaN is returned.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-asin">external function
		    <function>ASIN</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-atan">
		  <title><database>ATAN()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the arc tangent of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ATAN (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The result is an angle in the range &lt;-π/2, π/2&gt;.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-atan">external function
		    <function>ATAN</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-atan2">
		  <title><database>ATAN2()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the angle whose sine-to-cosine <emphasis>ratio</emphasis> is given by the two
		    arguments, and whose sine and cosine <emphasis>signs</emphasis> correspond to the signs of
		    the arguments. This allows results across the entire circle, including the angles -π/2 and
		    π/2.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <!--Note for maintainers/editors: the argument names y and x (in that order!) are chosen on purpose, for geometrical reasons.-->
		        <programlisting>ATAN2 (<replaceable>y</replaceable>, <replaceable>x</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The result is an angle in the range [-π, π].</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>x</replaceable> is negative, the result is π if
		            <replaceable>y</replaceable> is 0, and -π if <replaceable>y</replaceable> is
		            -0.</para>
		          </listitem>
		          <listitem>
		            <para>If both <replaceable>y</replaceable> and <replaceable>x</replaceable> are 0,
		            the result is meaningless. Starting with Firebird 3, an error will be raised if both
		            arguments are 0.</para>
		            <!--Bug report CORE-3201: an exception should be raised here or NaN returned.
		02 Feb 2011 Fixed by Adriano for 3.0 alpha. 2.1.5 and 2.5.1 not (yet?)-->
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-atan2">external function
		    <function>ATAN2</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <formalpara>
		    <title>Notes</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>A fully equivalent description of this function is the following:
		          <database>ATAN2</database>(<replaceable>y</replaceable>, <replaceable>x</replaceable>)
		          is the angle between the positive X-axis and the line from the origin to the point
		          (<replaceable>x</replaceable>, <replaceable>y</replaceable>). This also makes it
		          obvious that <database>ATAN2</database>(0, 0) is undefined.</para>
		        </listitem>
		        <listitem>
		          <para>If <replaceable>x</replaceable> is greater than 0,
		          <database>ATAN2</database>(<replaceable>y</replaceable>, <replaceable>x</replaceable>)
		          is the same as
		          <database>ATAN</database>(<replaceable>y</replaceable>/<replaceable>x</replaceable>).</para>
		        </listitem>
		        <listitem>
		          <para>If both sine and cosine of the angle are already known,
		          <database>ATAN2</database>(<replaceable>sin</replaceable>,
		          <replaceable>cos</replaceable>) gives the angle.</para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-bin_and">
		  <title><database>BIN_AND()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the result of the bitwise AND operation on the argument(s).</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_AND (<replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-bin_and">external function
		    <function>BIN_AND</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-bin_or">
		  <title><database>BIN_OR()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the result of the bitwise OR operation on the argument(s).</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_OR (<replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-bin_or">external function
		    <function>BIN_OR</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-bin_shl">
		  <title><database>BIN_SHL()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the first argument bitwise left-shifted by the second argument, i.e.
		    <replaceable>a</replaceable> &lt;&lt; <replaceable>b</replaceable> or
		    <replaceable>a</replaceable>·2^<replaceable>b</replaceable>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_SHL (<replaceable>number</replaceable>, <replaceable>shift</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-bin_shr">
		  <title><database>BIN_SHR()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the first argument bitwise right-shifted by the second argument, i.e.
		    <replaceable>a</replaceable> &gt;&gt; <replaceable>b</replaceable> or
		    <replaceable>a</replaceable>/2^<replaceable>b</replaceable>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_SHR (<replaceable>number</replaceable>, <replaceable>shift</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The operation performed is an arithmetic right shift (SAR), meaning that the
		            sign of the first operand is always preserved.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-bin_xor">
		  <title><database>BIN_XOR()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the result of the bitwise XOR operation on the argument(s).</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIN_XOR (<replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-bin_xor">external function
		    <function>BIN_XOR</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-bit_length">
		  <title><database>BIT_LENGTH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Gives the length in bits of the input string. For multi-byte character sets, this may
		    be less than the number of characters times 8 times the <quote>formal</quote> number of
		    bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
		  </formalpara>
		  <note>
		    <para>With arguments of type <database>CHAR</database>, this function takes the entire
		    formal string length (e.g. the declared length of a field or variable) into account. If you
		    want to obtain the <quote>logical</quote> bit length, not counting the trailing spaces,
		    right-<link linkend="langref25-functions-scalarfuncs-trim"><database>TRIM</database></link> the
		    argument before passing it to <database>BIT_LENGTH</database>.</para>
		  </note>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>BIT_LENGTH (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title><database>BLOB</database> support</title>
		    <para>Since Firebird 2.1, this function fully supports text <database>BLOB</database>s of
		    any length and character set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select bit_length('Hello!') from rdb$database
		-- returns 48</programlisting>
		        <programlisting>select bit_length(_iso8859_1 'Grüß di!') from rdb$database
		-- returns 64: ü and ß take up one byte each in ISO8859_1</programlisting>
		        <programlisting>select bit_length
		(cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
		from rdb$database
		-- returns 80: ü and ß take up two bytes each in UTF8</programlisting>
		        <programlisting>select bit_length
		(cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
		from rdb$database
		-- returns 208: all 24 <database>CHAR</database> positions count, and two of them are 16-bit</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-octet_length"><database>OCTET_LENGTH()</database></link>,
		    <link
		    linkend="langref25-functions-scalarfuncs-char_length"><database>CHARACTER_LENGTH()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-cast">
		  <title><database>CAST()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>IB</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.0, 2.1, 2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><database>CAST</database> converts an expression to the desired datatype or domain. If
		    the conversion is not possible, an error is raised.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>User-chosen.</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CAST (<replaceable>expression</replaceable> AS <replaceable>&lt;target_type&gt;</replaceable>)

		<replaceable>&lt;target_type&gt;</replaceable>  ::=  <replaceable>sql_datatype</replaceable>
		                | [TYPE OF] <replaceable>domain</replaceable>
		                | TYPE OF COLUMN <replaceable>relname</replaceable>.<replaceable>colname</replaceable></programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Shorthand syntax</title>
		    <para><blockquote>
		        <para>Alternative syntax, supported only when casting a string literal to a
		        <database>DATE</database>, <database>TIME</database> or
		        <database>TIMESTAMP</database>:</para>
		        <programlisting><replaceable>datatype</replaceable> <replaceable>'date/timestring'</replaceable></programlisting>
		        <para>This syntax was already available in InterBase, but was never properly documented.
		        <emphasis>Please notice:</emphasis> The shorthand syntax is evaluated immediately at
		        parse time, causing the value to stay the same until the statement is unprepared. For
		        datetime literals like <literal>'12-Oct-2012'</literal> this doesn't make any
		        difference. But for the pseudo-variables <literal>'NOW'</literal>,
		        <literal>'YESTERDAY'</literal>, <literal>'TODAY'</literal> and
		        <literal>'TOMORROW'</literal> this may not be what you want. If you need the value to be
		        evaluated at every call, use <database>CAST()</database>.</para>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <para>A full-syntax cast:</para>
		        <programlisting>select cast ('12' || '-June-' || '1959' as date) from rdb$database</programlisting>
		        <para>A shorthand string-to-date cast:</para>
		        <programlisting>update People set AgeCat = 'Old'
		where BirthDate &lt; date '1-Jan-1943'</programlisting>
		        <para>Notice that you can drop even the shorthand cast from the example above, as the
		        engine will understand from the context (comparison to a <database>DATE</database>
		        field) how to interpret the string:</para>
		        <programlisting>update People set AgeCat = 'Old'
		where BirthDate &lt; '1-Jan-1943'</programlisting>
		        <para>But this is not always possible. The cast below cannot be dropped, otherwise the
		        engine would find itself with an integer to be subtracted from a string:</para>
		        <programlisting>select date 'today' - 7 from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para>The following table shows the type conversions possible with
		  <database>CAST</database>.</para>
		  <table id="langrefupd25-tbl-cast">
		    <title>Possible <database>CAST</database>s</title>
		    <tgroup cols="2">
		      <colspec colname="colFromType" />
		      <colspec colname="colToType" />
		      <thead>
		        <row valign="top">
		          <entry>From</entry>
		          <entry>To</entry>
		        </row>
		      </thead>
		      <tbody>
		        <row valign="top">
		          <entry><simplelist>
		              <member>Numeric types</member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member>Numeric types</member>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		            </simplelist></entry>
		        </row>
		        <row valign="top">
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		              <member>Numeric types</member>
		              <member><database>DATE</database></member>
		              <member><database>TIME</database></member>
		              <member><database>TIMESTAMP</database></member>
		            </simplelist></entry>
		        </row>
		        <row valign="top">
		          <entry><simplelist>
		              <member><database>DATE</database></member>
		              <member><database>TIME</database></member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		              <member><database>TIMESTAMP</database></member>
		            </simplelist></entry>
		        </row>
		        <row valign="top">
		          <entry><simplelist>
		              <member><database>TIMESTAMP</database></member>
		            </simplelist></entry>
		          <entry><simplelist>
		              <member><database>[VAR]CHAR</database></member>
		              <member><database>BLOB</database></member>
		              <member><database>DATE</database></member>
		              <member><database>TIME</database></member>
		            </simplelist></entry>
		        </row>
		      </tbody>
		    </tgroup>
		  </table>
		  <para>Keep in mind that sometimes information is lost, for instance when you cast a
		  <database>TIMESTAMP</database> to a <database>DATE</database>. Also, the fact that types are
		  <database>CAST</database>-compatible is in itself no guarantee that a conversion will succeed.
		  <quote><database>CAST</database>(123456789 as <database>SMALLINT</database>)</quote> will
		  definitely result in an error, as will <quote><database>CAST</database>('Judgement Day' as
		  <database>DATE</database>)</quote>.</para>
		  <formalpara>
		    <title>Casting input fields</title>
		    <para>Since Firebird 2.0, you can cast statement parameters to a datatype:</para>
		  </formalpara>
		  <blockquote>
		    <programlisting>cast (? as integer)</programlisting>
		  </blockquote>
		  <para>This gives you control over the type of input field set up by the engine. Please notice
		  that with statement parameters, you always need a full-syntax cast – shorthand casts are not
		  supported.</para>
		  <formalpara>
		    <title>Casting to a domain or its type</title>
		    <para>Firebird 2.1 and above support casting to a domain or its base type. When casting to a
		    domain, any constraints (<database>NOT NULL</database> and/or <database>CHECK</database>)
		    declared for the domain must be satisfied or the cast will fail. Please be aware that a
		    <database>CHECK</database> passes if it evaluates to <constant>TRUE</constant>
		    <emphasis>or</emphasis> <constant>NULL</constant>! So, given the following
		    statements:</para>
		  </formalpara>
		  <blockquote>
		    <programlisting>create domain quint as int check (value &gt;= 5000)
		select cast (2000 as quint) from rdb$database     -- (1)
		select cast (8000 as quint) from rdb$database     -- (2)
		select cast (null as quint) from rdb$database     -- (3)</programlisting>
		  </blockquote>
		  <para>only cast number (1) will result in an error.</para>
		  <para>When the <database>TYPE OF</database> modifier is used, the expression is cast to the
		  base type of the domain, ignoring any constraints. With domain <type>quint</type> defined as
		  above, the following two casts are equivalent and will both succeed:</para>
		  <blockquote>
		    <programlisting>select cast (2000 as type of quint) from rdb$database
		select cast (2000 as int) from rdb$database</programlisting>
		  </blockquote>
		  <para>If <database>TYPE OF</database> is used with a
		  (<database>VAR</database>)<database>CHAR</database> type, its character set and collation are
		  retained:</para>
		  <blockquote>
		    <programlisting>create domain iso20 varchar(20) character set iso8859_1;
		create domain dunl20 varchar(20) character set iso8859_1 collate du_nl;
		create table zinnen (zin varchar(20));
		commit;
		insert into zinnen values ('Deze');
		insert into zinnen values ('Die');
		insert into zinnen values ('die');
		insert into zinnen values ('deze');

		select cast(zin as type of iso20) from zinnen order by 1;
		-- returns Deze -&gt; Die -&gt; deze -&gt; die

		select cast(zin as type of dunl20) from zinnen order by 1;
		-- returns deze -&gt; Deze -&gt; die -&gt; Die</programlisting>
		  </blockquote>
		  <warning>
		    <para>If a domain's definition is changed, existing <database>CAST</database>s to that
		    domain or its type may become invalid. If these <database>CAST</database>s occur in PSQL
		    modules, their invalidation may be detected. See the note <link
		    linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The <database>RDB$VALID_BLR</database>
		    field</citetitle></link>, near the end of this document.</para>
		  </warning>
		  <formalpara>
		    <title>Casting to a column's type</title>
		    <para>In Firebird 2.5 and above, it is possible to cast expressions to the type of an
		    existing table or view column. Only the type itself is used; in the case of string types,
		    this includes the character set but not the collation. Constraints and default values of the
		    source column are not applied.</para>
		  </formalpara>
		  <blockquote>
		    <programlisting>create table ttt (
		s varchar(40) character set utf8 collate unicode_ci_ai
		);
		commit;

		select cast ('Jag har många vänner' as type of column ttt.s) from rdb$database;</programlisting>
		  </blockquote>
		  <warning>
		    <title>Warnings</title>
		    <itemizedlist>
		      <listitem>
		        <para>For text types, character set and collation are preserved by the cast – just as
		        when casting to a domain. However, due to a bug, the collation is not always taken into
		        consideration when comparisons (e.g. equality tests) are made. In cases where the
		        collation is of importance, test your code thoroughly before deploying! This bug is
		        fixed for Firebird 3.</para>
		        <!--More specific: If the column has a direct type, comparisons igmore the collation even though output column
		descriptions do include the collation. If the column has a domain type, comparisons function correctly.-->
		      </listitem>
		      <listitem>
		        <para>If a column's definition is altered, existing <database>CAST</database>s to that
		        column's type may become invalid. If these <database>CAST</database>s occur in PSQL
		        modules, their invalidation may be detected. See the note <link
		        linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
		        <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
		        document.</para>
		      </listitem>
		    </itemizedlist>
		  </warning>
		  <formalpara>
		    <title>Casting <database>BLOB</database>s</title>
		    <para>Successful casting to and from <database>BLOB</database>s is possible since Firebird
		    2.1.</para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-ceil">
		  <title><database>CEIL()</database>, <database>CEILING()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the smallest whole number greater than or equal to the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database> or <database>DOUBLE PRECISION</database><!--DOUBLE PRECISION if arg is an SQL parameter--></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CEIL[ING] (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-ceiling">external function
		    <function>CEILING</function></link> is declared in your database, it will override the
		    internal function <database>CEILING</database> (but not <database>CEIL</database>). To make
		    the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-floor"><database>FLOOR()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-char_length">
		  <title><database>CHAR_LENGTH()</database>, <database>CHARACTER_LENGTH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Gives the length in characters of the input string.</para>
		  </formalpara>
		  <note>
		    <para>With arguments of type <database>CHAR</database>, this function returns the formal
		    string length (i.e. the declared length of a field or variable). If you want to obtain the
		    <quote>logical</quote> length, not counting the trailing spaces, right-<link
		    linkend="langref25-functions-scalarfuncs-trim"><database>TRIM</database></link> the argument before
		    passing it to <database>CHAR[ACTER]_LENGTH</database>.</para>
		    <!--This is the case when
		- CASTing to CHAR(n)
		- Reading a CHAR(n) variable or table field

		But e.g. a SUBSTRING result, although formally of the same length as the first
		argument, has a CHAR_LENGTH (and strlen) equal to the 'FOR' argument or the
		length to the end of the string, e.g:
		SUBSTRING('Hello' from 3 for 2) is a CHAR(5) with CHAR_LENGTH 2
		SUBSTRING('Hello' from 2) is a CHAR(5) with CHAR_LENGTH 4
		SUBSTRING('Hello' from 2 for 8) is a CHAR(5) with CHAR_LENGTH 4

		However, as soon as you CAST such substrings to a CHAR(n) or store them
		in a CHAR(n) field or variable, the CHAR_LENGTH becomes n.

		Another example: if you have a char(12) column with the string 'AB', it has
		a CHAR_LENGTH of 12 and concatenation with '.' shows the 10 spaces. Now if
		you select SUBSTRING(field from 2 for 2), you get a CHAR(12) with CHAR_LENGTH 2.
		You see only an A, but concatenation with '.' shows there's a space behind it.

		The conclusion must be (I think) that SUBSTRING puts a zero character after the
		result, or maybe fills the entire formal length with zero chars.-->
		  </note>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CHAR_LENGTH (<replaceable>str</replaceable>)
		CHARACTER_LENGTH (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title><database>BLOB</database> support</title>
		    <para>Since Firebird 2.1, this function fully supports text <database>BLOB</database>s of
		    any length and character set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select char_length('Hello!') from rdb$database
		-- returns 6</programlisting>
		        <programlisting>select char_length(_iso8859_1 'Grüß di!') from rdb$database
		-- returns 8</programlisting>
		        <programlisting>select char_length
		(cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
		from rdb$database
		-- returns 8; the fact that ü and ß take up two bytes each is irrelevant</programlisting>
		        <programlisting>select char_length
		(cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
		from rdb$database
		-- returns 24: all 24 <database>CHAR</database> positions count</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-bit_length"><database>BIT_LENGTH()</database></link>, <link
		    linkend="langref25-functions-scalarfuncs-octet_length"><database>OCTET_LENGTH()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-char_to_uuid">
		  <title><database>CHAR_TO_UUID()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Converts a human-readable 36-char UUID string to the corresponding 16-byte
		    UUID.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>CHAR(16) CHARACTER SET OCTETS</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>CHAR_TO_UUID (<replaceable>ascii_uuid</replaceable>)

		<replaceable>ascii_uuid</replaceable>  ::=  a string of length 36 with:
		               * '-' (hyphen) at positions 9, 14, 19 and 24;
		               * valid hex digits at every other position.</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select char_to_uuid('A0bF4E45-3029-2a44-D493-4998c9b439A3') from rdb$database
		-- returns A0BF4E4530292A44D4934998C9B439A3 (16-byte string)

		select char_to_uuid('A0bF4E45-3029-2A44-X493-4998c9b439A3') from rdb$database
		-- error: -Human readable UUID argument for CHAR_TO_UUID must
		--         have hex digit at position 20 instead of "X (ASCII 88)"</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-uuid_to_char"><database>UUID_TO_CHAR()</database></link>,
		    <link linkend="langref25-functions-scalarfuncs-gen_uuid"><database>GEN_UUID()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-coalesce">
		  <title><database>COALESCE()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>1.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>The <database>COALESCE</database> function takes two or more arguments and returns the
		    value of the first non-<constant>NULL</constant> argument. If all the arguments evaluate to
		    <constant>NULL</constant>, the result is <constant>NULL</constant>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Depends on input.</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>select 
		coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
		as FullName
		from Persons</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para>This example picks the Nickname from the Persons table. If it happens to be
		  <constant>NULL</constant>, it goes on to FirstName. If that too is <constant>NULL</constant>,
		  <quote>Mr./Mrs.</quote> is used. Finally, it adds the family name. All in all, it tries to use
		  the available data to compose a full name that is as informal as possible. Notice that this
		  scheme only works if absent nicknames and first names are really <constant>NULL</constant>: if
		  one of them is an empty string instead, <database>COALESCE</database> will happily return that
		  to the caller.</para>
		  <note>
		    <para>In Firebird 1.0.x, where <database>COALESCE</database> is not available, you can
		    accomplish the same with the <link
		    linkend="langrefupd25-udf-nvl"><function>*nvl</function></link> external functions.</para>
		  </note>
		</section>
		<section id="langref25-functions-scalarfuncs-cos">
		  <title><database>COS()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns an angle's cosine. The argument must be given in radians.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COS (<replaceable>angle</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>Any non-<constant>NULL</constant> result is – obviously – in the range [-1,
		            1].</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-cos">external function
		    <function>COS</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-cosh">
		  <title><database>COSH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the hyperbolic cosine of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COSH (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>Any non-<constant>NULL</constant> result is in the range [1, INF].</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-cosh">external function
		    <function>COSH</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-cot">
		  <title><database>COT()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns an angle's cotangent. The argument must be given in radians.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>COT (<replaceable>angle</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-cot">external function
		    <function>COT</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-dateadd">
		  <title><database>DATEADD()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Adds the specified number of years, months, weeks, days, hours, minutes, seconds or
		    milliseconds to a date/time value. (The <database>WEEK</database> unit is new in
		    2.5.)</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DATE</database>, <database>TIME</database> or
		    <database>TIMESTAMP</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>DATEADD (<replaceable>&lt;args&gt;</replaceable>)

		<replaceable>&lt;args&gt;</replaceable>      ::=  <replaceable>&lt;amount&gt;</replaceable> <replaceable>&lt;unit&gt;</replaceable> TO <replaceable>&lt;datetime&gt;</replaceable>
		             | <replaceable>&lt;unit&gt;</replaceable>, <replaceable>&lt;amount&gt;</replaceable>, <replaceable>&lt;datetime&gt;</replaceable>

		<replaceable>&lt;amount&gt;</replaceable>    ::=  an integer expression (negative to subtract)
		<replaceable>&lt;unit&gt;</replaceable>      ::=  YEAR | MONTH | WEEK | DAY
		               | HOUR | MINUTE | SECOND | MILLISECOND
		<replaceable>&lt;datetime&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The result type is determined by the third argument.</para>
		          </listitem>
		          <listitem>
		            <para>With <database>TIMESTAMP</database> and <database>DATE</database> arguments,
		            all units can be used. (Prior to Firebird 2.5, units smaller than
		            <database>DAY</database> were disallowed for <database>DATE</database>s.)</para>
		          </listitem>
		          <listitem>
		            <para>With <database>TIME</database> arguments, only <database>HOUR</database>,
		            <database>MINUTE</database>, <database>SECOND</database> and
		            <database>MILLISECOND</database> can be used.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>dateadd (28 day to current_date)
		dateadd (-6 hour to current_time)
		dateadd (month, 9, DateOfConception)
		dateadd (-38 week to DateOfBirth)
		dateadd (minute, 90, time 'now')
		dateadd (? year to date '11-Sep-1973')</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-datediff">
		  <title><database>DATEDIFF()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the number of years, months, weeks, days, hours, minutes, seconds or
		    milliseconds elapsed between two date/time values. (The <database>WEEK</database> unit is
		    new in 2.5.)</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>DATEDIFF (<replaceable>&lt;args&gt;</replaceable>)

		<replaceable>&lt;args&gt;</replaceable>     ::=  <replaceable>&lt;unit&gt;</replaceable> FROM <replaceable>&lt;moment1&gt;</replaceable> TO <replaceable>&lt;moment2&gt;</replaceable>
		            | <replaceable>&lt;unit&gt;</replaceable>, <replaceable>&lt;moment1&gt;</replaceable>, <replaceable>&lt;moment2&gt;</replaceable>

		<replaceable>&lt;unit&gt;</replaceable>     ::=  YEAR | MONTH | WEEK | DAY
		              | HOUR | MINUTE | SECOND | MILLISECOND
		<replaceable>&lt;momentN&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para><database>DATE</database> and <database>TIMESTAMP</database> arguments can be
		            combined. No other mixes are allowed.</para>
		          </listitem>
		          <listitem>
		            <para>With <database>TIMESTAMP</database> and <database>DATE</database> arguments,
		            all units can be used. (Prior to Firebird 2.5, units smaller than
		            <database>DAY</database> were disallowed for <database>DATE</database>s.)</para>
		          </listitem>
		          <listitem>
		            <para>With <database>TIME</database> arguments, only <database>HOUR</database>,
		            <database>MINUTE</database>, <database>SECOND</database> and
		            <database>MILLISECOND</database> can be used.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Computation</title>
		    <para><itemizedlist>
		        <listitem>
		          <para><database>DATEDIFF</database> doesn't look at any smaller units than the one
		          specified in the first argument. As a result,</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><quote><code>datediff (year, date '1-Jan-2009', date
		              '31-Dec-2009')</code></quote> returns 0, but</para>
		            </listitem>
		            <listitem>
		              <para><quote><code>datediff (year, date '31-Dec-2009', date
		              '1-Jan-2010')</code></quote> returns 1</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		        <listitem>
		          <para>It does, however, look at all the <emphasis>bigger</emphasis> units. So:</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><quote><code>datediff (day, date '26-Jun-1908', date
		              '11-Sep-1973')</code></quote> returns 23818</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		        <listitem>
		          <para>A negative result value indicates that <replaceable>moment2</replaceable> lies
		          before <replaceable>moment1</replaceable>.</para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>datediff (hour from current_timestamp to timestamp '12-Jun-2059 06:00')
		datediff (minute from time '0:00' to current_time)
		datediff (month, current_date, date '1-1-1900')
		datediff (day from current_date to cast(? as date))</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-decode">
		  <title><database>DECODE()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><database>DECODE</database> is a shortcut for the so-called <link
		    linkend="langrefupd25-case-simple"><quote>simple <database>CASE</database></quote>
		    construct</link>, in which a given expression is compared to a number of other expressions
		    until a match is found. The result is determined by the value listed after the matching
		    expression. If no match is found, the default result is returned, if present. Otherwise,
		    <constant>NULL</constant> is returned.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Varies</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>DECODE ( <replaceable>&lt;test-expr&gt;</replaceable>,
		     <replaceable>&lt;expr&gt;</replaceable>, <replaceable>result</replaceable>
		     [, <replaceable>&lt;expr&gt;</replaceable>, <replaceable>result</replaceable> ...]
		     [, <replaceable>defaultresult</replaceable>] )</programlisting>
		        <para>The equivalent CASE construct:</para>
		        <programlisting>CASE <replaceable>&lt;test-expr&gt;</replaceable>
		WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>result</replaceable>
		[WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>result</replaceable> ...]
		[ELSE <replaceable>defaultresult</replaceable>]
		END</programlisting>
		        <!--Both for DECODE and CASE:
		Determine whether and when to use <> with the replaceables, and BE CONSISTENT!-->
		        <caution>
		          <para>Matching is done with the <quote><literal>=</literal></quote> operator, so if
		          <replaceable>&lt;test-expr&gt;</replaceable> is <constant>NULL</constant>, it won't
		          match any of the <replaceable>&lt;expr&gt;</replaceable>s, not even those that are
		          <constant>NULL</constant>.</para>
		        </caution>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>select name,
		   age,
		   decode( upper(sex),
		           'M', 'Male',
		           'F', 'Female',
		           'Unknown' ),
		   religion
		from people</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langrefupd25-case"><database>CASE</database></link>, <link
		    linkend="langrefupd25-case-simple">Simple <database>CASE</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-exp">
		  <title><database>EXP()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the natural exponential,
		    <emphasis>e</emphasis><superscript><replaceable>number</replaceable></superscript></para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>EXP (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-ln"><database>LN()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-extract">
		  <title><database>EXTRACT()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>IB 6</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Extracts and returns an element from a <database>DATE</database>,
		    <database>TIME</database> or <database>TIMESTAMP</database> expression. This function was
		    already added in InterBase 6, but not documented in the <citetitle>Language
		    Reference</citetitle> at the time.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>SMALLINT</database> or <database>NUMERIC</database><!--or DECIMAL?--></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

		<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | WEEK
		               | DAY | WEEKDAY | YEARDAY
		               | HOUR | MINUTE | SECOND | MILLISECOND
		<replaceable>&lt;datetime&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para>The returned data types and possible ranges are shown in the table below. If you try to
		  extract a part that isn't present in the date/time argument (e.g. <database>SECOND</database>
		  from a <database>DATE</database> or <database>YEAR</database> from a
		  <database>TIME</database>), an error occurs.</para>
		  <table id="langrefupd25-tbl-extractranges">
		    <title>Types and ranges of <database>EXTRACT</database> results</title>
		    <tgroup cols="4">
		      <thead>
		        <row>
		          <entry>Part</entry>
		          <entry>Type</entry>
		          <entry>Range</entry>
		          <entry>Comment</entry>
		        </row>
		      </thead>
		      <tbody>
		        <row>
		          <entry><database>YEAR</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1–9999</entry>
		          <entry></entry>
		        </row>
		        <row>
		          <entry><database>MONTH</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1–12</entry>
		          <entry></entry>
		        </row>
		        <row>
		          <entry><database>WEEK</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1–53</entry>
		          <entry></entry>
		        </row>
		        <row>
		          <entry><database>DAY</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>1–31</entry>
		          <entry></entry>
		        </row>
		        <row>
		          <entry><database>WEEKDAY</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0–6</entry>
		          <entry>0 = Sunday</entry>
		        </row>
		        <row>
		          <entry><database>YEARDAY</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0–365</entry>
		          <entry>0 = January 1</entry>
		        </row>
		        <row>
		          <entry><database>HOUR</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0–23</entry>
		          <entry></entry>
		        </row>
		        <row>
		          <entry><database>MINUTE</database></entry>
		          <entry><database>SMALLINT</database></entry>
		          <entry>0–59</entry>
		          <entry></entry>
		        </row>
		        <row>
		          <entry><database>SECOND</database></entry>
		          <entry><database>NUMERIC(9,4)</database></entry>
		          <entry>0.0000–59.9999</entry>
		          <entry>includes millisecond as fraction</entry>
		        </row>
		        <row>
		          <entry><database>MILLISECOND</database></entry>
		          <entry><database>NUMERIC(9,1)</database></entry>
		          <entry>0.0–999.9</entry>
		          <entry>broken in 2.1, 2.1.1</entry>
		        </row>
		      </tbody>
		    </tgroup>
		  </table>
		  <section id="langref25-functions-scalarfuncs-extract-millisecond">
		    <title><database>MILLISECOND</database></title>
		    <formalpara>
		      <title>Added in</title>
		      <para>2.1 (with bug)<!--CORE-1962, fixed by Adriano--></para>
		    </formalpara>
		    <formalpara>
		      <title>Fixed in</title>
		      <para>2.1.2</para>
		    </formalpara>
		    <formalpara>
		      <title>Description</title>
		      <para>Firebird 2.1 and up support extraction of the millisecond from a
		      <database>TIME</database> or <database>TIMESTAMP</database>. The datatype returned is
		      <database>NUMERIC(9,1)</database>.</para>
		    </formalpara>
		    <note>
		      <para>If you extract the millisecond from <link
		      linkend="langrefupd25-current_time"><database>CURRENT_TIME</database></link>, be aware
		      that this variable defaults to seconds precision, so the result will always be 0. Extract
		      from <database>CURRENT_TIME(3)</database> or <link
		      linkend="langrefupd25-current_timestamp"><database>CURRENT_TIMESTAMP</database></link> to
		      get milliseconds precision.</para>
		    </note>
		  </section>
		  <section id="langref25-functions-scalarfuncs-extract-week">
		    <title><database>WEEK</database></title>
		    <formalpara>
		      <title>Added in</title>
		      <para>2.1</para>
		    </formalpara>
		    <formalpara>
		      <title>Description</title>
		      <para>Firebird 2.1 and up support extraction of the ISO-8601 week number from a
		      <database>DATE</database> or <database>TIMESTAMP</database>. ISO-8601 weeks start on a
		      Monday and always have the full seven days. Week 1 is the first week that has a majority
		      (at least 4) of its days in the new year. The first 1–3 days of the year may belong to the
		      last week (52 or 53) of the previous year. Likewise, a year's final 1–3 days may belong to
		      week 1 of the following year.</para>
		    </formalpara>
		    <caution>
		      <para>Be careful when combining <database>WEEK</database> and <database>YEAR</database>
		      results. For instance, 30 December 2008 lies in week 1 of 2009, so <quote><code>extract
		      (week from date '30 Dec 2008')</code></quote> returns 1. However, extracting
		      <database>YEAR</database> always gives the calendar year, which is 2008. In this case,
		      <database>WEEK</database> and <database>YEAR</database> are at odds with each other. The
		      same happens when the first days of January belong to the last week of the previous
		      year.</para>
		      <para>Please also notice that <database>WEEKDAY</database> is <emphasis>not</emphasis>
		      ISO-8601 compliant: it returns 0 for Sunday, whereas ISO-8601 specifies 7.</para>
		    </caution>
		  </section>
		</section>
		<section id="langref25-functions-scalarfuncs-floor">
		  <title><database>FLOOR()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the largest whole number smaller than or equal to the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database> or <database>DOUBLE PRECISION</database><!--DOUBLE PRECISION if arg is an SQL parameter--></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>FLOOR (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-floor">external function
		    <function>FLOOR</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-ceil"><database>CEIL()</database> /
		    <database>CEILING()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-gen_id">
		  <title><database>GEN_ID()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>IB</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Increments a generator or sequence and returns its new value. From Firebird 2.0
		    onward, the SQL-compliant <database>NEXT VALUE FOR</database> syntax is preferred, except
		    when an increment other than 1 is needed.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>GEN_ID (<replaceable>generator-name</replaceable>, <replaceable>&lt;step&gt;</replaceable>)

		<replaceable>&lt;step&gt;</replaceable>  ::=  An integer expression.</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>new.rec_id = gen_id(gen_recnum, 1);</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>Unless you know very well what you are doing, using <database>GEN_ID()</database> with
		    step values lower than 1 may compromise your data's integrity.</para>
		  </warning>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langrefupd25-nextvaluefor"><database>NEXT VALUE FOR</database></link>,
		    <link linkend="langrefupd25-create-gen"><database>CREATE GENERATOR</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-gen_uuid">
		  <title><database>GEN_UUID()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns a universally unique ID as a 16-byte character string.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>CHAR(16) CHARACTER SET OCTETS</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>GEN_UUID ()</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>select gen_uuid() from rdb$database
		-- returns e.g. 017347BFE212B2479C00FA4323B36320 (16-byte string)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-uuid_to_char"><database>UUID_TO_CHAR()</database></link>,
		    <link
		    linkend="langref25-functions-scalarfuncs-char_to_uuid"><database>CHAR_TO_UUID()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-hash">
		  <title><database>HASH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns a hash value for the input string. This function fully supports text
		    <database>BLOB</database>s of any length and character set.</para>
		    <!--This function seems rather crummy. It's only 64-bit, and for shorter strings it returns smaller numbers.
		For single ASCII characters it simply returns the ASCII code.-->
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>HASH (<replaceable>string</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-iif">
		  <title><database>IIF()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><database>IIF</database> takes three arguments. If the first evaluates to
		    <constant>true</constant>, the second argument is returned; otherwise the third is
		    returned.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Depends on input.</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>IIF (<replaceable>&lt;condition&gt;</replaceable>, <replaceable>ResultT</replaceable>, <replaceable>ResultF</replaceable>)

		<replaceable>&lt;condition&gt;</replaceable>  ::=  A boolean expression.</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>select iif( sex = 'M', 'Sir', 'Madam' ) from Customers</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para><database>IIF</database>(<parameter>Cond</parameter>, <parameter>Result1</parameter>,
		  <parameter>Result2</parameter>) is a shortcut for <quote><database>CASE</database>
		  <database>WHEN</database> <parameter>Cond</parameter> <database>THEN</database>
		  <parameter>Result1</parameter> <database>ELSE</database> <parameter>Result2</parameter>
		  <database>END</database></quote>. You can also compare <database>IIF</database> to the ternary
		  <quote><literal>?</literal> <literal>:</literal></quote> operator in C-like languages.</para>
		</section>
		<section id="langref25-functions-scalarfuncs-left">
		  <title><database>LEFT()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the leftmost part of the argument string. The number of characters is given in
		    the second argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LEFT (<replaceable>string</replaceable>, <replaceable>length</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>This function fully supports text <database>BLOB</database>s of any length,
		            including those with a multi-byte character set.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>string</replaceable> is a <database>BLOB</database>, the
		            result is a <database>BLOB</database>. Otherwise, the result is a
		            <database>VARCHAR(<replaceable>n</replaceable>)</database> with
		            <replaceable>n</replaceable> the length of the input string.</para>
		          </listitem>
		          <listitem>
		            <para>If the <replaceable>length</replaceable> argument exceeds the string length,
		            the input string is returned unchanged.</para>
		          </listitem>
		          <listitem>
		            <para>If the <replaceable>length</replaceable> argument is not a whole number,
		            bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5
		            becomes 2, 3.5 becomes 4, etc.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-right"><database>RIGHT()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-ln">
		  <title><database>LN()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the natural logarithm of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LN (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>An error is raised if the argument is negative or 0.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-ln">external function
		    <function>LN</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-exp"><database>EXP()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-log">
		  <title><database>LOG()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the <replaceable>x</replaceable>-based logarithm of
		    <replaceable>y</replaceable>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LOG (<replaceable>x</replaceable>, <replaceable>y</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>If either argument is 0 or below, an error is raised. (Before 2.5, this would
		            result in <constant>NaN</constant>, <constant>±INF</constant> or 0, depending on the
		            exact values of the arguments.)</para>
		          </listitem>
		          <listitem>
		            <para>If both arguments are 1, <constant>NaN</constant> is returned.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>x</replaceable> = 1 and <replaceable>y</replaceable> &lt; 1,
		            -<constant>INF</constant> is returned.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>x</replaceable> = 1 and <replaceable>y</replaceable> &gt; 1,
		            <constant>INF</constant> is returned.</para>
		          </listitem>
		        </itemizedlist>
		        <!--See CORE-1936: In 2.1, this was a mess.-->
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-log">external function
		    <function>LOG</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-log10">
		  <title><database>LOG10()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the 10-based logarithm of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LOG10 (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>An error is raised if the argument is negative or 0. (In versions prior to
		            2.5, such values would result in <constant>NaN</constant> and
		            -<constant>INF</constant>, respectively.)</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-log10">external function
		    <function>LOG10</function></link> is declared in your database, it will override the
		    internal function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-lower">
		  <title><database>LOWER()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the lower-case equivalent of the input string. The exact result depends on the
		    character set. With <database>ASCII</database> or <database>NONE</database> for instance,
		    only ASCII characters are lowercased; with <database>OCTETS</database>, the entire string is
		    returned unchanged. Since Firebird 2.1 this function also fully supports text
		    <database>BLOB</database>s of any length and character set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>(VAR)CHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LOWER (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <note>
		    <para>Because <database>LOWER</database> is a reserved word, the internal function will take
		    precedence even if the <link linkend="langrefupd25-udf-lower">external function by that
		    name</link> has also been declared. To call the (inferior!) external function, use
		    double-quotes and the exact capitalisation, as in
		    <function>"LOWER"</function>(<replaceable>str</replaceable>).</para>
		  </note>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>select Sheriff from Towns
		where lower(Name) = 'cooper''s valley'</programlisting>
		        <!--Maybe add some examples that show the workings with accented characters in different character sets.
		E.g. lower(_octets HÓPLÄ)  lower(_ascii 'HÓPLÄ') vs. lower(_iso8859_1 'HÓPLÄ').
		Do likewise for UPPER().-->
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-upper"><database>UPPER</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-lpad">
		  <title><database>LPAD()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.5 (backported to 2.1.4)</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Left-pads a string with spaces or with a user-supplied string until a given length is
		    reached.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>LPAD (<replaceable>str</replaceable>, <replaceable>endlen</replaceable> [, <replaceable>padstr</replaceable>])</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>This function fully supports text <database>BLOB</database>s of any length and
		            character set.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>str</replaceable> is a <database>BLOB</database>, the result
		            is a <database>BLOB</database>. Otherwise, the result is a
		            <database>VARCHAR</database>(<replaceable>endlen</replaceable>).</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>padstr</replaceable> is given and equals <literal>''</literal>
		            (empty string), no padding takes place.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>endlen</replaceable> is less than the current string length,
		            the string is truncated to <replaceable>endlen</replaceable>, even if
		            <replaceable>padstr</replaceable> is the empty string.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-lpad">external function
		    <function>LPAD</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <note>
		    <para>In Firebird 2.1–2.1.3, all non-BLOB results were of type
		    <database>VARCHAR</database>(32765), which made it advisable to cast them to a more modest
		    size. This is no longer the case.</para>
		    <!--CORE-1346, backported to 2.1.4
		Actually, the length was 32765 for single-byte charsets, 8191 for UTF8, etc.-->
		  </note>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <para><programlisting>lpad ('Hello', 12)                 -- returns '       Hello'
		lpad ('Hello', 12, '-')            -- returns '-------Hello'
		lpad ('Hello', 12, '')             -- returns 'Hello'
		lpad ('Hello', 12, 'abc')          -- returns 'abcabcaHello'
		lpad ('Hello', 12, 'abcdefghij')   -- returns 'abcdefgHello'
		lpad ('Hello', 2)                  -- returns 'He'
		lpad ('Hello', 2, '-')             -- returns 'He'
		lpad ('Hello', 2, '')              -- returns 'He'</programlisting></para>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. Although it does try to limit memory consumption, this may affect
		    performance if huge <database>BLOB</database>s are involved.</para>
		  </warning>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-rpad"><database>RPAD()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-maxvalue">
		  <title><database>MAXVALUE()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the maximum value from a list of numerical, string, or date/time expressions.
		    This function fully supports text <database>BLOB</database>s of any length and character
		    set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Varies</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>MAXVALUE (<replaceable>expr</replaceable> [, <replaceable>expr</replaceable> ...])</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>If one or more expressions resolve to <constant>NULL</constant>,
		            <database>MAXVALUE</database> returns <constant>NULL</constant>. This behaviour
		            differs from the aggregate function <database>MAX</database>.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-minvalue"><database>MINVALUE()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-minvalue">
		  <title><database>MINVALUE()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the minimum value from a list of numerical, string, or date/time expressions.
		    This function fully supports text <database>BLOB</database>s of any length and character
		    set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Varies</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>MINVALUE (<replaceable>expr</replaceable> [, <replaceable>expr</replaceable> ...])</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>If one or more expressions resolve to <constant>NULL</constant>,
		            <database>MINVALUE</database> returns <constant>NULL</constant>. This behaviour
		            differs from the aggregate function <database>MIN</database>.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-maxvalue"><database>MAXVALUE()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-mod">
		  <title><database>MOD()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the remainder of an integer division.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database> or <database>BIGINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>MOD (<replaceable>a</replaceable>, <replaceable>b</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>Non-integer arguments are rounded before the division takes place. So,
		            <quote>7.5 mod 2.5</quote> gives 2 (8 mod 3), not 0.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-mod">external function
		    <function>MOD</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-nullif">
		  <title><database>NULLIF()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>1.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para><database>NULLIF</database> returns the value of the first argument, unless it is
		    equal to the second. In that case, <constant>NULL</constant> is returned.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para>Depends on input.</para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para>This will return the average weight of the persons listed in FatPeople, excluding those
		  having a weight of -1, since <database>AVG</database> skips <constant>NULL</constant> data.
		  Presumably, -1 indicates <quote>weight unknown</quote> in this table. A plain
		  <database>AVG</database>(Weight) would include the -1 weights, thus skewing the result.</para>
		  <note>
		    <para>In Firebird 1.0.x, where <database>NULLIF</database> is not available, you can
		    accomplish the same with the <link
		    linkend="langrefupd25-udf-nullif"><function>*nullif</function></link> external
		    functions.</para>
		  </note>
		</section>
		<section id="langref25-functions-scalarfuncs-octet_length">
		  <title><database>OCTET_LENGTH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Gives the length in bytes (octets) of the input string. For multi-byte character sets,
		    this may be less than the number of characters times the <quote>formal</quote> number of
		    bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
		  </formalpara>
		  <note>
		    <para>With arguments of type <database>CHAR</database>, this function takes the entire
		    formal string length (e.g. the declared length of a field or variable) into account. If you
		    want to obtain the <quote>logical</quote> byte length, not counting the trailing spaces,
		    right-<link linkend="langref25-functions-scalarfuncs-trim"><database>TRIM</database></link> the
		    argument before passing it to <database>OCTET_LENGTH</database>.</para>
		  </note>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>OCTET_LENGTH (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title><database>BLOB</database> support</title>
		    <para>Since Firebird 2.1, this function fully supports text <database>BLOB</database>s of
		    any length and character set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select octet_length('Hello!') from rdb$database
		-- returns 6</programlisting>
		        <programlisting>select octet_length(_iso8859_1 'Grüß di!') from rdb$database
		-- returns 8: ü and ß take up one byte each in ISO8859_1</programlisting>
		        <programlisting>select octet_length
		(cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
		from rdb$database
		-- returns 10: ü and ß take up two bytes each in UTF8</programlisting>
		        <programlisting>select octet_length
		(cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
		from rdb$database
		-- returns 26: all 24 <database>CHAR</database> positions count, and two of them are 2-byte</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-bit_length"><database>BIT_LENGTH()</database></link>, <link
		    linkend="langref25-functions-scalarfuncs-char_length"><database>CHARACTER_LENGTH()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-overlay">
		  <title><database>OVERLAY()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Overwrites part of a string with another string. By default, the number of characters
		    removed from the host string equals the length of the replacement string. With the optional
		    fourth argument, the user can specify a different number of characters to be removed.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>OVERLAY (<replaceable>string</replaceable> PLACING <replaceable>replacement</replaceable> FROM <replaceable>pos</replaceable> [FOR <replaceable>length</replaceable>])</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>This function supports <database>BLOB</database>s of any length.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>string</replaceable> or <replaceable>replacement</replaceable>
		            is a <database>BLOB</database>, the result is a <database>BLOB</database>.
		            Otherwise, the result is a <database>VARCHAR(<replaceable>n</replaceable>) with
		            <replaceable>n</replaceable> the sum of the lengths of
		            <replaceable>string</replaceable> and
		            <replaceable>replacement</replaceable>.</database></para>
		          </listitem>
		          <listitem>
		            <para>As usual in SQL string functions, <replaceable>pos</replaceable> is
		            1-based.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>pos</replaceable> is beyond the end of
		            <replaceable>string</replaceable>, <replaceable>replacement</replaceable> is placed
		            directly after <replaceable>string.</replaceable></para>
		          </listitem>
		          <listitem>
		            <para>If the number of characters from <replaceable>pos</replaceable> to the end of
		            <replaceable>string</replaceable> is smaller than the length of
		            <replaceable>replacement</replaceable> (or than the
		            <replaceable>length</replaceable> argument, if present),
		            <replaceable>string</replaceable> is truncated at <replaceable>pos</replaceable> and
		            <replaceable>replacement</replaceable> placed after it.</para>
		          </listitem>
		          <listitem>
		            <para>The effect of a <quote><database>FOR</database> 0</quote> clause is that
		            <replaceable>replacement</replaceable> is simply inserted into
		            <replaceable>string</replaceable>.</para>
		          </listitem>
		          <listitem>
		            <para>If any argument is <constant>NULL</constant>, the result is
		            <constant>NULL</constant>.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>pos</replaceable> or <replaceable>length</replaceable> is not
		            a whole number, bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0,
		            1.5 becomes 2, 2.5 becomes 2, 3.5 becomes 4, etc.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>overlay ('Goodbye' placing 'Hello' from 2)    -- returns 'GHelloe'
		overlay ('Goodbye' placing 'Hello' from 5)    -- returns 'GoodHello'
		overlay ('Goodbye' placing 'Hello' from 8)    -- returns 'GoodbyeHello'
		overlay ('Goodbye' placing 'Hello' from 20)   -- returns 'GoodbyeHello'

		overlay ('Goodbye' placing 'Hello' from 2 for 0)   -- r. 'GHellooodbye'
		overlay ('Goodbye' placing 'Hello' from 2 for 3)   -- r. 'GHellobye'
		overlay ('Goodbye' placing 'Hello' from 2 for 6)   -- r. 'GHello'
		overlay ('Goodbye' placing 'Hello' from 2 for 9)   -- r. 'GHello'

		overlay ('Goodbye' placing '' from 4)         -- returns 'Goodbye'
		overlay ('Goodbye' placing '' from 4 for 3)   -- returns 'Gooe'
		overlay ('Goodbye' placing '' from 4 for 20)  -- returns 'Goo'

		overlay ('' placing 'Hello' from 4)           -- returns 'Hello'
		overlay ('' placing 'Hello' from 4 for 0)     -- returns 'Hello'
		overlay ('' placing 'Hello' from 4 for 20)    -- returns 'Hello'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. This may affect performance if huge <database>BLOB</database>s are
		    involved.</para>
		  </warning>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-replace"><database>REPLACE()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-pi">
		  <title><database>PI()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns an approximation of the value of π.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>PI ()</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-pi">external function
		    <function>PI</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-position">
		  <title><database>POSITION()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the (1-based) position of the first occurrence of a substring in a host
		    string. With the optional third argument, the search starts at a given offset, disregarding
		    any matches that may occur earlier in the string. If no match is found, the result is
		    0.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>POSITION (<replaceable>&lt;args&gt;</replaceable>)

		<replaceable>&lt;args&gt;</replaceable>  ::=  <replaceable>substr</replaceable> IN <replaceable>string</replaceable>
		         | <replaceable>substr</replaceable>, <replaceable>string</replaceable> [, <replaceable>startpos</replaceable>]</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>The <database>optional third argument is only supported in the second syntax
		            (comma syntax).</database></para>
		          </listitem>
		          <listitem>
		            <para>The empty string is considered a substring of every string. Therefore, if
		            <replaceable>substr</replaceable> is '' (empty string) and
		            <replaceable>string</replaceable> is not <constant>NULL</constant>, the result
		            is:</para>
		            <itemizedlist spacing="compact">
		              <listitem>
		                <para>1 if <replaceable>startpos</replaceable> is not given;</para>
		              </listitem>
		              <listitem>
		                <para><replaceable>startpos</replaceable> if <replaceable>startpos</replaceable>
		                lies within <replaceable>string</replaceable>;</para>
		              </listitem>
		              <listitem>
		                <para>0 if <replaceable>startpos</replaceable> lies beyond the end of
		                <replaceable>string</replaceable>.</para>
		              </listitem>
		            </itemizedlist>
		            <para><emphasis role="bold">Notice:</emphasis> A bug in Firebird 2.1–2.1.3 and 2.5
		            causes <database>POSITION</database> to <emphasis>always</emphasis> return 1 if
		            <replaceable>substr</replaceable> is the empty string. This is fixed in 2.1.4 and
		            2.5.1.</para>
		            <!--If startpos present, result should be startpos if inside string, and 0 if past string. CORE-3244.
		Fixed in 2.1.4, 2.5.1, 3.0-->
		          </listitem>
		          <listitem>
		            <para>This function fully supports text <database>BLOB</database>s of any size and
		            character set.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>position ('be' in 'To be or not to be')      -- returns 4
		position ('be', 'To be or not to be')        -- returns 4
		position ('be', 'To be or not to be', 4)     -- returns 4
		position ('be', 'To be or not to be', 8)     -- returns 17
		position ('be', 'To be or not to be', 18)    -- returns 0
		position ('be' in 'Alas, poor Yorick!')      -- returns 0</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. This may affect performance if huge <database>BLOB</database>s are
		    involved.</para>
		  </warning>
		</section>
		<section id="langref25-functions-scalarfuncs-power">
		  <title><database>POWER()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th
		    power.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>POWER (<replaceable>x</replaceable>, <replaceable>y</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>If <replaceable>x</replaceable> negative, an error is raised.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-dpower">external function
		    <function>POWER</function></link> is declared in your database as <function>power</function>
		    instead of the default <function>dPower</function>, it will override the internal function.
		    To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-rand">
		  <title><database>RAND()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns a random number between 0 and 1.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RAND ()</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-rand">external function
		    <function>RAND</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-get_context">
		  <title><database>RDB$GET_CONTEXT()</database></title>
		  <note>
		    <para><database>RDB$GET_CONTEXT</database> and its counterpart
		    <database>RDB$SET_CONTEXT</database> are actually predeclared UDFs. They are listed here as
		    internal functions because they are always present – the user doesn't have to do anything to
		    make them available.</para>
		  </note>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		    <!--Since it's a declared UDF, it should be availabe in ESQL-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Retrieves the value of a context variable from one of the namespaces
		    <database>SYSTEM</database>, <database>USER_SESSION</database> and
		    <database>USER_TRANSACTION</database>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR(255)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RDB$GET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>')

		<replaceable>&lt;namespace&gt;</replaceable>  ::=  SYSTEM | USER_SESSION | USER_TRANSACTION
		<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title role="block">The namespaces</title>
		    <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
		    namespaces are initially empty. The user can create and set variables in them with
		    <database>RDB$SET_CONTEXT()</database> and retrieve them with
		    <database>RDB$GET_CONTEXT()</database>. The <database>SYSTEM</database> namespace is
		    read-only. It contains a number of predefined variables, shown in the table below.<table
		        border="topbot" id="langrefupd25-tbl-systemnamespace">
		        <title>Context variables in the SYSTEM namespace</title>
		        <tgroup cols="2">
		          <colspec colname="colVarname" colwidth="1*" />
		          <colspec colname="colVardescr" colwidth="3*" />
		          <tbody>
		            <row valign="top">
		              <entry><varname>DB_NAME</varname></entry>
		              <entry>Either the full path to the database or – if connecting via the path is
		              disallowed – its alias.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>NETWORK_PROTOCOL</varname></entry>
		              <entry>The protocol used for the connection: <literal>'TCPv4'</literal>,
		              <literal>'WNET'</literal>, <literal>'XNET'</literal> or
		              <constant>NULL</constant>.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>CLIENT_ADDRESS</varname></entry>
		              <entry>For TCPv4, this is the IP address. For XNET, the local process ID. For all
		              other protocols this variable is <constant>NULL</constant>.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>CURRENT_USER</varname></entry>
		              <entry>Same as global <link
		              linkend="langrefupd25-current_user"><varname>CURRENT_USER</varname></link>
		              variable.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>CURRENT_ROLE</varname></entry>
		              <entry>Same as global <link
		              linkend="langrefupd25-current_role"><varname>CURRENT_ROLE</varname></link>
		              variable.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>SESSION_ID</varname></entry>
		              <entry>Same as global <link
		              linkend="langrefupd25-current_connection"><varname>CURRENT_CONNECTION</varname></link>
		              variable.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>TRANSACTION_ID</varname></entry>
		              <entry>Same as global <link
		              linkend="langrefupd25-current_transaction"><varname>CURRENT_TRANSACTION</varname></link>
		              variable.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>ISOLATION_LEVEL</varname></entry>
		              <entry>The isolation level of the current transaction: <literal>'READ</literal>
		              <literal>COMMITTED'</literal>, <literal>'SNAPSHOT'</literal> or
		              <literal>'CONSISTENCY'</literal>.</entry>
		            </row>
		            <row valign="top">
		              <entry><varname>ENGINE_VERSION</varname></entry>
		              <entry>The Firebird engine (server) version. Added in 2.1.</entry>
		            </row>
		          </tbody>
		        </tgroup>
		      </table></para>
		  </formalpara>
		  <formalpara>
		    <title>Return values and error behaviour</title>
		    <para>If the polled variable exists in the given namespace, its value will be returned as a
		    string of max. 255 characters. If the namespace doesn't exist or if you try to access a
		    non-existing variable in the <database>SYSTEM</database> namespace, an error is raised. If
		    you poll a non-existing variable in one of the other namespaces, <constant>NULL</constant>
		    is returned. Both namespace and variable names must be given as single-quoted,
		    case-sensitive, non-<constant>NULL</constant> strings.</para>
		    <!--Funny enough, a variable's name may be the empty string.-->
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database</programlisting>
		      </blockquote><blockquote>
		        <programlisting>New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');</programlisting>
		        <programlisting>insert into MyTable (TestField)
		values (rdb$get_context('USER_SESSION', 'MyVar'))</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-set_context"><database>RDB$SET_CONTEXT()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-set_context">
		  <title><database>RDB$SET_CONTEXT()</database></title>
		  <note>
		    <para><database>RDB$SET_CONTEXT</database> and its counterpart
		    <database>RDB$GET_CONTEXT</database> are actually predeclared UDFs. They are listed here as
		    internal functions because they are always present – the user doesn't have to do anything to
		    make them available.</para>
		  </note>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		    <!--Since it's a declared UDF, it should be availabe in ESQL-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Creates, sets or unsets a variable in one of the user-writable namespaces
		    <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RDB$SET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>', <replaceable>&lt;value&gt;</replaceable> | <constant>NULL</constant>)

		<replaceable>&lt;namespace&gt;</replaceable>  ::=  USER_SESSION | USER_TRANSACTION
		<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters
		<replaceable>&lt;value&gt;</replaceable>      ::=  A value of any type, as long as it's castable
		              to a VARCHAR(255)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title role="block">The namespaces</title>
		    <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
		    namespaces are initially empty. The user can create and set variables in them with
		    <database>RDB$SET_CONTEXT()</database> and retrieve them with
		    <database>RDB$GET_CONTEXT()</database>. The <database>USER_SESSION</database> context is
		    bound to the current connection. Variables in <database>USER_TRANSACTION</database> only
		    exist in the transaction in which they have been set. When the transaction ends, the context
		    and all the variables defined in it are destroyed.</para>
		  </formalpara>
		  <formalpara>
		    <title role="block">Return values and error behaviour</title>
		    <para>The function returns 1 if the variable already existed before the call and 0 if it
		    didn't. To remove a variable from a context, set it to <constant>NULL</constant>. If the
		    given namespace doesn't exist, an error is raised. Both namespace and variable names must be
		    entered as single-quoted, case-sensitive, non-<constant>NULL</constant> strings.</para>
		    <!--Funny enough, a variable's name may be the empty string.-->
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database</programlisting>
		      </blockquote><blockquote>
		        <programlisting>rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);</programlisting>
		        <programlisting>select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
		from rdb$database</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Notes</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>The maximum number of variables in any single context is 1000.</para>
		        </listitem>
		        <listitem>
		          <para>All <database>USER_TRANSACTION</database> variables will survive a <link
		          linkend="langrefupd25-rollback-retain"><database>ROLLBACK RETAIN</database></link> or
		          <link linkend="langrefupd25-rollback-to-savepoint"><database>ROLLBACK TO
		          SAVEPOINT</database></link> unaltered, no matter at which point during the transaction
		          they were set.</para>
		        </listitem>
		        <listitem>
		          <para>Due to its UDF-like nature, <database>RDB$SET_CONTEXT</database> can – in PSQL
		          only – be called like a void function, without assigning the result, as in the second
		          example above. Regular internal functions don't allow this type of use.</para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-get_context"><database>RDB$GET_CONTEXT()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-replace">
		  <title><database>REPLACE()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Replaces all occurrences of a substring in a string.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>REPLACE (<replaceable>str</replaceable>, <replaceable>find</replaceable>, <replaceable>repl</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>This function fully supports text <database>BLOB</database>s of any length and
		            character set.</para>
		          </listitem>
		          <listitem>
		            <para>If any argument is a <database>BLOB</database>, the result is a
		            <database>BLOB</database>. Otherwise, the result is a
		            <database>VARCHAR(<replaceable>n</replaceable>) with <replaceable>n</replaceable>
		            calculated from the lengths of <replaceable>str</replaceable>,
		            <replaceable>find</replaceable> and <replaceable>repl</replaceable> in such a way
		            that even the maximum possible number of replacements won't overflow the
		            field.</database></para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>find</replaceable> is the empty string,
		            <replaceable>str</replaceable> is returned unchanged.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>repl</replaceable> is the empty string, all occurrences of
		            <replaceable>find</replaceable> are deleted from
		            <replaceable>str</replaceable>.</para>
		          </listitem>
		          <listitem>
		            <para>If any argument is <constant>NULL</constant>, the result is always
		            <constant>NULL</constant>, even if nothing would have been replaced.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>replace ('Billy Wilder',  'il', 'oog')     -- returns 'Boogly Woogder'
		replace ('Billy Wilder',  'il',    '')     -- returns 'Bly Wder'
		replace ('Billy Wilder',  null, 'oog')     -- returns <constant>NULL</constant>
		replace ('Billy Wilder',  'il',  null)     -- returns <constant>NULL</constant>
		replace ('Billy Wilder', 'xyz',  null)     -- returns <constant>NULL</constant> (!)
		replace ('Billy Wilder', 'xyz', 'abc')     -- returns 'Billy Wilder'
		replace ('Billy Wilder',    '', 'abc')     -- returns 'Billy Wilder'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. This may affect performance if huge <database>BLOB</database>s are
		    involved.</para>
		  </warning>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-overlay"><database>OVERLAY()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-reverse">
		  <title><database>REVERSE()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns a string backwards.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>REVERSE (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>reverse ('spoonful')                 -- returns 'lufnoops'
		reverse ('Was it a cat I saw?')      -- returns '?was I tac a ti saW'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <tip>
		    <para>This function comes in very handy if you want to group, search or order on string
		    endings, e.g. when dealing with domain names or email addresses:</para>
		    <programlisting>create index ix_people_email on people
		computed by (reverse(email));

		select * from people
		where reverse(email) starting with reverse('.br');</programlisting>
		  </tip>
		</section>
		<section id="langref25-functions-scalarfuncs-right">
		  <title><database>RIGHT()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the rightmost part of the argument string. The number of characters is given
		    in the second argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RIGHT (<replaceable>string</replaceable>, <replaceable>length</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>This function supports text <database>BLOB</database>s of any length, but has
		            a bug in versions 2.1–2.1.3 and 2.5 that makes it fail with text
		            <database>BLOB</database>s larger than 1024 bytes that have a multi-byte character
		            set. This has been fixed in versions 2.1.4 and 2.5.1.<!--Reported as CORE-3228. Bug present in 2.1-2.1.3 and 2.5 - fixed for 2.1.4, 2.5.1, 3.0
		Notice: the limit is 1024 BYTES, not characters.--></para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>string</replaceable> is a <database>BLOB</database>, the
		            result is a <database>BLOB</database>. Otherwise, the result is a
		            <database>VARCHAR(<replaceable>n</replaceable>)</database> with
		            <replaceable>n</replaceable> the length of the input string.</para>
		          </listitem>
		          <listitem>
		            <para>If the <replaceable>length</replaceable> argument exceeds the string length,
		            the input string is returned unchanged.</para>
		          </listitem>
		          <listitem>
		            <para>If the <replaceable>length</replaceable> argument is not a whole number,
		            bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5
		            becomes 2, 3.5 becomes 4, etc.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. This may affect performance if huge <database>BLOB</database>s are
		    involved.</para>
		  </warning>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-sright">external function
		    <function>RIGHT</function></link> is declared in your database as <function>right</function>
		    instead of the default <function>sright</function>, it will override the internal function.
		    To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-left"><database>LEFT()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-round">
		  <title><database>ROUND()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Rounds a number to the nearest integer. If the fractional part is exactly
		    <literal>0.5</literal>, rounding is upward for positive numbers and downward for negative
		    numbers. With the optional <parameter>scale</parameter> argument, the number can be rounded
		    to powers-of-ten multiples (tens, hundreds, tenths, hundredths, etc.) instead of just
		    integers.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database>, (scaled) <database>BIGINT</database> or
		    <database>DOUBLE</database></para>
		    <!--DOUBLE if the first arg is a statement parameter-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>ROUND (<replaceable>&lt;number&gt;</replaceable> [, <replaceable>&lt;scale&gt;</replaceable>])

		<replaceable>&lt;number&gt;</replaceable>  ::=  a numerical expression
		<replaceable>&lt;scale&gt;</replaceable>   ::=  an integer specifying the number of decimal places
		           toward which should be rounded, e.g.:
		              2 for rounding to the nearest multiple of 0.01
		              1 for rounding to the nearest multiple of 0.1
		              0 for rounding to the nearest whole number
		             -1 for rounding to the nearest multiple of 10
		             -2 for rounding to the nearest multiple of 100</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Notes</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>If the <parameter>scale</parameter> argument is present, the result usually has
		          the same scale as the first argument, e.g.</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para>ROUND(123.654, 1) returns 123.700 (not 123.7)</para>
		            </listitem>
		            <listitem>
		              <para>ROUND(8341.7, -3) returns 8000.0 (not 8000)</para>
		            </listitem>
		            <listitem>
		              <para>ROUND(45.1212, 0) returns 45.0000 (not 45)</para>
		            </listitem>
		          </itemizedlist>
		          <para>Otherwise, the result scale is 0:</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para>ROUND(45.1212) returns 45</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <important>
		    <itemizedlist>
		      <listitem>
		        <para>If the <link linkend="langrefupd25-udf-round">external function
		        <function>ROUND</function></link> is declared in your database, it will override the
		        internal function. To make the internal function available, <link
		        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		        function (UDF).</para>
		        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		      </listitem>
		      <listitem>
		        <para>If you are used to the behaviour of the external function
		        <function>ROUND</function>, please notice that the <emphasis>internal</emphasis>
		        function always rounds halves away from zero, i.e. downward for negative numbers.</para>
		      </listitem>
		    </itemizedlist>
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-rpad">
		  <title><database>RPAD()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.5 (backported to 2.1.4)</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Right-pads a string with spaces or with a user-supplied string until a given length is
		    reached.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>RPAD (<replaceable>str</replaceable>, <replaceable>endlen</replaceable> [, <replaceable>padstr</replaceable>])</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>This function fully supports text <database>BLOB</database>s of any length and
		            character set.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>str</replaceable> is a <database>BLOB</database>, the result
		            is a <database>BLOB</database>. Otherwise, the result is a
		            <database>VARCHAR</database>(<replaceable>endlen</replaceable>).</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>padstr</replaceable> is given and equals <literal>''</literal>
		            (empty string), no padding takes place.</para>
		          </listitem>
		          <listitem>
		            <para>If <replaceable>endlen</replaceable> is less than the current string length,
		            the string is truncated to <replaceable>endlen</replaceable>, even if
		            <replaceable>padstr</replaceable> is the empty string.</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-rpad">external function
		    <function>RPAD</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		  <note>
		    <para>In Firebird 2.1–2.1.3, all non-BLOB results were of type
		    <database>VARCHAR</database>(32765), which made it advisable to cast them to a more modest
		    size. This is no longer the case.</para>
		    <!--CORE-1346, backported to 2.1.4
		Actually, the length was 32765 for single-byte charsets, 8191 for UTF8, etc.-->
		  </note>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <para><programlisting>rpad ('Hello', 12)                 -- returns 'Hello       '
		rpad ('Hello', 12, '-')            -- returns 'Hello-------'
		rpad ('Hello', 12, '')             -- returns 'Hello'
		rpad ('Hello', 12, 'abc')          -- returns 'Helloabcabca'
		rpad ('Hello', 12, 'abcdefghij')   -- returns 'Helloabcdefg'
		rpad ('Hello', 2)                  -- returns 'He'
		rpad ('Hello', 2, '-')             -- returns 'He'
		rpad ('Hello', 2, '')              -- returns 'He'</programlisting></para>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. Although it does try to limit memory consumption, this may affect
		    performance if huge <database>BLOB</database>s are involved.</para>
		  </warning>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-lpad"><database>LPAD()</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-sign">
		  <title><database>SIGN()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the sign of the argument: -1, 0 or 1.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>SMALLINT</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SIGN (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-sign">external function
		    <function>SIGN</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-sin">
		  <title><database>SIN()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns an angle's sine. The argument must be given in radians.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SIN (<replaceable>angle</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>Any non-<constant>NULL</constant> result is – obviously – in the range [-1,
		            1].</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-sin">external function
		    <function>SIN</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-sinh">
		  <title><database>SINH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the hyperbolic sine of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SINH (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-sinh">external function
		    <function>SINH</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-sqrt">
		  <title><database>SQRT()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the square root of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SQRT (<replaceable>number</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-sqrt">external function
		    <function>SQRT</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-substring">
		  <title><database>SUBSTRING()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>1.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.0, 2.1, 2.1.5, 2.5.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns a string's substring starting at the given position, either to the end of the
		    string or with a given length.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR(<replaceable>n</replaceable>)</database> or
		    <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>SUBSTRING (<replaceable>str</replaceable> FROM <replaceable>startpos</replaceable> [FOR <replaceable>length</replaceable>])</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <para>This function returns the substring starting at character position
		  <replaceable>startpos</replaceable> (the first position being 1). Without the
		  <database>FOR</database> argument, it returns all the remaining characters in the string. With
		  <database>FOR</database>, it returns <replaceable>length</replaceable> characters or the
		  remainder of the string, whichever is shorter.</para>
		  <para>In Firebird 1.x, <replaceable>startpos</replaceable> and
		  <replaceable>length</replaceable> must be integer literals. In 2.0 and above they can be any
		  valid integer expression.</para>
		  <para>Starting with Firebird 2.1, this function fully supports binary and text
		  <database>BLOB</database>s of any length and character set. If <replaceable>str</replaceable>
		  is a <database>BLOB</database>, the result is also a <database>BLOB</database>. For any other
		  argument type, the result is a <database>VARCHAR</database>(<replaceable>n</replaceable>).
		  Previously, the result type used to be <database>CHAR</database>(<replaceable>n</replaceable>)
		  if the argument was a <database>CHAR</database>(<replaceable>n</replaceable>) or a string
		  literal.</para>
		  <para>For non-<database>BLOB</database> arguments, the width of the result field is always
		  equal to the length of <replaceable>str</replaceable>, regardless of
		  <replaceable>startpos</replaceable> and <replaceable>length</replaceable>. So,
		  <code>substring('pinhead' from 4 for 2)</code> will return a <database>VARCHAR(7)</database>
		  containing the string <literal>'he'</literal>.</para>
		  <para>If any argument is <constant>NULL</constant>, the result is
		  <constant>NULL</constant>.</para>
		  <warning>
		    <title>Bugs</title>
		    <itemizedlist>
		      <listitem>
		        <para>If <replaceable>str</replaceable> is a <database>BLOB</database> and the
		        <replaceable>length</replaceable> argument is not present, the output is limited to
		        32767 characters. Workaround: with long <database>BLOB</database>s, always specify
		        char_length(<replaceable>str</replaceable>) – or a sufficiently high integer – as the
		        third argument, unless you are sure that the requested substring fits within 32767
		        characters.</para>
		        <para>This bug has been fixed in version 2.5.1; the fix was also backported to
		        2.1.5.<!--CORE-3245
		Indeed, it takes max 32767 CHARACTERS - the number of BYTES may be larger.
		Fixed 2 Feb 2011 by Dmitry for 2.1.5, 2.5.1, 3.0 alpha 1--></para>
		      </listitem>
		      <listitem>
		        <para>A bug in Firebird 2.0 which caused the function to return <quote>false
		        emptystrings</quote> if <replaceable>startpos</replaceable> or
		        <replaceable>length</replaceable> was <constant>NULL</constant>, has been fixed.<!--Also in later 2.0.x versions?--></para>
		      </listitem>
		    </itemizedlist>
		  </warning>
		  <formalpara>
		    <title>Example</title>
		    <para><blockquote>
		        <programlisting>insert into AbbrNames(AbbrName)
		select substring(LongName from 1 for 3) from LongNames</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. Although it does try to limit memory consumption, this may affect
		    performance if huge <database>BLOB</database>s are involved.</para>
		  </warning>
		</section>
		<section id="langref25-functions-scalarfuncs-tan">
		  <title><database>TAN()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns an angle's tangent. The argument must be given in radians.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>TAN (<replaceable>angle</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-tan">external function
		    <function>TAN</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-tanh">
		  <title><database>TANH()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the hyperbolic tangent of the argument.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>DOUBLE PRECISION</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>TANH (<replaceable>number</replaceable>)</programlisting>
		        <itemizedlist>
		          <listitem>
		            <para>Due to rounding, any non-<constant>NULL</constant> result is in the range [-1,
		            1] (mathematically, it's &lt;-1, 1&gt;).</para>
		          </listitem>
		        </itemizedlist>
		      </blockquote></para>
		  </formalpara>
		  <important>
		    <para>If the <link linkend="langrefupd25-udf-tanh">external function
		    <function>TANH</function></link> is declared in your database, it will override the internal
		    function. To make the internal function available, <link
		    linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
		    linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
		    function (UDF).</para>
		    <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-trim">
		  <title><database>TRIM()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL: no-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.0</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Removes leading and/or trailing spaces (or optionally other strings) from the input
		    string. Since Firebird 2.1 this function fully supports text <database>BLOB</database>s of
		    any length and character set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>VARCHAR(<replaceable>n</replaceable>)</database> or
		    <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>TRIM ([<replaceable>&lt;adjust&gt;</replaceable>] <replaceable>str</replaceable>)

		<replaceable>&lt;adjust&gt;</replaceable>  ::=  {[<replaceable>where</replaceable>] [<replaceable>what</replaceable>]} FROM

		<replaceable>where</replaceable>     ::=  BOTH | LEADING | TRAILING       /* default is BOTH */

		<replaceable>what </replaceable>     ::=  The substring to be removed (repeatedly if necessary)
		           from <replaceable>str</replaceable>'s head and/or tail. Default is ' ' (space).</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select trim ('  Waste no space   ') from rdb$database
		-- returns 'Waste no space'</programlisting>
		        <programlisting>select trim (leading from '  Waste no space   ') from rdb$database
		-- returns 'Waste no space   '</programlisting>
		        <programlisting>select trim (leading '.' from '  Waste no space   ') from rdb$database
		-- returns '  Waste no space   '</programlisting>
		        <programlisting>select trim (trailing '!' from 'Help!!!!') from rdb$database
		-- returns 'Help'</programlisting>
		        <programlisting>select trim ('la' from 'lalala I love you Ella') from rdb$database
		-- returns ' I love you El'</programlisting>
		        <programlisting>select trim ('la' from 'Lalala I love you Ella') from rdb$database
		-- returns 'Lalala I love you El'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Notes</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>If <replaceable>str</replaceable> is a <database>BLOB</database>, the result is
		          a <database>BLOB</database>. Otherwise, it is a
		          <database>VARCHAR</database>(<replaceable>n</replaceable>) with
		          <replaceable>n</replaceable> the formal length of
		          <replaceable>str</replaceable>.</para>
		        </listitem>
		        <listitem>
		          <para>The substring to be removed, if specified, may not be bigger than 32767 bytes.
		          However, if this substring is <emphasis>repeated</emphasis> at
		          <replaceable>str</replaceable>'s head or tail, the total number of bytes removed may
		          be far greater. (The restriction on the size of the substring will be lifted in
		          Firebird 3.)<!--CORE-3234: Lifting of this restriction requested. Fixed by Adriano for 3.0 alpha 1.--></para>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <warning>
		    <para>When used on a <database>BLOB</database>, this function may need to load the entire
		    object into memory. This may affect performance if huge <database>BLOB</database>s are
		    involved.</para>
		  </warning>
		</section>
		<section id="langref25-functions-scalarfuncs-trunc">
		  <title><database>TRUNC()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the integer part of a number. With the optional <parameter>scale</parameter>
		    argument, the number can be truncated to powers-of-ten multiples (tens, hundreds, tenths,
		    hundredths, etc.) instead of just integers.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>INTEGER</database>, (scaled) <database>BIGINT</database> or
		    <database>DOUBLE</database></para>
		    <!--DOUBLE if the first arg is a statement parameter-->
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>TRUNC (<replaceable>&lt;number&gt;</replaceable> [, <replaceable>&lt;scale&gt;</replaceable>])

		<replaceable>&lt;number&gt;</replaceable>  ::=  a numerical expression
		<replaceable>&lt;scale&gt;</replaceable>   ::=  an integer specifying the number of decimal places
		           toward which should be truncated, e.g.:
		              2 for truncating to a multiple of 0.01
		              1 for truncating to a multiple of 0.1
		              0 for truncating to a whole number
		             -1 for truncating to a multiple of 10
		             -2 for truncating to a multiple of 100</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Notes</title>
		    <para><itemizedlist>
		        <listitem>
		          <para>If the <parameter>scale</parameter> argument is present, the result usually has
		          the same scale as the first argument, e.g.</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><database>TRUNC</database>(789.2225, 2) returns 789.2200 (not 789.22)</para>
		            </listitem>
		            <listitem>
		              <para><database>TRUNC</database>(345.4, -2) returns 300.0 (not 300)</para>
		            </listitem>
		            <listitem>
		              <para><database>TRUNC</database>(-163.41, 0) returns -163.00 (not -163)</para>
		            </listitem>
		          </itemizedlist>
		          <para>Otherwise, the result scale is 0:</para>
		          <itemizedlist spacing="compact">
		            <listitem>
		              <para><database>TRUNC</database>(-163.41) returns -163</para>
		            </listitem>
		          </itemizedlist>
		        </listitem>
		      </itemizedlist></para>
		  </formalpara>
		  <important>
		    <para>If you are used to the behaviour of the <link
		    linkend="langrefupd25-udf-truncate">external function <function>TRUNCATE</function></link>,
		    please notice that the <emphasis>internal</emphasis> function <database>TRUNC</database>
		    always truncates toward zero, i.e. upward for negative numbers.</para>
		  </important>
		</section>
		<section id="langref25-functions-scalarfuncs-upper">
		  <title><database>UPPER()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, ESQL, PSQL</para>
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>IB</para>
		  </formalpara>
		  <formalpara>
		    <title>Changed in</title>
		    <para>2.0, 2.1</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Returns the upper-case equivalent of the input string. The exact result depends on the
		    character set. With <database>ASCII</database> or <database>NONE</database> for instance,
		    only ASCII characters are uppercased; with <database>OCTETS</database>, the entire string is
		    returned unchanged. Since Firebird 2.1 this function also fully supports text
		    <database>BLOB</database>s of any length and character set.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>(VAR)CHAR</database> or <database>BLOB</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>UPPER (<replaceable>str</replaceable>)</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select upper(_iso8859_1 'Débâcle')
		from rdb$database
		-- returns 'DÉBÂCLE' (before Firebird 2.0: 'DéBâCLE')</programlisting>
		        <programlisting>select upper(_iso8859_1 'Débâcle' collate fr_fr)
		from rdb$database
		-- returns 'DEBACLE', following French uppercasing rules</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link linkend="langref25-functions-scalarfuncs-lower"><database>LOWER</database></link></para>
		  </formalpara>
		</section>
		<section id="langref25-functions-scalarfuncs-uuid_to_char">
		  <title><database>UUID_TO_CHAR()</database></title>
		  <formalpara>
		    <title>Available in</title>
		    <para>DSQL, PSQL</para>
		    <!--ESQL ?-->
		  </formalpara>
		  <formalpara>
		    <title>Added in</title>
		    <para>2.5</para>
		  </formalpara>
		  <formalpara>
		    <title>Description</title>
		    <para>Converts a 16-byte UUID to its 36-character, human-readable ASCII
		    representation.</para>
		  </formalpara>
		  <formalpara>
		    <title>Result type</title>
		    <para><database>CHAR(36)</database></para>
		  </formalpara>
		  <formalpara>
		    <title>Syntax</title>
		    <para><blockquote>
		        <programlisting>UUID_TO_CHAR (<replaceable>uuid</replaceable>)

		<replaceable>uuid</replaceable>  ::=  a string consisting of 16 single-byte characters</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>Examples</title>
		    <para><blockquote>
		        <programlisting>select uuid_to_char(x'876C45F4569B320DBCB4735AC3509E5F') from rdb$database
		-- returns '876C45F4-569B-320D-BCB4-735AC3509E5F'

		select uuid_to_char(gen_uuid()) from rdb$database
		-- returns e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

		select uuid_to_char('Firebird swings!') from rdb$database
		-- returns '46697265-6269-7264-2073-77696E677321'</programlisting>
		      </blockquote></para>
		  </formalpara>
		  <formalpara>
		    <title>See also</title>
		    <para><link
		    linkend="langref25-functions-scalarfuncs-char_to_uuid"><database>CHAR_TO_UUID()</database></link>,
		    <link linkend="langref25-functions-scalarfuncs-gen_uuid"><database>GEN_UUID()</database></link></para>
		  </formalpara>
		</section>
  
	</section>
		<section id="langref25-functions-aggfuncs">
		    <title>Aggregate functions</title>
		    <para>Aggregate functions operate on groups of records, rather than on individual records or
		    variables. They are often used in combination with a <database>GROUP BY</database>
		    clause.</para>
		    <section id="langref25-functions-aggfuncs-avg">
		      <title><database>AVG()</database></title>
		      <formalpara>
		        <title>Available in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Added in</title>
		        <para>IB</para>
		      </formalpara>
		      <formalpara>
		        <title>Changed in</title>
		        <para><!--Check with 2.0 to make sure!--></para>
		      </formalpara>
		      <formalpara>
		        <title>Description</title>
		        <para><database>AVG</database> returns the average argument value in the group. </para>
		      </formalpara>
		      <formalpara>
		        <title>Result type</title>
		        <para>Integer</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>AVG (<replaceable>expression</replaceable>)</programlisting>
		            <itemizedlist>
		              <listitem>
		                <para>If the group is empty or contains only <database>NULL</database>s, the result
		                is <database>NULL</database>.</para>
		              </listitem>
		            </itemizedlist>
		          </blockquote></para>
		      </formalpara>
		    </section>
		    <section id="langref25-functions-aggfuncs-count">
		      <title><database>COUNT()</database></title>
		      <formalpara>
		        <title>Available in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Added in</title>
		        <para>IB</para>
		      </formalpara>
		      <formalpara>
		        <title>Changed in</title>
		        <para><!--Check with 2.0 to make sure!--></para>
		      </formalpara>
		      <formalpara>
		        <title>Description</title>
		        <para><database>COUNT</database> returns the number of non-null values in the group. </para>
		      </formalpara>
		      <formalpara>
		        <title>Result type</title>
		        <para>Integer</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>COUNT (<replaceable>expression</replaceable>)</programlisting>
		            <itemizedlist>
		              <listitem>
		                <para>If the group is empty or contains only <database>NULL</database>s, the result
		                is <database>0</database>.</para>
		              </listitem>
		            </itemizedlist>
		          </blockquote></para>
		      </formalpara>
		    </section>
		    <section id="langref25-functions-aggfuncs-list">
		      <title><database>LIST()</database></title>
		      <formalpara>
		        <title>Available in</title>
		        <para>DSQL, PSQL</para>
		        <!--ESQL?  -> Oleg Loa, Dmitry Yemanov-->
		      </formalpara>
		      <formalpara>
		        <title>Added in</title>
		        <para>2.1</para>
		      </formalpara>
		      <formalpara>
		        <title>Changed in</title>
		        <para>2.5</para>
		      </formalpara>
		      <formalpara>
		        <title>Description</title>
		        <para><database>LIST</database> returns a string consisting of the
		        non-<constant>NULL</constant> argument values in the group, separated either by a comma or
		        by a user-supplied delimiter. If there are no non-<constant>NULL</constant> values (this
		        includes the case where the group is empty), <constant>NULL</constant> is returned.</para>
		      </formalpara>
		      <formalpara>
		        <title>Result type</title>
		        <para><database><database>BLOB</database></database></para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>LIST ([ALL | DISTINCT] <replaceable>expression</replaceable> [, <replaceable>separator</replaceable>])</programlisting>
		            <itemizedlist>
		              <listitem>
		                <para><database>ALL</database> (the default) results in all
		                non-<constant>NULL</constant> values to be listed. With
		                <database>DISTINCT</database>, duplicates are removed, except if
		                <replaceable>expression</replaceable> is a <database>BLOB</database>.<!--CORE-3253--></para>
		              </listitem>
		              <listitem>
		                <para>In Firebird 2.5 and up, the optional <replaceable>separator</replaceable>
		                argument may be any string expression. This makes it possible to specify e.g.
		                <parameter><literal>ascii_char(13)</literal></parameter> as a separator. (This
		                improvement has also been backported to 2.1.4.)</para>
		              </listitem>
		              <listitem>
		                <para>The <replaceable>expression</replaceable> and
		                <replaceable>separator</replaceable> arguments support <database>BLOB</database>s of
		                any size and character set.</para>
		              </listitem>
		              <listitem>
		                <para>Date/time and numerical arguments are implicitly converted to strings before
		                concatenation.</para>
		              </listitem>
		              <listitem>
		                <para>The result is a text <database>BLOB</database>, except when
		                <replaceable>expression</replaceable> is a <database>BLOB</database> of another
		                subtype.</para>
		              </listitem>
		              <listitem>
		                <para>The ordering of the list values is undefined.</para>
		                <!--Rlsnotes say: implementation-defined. What does this mean: that they can differ between, say, Fb/Win and Fb/Linux?
		-> No, this seems to have been blindly copied from the SQL-2003 standard documents-->
		              </listitem>
		            </itemizedlist>
		          </blockquote></para>
		      </formalpara>
		    </section>
		    <section id="langref25-functions-aggfuncs-max">
		      <title><database>MAX()</database></title>
		      <formalpara>
		        <title>Available in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Added in</title>
		        <para>IB</para>
		      </formalpara>
		      <formalpara>
		        <title>Changed in</title>
		        <para>2.1<!--Check with 2.0 to make sure!--></para>
		      </formalpara>
		      <formalpara>
		        <title>Description</title>
		        <para><database>MAX</database> returns the maximum argument value in the group. If the
		        argument is a string, this is the value that comes last when the active collation is
		        applied.</para>
		      </formalpara>
		      <formalpara>
		        <title>Result type</title>
		        <para>Varies</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>MAX (<replaceable>expression</replaceable>)</programlisting>
		            <itemizedlist>
		              <listitem>
		                <para>If the group is empty or contains only <database>NULL</database>s, the result
		                is <database>NULL</database>.</para>
		              </listitem>
		              <listitem>
		                <para>Since Firebird 2.1, this function fully supports text
		                <database>BLOB</database>s of any size and character set.</para>
		              </listitem>
		            </itemizedlist>
		          </blockquote></para>
		      </formalpara>
		    </section>
		    <section id="langref25-functions-aggfuncs-min">
		    <section id="langref25-functions-aggfuncs-sum">
		      <title><database>SUM()</database></title>
		      <formalpara>
		        <title>Available in</title>
		        <para>DSQL, ESQL, PSQL</para>
		      </formalpara>
		      <formalpara>
		        <title>Added in</title>
		        <para>IB</para>
		      </formalpara>
		      <formalpara>
		        <title>Changed in</title>
		        <para><!--Check with 2.0 to make sure!--></para>
		      </formalpara>
		      <formalpara>
		        <title>Description</title>
		        <para><database>SUM</database> calculates and returns the sum of non-null values in the group. </para>
		      </formalpara>
		      <formalpara>
		        <title>Result type</title>
		        <para>Integer</para>
		      </formalpara>
		      <formalpara>
		        <title>Syntax</title>
		        <para><blockquote>
		            <programlisting>SUM (<replaceable>expression</replaceable>)</programlisting>
		            <itemizedlist>
		              <listitem>
		                <para>If the group is empty or contains only <database>NULL</database>s, the result
		                is <database>NULL</database>.</para>
		              </listitem>
		            </itemizedlist>
		          </blockquote></para>
		      </formalpara>
		    </section>
			</section>
  </section>
</chapter>
