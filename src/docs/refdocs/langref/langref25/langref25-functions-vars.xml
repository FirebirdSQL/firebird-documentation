<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="langref25-functions">
  <title>Built-in functions and variables</title>
  <section id="langref25-functions-contextvars">
    <title>Context variables</title>
  

		<section id="langref25-contextvars-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_CONNECTION</varname> contains the unique identifier of the current
        connection.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page
      and reset to 0 upon restore. Since version 2.1, it is incremented upon every new connection.
      (In previous versions, it was only incremented if the client read it during a session.) As a
      result, <varname>CURRENT_CONNECTION</varname> now indicates the number of connections since
      the creation – or most recent restoration – of the database.</para>
    </section>

		<section id="langref25-contextvars-current_role">
		  <title><varname>CURRENT_ROLE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the
        currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is
        <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><varname>CURRENT_ROLE</varname> always represents a valid role or
      <database>NONE</database>. If a user connects with a non-existing role, the engine silently
      resets it to <database>NONE</database> without returning an error.</para>
		</section>

    <section id="langref25-contextvars-current_time">
      <title><varname>CURRENT_TIME</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIME</varname> returns the current server time. In versions prior to
        2.0, the fractional part used to be always <quote><literal>.0000</literal></quote>, giving
        an effective precision of 0 decimals. From Firebird 2.0 onward you can specify a precision
        when polling this variable. The default is still 0 decimals, i.e. seconds precision.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIME</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIME [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_time from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select current_time(2) from rdb$database
-- returns e.g. 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Unlike <varname>CURRENT_TIME</varname>, the default precision of
              <varname>CURRENT_TIMESTAMP</varname> has changed to 3 decimals. As a result,
              <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum of
              <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIME</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langref25-contextvars-now"><literal>'NOW'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-current_timestamp">
      <title><varname>CURRENT_TIMESTAMP</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIMESTAMP</varname> returns the current server date and time. In
        versions prior to 2.0, the fractional part used to be always
        <quote><literal>.0000</literal></quote>, giving an effective precision of 0 decimals. From
        Firebird 2.0 onward you can specify a precision when polling this variable. The default is 3
        decimals, i.e. milliseconds precision.<!--This new functionality also available in ESQL? Dimtry says about the new ms precision:
"I believe it should be supported automagically." About the precision arg: "Not supported."--></para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIMESTAMP [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_timestamp from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <programlisting>select current_timestamp(2) from rdb$database
-- returns e.g. 2008-08-13 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The default precision of <varname>CURRENT_TIME</varname> is still 0 decimals, so
              in Firebird 2.0 and up <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum
              of <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIMESTAMP</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langref25-contextvars-now"><literal>'NOW'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TRANSACTION</varname> contains the unique identifier of the current
        transaction.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header
      page and reset to 0 upon restore. It is incremented with every new transaction.</para>
    </section>
    <section id="langref25-contextvars-current_user">
      <title><varname>CURRENT_USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <database>USER</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-deleting">
      <title><varname>DELETING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired
        because of a <database>DELETE</database> operation. Intended for use in <link
        linkend="langref25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-gdscode">
      <title><varname>GDSCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>GDSCODE</varname> context variable contains the numerical representation of the
        current Firebird error code. Prior to Firebird 2.0, <varname>GDSCODE</varname> was only set
        in <database>WHEN GDSCODE</database> handlers. Now it may also be non-zero in <database>WHEN
        ANY</database>, <database>WHEN SQLCODE</database> and <database>WHEN EXCEPTION</database>
        blocks, provided that the condition raising the error corresponds with a Firebird error
        code. Outside error handlers, <varname>GDSCODE</varname> is always 0. Outside PSQL it
        doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when gdscode grant_obj_notfound, gdscode grant_fld_notfound,
     gdscode grant_nopriv, gdscode grant_nopriv_on_base
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Please notice: After <database>WHEN GDSCODE</database>, you must use symbolic names like
      <errorcode>grant_obj_notfound</errorcode> etc. But the <varname>GDSCODE</varname> context
      variable is an <database>INTEGER</database>. If you want to compare it against a certain
      error, you have to use the numeric value, e.g. 335544551 for
      <errorcode>grant_obj_notfound</errorcode>.</para>
    </section>
    <section id="langref25-contextvars-inserting">
      <title><varname>INSERTING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger
        fired because of an <database>INSERT</database> operation. Intended for use in <link
        linkend="langref25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-new">
      <title><varname>NEW</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>NEW</varname> contains the new version of a database record that has just
        been inserted or updated. Starting with Firebird 2.0 it is read-only in
        <database>AFTER</database> triggers.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>NEW</varname> is
        always available. But if the trigger is fired by a <database>DELETE</database>, there will
        be no new version of the record. In that situation, reading from <varname>NEW</varname> will
        always return <constant>NULL</constant>; writing to it will cause a runtime
        exception.</para>
      </note>
    </section>
    <section id="langref25-contextvars-now">
      <title><literal>'NOW'</literal></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><literal>'NOW'</literal> is not a variable but a string literal. It is, however,
        special in the sense that when you <database>CAST()</database> it to a date/time type, you
        will get the current date and/or time. The fractional part of the time used to be always
        <quote><literal>.0000</literal></quote>, giving an effective seconds precision. Since
        Firebird 2.0 the precision is 3 decimals, i.e. milliseconds. <literal>'NOW'</literal> is
        case-insensitive, and the engine ignores leading or trailing spaces when casting.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(3)</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select 'Now' from rdb$database
-- returns 'Now'</programlisting>
            <programlisting>select cast('Now' as date) from rdb$database
-- returns e.g. 2008-08-13</programlisting>
            <programlisting>select cast('now' as time) from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select cast('NOW' as timestamp) from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <para><link linkend="langref25-shorthandcast">Shorthand syntax</link> for the last
            three statements:</para>
            <programlisting>select date 'Now' from rdb$database
select time 'now' from rdb$database
select timestamp 'NOW' from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><literal>'NOW'</literal> always returns the actual date/time, even in PSQL
              modules, where <varname>CURRENT_DATE</varname>, <link
              linkend="langref25-contextvars-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langref25-contextvars-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              return the same value throughout the duration of the outermost routine. This makes
              <literal>'NOW'</literal> useful for measuring time intervals in triggers, procedures
              and executable blocks.</para>
            </listitem>
            <listitem>
              <para>Except in the situation mentioned above, reading
              <varname>CURRENT_DATE</varname>, <link
              linkend="langref25-contextvars-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langref25-contextvars-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              is generally preferable to casting <literal>'NOW'</literal>. Be aware though that
              <varname>CURRENT_TIME</varname> defaults to seconds precision; to get milliseconds
              precision, use <varname>CURRENT_TIME</varname>(<parameter>3</parameter>).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-old">
      <title><varname>OLD</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>OLD</varname> contains the existing version of a database record just before
        a deletion or update. Starting with Firebird 2.0 it is read-only.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>OLD</varname> is
        always available. But if the trigger is fired by an <database>INSERT</database>, there is
        obviously no pre-existing version of the record. In that situation, reading from
        <varname>OLD</varname> will always return <constant>NULL</constant>; writing to it will
        cause a runtime exception.</para>
      </note>
    </section>
    <section id="langref25-contextvars-row_count">
      <title><varname>ROW_COUNT</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <varname>ROW_COUNT</varname> context variable contains the number of rows affected
        by the most recent DML statement (<database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database>, <database>SELECT</database> or <database>FETCH</database>) in
        the current trigger, stored procedure or executable block.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Behaviour with <database>SELECT</database> and <database>FETCH<!--Better make this a table!--></database></title>
        <para><itemizedlist>
            <listitem>
              <para>After a singleton <database>SELECT</database>, <varname>ROW_COUNT</varname> is 1
              if a data row was retrieved and 0 otherwise.</para>
            </listitem>
            <listitem>
              <para>In a <database>FOR SELECT</database> loop, <varname>ROW_COUNT</varname> is
              incremented with every iteration (starting at 0 before the first).</para>
            </listitem>
            <listitem>
              <para>After a <database>FETCH</database> from a cursor, <varname>ROW_COUNT</varname>
              is 1 if a data row was retrieved and 0 otherwise. Fetching more records from the same
              cursor does <emphasis>not</emphasis> increment <varname>ROW_COUNT</varname> beyond
              1.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.<replaceable>x</replaceable>, <varname>ROW_COUNT</varname> is 0
              after any type of <database>SELECT</database> statement.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <note>
        <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows affected
        by an <database>EXECUTE STATEMENT</database> or <database>EXECUTE PROCEDURE
        </database>command.</para>
      </note>
    </section>
    <section id="langref25-contextvars-sqlcode">
      <title><varname>SQLCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Deprecated in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>SQLCODE</varname> context variable contains the current SQL error code. Prior to
        Firebird 2.0, <varname>SQLCODE</varname> was only set in <database>WHEN SQLCODE</database>
        and <database>WHEN ANY</database> handlers. Now it may also be non-zero in <database>WHEN
        GDSCODE</database> and <database>WHEN EXCEPTION</database> blocks, provided that the
        condition raising the error corresponds with an SQL error code. Outside error handlers,
        <varname>SQLCODE</varname> is always 0. Outside PSQL it doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Important notice</title>
        <para><varname>SQLCODE</varname> is now deprecated in favour of the SQL-2003-compliant <link
        linkend="langref25-contextvars-sqlstate"><citetitle><varname>SQLSTATE</varname></citetitle></link>
        status code. Support for <varname>SQLCODE</varname> and <database>WHEN SQLCODE</database>
        will be discontinued in some future version of Firebird.</para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-sqlstate">
      <title><varname>SQLSTATE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handler, the
        <varname>SQLSTATE</varname> context variable contains the 5-character, SQL-2003-compliant
        status code resulting from the statement that raised the error. Outside error handlers,
        <varname>SQLSTATE</varname> is always '00000'. Outside PSQL it is not available at
        all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  Msg = case sqlstate
          when '22003' then 'Numeric value out of range.'
          when '22012' then 'Division by zero.'
          when '23000' then 'Integrity constraint violation.'
          else 'Something bad happened! SQLSTATE = ' || sqlstate
        end;  
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><database>SQLSTATE</database> is destined to replace
              <database>SQLCODE</database>. The latter is now deprecated in Firebird and will
              disappear in some future version.</para>
            </listitem>
            <listitem>
              <para>Firebird does not (yet) support the syntax <quote><database>WHEN SQLSTATE ...
              DO</database></quote>. You have to use <database>WHEN ANY</database> and test the
              <varname>SQLSTATE</varname> variable within the handler.</para>
              <!--Request for improvement CORE-3526-->
            </listitem>
            <listitem>
              <para>Each <database>SQLSTATE</database> code is the concatenation of a 2-character
              class and a 3-character subclass. Classes 00 (successful completion), 01 (warning) and
              02 (no data) represent <firstterm>completion conditions</firstterm>. Every status code
              outside these classes is an <firstterm>exception</firstterm>. Because classes 00, 01
              and 02 don't raise an error, they won't ever show up in the
              <varname>SQLSTATE</varname> variable.</para>
            </listitem>
            <listitem>
              <para>For a complete listing of <database>SQLSTATE</database> codes, consult the
              <ulink
              url="http://www.firebirdsql.org/rlsnotesh/rlsnotes25.html#rnfb25-appx-sqlstates"><citetitle>Appendix
              to the Firebird 2.5 Release Notes</citetitle></ulink>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langref25-contextvars-updating">
      <title><varname>UPDATING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired
        because of an <database>UPDATE</database> operation. Intended for use in <link
        linkend="langref25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>




  </section>
  <section id="langref25-functions-scalarfuncs">
    <title>Scalar functions</title>
    <para>To be written.</para>
  </section>
  <section id="langref25-functions-aggfuncs">
    <title>Aggregate functions</title>
    <para>To be written.</para>
  </section>
</chapter>
