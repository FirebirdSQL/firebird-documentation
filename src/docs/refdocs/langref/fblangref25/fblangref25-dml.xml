<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-dml">
  <title>Data Manipulation (DML) Statements</title>
  <para>DML&mdash;data manipulation language&mdash; is the subset of SQL that is used 
  by applications and procedural modules to extract and change data.  Extraction, for 
  the purpose of reading data, both raw and manipulated, is achieved with the 
  <database>SELECT</database> statement.  <database>INSERT</database> is for adding new 
  data and <database>DELETE</database> is for erasing data that are no longer required. 
  <database>UPDATE</database>, <database>MERGE</database> and <database>INSERT OR 
  UPDATE</database> all modify data in various ways.</para>
<!-- ========================================================================================
                   S E L E C T
     ======================================================================================== -->

  <section id="fblangref25-dml-select">
    <title><database>SELECT</database></title>
    <formalpara>
      <title>Used for</title>
      <para>Retrieving data</para>
    </formalpara>
    <formalpara>
      <title>Available in</title>
      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Global syntax</title>

      <para><blockquote>
          <programlisting>SELECT
[WITH [RECURSIVE] &lt;cte&gt; [, &lt;cte&gt; ...]]
SELECT
  [FIRST m] [SKIP n]
  [DISTINCT | ALL] &lt;columns&gt;
FROM
  source [[AS] alias]
  [&lt;joins&gt;]
[WHERE &lt;condition&gt;]
[GROUP BY &lt;grouping-list&gt;
[HAVING &lt;aggregate-condition&gt;]]
[PLAN &lt;plan-expr&gt;]
[UNION [DISTINCT | ALL] &lt;other-select&gt;]
[ORDER BY &lt;ordering-list&gt;]
[ROWS m [TO n]]
[FOR UPDATE [OF &lt;columns&gt;]]
[WITH LOCK]
[INTO &lt;variables&gt;]

&lt;variables&gt; ::= [:]varname [, [:]varname ...]</programlisting>
        </blockquote></para>
    </formalpara>
    <bridgehead id="select" renderas="sect4">Description</bridgehead>
    <para>The <database>SELECT</database> statement retrieves data from the
    database and hands them to the application or the enclosing SQL statement.
    Data are returned in zero or more <firstterm>rows</firstterm>, each
    containing one or more <firstterm>columns</firstterm> or
    <firstterm>fields</firstterm>. The total of rows returned is the
    <firstterm>result set</firstterm> of the statement.</para>

    <para>The only mandatory parts of the <database>SELECT</database>
    statement are:</para>

    <itemizedlist>
      <listitem>
        <para>The SELECT keyword, followed by a columns list. This part
        specifies <emphasis>what</emphasis> you want to retrieve.</para>
      </listitem>

      <listitem>
        <para>The <database>FROM</database> keyword, followed by a selectable
        object. This tells the engine <emphasis>where</emphasis> you want to
        get it <emphasis>from</emphasis>.</para>
      </listitem>
    </itemizedlist>

    <para>In its most basic form, <database>SELECT</database> retrieves a
    number of columns from a single table or view, like this:</para>

    <blockquote>
      <programlisting>select id, name, address
  from contacts</programlisting>
    </blockquote>

    <para>Or, to retrieve all the columns:</para>

    <blockquote>
      <programlisting>select * from sales</programlisting>
    </blockquote>

    <para>In practice, the rows retrieved are often limited by a
    <database>WHERE</database> clause. The result set may be sorted by an
    <database>ORDER BY</database> clause, and <database>FIRST</database>,
    <database>SKIP</database> or <database>ROWS</database> may further limit
    the number of output rows. The column list may contain all kinds of
    expressions instead of just column names, and the source need not be a
    table or view: it may also be a derived table, a common table expression
    (CTE) or a selectable stored procedure (SP). Multiple sources may be
    combined in a <database>JOIN</database>, and multiple result sets may be
    combined in a <database>UNION</database>.</para>

    <para>The following sections discuss the available
    <database>SELECT</database> subclauses and their usage in detail.</para>

    <section id="fblangref25-dml-select-first-skip">
      <title><database>FIRST</database>, <database>SKIP</database></title>
      <formalpara>
        <title>Used for</title>
        <para>&nbsp;Retrieving a slice of rows from an ordered set</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SELECT
   [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
   FROM ...
   ...

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  <replaceable>integer-literal</replaceable> | <replaceable>query-parameter</replaceable> | (<replaceable>integer-expression</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <table id="fblangref25-dml-tbl-firstskip">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the FIRST and SKIP Clauses</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">integer literal</entry>
              <entry align="left">Integer literal</entry>
            </row>
            <row valign="middle">
              <entry align="center">query parameter</entry>
              <entry align="left">Query parameter place-holder. ? in DSQL and :paramname in PSQL</entry>
            </row>
            <row valign="middle">
              <entry align="center">integer-expression</entry>
              <entry align="left">Expression returning an integer value</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

     <note>
       <title>FIRST and SKIP are non-standard syntax</title>
        <para><database>FIRST</database> and <database>SKIP</database> are
        Firebird-specific, non-SQL-compliant keywords. You are advised to
        use the <link linkend="fblangref25-dml-select-rows"><database>ROWS</database></link>
        syntax wherever possible.</para>
      </note>

      <bridgehead id="firstskip" renderas="sect4">Description</bridgehead>
      <para><database>FIRST</database> limits the output of a query to the
      first <replaceable>m</replaceable> rows. <database>SKIP</database> will suppress
      the given <replaceable>n</replaceable> rows before starting to return output.</para>

      <para><database>FIRST</database> and <database>SKIP</database> are both
      optional. When used together as in <quote><database>FIRST</database>
      <replaceable>m</replaceable> <database>SKIP</database>
      <replaceable>n</replaceable></quote>, the <replaceable>n</replaceable>
      topmost rows of the output set are discarded and the first
      <replaceable>m</replaceable> rows of the rest of the set are returned.</para>

      <section id="fblangref25-dml-select-first-skip01">
        <title>Characteristics of <database>FIRST</database> and <database>SKIP</database></title>
        <itemizedlist>
          <listitem>Any argument to <database>FIRST</database> and <database>SKIP</database>
          that is not an integer literal or an SQL parameter must be enclosed in parentheses.
          This implies that a subquery expression must be enclosed in <emphasis>two</emphasis>
          pairs of parentheses.</listitem>
          <listitem><database>SKIP</database> 0 is allowed but totally pointless.</listitem>
          <listitem><database>FIRST</database> 0 is also allowed and returns an
          empty set.</listitem>
          <listitem> Negative <database>SKIP</database> and/or <database>FIRST</database>
          values result in an error.</listitem>
          <listitem>If a <database>SKIP</database> lands past the end of the dataset, an
          empty set is returned.</listitem>
          <listitem> If the number of rows in the dataset (or the remainder left after a
          <database>SKIP</database>) is less than the value of the <replaceable>m</replaceable>
          argument supplied for <database>FIRST</database>, that smaller number of rows is
          returned. These are valid results, not error conditions.</listitem>
        </itemizedlist>
        <caution>
          <para>An error occurs when you use FIRST in subqueries.  This query
            <literallayout class="monospaced">
DELETE FROM MYTABLE
  WHERE ID IN (SELECT FIRST 10 ID FROM MYTABLE)
            </literallayout>
          will delete ALL records from the table.  The subquery retrieves 10 rows each time,
          deletes them and the operation is repeated until the table is empty. Keep it in mind!
          Or, better, use the <link linkend="fblangref25-dml-select-rows">ROWS</link> clause
          in the DELETE statement.</para>
        </caution>
      </section>

      <bridgehead id="firstskipexamples" renderas="sect4">Examples</bridgehead>

      <para>The following query will return the first 10 names from the People
      table:</para>

      <blockquote>
        <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>The following query will return everything
      <emphasis>but</emphasis> the first 10 names:</para>

      <blockquote>
        <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>And this one returns the last 10 rows. Notice the double
      parentheses:</para>

      <blockquote>
        <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
      </blockquote>

      <para>This query returns rows 81 to 100 of the People table:</para>

      <blockquote>
        <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
      </blockquote>

      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-dml-select-rows"><database>ROWS</database></link>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-select-column-list">
      <title>The <database>SELECT</database> Columns List</title>

      <para>The columns list contains one or more comma-separated value
      expressions. Each expression provides a value for one output column.
      Alternatively, <literal>*</literal> (<quote>select star</quote>) can be
      used to stand for all the columns in a relation (i.e. a table, view or
      selectable stored procedure).</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   [...]
   [DISTINCT | ALL] <replaceable>&lt;output-column&gt;</replaceable> [, <replaceable>&lt;output-column&gt;</replaceable> ...]
   [...]
   FROM ...

<replaceable>&lt;output-column&gt;</replaceable>     ::=  [<replaceable>qualifier</replaceable>.]*
                           | <replaceable>&lt;value-expression&gt;</replaceable> [COLLATE <replaceable>collation</replaceable>] [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;value-expression&gt;</replaceable>  ::=  [<replaceable>qualifier</replaceable>.]<replaceable>table-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>view-column</replaceable>
                           | [<replaceable>qualifier</replaceable>.]<replaceable>selectable-SP-outparm</replaceable>
                           | <replaceable>constant</replaceable>
                           | <replaceable>context-variable</replaceable>
                           | <replaceable>function-call</replaceable>
                           | <replaceable>single-value-subselect</replaceable>
                           | <emphasis><database>CASE</database>-construct</emphasis>
                           | <quote>any other expression returning a single
                                value of a Firebird data type or <database>NULL</database></quote>

<replaceable>qualifier</replaceable>           ::=  a relation name or alias
<replaceable>collation</replaceable>           ::=  a valid collation name (only for character type columns)</programlisting>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-dml-tbl-columnslist">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the SELECT Columns List</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">qualifier</entry>
              <entry align="left">Name of relation (view, stored procedure, derived table); or an
              alias for it</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation	</entry>
              <entry align="left">Only for character-type columns: a collation name that exists and
              is valid for the character set of the data</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Column or field alias</entry>
            </row>
            <row valign="middle">
              <entry align="center">table-column</entry>
              <entry align="left">Name of a table column</entry>
            </row>
            <row valign="middle">
              <entry align="center">view-column</entry>
              <entry align="left">Name of a view column</entry>
            </row>
            <row valign="middle">
              <entry align="center">selectable-SP-outparm</entry>
              <entry align="left">Declared name of an output parameter of a selectable
              stored procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">constant</entry>
              <entry align="left">A constant</entry>
            </row>
            <row valign="middle">
              <entry align="center">context-variable</entry>
              <entry align="left">Context variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">function-call</entry>
              <entry align="left">Scalar or aggregate function call expression</entry>
            </row>
            <row valign="middle">
              <entry align="center">single-value-subselect</entry>
              <entry align="left">A subquery returning one scalar value (singleton)</entry>
            </row>
            <row valign="middle">
              <entry align="center">CASE-construct</entry>
              <entry align="left">CASE construct setting conditions for a return value</entry>
            </row>
            <row valign="middle">
              <entry align="center">other-single-value-expr </entry>
              <entry align="left">Any other expression returning a single value of a Firebird
              data type; or NULL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <bridgehead renderas="sect4">Description</bridgehead>

      <para>It is always valid to qualify a column name (or
      <quote><literal>*</literal></quote>) with the name or alias of the
      table, view or selectable SP to which it belongs, followed by a dot. e.g.,
      <function>relationname.columnname</function>, <function>relationname.*</function>,
      <function>alias.columnname</function>, <function>alias.*</function>.
      Qualifying is <command>required</command> if the column name occurs in 
      more than one relation taking part in a join. Qualifying
      <quote><literal>*</literal></quote> is always mandatory if it is not the 
      only item in the column list.</para>
      <important>
        <para>Aliases obfuscate the original relation name: once a table, view 
        or procedure has been aliased, only the alias can be used as its
        qualifier throughout the query. The relation name itself becomes 
        unavailable.</para>
      </important>

      <para>The column list may optionally be preceded by one of the keywords
      <database>DISTINCT</database> or <database>ALL</database>:
        <itemizedlist spacing="compact">
          <listitem><database>DISTINCT</database> filters out any duplicate rows. That is,
        if two or more rows have the same values in every corresponding column,
        only one of them is included in the result set</listitem>
        <listitem><database>ALL</database> is the default: it returns all of the rows, including
        duplicates. <database>ALL</database> is rarely used; it is supported for
        compliance with the SQL standard.</listitem>
        </itemizedlist>
      </para>

      <para>A <database>COLLATE</database> clause will not change the
      appearance of the column as such. However, if the specified collation
      changes the case or accent sensitivity of the column, it may
      influence:
      <itemizedlist spacing="compact">
        <listitem>
          <para>The ordering, if an <database>ORDER BY</database> clause is
          also present and it involves that column</para>
        </listitem>

        <listitem>
          <para>Grouping, if the column is part of a <database>GROUP
          BY</database> clause</para>
        </listitem>

        <listitem>
          <para>The rows retrieved (and hence the total number of rows in the
          result set), if <database>DISTINCT</database> is used</para>
        </listitem>
      </itemizedlist>
      </para>

      <bridgehead renderas="sect4">Examples of <database>SELECT</database> queries with
      different types of column lists</bridgehead>

      <para>A simple <database>SELECT</database> using only column
      names:</para>

      <blockquote>
        <programlisting>select cust_id, cust_name, phone
  from customers
  where city = 'London'</programlisting>
      </blockquote>

      <para>A query featuring a concatenation expression and a function call
      in the columns list:</para>

      <blockquote>
        <programlisting>select 'Mr./Mrs. ' || lastname, street, zip, upper(city)
  from contacts
  where date_last_purchase(id) = current_date</programlisting>
      </blockquote>

      <para>A query with two subselects:</para>

      <blockquote>
        <programlisting>select p.fullname,
       (select name from classes c where c.id = p.class) as class,
       (select name from mentors m where m.id = p.mentor) as mentor
from pupils p</programlisting>
      </blockquote>

      <para>The following query accomplishes the same as the previous one
      using joins instead of subselects:</para>

      <blockquote>
        <programlisting>select p.fullname,
       c.name as class,
       m.name as mentor
from pupils p
  join classes c on c.id = p.class
  join mentors m on m.id = p.mentor</programlisting>
      </blockquote>

      <para>This query uses a <database>CASE</database> construct to determine
      the correct title, e.g. when sending mail to a person:</para>

      <blockquote>
        <programlisting>select <emphasis role="bold">case upper(sex)
         when 'F' then 'Mrs.'
         when 'M' then 'Mr.'
         else ''
       end</emphasis> as title,
       lastname,
       address
from employees</programlisting>
      </blockquote>

      <para>Querying a selectable stored procedure:</para>

      <blockquote>
        <programlisting>select * from interesting_transactions(2010, 3, 'S')
  order by amount</programlisting>
      </blockquote>

      <para>Selecting from columns of a derived table. A derived table is a
      parenthesized <database>SELECT</database> statement whose result set is
      used in an enclosing query as if it were a regular table or view. The
      derived table is shown in bold here:</para>

      <blockquote>
        <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>
      </blockquote>

      <para>Asking the time through a context variable
      (<database>CURRENT_TIME</database>):</para>

      <blockquote>
        <programlisting>select current_time from rdb$database</programlisting>
      </blockquote>

      <para>For those not familiar with <database>RDB$DATABASE</database>:
      this is a system table that is present in all Firebird databases and is
      guaranteed to contain exactly one row. Although it wasn't created for
      this purpose, it has become standard practice among Firebird programmers
      to select from this table if you want to select <quote>from
      nothing</quote>, i.e., if you need data that are not bound to a any
      table or view, but can be derived from the expressions in the output
      columns alone. Another example is:</para>

      <blockquote>
        <programlisting>select power(12, 2) as twelve_squared, power(12, 3) as twelve_cubed
  from rdb$database</programlisting>
      </blockquote>

      <para>Finally, an example where you select some meaningful information
      from <database>RDB$DATABASE</database> itself:</para>

      <blockquote>
        <programlisting>select rdb$character_set_name from rdb$database</programlisting>
      </blockquote>

      <para>As you may have guessed, this will give you the default character
      set of the database.</para>
      
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-functions-scalarfuncs">Scalar Functions</link>,
        <link linkend="fblangref25-functions-aggfuncs">Aggregate Functions</link>,
        <link linkend="fblangref25-functions-contextvars">Context Variables</link>,
        <link linkend="fblangref25-commons-conditional-case"><database>CASE</database></link>,
        <link linkend="fblangref25-commons-subqueries">Subqueries</link>
        </para>
      </formalpara>

    </section> <!-- columns list -->


    <section id="fblangref25-dml-select-from">
      <title>The <database>FROM</database> clause</title>

      <para>The <database>FROM</database> clause specifies the source(s) from
      which the data are to be retrieved. In its simplest form, this is just a
      single table or view. But the source can also be a selectable stored
      procedure, a derived table or a common table expression. Multiple
      sources can be combined using various types of joins.</para>

      <para>This section concentrates on single-source selects. <link linkend="fblangref25-dml-select-joins">Joins</link> are
      discussed in a following section.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>&lt;derived-table&gt;</replaceable>
                          | <replaceable>&lt;common-table-expression&gt;</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;derived-table&gt;</replaceable>   ::=  (<replaceable>select-statement</replaceable>) [[AS] <replaceable>alias</replaceable>]
                         [(<replaceable>&lt;column-aliases&gt;</replaceable>)]

<replaceable>&lt;common-table-expression&gt;</replaceable>
                  ::=  WITH [RECURSIVE] <replaceable>&lt;cte-def&gt;</replaceable> [, <replaceable>&lt;cte-def&gt;</replaceable> ...]
                       <replaceable>select-statement</replaceable>

<replaceable>&lt;cte-def&gt;</replaceable>         ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-aliases&gt;</replaceable>)] AS (<replaceable>select-statement</replaceable>)

<replaceable>&lt;column-aliases&gt;</replaceable>  ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
          </blockquote></para>
      </formalpara>
      
      <table id="fblangref25-dml-tbl-from">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the FROM Clause</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">table</entry>
              <entry align="left">Name of a table</entry>
            </row>
            <row valign="middle">
              <entry align="center">view</entry>
              <entry align="left">Name of a view</entry>
            </row>
            <row valign="middle">
              <entry align="center">selectable-stored-procedure</entry>
              <entry align="left">Name of a selectable stored procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">args</entry>
              <entry align="left">Selectable stored procedure arguments</entry>
            </row>
            <row valign="middle">
              <entry align="center">derived table</entry>
              <entry align="left">Derived table query expression</entry>
            </row>
            <row valign="middle">
              <entry align="center">cte-def</entry>
              <entry align="left">Common table expression (CTE) definition, including
              an <quote>ad hoc</quote> name</entry>
            </row>
            <row valign="middle">
              <entry align="center">select-statement</entry>
              <entry align="left">Any SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-aliases</entry>
              <entry align="left">Alias for a column in a relation, CTE or derived table</entry>
            </row>
            <row valign="middle">
              <entry align="center">name</entry>
              <entry align="left">The <quote>ad hoc</quote> name for a CTE</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">The alias of a data source (table, view, procedure, CTE,
              derived table)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <section id="fblangref25-dml-select-from-table-view">
        <title>Selecting <database>FROM</database> a table or view</title>

        <para>When selecting from a single table or view, the
        <database>FROM</database> clause need not contain anything more than
        the name. An alias may be useful or even necessary if there are
        subqueries that refer to the main select statement (as they
        often do&mdash;subqueries like this are called <firstterm>correlated
        subqueries</firstterm>).</para>

        <bridgehead renderas="sect4">Examples</bridgehead>

        <blockquote>
          <programlisting>select id, name, sex, age from actors
  where state = 'Ohio'</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from birds
  where type = 'flightless'
  order by family, genus, species</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select firstname,
       middlename,
       lastname,
       date_of_birth,
       (select name from schools s where p.school = s.id) schoolname
from pupils p
where year_started = '2012'
order by schoolname, date_of_birth</programlisting>
        </blockquote>
        <important>
          <title>Never mix column names with column aliases!</title>
          <para>If you specify an alias for a table or a view, you must always use this 
          alias in place of the table name whenever you query the columns of the 
          relation (and wherever else you make a reference to columns, such as 
          ORDER BY, GROUP BY and WHERE clauses.</para>
          <para>Correct use:
            <blockquote><programlisting>
SELECT PEARS
FROM FRUIT

SELECT FRUIT.PEARS
FROM FRUIT

SELECT PEARS
FROM FRUIT F

SELECT F.PEARS
FROM FRUIT F
            </programlisting></blockquote>
        Incorrect use:
            <blockquote><programlisting>
SELECT FRUIT.PEARS
FROM FRUIT F
            </programlisting></blockquote>
          </para>
        </important>
      </section>

      <section id="fblangref25-dml-select-sp">
        <title>Selecting <database>FROM</database> a stored procedure</title>

        <para>A <firstterm>selectable stored procedure</firstterm> is a
        procedure that:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>contains at least one output parameter, and</para>
          </listitem>

          <listitem>
            <para>utilizes the <database>SUSPEND</database> keyword so the
            caller can fetch the output rows one by one, just as when
            selecting from a table or view.</para>
          </listitem>
        </itemizedlist>

        <para>The output parameters of a selectable stored procedure
        correspond to the columns of a regular table.</para>

        <para>Selecting from a stored procedure without input parameters is
        just like selecting from a table or view:</para>

        <blockquote>
          <programlisting>select * from suspicious_transactions
  where assignee = 'John'</programlisting>
        </blockquote>

        <para>Any required input parameters must be specified after the
        procedure name, enclosed in parentheses:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
  where alt &gt;= 20
  order by az, alt</programlisting>
        </blockquote>

        <para>Values for optional parameters (that is, parameters for which
        default values have been defined) may be omitted or provided. However,
        if you provide them only partly, the parameters you omit must all be
        at the tail end.</para>

        <para>Supposing that the procedure
        <systemitem>visible_stars</systemitem> from the previous example has
        two optional parameters: <parameter>min_magn</parameter>
        (numeric(3,1)) and <parameter>spectral_class</parameter>
        (varchar(12)), the following queries are all valid:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30')
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0)
select name, az, alt from visible_stars('Brugge', current_date, '22:30', 4.0, 'G')</programlisting>
        </blockquote>

        <para>But this one isn't, because there's a <quote>hole</quote> in the
        parameter list:</para>

        <blockquote>
          <programlisting>select name, az, alt from visible_stars('Brugge', current_date, '22:30', 'G')</programlisting>
        </blockquote>

        <para>An alias for a selectable stored procedure is specified
        <emphasis>after</emphasis> the parameter list:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = gw.number)
from get_winners('#34517', 'AMS') gw</programlisting>
        </blockquote>

        <para>If you refer to an output parameter (<quote>column</quote>) by
        qualifying it with the full procedure name, the parameter
        list should be omitted:</para>

        <blockquote>
          <programlisting>select number,
       (select name from contestants c where c.number = <emphasis role="bold">get_winners.number</emphasis>)
from get_winners('#34517', 'AMS')</programlisting>
        </blockquote>
        <formalpara>
          <title>See also</title>
          <para>&nbsp;<link linkend="fblangref25-psql-storedprocs">Stored Procedures</link>,
          <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>
          </para>
        </formalpara>
      </section>

      <section id="fblangref25-dml-select-from-dt">
        <title>Selecting <database>FROM</database> a derived table</title>

        <para>A derived table is a valid <database>SELECT</database> statement
        enclosed in parentheses, optionally followed by a table alias and/or
        column aliases. The result set of the statement acts as a virtual
        table which the enclosing statement can query.</para>
        <formalpara>
          <title>Syntax</title>
          <blockquote><programlisting>
(select-query)
  [[AS] <replaceable>derived-table-alias</replaceable>]
  [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

&lt;derived-column-aliases&gt; := <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]
          </programlisting></blockquote>
        </formalpara>
        <para>The set returned data set by this <quote><database>SELECT FROM (SELECT FROM..)</database></quote>
        style of statement is a virtual table that can be queried within the enclosing statement, as if
        it were a regular table or view.</para>
        <bridgehead renderas="sect4">Sample using a derived table</bridgehead>
        <para>The derived table in the query below returns the list of table names
        in the database and the number of columns in each. A <quote>drill-down</quote> query
        on the derived table returns the counts of fields and the counts of tables having
        each field count:
          <blockquote><programlisting>
SELECT
    FIELDCOUNT,
    COUNT(RELATION) AS NUM_TABLES
FROM (SELECT
           R.RDB$RELATION_NAME RELATION,
           COUNT(*) AS FIELDCOUNT
      FROM RDB$RELATIONS R
           JOIN RDB$RELATION_FIELDS RF
           ON RF.RDB$RELATION_NAME = R.RDB$RELATION_NAME
           GROUP BY RELATION)
GROUP BY FIELDCOUNT
          </programlisting></blockquote>
        </para>
        <para>A trivial example demonstrating how the alias of a derived table and the list
        of column aliases (both optional) can be used:
          <blockquote><programlisting>
SELECT
  DBINFO.DESCR, DBINFO.DEF_CHARSET
FROM (SELECT *
      FROM RDB$DATABASE) DBINFO
        (DESCR, REL_ID, SEC_CLASS, DEF_CHARSET)
          </programlisting></blockquote>
        </para>
        <note>
          <title>More about Derived Tables</title>
          <para>Derived tables can
            <itemizedlist>
              <listitem>be nested</listitem>
              <listitem>be unions and can be used in unions</listitem>
              <listitem>contain aggregate functions, subqueries and joins</listitem>
              <listitem>be used in aggregate functions, subqueries and joins</listitem>
              <listitem>be calls to selectable stored procedures or queries to them</listitem>
              <listitem>have <database>WHERE</database>, <database>ORDER BY</database> and
              <database>GROUP BY</database> clauses, <database>FIRST, SKIP</database> or
              <database>ROWS</database> directives, et al.</listitem>
            </itemizedlist>
          </para>
          <para>Furthermore,
            <itemizedlist>
              <listitem>Each column in a derived table must have a name. If it does not have a
              name, such as when it is a constant or a run-time expression, it should be
              given an alias, either in the regular way or by including it in the list of
              column aliases in the derived table's specification.
                <itemizedlist>
                  <listitem><emphasis>The list of column aliases is optional but, if it exists, it must
                  contain an alias for every column in the derived table</emphasis></listitem>
                </itemizedlist>
              </listitem>
              <listitem>The optimizer can process derived tables very effectively. However, if a
              derived table is included in an inner join and contains a subquery, the optimizer
              will be unable to use any join order.</listitem>
            </itemizedlist>
          </para>
        </note>
        <bridgehead renderas="sect4">A more useful example</bridgehead>
        <para>Suppose we have a table <database>COEFFS</database> which
        contains the coefficients of a number of quadratic equations we have
        to solve. It has been defined like this:</para>

        <blockquote>
          <programlisting>create table coeffs (
  a double precision not null,
  b double precision not null,
  c double precision not null,
  constraint chk_a_not_zero check (a &lt;&gt; 0)
)</programlisting>
        </blockquote>

        <para>Depending on the values of <replaceable>a</replaceable>,
        <replaceable>b</replaceable> and <replaceable>c</replaceable>, each
        equation may have zero, one or two solutions. It is possible to
        find these solutions with a single-level query on table
        <database>COEFFS</database>, but the code will look rather messy and
        several values (like the discriminant) will have to be calculated
        multiple times per row. A derived table can help keep things clean
        here:</para>

        <blockquote>
          <programlisting>select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select b, b*b - 4*a*c, 2*a from coeffs) (b, D, denom)</programlisting>
        </blockquote>

        <para>If we want to show the coefficients next to the solutions (which
        may not be a bad idea), we can alter the query like this:</para>

        <blockquote>
          <programlisting>select
  a, b, c,
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
  from
    (select a, b, c, b*b - 4*a*c as D, 2*a as denom
     from coeffs)</programlisting>
        </blockquote>

        <para>Notice that whereas the first query used a column aliases list
        for the derived table, the second adds aliases internally where
        needed. Both methods work, as long as every column is guaranteed to
        have a name.</para>
      </section>

      <section id="fblangref25-dml-select-from-cte">
        <title>Selecting <database>FROM</database> a CTE</title>

        <para>A common table expression or <database>CTE</database> is a more
        complex variant of the derived table, but it is also more powerful. A preamble,
        starting with the keyword <database>WITH</database>, defines one or
        more named <database>CTE</database>'s, each with an optional column
        aliases list. The main query, which follows the preamble, can then
        access these <database>CTE</database>'s as if they were regular tables
        or views. The <database>CTE</database>'s go out of scope once the main
        query has run to completion.</para>

        <para>For a full discussion of <database>CTE</database>'s, please
        refer to the section <link
        linkend="fblangref25-dml-select-cte"><citetitle>Common Table Expressions
        (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</citetitle></link>.</para>

        <para>The following is a rewrite of our derived table example as a
        <database>CTE</database>:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
)
select
  iif (D &gt;= 0, (-b - sqrt(D)) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrt(D)) / denom, null) sol_2
from vars</programlisting>
        </blockquote>

        <para>Except for the fact that the calculations that have to be made
        first are now at the beginning, this isn't a great improvement over
        the derived table version. But we can now also eliminate the double
        calculation of sqrt(D) for every row:</para>

        <blockquote>
          <programlisting>with vars (b, D, denom) as (
  select b, b*b - 4*a*c, 2*a from coeffs
),
vars2 (b, D, denom, sqrtD) as (
  select b, D, denom, iif (D &gt;= 0, sqrt(D), null) from vars
)
select
  iif (D &gt;= 0, (-b - sqrtD) / denom, null) sol_1,
  iif (D &gt;  0, (-b + sqrtD) / denom, null) sol_2
from vars2</programlisting>
        </blockquote>

        <para>The code is a little more complicated now, but it might execute
        more efficiently (depending on what takes more time: executing the
        <database>SQRT</database> function or passing the values of
        <replaceable>b</replaceable>, <replaceable>D</replaceable> and
        <replaceable>denom</replaceable> through an extra
        <database>CTE</database>). Incidentally, we could have done the same
        with derived tables, but that would involve nesting.</para>
      </section>
      <formalpara>
        <title>See also</title> 
        <para><link
        linkend="fblangref25-dml-select-cte"><citetitle>Common Table Expressions
        (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</citetitle></link>.
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-select-joins">
      <title>Joins</title>

      <para>Joins combine data from two sources into a single set. This is
      done on a row-by-row basis and usually involves checking a
      <firstterm>join condition</firstterm> in order to determine which rows
      should be merged and appear in the resulting dataset. There are several
      types (<database>INNER</database>, <database>OUTER</database>) and
      classes (qualified, natural, etc.) of joins, each with its own syntax
      and rules.</para>

      <para>Since joins can be chained, the datasets involved in a join may
      themselves be joined sets.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT
   ...
   FROM <replaceable>&lt;source&gt;</replaceable>
   [<replaceable>&lt;joins&gt;</replaceable>]
   [...]

<replaceable>&lt;source&gt;     </replaceable>     ::=  {<replaceable>table</replaceable>
                          | <replaceable>view</replaceable>
                          | <replaceable>selectable-stored-procedure</replaceable> [(<replaceable>args</replaceable>)]
                          | <replaceable>derived-table</replaceable>
                          | <replaceable>common-table-expression</replaceable>}
                       [[AS] <replaceable>alias</replaceable>]

<replaceable>&lt;joins&gt;      </replaceable>     ::=  <replaceable>&lt;join&gt;</replaceable> [<replaceable>&lt;join&gt;</replaceable> ...]

<replaceable>&lt;join&gt;</replaceable>            ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>
                         | NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>
                         | {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-dml-tbl-join">
      <?dbfo keep-together='auto'?>
        <title>Arguments for JOIN Clauses</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">table</entry>
              <entry align="left">Name of a table</entry>
            </row>
            <row valign="middle">
              <entry align="center">view</entry>
              <entry align="left">name of a view</entry>
            </row>
            <row valign="middle">
              <entry align="center">selectable-stored-procedure</entry>
              <entry align="left">Name of a selectable stored procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">args</entry>
              <entry align="left">Selectable stored procedure input parameter[s]</entry>
            </row>
            <row valign="middle">
              <entry align="center">derived-table</entry>
              <entry align="left">Reference, by name, to a derived table</entry>
            </row>
            <row valign="middle">
              <entry align="center">common-table-expression</entry>
              <entry align="left">Reference, by name, to a common table expression (CTE)</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">An alias for a data source (table, view, procedure, CTE, derived table)</entry>
            </row>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">Join condition (criterion)</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-list</entry>
              <entry align="left">The list of columns used for an equi-join</entry>
            </row>
          </tbody>
        </tgroup>
      </table>


      <section id="fblangref25-dml-select-joins-types">
        <title>Inner vs. outer joins</title>

        <para>A join always combines data rows from two sets (usually referred
        to as the left set and the right set). By default, only rows that meet
        the join condition (i.e., that match at least one row in the other set
        when the join condition is applied) make it into the result set. This
        default type of join is called an <firstterm>inner join</firstterm>.
        Suppose we have the following two tables:</para>

        <blockquote>
          <para>Table A:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>

          <para>Table B:</para>

          <informaltable>
            <tgroup cols="2">
              <thead>
                <row>
                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>If we join these tables like this:</para>

        <blockquote>
          <programlisting>select *
  from A
  join B on A.id = B.code</programlisting>
        </blockquote>

        <para>then the result set will be:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>The first row of A has been joined with the second row of B
        because together they met the condition <quote>A.id = B.code</quote>.
        The other rows from the source tables have no match in the opposite
        set and are therefore not included in the join. Remember, this is an
        <database>INNER</database> join. We can make that fact explicit by
        writing:</para>

        <blockquote>
          <programlisting>select *
  from A
  inner join B on A.id = B.code</programlisting>
        </blockquote>

        <para>However, since <database>INNER</database> is the default, this
        is rarely done.</para>

        <para>It is perfectly possible that a row in the left set matches
        several rows from the right set or vice versa. In that case, all those
        combinations are included, and we can get results like:</para>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>-1.0</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>Still don't know</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>-23</entry>

                  <entry>I give up</entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <para>Sometimes we want (or need) <emphasis>all</emphasis> the rows of
        one or both of the sources to appear in the joined set, regardless of
        whether they match a record in the other source. This is where outer
        joins come in. A <database>LEFT</database> outer join includes all the
        records from the left set, but only matching records from the right
        set. In a <database>RIGHT</database> outer join it's the other way
        around. <database>FULL</database> outer joins include all the records
        from both sets. In all outer joins, the <quote>holes</quote> (the
        places where an included source record doesn't have a match in the
        other set) are filled up with <database>NULL</database>s.</para>

        <para>In order to make an outer join, you must specify
        <database>LEFT</database>, <database>RIGHT</database> or
        <database>FULL</database>, optionally followed by the keyword
        <database>OUTER</database>.</para>

        <para>Below are the results of the various outer joins when applied to
        our original tables <database>A</database> and
        <database>B</database>:</para>

        <blockquote>
          <programlisting>select *
  from A
  left [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  right [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>

        <blockquote>
          <programlisting>select *
  from A
  full [outer] join B on A.id = B.code</programlisting>
        </blockquote>

        <blockquote>
          <informaltable>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry>ID</entry>

                  <entry>S</entry>

                  <entry>CODE</entry>

                  <entry>X</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry>-23</entry>

                  <entry>56.7735</entry>
                </row>

                <row>
                  <entry>87</entry>

                  <entry>Just some text</entry>

                  <entry>87</entry>

                  <entry>416.0</entry>
                </row>

                <row>
                  <entry>235</entry>

                  <entry>Silence</entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>

                  <entry><emphasis>&lt;null&gt;</emphasis></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </blockquote>
      </section>

      <section id="fblangref25-dml-select-joins-qualified">
        <title>Qualified joins</title>

        <para>Qualified joins specify conditions for the combining of rows.
        This happens either explicitly in an <database>ON</database> clause or
        implicitly in a <database>USING</database> clause.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;qualified-join&gt;</replaceable>  ::=  [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable> <replaceable>&lt;join-condition&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>       ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]

<replaceable>&lt;join-condition&gt;</replaceable>  ::=  ON <replaceable>condition</replaceable> | USING (<replaceable>column-list</replaceable>)</programlisting>
            </blockquote></para>
        </formalpara>

        <section>
          <title>Explicit-condition joins</title>

          <para>Most qualified joins have an <database>ON</database> clause,
          with an explicit condition that can be any valid boolean expression
          but usually involves some comparison between the two sources
          involved.</para>

          <para>Quite often, the condition is an equality test (or a number of
          <database>AND</database>ed equality tests) using the
          <quote><literal>=</literal></quote> operator. Joins like these are
          called <firstterm>equi-joins</firstterm>. (The examples in the
          section on inner and outer joins were al equi-joins.)</para>

          <para>Examples of joins with an explicit condition:</para>

          <blockquote>
            <programlisting>/* Select all Detroit customers who made a purchase
   in 2013, along with the purchase details: */
select * from customers c
  join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>
          </blockquote>

          <blockquote>
            <programlisting>/* Same as above, but include non-buying customers: */
select * from customers c
  left join sales s on s.cust_id = c.id
  where c.city = 'Detroit' and s.year = 2013</programlisting>

            <programlisting>/* For each man, select the women who are taller than he.
   Men for whom no such woman exists are not included. */
select m.fullname as man, f.fullname as woman
  from males m
  join females f on f.height &gt; m.height</programlisting>

            <programlisting>/* Select all pupils with their class and mentor.
   Pupils without a mentor are also included.
   Pupils without a class are not included. */
select p.firstname, p.middlename, p.lastname,
       c.name, m.name
  from pupils p
  join classes c on c.id = p.class
  left join mentors m on m.id = p.mentor</programlisting>
          </blockquote>
        </section>

        <section id="fblangref25-dml-select-joins-named-columns">
          <title>Named columns joins</title>

          <para>Equi-joins often compare columns that have the same name in
          both tables. If this is the case, we can also use the second type of
          qualified join: the <firstterm>named columns join</firstterm>.
          <note>
            <para>Named columns joins are not supported in Dialect 1
            databases.</para>
          </note>
          Named columns joins have a <database>USING</database> clause which states
          just the column names. So instead of this:</para>

          <blockquote>
            <programlisting>select * from flotsam f
  join jetsam j
  on f.sea = j.sea
  and f.ship = j.ship</programlisting>
          </blockquote>

          <para>we can also write:</para>

          <blockquote>
            <programlisting>select * from flotsam
  join jetsam using (sea, ship)</programlisting>
          </blockquote>

          <para>which is considerably shorter. The result set is a little
          different though&mdash;at least when using
          <quote><database>SELECT</database> *</quote>:</para>

          <itemizedlist>
            <listitem>
              <para>The explicit-condition join&mdash;with the
              <database>ON</database> clause&mdash;will contain each of the
              columns <database>SEA</database> and <database>SHIP</database>
              twice: once from table <database>FLOTSAM</database>, and once
              from table <database>JETSAM</database>. Obviously, they will
              have the same values.</para>
            </listitem>

            <listitem>
              <para>The named columns join&mdash;with the
              <database>USING</database> clause&mdash;will contain these columns
              only once.</para>
            </listitem>
          </itemizedlist>

          <para>If you want all the columns in the result set of the named
          columns join, set up your query like this:</para>

          <blockquote>
            <programlisting>select f.*, j.*
  from flotsam f
  join jetsam j using (sea, ship)</programlisting>
          </blockquote>

          <para>This will give you the exact same result set as the
          explicit-condition join.</para>

          <para>For an <database>OUTER</database> named columns join, there's
          an additional twist when using <quote><database>SELECT</database>
          *</quote> or an unqualified column name from the
          <database>USING</database> list:</para>

          <para>If a row from one source set doesn't have a match in the other
          but must still be included because of the <database>LEFT</database>,
          <database>RIGHT</database> or <database>FULL</database> directive,
          the merged column in the joined set gets the
          non-<database>NULL</database> value. That is fair enough, but now
          you can't tell whether this value came from the left set, the right
          set, or both. This can be especially deceiving when the value came
          from the right hand set, because <quote><literal>*</literal></quote>
          always shows combined columns in the left hand part&mdash;even in the
          case of a <database>RIGHT</database> join.</para>

          <para>Whether this is a problem or not depends on the situation. If
          it is, use the <quote><literal>a</literal>.<literal>*</literal>,
          <literal>b</literal>.<literal>*</literal></quote> approach shown
          above, with <literal>a</literal> and <literal>b</literal> the names
          or aliases of the two sources. Or better yet, avoid
          <quote><literal>*</literal></quote> altogether in your serious
          queries and qualify all column names in joined sets. This has the
          additional benefit that it forces you to think about which data you
          want to retrieve and where from.</para>

          <para>It is your responsibility to make sure that the column names
          in the <database>USING</database> list are of compatible types
          between the two sources. If the types are compatible but not equal,
          the engine converts them to the type with the broadest range of
          values before comparing the values. This will also be the data type
          of the merged column that shows up in the result set if
          <quote><database>SELECT</database> *</quote> or the unqualified
          column name is used. Qualified columns on the other hand will always
          retain their original data type.</para>
        </section>
      </section> <!-- Qualified joins -->

      <section id="fblangref25-dml-select-joins-natural">
        <title>Natural joins</title>

        <para>Taking the idea of the named columns join a step further, a
        <firstterm>natural join</firstterm> performs an automatic equi-join on
        all the columns that have the same name in the left and right table.
        The data types of these columns must be compatible.
          <note>
            <para>Natural joins are not supported in Dialect 1
            databases.</para>
          </note>
        </para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;natural-join&gt;</replaceable>  ::=  NATURAL [<replaceable>&lt;join-type&gt;</replaceable>] JOIN <replaceable>&lt;source&gt;</replaceable>

<replaceable>&lt;join-type&gt;</replaceable>     ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Given these two tables:</para>

        <blockquote>
          <programlisting>create table TA (
  a bigint,
  s varchar(12),
  ins_date date
)</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>create table TB (
  a bigint,
  descr varchar(12),
  x float,
  ins_date date
)</programlisting>
        </blockquote>

        <para>a natural join on <database>TA</database> and
        <database>TB</database> would involve the columns
        <replaceable>a</replaceable> and <replaceable>ins_date</replaceable>,
        and the following two statements would have the same effect:</para>

        <blockquote>
          <programlisting>select * from TA
  natural join TB</programlisting>
        </blockquote>

        <blockquote>
          <programlisting>select * from TA
  join TB using (a, ins_date)</programlisting>
        </blockquote>

        <para>Like all joins, natural joins are inner joins by default, but
        you can turn them into outer joins by specifying
        <database>LEFT</database>, <database>RIGHT</database> or
        <database>FULL</database> before the <database>JOIN</database>
        keyword.</para>

        <para>Caution: if there are no columns with the same name in the two
        source relations, a <database>CROSS JOIN</database> is performed.
        We'll get to this type of join in a minute.</para>
      </section>

      <section id="fblangref25-dml-select-joins-equality">
        <title>A Note on Equality</title>
        <important>
          <para>This note about equality and inequality operators applies
          everywhere in Firebird's SQL language, not just in JOIN conditions.</para>
        </important>
        <para>The <quote><literal>=</literal></quote> operator, which is
        explicitly used in many conditional joins and implicitly in named
        column joins and natural joins, only matches values to values.
        According to the SQL standard, <database>NULL</database> is not a
        value and hence two <database>NULL</database>s are neither equal nor
        unequal to one another. If you need <database>NULL</database>s to
        match each other in a join, use the <database>IS NOT DISTINCT
        FROM</database> operator. This operator returns true if the operands
        have the same value <emphasis>or</emphasis> if they are both
        <database>NULL</database>.</para>

        <blockquote>
          <programlisting>select *
  from A join B
  on A.id is not distinct from B.code</programlisting>
        </blockquote>

        <para>Likewise, in the&mdash;extremely rare&mdash;cases where you want to join
        on <emphasis>in</emphasis>equality, use <database>IS DISTINCT
        FROM</database>, not <quote><literal>&lt;&gt;</literal></quote>, if
        you want <database>NULL</database> to be considered different from any
        value and two <database>NULL</database>s considered equal:</para>

        <blockquote>
          <programlisting>select *
  from A join B
  on A.id is distinct from B.code</programlisting>
        </blockquote>
      </section>

      <section id="fblangref25-dml-select-joins-cross">
        <title>Cross joins</title>

        <para>A cross join produces the full set product of the two data
        sources. This means that it successfully matches every row in the left
        source to every row in the right source.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;cross-join&gt;</replaceable>  ::=  {CROSS JOIN | ,} <replaceable>&lt;source&gt;</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <para>Please notice that the comma syntax is deprecated! It is only
        supported to keep legacy code working and may disappear in some future
        version.</para>

        <para>Cross-joining two sets is equivalent to joining them on a
        tautology (a condition that is always true). The following two
        statements have the same effect:</para>

        <blockquote>
          <programlisting>select * from TA
  cross join TB</programlisting>

          <programlisting>select * from TA
  join TB on 1 = 1</programlisting>
        </blockquote>

        <para>Cross joins are inner joins, because they only include matching
        records – it just so happens that <emphasis>every</emphasis> record
        matches! An outer cross join, if it existed, wouldn't add anything to
        the result, because what outer joins add are non-matching records, and
        these don't exist in cross joins.</para>

        <para>Cross joins are seldom useful, except if you want to list all
        the possible combinations of two or more variables. Suppose you are
        selling a product that comes in different sizes, different colors and
        different materials. If these variables are each listed in a table of
        their own, this query would return all the combinations:</para>

        <blockquote>
          <programlisting>select m.name, s.size, c.name
  from materials m
  cross join sizes s
  cross join colors c</programlisting>
        </blockquote>
      </section>

      <section id="fblangref25-dml-select-joins-ambiguity">
        <title>Ambiguous field names in joins</title>

        <para>Firebird rejects unqualified field names in a query if these
        field names exist in more than one dataset involved in a join. This is
        even true for inner equi-joins where the field name figures in the
        <database>ON</database> clause like this:</para>

        <blockquote>
          <programlisting>select a, b, c
  from TA
  join TB on TA.a = TB.a</programlisting>
        </blockquote>

        <para>There is one exception to this rule: with named columns joins
        and natural joins, the unqualified field name of a column taking part
        in the matching process may be used legally and refers to the merged
        column of the same name. For named columns joins, these are the
        columns listed in the <database>USING</database> clause. For natural
        joins, they are the columns that have the same name in both relations.
        But please notice again that, especially in outer joins, plain
        <replaceable>colname</replaceable> isn't always the same as
        <replaceable>left</replaceable>.<replaceable>colname</replaceable> or
        <replaceable>right</replaceable>.<replaceable>colname</replaceable>.
        Types may differ, and one of the qualified columns may be
        <database>NULL</database> while the other isn't. In that case, the
        value in the merged, unqualified column may mask the fact that one of
        the source values is absent.</para>
      </section>

      <section id="fblangref25-dml-select-joins-storedprocs">
        <title>Joins with stored procedures</title>
        <para>If a join is performed with a stored procedure that is not correlated
        with other data streams via input parameters, there are no oddities.  If
        correlation <emphasis>is</emphasis> involved, an unpleasant quirk reveals
        itself. The problem is that the optimizer denies itself any way to determine
        the interrelationships of the input parameters of the procedure from the fields
        in the other streams:
          <blockquote><programlisting>
SELECT *
FROM MY_TAB
JOIN MY_PROC(MY_TAB.F) ON 1 = 1
          </programlisting></blockquote>
        </para>
        <para>Here, the procedure will be executed before a single record has been
        retrieved from the table, MY_TAB. The <function>isc_no_cur_rec error</function> error
        (<emphasis>no current record for fetch operation</emphasis>) is raised, interrupting
        the execution.</para>
        <para>The solution is to use syntax that specifies the join order <emphasis>explicitly</emphasis>:
          <blockquote><programlisting>
SELECT *
FROM MY_TAB
LEFT JOIN MY_PROC(MY_TAB.F) ON 1 = 1
          </programlisting></blockquote>
        This forces the table to be read before the procedure and everything works correctly.</para>
        <tip>
          <para>This quirk has been recognised as a bug in the optimizer and will be fixed in the next
          version of Firebird.</para>
        </tip>
      </section>
    </section> <!-- JOINS -->

    <section id="fblangref25-dml-select-where">
      <title>The <database>WHERE</database> clause</title>

      <para>The <database>WHERE</database> clause serves to limit the rows
      returned to the ones that the caller is interested in. The condition
      following the keyword <database>WHERE</database> can be as simple as a
      check like <quote><database>AMOUNT</database> = 3</quote> or it can be a
      multilayered, convoluted expression containing subselects, predicates,
      function calls, mathematical and logical operators, context variables
      and more.</para>

      <para>The condition in the <database>WHERE</database> clause is often
      called the <firstterm>search condition</firstterm>, the
      <firstterm>search expression</firstterm> or simply the
      <firstterm>search</firstterm>.</para>

      <para>In DSQL and ESQL, the search expression may contain parameters.
      This is useful if a query has to be repeated a number of times with
      different input values. In the SQL string as it is passed to the server,
      question marks are used as placeholders for the parameters. They are
      called <firstterm>positional parameters</firstterm> because they can
      only be told apart by their position in the string. Connectivity
      libraries often support <firstterm>named parameters</firstterm> of the
      form <parameter>:id</parameter>, <parameter>:amount</parameter>,
      <parameter>:a</parameter> etc. These are more user-friendly; the library
      takes care of translating the named parameters to positional parameters
      before passing the statement to the server.</para>

      <para>The search condition may also contain local (PSQL) or host (ESQL)
      variable names, preceded by a colon.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ...
   FROM ...
   [...]
   WHERE <replaceable>&lt;search-condition&gt;</replaceable>
   [...]

<replaceable>&lt;search-condition&gt;</replaceable>  ::=  a boolean expression returning
                         <constant>TRUE</constant>, <constant>FALSE</constant> or possibly <constant>UNKNOWN</constant> (<constant>NULL</constant>)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Only those rows for which the search condition evaluates to
      <constant>TRUE</constant> are included in the result set. Be careful
      with possible <constant>NULL</constant> outcomes: if you negate a
      <constant>NULL</constant> expression with <database>NOT</database>, the
      result will still be <constant>NULL</constant> and the row will not
      pass. This is demonstrated in one of the examples below.</para>

      <bridgehead renderas="sect4">Examples</bridgehead>

      <blockquote>
        <programlisting>select genus, species from mammals
  where family = 'Felidae'
  order by genus</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from persons
  where birthyear in (1880, 1881) 
     or birthyear between 1891 and 1898</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select name, street, borough, phone
  from schools s
  where exists (select * from pupils p where p.school = s.id)
  order by borough, street</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from employees
  where salary &gt;= 10000 and position &lt;&gt; 'Manager'</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select name from wrestlers
  where region = 'Europe'
    and weight &gt; all (select weight from shot_putters
                      where region = 'Africa')</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select id, name from players
  where team_id = (select id from teams where name = 'Buffaloes')</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select sum (population) from towns
  where name like '%dam'
  and province containing 'land'</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select password from usertable
  where username = current_user</programlisting>
      </blockquote>

      <para>The following example shows what can happen if the search
      condition evaluates to <constant>NULL</constant>.</para>

      <para>Suppose you have a table listing some children's names and the
      number of marbles they possess. At a certain moment, the table contains
      these data:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>CHILD</entry>

                <entry>MARBLES</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Anita</entry>

                <entry>23</entry>
              </row>

              <row>
                <entry>Bob E.</entry>

                <entry>12</entry>
              </row>

              <row>
                <entry>Chris</entry>

                <entry><emphasis>&lt;null&gt;</emphasis></entry>
              </row>

              <row>
                <entry>Deirdre</entry>

                <entry>1</entry>
              </row>

              <row>
                <entry>Eve</entry>

                <entry>17</entry>
              </row>

              <row>
                <entry>Fritz</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>Gerry</entry>

                <entry>21</entry>
              </row>

              <row>
                <entry>Hadassah</entry>

                <entry><emphasis>&lt;null&gt;</emphasis></entry>
              </row>

              <row>
                <entry>Isaac</entry>

                <entry>6</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>First, please notice the difference between
      <constant>NULL</constant> and 0: Fritz is <emphasis>known</emphasis> to
      have no marbles at all, Chris's and Hadassah's marble counts are
      unknown.</para>

      <para>Now, if you issue this SQL statement:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &gt; 10</programlisting>
      </blockquote>

      <para>you will get the names Anita, Bob E., Eve and Gerry. These
      children all have more than 10 marbles.</para>

      <para>If you negate the expression:<blockquote>
          <programlisting>select list(child) from marbletable where not marbles &gt; 10</programlisting>
        </blockquote></para>

      <para>it's the turn of Deirdre, Fritz and Isaac to fill the list. Chris
      and Hadassah are not included, because they aren't
      <emphasis>known</emphasis> to have ten marbles or less. Should you
      change that last query to:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &lt;= 10</programlisting>
      </blockquote>

      <para>the result will still be the same, because the expression
      <constant>NULL</constant> <literal>&lt;=</literal> <literal>10</literal>
      yields <constant>UNKNOWN</constant>. This is not the same as
      <constant>TRUE</constant>, so Chris and Hadassah are not listed. If you
      want them listed with the <quote>poor</quote> children, change the query
      to:</para>

      <blockquote>
        <programlisting>select list(child) from marbletable where marbles &lt;= 10 or marbles is null</programlisting>
      </blockquote>

      <para>Now the search condition becomes true for Chris and Hadassah,
      because <quote><literal>marbles is null</literal></quote> obviously
      returns <constant>TRUE</constant> in their case. In fact, the search
      condition cannot be <constant>NULL</constant> for anybody now.</para>

      <para>Lastly, two examples of <database>SELECT</database> queries with
      parameters in the search. It depends on the application how you should
      define query parameters and even if it is possible at all. Notice that
      queries like these cannot be executed immediately: they have to be
      <emphasis>prepared</emphasis> first. Once a parameterized query has been
      prepared, the user (or calling code) can supply values for the
      parameters and have it executed many times, entering new values before
      every call. How the values are entered and the execution started is up
      to the application. In a GUI environment, the user typically types the
      parameter values in one or more text boxes and then clicks an
      <quote>Execute</quote>, <quote>Run</quote> or <quote>Refresh</quote>
      button.</para>

      <blockquote>
        <programlisting>select name, address, phone frome stores
  where city = ? and class = ?</programlisting>
      </blockquote>

      <blockquote>
        <programlisting>select * from pants
  where model = :model and size = :size and color = :col</programlisting>
      </blockquote>

      <para>The last query cannot be passed directly to the engine; the
      application must convert it to the other format first, mapping named
      parameters to positional parameters.</para>
    </section>

    <section id="fblangref25-dml-select-groupby">
      <title>The <database>GROUP BY</database> clause</title>

      <para><database>GROUP BY</database> merges output rows that have the
      same combination of values in its item list into a single row. Aggregate
      functions in the select list are applied to each group individually
      instead of to the dataset as a whole.</para>

      <para>If the select list only contains aggregate columns or, more
      generally, columns whose values don't depend on individual rows in the
      underlying set, <database>GROUP BY</database> is optional. When
      omitted, the final result set of will consist of a single row (provided
      that at least one aggregated column is present).</para>

      <para>If the select list contains both aggregate columns and columns
      whose values may vary per row, the <database>GROUP BY</database> clause
      becomes mandatory.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;grouping-item&gt;</replaceable> [, <replaceable>&lt;grouping-item&gt;</replaceable> ...]
   [HAVING <replaceable>&lt;grouped-row-condition&gt;</replaceable>]
   ...

<replaceable>&lt;grouping-item&gt;</replaceable>         ::=  <replaceable>&lt;non-aggr-select-item&gt;</replaceable>
                               | <replaceable>&lt;non-aggr-expression&gt;</replaceable>

<replaceable>&lt;non-aggr-select-item&gt;</replaceable>  ::=  <replaceable>column-copy</replaceable>
                               | <replaceable>column-alias</replaceable>
                               | <replaceable>column-position</replaceable>
          </programlisting>
          </blockquote></para>
      </formalpara>
      <table id="fblangref25-dml-tbl-groupby">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the GROUP BY Clause</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">non-aggr-expression</entry>
              <entry align="left">Any non-aggregating expression that is not included in the SELECT list,
              i.e. unselected columns from the source set or expressions that do not depend on the data
              in the set at all</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-copy</entry>
              <entry align="left">A literal copy, from the SELECT list, of an expression that contains
              no aggregate function</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-alias</entry>
              <entry align="left">The alias, from the SELECT list,  of an expression (column) that contains
              no aggregate function</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-position</entry>
              <entry align="left">The position number, in the SELECT list, of an expression (column) that
              contains no aggregate function</entry>
            </row>
          </tbody>
        </tgroup>
      </table>


      <para>A general rule of thumb is that every non-aggregate item in the
      <database>SELECT</database> list must also be in the <database>GROUP
      BY</database> list. You can do this in three ways:</para>

      <orderedlist>
        <listitem>
          <para>By copying the item verbatim from the select list, e.g.
          <quote><literal>class</literal></quote> or
          <quote><literal>'D:'</literal> <literal>||</literal>
          <literal>upper(doccode)</literal></quote>.</para>
        </listitem>

        <listitem>
          <para>By specifying the column alias, if it exists.</para>
        </listitem>

        <listitem>
          <para>By specifying the column position as an integer
          <emphasis>literal</emphasis> between 1 and the number of columns.
          Integer values resulting from expressions or parameter substitutions
          are simply invariables and will be used as such in the grouping.
          They will have no effect though, as their value is the same for each
          row.</para>
        </listitem>
      </orderedlist>

      <note>
        <para>If you group by a column position, the expression
        at that position is copied internally from the select list. If it
        concerns a subquery, that subquery will be executed again in 
        the grouping phase.  That is to say, grouping by the column 
        position, rather than duplicating the subquery expression 
        in the grouping clause, saves keystrokes and bytes, but it 
        is not a way of saving processing cycles!</para>
      </note>

      <para>In addition to the required items, the grouping list may also
      contain:</para>

      <itemizedlist>
        <listitem>
          <para>Columns from the source table that are not in the select list,
          or non-aggregate expressions based on such columns. Adding such
          columns may further subdivide the groups. But since these columns
          are not in the select list, you can't tell which aggregated row
          corresponds to which value in the column. So, in general, if you are
          interested in this information, you also include the column or
          expression in the select list&mdash;which brings you back to the
          rule: <quote>every non-aggregate column in the select list must
          also be in the grouping list</quote>.</para>
        </listitem>

        <listitem>
          <para>Expressions that aren't dependent on the data in the
          underlying set, e.g. constants, context variables, single-value
          non-correlated subselects etc. This is only mentioned for
          completeness, as adding such items is utterly pointless: they don't
          affect the grouping at all. <quote>Harmless but useless</quote>
          items like these may also figure in the select list without being
          copied to the grouping list.</para>
        </listitem>
      </itemizedlist>

      <bridgehead renderas="sect4">Examples</bridgehead>

      <para>When the select list contains only aggregate columns,
      <database>GROUP BY</database> is not mandatory:
      <blockquote>
        <programlisting>select count(*), avg(age) from students
  where sex = 'M'</programlisting>
      </blockquote>
       </para>

      <para>This will return a single row listing the number of male students
      and their average age. Adding expressions that don't depend on values in
      individual rows of table <database>STUDENTS</database> doesn't change
      that:
      <blockquote>
        <programlisting>select count(*), avg(age), current_date from students
  where sex = 'M'</programlisting>
      </blockquote>
      The row will now have an extra column showing the current date,
      but other than that, nothing fundamental has changed. A <database>GROUP
      BY</database> clause is still not required.</para>

      <para>However, in both the above examples it is
      <emphasis>allowed</emphasis>. This is perfectly valid:
      <blockquote>
        <programlisting>select count(*), avg(age) from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      and will return a row for each class that has boys in it, listing
      the number of boys and their average age in that particular class. (If
      you also leave the <literal>current_date</literal> field in, this value
      will be repeated on every row, which is not very exciting.)</para>

      <para>The above query has a major drawback though: it gives you
      information about the different classes, but it doesn't tell you which
      row applies to which class. In order to get that extra bit of
      information, the non-aggregate column <database>CLASS</database> must be
      added to the select list:</para>

      <blockquote>
        <programlisting>select class, count(*), avg(age) from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>Now we have a useful query. Notice that the addition of column
      <database>CLASS</database> also makes the <database>GROUP BY</database>
      clause mandatory. We can't drop that clause anymore, unless we also
      remove <database>CLASS</database> from the column list.</para>

      <para>The output of our last query may look something like this:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="3">
            <thead>
              <row>
                <entry>CLASS</entry>

                <entry>COUNT</entry>

                <entry>AVG</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2A</entry>

                <entry>12</entry>

                <entry>13.5</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>9</entry>

                <entry>13.9</entry>
              </row>

              <row>
                <entry>3A</entry>

                <entry>11</entry>

                <entry>14.6</entry>
              </row>

              <row>
                <entry>3B</entry>

                <entry>12</entry>

                <entry>14.4</entry>
              </row>

              <row>
                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>The headings <quote>COUNT</quote> and <quote>AVG</quote> are not
      very informative. In a simple case like this, you might get away with
      that, but in general you should give aggregate columns a meaningful name
      by aliasing them:</para>

      <blockquote>
        <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class</programlisting>
      </blockquote>

      <para>As you may recall from the formal syntax of the columns list, the
      <database>AS</database> keyword is optional.</para>

      <para>Adding more non-aggregate (or rather: row-dependent) columns
      requires adding them to the <database>GROUP BY</database> clause too.
      For instance, you might want to see the above information for girls as
      well; and you may also want to differentiate between boarding and day
      students:</para>

      <blockquote>
        <programlisting>select class,
       sex,
       boarding_type,
       count(*) as number,
       avg(age) as avg_age
  from students
  group by class, sex, boarding_type</programlisting>
      </blockquote>

      <para>This may give you the following result:</para>

      <blockquote>
        <informaltable>
          <tgroup cols="5">
            <thead>
              <row>
                <entry>CLASS</entry>

                <entry>SEX</entry>

                <entry>BOARDING_TYPE</entry>

                <entry>NUMBER</entry>

                <entry>AVG_AGE</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>2A</entry>

                <entry>F</entry>

                <entry>BOARDING</entry>

                <entry>9</entry>

                <entry>13.3</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>F</entry>

                <entry>DAY</entry>

                <entry>6</entry>

                <entry>13.5</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>M</entry>

                <entry>BOARDING</entry>

                <entry>7</entry>

                <entry>13.6</entry>
              </row>

              <row>
                <entry>2A</entry>

                <entry>M</entry>

                <entry>DAY</entry>

                <entry>5</entry>

                <entry>13.4</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>F</entry>

                <entry>BOARDING</entry>

                <entry>11</entry>

                <entry>13.7</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>F</entry>

                <entry>DAY</entry>

                <entry>5</entry>

                <entry>13.7</entry>
              </row>

              <row>
                <entry>2B</entry>

                <entry>M</entry>

                <entry>BOARDING</entry>

                <entry>6</entry>

                <entry>13.8</entry>
              </row>

              <row>
                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>

                <entry>...</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </blockquote>

      <para>Each row in the result set corresponds to one particular
      combination of the variables class, sex and boarding type. The aggregate
      results&mdash;number and average age&mdash;are given for each of these rather
      specific groups individually. In a query like this, you don't see a
      total for boys as a whole, or day students as a whole. That's the
      tradeoff: the more non-aggregate columns you add, the more you can
      pinpoint very specific groups, but the more you also lose sight of the
      general picture. Of course you can still obtain the
      <quote>coarser</quote> aggregates through separate queries.</para>

      <section id="fblangref25-dml-select-groupby-having">
        <title><database>HAVING</database></title>

        <para>Just as a <database>WHERE</database> clause limits the rows in a
        dataset to those that meet the search condition, so the
        <database>HAVING</database> subclause imposes restrictions on the
        aggregated rows in a grouped set. <database>HAVING</database> is
        optional, and can only be used in conjunction with <database>GROUP
        BY</database>.</para>

        <para>The condition(s) in the <database>HAVING</database> clause can
        refer to:</para>

        <itemizedlist>
          <listitem>
            <para>Any aggregated column in the select list. This is the most
            widely used alternative.</para>
          </listitem>

          <listitem>
            <para>Any aggregated expression that is not in the select list,
            but allowed in the context of the query. This is sometimes useful
            too.</para>
          </listitem>

          <listitem>
            <para>Any column in the <database>GROUP BY</database> list. While
            legal, it is more efficient to filter on these non-aggregated data
            at an earlier stage: in the <database>WHERE</database>
            clause.</para>
          </listitem>

          <listitem>
            <para>Any expression whose value doesn't depend on the contents of
            the dataset (like a constant or a context variable). This is valid
            but utterly pointless, because it will either suppress the entire
            set or leave it untouched, based on conditions that have nothing
            to do with the set itself.</para>
          </listitem>
        </itemizedlist>

        <para>A <database>HAVING</database> clause can
        <emphasis>not</emphasis> contain:</para>

        <itemizedlist>
          <listitem>
            <para>Non-aggregated column expressions that are not in the
            <database>GROUP BY</database> list.</para>
          </listitem>

          <listitem>
            <para>Column positions. An integer in the
            <database>HAVING</database> clause is just an integer.</para>
          </listitem>

          <listitem>
            <para>Column aliases – not even if they appear in the
            <database>GROUP BY</database> clause!<!--Is that by design? Test also in 2.5--></para>
          </listitem>
        </itemizedlist>

        <bridgehead renderas="sect4">Examples</bridgehead>

        <para>Building on our earlier examples, this could be used to skip
        small groups of students:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having count(*) &gt;= 5</programlisting>
        </blockquote>

        <para>To select only groups that have a minimum age spread:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having max(age) - min(age) &gt; 1.2</programlisting>
        </blockquote>

        <para>Notice that if you're really interested in this information,
        you'd normally include <literal>min(age)</literal> and
        <literal>max(age)</literal> – or the expression
        <quote><literal>max(age)</literal> <literal>-</literal>
        <literal>min(age)</literal></quote> – in the select list as
        well!</para>

        <para>To include only 3rd classes:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M'
  group by class
  having class starting with '3'</programlisting>
        </blockquote>

        <para>Better would be to move this condition to the
        <database>WHERE</database> clause:</para>

        <blockquote>
          <programlisting>select class,
       count(*) as num_boys,
       avg(age) as boys_avg_age
  from students
  where sex = 'M' and class starting with '3'
  group by class</programlisting>
        </blockquote>
      </section> <!-- HAVING -->
    </section> <!-- GROUP BY -->

    <section id="fblangref25-dml-select-plan">
      <title>The <database>PLAN</database> clause</title>

      <para>The <database>PLAN</database> clause enables the user to submit a
      data retrieval plan, thus overriding the plan that the optimizer would
      have generated automatically.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>PLAN <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;plan-expr&gt;</replaceable>    ::=  (<replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])
                    | <replaceable>&lt;sorted-item&gt;</replaceable>
                    | <replaceable>&lt;joined-item&gt;</replaceable>
                    | <replaceable>&lt;merged-item&gt;</replaceable>

<replaceable>&lt;sorted-item&gt;</replaceable>  ::=  SORT (<replaceable>&lt;plan-item&gt;</replaceable>)

<replaceable>&lt;joined-item&gt;</replaceable>  ::=  JOIN (<replaceable>&lt;plan-item&gt;</replaceable>, <replaceable>&lt;plan-item&gt;</replaceable> [, <replaceable>&lt;plan-item&gt;</replaceable> ...])

<replaceable>&lt;merged-item&gt;</replaceable>  ::=  [SORT] MERGE (<replaceable>&lt;sorted-item&gt;</replaceable>, <replaceable>&lt;sorted-item&gt;</replaceable> [, <replaceable>&lt;sorted-item&gt;</replaceable> ...])

<replaceable>&lt;plan-item&gt;</replaceable>    ::=  <replaceable>&lt;basic-item&gt;</replaceable> | <replaceable>&lt;plan-expr&gt;</replaceable>

<replaceable>&lt;basic-item&gt;</replaceable>   ::=  <replaceable>&lt;relation&gt;</replaceable>
                    {NATURAL
                     | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)
                     | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;relation&gt;</replaceable>     ::=  <replaceable>table</replaceable>
                    | <replaceable>view</replaceable> [<replaceable>table</replaceable>]

<replaceable>&lt;indexlist&gt;</replaceable>    ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]
          </programlisting>
          </blockquote></para>
      </formalpara>

      <table id="fblangref25-dml-tbl-plan">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the PLAN Clause</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">table</entry>
              <entry align="left">Table name or its alias</entry>
            </row>
            <row valign="middle">
              <entry align="center">view</entry>
              <entry align="left">View name</entry>
            </row>
            <row valign="middle">
              <entry align="center">index</entry>
              <entry align="left">Index name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Every time a user submits a query to the Firebird engine, the
      optimizer computes a data retrieval strategy. Most Firebird clients can
      make this retrieval plan visible to the user. In Firebird's own
      <application>isql</application> utility, this is done with the command
      <database>SET PLAN ON</database>. If you are studying query plans rather
      than running queries, <database>SET PLANONLY ON</database> will show the
      plan without executing the query.</para>

      <para>In most situations, you can trust that Firebird will select the
      optimal query plan for you. However, if you have complicated queries
      that seem to be underperforming, it may very well be worth your while to
      examine the plan and see if you can improve on it.</para>

      <section id="fblangref25-dml-select-plan-simple">
        <title>Simple plans</title>

        <para>The simplest plans consist of just a relation name followed by a
        retrieval method. E.g., for an unsorted single-table select without a
        <database>WHERE</database> clause:</para>

        <blockquote>
          <programlisting>select * from students
  plan (students natural)</programlisting>
        </blockquote>

        <para>If there's a <database>WHERE</database> or a
        <database>HAVING</database> clause, you can specify the index to be
        used for finding matches:</para>

        <blockquote>
          <programlisting>select * from students
  where class = '3C'
  plan (students index (ix_stud_class))</programlisting>
        </blockquote>

        <para>The <database>INDEX</database> directive is also used for join
        conditions (to be discussed a little later). It can contain a list of
        indexes, separated by commas.</para>

        <para><database>ORDER</database> specifies the index for sorting the
        set if an <database>ORDER BY</database> or <database>GROUP
        BY</database> clause is present:</para>

        <blockquote>
          <programlisting>select * from students
  plan (students order pk_students)
  order by id</programlisting>
        </blockquote>

        <para><database>ORDER</database> and <database>INDEX</database> can be
        combined:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan (students order pk_students index (ix_stud_class))
  order by id</programlisting>
        </blockquote>

        <para>It is perfectly OK if <database>ORDER</database> and
        <database>INDEX</database> specify the same index:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan (students order ix_stud_class index (ix_stud_class))
  order by class</programlisting>
        </blockquote>

        <para>For sorting sets when there's no usable index available (or if
        you want to suppress its use), leave out <database>ORDER</database>
        and prepend the plan expression with <database>SORT</database>:</para>

        <blockquote>
          <programlisting>select * from students
  plan sort (students natural)
  order by name</programlisting>
        </blockquote>

        <para>Or when an index is used for the search:</para>

        <blockquote>
          <programlisting>select * from students
  where class &gt;= '3'
  plan sort (students index (ix_stud_class))
  order by name</programlisting>
        </blockquote>

        <para>Notice that <database>SORT</database>, unlike
        <database>ORDER</database>, is outside the parentheses. This reflects
        the fact that the data rows are retrieved unordered and sorted
        afterwards by the engine.</para>

        <para>When selecting from a view, specify the view and the table
        involved. For instance, if you have a view
        <database>FRESHMEN</database> that selects just the first-year
        students:</para>

        <blockquote>
          <programlisting>select * from freshmen
  plan (freshmen students natural)</programlisting>
        </blockquote>

        <para>Or, for instance:</para>

        <blockquote>
          <programlisting>select * from freshmen
  where id &gt; 10
  plan sort (freshmen students index (pk_students))
  order by name desc</programlisting>
        </blockquote>
        <important>
          <para>If a table or view has been aliased, it is the alias, not the
          original name, that must be used in the <database>PLAN</database>
          clause.</para>
        </important>
      </section>

      <section id="fblangref25-dml-select-plan-composite">
        <title>Composite plans</title>

        <para>When a join is made, you can specify the index which is to be
        used for matching. You must also use the <database>JOIN</database>
        directive on the two streams in the plan:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan join (s natural, c index (pk_classes))</programlisting>
        </blockquote>

        <para>The same join, sorted on an indexed column:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan join (s order pk_students, c index (pk_classes))
  order by s.id</programlisting>
        </blockquote>

        <para>And on a non-indexed column:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  plan sort (join (s natural, c index (pk_classes)))
  order by s.name</programlisting>
        </blockquote>

        <para>With a search added:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from students s
  join classes c on c.name = s.class
  where s.class &lt;= '2'
  plan sort (join (s index (fk_student_class), c index (pk_classes)))
  order by s.name</programlisting>
        </blockquote>

        <para>As a left outer join:</para>

        <blockquote>
          <programlisting>select s.id, s.name, s.class, c.mentor
  from classes c
  left join students s on c.name = s.class
  where s.class &lt;= '2'
  plan sort (join (c natural, s index (fk_student_class)))
  order by s.name</programlisting>
        </blockquote>

        <para>If there is no index available to match the join criteria (or if
        you don't want to use it), the plan must first sort both streams on
        their join column(s) and then merge them. This is achieved with the
        <database>SORT</database> directive (which we've already met) and
        <database>MERGE</database> instead of
        <database>JOIN</database>:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  plan merge (sort (c natural), sort (s natural))</programlisting>
        </blockquote>

        <para>Adding an <database>ORDER BY</database> clause means the result
        of the merge must also be sorted:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  plan sort (merge (sort (c natural), sort (s natural)))
  order by c.name, s.id</programlisting>
        </blockquote>

        <para>Finally, we add a search condition on two indexable colums of
        table <database>STUDENTS</database>:</para>

        <blockquote>
          <programlisting>select * from students s
  join classes c on c.cookie = s.cookie
  where s.id &lt; 10 and s.class &lt;= '2'
  plan sort (merge (sort (c natural),
                    sort (s index (pk_students, fk_student_class))))
  order by c.name, s.id</programlisting>
        </blockquote>

        <para>As follows from the formal syntax definition,
        <database>JOIN</database>s and <database>MERGE</database>s in the plan
        may combine more than two streams. Also, every plan expression may be
        used as a plan item in an encompassing plan. This means that plans of
        certain complicated queries may have various nesting levels.</para>

        <para>Finally, instead of <database>MERGE</database> you may also
        write <database>SORT MERGE</database>. As this makes absolutely no
        difference and may create confusion with <quote>real</quote>
        <database>SORT</database> directives (the ones that
        <emphasis>do</emphasis> make a difference), it's probably best to
        stick to plain <database>MERGE</database>.</para>

        <warning>
          <para>Occasionally, the optimizer will accept a plan and then not
          follow it, even though it does not reject it as invalid.  One such
          example was
          <blockquote><literallayout class="monospaced">
MERGE (unsorted stream, unsorted stream)
          </literallayout></blockquote>
          It is advisable to treat such as plan as <quote>deprecated</quote>.
          </para>
        </warning>
      </section>
    </section>

    <section id="fblangref25-dml-select-union">
      <title><database>UNION</database></title>

      <para>A <database>UNION</database> concatenates two or more datasets,
      thus increasing the number of rows but not the number of columns.
      Datasets taking part in a <database>UNION</database> must have the same
      number of columns, and columns at corresponding positions must be of the
      same type. Other than that, they may be totally unrelated.</para>

      <para>By default, a union suppresses duplicate rows. <database>UNION
      ALL</database> shows all rows, including any duplicates. The optional
      <database>DISTINCT</database> keyword makes the default behaviour
      explicit.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting><replaceable>&lt;union&gt;</replaceable>               ::=  <replaceable>&lt;individual-select&gt;</replaceable>
                           UNION [DISTINCT | ALL]
                           <replaceable>&lt;individual-select&gt;</replaceable>
                           [UNION [DISTINCT | ALL]
                            <replaceable>&lt;individual-select&gt;</replaceable>
                            ...]
                           [<replaceable>&lt;union-wide-clauses&gt;</replaceable>]

<replaceable>&lt;individual-select&gt;</replaceable>   ::=  SELECT
                           [TRANSACTION <replaceable>name</replaceable>]
                           [FIRST <replaceable>&lt;m&gt;</replaceable>] [SKIP <replaceable>&lt;n&gt;</replaceable>]
                           [DISTINCT | ALL] <replaceable>&lt;columns&gt;</replaceable>
                           [INTO <replaceable>&lt;host-varlist&gt;</replaceable>]
                           FROM <replaceable>source</replaceable> [[AS] <replaceable>alias</replaceable>]
                           [<replaceable>&lt;joins&gt;</replaceable>]
                           [WHERE <replaceable>&lt;condition&gt;</replaceable>]
                           [GROUP BY <replaceable>&lt;grouping-list&gt;</replaceable>
                           [HAVING <replaceable>&lt;aggregate-condition&gt;</replaceable>]]
                           [PLAN <replaceable>&lt;plan-expr&gt;</replaceable>]

<replaceable>&lt;union-wide-clauses&gt;</replaceable>  ::=  [ORDER BY <replaceable>&lt;ordering-list&gt;</replaceable>]
                           [ROWS <replaceable>m</replaceable> [TO <replaceable>n</replaceable>]]
                           [FOR UPDATE [OF <replaceable>&lt;columns&gt;</replaceable>]]
                           [WITH LOCK]
                           [INTO <replaceable>&lt;PSQL-varlist&gt;</replaceable>]</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Unions take their column names from the <emphasis>first</emphasis>
      select query. If you want to alias union columns, do so in the column
      list of the topmost <database>SELECT</database>. Aliases in other
      participating selects are allowed and may even be useful, but will not
      propagate to the union level.</para>

      <para>If a union has an <database>ORDER BY</database> clause, the only
      allowed sort items are integer literals indicating 1-based column
      positions, optionally followed by an
      <database>ASC</database>/<database>DESC</database> and/or a
      <database>NULLS</database>
      <database>FIRST</database>/<database>LAST</database> directive. This
      also implies that you cannot order a union by anything that isn't a
      column in the union. (You can, however, wrap it in a derived table,
      which gives you back all the usual sort options.)</para>

      <para>Unions are allowed in subqueries of any kind and can themselves
      contain subqueries. They can also contain joins, and can take part in a
      join when wrapped in a derived table.</para>

      <bridgehead renderas="sect4">Examples</bridgehead>

      <para>This query presents information from different music collections
      in one dataset using unions:
      <blockquote>
        <programlisting>select id, title, artist, length, 'CD' as medium
  from cds
union
select id, title, artist, length, 'LP'
  from records
union
select id, title, artist, length, 'MC'
  from cassettes
order by 3, 2  -- artist, title</programlisting>
      </blockquote>

      If <literal>id</literal>, <literal>title</literal>,
      <literal>artist</literal> and <literal>length</literal> are the only
      fields in the tables involved, the query can also be written as:
      <blockquote>
        <programlisting>select c.*, 'CD' as medium
  from cds c
union
select r.*, 'LP'
  from records r
union
select c.*, 'MC'
  from cassettes c
order by 3, 2  -- artist, title</programlisting>
      </blockquote>
      </para>
      <para>Qualifying the <quote>stars</quote> is necessary here because they
      are not the only item in the column list. Notice how the <quote>c</quote>
      aliases in the first and third select do not conflict with each other:  their
      scopes are not union-wide but apply only to their respective select
      queries.</para>

      <para>The next query retrieves names and phone numbers from translators
      and proofreaders. Translators who also work as proofreaders will show up
      only once in the result set, provided their phone number is the same in
      both tables. The same result can be obtained without
      <database>DISTINCT</database>. With <database>ALL</database>, these
      people would appear twice.
      <blockquote>
        <programlisting>select name, phone from translators
  union distinct
select name, telephone from proofreaders</programlisting>
      </blockquote>
      </para>
      <para>A <database>UNION</database> within a subquery:
      <blockquote>
        <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
      </blockquote></para>
    </section>

    <section id="fblangref25-dml-select-orderby">
      <title><database>ORDER BY</database></title>
      <para>When a <database>SELECT</database> statement is executed, the result set is not sorted
      in any way.  It often happens that rows appear to be sorted chronologically, simply because
      they are returned in the same order they were added to the table by <database>INSERT</database>
      statements. To specify a sorting order for the set specification, an <database>ORDER BY</database>
      clause is used.</para>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
SELECT ... FROM ...
...
ORDER BY &lt;ordering-item&gt; [, &lt;ordering-item&gt; &hellip;]

&lt;ordering-item&gt; ::=
  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
  [COLLATE <replaceable>collation-name</replaceable>]
  [ASC[ENDING] | DESC[ENDING]]
  [NULLS {FIRST|LAST}]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-dml-tbl-orderby">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the ORDER BY Clause</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">col-name</entry>
              <entry align="left">Full column name</entry>
            </row>
            <row valign="middle">
              <entry align="center">col-alias</entry>
              <entry align="left">Column alias</entry>
            </row>
            <row valign="middle">
              <entry align="center">col-position</entry>
              <entry align="left">Column position in the SELECT list</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">Any expression</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation-name</entry>
              <entry align="left">Collation name (sorting order for string types)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <bridgehead renderas="sect4">Description</bridgehead>
      <para>The <database>ORDER BY</database> consists of a comma-separated list of the columns
      on which the result data set should be sorted. The sort order can be specified by the name
      of the column&mdash;but only if the column was not previously aliased in the
      <database>SELECT</database> columns list.  The alias must be used if it was used there.
      The ordinal position number of the column in the  , the alias given to the column in the SELECT list with the help of the AS keyword
      or the number of the column in the <database>SELECT</database> list can be used without
      restriction.</para>
      <para>The three forms of expressing the columns for the sort order can be mixed in the same
      <database>ORDER BY</database> clause.  For instance, one column in the list can be
      specified by its name and another column can be specified by its number.</para>
      <note>
        <para>If you use the column position to specify the sort order for a query of the
        <constant>SELECT *</constant> style, the server expands the asterisk to the full column
        list in order to determine the columns for the sort. It is, however, considered <quote>sloppy
        practice</quote> to design ordered sets this way.</para>
      </note>
      <section id="fblangref25-dml-select-orderby-direction">
        <title>Sorting Direction</title>
        <para>The keyword <database>ASCENDING</database>, usually abbreviated to <database>ASC</database>,
        specifies a sort direction from lowest to highest. <database>ASCENDING</database> is the default
        sort direction.</para>
        <para>The keyword <database>DESCENDING</database>, usually abbreviated to <database>DESC</database>,
        specifies a sort direction from highest to lowest.</para>
        <para>Specifying ascending order for one column and the descending order for another is allowed.</para>
      </section>

      <section id="fblangref25-dml-select-orderby-collation">
        <title>Collation Order</title>
        <para>The keyword <database>COLLATE</database> specifies the collation order for a
        string column if you need a collation that is different from the normal one for this column.
        The normal collation order will be either the default one for the database character set or
        one that has been set explicitly in the column's definition.</para>
      </section>

      <section id="fblangref25-dml-select-orderby-nullsposition">
        <title>NULLs Position</title>
        <para>The keyword <database>NULLS</database> defines where NULL in the associated column
        will fall in the sort order:  <database>NULLS FIRST</database> places the rows with the
        <database>NULL</database> column <emphasis>above</emphasis> rows ordered by that column's
        value;  <database>NULLS LAST</database> places those rows <emphasis>after</emphasis> the
        ordered rows.</para>
        <para><database>NULLS FIRST</database> is the default.</para>
      </section>

      <section id="fblangref25-dml-select-orderby-unions">
        <title>Ordering <database>UNION</database>-ed Sets</title>
        <para>The discrete queries contributing to a <database>UNION</database> cannot take an
        <database>ORDER BY</database> clause.  The only option is to order the entire output,
        using one <database>ORDER BY</database> clause at the end of the overall query.</para>
        <para>The simplest&mdash;and, in some cases, the only&mdash; method for specifying the
        sort order is by the ordinal column position. However, it is also valid to use the
        column names or aliases, from the first contributing query <emphasis>only</emphasis>.</para>
        <para>The <database>ASC/DESC</database> and/or <database>NULLS</database> directives
        are available for this global set.</para>
        <para>If discrete ordering within the contributing set is required, use of derived tables
        or common table expressions for those sets may be a solution.</para>
      </section>

      <bridgehead renderas="sect4">Examples</bridgehead>
      <para>Sorting the result set in ascending order, ordering by the RDB$CHARACTER_SET_ID,
      RDB$COLLATION_ID columns of the DB$COLLATIONS table:
        <blockquote><programlisting>
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY RDB$CHARACTER_SET_ID, RDB$COLLATION_ID
        </programlisting></blockquote>
      The same, but sorting by the column aliases:
        <blockquote><programlisting>
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY CHARSET_ID, COLL_ID
        </programlisting></blockquote>
      </para>
      <para>Sorting the output data by the column position numbers:
        <blockquote><programlisting>
SELECT
    RDB$CHARACTER_SET_ID AS CHARSET_ID,
    RDB$COLLATION_ID AS COLL_ID,
    RDB$COLLATION_NAME AS NAME
FROM RDB$COLLATIONS
ORDER BY 1, 2
        </programlisting></blockquote>
      </para>
      <para>Sorting a <database>SELECT *</database> query by position numbers&mdash;possible,
      but <emphasis>nasty</emphasis> and not recommended:
        <blockquote><programlisting>
SELECT *
FROM RDB$COLLATIONS
ORDER BY 3, 2
        </programlisting></blockquote>
      </para>
      <para>Sorting by the second column in the BOOKS table:
        <blockquote><programlisting>
SELECT
    BOOKS.*,
    FILMS.DIRECTOR
FROM BOOKS, FILMS
ORDER BY 2
        </programlisting></blockquote>
      </para>
      <caution>
        <para>Expressions whose calculation results are non-negative integers will be
        interpreted as column position numbers and will cause an exception if they fall
        outside the range from 1 to the number of columns.
          <formalpara>
            <title>Example</title>
            <blockquote><literallayout class="monospaced">
SELECT
  X, Y, NOTE
FROM PAIRS
ORDER BY X+Y DESC
            </literallayout></blockquote>
          </formalpara>
          <itemizedlist>
            <listitem>The number returned by a function or a procedure is unpredictable,
            regardless of whether the sort order is defined by the expression itself or by
            the column number</listitem>
            <listitem>Only non-negative integers are interpreted as column numbers</listitem>
            <listitem>An integer obtained by one-time evaluation of an expression or by parameter
            substitution is saved as a constant, because this value applies to all rows.</listitem>
          </itemizedlist>
        </para>
      </caution>

      <bridgehead renderas="sect4">Examples, continued</bridgehead>
      <para>Sorting in descending order by the values of column PROCESS_TIME, with NULLS
      placed at the beginning of the set:
        <blockquote><programlisting>
SELECT *
FROM MSG
ORDER BY PROCESS_TIME DESC NULLS FIRST
        </programlisting></blockquote>
       </para>
       <para>Sorting the set obtained by a <database>UNION</database> of two queries. Results
       are sorted in descending order for the values in the second column, with
       <constant>NULL</constant>s at the end of the set; and in ascending order for the
       values of the first column with <constant>NULL</constant>s at the beginning.
        <blockquote><programlisting>
SELECT
  DOC_NUMBER, DOC_DATE
FROM PAYORDER
UNION ALL
SELECT
  DOC_NUMBER, DOC_DATE
FROM BUDGORDER
ORDER BY 2 DESC NULLS LAST, 1 ASC NULLS FIRST
        </programlisting></blockquote>
      </para>
    </section> <!-- ORDER BY -->

    <section id="fblangref25-dml-select-rows">
      <title><database>ROWS</database></title>
      <formalpara>
        <title>Used for</title>
        <para>&nbsp;Retrieving a slice of rows from an ordered set</para>
      </formalpara>

      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
              <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]
           </programlisting>
           </blockquote>
        </para>
      </formalpara>
      <table id="fblangref25-dml-tbl-rows">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the ROWS Clause</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">Any integer expressions</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <formalpara>
        <title>Description</title>

        <para>Limits the amount of rows returned by the
        <database>SELECT</database> statement to a specified number or
        range.</para>
      </formalpara>
      <para>The <database>FIRST</database> and <database>SKIP</database> clauses do the same job
      as <database>ROWS</database> are not SQL-compliant. Using <database>ROWS</database> is thus
      preferable in new code. Unlike <database>FIRST</database> and <database>SKIP</database>,
      the <database>ROWS</database> and <database>TO</database> clauses accept any type of
      integer expression as their arguments, without parentheses. Of course, parentheses may
      still be needed for nested evaluations inside the expression and a subquery must always
      be enclosed in parentheses.</para>

      <important>
        <itemizedlist>
          <listitem>Numbering of rows in the intermediate set&mdash;the overall set cached on disk
          before the <quote>slice</quote> is extracted&mdash;starts at 1.</listitem>
          <listitem>Both <database>FIRST/SKIP</database> and <database>ROWS</database> can be used
          without the <database>ORDER BY</database> clause, although it rarely makes sense to
          do so&mdash;except perhaps when you want to take a quick look at the table data
          and don't care that rows will be in random order. For this purpose, a query like
          <quote><function>SELECT * FROM TABLE1 ROWS 20</function></quote> would return the
          first 20 rows instead of a whole table that might be rather big.</listitem>
        </itemizedlist>
      </important>

      <para>Calling <database>ROWS</database> <replaceable>m</replaceable> retrieves the
      first <replaceable>m</replaceable> records from the set specified.</para>

      <bridgehead renderas="sect4">Characteristics of using
      <database>ROWS</database> <replaceable>m</replaceable> without a <database>TO</database>
      clause:</bridgehead>

      <itemizedlist spacing="compact">
        <listitem>If <replaceable>m</replaceable> is greater than the total number of records
        in the intermediate data set, the entire set is returned</listitem>
        <listitem>If <replaceable>m</replaceable> = 0, an empty set is returned</listitem>
        <listitem>If <replaceable>m</replaceable> &lt; 0, the the <database>SELECT</database>
        statement call fails with an error</listitem>
      </itemizedlist>

      <para>Calling <database>ROWS</database> <replaceable>m</replaceable> <database>TO</database>
      <replaceable>n</replaceable>retrieves the rows from the set, starting at row
      <replaceable>m</replaceable> and ending after row <replaceable>n</replaceable>&mdash;the set
      is inclusive.</para>

      <bridgehead renderas="sect4">Characteristics of using
      <database>ROWS</database> <replaceable>m</replaceable> with a <database>TO</database>
      clause:</bridgehead>
      <itemizedlist spacing="compact">
        <listitem>If <replaceable>m</replaceable> is greater than the total number of rows in the
        intermediate set and <replaceable>n</replaceable> &gt;= <replaceable>m</replaceable>, an
        empty set is returned</listitem>
        <listitem>If <replaceable>m</replaceable> is not greater than <replaceable>n</replaceable>
        and <replaceable>n</replaceable> is greater than the total number of rows in the intermediate
        set, the result set will be limited to rows starting from <replaceable>m</replaceable>, up
        to the end of the set</listitem>
        <listitem>If <replaceable>m</replaceable> &lt; 1 and <replaceable>n</replaceable> &lt; 1,
        the <database>SELECT</database> statement call fails with an error</listitem>
        <listitem>If <replaceable>n</replaceable> = <replaceable>m</replaceable> - 1,
        an empty set is returned</listitem>
        <listitem>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable> - 1,
        the <database>SELECT</database> statement call fails with an error</listitem>
      </itemizedlist>

      <bridgehead renderas="sect4">Using a <database>TO</database> clause without a <database>ROWS</database>
      clause:</bridgehead>
      <para>While <database>ROWS</database> replaces the non-standard <database>FIRST</database> and
      <database>SKIP</database> syntax, there is one situation where the standard syntax does not
      provide the same behaviour:  specifying <database>SKIP</database> <replaceable>n</replaceable>
      on its own returns the entire intermediate set, without the first <replaceable>n</replaceable>
      rows.  The <database>ROWS</database>...<database>TO</database> syntax needs a little help to
      achieve this.</para>
      <para>With the <database>ROWS</database> syntax, you need a <database>ROWS</database> clause
      <emphasis>in association with</emphasis> the <database>TO</database> clause and deliberately
      make the second (<replaceable>n</replaceable>) argument greater than the size of the intermediate
      data set.  This is achieved by creating an expression for <replaceable>n</replaceable> that
      uses a subquery to retrieve the count of rows in the intermediate set and adds 1 to it.</para>

      <section id="fblangref25-dml-select-rows-mixing">
        <title>Mixing <database>ROWS</database> and <database>FIRST/SKIP</database></title>
        <para><database>ROWS</database> syntax cannot be mixed with <database>FIRST/SKIP</database>
        syntax in the same <database>SELECT</database> expression.  Using the different syntaxes in
        different subqueries in the same statement is allowed.</para>
      </section>

      <section id="fblangref25-dml-select-rows-union">
        <title><database>ROWS</database> Syntax in <database>UNION</database> Queries</title>
        <para>When <database>ROWS</database> is used in a <database>UNION</database> query, the
        <database>ROWS</database> directive is applied to the unioned set and must be placed
        after the last <database>SELECT</database> statement.</para>
        <para>If a need arises to limit the subsets returned by one or more <database>SELECT</database>
        statements inside UNION, there are a couple of options:
          <orderedlist>
            <listitem>Use <database>FIRST/SKIP</database> syntax in these <database>SELECT</database>
            statements&mdash;bearing in mind that an ordering clause (<database>ORDER BY</database>)
            cannot be applied locally to the discrete queries, but only to the combined
            output.</listitem>
            <listitem>Convert the queries to derived tables with their own <database>ROWS</database>
            clauses.</listitem>
          </orderedlist>
        </para>
      </section>

      <bridgehead renderas="sect4">Examples</bridgehead>
      <para>The following examples rewrite the <link linkend="firstskipexamples">examples</link>
      used in the section about <database>FIRST</database>
      and <database>SKIP</database>, <link linkend="fblangref25-dml-select-first-skip">earlier in this
      chapter</link>.</para>

      <para>Retrieve the first ten names from a the output of a sorted query on the PEOPLE table:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 1 TO 10
        </programlisting></blockquote></para>
      <para>or its equivalent
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 10
        </programlisting></blockquote>
      </para>

      <para>Return all records from the PEOPLE table except for the first 10 names:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 11 TO (SELECT COUNT(*) FROM People)
        </programlisting></blockquote>
      </para>
      <para>And this query will return the last 10 records (pay attention to the parentheses):
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS (SELECT COUNT(*) - 9 FROM People)
TO (SELECT COUNT(*) FROM People)
        </programlisting></blockquote>
      </para>
      <para>This one will return rows 81-100 from the PEOPLE table:
        <blockquote><programlisting>
SELECT id, name
FROM People
ORDER BY name ASC
ROWS 81 TO 100
        </programlisting></blockquote>
      </para>
      <note>
        <para><database>ROWS</database> can also be used with the <link
        linkend="fblangref25-dml-update"><database>UPDATE</database></link> and
        <link
        linkend="fblangref25-dml-delete"><database>DELETE</database></link>
        statements.</para>
      </note>
    </section> <!-- ROWS -->

<!-- SELECT ... W I T H   L O C K -->

    <section id="fblangref25-dml-with-lock">
      <title><database>WITH LOCK</database></title>

      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Used for</title>
        <para>Limited pessimistic locking</para>
      </formalpara>

      <formalpara>
        <title>Description:</title>
        <para><database>WITH LOCK</database> provides a limited explicit
        pessimistic locking capability for cautious use in conditions where
        the affected row set is:<orderedlist numeration="loweralpha"
            spacing="compact">
            <listitem>
              <para>extremely small (ideally, a singleton),
              <emphasis>and</emphasis></para>
            </listitem>

            <listitem>
              <para>precisely controlled by the application code.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>
      <caution>
        <title>This is for experts only!</title>

        <para>The need for a pessimistic lock in Firebird is very rare
        indeed and should be well understood before use of this extension is
        considered.</para>
        <para>It is essential to understand the effects of transaction
        isolation and other transaction attributes before attempting to
        implement explicit locking in your application.</para>
      </caution>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
          </blockquote></para>
      </formalpara>

      <para>If the <database>WITH LOCK</database> clause succeeds, it will
      secure a lock on the selected rows and prevent any other transaction
      from obtaining write access to any of those rows, or their dependants,
      until your transaction ends.</para>

      <para><database>WITH LOCK</database> can only be used with a
      top-level, single-table <database>SELECT</database> statement. It is
      <emphasis>not</emphasis> available:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification</para>
        </listitem>

        <listitem>
          <para>for joined sets</para>
        </listitem>

        <listitem>
          <para>with the <database>DISTINCT</database> operator, a
          <database>GROUP BY</database> clause or any other aggregating
          operation</para>
        </listitem>

        <listitem>
          <para>with a view</para>
        </listitem>

        <listitem>
          <para>with the output of a selectable stored procedure</para>
        </listitem>

        <listitem>
          <para>with an external table</para>
        </listitem>

        <listitem>
          <para>with a <database>UNION</database> query</para>
          <para><comment>Editor's note :: Should be in here, too?</comment></para>
        </listitem>

      </itemizedlist>

      <para>As the engine considers, in turn, each record falling under an explicit lock
      statement, it returns either the record version that is the most currently committed,
      regardless of database state when the statement was submitted, or an exception.</para>
      <para>Wait behaviour and conflict reporting depend on the transaction parameters specified
      in the TPB block:</para>
        <table id="fblangref25-tbl-tpb-effects">
          <title>How TPB settings affect explicit locking</title>
          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />
            <colspec align="left" colname="behaviour" colwidth="3*" />
            <thead>
              <row>
                <entry align="center">TPB mode</entry>
                <entry align="center">Behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row valign="top">
                <entry><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explicit locks are overridden by implicit or explicit
                table-level locks and are ignored.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If a record is modified by any transaction that was
                committed since the transaction attempting to get explicit lock started, or an
                active transaction has performed a modification of this record, an update conflict
                exception is raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If the record is modified by any transaction that has
                committed since the transaction attempting to get explicit lock started, an update
                conflict exception is raised immediately.</para><para>If an active transaction is
                holding ownership on this record (via explicit locking or by a normal optimistic
                write-lock) the transaction attempting the explicit lock waits for the outcome of
                the blocking transaction and, when it finishes, attempts to get the lock on the
                record again. This means that, if the blocking transaction committed a modified
                version of this record, an update conflict exception will be raised.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or normal update), an update conflict exception is
                raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or by a normal optimistic write-lock), the
                transaction attempting the explicit lock waits for the outcome of blocking
                transaction and when it finishes, attempts to get the lock on the record
                again.</para><para>Update conflict exceptions can never be raised by an explicit
                lock statement in this TPB mode.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      <section id="fblangref-dml-for-update">
        <title><database>FOR UPDATE [OF]</database></title>
        <para>If the <database>FOR UPDATE</database> clause is included, the
        buffered fetches are suppressed and, instead, the lock will be applied to each
        row, one by one, at the moment it is fetched into the server-side row cache.
        It becomes possible, then, that a lock which appeared to succeed when requested
        will nevertheless <emphasis>fail subsequently</emphasis>, when an attempt is made to
        fetch a row which has become locked by another transaction.
          <tip>
            <para>As an alternative, it may be possible in your access components to set 
            the size of the fetch buffer to 1. This would enable you to process the currently-locked row 
            before the next is fetched and locked, or to handle errors without rolling back your
            transaction.</para>
          </tip>
        </para>
        <section id="fblangref-dml-withlock-of">
          <title>The optional <quote><database>OF</database><replaceable>&lt;column-names&gt;</replaceable></quote>
          sub-clause</title>
          <para>The <database>FOR UPDATE</database> clause can optionally include the <quote><database>OF</database>
          <replaceable>&lt;column-names&gt;</replaceable></quote> subclause to enable positioned
          updates.</para>
          <para><comment>Editor's note :: I don't think this actually says anything useful about this sub-clause.
          I suspect it is an unintended survivor from some ESQL documentation.</comment></para>
        </section>
      </section> <!-- FOR UPDATE -->

      <section id="fblangref25-dml-withlock-engine">
        <title>How the engine deals with <database>WITH LOCK</database></title>
        <para>When an <database>UPDATE</database> statement tries to access a record that is locked
        by another transaction, it either raises an update conflict exception or waits for the
        locking transaction to finish, depending on TPB mode. Engine behaviour here is the same as
        if this record had already been modified by the locking transaction.</para>
        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>
        <para>The engine guarantees that all records returned by an explicit lock statement are
        actually locked and <emphasis>do</emphasis> meet the search conditions specified in
        <database>WHERE</database> clause, as long as the search conditions do not depend on any
        other tables, via joins, subqueries, etc. It also guarantees that rows not meeting the
        search conditions will not be locked by the statement. It can <emphasis>not</emphasis>
        guarantee that there are no rows which, though meeting the search conditions, are not
        locked.</para>
        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during
          the course of the locking statement's execution.</para>
        </note>
        <para>The engine locks rows at fetch time. This has important consequences if you lock
        several rows at once. Many access methods for Firebird databases default to fetching output
        in packets of a few hundred rows (<quote>buffered fetches</quote>). Most data access
        components cannot bring you the rows contained in the last-fetched packet, where an error
        occurred.</para>
      </section>
      <section id="fblangref-dml-withlock-caveats">
        <title>Caveats using <database>WITH LOCK</database></title>
        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were
            taken under that savepoint, but it doesn't notify waiting transactions. Applications
            should not depend on this behaviour as it may get changed in the future.</para>
          </listitem>
          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict
            errors, the volume of deadlock errors will grow unless you design your locking strategy
            carefully and control it rigorously.</para>
          </listitem>
          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit
            locks are (1) to prevent expensive handling of update conflict errors in heavily loaded
            applications and (2) to maintain integrity of objects mapped to a relational database in
            a clustered environment. If your use of explicit locking doesn't fall in one of these
            two categories, then it's the wrong way to do the task in Firebird.</para>
          </listitem>
          <listitem>
            <para>Explicit locking is an advanced feature; do not misuse it! While solutions for
            these kinds of problems may be very important for web sites handling thousands of
            concurrent writers, or for ERP/CRM systems operating in large corporations, most
            application programs do not need to work in such conditions.</para>
          </listitem>
        </itemizedlist>
      </section>
      <bridgehead id="fblangref25-dml-withlock-examples" renderas="sect4">
      Examples using explicit locking</bridgehead>
      <orderedlist numeration="lowerroman">
          <listitem>
            <para>Simple:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK</programlisting>
          </listitem>
          <listitem>
            <para>Multiple rows, one-by-one processing with DSQL cursor:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK</programlisting>
          </listitem>
      </orderedlist>
    </section> <!-- select ... with lock -->

    <section id="fblangref25-dml-select-into">
      <title><database>INTO</database></title>
      <formalpara>
        <title>Used for</title>
        <para>Passing <database>SELECT</database> output into variables</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>

      <para>In PSQL code (triggers, stored procedures and executable blocks),
      the results of a <database>SELECT</database> statement can be loaded
      row-by-row into local variables.  It is often the only way to do anything
      with the returned values at all. The number, order and types of the
      variables must match the columns in the output row.</para>

      <para>A <quote>plain</quote> <database>SELECT</database> statement can
      only be used in PSQL if it returns at most one row, i.e., if it is a <emphasis>singleton</emphasis>
      select. For multi-row selects, PSQL provides
      the <link linkend="fblangref25-psql-forselect"><database>FOR SELECT</database></link>
      loop construct, discussed later in the PSQL chapter. PSQL also supports
      the <database>DECLARE CURSOR</database> statement, which binds a named cursor to
      a <database>SELECT</database> statement. The cursor can then be used to walk the
      result set.</para>

      <formalpara>
        <title>Syntax</title>
        <para>In PSQL the <database>INTO</database> clause is placed at the very end of
        the <database>SELECT</database> statement.</para>
        <blockquote><programlisting>
SELECT [...] &lt;column-list&gt;
FROM ...
[...]
[INTO &lt;variable-list&gt;]

&lt;variable-list&gt; ::= [:]<replaceable>psqlvar</replaceable> [, [:]<replaceable>psqlvar</replaceable> ...]
        </programlisting></blockquote>
        <note>
          <para>The colon prefix before local variable names in PSQL is optional.</para>
        </note>
      </formalpara>

      <bridgehead renderas="sect4">Examples</bridgehead>

      <para>Selecting some aggregated values and passing them into previously
      declared variables <varname>min_amt</varname>,
      <varname>avg_amt</varname> and <varname>max_amt</varname>:

        <blockquote>
        <programlisting>select min(amount), avg(cast(amount as float)), max(amount)
  from orders
  where artno = 372218
  into min_amt, avg_amt, max_amt;</programlisting>
        </blockquote>
        <note>
          <para>The <database>CAST</database> serves to make the average a real
          number;  otherwise, since <systemitem>amount</systemitem> is presumably
          an integer field, SQL rules would truncate it to the nearest lower
          integer.</para>
        </note>
      </para>
      <para>A PSQL trigger that retrieves two values as a <database>BLOB</database>
      field (using the <database>LIST()</database>
      function) and assigns it <database>INTO</database> a third field:
        <blockquote>
        <programlisting>select list(name, ', ')
  from persons p
  where p.id in (new.father, new.mother)
  into new.parentnames;</programlisting>
        </blockquote>
      </para>
    </section> <!-- INTO clause -->


    <!-- C O M M O N   T A B L E   E X P R E S S I O N S  -->

    <section id="fblangref25-dml-select-cte">
      <title>Common Table Expressions (<quote><database>WITH ...
      AS ... SELECT</database></quote>)</title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>


      </formalpara>

      <para>A common table expression or <database>CTE</database> can be
      described as a virtual table or view, defined in a preamble to a main
      query, and going out of scope after the main query's execution. The
      main query can reference any <database>CTE</database>s defined in the
      preamble as if they were regular tables or views.
      <database>CTE</database>s can be recursive, i.e. self-referencing, but
      they cannot be nested.</para>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
              <programlisting><replaceable>&lt;cte-construct&gt;</replaceable>  ::=  <replaceable>&lt;cte-defs&gt;</replaceable>
                      <replaceable>&lt;main-query&gt;</replaceable>

<replaceable>&lt;cte-defs&gt;</replaceable>       ::=  WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]

<replaceable>&lt;cte&gt;</replaceable>            ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-stmt&gt;</replaceable>)

<replaceable>&lt;column-list&gt;</replaceable>    ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]
            </programlisting></blockquote>
        </para>
      </formalpara>
      <table id="fblangref25-dml-tbl-cte">
      <?dbfo keep-together='auto'?>
        <title>Arguments for Common Table Expressions</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cte-stmt</entry>
              <entry align="left">Any SELECT statement, including UNION</entry>
            </row>
            <row valign="middle">
              <entry align="center">main-query</entry>
              <entry align="left">The main SELECT statement, which can refer to the CTEs defined in the preamble</entry>
            </row>
            <row valign="middle">
              <entry align="center">name</entry>
              <entry align="left">Alias for a table expression</entry>
            </row>
            <row valign="middle">
              <entry align="center">column-alias</entry>
              <entry align="left">Alias for a column in a table expression</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
              <programlisting><emphasis role="bold">with dept_year_budget as (
  select fiscal_year,
         dept_no,
         sum(projected_budget) as budget
  from proj_dept_budget
  group by fiscal_year, dept_no
)</emphasis>
select d.dept_no,
       d.department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from department d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009
where exists (
  select * from proj_dept_budget b
  where d.dept_no = b.dept_no
)</programlisting>
            </blockquote></para>
      </formalpara>
      <bridgehead renderas="sect4">CTE Notes</bridgehead>
      <itemizedlist>
        <listitem>
          <para>A <database>CTE</database> definition can contain any
          legal <database>SELECT</database> statement, as long as it
          doesn't have a <quote><database>WITH...</database></quote>
          preamble of its own (no nesting).</para>
        </listitem>

        <listitem>
          <para><database>CTE</database>s defined for the same main
          query can reference each other, but care should be taken to
          avoid loops.</para>
        </listitem>

        <listitem>
          <para><database>CTE</database>s can be referenced from
          anywhere in the main query.</para>
        </listitem>

        <listitem>
          <para>Each <database>CTE</database> can be referenced multiple
          times in the main query, using different aliases if necessary.</para>
         </listitem>

        <listitem>
          <para>When enclosed in parentheses, <database>CTE</database>
          constructs can be used as subqueries in
          <database>SELECT</database> statements, but also in
          <database>UPDATE</database>s, <database>MERGE</database>s
          etc.</para>
        </listitem>

        <listitem>
          <para>In PSQL, <database>CTE</database>s are also supported in
          <database>FOR</database> loop headers:</para>

          <literallayout class="monospaced">
for
  <emphasis role="bold">with my_rivers as (select * from rivers where owner = 'me')</emphasis>
    select name, length from my_rivers into :rname, :rlen
do
begin
  ..
end
          </literallayout>
        </listitem>
      </itemizedlist>

      <important>
        <para>If a <database>CTE</database> is declared, it must be used later: otherwise,
        you will get an error like this: 'CTE &quot;AAA&quot; is not used in query'.</para>
      </important>

      <section id="fblangref25-dml-select-cte-recursive">
        <title>Recursive <database>CTE</database>s</title>

        <para>A recursive (self-referencing) <database>CTE</database> is a
        <database>UNION</database> which must have at least one
        non-recursive member, called the <firstterm>anchor</firstterm>. The
        non-recursive member(s) must be placed before the recursive
        member(s). Recursive members are linked to each other and to their
        non-recursive neighbour by <database>UNION ALL</database> operators.
        The unions between non-recursive members may be of any type.</para>

        <para>Recursive <database>CTE</database>s require the
        <database>RECURSIVE</database> keyword to be present right after
        <database>WITH</database>. Each recursive union member may reference
        itself only once, and it must do so in a <database>FROM</database>
        clause.</para>

        <para>A great benefit of recursive <database>CTE</database>s is that
        they use far less memory and CPU cycles than an equivalent recursive
        stored procedure.</para>

        <bridgehead renderas="sect4">Execution Pattern</bridgehead>
        <para>The execution pattern of a recursive <database>CTE</database>
        is as follows:</para>

        <itemizedlist>
          <listitem>
            <para>The engine begins execution from a non-recursive
            member.</para>
          </listitem>

          <listitem>
            <para>For each row evaluated, it starts executing each recursive
            member one by one, using the current values from the outer row
            as parameters.</para>
          </listitem>

          <listitem>
            <para>If the currently executing instance of a recursive member
            produces no rows, execution loops back one level and gets the
            next row from the outer result set.</para>
          </listitem>
        </itemizedlist>

        <formalpara>
            <title>Example of recursive <database>CTE</database>s</title>
            <para><blockquote>
              <programlisting>
WITH RECURSIVE DEPT_YEAR_BUDGET AS (
  SELECT
      FISCAL_YEAR,
      DEPT_NO,
      SUM(PROJECTED_BUDGET) BUDGET
  FROM PROJ_DEPT_BUDGET
  GROUP BY FISCAL_YEAR, DEPT_NO
),
DEPT_TREE AS (
  SELECT
      DEPT_NO,
      HEAD_DEPT,
      DEPARTMENT,
      CAST('' AS VARCHAR(255)) AS INDENT
  FROM DEPARTMENT
  WHERE HEAD_DEPT IS NULL
  UNION ALL
  SELECT
      D.DEPT_NO,
      D.HEAD_DEPT,
      D.DEPARTMENT,
      H.INDENT || ' '
  FROM DEPARTMENT D
    JOIN DEPT_TREE H ON H.HEAD_DEPT = D.DEPT_NO
)
SELECT
    D.DEPT_NO,
    D.INDENT || D.DEPARTMENT DEPARTMENT,
    DYB_2008.BUDGET AS BUDGET_08,
    DYB_2009.BUDGET AS BUDGET_09
FROM DEPT_TREE D
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2008 ON
      (D.DEPT_NO = DYB_2008.DEPT_NO) AND
      (DYB_2008.FISCAL_YEAR = 2008)
    LEFT JOIN DEPT_YEAR_BUDGET DYB_2009 ON
      (D.DEPT_NO = DYB_2009.DEPT_NO) AND
      (DYB_2009.FISCAL_YEAR = 2009)
              </programlisting></blockquote>
            </para>
            <para>The next example returns the pedigree of a horse. The main difference 
            is that recursion occurs simultaneously in two branches of the pedigree.
              <blockquote><programlisting>
WITH RECURSIVE PEDIGREE (
    CODE_HORSE,
    CODE_FATHER,
    CODE_MOTHER,
    NAME,
    MARK,
    DEPTH)
AS (SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        CAST('' AS VARCHAR(80)),
        0
    FROM
        HORSE
    WHERE
        HORSE.CODE_HORSE = :CODE_HORSE
    UNION ALL
    SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        'F' || PEDIGREE.MARK,
        PEDIGREE.DEPTH + 1
    FROM
        HORSE
        JOIN PEDIGREE
      ON HORSE.CODE_HORSE = PEDIGREE.CODE_FATHER
    WHERE
        PEDIGREE.DEPTH &lt; :MAX_DEPTH
    UNION ALL
    SELECT
        HORSE.CODE_HORSE,
        HORSE.CODE_FATHER,
        HORSE.CODE_MOTHER,
        HORSE.NAME,
        'M' || PEDIGREE.MARK,
        PEDIGREE.DEPTH + 1
    FROM
        HORSE
        JOIN PEDIGREE
      ON HORSE.CODE_HORSE = PEDIGREE.CODE_MOTHER
    WHERE
        PEDIGREE.DEPTH &lt; :MAX_DEPTH
)
SELECT
    CODE_HORSE,
    NAME,
    MARK,
    DEPTH
FROM
    PEDIGREE
              </programlisting></blockquote>
            </para>
        </formalpara>

        <formalpara>
          <title>Notes on recursive <database>CTE</database>s</title>

          <para><itemizedlist>
            <listitem>
              <para>Aggregates (<database>DISTINCT</database>,
                <database>GROUP BY</database>, <database>HAVING</database>)
                and aggregate functions (<database>SUM</database>,
                <database>COUNT</database>, <database>MAX</database> etc)
                are not allowed in recursive union members.</para>
              </listitem>

              <listitem>
                <para>A recursive reference cannot participate in an outer
                join.</para>
              </listitem>

              <listitem>
                <para>The maximum recursion depth is 1024.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section> <!-- C O M M O N   T A B L E   E X P R E S S I O N S -->

  </section> <!-- S E L E C T -->

<!-- ========================================================================================
                   I N S E R T
     ======================================================================================== -->

  <section id="fblangref25-dml-insert">
    <title><database>INSERT</database></title>
    <formalpara>
      <title>Used for</title>
      <para>&nbsp;Inserting rows of data into a table</para>
    </formalpara>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para>
      <blockquote><programlisting>
INSERT INTO <replaceable>target</replaceable>
{DEFAULT VALUES | [(&lt;column_list&gt;)] &lt;value_source&gt;}
[RETURNING &lt;returning_list&gt; [INTO &lt;variables&gt;]]

&lt;column_list&gt; ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]

&lt;value_source&gt; ::= VALUES (&lt;value_list&gt;) | &lt;select_stmt&gt;

&lt;value_list&gt; ::= <replaceable>value</replaceable> [, <replaceable>value</replaceable> ...]

&lt;returning_list&gt; ::= <replaceable>ret_value</replaceable> [, <replaceable>ret_value</replaceable> ...]
&lt;variables&gt; ::= [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]
</programlisting></blockquote>
      </para>
    </formalpara>
          <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->
      <table id="fblangref25-dml-tbl-insert">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the INSERT Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">The name of the table or view to which a new row, or batch of rows, 
              should be added</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Column in the table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">An expression whose value is used for inserting into the table</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">The expression to be returned in the RETURNING clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name of a PSQL local variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Description</title>

      <para>The <database>INSERT</database> statement is used to add rows
      to a table or to one or more tables underlying a view:
        <itemizedlist>
          <listitem>If the column values are supplied in a <database>VALUES</database> clause,
          exactly one row is inserted</listitem>
          <listitem>The values may be provided instead by a <database>SELECT</database> expression,
          in which case zero to many rows may be inserted</listitem>
          <listitem>With the <database>DEFAULT VALUES</database> clause, no values are provided at
          all and exactly one row is inserted.</listitem>
        </itemizedlist>
      </para>
      <note>
        <title>Restrictions</title>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Columns returned to the <database>NEW.</database><replaceable>column_name</replaceable>
            context variables in triggers should not have a colon (<quote><literal>:</literal></quote>)
            prefixed to their names</para>
          </listitem>
          <listitem>
            <para>No column may appear more than once in the column list.</para>
          </listitem>
        </itemizedlist>
      </note>
    </formalpara>

    <important>
      <title>ALERT :: 'BEFORE INSERT' Triggers</title>
      <para>Regardless of the method used for inserting rows, be mindful of any columns
      in the target table or view that are populated by <database>BEFORE INSERT</database>
      triggers, such as primary keys and case-insensitive search columns.  Those columns
      should be excluded from both the <replaceable>column_list</replaceable> and the
      <database>VALUES</database> list if, as they should, the triggers test the
      <database>NEW.</database><replaceable>column_name</replaceable> for <constant>NULL</constant>.
      </para>
    </important>
     <para><comment>Editor's note :: I added the alert above, because it wasn't mentioned
     anywhere.</comment></para>

    <section id="fblangref25-dml-insert-values">
      <title><database>INSERT</database> ...
      <database>VALUES</database></title>

      <para>The <database>VALUES</database> list must provide a value for
      every column in the column list, in the same order and of the correct
      type. The column list need not specify every column in the target but,
      if the column list is absent, the engine requires a value for every
      column in the table or view (computed columns excluded).</para>

      <section id="fblangref25-dml-insert-values-character">
        <title>Introducer Syntax for String Literals</title>
        <para>String literals may optionally be preceded by a character set
        name, itself prefixed with an underscore <quote>_</quote>.  This is known 
        as <firstterm>introducer syntax</firstterm>.  Its purpose is to inform 
        the engine as to how it is to interpret and store the incoming string.</para>
        <note>
          <para>Introducer syntax works only with literal strings.  It cannot be 
          applied directly to string variables, parameters or function expressions.</para>
        </note>
      </section>

      <formalpara>
        <title>Examples</title>
        <para>
          <blockquote><programlisting>
INSERT INTO cars (make, model, year)
VALUES ('Ford', 'T', 1908);

INSERT INTO cars
VALUES ('Ford', 'T', 1908, 'USA', 850);

-- notice the '_' prefix
INSERT INTO People
VALUES (_ISO8859_1 'Hans-J&ouml;rg Sch&auml;fer')
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-insert-select">
      <title><database>INSERT</database> ...
      <database>SELECT</database></title>

      <para>For this method of inserting, the output columns of the 
      <database>SELECT</database> statement must provide a
      value for every target column in the column list, in the same order and
      of the correct type.</para>
      <para>Literal values, context variables or expressions of compatible type 
      can be substituted for any column in the source row.  In this case, a 
      source column list and a corresponding <database>VALUES</database> list 
      are required.</para>
      <para>If the column list is absent&mdash;as it is when <database>SELECT *</database>
      is used for the source expression&mdash;the <replaceable>column_list</replaceable>
      must contain the names of every column in the target table or view (computed columns
      excluded).</para>

      <formalpara>
        <title>Examples</title>

        <para>
          <blockquote><programlisting>
INSERT INTO cars (make, model, year)
  SELECT make, model, year
  FROM new_cars;

INSERT INTO cars
  SELECT * FROM new_cars;

INSERT INTO Members (number, name)
  SELECT number, name FROM NewMembers
    WHERE Accepted = 1
UNION ALL
  SELECT number, name FROM SuspendedMembers
    WHERE Vindicated = 1

INSERT INTO numbers(num)
  WITH RECURSIVE r(n) as (
      SELECT 1 FROM rdb$database
      UNION ALL
      SELECT n+1 FROM r WHERE n &lt; 100
                          )
SELECT n FROM r
          </programlisting></blockquote>
        </para>
      </formalpara>

      <para>Of course, the column names in the source table need not be the
      same as those in the target table. Any type of
      <database>SELECT</database> statement is permitted, as long as its
      output columns exactly match the insert columns in number, order and
      type. Types need not be exactly the same, but they must be
      assignment-compatible.</para>
    </section>

    <section id="fblangref25-dml-insert-defaults">
      <title><database>INSERT</database> ... <database>DEFAULT
      VALUES</database></title>

      <para>The <database>DEFAULT VALUES</database> clause allows insertion of
      a record without providing any values at all, neither directly nor from
      a <database>SELECT</database> statement. This is only possible if every
      <database>NOT NULL</database> or <database>CHECK</database>ed column in
      the table either has a valid default declared or gets such a value from
      a <database>BEFORE INSERT</database> trigger. Furthermore, triggers
      providing required field values must not depend on the presence of input
      values.</para>

      <formalpara>
        <title>Example</title>

        <para>
          <blockquote><programlisting>
INSERT INTO journal
  DEFAULT VALUES
RETURNING entry_id
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-insert-returning">
      <title>The <database>RETURNING</database> clause</title>

      <para>An <database>INSERT</database> statement adding <emphasis>at most
      one row</emphasis> may optionally include a
      <database>RETURNING</database> clause in order to return values from the
      inserted row. The clause, if present, need not contain all of the insert
      columns and may also contain other columns or expressions. The returned
      values reflect any changes that may have been made in
      <database>BEFORE INSERT</database> triggers.</para>
      <important>
        <title>ALERT :: Multiple INSERTs</title>
        <para>In DSQL, a statement with <database>RETURNING</database> always
        returns only one row. If the <database>RETURNING</database> clause is
        specified and more than one row is inserted by the <database>INSERT</database>
        statement, the statement fails and an error message is returned. This
        behaviour may change in future Firebird versions.</para>
      </important>
      <formalpara>
        <title>Examples</title>

        <para>
          <blockquote><programlisting>
INSERT INTO Scholars (
  firstname, 
  lastname,
  address,
  phone,
  email)
VALUES (
  'Henry',
  'Higgins',
  '27A Wimpole Street',
  '3231212',
  NULL)
RETURNING lastname, fullname, id;

INSERT INTO Dumbbells (firstname, lastname, iq)
  SELECT fname, lname, iq
FROM Friends
  ORDER BY iq ROWS 1
  RETURNING id, firstname, iq
INTO :id, :fname, :iq;
          </programlisting></blockquote>
        </para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para>
          <itemizedlist>
            <listitem>
              <para><database>RETURNING</database> is only supported for
              <database>VALUES</database> inserts and singleton
              <database>SELECT</database> inserts.</para>
            </listitem>

            <listitem>
              <para>In DSQL, a statement with a <database>RETURNING</database>
              clause <emphasis role="">always</emphasis> returns exactly one
              row. If no record was actually inserted, the fields in this row
              are all <constant>NULL</constant>. This behaviour may change in
              a later version of Firebird. In PSQL, if no row was inserted,
              nothing is returned, and the target variables keep their
              existing values.</para>
            </listitem>
          </itemizedlist>
        </para>
      </formalpara>
      <para><comment>Editor's note :: These notes were missing from the
      raw translation: perhaps they were overlooked by the translator?</comment>
      </para>
      <para><comment>Editor's note :: And the following section as well!</comment></para>
    </section>

    <section id="fblangref25-dml-insert-blobs">
      <title>Inserting into <database>BLOB</database> columns</title>

      <para>Inserting into <database>BLOB</database> columns is only possible
      under the following circumstances:</para>

      <orderedlist>
        <listitem>
          <para>The client application has made special provisions for such
          inserts, using the Firebird API. In this case, the <firstterm>modus operandi</firstterm> is
          application-specific and outside the scope of this manual.</para>
        </listitem>

        <listitem>
          <para>The value inserted is a text string of no more than 32767 bytes.
            <caution>
              <para>If the value is not a string literal, beware of
              concatenations, as the output from the expression may exceed the maximum
              length.</para>
            </caution>
          </para>
        </listitem>

        <listitem>
          <para>You are using the <quote><database>INSERT</database> ...
          <database>SELECT</database></quote> form and one or more columns in
          the result set are <database>BLOB</database>s.</para>
        </listitem>

      </orderedlist>
    </section>
  </section> <!-- INSERT -->

<!-- ========================================================================================
                   U P D A T E
     ======================================================================================== -->

  <section id="fblangref25-dml-update">
    <title><database>UPDATE</database></title>

    <formalpara>
      <title>Used for</title>
      <para>&nbsp;Modifying rows in tables and views</para>
    </formalpara>
    <formalpara>
      <title>Available in</title>
      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>
      <para>
        <blockquote><programlisting>
   UPDATE <replaceable>target</replaceable> [[AS] <replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;returning_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;returning_list&gt;</replaceable>     ::=  <replaceable>ret_value</replaceable> [, <replaceable>ret_value</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
       </programlisting></blockquote>
     </para>
    </formalpara>

      <table id="fblangref25-dml-tbl-update">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the UPDATE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">The name of the table or view where the records are updated</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Alias for the table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Name or alias of a column in the table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">newval</entry>
              <entry align="left">New value for a column that is to be updated in the table or view by the statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">search-conditions</entry>
              <entry align="left">A search condition limiting the set of the rows to be updated</entry>
            </row>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">The name of the cursor through which the row[s] to be updated are positioned</entry>
            </row>
            <row valign="middle">
              <entry align="center">plan_items</entry>
              <entry align="left">Clauses in the query plan</entry>
            </row>
            <row valign="middle">
              <entry align="center">sort_items</entry>
              <entry align="left">Columns listed in an ORDER BY clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">Integer expressions for limiting the number of rows to be updated</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">A value to be returned in the RETURNING clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name of a PSQL local variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    <formalpara>
      <title>Description</title>

      <para>The <database>UPDATE</database> statement changes values in a table
      or in one or more of the tables that underlie a view. The columns affected
      are specified in the <database>SET</database> clause. The rows affected may
      be limited by the <database>WHERE</database> and <database>ROWS</database>
      clauses. If neither <database>WHERE</database> nor <database>ROWS</database>
      is present, all the records in the table will be updated.</para>
    </formalpara>

    <section id="fblangref25-dml-update-alias-use">
      <title>Using an alias</title>

      <para>If you assign an alias to a table or a view, the alias <emphasis>must</emphasis>
      be used when specifying columns and also in any column references included in other
      clauses.</para>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>Correct usage:</para>

            <programlisting>update Fruit set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit set Fruit.soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set soort = 'pisang' where ...</programlisting>

            <programlisting>update Fruit F set F.soort = 'pisang' where ...</programlisting>

            <para>Not possible:</para>

            <programlisting>update Fruit F set Fruit.soort = 'pisang' where ...</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-update-setclause">
      <title>The <database>SET</database> Clause</title>

      <para>In the <database>SET</database> clause, the assignment phrases, containing
      the columns with the values to be set, are separated by commas. In an assignment
      phrase, column names are on the left and the values or expressions containing the
      assignment values are on the right. A column may be included only once in
      the <database>SET</database> clause.</para>

      <para>A column name can be used in expressions on the right.  The old value of
      the column will always be used in these right-side values, even if the column
      was already assigned a new value earlier in the <database>SET</database> clause.
        <formalpara>
          <title>Here is an example</title>
          <para>Data in the TSET table:
            <blockquote><literallayout class="monospaced">
A B
----
1 0
2 0
            </literallayout></blockquote>
          The statement
            <blockquote><programlisting>
UPDATE tset SET a = 5, b = a
        </programlisting></blockquote>
          will change the values to
          <blockquote><literallayout class="monospaced">
A B
----
5 1
5 2
          </literallayout></blockquote>

          Notice that the old values (1 and 2) are used to update the b column even after the
          column was assigned a new value (5).
          </para>
          <note>
            <para>It was not always like that.  Before version 2.5, columns got their new values
            immediately upon assignment. It was non-standard behaviour that was fixed in version 2.5.</para>
            <para>To maintain compatibility with legacy code, the configuration file <filename>firebird.conf</filename>
            includes the parameter <varname>OldSetClauseSemantics</varname>, that can be set True (1) to restore
             the old, bad behaviour. It is a temporary measure&mdash;the parameter will be removed in future.</para>
          </note>
        </formalpara>
      </para>
    </section> <!-- SET clause -->

    <section id="fblangref25-dml-update-whereclause">
      <title>The <database>WHERE</database> Clause</title>
      <para>The WHERE clause sets the conditions that limit the set of records for a
      <firstterm>searched update</firstterm>.</para>
      <para>In PSQL, if a named cursor is being used for updating a set, using the
      <database>WHERE CURRENT OF</database> clause, the action is limited to the row where the
      cursor is currently positioned.  This is a <firstterm>positioned update</firstterm>.
        <note>
          <para>The <database>WHERE CURRENT OF</database> clause is available only in PSQL only,
          since there is no statement for creating and manipulating an explicit cursor
          in DSQL.  Searched updates are also available in PSQL, of course.</para>
        </note>
      </para>

      <formalpara>
        <title>Examples</title>
        <para>
          <blockquote><programlisting>
UPDATE People
  SET firstname = 'Boris'
  WHERE lastname = 'Johnson';

UPDATE employee e
  SET salary = salary * 1.05
  WHERE EXISTS(
         SELECT *
           FROM employee_project ep
           WHERE e.emp_no = ep.emp_no);

UPDATE addresses
  SET city = 'Saint Petersburg', citycode = 'PET'
  WHERE city = 'Leningrad'

UPDATE employees
  SET salary = 2.5 * salary
  WHERE title = 'CEO'
          </programlisting></blockquote>
        </para>
<!-- introducer syntax -->
        <para>For string literals with which the parser needs help to interpret the character
        set of the data, the <link linkend="fblangref25-dml-insert-values-character">introducer
        syntax</link> may be used.  The string literal is preceded by the character set name,
        prefixed with an underscore character:
          <blockquote><programlisting>
-- notice the '_' prefix

UPDATE People
SET name = _ISO8859_1 'Hans-J&ouml;rg Sch&auml;fer'
WHERE id = 53662
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- WHERE clause -->

    <section id="fblangref25-dml-update-orderbyclause">
      <title>The <database>ORDER BY</database> and <database>ROWS</database> Clauses</title>
      <para>The <database>ORDER BY</database> and <database>ROWS</database> clauses make sense
      only when used together. However, they can be used separately.</para>

      <para>If <database>ROWS</database> has one argument, <replaceable>m</replaceable>, the
      rows to be updated will be limited to the first <replaceable>m</replaceable> rows.
        <formalpara>
          <title>Points to note</title>
          <itemizedlist spacing="compact">
            <listitem>If m &gt; the number of rows being processed, the entire set of rows
            is updated</listitem>
            <listitem>If m = 0, no rows are updated</listitem>
            <listitem>If m &lt; 0, an error occurs and the update fails</listitem>
          </itemizedlist>
        </formalpara>
      </para>

      <para>If two arguments are used, <replaceable>m</replaceable> and <replaceable>n</replaceable>,
      <database>ROWS</database> limits the rows being updated to rows from
      <replaceable>m</replaceable> to <replaceable>n</replaceable> inclusively.
      Both arguments are integers and start from 1.
        <formalpara>
          <title>Points to note</title>
          <itemizedlist spacing="compact">
            <listitem>If m &gt; the number of rows being processed, no rows are updated</listitem>
            <listitem>If n &gt; the number of rows, rows from m to the end of the set are updated</listitem>
            <listitem>If m &lt; 1 or n &lt; 1, an error occurs and the update fails</listitem>
            <listitem>If n = m - 1, no rows are updated</listitem>
            <listitem>If n &lt; m -1, an error occurs and the update fails</listitem>
          </itemizedlist>
        </formalpara>
      </para>
      <formalpara>
        <title>ROWS Example</title>
        <para>
          <blockquote><programlisting>
UPDATE employees
SET salary = salary + 50
ORDER BY salary ASC
ROWS 20
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- order by and rows -->

    <section id="fblangref25-dml-update-returningclause">
      <title>The <database>RETURNING</database> Clause</title>
      <para>An <database>UPDATE</database> statement involving <emphasis>at most one row</emphasis>
      may include <database>RETURNING</database> in order to return some values from the row
      being updated. <database>RETURNING</database> may include data from any row, not necessarily
      the one that is currently being updated.  It can include literals not associated with columns,
      if there is a need for that.</para>
      <para>When the <database>RETURNING</database> set contains data from the current row, the returned
      values report changes made in the <database>BEFORE UPDATE</database> triggers, but not those made
      in <database>AFTER UPDATE</database> triggers.</para>
      <para>The context variables <database>OLD</database>.fieldname and <database>NEW</database>.fieldname
      can be used as column names. If <database>OLD.</database> or <database>NEW.</database> is not
      specified, the column values returned are the <database>NEW.</database> ones.</para>
      <para>In DSQL, a statement with <database>RETURNING</database> always returns a single row.
      If the statement updates no records, the returned values contain <constant>NULL</constant>.
      This behaviour may change in future Firebird versions.</para>

      <section  id="fblangref25-dml-update-returning-into">
        <title>The <database>INTO</database> Sub-clause</title>
        <para>In PSQL, the <database>INTO</database> clause can be used to pass the returning values
        to local variables. It is not available in DSQL. If no records are updated, nothing is
        returned and variables specified in <database>RETURNING</database> will keep their
        previous values.
          <note>
            <para>A column returned to a <database>NEW.</database> context variable in the trigger
            should not have a colon before its name.</para>
          </note>
        </para>
        <para><comment>Editor's note :: This note seems to be a non-sequitur.  Should it be
        <quote>A column returned FROM ...</quote>?</comment></para>
      </section> <!-- RETURNING INTO -->

      <formalpara>
      <title>RETURNING Example (DSQL)</title>
        <para>
          <blockquote><programlisting>
UPDATE Scholars
SET firstname = 'Hugh', lastname = 'Pickering'
WHERE firstname = 'Henry' and lastname = 'Higgins'
RETURNING id, old.lastname, new.lastname
          </programlisting></blockquote>
        </para>
      </formalpara>

    </section> <!-- RETURNING clause -->

    <section id="fblangref25-dml-update-blob">
      <title>Updating <database>BLOB</database> columns</title>

      <para>Updating a <database>BLOB</database> column always replaces the
      entire contents. Even the <database>BLOB</database> ID, the
      <quote>handle</quote> that is stored directly in the column, is changed.
      <database>BLOB</database>s can be updated if:</para>

      <orderedlist>
        <listitem>
          <para>The client application has made special provisions for this
          operation, using the Firebird API. In this case, the <firstterm>modus operandi</firstterm>
          is application-specific and outside the scope of this manual.</para>
        </listitem>

        <listitem>
          <para>The new value is a text string of at most 32767 bytes. Please
          notice: if the value is not a string literal, beware of
          concatenations, as these may exceed the maximum length.</para>
        </listitem>

        <listitem>
          <para>The source is itself a <database>BLOB</database> column or,
          more generally, an expression that returns a
          <database>BLOB</database>.</para>
        </listitem>

        <listitem>
          <para>You use the <database>INSERT CURSOR</database> statement (ESQL only).</para>
        </listitem>
      </orderedlist>
    </section>
  </section> <!-- UPDATE -->

<!-- ========================================================================================
                   U P D A T E   O R   I N S E R T
     ======================================================================================== -->

  <section id="fblangref25-dml-update-or-insert">
    <title><database>UPDATE OR INSERT</database></title>
    <formalpara>
      <title>Used for</title>
      <para>Updating an existing record in a table or, if it does not exist,
      inserting it</para>
    </formalpara>
    <formalpara>
      <title>Available in</title>
      <para>DSQL, PSQL</para>

      <!--ESQL ? Guess not, readme says: Scope: DSQL, PSQL-->
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
        <programlisting>UPDATE OR INSERT INTO
   {<replaceable>target</replaceable>} [(<replaceable>&lt;column_list&gt;</replaceable>)]
   VALUES (<replaceable>&lt;value_list&gt;</replaceable>)
   [MATCHING (<replaceable>&lt;column_list&gt;</replaceable>)]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;column_list&gt;</replaceable>      ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;value_list&gt;</replaceable>       ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;ret_values&gt;</replaceable>       ::=  <replaceable>ret_value</replaceable>    [, <replaceable>ret_value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>    ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
        </programlisting>
      </blockquote></para>
    </formalpara>

      <table id="fblangref25-dml-tbl-updorins">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the UPDATE OR INSERT Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">The name of the table or view where the record[s] is to be updated
              or a new record inserted</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name of a column in the table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">An expression whose value is to be used for inserting or updating
              the table</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">An expression returned in the RETURNING clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variable name&mdash;PSQL only</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Description</title>
      <para><database>UPDATE OR INSERT</database> inserts a new record or
      updates one or more existing records. The action taken depends on the
      values provided for the columns in the <database>MATCHING</database>
      clause (or, if the latter is absent, in the primary key). If there are
      records found matching those values, they are updated. If not, a new
      record is inserted.</para>
      <para>
        <blockquote>A match only counts if all the values in the
        <database>MATCHING</database> or <database>PK</database> columns are
        equal. Matching is done with the <link
        linkend="fblangref25-commons-isnotdistinct"><database>IS NOT DISTINCT</database></link>
        operator, so one <constant>NULL</constant> matches another.</blockquote>
      </para>
    </formalpara>

    <note>
      <title>Restrictions</title>

      <itemizedlist spacing="compact">
        <listitem>
          <para>If the table has no <database>PK</database>, the
          <database>MATCHING</database> clause becomes mandatory.</para>
        </listitem>

        <listitem>
          <para>In the <database>MATCHING</database> list as well as in
          the update/insert column list, each column name may occur only
          once.</para>
        </listitem>

        <listitem>
          <para>The <quote><database>INTO</database>
          <replaceable>&lt;variables&gt;</replaceable></quote> subclause
          is only available in PSQL.</para>
        </listitem>

        <listitem>
          <para>When values are returned into the context variable
          <database>NEW</database>, this name must not be preceded by a
          colon (<quote><literal>:</literal></quote>).</para>
        </listitem>
      </itemizedlist>
    </note>

    <section id="fblangref25-dml-update-or-insert-returning">
      <title>The <database>RETURNING</database> clause</title>

      <para>The optional <database>RETURNING</database> clause, if present,
      need not contain all the columns mentioned in the statement and may also
      contain other columns or expressions. The returned values reflect any
      changes that may have been made in <database>BEFORE</database> triggers,
      but not those in <database>AFTER</database> triggers.
      <database>OLD</database>.<replaceable>fieldname</replaceable> and
      <database>NEW</database>.<replaceable>fieldname</replaceable> may both
      be used in the list of columns to return; for field names not preceded
      by either of these, the new value is returned.</para>

      <para>In DSQL, a statement with a <database>RETURNING</database> clause
      <emphasis role="">always</emphasis> returns exactly one row. If a
      <database>RETURNING</database> clause is present and more than one
      matching record is found, an error is raised. This behaviour may change
      in a later version of Firebird.</para>
    </section>

    <formalpara>
      <title>Example</title>
      <para>Modifying data in a table, using UPDATE OR INSERT in a PSQL
      module.  The return value is passed to a local variable, whose
      colon prefix is not optional.
      <blockquote>
          <programlisting>UPDATE OR INSERT INTO Cows (Name, Number, Location)
  VALUES ('Suzy Creamcheese', 3278823, 'Green Pastures')
  MATCHING (Number)
  RETURNING rec_id into :id;</programlisting>
        </blockquote>
      </para>
    </formalpara>
  </section> <!-- update or insert -->

<!-- ========================================================================================
                   D E L E T E
     ======================================================================================== -->


  <section id="fblangref25-dml-delete">
    <title><database>DELETE</database></title>
    <formalpara>
      <title>Used for</title>
      <para>&nbsp;Deleting rows from a table or view</para>
    </formalpara>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>


    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>DELETE
   FROM {<replaceable>target</replaceable>} [[AS] <replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;returning_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;returning_list&gt;</replaceable>     ::=  <replaceable>ret_value</replaceable> [, <replaceable>ret_value</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
          </programlisting>
      </blockquote></para>
    </formalpara>

      <table id="fblangref25-dml-tbl-delete">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the DELETE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">The name of the table or view from which the records are to be deleted</entry>
            </row>
            <row valign="middle">
              <entry align="center">alias</entry>
              <entry align="left">Alias for the target table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">search-conditions</entry>
              <entry align="left">Search condition limiting the set of rows being targeted for deletion</entry>
            </row>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">The name of the cursor in which current record is positioned for deletion</entry>
            </row>
            <row valign="middle">
              <entry align="center">plan_items</entry>
              <entry align="left">Query plan clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">sort_items</entry>
              <entry align="left">ORDER BY clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">Integer expressions for limiting the number of rows being deleted</entry>
            </row>
            <row valign="middle">
              <entry align="center">ret_value</entry>
              <entry align="left">An expression to be returned in the RETURNING clause</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name of a PSQL variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Description</title>

      <para><database>DELETE</database> removes rows from a database table or
      from one or more of the tables that underlie a view. <database>WHERE</database>
      and <database>ROWS</database> clauses can limit the number of rows
      deleted. If neither <database>WHERE</database> nor
      <database>ROWS</database> is present, <database>DELETE</database>
      removes all the rows in the relation.</para>
    </formalpara>

    <section id="fblangref25-dml-delete-alias-use">
      <title>Aliases</title>
      <para>If an alias is specified for the target table or view, it
      must be used to qualify all field name references in the
      <database>DELETE</database> statement.
        <formalpara>
          <title>Examples</title>
          <para>
            <blockquote>
            <para>Supported usage:</para>

            <programlisting>delete from Cities where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities where Cities.name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where name starting 'Alex'</programlisting>

            <programlisting>delete from Cities C where C.name starting 'Alex'</programlisting>

            <para>Not possible:</para>

            <programlisting>delete from Cities C where Cities.name starting 'Alex'</programlisting>
              </blockquote>
          </para>
        </formalpara>
      </para>
    </section>

    <section id="fblangref25-dml-delete-where">
      <title><database>WHERE</database></title>

      <para>The WHERE clause sets the conditions that limit the set of records for a
      <firstterm>searched delete</firstterm>.</para>
      <para>In PSQL, if a named cursor is being used for deleting a set, using the
      <database>WHERE CURRENT OF</database> clause, the action is limited to the row where the
      cursor is currently positioned.  This is a <firstterm>positioned update</firstterm>.
        <note>
          <para>The <database>WHERE CURRENT OF</database> clause is available only in PSQL and ESQL,
          since there is no statement for creating and manipulating an explicit cursor
          in DSQL.  Searched deletes are also available in PSQL, of course.</para>
        </note>
      </para>

      <formalpara>
        <title>Examples</title>
        <para>
          <blockquote><programlisting>
DELETE FROM People
  WHERE firstname &lt;&gt; 'Boris' AND lastname &lt;&gt; 'Johnson'
         </programlisting>

          <programlisting>
DELETE FROM employee e
  WHERE NOT EXISTS(
    SELECT *
    FROM employee_project ep
     WHERE e.emp_no = ep.emp_no);
         </programlisting>

         <programlisting>
DELETE FROM Cities
  WHERE CURRENT OF Cur_Cities;  -- ESQL and PSQL only
         </programlisting>
          </blockquote>
        </para>
      </formalpara>
    </section><!-- where -->

    <section id="fblangref25-dml-delete-plan">
      <title><database>PLAN</database></title>
      <para>A <database>PLAN</database> clause allows the user to optimize
      the operation manually.</para>

      <formalpara>
        <title>Example</title>

        <para>
          <blockquote><programlisting>
DELETE FROM Submissions
  WHERE date_entered &lt; '1-Jan-2002'
  PLAN (Submissions INDEX ix_subm_date);
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-delete-orderby">
      <title><database>ORDER BY</database> and <database>ROWS</database></title>
      <para>The <database>ORDER BY</database> clause orders the set before
      the actual deletion takes place. It only makes sense in combination
      with <database>ROWS</database>, but is also valid without it.</para>

      <para>The <database>ROWS</database> clause limits the number of rows being 
      deleted. Integer literals or any integer expressions can be used for
      the arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>.
      </para>
      
      <para>If <database>ROWS</database> has one argument, <replaceable>m</replaceable>, the
      rows to be deleted will be limited to the first <replaceable>m</replaceable> rows.
        <formalpara>
          <title>Points to note</title>
          <itemizedlist spacing="compact">
            <listitem>If m &gt; the number of rows being processed, the entire set of rows
            is deleted</listitem>
            <listitem>If m = 0, no rows are deleted</listitem>
            <listitem>If m &lt; 0, an error occurs and the update fails</listitem>
          </itemizedlist>
        </formalpara>
      </para>

      <para>If two arguments are used, <replaceable>m</replaceable> and <replaceable>n</replaceable>,
      <database>ROWS</database> limits the rows being deleted to rows from
      <replaceable>m</replaceable> to <replaceable>n</replaceable> inclusively.
      Both arguments are integers and start from 1.
        <formalpara>
          <title>Points to note</title>
          <itemizedlist spacing="compact">
            <listitem>If m &gt; the number of rows being processed, no rows are deleted</listitem>
            <listitem>If m &gt; 0 and &lt;= the number of rows in the set and n is outside
            these values, rows from m to the end of the set are deleted</listitem>
            <listitem>If m &lt; 1 or n &lt; 1, an error occurs and the deletion fails</listitem>
            <listitem>If n = m - 1, no rows are deleted</listitem>
            <listitem>If n &lt; m -1, an error occurs and the update fails</listitem>
          </itemizedlist>
        </formalpara>
      </para>

      <formalpara>
        <title>Examples</title>
        <para>
          <blockquote>
         <para>Deleting the oldest purchase:
            <programlisting>
DELETE FROM Purchases
  ORDER BY date ROWS 1
            </programlisting></para>
         <para>Deleting the highest custno(s):
            <programlisting>
DELETE FROM Sales
  ORDER BY custno DESC ROWS 1 to 10
            </programlisting></para>
         <para>Deleting all sales, <database>ORDER BY</database> clause pointless:
            <programlisting>
DELETE FROM Sales
  ORDER BY custno DESC
            </programlisting></para>
         <para>Deleting one record starting from the end, i.e. from Z&hellip;:
            <programlisting>
DELETE FROM popgroups
  ORDER BY name DESC ROWS 1
            </programlisting></para>
         <para>Deleting the five oldest groups:
            <programlisting>
DELETE FROM popgroups
  ORDER BY formed ROWS 5
            </programlisting></para>
         <para>No sorting (<database>ORDER BY</database>) is specified so 8 found records,
         starting from the fifth one, will be deleted:
            <programlisting>
DELETE FROM popgroups
  ROWS 5 TO 12
            </programlisting></para>
          </blockquote>
        </para>
      </formalpara>
    </section>

    <section id="fblangref25-dml-delete-returning">
      <title><database>RETURNING</database></title>
      <para>A <database>DELETE</database> statement removing <emphasis>at
        most one row</emphasis> may optionally include a
        <database>RETURNING</database> clause in order to return values from
        the deleted row. The clause, if present, need not contain all the
        relation's columns and may also contain other columns or expressions.
      </para>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>In DSQL, a statement with <database>RETURNING</database> always
          returns a singleton, never a mult-row set. If no records are deleted, the
          returned columns contain <constant>NULL</constant>. This behaviour may change
          in future Firebird versions</listitem>
          <listitem>The <database>INTO</database> clause is available only in PSQL
            <itemizedlist>
              <listitem>If the row is not deleted, nothing is returned and the target
              variables keep their values</listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
      </note>

      <formalpara>
        <title>Examples</title>
        <para>
          <blockquote>
             <programlisting>
DELETE FROM Scholars
  WHERE firstname = 'Henry' and lastname = 'Higgins'
  RETURNING lastname, fullname, id
            </programlisting>

            <programlisting>
DELETE FROM Dumbbells
  ORDER BY iq DESC
  ROWS 1
  RETURNING lastname, iq into :lname, :iq;
            </programlisting>
         </blockquote>
        </para>
      </formalpara>
    </section>
    <para><comment>Editor's note :: I have excluded two allusions to assigning values to  
    the NEW and OLD context variables in PSQL (one Note, one example) as there are no NEW context
    variables in DELETE triggers and the OLD ones are read-only.  Oops!  they were
    probably copy/paste booboos.</comment></para>
  </section>  <!-- DELETE -->

<!-- ========================================================================================
                   M E R G E
     ======================================================================================== -->

  <section id="fblangref25-dml-merge">
    <title><database>MERGE</database></title>
      <formalpara>
        <title>Used for</title>
        <para>&nbsp;Merging data from a source set into a target relation</para>
      </formalpara>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, PSQL<!--ESQL... guess not--></para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para><blockquote>
          <programlisting>MERGE INTO <replaceable>target</replaceable> [[AS] <replaceable>target-alias</replaceable>]
   USING <replaceable>source</replaceable> [[AS] <replaceable>source-alias</replaceable>]
   ON <replaceable>join-condition</replaceable>
   WHEN MATCHED THEN UPDATE SET <replaceable>colname</replaceable> = <replaceable>value</replaceable> [, <replaceable>colname</replaceable> = <replaceable>value</replaceable> ...]
   WHEN NOT MATCHED THEN INSERT [(<replaceable>&lt;columns&gt;</replaceable>)] VALUES (<replaceable>&lt;values&gt;</replaceable>)

<replaceable>&lt;columns&gt;</replaceable>  ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;values&gt;</replaceable>   ::=  <replaceable>value</replaceable>   [, <replaceable>value</replaceable>   ...]
        </programlisting>
      </blockquote></para>
    </formalpara>

      <table id="fblangref25-dml-tbl-merge">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the MERGE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">target</entry>
              <entry align="left">Name of target relation (table or updatable view)</entry>
            </row>
            <row valign="middle">
              <entry align="center">source</entry>
              <entry align="left">Data source. It can be a table, a view, a stored procedure or a derived table</entry>
            </row>
            <row valign="middle">
              <entry align="center">target-alias</entry>
              <entry align="left">Alias for the target relation (table or updatable view)</entry>
            </row>
            <row valign="middle">
              <entry align="center">source-alias</entry>
              <entry align="left">Alias for the source relation or set</entry>
            </row>
            <row valign="middle">
              <entry align="center">join-conditions</entry>
              <entry align="left">The (ON) condition[s] for matching the source records
              with those in the target</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name of a column in the target relation</entry>
            </row>
            <row valign="middle">
              <entry align="center">value</entry>
              <entry align="left">The value assigned to a column in the target table. It is an expression that may be a literal
              value, a PSQL variable, a column from the source or a compatible context variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <bridgehead renderas="sect4">Description</bridgehead>
    <para>The <database>MERGE</database> statement merges data into a table or
    updatable view. The source may be a table, view or <quote>anything you can
    <database>SELECT</database> from</quote> in general. Each source record
    will be used to update one or more target records, insert a new record
    in the target table, or neither.</para>
    <para> The action taken depends on the supplied join condition and the <database>WHEN</database>
    clause(s). The condition will typically contain a comparison of fields in the source and target
    relations.</para>

    <note>
      <title>Notes</title>
      <para>Only one of each <database>WHEN</database> clause can be supplied.
      This will change in the next major version of Firebird, when compound matching conditions 
      will be supported.</para>
      <para><database>WHEN NOT MATCHED</database> is evaluated from the source viewpoint, that is,
      the table or set specified in <database>USING</database>. It has to work this way because,
      if the source record does not match a target record, <database>INSERT</database> is executed.
      Of course, if there is a target record that does not match a source record, nothing is done.</para>
      <para>Currently, the ROW_COUNT variable returns the value 1, even if more than one record
      is modified or inserted. For details and progress, refer to
      <ulink url="http://tracker.firebirdsql.org/browse/CORE-4400">Tracker ticket CORE-4400</ulink>.</para>
    </note>
    <warning>
      <title>ALERT :: Another irregularity!</title>
      <para>If the <database>WHEN MATCHED</database> clause is present and several records match
      a single record in the target table, an <database>UPDATE</database> will be executed on that one
      target record for each one of the matching source records, with each successive update overwriting
      the previous one. This behaviour does not comply with the SQL:2003 standard, which requires that
      this situation throw an exception (an error).</para>
    </warning>

    <formalpara>
      <title>Examples</title>
      <para>
        <blockquote>
          <programlisting>
MERGE INTO books b
  USING purchases p
  ON p.title = b.title and p.type = 'bk'
  WHEN MATCHED THEN
    UPDATE SET b.desc = b.desc || '; ' || p.desc
  WHEN NOT MATCHED THEN
    INSERT (title, desc, bought) values (p.title, p.desc, p.bought)
          </programlisting>

          <programlisting>
MERGE INTO customers c
  USING (SELECT * from customers_delta WHERE id &gt; 10) cd
  ON (c.id = cd.id)
  WHEN MATCHED THEN
    UPDATE SET name = cd.name
  WHEN NOT MATCHED THEN
    INSERT (id, name) values (cd.id, cd.name)
          </programlisting>

          <programlisting>
MERGE INTO numbers
USING (
  WITH RECURSIVE r(n) AS (
    SELECT 1 FROM rdb$database
    UNION ALL
    SELECT n+1 FROM r WHERE n &lt; 200
  )
  SELECT n FROM r
) t
ON numbers.num = t.n
WHEN NOT MATCHED THEN
  INSERT(num) VALUES(t.n);
          </programlisting>
        </blockquote>
      </para>
    </formalpara>
  </section><!-- MERGE -->



<!-- ========================================================================================
                   E X E C U T E   P R O C E D U R E
     ======================================================================================== -->

  <section id="fblangref25-dml-execproc">
    <title><database>EXECUTE PROCEDURE</database></title>

    <formalpara>
      <title>Used for</title>
      <para>&nbsp;Executing a stored procedure</para>
    </formalpara>

    <formalpara>
      <title>Available in</title>

      <para>DSQL, ESQL, PSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para>
        <blockquote>
          <programlisting>
EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...]] | [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]
   [RETURNING_VALUES <replaceable>&lt;outvar&gt;</replaceable> [, <replaceable>&lt;outvar&gt;</replaceable> ...] | (<replaceable>&lt;outvar&gt;</replaceable> [, <replaceable>&lt;outvar&gt;</replaceable> ...])]

<replaceable>&lt;outvar&gt;</replaceable> ::= [:]varname
          </programlisting>
        </blockquote>
      </para>
    </formalpara>
    
    <para><comment>Editor's note :: Notice I added the non-parenthesised option for return parameters, after 
    an exchange with Dmitry Y.</comment></para>

      <table id="fblangref25-dml-tbl-execproc">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the EXECUTE PROCEDURE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name of the stored procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">inparam</entry>
              <entry align="left">An expression evaluating to the declared data type of
              an input parameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">A PSQL variable to receive the return value</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

    <formalpara>
      <title>Description</title>

      <para>Executes an <firstterm>executable stored procedure</firstterm>, taking a list of 
      one or more input parameters, if they are defined for the procedure, and returning a one-row 
      set of output values, if they are defined for the procedure.</para>
    </formalpara>

    <section id="fblangref25-dml-execproc-which">
      <title><quote>Executable</quote> Stored Procedure</title>
      <para>The <database>EXECUTE PROCEDURE</database> statement is most commonly used to invoke
      the style of stored procedure that is written to perform some data-modifying task at the server
      side&mdash;those that do not contain any <database>SUSPEND</database> statements in their
      code.  They can be designed to return a result set, consisting of only one row, which is usually
      passed, via a set of <database>RETURNING_VALUES()</database> variables, to another stored
      procedure that calls it. Client interfaces usually have an API wrapper that can retrieve the
      output values into a single-row buffer when calling <database>EXECUTE PROCEDURE</database>
      in DSQL.</para>
      <para>Invoking the other style of stored procedure&mdash;a <quote>selectable</quote> one&mdash;is
      possible with <database>EXECUTE PROCEDURE</database> but it returns only the first row of
      an output set which is almost surely designed to be multi-row.  Selectable stored procedures
      are designed to be invoked by a <database>SELECT</database> statement, producing output that
      behaves like a virtual table.</para>
    </section>

    <note>
      <title>Notes</title>
      <itemizedlist>
        <listitem>
          <para>In PSQL and DSQL, input parameters may be any expression that resolves to the expected type.</para>
        </listitem>
        <listitem>
          <para>Although parentheses are not required after the name of the stored procedure to enclose
          the input parameters, their use is recommended for the sake of good housekeeping.</para>
        </listitem>
        <listitem>
          <para>Where output parameters have been defined in a procedure, the <database>RETURNING_VALUES</database>
          clause can be used in PSQL to retrieve them into a list of previously declared variables that
          conforms in sequence, data type and number with the defined output parameters.</para>
        </listitem>
        <listitem>
          <para>The list of <database>RETURNING_VALUES</database> may be optionally enclosed in
          parentheses and their use is recommended.</para>
        </listitem>
        <listitem>
          <para>When DSQL applications call <database>EXECUTE PROCEDURE</database> using the Firebird API or
          some form of wrapper for it, a buffer is prepared to receive the output row and the
          <database>RETURNING_VALUES</database> clause is not used.</para>
        </listitem>
      </itemizedlist>
    </note>
    <formalpara>
      <title>Examples</title>
      <para>
        <blockquote>
          <para>In PSQL, with optional colons and without optional parentheses:</para>
          <programlisting>
EXECUTE PROCEDURE MakeFullName
  :FirstName, :MiddleName, :LastName
  RETURNING_VALUES :FullName;
          </programlisting>

          <para>In Firebird's command-line utility
          <emphasis>isql</emphasis>,  with literal parameters and 
          optional parentheses:</para>
          <programlisting>
EXECUTE PROCEDURE MakeFullName ('J', 'Edgar', 'Hoover');
          </programlisting>

          <para><emphasis role="bold">Note:</emphasis> In <emphasis>isql</emphasis>,
          <database>RETURNING_VALUES</database> is not used. Any output values are
          captured by the application and displayed automatically.</para>

          <para>A PSQL example with expression parameters and optional parentheses:</para>
          <programlisting>
EXECUTE PROCEDURE MakeFullName
  ('Mr./Mrs. ' || FirstName, MiddleName, upper(LastName))
  RETURNING_VALUES (FullName);
          </programlisting>
        </blockquote>
        </para>
    </formalpara>
  </section> <!-- EXECUTE PROCEDURE -->

<!-- ========================================================================================
                   E X E C U T E   B L O C K
     ======================================================================================== -->

  <section id="fblangref25-dml-execblock">
    <title><database>EXECUTE BLOCK</database></title>
    <formalpara>
      <title>Used for</title>
      <para>&nbsp;Creating an <quote>anonymous</quote> block of PSQL code in DSQL for
      immediate execution</para>
    </formalpara>

    <formalpara>
      <title>Available in</title>
      <para>DSQL</para>
    </formalpara>

    <formalpara>
      <title>Syntax</title>

      <para>
        <blockquote>
          <programlisting>
EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparams&gt;</replaceable>         ::=  <replaceable>&lt;param_decl&gt;</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable> ]
<replaceable>&lt;outparams&gt;</replaceable>        ::=  <replaceable>&lt;param_decl&gt;</replaceable>     [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;param_decl&gt;</replaceable>       ::=  <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
<replaceable>&lt;type&gt;</replaceable>             ::=  <replaceable>datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>

<replaceable>datatype</replaceable> ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

<replaceable>&lt;declarations&gt;</replaceable>     ::=  <replaceable>declare_item</replaceable> [<replaceable>declare_item</replaceable> ...]
<replaceable>declare_item</replaceable> ::=  <replaceable>declare_var</replaceable>; | <replaceable>declare_cursor</replaceable>
          </programlisting>
        </blockquote>
      </para>
    </formalpara>

      <table id="fblangref25-dml-tbl-execblock">
      <?dbfo keep-together='auto'?>
        <title>Arguments for the EXECUTE BLOCK Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colArgument" colwidth="*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">param_decl</entry>
              <entry align="left">Name and description of an input or output parameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">A section for declaring local variables and named cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Local variable declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Declaration of a named cursor</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">The name of an input or output parameter of the procedural block, up to 31
              characters long. The name must be unique among input and output parameters and local variables
              in the block</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation sequence</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Domain</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel</entry>
              <entry align="left">Name of a table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Name of a column in a table or view</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Precision. From 1 to 18</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Scale. From 0 to 18. It must be less than or equal to <replaceable>precision</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string, in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Character set</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size, it cannot be greater than 65,535</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    <formalpara>
      <title>Description</title>

      <para>Executes a block of PSQL code as if it were a stored procedure,
      optionally with input and output parameters and variable declarations.
      This allows the user to perform <quote>on-the-fly</quote> PSQL within a
      DSQL context.</para>
    </formalpara>

    <formalpara>
      <title>Examples</title>
      <para>
        <blockquote><programlisting>
          <para>This example injects the numbers 0 through 127 and their
          corresponding ASCII characters into the table
          <database>ASCIITABLE</database>:</para>
EXECUTE BLOCK
AS
declare i INT = 0;
BEGIN
  WHILE (i &lt; 128) DO
  BEGIN
    INSERT INTO AsciiTable VALUES (:i, ascii_char(:i));
    i = i + 1;
  END
END
          </programlisting>
        </blockquote>
        <blockquote>
          <para>The next example calculates the geometric mean of two numbers
          and returns it to the user:</para>
           <programlisting>
EXECUTE BLOCK (x DOUBLE PRECISION = ?, y DOUBLE PRECISION = ?)
RETURNS (gmean DOUBLE PRECISION)
AS
BEGIN
  gmean = SQRT(x*y);
  SUSPEND;
END
          </programlisting>

          <para>Because this block has input parameters, it has to be prepared
          first. Then the parameters can be set and the block executed. It
          depends on the client software how this must be done and even if it
          is possible at all&mdash;see the notes below.</para>

          <para>Our last example takes two integer values,
          <varname>smallest</varname> and <varname>largest</varname>. For all
          the numbers in the range <varname>smallest</varname> ..
          <varname>largest</varname>, the block outputs the number itself, its
          square, its cube and its fourth power.</para>

          <programlisting>
EXECUTE BLOCK (smallest INT = ?, largest INT = ?)
RETURNS (number INT, square BIGINT, cube BIGINT, fourth BIGINT)
AS
BEGIN
  number = smallest;
  WHILE (number &lt;= largest) DO
  BEGIN
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    SUSPEND;
    number = number + 1;
  END
END
          </programlisting>
          <para>Again, it depends on the client software if and how you can
          set the parameter values.</para>
        </blockquote>
       </para>
    </formalpara>

    <section id="fblangref25-dml-execblock-params">
      <title>Input and output parameters</title>

      <para>Executing a block without input parameters should be possible with
      every Firebird client that allows the user to enter his or her own DSQL
      statements. If there are input parameters, things get trickier: these
      parameters must get their values after the statement is prepared but
      before it is executed. This requires special provisions, which not every
      client application offers. (Firebird's own
      <application>isql</application>, for one, doesn't.)</para>

      <para>The server only accepts question marks
      (<quote><literal>?</literal></quote>) as placeholders for the input
      values, not <quote><literal>:a</literal></quote>,
      <quote><literal>:MyParam</literal></quote> etc., or literal values.
      Client software may support the <quote><literal>:xxx</literal></quote>
      form though, and will preprocess it before sending it to the
      server.</para>

      <para>If the block has output parameters, you <emphasis>must</emphasis>
      use <database>SUSPEND</database> or nothing will be returned.</para>

      <para>Output is always returned in the form of a result set, just as
      with a <database>SELECT</database> statement. You can't use
      <database>RETURNING_VALUES</database> or execute the block
      <database>INTO</database> some variables, even if there is only one
      result row.</para>

      <sidebar>
        <title>PSQL Links</title>
        <para>For more information about parameter and variable declarations, 
        and <replaceable>&lt;PSQL statements&gt;</replaceable> consult Chapter 7,
        <link linkend="fblangref25-psql"><citetitle>Procedural SQL (PSQL) Statements</citetitle></link>.</para>
        <para>For <replaceable>&lt;declarations&gt;</replaceable> in particular, see
        <link linkend="fblangref25-psql-declare-variable"><database>DECLARE [VARIABLE]</database></link>
        and <link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link> for
        the exact syntax.</para>
      </sidebar>
    </section>

    <section id="fblangref25-dml-execblock-terms">
      <title>Statement terminators</title>

      <para>Some clients, especially those allowing the user to submit several
      statements at once, may require you to surround the <database>EXECUTE
      BLOCK</database> statement with <database>SET TERM</database> lines,
      like this:</para>

      <blockquote>
        <programlisting>
SET TERM #;
EXECUTE BLOCK (...)
AS
BEGIN
  statement1;
  statement2;
END #
SET TERM ;#
        </programlisting>
      </blockquote>
      <para>As an example, in Firebird's <emphasis>isql</emphasis>
      client you must set the terminator to something other than
      the semi-colon (<quote><literal>;</literal></quote>) before you type in the
      <database>EXECUTE BLOCK</database> statement, because that application 
      uses the semi-colon as its own statement terminator. Failure to 
      set an alternative terminator for <emphasis>isql</emphasis> will cause
      <emphasis>isql</emphasis> to try to execute the portion you have
      typed so far, as soon as you type any line with a semicolon and 
      press Enter.</para>
    </section>
  </section>  <!-- EXECUTE BLOCK -->

</chapter>
