<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="fblangref25-commons">
  <title>Common Language Elements</title>
  <para>    This chapter covers the elements that are common throughout the implementation of the
    SQL language&#x2014;the <firstterm>expressions</firstterm> that are used to extract and operate 
    on assertions about data and the <firstterm>predicates</firstterm> that test the truth of those 
    assertions.</para>
  <section id="fblangref25-commons-expressions">
    <title>Expressions</title>
    <para>SQL expressions provide formal methods for evaluating, transforming and comparing
    values. SQL expressions may include table columns, variables, constants, literals, various
    statements and predicates and also other expressions. The complete list of possible tokens
    in expressions follows.</para>

    <table id="fblangref25-dtyp-tbl-exprelements">
    <?dbfo keep-together='auto'?>
      <title>Description of Expression Elements</title>
      <tgroup cols="2">
        <colspec colname="colElem" colwidth="2*"></colspec>
        <colspec colname="colDesc" colwidth="5*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Element</entry>
            <entry align="center">Description</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="left">Column name</entry>
            <entry align="left">Identifier of a column from a specified table used in evaluations
            or as a search condition. A column of the array type cannot be an element in an expression
            except when used with the <database>IS [NOT] NULL</database> predicate.</entry>
          </row>
          <row valign="middle">
            <entry align="left">Array element</entry>
            <entry align="left">An expression may contain a reference to an array member
            i.e., <replaceable>&lt;array_name&gt;[s]</replaceable>,
            where <replaceable>s</replaceable> is the subscript of the member in the array
            <replaceable>&lt;array_name&gt;</replaceable></entry>
          </row>
          <row valign="middle">
            <entry align="left">Arithmetic operators</entry>
            <entry align="left">The +, -, *, / characters used to calculate values</entry>
          </row>
          <row valign="middle">
            <entry align="left">Concatenation operator</entry>
            <entry align="left">The || (<quote>double-pipe</quote>) operator used to concatenate
            strings</entry>
          </row>
          <row valign="middle">
            <entry align="left">Logical operators</entry>
            <entry align="left">The reserved words NOT, AND and OR, used to combine simple search
            conditions in order to create complex assertions</entry>
          </row>
          <row valign="middle">
            <entry align="left">Comparison operators</entry>
            <entry align="left">The symbols =, &lt;&gt;, !=, ~=, ^=, &lt;, &lt;=, &gt;, &gt;=, 
            !&lt;, ~&lt;, ^&lt;, !&gt;, ~&gt; and ^&gt;</entry>
          </row>
          <row valign="middle">
            <entry align="left">Comparison predicates</entry>
            <entry align="left"><database>LIKE, STARTING WITH, CONTAINING, SIMILAR TO, BETWEEN,
            IS [NOT] NULL</database> and <database>IS [NOT] DISTINCT FROM</database></entry>
          </row>
          <row valign="middle">
            <entry align="left">Existential predicates</entry>
            <entry align="left">Predicates used to check the existence of values in a set. The
            <database>IN</database> predicate can be used both with sets of comma-separated
            constants and with subqueries that return a single column. The <database>EXISTS, SINGULAR, ALL,
            ANY</database> and <database>SOME</database> predicates can be used only
            with subqueries</entry>
          </row>
          <row valign="middle">
            <entry align="left">Constant</entry>
            <entry align="left">A number; or a string literal enclosed in apostrophes</entry>
          </row>
          <row valign="middle">
            <entry align="left">Date/time literal</entry>
            <entry align="left">An expression, similar to a string literal enclosed in apostrophes,
            that can be interpreted as a date, time or timestamp value. Date literals can be
            predefined literals ('TODAY', 'NOW', etc.) or strings of characters
            and numerals, such as '25.12.2016 15:30:35', that can be resolved as date and/or time strings</entry>
          </row>
          <row valign="middle">
            <entry align="left">Context variable</entry>
            <entry align="left">An internally-defined <link linkend="fblangref25-functions-contextvars">context 
            variable</link></entry>
          </row>
          <row valign="middle">
            <entry align="left">Local variable</entry>
            <entry align="left">Declared local variable, input or output parameter of a PSQL
            module (stored procedure, trigger, unnamed PSQL block in DSQL)</entry>
          </row>
          <row valign="middle">
            <entry align="left">Positional parameter</entry>
            <entry align="left">A member of in an ordered group of one or more unnamed parameters
            passed to a stored procedure or prepared query</entry>
          </row>
          <row valign="middle">
            <entry align="left">Subquery</entry>
            <entry align="left">A SELECT statement enclosed in parentheses that returns a single (scalar)
            value or, when used in existential predicates, a set of values</entry>
          </row>
          <row valign="middle">
            <entry align="left">Function identifier</entry>
            <entry align="left">The identifier of an internal or external function in a function
            expression</entry>
          </row>
          <row valign="middle">
            <entry align="left">Type cast</entry>
            <entry align="left">An expression explicitly converting data of one data type to another
            using the <database>CAST</database> function ( <function>CAST (&lt;value&gt;
            AS &lt;datatype&gt;)</function> ). For date/time literals only, the shorthand syntax 
            &lt;datatype&gt; &lt;value&gt; is also supported (<function>DATE '25.12.2016'</function>)</entry>
          </row>
          <row valign="middle">
            <entry align="left">Conditional expression</entry>
            <entry align="left">Expressions using CASE and related internal functions</entry>
          </row>
          <row valign="middle">
            <entry align="left">Parentheses</entry>
            <entry align="left">Bracket pairs (&#x2026;) used to group expressions.
            Operations inside the parentheses are performed before operations outside them. When
            nested parentheses are used, the most deeply nested expressions are evaluated
            first and then the evaluations move outward through the levels of nesting.</entry>
          </row>
          <row valign="middle">
            <entry align="left">COLLATE clause</entry>
            <entry align="left">Clause applied to CHAR and VARCHAR types to specify the 
            character-set-specific collation sequence to use in string comparisons</entry>
          </row>
          <row valign="middle">
            <entry align="left"><database>NEXT VALUE FOR</database> <replaceable>sequence</replaceable></entry>
            <entry align="left">Expression for obtaining the next value of a specified generator
            (sequence). The internal <database>GEN_ID()</database> function does the same</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="fblangref25-commons-constants">
      <title>Constants</title>
      <para>A constant is a value that is supplied directly in an SQL statement, not derived from an expression,
      a parameter, a column reference nor a variable.  It can be a string or a number.</para>

      <section id="fblangref25-commons-string-constant">
        <title>String Constants (Literals)</title>
        <para>A string constant is a series of characters enclosed between a pair of apostrophes
        (<quote>single quotes</quote>).  The maximum length of a string is 32,767 bytes;  the 
        maximum character count will be determined by the number of bytes used to encode each 
        character.</para>
        <note>
          <itemizedlist spacing="compact">
            <listitem><para>Double quotes are <emphasis>NOT VALID</emphasis> for quoting strings.
            SQL reserves a different purpose for them.</para></listitem>
            <listitem><para>If a literal apostrophe is required within a string constant, it is
            <quote>escaped</quote> by prefixing it with another apostrophe.  For example, 
            <filename>'Mother O''Reilly's home-made hooch'</filename>.</para></listitem>
            <listitem><para>Care should be taken with the string length if the value is to be
            written to a <database>VARCHAR</database> column.  The maximum length for a
            <database>VARCHAR</database> is 32,765 bytes.</para></listitem>
          </itemizedlist>
        </note>
        <para>The character set of a string constant is assumed to be the same as the character set of
        its destined storage.</para>


        <section id="fblangref25-commons-hexstrings">
          <title>String Constants in Hexadecimal Notation</title>
          <para>From Firebird 2.5 forward, string literals can be entered in hexadecimal notation, 
          so-called <quote>binary strings</quote>.  Each pair of hex digits defines one byte in 
          the string. Strings entered this way will have character set <database>OCTETS</database> 
          by default but the <link linkend="fblangref25-commons-introducer-syntax"><firstterm>introducer 
          syntax</firstterm></link> can be used to force a string to be interpreted as another character set.</para>
          <formalpara>
            <title>Syntax</title>
            <para>
            <blockquote>
              <literallayout class="monospaced">
{x|X}'<replaceable>&lt;hexstring&gt;</replaceable>'

  <replaceable>&lt;hexstring>&gt;</replaceable>  ::=  an even number of <replaceable>&lt;hexdigit&gt;</replaceable>
  <replaceable>&lt;hexdigit&gt;</replaceable>   ::=  one of 0..9, A..F, a..f
              </literallayout>
            </blockquote>
            </para>
          </formalpara>
          
          <formalpara>
            <title>Examples</title>
            <para>
            <programlisting>
    select x'4E657276656E' from rdb$database
      -- returns 4E657276656E, a 6-byte 'binary' string

    select _ascii x'4E657276656E' from rdb$database
      -- returns 'Nerven' (same string, now interpreted as ASCII text)

    select _iso8859_1 x'53E46765' from rdb$database
      -- returns 'S&#xe4;ge' (4 chars, 4 bytes)

    select _utf8 x'53C3A46765' from rdb$database
      -- returns 'S&#xe4;ge' (4 chars, 5 bytes)
            </programlisting>
            </para>
          </formalpara>
          <note>
            <title>Notes</title>
            <para>The client interface determines how binary strings are displayed to the user. 
            The <emphasis>isql</emphasis> utility, for example, uses upper case letters A-F, while FlameRobin 
            uses lower case letters. Other client programs may use other conventions, such as displaying spaces 
            between the byte pairs: '4E 65 72 76 65 6E'.</para>
            <para>The hexadecimal notation allows any byte value (including 00) to be inserted at any position 
            in the string. However, if you want to coerce it to anything other than OCTETS, it is your 
            responsibility to supply the bytes in a sequence that is valid for the target character set.</para>
          </note>
        </section>

        <section id="fblangref25-commons-introducer-syntax">
          <title>Introducer Syntax for String Literals</title>
          <para>If necessary, a string literal may be preceded by a character set
          name, itself prefixed with an underscore <quote>_</quote>.  This is known
          as <firstterm>introducer syntax</firstterm>.  Its purpose is to inform
          the engine about how to interpret and store the incoming string.</para>
          <para>Example
          <blockquote><programlisting>
INSERT INTO People
VALUES (_ISO8859_1 'Hans-J&#xf6;rg Sch&#xe4;fer')
            </programlisting></blockquote>
          </para>
        </section>
      </section>

      <section id="fblangref25-commons-number-constant">
        <title>Number Constants</title>
        <para>A number constant is any valid number in a supported notation:
          <itemizedlist>
            <listitem><para>In SQL, for numbers in the standard decimal notation, the decimal point is
            always represented by period (full-stop, dot) character and thousands are not
            separated.  Inclusion of commas, blanks, etc. will cause errors.</para></listitem>
            <listitem><para>Exponential notation is supported.  For example, 0.0000234 can be expressed
            as <filename>2.34e-5</filename>.</para></listitem>
            <listitem><para>Hexadecimal notation is supported by Firebird 2.5 and higher versions&#x2014;see below.</para></listitem>
          </itemizedlist>
        </para>
        <section id="fblangref25-commons-hexnumbers">
          <title>Hexadecimal Notation for Numerals</title>
          <para>From Firebird 2.5 forward, integer values can be entered in hexadecimal notation.
          Numbers with 1-8 hex digits will be interpreted as type INTEGER; numbers with 9-16 hex digits as
          type BIGINT.</para>
          <formalpara>
            <title>Syntax</title>
            <para>
            <blockquote><literallayout class="monospaced">
0{x|X}<replaceable>&lt;hexdigits&gt;</replaceable>

  <replaceable>&lt;hexdigits&gt;</replaceable>  ::=  1-16 of <replaceable>&lt;hexdigit&gt;</replaceable>
  <replaceable>&lt;hexdigit&gt;</replaceable>   ::=  one of 0..9, A..F, a..f
            </literallayout></blockquote>
            </para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para>
            <blockquote><programlisting>
select 0x6FAA0D3 from rdb$database           -- returns 117088467
select 0x4F9 from rdb$database               -- returns 1273
select 0x6E44F9A8 from rdb$database          -- returns 1850014120
select 0x9E44F9A8 from rdb$database          -- returns -1639646808 (an INTEGER)
select 0x09E44F9A8 from rdb$database         -- returns 2655320488 (a BIGINT)
select 0x28ED678A4C987 from rdb$database     -- returns 720001751632263
select 0xFFFFFFFFFFFFFFFF from rdb$database  -- returns -1
            </programlisting></blockquote>
            </para>
          </formalpara>
          <section id="fblangref25-commons-hexranges">
            <title>Hexadecimal Value Ranges</title>
            <itemizedlist>
              <listitem><para>
              Hex numbers in the range 0 .. 7FFF FFFF are positive INTEGERs with values between
              0 .. 2147483647 decimal. To coerce a number to BIGINT,  prepend enough zeroes to bring the
              total number of hex digits to nine or above.  That changes the type but not the value.</para></listitem>

              <listitem>
                <para>Hex numbers between 8000 0000 .. FFFF FFFF require some attention:</para>
                <itemizedlist mark="circle">
                  <listitem><para>When written with eight hex digits, as in 0x9E44F9A8, a value is interpreted as
                  32-bit INTEGER. Since the leftmost bit (sign bit) is set, it maps to the negative range
                  -2147483648 .. -1 decimal.</para></listitem>
                  <listitem><para>With one or more zeroes prepended, as in 0x09E44F9A8, a value is interpreted
                  as 64-bit BIGINT in the range 0000 0000 8000 0000 .. 0000 0000 FFFF FFFF. The sign bit
                  is not set now, so they map to the positive range 2147483648 .. 4294967295 decimal.</para>
                  </listitem>
                </itemizedlist>
              <para>Thus, in this range&#x2014;and only in this range&#x2014;prepending a mathematically
              insignificant 0 results in a totally different value. This is something to be aware of.
              </para>
              </listitem>
              <listitem><para>Hex numbers between 1 0000 0000 .. 7FFF FFFF FFFF FFFF are all positive
              BIGINT.</para></listitem>
              <listitem><para>Hex numbers between 8000 0000 0000 0000 .. FFFF FFFF FFFF FFFF are all
              negative BIGINT.</para></listitem>
              <listitem>
                <para>A SMALLINT cannot be written in hex, strictly speaking, since even 0x1 is evaluated
                as INTEGER.  However, if you write a positive integer within the 16-bit range 0x0000
                (decimal zero) to 0x7FFF (decimal 32767) it will be converted to SMALLINT transparently.</para>

                <para>It is possible to write to a negative SMALLINT in hex, using a 4-byte hex number within the
                range 0xFFFF8000 (decimal -32768) to 0xFFFFFFFF (decimal -1).</para>
              </listitem>
            </itemizedlist>
          </section><!-- hexranges -->
        </section><!-- hexnumbers -->
      </section><!-- number constant -->
    </section><!-- constants -->

    <section id="fblangref25-commons-sqloperators">
      <title>SQL Operators</title>
      <para>SQL operators comprise operators for comparing, calculating, evaluating and concatenating values.</para>

      <section id="fblangref25-commons-operpreced">
        <title>Operator Precedence</title>
        <para>SQL Operators are divided into four types. Each operator type has a <emphasis>precedence</emphasis>,
        a ranking that determines the order in which operators and the values obtained with their help
        are evaluated in an expression.The higher the precedence of the operator type is, the earlier it will be evaluated.
        Each operator has its own precedence within its type, that determines the order in which they are evaluated in an
        expression.</para>
        <para>Operators with the same precedence are evaluated from left to right. To force a different evaluation order,
        operations can be grouped by means of parentheses.</para>

        <table id="fblangref25-dtyp-tbl-operpreced">
        <?dbfo keep-together='auto'?>
          <title>Operator Type Precedence</title>
          <tgroup cols="3">
            <colspec colname="col01" colwidth="1*"></colspec>
            <colspec colname="col02" colwidth="1*"></colspec>
            <colspec colname="col03" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Operator Type</entry>
                <entry align="center">Precedence</entry>
                <entry align="center">Explanation</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">Concatenation</entry>
                <entry align="center">1</entry>
                <entry align="left">Strings are concatenated before any other operations take place</entry>
              </row>
              <row valign="middle">
                <entry align="center">Arithmetic</entry>
                <entry align="center">2</entry>
                <entry align="left">Arithmetic operations are performed after strings are concatenated,
                but before comparison and logical operations</entry>
              </row>
              <row valign="middle">
                <entry align="center">Comparison</entry>
                <entry align="center">3</entry>
                <entry align="left">Comparison operations take place after string concatenation and
                arithmetic operations, but before logical operations</entry>
              </row>
              <row valign="middle">
                <entry align="center">Logical</entry>
                <entry align="center">4</entry>
                <entry align="left">Logical operators are executed after all other types of operators</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <section id="fblangref25-commons-concat">
          <title>Concatenation Operator</title>
          <para>The concatenation operator, two pipe characters known as <quote>double
          pipe</quote>&#x2014;<command> || </command>&#x2014; concatenates (connects together) two character
          strings to form a single string. Character strings can be constants or values obtained from columns
          or other expressions.</para>
          <formalpara><title>Example</title>
            <para>
            <programlisting>
       SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
       FROM EMPLOYEE
            </programlisting>
            </para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-arith">
          <title>Arithmetic Operators</title>
          <table id="fblangref25-dtyp-tbl-arithpreced">
          <?dbfo keep-together='auto'?>
            <title>Arithmetic Operator Precedence</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Purpose</entry>
                  <entry align="center">Precedence</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>+ <replaceable>signed_number</replaceable></command></entry>
                  <entry align="center">Unary plus</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>- <replaceable>signed_number</replaceable></command></entry>
                  <entry align="center">Unary minus</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>*</command></entry>
                  <entry align="center">Multiplication</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>/</command></entry>
                  <entry align="center">Division</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>+</command></entry>
                  <entry align="center">Addition</entry>
                  <entry align="center">3</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>-</command></entry>
                  <entry align="center">Subtraction</entry>
                  <entry align="center">3</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <formalpara>
            <title>Example</title>
            <para>
            <programlisting>
       UPDATE T
         SET A = 4 + 1/(B-C)*D
            </programlisting>
            </para>
          </formalpara>
          <note>
            <para>Where operators have the same precedence, they are evaluated in
            left-to-right sequence.</para>
          </note>
        </section><!-- Arithmetic operators -->

        <section id="fblangref25-commons-compar">
          <title>Comparison Operators</title>
          <table id="fblangref25-dtyp-tbl-comparpreced">
          <?dbfo keep-together='auto'?>
            <title>Comparison Operator Precedence</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Purpose</entry>
                  <entry align="center">Precedence</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>=</command></entry>
                  <entry align="center">Is equal to, is identical to</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;&gt;, !=, ~=, ^=</command></entry>
                  <entry align="center">Is not equal to</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&gt;</command></entry>
                  <entry align="center">Is greater than</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;</command></entry>
                  <entry align="center">Is less than</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&gt;=</command></entry>
                  <entry align="center">Is greater than or equal to</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;=</command></entry>
                  <entry align="center">Is less than or equal to</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>!&gt;, ~&gt;, ^&gt;</command></entry>
                  <entry align="center">Is not greater than</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>!&lt;, ~&lt;, ^&lt;</command></entry>
                  <entry align="center">Is not less than</entry>
                  <entry align="center">1</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>This group also includes comparison predicates <database>BETWEEN, LIKE,
          CONTAINING, SIMILAR TO, IS</database> and others.</para>
          <formalpara><title>Example</title>
            <para>
            <programlisting>
       IF (SALARY &gt; 1400) THEN
       &#x2026;
            </programlisting>
            </para>
          </formalpara>
          <formalpara><title>See also</title>
             <para><link linkend="fblangref25-commons-othercomppreds">Other Comparison Predicates</link>.</para>
          </formalpara>
        </section> <!-- Comparison operators -->

        <section id="fblangref25-commons-logical">
          <title>Logical Operators</title>
          <table id="fblangref25-dtyp-tbl-logical">
          <?dbfo keep-together='auto'?>
            <title>Logical Operator Precedence</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Purpose</entry>
                  <entry align="center">Precedence</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>NOT</command></entry>
                  <entry align="center">Negation of a search condition</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>AND</command></entry>
                  <entry align="center">Combines two or more predicates, each of which must
                  be true for the entire predicate to be true</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>OR</command></entry>
                  <entry align="center">Combines two or more predicates, of which at least one
                  predicate must be true for the entire predicate to be true</entry>
                  <entry align="center">3</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <formalpara>
            <title>Example</title>
            <para>
            <programlisting>
       IF (A &lt; B OR (A &gt; C AND A &gt; D) AND NOT (C = D)) THEN &#x2026;
            </programlisting>
            </para>
          </formalpara>
        </section> <!-- Logical operators -->
      </section> <!-- Operator precedence -->

      <section id="fblangref25-commons-conditional-nxtvlufor">
        <title><database>NEXT VALUE FOR</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <para><database>NEXT VALUE FOR</database> returns the next value of a sequence.
        <database>SEQUENCE</database> is an SQL-compliant term for a generator in Firebird
        and its ancestor, InterBase. The <database>NEXT VALUE FOR</database> operator is
        equivalent to the legacy <database>GEN_ID (..., 1)</database> function and is the
        recommended syntax for retrieving the next sequence value.</para>
        <formalpara>
          <title>Syntax for NEXT VALUE FOR</title>
          <para>
          <programlisting>
       NEXT VALUE FOR <replaceable>sequence-name</replaceable>
          </programlisting>
          </para>
        </formalpara>

        <formalpara>
          <title>Example</title>
          <para>
          <programlisting>
       NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
          </programlisting>
          </para>
        </formalpara>

        <note>
          <para>Unlike <database>GEN_ID (..., 1)</database>, the <database>NEXT VALUE FOR</database>
          variant does not take any parameters and thus, provides no way to retrieve the
          <emphasis>current value</emphasis> of a sequence, nor to step the next value by
          more than 1.  <database>GEN_ID (..., &lt;step value&gt;)</database> is still needed for
          these tasks.  A &lt;step value&gt; of 0 returns the current sequence value.</para>
        </note>

        <formalpara>
          <title>See also</title>
          <para>&nbsp;<link linkend="fblangref25-ddl-sequence">SEQUENCE (GENERATOR)</link>,
          <link linkend="fblangref25-functions-scalarfuncs-gen_id"><database>GEN_ID()</database></link>
          </para>
        </formalpara>
      </section><!-- NEXT VALUE FOR -->
    </section> <!-- Operators -->

    <section id="fblangref25-commons-conditional">
      <title>Conditional Expressions</title>
      <para>A conditional expression is one that returns different values according to how a
      certain condition is met.  It is composed by applying a conditional function construct,
      of which Firebird supports several.  This section describes only one conditional expression
      construct: <database>CASE</database>. All other conditional expressions apply internal
      functions derived from <database>CASE</database> and are described in 
      <link linkend="fblangref25-functions-conditional">Conditional Functions</link>.</para>

      <section id="fblangref25-commons-conditional-case">
        <title><database>CASE</database></title>
        <formalpara>
          <title>Available</title><para> DSQL, PSQL</para>
        </formalpara>
        <para>The <database>CASE</database> construct returns a single value from a number of
        possible ones. Two syntactic variants are supported:
          <itemizedlist>
            <listitem><para>The <emphasis>simple</emphasis>&nbsp;<database>CASE</database>, comparable
            to a <firstterm>case construct</firstterm> in Pascal or a <firstterm>switch</firstterm> in C</para></listitem>
            <listitem><para>The <emphasis>searched</emphasis>&nbsp;<database>CASE</database>, which works like a series
            of &nbsp;<quote><function>if ... else if ... else if</function></quote> &nbsp;clauses.</para></listitem>
          </itemizedlist>
        </para>

        <section id="fblangref25-commons-conditional-case-simple">
          <title>Simple <database>CASE</database></title>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       &#x2026;
       CASE &lt;test-expr&gt;
         WHEN &lt;expr> THEN &lt;result&gt;
         [WHEN &lt;expr> THEN &lt;result&gt; ...]
         [ELSE &lt;defaultresult&gt;]
       END
       &#x2026;
            </programlisting>
            </para>
          </formalpara>
          <para>When this variant is used, <function> &lt;test-expr&gt; </function> is compared to
          &lt;expr&gt; 1, &lt;exp&gt; 2 etc., until a match is found and the corresponding
          result is returned. If no match is found, &lt;defaultresult&gt; from the optional
          <database>ELSE</database> clause is returned. If there are no matches and no
          <database>ELSE</database> clause, <database>NULL</database> is returned.</para>
          <para>The matching works identically to the &quot;=&quot; operator.  That is,
          if &lt;test-expr&gt; is <database>NULL</database>, it does not match any
          &lt;expr&gt;, not even an expression that resolves to <database>NULL</database>.</para>
          <para>The returned result does not have to be a literal value: it might be a field
          or variable name, compound expression or <database>NULL</database> literal.</para>
            <formalpara>
              <title>Example</title>
              <para>
              <programlisting>
  SELECT
    NAME,
    AGE,
    CASE UPPER(SEX)
      WHEN 'M' THEN 'Male'
      WHEN 'F' THEN 'Female'
      ELSE 'Unknown'
    END GENDER,
	RELIGION
      FROM PEOPLE
              </programlisting>
              </para>
            </formalpara>
          <para>A short form of the simple <database>CASE</database> construct is used in
          the <link linkend="fblangref25-functions-scalarfuncs-decode"><database>DECODE</database></link> 
          function.</para>
        </section> <!-- Simple CASE -->

        <section id="fblangref25-commons-conditional-case-srched">
          <title>Searched <database>CASE</database></title>
          <formalpara>
            <title>Syntax</title>
            <para>
            <programlisting>
       CASE
         WHEN &lt;bool_expr&gt; THEN &lt;result&gt;
         [WHEN &lt;bool_expr&gt; THEN &lt;result&gt; &#x2026;]
         [ELSE &lt;defaultresult&gt;]
       END
            </programlisting>
            </para>
          </formalpara>
          <para>The &lt;bool_expr&gt; expression is one that gives a ternary logical result:
          <database>TRUE, FALSE</database> or <database>NULL</database>. The first expression
          to return <database>TRUE</database> determines the result. If no expressions return
          <database>TRUE</database>, &lt;defaultresult&gt; from the optional <database>ELSE</database>
          clause is returned as the result. If no expressions return <database>TRUE</database>
          and there is no <database>ELSE</database> clause, the result will
          be <database>NULL</database>.</para>
          <para>As with the simple <database>CASE</database> construct, the result need not
          be a literal value: it might be a field or variable name, a compound expression, or
          be <database>NULL</database>.</para>
          <formalpara>
            <title>Example</title>
            <para>
            <programlisting>
       CANVOTE = CASE
         WHEN AGE &gt;= 18 THEN 'Yes'
         WHEN AGE &lt; 18 THEN 'No'
         ELSE 'Unsure'
       END
            </programlisting>
            </para>
          </formalpara>
        </section> <!-- Searched CASE -->
      </section><!-- CASE -->
    </section> <!-- Conditional Expressions -->

    <section id="fblangref25-commons-null-in-expr">
      <title><database>NULL</database> in Expressions</title>
      <para><database>NULL</database> is not a value in SQL, but a <emphasis>state</emphasis>
      indicating that the value of the element either <emphasis>unknown</emphasis> or it does
      not exist. It is not a zero, nor a void, nor an <quote>empty string</quote>, and it does
      not act like any value.</para>
      <para>When you use <database>NULL</database> in numeric, string or date/time expressions,
      the result will always be <database>NULL</database>. When you use <database>NULL</database>
      in logical (Boolean) expressions, the result will depend on the type of the operation and
      on other participating values. When you compare a value to <database>NULL</database>, the
      result will be <emphasis>unknown</emphasis>.</para>
      <important>
        <title>Important to Note</title>
        <para><database>NULL</database> means <database>NULL</database> but,
        in Firebird, the logical result <emphasis>unknown</emphasis> is also <emphasis>represented
        by</emphasis> <database>NULL</database>.</para>
      </important>

      <section id="fblangref25-commons-returningnull">
        <title>Expressions Returning <database>NULL</database></title>
        <para>Expressions in this list will always return <database>NULL</database>:
          <literallayout class="monospaced">
       1 + 2 + 3 + NULL
       'Home ' || 'sweet ' || NULL
       MyField = NULL
       MyField &lt;&gt; NULL
       NULL = NULL
       not (NULL)
          </literallayout>
        If it seems difficult to understand why, remember that NULL is a state that stands for
        <quote>unknown</quote>.
        </para>
      </section>

      <section id="fblangref25-commons-nullinlogical">
        <title><database>NULL</database> in Logical Expressions</title>
        <para>It has already been shown that <function> not (NULL) </function> results in
        <database>NULL</database>. The interaction is a bit more complicated for the logical
        <database>AND</database> and logical <database>OR</database> operators:
          <literallayout class="monospaced">
       NULL or false = NULL
       NULL or true = true
       NULL or NULL = NULL
       NULL and false = false
       NULL and true = NULL
       NULL and NULL = NULL
          </literallayout>
        </para>
        <para>Up to and including Firebird 2.5.x, there is no implementation for a logical (Boolean)
        data type&#x2014;that is coming in Firebird 3. However, there are logical expressions (predicates)
          that can return true, false or unknown.</para>
          <formalpara>
            <title>Examples</title>
            <para>
            <literallayout class="monospaced">
       (1 = NULL) or (1 &lt;&gt; 1) -- returns NULL
       (1 = NULL) or (1 = 1) -- returns TRUE
       (1 = NULL) or (1 = NULL) -- returns NULL
       (1 = NULL) and (1 &lt;&gt; 1) -- returns FALSE
       (1 = NULL) and (1 = 1) -- returns NULL
       (1 = NULL) and (1 = NULL) -- returns NULL
            </literallayout>
            </para>
          </formalpara>
      </section>
    </section> <!-- NULL in expressions -->

    <section id="fblangref25-commons-subqueries">
      <title>Subqueries</title>
      <para>A subquery is a special form of expression that is actually a query embedded within 
      another query. Subqueries are written in the same way as regular
      <database>SELECT</database> queries, but they must be enclosed in parentheses. Subquery
      expressions can be used in the following ways:
        <itemizedlist>
          <listitem><para>To specify an output column in the SELECT list</para></listitem>
          <listitem><para>To obtain values or conditions for search predicates (the
          <database>WHERE</database>, <database>HAVING</database> clauses).</para></listitem>
          <listitem><para>To produce a set that the enclosing query can select from, as though were a
          regular table or view. Subqueries like this appear in the FROM clause (derived tables) 
          or in a Common Table Expression (CTE)</para></listitem>
        </itemizedlist>
      </para>
      <section id="fblangref25-commons-correlatedsq">
        <title>Correlated Subqueries</title>
        <para>A subquery can be <emphasis>correlated</emphasis>. A query is correlated when the subquery
        and the main query are interdependent. To process each record in the subquery, it is necessary
        to fetch a record in the main query; i.e., the subquery fully depends on the main query.</para>
        <formalpara>
          <title>Sample Correlated Subquery</title>
          <para>
          <programlisting>
       SELECT *
       FROM Customers C
       WHERE EXISTS
             (SELECT *
              FROM Orders O
              WHERE C.cnum = O.cnum
                AND O.adate = DATE '10.03.1990');
          </programlisting>
          </para>
        </formalpara>

        <para>When subqueries are used to get the values of the output column in the SELECT list,
        a subquery must return a <emphasis>scalar</emphasis> result.</para>
      </section>

      <section id="fblangref25-commons-scalarsq">
        <title>Scalar Results</title>
        <para>Subqueries used in search predicates, other than existential and quantified
        predicates, must return a <emphasis>scalar</emphasis> result;  that is, not more than one column from
        not more than one matching row or aggregation.  If the result would return more, a run-time error will
        occur (<quote>Multiple rows in a singleton select...</quote>).</para>
        <note>
          <para>Although it is reporting a genuine error, the message can be slightly misleading.
          A <quote>singleton SELECT</quote> is a query that must not be capable of returning more than one row.
          However, <quote>singleton</quote> and <quote>scalar</quote> are not synonymous:  not all singleton
          SELECTS are required to be scalar; and single-column selects can return multiple rows for existential
          and quantified predicates.</para>
        </note>

        <formalpara>
          <title>Subquery Examples</title>
          <para>
          <orderedlist>
            <listitem><para>A subquery as the output column in a <database>SELECT</database> list:</para>
              <programlisting>
       SELECT
           e.first_name,
           e.last_name,
           (SELECT
                sh.new_salary
            FROM
                salary_history sh
            WHERE
                sh.emp_no = e.emp_no
            ORDER BY sh.change_date DESC ROWS 1) AS last_salary
       FROM
            employee e
              </programlisting>
            </listitem>
            <listitem><para>A subquery in the <database>WHERE</database> clause for obtaining the
            employee's maximum salary and filtering by it:</para>
              <programlisting>
       SELECT
           e.first_name,
           e.last_name,
           e.salary
       FROM
           employee e
       WHERE
           e.salary = (
                       SELECT MAX(ie.salary)
                       FROM employee ie
                       )
              </programlisting>
            </listitem>
          </orderedlist>
          </para>
        </formalpara>
      </section>
    </section> <!-- Subqueries -->
  </section> <!-- Expressions -->

<!-- ============================================================== -->
  <section id="fblangref25-commons-predicates">
    <title>Predicates</title>
    <para>A predicate is a simple expression asserting some fact, let's call it <varname>P</varname>. 
    If <varname>P</varname> resolves as TRUE, it succeeds.  If it resolves to FALSE or NULL (UNKNOWN), 
    it fails. A trap lies here, though:  suppose the predicate, <varname>P</varname>, returns FALSE.  
    In this case NOT(<varname>P</varname>) will return TRUE. On the other hand, if <varname>P</varname> 
    returns NULL (unknown), then NOT(<varname>P</varname>) returns NULL as well.</para>

    <para>In SQL, predicates can appear in <database>CHECK</database> constraints, <database>WHERE</database> 
    and <database>HAVING</database> clauses, <database>CASE</database> expressions, the <database>IIF()</database> 
    function and in the <database>ON</database> condition of <database>JOIN</database> clauses.</para>

    <section id="fblangref25-commons-assertions">
      <title>Assertions</title>
      <para>An assertion is a statement about the data that, like a predicate, can resolve to TRUE, 
      FALSE or NULL.  Assertions consist of one or more predicates, possibly negated using NOT and 
      connected by AND and OR operators. Parentheses may be used for grouping predicates and 
      controlling evaluation order.</para>

      <para>A predicate may embed other predicates. Evaluation sequence is in the outward
      direction, i.e., the innermost predicates are evaluated first.  Each <quote>level</quote> is
      evaluated in precedence order until the truth of the ultimate assertion is resolved.</para>
    </section>

    <section id="fblangref25-commons-comppreds">
      <title>Comparison Predicates</title>
      <para>A comparison predicate consists of two expressions connected with a comparison operator.
      There are six traditional comparison operators:
        <literallayout>
       <command>=</command>, <command>&gt;</command>, <command>&lt;</command>, <command>&gt;=</command>, <command>&lt;=</command>, <command>&lt;&gt;</command>
        </literallayout>
      (For the complete list of comparison operators with their variant forms, see
      <link linkend= "fblangref25-commons-compar">Comparison Operators</link>.)
      </para>

      <para>If one of the sides (left or right) of a comparison predicate has <database>NULL</database>
      in it, the value of the predicate will be UNKNOWN.</para>

      <formalpara>
        <title>Examples</title>
        <para>
        <orderedlist>
          <listitem><para>Retrieve information about computers with the CPU frequency not less than
          500 MHz and the price lower than $800:</para>
            <programlisting>
       SELECT *
       FROM Pc
       WHERE speed &gt;= 500 AND price &lt; 800;
            </programlisting>
          </listitem>
          <listitem><para>Retrieve information about all dot matrix printers that cost less than $300:</para>
             <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype = 'matrix' AND price &lt; 300;
            </programlisting>
          </listitem>
          <listitem><para>The following query will return no data, even if there are printers with no
          type specified for them, because a predicate that compares <database>NULL</database> with 
          <database>NULL</database> returns <database>NULL</database>:</para>
            <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype = NULL AND price &lt; 300;
            </programlisting>
            <para>On the other hand, <replaceable>ptrtype</replaceable> can be tested for <database>NULL</database>
              and return a result:  it is just that it is not a <emphasis>comparison</emphasis> test:</para>
            <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype IS NULL AND price &lt; 300;
            </programlisting>
            <para>&#x2014;see <link linkend="fblangref25-commons-isnotnull"><database>IS [NOT] NULL</database></link>.</para>
          </listitem>
        </orderedlist>
        </para>
      </formalpara>
      
      <note>
        <title>Note about String Comparison</title>
        <para>When <database>CHAR</database> and <database>VARCHAR</database> fields are compared for 
        equality, trailing spaces are ignored in all cases.</para>
      </note>

      <section id="fblangref25-commons-othercomppreds">
        <title>Other Comparison Predicates</title>
        <para>Other comparison predicates are marked by keyword symbols.</para>
        <section id="fblangref25-commons-predbetween">
          <title><database>BETWEEN</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       &lt;value&gt; [NOT] BETWEEN &lt;value_1&gt; AND &lt;value_2&gt;
            </programlisting>
            </para>
          </formalpara>
          <para>The <database>BETWEEN</database> predicate tests whether a value falls within
          a specified range of two values. (<database>NOT BETWEEN</database> tests whether the value
          does not fall within that range.)</para>
          <para>The operands for <database>BETWEEN</database> predicate are two arguments of
          compatible data types. Unlike in some other DBMS, the <database>BETWEEN</database>
          predicate in Firebird is not symmetrical&#x2014;if the lower value is not the first
          argument, the <database>BETWEEN</database> predicate will always return False.
          The search is inclusive (the values represented by both arguments are included in
          the search). In other words, the <database>BETWEEN</database> predicate could be
          rewritten:
            <literallayout class="monospaced">
       &lt;value&gt; &gt;= &lt;value_1&gt; AND &lt;value&gt; &lt;= &lt;value_2&gt;
            </literallayout>
          </para>
          <para>When <database>BETWEEN</database> is used in the search conditions of DML queries,
          the Firebird optimizer can use an index on the searched column, if it is available.</para>
          <formalpara><title>Example</title>
            <para>
            <programlisting>
       SELECT *
       FROM EMPLOYEE
       WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
            </programlisting>
            </para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predlike">
          <title><database>LIKE</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       &lt;match value&gt; [NOT] LIKE &lt;pattern&gt;
          [ESCAPE &lt;escape character&gt;]

       &lt;match value&gt; ::= <replaceable>character-type expression</replaceable>

       &lt;pattern&gt; ::= <replaceable>search pattern</replaceable>

       &lt;escape character&gt; ::= <replaceable>escape character</replaceable>
            </programlisting>
            </para>
          </formalpara>
          <para>The <database>LIKE</database> predicate compares the character-type expression with
          the pattern defined in the second expression. Case- or accent-sensitivity for the comparison
          is determined by the collation that is in use.  A collation can be specified for either
          operand, if required.</para>

          <section id="fblangref25-commons-wildcards">
          <title>Wildcards</title>
          <para>Two wildcard symbols are available for use in the search pattern:
            <itemizedlist>
              <listitem><para>the percentage symbol (%) will match any sequence of zero or more
              characters in the tested value</para></listitem>
              <listitem><para>the underscore character (_) will match any single character
              in the tested value</para></listitem>
            </itemizedlist>
          </para>
          <para>If the tested value matches the pattern, taking into account wildcard symbols, the
          predicate is True.</para>
        </section>

        <section id="fblangref25-commons-escapechar">
          <title>Using the <database>ESCAPE</database> Character Option</title>
          <para>If the search string contains either of the wildcard symbols, the <database>ESCAPE</database>
          clause can be used to specify an escape character.  The escape character must precede the '%' or '_'
          symbol in the search string, to indicate that the symbol is to be interpreted as a
          literal character.</para>
        </section>

        <section>
          <title>Examples using <database>LIKE</database></title>
            <orderedlist>
              <listitem><para>Find the numbers of departments whose names start with the
              word <quote>Software</quote>:</para>
                <programlisting>
       SELECT DEPT_NO
       FROM DEPT
       WHERE DEPT_NAME LIKE 'Software%';
                </programlisting>
                <para>It is possible to use an index on the DEPT_NAME field if it exists.</para>
                <note>
                  <title>About <database>LIKE</database> and the Optimizer</title>
                  <para>Actually, the <database>LIKE</database> predicate does not use an index. However,
                  if the predicate takes the form of <function> LIKE 'string%' </function>, it will be
                  converted to the <database>STARTING WITH</database> predicate, which will use an index.</para>
                  <para>So&#x2014;if you need to search for the beginning of a string, it is recommended to use the
                  STARTING WITH predicate instead of the LIKE predicate.</para>
                </note>
              </listitem>
              <listitem><para>Search for employees whose names consist of 5 letters, start with the letters <quote>Sm</quote>
              and end with <quote>th</quote>. The predicate will be true for such names as <quote>Smith</quote> and
              <quote>Smyth</quote>.</para>
                <programlisting>
       SELECT
           first_name
       FROM
           employee
       WHERE first_name LIKE 'Sm_th'
                </programlisting>
              </listitem>
              <listitem><para>Search for all clients whose address contains the string <quote>Rostov</quote>:</para>
                <programlisting>
       SELECT *
       FROM CUSTOMER
       WHERE ADDRESS LIKE '%Rostov%'
                </programlisting>
                <note>
                  <para>If you need to do a case-insensitive search for something <emphasis>enclosed
                  inside</emphasis> a string (<function> LIKE '%Abc%' </function>), use of
                  the <database>CONTAINING</database> predicate is recommended, in preference to
                  the <database>LIKE</database> predicate.</para>
                </note>
              </listitem>
              <listitem><para>Search for tables containing the underscore character in their names. The <quote>#</quote>
              character is specified as the escape character:</para>
                <programlisting>
       SELECT
         RDB$RELATION_NAME
       FROM RDB$RELATIONS
       WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
                </programlisting>
              </listitem>
            </orderedlist>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-predstartwith"><database>STARTING WITH</database></link>,
              <link linkend="fblangref25-commons-predcontaining"><database>CONTAINING</database></link>,
              <link linkend="fblangref25-commons-predsiimilarto"><database>SIMILAR TO</database></link>
            </para>
          </formalpara>
        </section>
        </section>

        <section id="fblangref25-commons-predstartwith">
          <title><database>STARTING WITH</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       &lt;value&gt; [NOT] STARTING WITH &lt;value&gt;
            </programlisting>
            </para>
          </formalpara>
          <para>The <database>STARTING WITH</database> predicate searches for a string
          or a string-like type that starts with the characters in its &lt;value&gt; argument.
          The search is case-sensitive.</para>
          <para>When <database>STARTING WITH</database> is used in the search conditions of
          DML queries, the Firebird optimizer can use an index on the searched column,
          if it exists.</para>
          <formalpara><title>Example</title>
            <para>Search for employees whose last names start with <quote>Jo</quote>:
              <programlisting>
       SELECT LAST_NAME, FIRST_NAME
       FROM EMPLOYEE
       WHERE LAST_NAME STARTING WITH 'Jo'
              </programlisting>
            </para>
          </formalpara>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-predlike"><database>LIKE</database></link></para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predcontaining">
          <title><database>CONTAINING</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       &lt;value&gt; [NOT] CONTAINING &lt;value&gt;
            </programlisting>
            </para>
          </formalpara>
          <para>The <database>CONTAINING</database> predicate searches for a string or a string-like
          type looking for the sequence of characters that matches its argument. It can be used for
          an alphanumeric (string-like) search on numbers and dates. A <database>CONTAINING</database>
          search is not case-sensitive.  However, if an accent-sensitive collation is in use then
          the search will be accent-sensitive.</para>
          <para>When <database>CONTAINING</database> is used in the search conditions of DML queries,
          the Firebird optimizer can use an index on the searched column, if a suitable one exists.</para>
          <formalpara><title>Examples</title>
            <para>
            <orderedlist>
              <listitem><para>Search for projects whose names contain the substring <quote>Map</quote>:</para>
                <programlisting>
       SELECT *
       FROM PROJECT
       WHERE PROJ_NAME CONTAINING 'Map';
                </programlisting>
                <para>Two rows with the names <quote>AutoMap</quote> and <quote>MapBrowser port</quote> are
                  returned.</para></listitem>
              <listitem><para>Search for changes in salaries with the date containing number 84 (in this
              case, it means changes that took place in 1984):</para>
                <programlisting>
       SELECT *
       FROM SALARY_HISTORY
       WHERE CHANGE_DATE CONTAINING 84;
                </programlisting>
              </listitem>
             </orderedlist>
            </para>
          </formalpara>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-predlike"><database>LIKE</database></link></para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predsiimilarto">
          <title><database>SIMILAR TO</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       <replaceable>string-expression</replaceable> [NOT] SIMILAR TO &lt;pattern&gt; [ESCAPE &lt;escape-char&gt;]
       &lt;pattern&gt; ::= an SQL regular expression
       &lt;escape-char&gt; ::= a single character
            </programlisting>
            </para>
          </formalpara>
          <para>SIMILAR TO matches a string against an SQL regular expression pattern.
          Unlike in some other languages, the pattern must match the entire string in
          order to succeed&#x2014;matching a substring is not enough. If any operand is
          <database>NULL</database>, the result is <database>NULL</database>. Otherwise,
          the result is <database>TRUE</database> or <database>FALSE</database>.</para>

          <section id="fblangref25-commons-syntaxregex">
            <title>Syntax: SQL Regular Expressions</title>
            <para>The following syntax defines the SQL regular expression format. It is a
            complete and correct top-down definition. It is also highly formal, rather
            long and probably perfectly fit to discourage everybody who hasn't already
            some experience with regular expessions (or with highly formal, rather long
            top-down definitions). Feel free to skip it and read the next section,
            <link linkend="fblangref25-commons-buildregex">Building Regular Expressions</link>, which uses a
            bottom-up approach, aimed at the rest of us.</para>
            <programlisting>
  &lt;regular expression&gt; ::= &lt;regular term&gt; ['|' &lt;regular term&gt; ...]

  &lt;regular term&gt; ::= &lt;regular factor&gt; ...

  &lt;regular factor&gt; ::= &lt;regular primary&gt; [&lt;quantifier&gt;]

  &lt;quantifier&gt; ::= ?
               | *
               | +
               | '{' &lt;m&gt; [,[&lt;n&gt;]] '}'

  &lt;m&gt;, &lt;n&gt; ::= unsigned int, with &lt;m&gt; &lt;= &lt;n&gt; if both present

  &lt;regular primary&gt; ::= &lt;character&gt;
                    | &lt;character class&gt;
                    | %
                    | (&lt;regular expression&gt;)

  &lt;character&gt; ::= &lt;escaped character&gt;
              | &lt;non-escaped character&gt;

  &lt;escaped character&gt; ::= &lt;escape-char&gt; &lt;special character&gt;
                      | &lt;escape-char&gt; &lt;escape-char&gt;

  &lt;special character&gt; ::= any of the characters []()|^-+*%_?{

  &lt;non-escaped character&gt; ::= any character that is not a &lt;special character&gt;
                            and not equal to &lt;escape-char&gt; (if defined)
  &lt;character class&gt; ::= '_'
                    | '[' &lt;member&gt; ... ']'
                    | '[^' &lt;non-member&gt; ... ']'
                    | '[' &lt;member&gt; ... '^' &lt;non-member&gt; ... ']'

  &lt;member&gt;, &lt;non-member&gt; ::= &lt;character&gt;
                         | &lt;range&gt;
                         | &lt;predefined class&gt;

  &lt;range&gt; ::= &lt;character&gt;-&lt;character&gt;

  &lt;predefined class&gt; ::= '[:' &lt;predefined class name&gt; ':]'

  &lt;predefined class name&gt; ::= ALPHA | UPPER | LOWER | DIGIT
                             | ALNUM | SPACE | WHITESPACE

            </programlisting>
          </section>
          <section id="fblangref25-commons-buildregex">
            <title>Building Regular Expressions</title>
            <para>In this section are the elements and rules for building
            SQL regular expressions.</para>
            <section id="fblangref25-commons-regexchar">
              <title>Characters</title>
              <para>Within regular expressions, most characters represent themselves.
              The only exceptions are the special characters below:
                <literallayout><command>
       [ ] ( ) | ^ - + * % _ ? { }
                </command></literallayout>
              ...and the escape character, if it is defined.</para>
              <para>A regular expression that contains no special or escape characters matches only
              strings that are identical to itself (subject to the collation in use). That is,
              it functions just like the <quote><command>=</command></quote> operator:
                <programlisting>
       'Apple' similar to 'Apple'  -- true
       'Apples' similar to 'Apple' -- false
       'Apple' similar to 'Apples' -- false
       'APPLE' similar to 'Apple'  -- depends on collation
                </programlisting>
              </para>
            </section><!-- regex characters -->

            <section id="fblangref25-commons-regexwildcards">
              <title>Wildcards</title>
              <para>The known SQL wildcards <command>_</command> and <command>%</command> match
              any single character and a string of any length, respectively:
                <programlisting>
       'Birne' similar to 'B_rne'   -- true
       'Birne' similar to 'B_ne'    -- false
       'Birne' similar to 'B%ne'    -- true
       'Birne' similar to 'Bir%ne%' -- true
       'Birne' similar to 'Birr%ne' -- false
                </programlisting>
              Notice how % also matches the empty string.</para>
            </section> <!-- regex wildcards -->

            <section id="fblangref25-commons-regexcharclass">
              <title>Character Classes</title>
              <para>A bunch of characters enclosed in brackets define a character class. A character
              in the string matches a class in the pattern if the character is a member of the class:
                <programlisting>
       'Citroen' similar to 'Cit[arju]oen'     -- true
       'Citroen' similar to 'Ci[tr]oen'        -- false
       'Citroen' similar to 'Ci[tr][tr]oen'    -- true
                </programlisting>
              As can be seen from the second line, the class only matches a single character,
              not a sequence.</para>
              <para>Within a class definition, two characters connected by a hyphen define a range.
              A range comprises the two endpoints and all the characters that lie between them in the
              active collation. Ranges can be placed anywhere in the class definition without special
              delimiters to keep them apart from the other elements.
                <programlisting>
       'Datte' similar to 'Dat[q-u]e'          -- true
       'Datte' similar to 'Dat[abq-uy]e'       -- true
       'Datte' similar to 'Dat[bcg-km-pwz]e'   -- false
                </programlisting>
              </para>

              <section id="fblangref25-commons-regexpredefclass">
                <title>Predefined Character Classes</title>
                <para>The following predefined character classes can also be used in a class definition:</para>
                  <formalpara><title>[:ALPHA:]</title>
                    <para>Latin letters a..z and A..Z. With an accent-insensitive collation, this class
                    also matches accented forms of these characters.</para>
                  </formalpara>

                  <formalpara><title>[:DIGIT:]</title>
                    <para>Decimal digits 0..9.</para>
                  </formalpara>

                  <formalpara><title>[:ALNUM:]</title>
                    <para>Union of [:ALPHA:] and [:DIGIT:].</para>
                  </formalpara>

                  <formalpara><title>[:UPPER:]</title>
                    <para>Uppercase Latin letters A..Z. Also matches lowercase with case-insensitive
                    collation and accented forms with accent-insensitive collation.</para>
                  </formalpara>

                  <formalpara><title>[:LOWER:]</title>
                    <para>Lowercase Latin letters a..z. Also matches uppercase with case-insensitive
                    collation and accented forms with accent-insensitive collation.</para>
                  </formalpara>

                  <formalpara><title>[:SPACE:]</title>
                    <para>Matches the space character (ASCII 32).</para>
                  </formalpara>

                  <formalpara><title>[:WHITESPACE:]</title>
                    <para>Matches horizontal tab (ASCII 9), linefeed (ASCII 10), vertical
                    tab (ASCII 11), formfeed (ASCII 12), carriage return (ASCII 13) and space (ASCII 32).</para>
                  </formalpara>
                <para>Including a predefined class has the same effect as including all its members.
                Predefined classes are only allowed within class definitions. If you need to match
                against a predefined class and nothing more, place an extra pair of brackets around it.
                  <programlisting>
       'Erdbeere' similar to 'Erd[[:ALNUM:]]eere'     -- true
       'Erdbeere' similar to 'Erd[[:DIGIT:]]eere'     -- false
       'Erdbeere' similar to 'Erd[a[:SPACE:]b]eere'   -- true
       'Erdbeere' similar to [[:ALPHA:]]              -- false
       'E'        similar to [[:ALPHA:]]              -- true
                  </programlisting>
              If a class definition starts with a caret, everything that follows is excluded from the
              class. All other characters match:
                  <programlisting>
       'Framboise' similar to 'Fra[^ck-p]boise'       -- false
       'Framboise' similar to 'Fr[^a][^a]boise'       -- false
       'Framboise' similar to 'Fra[^[:DIGIT:]]boise'  -- true
                  </programlisting>
              If the caret is not placed at the start of the sequence, the class contains everything
              before the caret, except for the elements that also occur after the caret:
                  <programlisting>
       'Grapefruit' similar to 'Grap[a-m^f-i]fruit'   -- true
       'Grapefruit' similar to 'Grap[abc^xyz]fruit'   -- false
       'Grapefruit' similar to 'Grap[abc^de]fruit'    -- false
       'Grapefruit' similar to 'Grap[abe^de]fruit'    -- false

       '3' similar to '[[:DIGIT:]^4-8]'               -- true
       '6' similar to '[[:DIGIT:]^4-8]'               -- false
                  </programlisting>
              Lastly, the already mentioned wildcard <quote>_</quote> is a character class of its own,
              matching any single character.
                </para>
              </section>
            </section> <!-- regex character classes -->

            <section id="fblangref25-commons-regexquantifiers">
              <title>Quantifiers</title>
              <para>A question mark immediately following a character or class indicates that the
              preceding item may occur 0 or 1 times in order to match:
                <programlisting>
       'Hallon' similar to 'Hal?on'                   -- false
       'Hallon' similar to 'Hal?lon'                  -- true
       'Hallon' similar to 'Halll?on'                 -- true
       'Hallon' similar to 'Hallll?on'                -- false
       'Hallon' similar to 'Halx?lon'                 -- true
       'Hallon' similar to 'H[a-c]?llon[x-z]?'        -- true
                </programlisting>
              An asterisk immediately following a character or class indicates that the preceding
              item may occur 0 or more times in order to match:
                <programlisting>
       'Icaque' similar to 'Ica*que'                  -- true
       'Icaque' similar to 'Icar*que'                 -- true
       'Icaque' similar to 'I[a-c]*que'               -- true
       'Icaque' similar to '_*'                       -- true
       'Icaque' similar to '[[:ALPHA:]]*'             -- true
       'Icaque' similar to 'Ica[xyz]*e'               -- false
                </programlisting>
              A plus sign immediately following a character or class indicates that the preceding
              item must occur 1 or more times in order to match:
                <programlisting>
       'Jujube' similar to 'Ju_+'                     -- true
       'Jujube' similar to 'Ju+jube'                  -- true
       'Jujube' similar to 'Jujuber+'                 -- false
       'Jujube' similar to 'J[jux]+be'                -- true
       'Jujube' sililar to 'J[[:DIGIT:]]+ujube'       -- false
                </programlisting>
              If a character or class is followed by a number enclosed in braces, it must be
              repeated exactly that number of times in order to match:
                <programlisting>
       'Kiwi' similar to 'Ki{2}wi'                    -- false
       'Kiwi' similar to 'K[ipw]{2}i'                 -- true
       'Kiwi' similar to 'K[ipw]{2}'                  -- false
       'Kiwi' similar to 'K[ipw]{3}'                  -- true
                </programlisting>
              If the number is followed by a comma, the item must be repeated at least that
              number of times in order to match:
                <programlisting>
       'Limone' similar to 'Li{2,}mone'               -- false
       'Limone' similar to 'Li{1,}mone'               -- true
       'Limone' similar to 'Li[nezom]{2,}'            -- true
                </programlisting>
              If the braces contain two numbers separated by a comma, the second number not
              smaller than the first, then the item must be repeated at least the first
              number and at most the second number of times in order to match:
                <programlisting>
       'Mandarijn' similar to 'M[a-p]{2,5}rijn'       -- true
       'Mandarijn' similar to 'M[a-p]{2,3}rijn'       -- false
       'Mandarijn' similar to 'M[a-p]{2,3}arijn'      -- true
                </programlisting>
              The quantifiers ?, * and + are shorthand for {0,1}, {0,} and {1,},
              respectively.
              </para>
            </section> <!-- regex quantifiers -->

            <section id="fblangref25-commons-regexoring">
              <title>OR-ing Terms</title>
              <para>Regular expression terms can be OR'ed with the | operator. A match is made
              when the argument string matches at least one of the terms:
                <programlisting>
       'Nektarin' similar to 'Nek|tarin'              -- false
       'Nektarin' similar to 'Nektarin|Persika'       -- true
       'Nektarin' similar to 'M_+|N_+|P_+'            -- true
                </programlisting>
              </para>
            </section> <!-- OR-ing terms -->

            <section id="fblangref25-commons-regexsubexpr">
              <title>Subexpressions</title>
              <para>One or more parts of the regular expression can be grouped into subexpressions
              (also called subpatterns) by placing them between parentheses. A subexpression is a
              regular expression in its own right. It can contain all the elements allowed in a
              regular expression, and can also have quantifiers added to it.
                <programlisting>
       'Orange' similar to 'O(ra|ri|ro)nge'           -- true
       'Orange' similar to 'O(r[a-e])+nge'            -- true
       'Orange' similar to 'O(ra){2,4}nge'            -- false
       'Orange' similar to 'O(r(an|in)g|rong)?e'      -- true
                </programlisting>
              </para>
            </section> <!-- subexpressions -->
            <section id="fblangref25-commons-regexescap">
              <title>Escaping Special Characters</title>
              <para>In order to match against a character that is special in regular expressions,
              that character has to be escaped. There is no default escape character; rather, the
              user specifies one when needed:
                <programlisting>
'Peer (Poire)' similar to 'P[^ ]+ \(P[^ ]+\)' escape '\'    -- true
'Pera [Pear]'  similar to 'P[^ ]+ #[P[^ ]+#]' escape '#'    -- true
'P&#xe4;ron-&#xe4;ppledryck' similar to 'P%$-&#xe4;%' escape '$'           -- true
'P&#xe4;rondryck' similar to 'P%--&#xe4;%' escape '-'                 -- false
                </programlisting>
              The last line demonstrates that the escape character can also escape
              itself, if needed.
              </para>
            </section> <!-- escaping special chars -->
          </section> <!-- Building regex expr -->
        </section><!-- Similar To -->

        <section id="fblangref25-commons-isnotdistinct">
          <title><database>IS [NOT] DISTINCT FROM</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       <replaceable>operand1</replaceable> IS [NOT] DISTINCT FROM <replaceable>operand2</replaceable>
            </programlisting>
            </para>
          </formalpara>
          <para>Two operands are considered DISTINCT if they have a different value or if one of them
          is NULL and the other non-null. They are NOT DISTINCT if they have the same value or if both
          of them are NULL.</para>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-isnotnull"><database>IS [NOT] NULL</database></link></para>
          </formalpara>
        </section> <!-- is not distinct from -->

        <section id="fblangref25-commons-isnotnull">
          <title><database>IS [NOT] NULL</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL, ESQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <para>
            <programlisting>
       &lt;value&gt; IS [NOT] NULL
            </programlisting>
            </para>
          </formalpara>
          <para>Since NULL is not a value, these operators are not comparison operators. The
          <database>IS [NOT] NULL</database> predicate tests the assertion that the expression on
          the left side has a value (IS NOT NULL) or has no value (IS NULL).</para>
          <formalpara><title>Example</title>
            <para>&nbsp;Search for sales entries that have no shipment date set for them:
              <programlisting>
       SELECT * FROM SALES
         WHERE SHIP_DATE IS NULL;
              </programlisting>
            </para>
          </formalpara>
          <note>
            <title>Note regarding the IS predicates</title>
            <para>Up to and including Firebird 2.5, the <database>IS</database> predicates, like
              the other comparison predicates, do not have precedence over the others.  In Firebird 3.0
              and higher, these predicates take precedence above the others.</para>
          </note>
        </section> <!-- is not null -->
      </section><!-- Other comparison predicates -->
    </section><!-- Comparison predicates -->

    <section id="fblangref25-commons-existential">
      <title>Existential Predicates</title>
      <para>This group of predicates includes those that use subqueries to submit values for all
      kinds of assertions in search conditions. Existential predicates are so called because they
      use various methods to test for the <firstterm>existence</firstterm> or <firstterm>non-existence</firstterm>
      of some assertion, returning <database>TRUE</database> if the existence or non-existence is
      confirmed or <database>FALSE</database> otherwise.</para>

      <section id="fblangref25-commons-exists">
        <title><database>EXISTS</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <para>
          <programlisting>
       [NOT] EXISTS(&lt;select_stmt&gt;)
          </programlisting>
          </para>
        </formalpara>
        <para>The <database>EXISTS</database> predicate uses a subquery expression as its argument.
        It returns <database>TRUE</database> if the subquery result would contain at least one row; otherwise
        it returns <database>FALSE</database>.</para>
        <para><database>NOT EXISTS</database> returns <database>FALSE</database> if the subquery result would
        contain at least one row; it returns <database>TRUE</database> otherwise.</para>
        <note>
          <para>The subquery can specify multiple columns, or <database>SELECT *</database>, because the
          evaluation is made on the number of rows that match its criteria, not on the data. </para>
        </note>
        <formalpara><title>Examples</title>
          <para>
          <orderedlist>
            <listitem><para>Find those employees who have projects.</para>
              <programlisting>
       SELECT *
       FROM employee
       WHERE EXISTS(SELECT *
                    FROM  employee_project ep
                    WHERE ep.emp_no = employee.emp_no)
              </programlisting>
            </listitem>
            <listitem><para>Find those employees who have no projects.</para>
              <programlisting>
       SELECT *
       FROM employee
       WHERE NOT EXISTS(SELECT *
                        FROM employee_project ep
                        WHERE ep.emp_no = employee.emp_no)
              </programlisting>
            </listitem>
          </orderedlist>
          </para>
        </formalpara>
      </section>

      <section id="fblangref25-commons-in">
        <title><database>IN</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <para>
          <programlisting>
       &lt;value&gt; [NOT] IN(&lt;select_stmt&gt; | &lt;value_list&gt;)

       &lt;value_list&gt; ::= &lt;value_1&gt; [, &lt;value_2&gt; &#x2026;]
          </programlisting>
          </para>
        </formalpara>
        <para>The <database>IN</database> predicate tests whether the value of the expression on the left
        side is present in the set of values specified on the right side. The set of values cannot have
        more than 1500 items. The <database>IN</database> predicate could be replaced with the following
        equivalent form:
          <programlisting>
       (&lt;value&gt; = &lt;value_1&gt; [OR &lt;value&gt; = &lt;value_2&gt; &#x2026;])
          </programlisting>
        When the <database>IN</database> predicate is used in the search conditions of DML queries,
        the Firebird optimizer can use an index on the searched column, if a suitable one exists.</para>

        <para>In its second form, the <database>IN</database> predicate tests whether the value of the
        expression on the left side is present (or not present, if <database>NOT IN</database> is used)
        in the result of the executed subquery on the right side.</para>
        <para>The subquery must be specified to result in only one column, otherwise the error
        <quote>count of column list and variable list do not match</quote> will occur.</para>

        <para>Queries specified using the <database>IN</database> predicate with a subquery can be
        replaced with a similar query using the <database>EXISTS</database> predicate.
        For instance, the following query:
          <programlisting>
       SELECT
         model, speed, hd
       FROM PC
       WHERE
       model IN (SELECT model
                   FROM product
                   WHERE maker = 'A');
          </programlisting>
        can be replaced with a similar one using the EXISTS predicate:
          <programlisting>
       SELECT
         model, speed, hd
       FROM PC
       WHERE
         EXISTS (SELECT *
                 FROM product
                   WHERE maker = 'A'
                   AND product.model = PC.model);
          </programlisting>

        However, a query using <database>NOT IN</database> with a subquery does
        not always give the same result as its <database>NOT EXISTS</database> counterpart.
        The reason is that <database>EXISTS</database> always returns TRUE or FALSE, whereas
        <database>IN</database> returns <database>NULL</database> in one of these two cases:
        <orderedlist spacing="compact" numeration="loweralpha">
          <listitem><para>when the test value is <database>NULL</database> and the <database>IN ()</database>
          list is not empty</para></listitem>
          <listitem><para>when the test value has no match in the <database>IN ()</database> list and at
          least one list element is <database>NULL</database></para></listitem>
        </orderedlist>
        It is in only these two cases that <database>IN ()</database> will return <database>NULL</database>
        while the corresponding <database>EXISTS</database> predicate will return <database>FALSE</database>
        ('no matching row found'). In a search or, for example, an <database>IF (...)</database> statement,
        both results mean <quote>failure</quote> and it makes no difference to the outcome.</para>
        <para>But, for the same data, <database>NOT IN ()</database> will return <database>NULL</database>,
        while <database>NOT EXISTS</database> will return <database>TRUE</database>, leading to opposite
        results.</para>
        <para>As an example, suppose you have the following query:
          <programlisting>
       -- Looking for people who were not born
       -- on the same day as any famous New York citizen
       SELECT P1.name AS NAME
       FROM Personnel P1
       WHERE P1.birthday NOT IN (SELECT C1.birthday
                                 FROM Celebrities C1
                                 WHERE C1.birthcity = 'New York');
          </programlisting>
        Now, assume that the NY celebrities list is not empty and contains at
        least one NULL birthday. Then for every citizen who does not share his
        birthday with a NY celebrity, <database>NOT IN</database> will return <database>NULL</database>,
        because that is what <database>IN</database> does.  The search condition is thereby not
        satisfied and the citizen will be left out of the <database>SELECT</database> result,
        which is wrong.</para>
        <para>For citizens whose birthday does match with a celebrity's birthday,
        <database>NOT IN</database> will correctly return <database>FALSE</database>, so they will
        be left out too, and no rows will be returned.</para>
        <para>If the <database>NOT EXISTS</database> form is used:
          <programlisting>
       -- Looking for people who were not born
       -- on the same day as any famous New York citizen
       SELECT P1.name AS NAME
       FROM Personnel P1
       WHERE NOT EXISTS (SELECT *
                         FROM Celebrities C1
                         WHERE C1.birthcity = 'New York'
                           AND C1.birthday = P1.birthday);
          </programlisting>
       non-matches will have a <database>NOT EXISTS</database> result of <database>TRUE</database> 
       and their records will be in the result set.
         <caution>
           <title>Advice</title>
           <para>If there is any chance of NULLs being encountered when searching for a non-match, 
           you will want to use <database>NOT EXISTS</database>.</para>
         </caution>
        </para>
        <formalpara><title>Examples of use</title>
          <para>
          <orderedlist>
            <listitem><para>Find employees with the names <quote>Pete</quote>, <quote>Ann</quote>
            and <quote>Roger</quote>:</para>
              <programlisting>
       SELECT *
       FROM EMPLOYEE
       WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
              </programlisting>
            </listitem>
            <listitem><para>Find all computers that have models whose manufacturer starts with
            the letter <quote>A</quote>:</para>
              <programlisting>
       SELECT
          model, speed, hd
       FROM PC
       WHERE
         model IN (SELECT model
                   FROM product
                   WHERE maker STARTING WITH 'A');
              </programlisting>
            </listitem>
          </orderedlist>
          </para>
        </formalpara>
        <formalpara><title>See also</title>
          <para><link linkend="fblangref25-commons-exists">EXISTS</link></para>
        </formalpara>
      </section>

      <section id="fblangref25-commons-singular">
        <title><database>SINGULAR</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <para>
          <programlisting>
       [NOT] SINGULAR(&lt;select_stmt&gt;)
          </programlisting>
          </para>
        </formalpara>
        <para>The <database>SINGULAR</database> predicate takes a subquery as its argument
        and evaluates it as True if the subquery returns exactly one result row; otherwise
        the predicate is evaluated as False. The subquery may list several output columns 
        since the rows are not returned anyway. They are only tested for (singular) 
        existence. For brevity, people usually specify '<database>SELECT *</database>'. 
        The <database>SINGULAR</database> predicate can return only two values: 
        <database>TRUE</database> or <database>FALSE</database>.</para>
        <formalpara><title>Example</title>
          <para>&nbsp;Find those employees who have only one project.
            <programlisting>
       SELECT *
       FROM employee
       WHERE SINGULAR(SELECT *
                      FROM
                        employee_project ep
                      WHERE
                        ep.emp_no = employee.emp_no)
            </programlisting>
          </para>
        </formalpara>
      </section>
    </section> <!-- Existential Predicates -->

    <section id="fblangref25-commons-quantifiedsq">
      <title><database>Quantified Subquery Predicates</database></title>
      <para>A quantifier is a logical operator that sets the number of objects for which
      this assertion is true. It is not a numeric quantity, but a logical one that connects
      the assertion with the full set of possible objects. Such predicates are based on
      logical universal and existential quantifiers that are recognised in formal
      logic.</para>
      <para>In subquery expressions, quantified predicates make it possible to compare
      separate values with the results of subqueries; they have the following common form:
        <programlisting>
       &lt;value expression&gt; &lt;comparison operator&gt; &lt;quantifier&gt; &lt;subquery&gt;
        </programlisting>
      </para>

      <section id="fblangref25-commons-quant-all">
        <title><database>ALL</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <para>
          <programlisting>
       &lt;value&gt; &lt;op&gt; ALL(&lt;select_stmt&gt;)
          </programlisting>
          </para>
        </formalpara>
        <para>When the <database>ALL</database> quantifier is used, the predicate is TRUE
        if every value returned by the subquery satisfies the condition in the predicate of
        the main query.</para>
        <formalpara><title>Example</title>
          <para>&nbsp;Show only those clients whose ratings are higher than the rating of every
          client in Paris.
            <programlisting>
       SELECT c1.*
       FROM Customers c1
       WHERE c1.rating &gt; ALL
             (SELECT c2.rating
              FROM Customers c2
              WHERE c2.city = 'Paris')
            </programlisting>
          </para>
        </formalpara>
        <important>
          <para>If the subquery returns an empty set, the predicate is TRUE for every 
          left-side value, regardless of the operator. This may appear to be contradictory,
          because every left-side value will thus be considered both smaller and greater 
          than, both equal to and unequal to, every element of the right-side stream.</para>
          <para>Nevertheless, it aligns perfectly with formal logic: if the set is empty, 
          the predicate is true 0 times, i.e., for every row in the set.</para>
        </important>  
      </section>

      <section id="fblangref25-commons-quant-anysome">
        <title><database>ANY</database> and <database>SOME</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL, ESQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <para>
          <programlisting>
       &lt;value&gt; &lt;op&gt; {ANY | SOME} (&lt;select_stmt&gt;)
          </programlisting>
          </para>
        </formalpara>
        <para>The quantifiers <database>ANY</database> and <database>SOME</database> are
        identical in their behaviour. Apparently, both are present in the SQL standard
        so that they could be used interchangeably in order to improve the readability
        of operators. When the <database>ANY</database> or the <database>SOME</database>
        quantifier is used, the predicate is true if any of the values returned by the
        subquery satisfies the condition in the predicate of the main query. If the
        subquery would return no rows at all, the predicate is automatically considered
        as False.</para>
        <formalpara><title>Example</title>
          <para>&nbsp;Show only those clients whose ratings are higher than those of one or
          more clients in Rome.
            <programlisting>
       SELECT *
       FROM Customers
       WHERE rating &gt; ANY
             (SELECT rating
              FROM Customers
              WHERE city = 'Rome')
            </programlisting>
          </para>
        </formalpara>
      </section>
    </section><!-- quantified subquery predicates -->
  </section> <!-- Predicates  -->

</chapter>
