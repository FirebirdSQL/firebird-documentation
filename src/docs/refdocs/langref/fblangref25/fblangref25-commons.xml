<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-commons">
  <title>Common Language Elements</title>
  <section id="fblangref25-commons-expressions">
    <title>Expressions</title>
    <para>SQL expressions provide formal methods for evaluating, transforming and comparing
    values. SQL expressions may include table columns, variables, constants, literals, various
    statements and predicates and also other expressions. The complete list of possible tokens
    in expressions follows.</para>

    <table id="fblangref25-dtyp-tbl-exprelements">
    <?dbfo keep-together='auto'?>
      <title>Description of Expression Elements</title>
      <tgroup cols="2">
        <colspec colname="colElem" colwidth="2*"></colspec>
        <colspec colname="colDesc" colwidth="5*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Element</entry>
            <entry align="center">Description</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="left">Column name</entry>
            <entry align="left">Identifier of a column from a specified table used in evaluations
            or as a search condition. A column of the array type cannot be an element in an expression
            unless it is checked for <database>IS [NOT] NULL</database></entry>
          </row>
          <row valign="middle">
            <entry align="left">Array element</entry>
            <entry align="left">An expression may contain a reference to an array element</entry>
          </row>
          <row valign="middle">
            <entry align="left">Arithmetic operators</entry>
            <entry align="left">The +, -, *, / characters used to calculate values</entry>
          </row>
          <row valign="middle">
            <entry align="left">Concatenation operator</entry>
            <entry align="left">The || (<quote>double-pipe</quote>) operator used to concatenate
            strings</entry>
          </row>
          <row valign="middle">
            <entry align="left">Logical operators</entry>
            <entry align="left">The reserved words NOT, AND and OR, used to combine simple search
            conditions in order to create complex assertions</entry>
          </row>
          <row valign="middle">
            <entry align="left">Comparison operators</entry>
            <entry align="left">The characters &lt;, &gt;, &lt;=, &gt;=, = and &lt;&gt; and !=
            used as symbols to compare values</entry>
          </row>
          <row valign="middle">
            <entry align="left">Comparison predicates</entry>
            <entry align="left"><database>LIKE, STARTING WITH, CONTAINING, SIMILAR TO, BETWEEN,
            IS [NOT] NULL</database> and <database>IS [NOT] DISTINCT FROM</database></entry>
          </row>
          <row valign="middle">
            <entry align="left">Existential predicates</entry>
            <entry align="left">Predicates used to check the existence of values in a set. The
            <database>IN</database> predicate can be used both with sets of comma-separated
            constants and with scalar subqueries. The <database>EXISTS, SINGULAR, ALL,
            ANY</database> and <database>SOME</database> predicates can be used only
            with subqueries</entry>
          </row>
          <row valign="middle">
            <entry align="left">Constant</entry>
            <entry align="left">A number; or a string literal enclosed in apostrophes</entry>
          </row>
          <row valign="middle">
            <entry align="left">Date literal</entry>
            <entry align="left">An expression, similar to a string literal enclosed in apostrophes,
            that can be interpreted as a date, time or timestamp value. Date literals can be
            predefined literals (&quot;TODAY&quot;, &quot;NOW&quot;, etc.) or able to be evaluated
            as date and time strings</entry>
          </row>
          <row valign="middle">
            <entry align="left">Context variable</entry>
            <entry align="left">An internally-defined context variable</entry>
          </row>
          <row valign="middle">
            <entry align="left">Local variable</entry>
            <entry align="left">Declared local variable, input or output parameter of a PSQL
            module (stored procedure, trigger, unnamed PSQL block in DSQL)</entry>
          </row>
          <row valign="middle">
            <entry align="left">Positional parameter</entry>
            <entry align="left">A member of in an ordered group of one or more unnamed parameters
            passed to a stored procedure or prepared query</entry>
          </row>
          <row valign="middle">
            <entry align="left">Subquery</entry>
            <entry align="left">A SELECT statement enclosed in parentheses that returns a single (scalar)
            value or, when used in existential predicates, a set of values</entry>
          </row>
          <row valign="middle">
            <entry align="left">Function identifier</entry>
            <entry align="left">The identifier of an internal or external function in a function
            expression</entry>
          </row>
          <row valign="middle">
            <entry align="left">Type cast</entry>
            <entry align="left">An expression explicitly converting data of one data type to another
            using the <database>CAST</database> function ( <function>CAST (&lt;value&gt;
            AS &lt;datatype&gt;)</function> )</entry>
          </row>
          <row valign="middle">
            <entry align="left">Conditional expression</entry>
            <entry align="left">Expressions using the internal functions CASE, COALESCE,
            NULLIF, IIF</entry>
          </row>
          <row valign="middle">
            <entry align="left">Parentheses</entry>
            <entry align="left">Bracket pairs (&hellip;) used to group expressions.
            Operations inside the parentheses are performed before operations outside them. When
            embedded parentheses are used, the most deeply embedded expressions are evaluated
            first and then the evaluations move outward through the levels of embedding</entry>
          </row>
          <row valign="middle">
            <entry align="left">COLLATE clause</entry>
            <entry align="left">Clause applied to CHAR and VARCHAR types to specify the collation
            sequence to use in string comparisons</entry>
          </row>
          <row valign="middle">
            <entry align="left"><database>NEXT VALUE FOR</database> <replaceable>sequence</replaceable></entry>
            <entry align="left">Expression for obtaining the next value of a specified generator
            (sequence). The internal <database>GEN_ID()</database> function does the same</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="fblangref25-commons-sqloperators">
      <title>SQL Operators</title>
      <para>SQL operators comprise operators for comparing, calculating, evaluating and concatenating values.</para>

      <section id="fblangref25-commons-operpreced">
        <title>Operator Precedence</title>
        <para>SQL Operators are divided into four types. Each operator type has a <emphasis>precedence</emphasis>,
        a ranking that determines the order in which operators and the values obtained with their help
        are evaluated in an expression.The higher the precedence of the operator type is, the earlier it will be evaluated.
        Each operator has its own precedence within its type, that determines the order in which they are evaluated in an
        expression.</para>
        <para>Operators with the same precedence are evaluated from left to right. To force a different evaluation order,
        operations can be grouped by means of parentheses.</para>

        <table id="fblangref25-dtyp-tbl-operpreced">
        <?dbfo keep-together='auto'?>
          <title>Operator Type Precedence</title>
          <tgroup cols="3">
            <colspec colname="col01" colwidth="1*"></colspec>
            <colspec colname="col02" colwidth="1*"></colspec>
            <colspec colname="col03" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Operator Type</entry>
                <entry align="center">Precedence</entry>
                <entry align="center">Explanation</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">Concatenation</entry>
                <entry align="center">1</entry>
                <entry align="left">Strings are concatenated before any other operations take place</entry>
              </row>
              <row valign="middle">
                <entry align="center">Arithmetic</entry>
                <entry align="center">2</entry>
                <entry align="left">Arithmetic operations are performed after strings are concatenated,
                but before comparison and logical operations</entry>
              </row>
              <row valign="middle">
                <entry align="center">Comparison</entry>
                <entry align="center">3</entry>
                <entry align="left">Comparison operations take place after string concatenation and
                arithmetic operations, but before logical operations</entry>
              </row>
              <row valign="middle">
                <entry align="center">Logical</entry>
                <entry align="center">4</entry>
                <entry align="left">Logical operators are executed after all other types of operators</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <section id="fblangref25-commons-concat">
          <title>Concatenation Operator</title>
          <para>The concatenation operator, two pipe characters known as <quote>double
          pipe</quote>&mdash;<command> || </command>&mdash; concatenates (connects together) two character
          strings to form a single string. Character strings can be constants or values obtained from columns
          or other expressions.</para>
          <formalpara><title>Example</title>
            <programlisting>
       SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
       FROM EMPLOYEE
            </programlisting>
          </formalpara>
        </section>

        <section id="fblangref25-commons-arith">
          <title>Arithmetic Operators</title>
          <table id="fblangref25-dtyp-tbl-arithpreced">
          <?dbfo keep-together='auto'?>
            <title>Arithmetic Operator Precedence</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Purpose</entry>
                  <entry align="center">Precedence</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>*</command></entry>
                  <entry align="center">Multiplication</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>/</command></entry>
                  <entry align="center">Division</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>+</command></entry>
                  <entry align="center">Addition</entry>
                  <entry align="center">3</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>-</command></entry>
                  <entry align="center">Subtraction</entry>
                  <entry align="center">4</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <formalpara>
            <title>Example</title>
            <programlisting>
       UPDATE T
         SET A = 4 + 1/(B-C)*D
            </programlisting>
          </formalpara>
        </section><!-- Arithmetic operators -->

        <section id="fblangref25-commons-compar">
          <title>Comparison Operators</title>
          <table id="fblangref25-dtyp-tbl-comparpreced">
          <?dbfo keep-together='auto'?>
            <title>Comparison Operator Precedence</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Purpose</entry>
                  <entry align="center">Precedence</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>=</command></entry>
                  <entry align="center">Is equal to, is identical to</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;&gt;, !=, ~=, ^=</command></entry>
                  <entry align="center">Is not equal to</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&gt;</command></entry>
                  <entry align="center">Is greater than</entry>
                  <entry align="center">3</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;</command></entry>
                  <entry align="center">Is less than</entry>
                  <entry align="center">4</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&gt;=</command></entry>
                  <entry align="center">Is greater than or equal to</entry>
                  <entry align="center">5</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>&lt;=</command></entry>
                  <entry align="center">Is less than or equal to</entry>
                  <entry align="center">6</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>!&gt;, ~&gt;, ^&gt;</command></entry>
                  <entry align="center">Is not greater than</entry>
                  <entry align="center">7</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>!&lt;, ~&lt;, ^&lt;</command></entry>
                  <entry align="center">Is not less than</entry>
                  <entry align="center">8</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>This group also includes comparison predicates <database>BETWEEN, LIKE>,
          CONTAINING, SIMILAR TO</database> and others.</para>
          <formalpara><title>Example</title>
            <programlisting>
       IF (SALARY &gt; 1400) THEN
       &hellip;
            </programlisting>
          </formalpara>
          <formalpara><title>See also</title>
             <para><link linkend="fblangref25-commons-othercomppreds">Other Comparison Predicates</link>.</para>
          </formalpara>
        </section> <!-- Comparison operators -->

        <section id="fblangref25-commons-logical">
          <title>Logical Operators</title>
          <table id="fblangref25-dtyp-tbl-logical">
          <?dbfo keep-together='auto'?>
            <title>Logical Operator Precedence</title>
            <tgroup cols="3">
              <colspec colname="col01" colwidth="1*"></colspec>
              <colspec colname="col02" colwidth="2*"></colspec>
              <colspec colname="col03" colwidth="1*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center">Operator</entry>
                  <entry align="center">Purpose</entry>
                  <entry align="center">Precedence</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center"><command>NOT</command></entry>
                  <entry align="center">Negation of a search condition</entry>
                  <entry align="center">1</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>AND</command></entry>
                  <entry align="center">Combines two or more predicates, each of which must
                  be true for the entire predicate to be true</entry>
                  <entry align="center">2</entry>
                </row>
                <row valign="middle">
                  <entry align="center"><command>OR</command></entry>
                  <entry align="center">Combines two or more predicates, of which at least one
                  predicate must be true for the entire predicate to be true</entry>
                  <entry align="center">3</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <formalpara>
            <title>Example</title>
            <programlisting>
       IF (A &lt; B OR (A &gt; C AND A &gt; D) AND NOT (C = D)) THEN &hellip;
            </programlisting>
          </formalpara>
        </section> <!-- Logical operators -->
      </section> <!-- Operator precedence -->

      <section id="fblangref25-commons-conditional-nxtvlufor">
        <title><database>NEXT VALUE FOR</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <para><database>NEXT VALUE FOR</database> returns the next value of a sequence.
        <database>SEQUENCE</database> is an SQL-compliant term for a generator in Firebird
        and its ancestor, InterBase. The <database>NEXT VALUE FOR</database> operator is
        equivalent to the legacy <database>GEN_ID (..., 1)</database> function and is the
        recommended syntax for retrieving the next sequence value.</para>
        <formalpara>
          <title>Syntax for NEXT VALUE FOR</title>
          <programlisting>
       NEXT VALUE FOR <replaceable>sequence-name</replaceable>
          </programlisting>
        </formalpara>

        <formalpara>
          <title>Example</title>
          <programlisting>
       NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
          </programlisting>
        </formalpara>

        <note>
          <para>Unlike <database>GEN_ID (..., 1)</database>, the <database>NEXT VALUE FOR</database>
          variant does not take any parameters and thus, provides no way to retrieve the
          <emphasis>current value</emphasis> of a sequence, nor to step the next value by
          more than 1.  <database>GEN_ID (..., &lt;step value&gt;)</database> is still needed for
          these tasks.  A &lt;step value&gt; of 0 returns the current sequence value.</para>
        </note>

        <formalpara>
          <title>See also</title>
          <para>&nbsp;<link linkend="fblangref25-ddl-sequence">SEQUENCE (GENERATOR)</link>,
          <link linkend="fblangref25-functions-scalarfuncs-gen_id"><database>GEN_ID()</database></link>
          </para>
        </formalpara>
      </section><!-- NEXT VALUE FOR -->
    </section> <!-- Operators -->

    <section id="fblangref25-commons-conditional">
      <title>Conditional Expressions</title>
      <para>A conditional expression is one that returns different values according to how a
      certain condition is met.  It is composed by applying a conditional function construct,
      of which Firebird supports several.  This section describes only one conditional expression
      construct: <database>CASE</database>. All other conditional expressions apply internal
      functions derived from <database>CASE</database> and are described in 
      <link linkend="fblangref25-functions-conditional">Conditional Functions</link>.</para>

      <section id="fblangref25-commons-conditional-case">
        <title><database>CASE</database></title>
        <formalpara>
          <title>Available</title><para> DSQL, PSQL</para>
        </formalpara>
        <para>The <database>CASE</database> construct returns a single value from a number of
        possible ones. Two syntactic variants are supported:
          <itemizedlist>
            <listitem>The <emphasis>simple</emphasis> <database>CASE</database>, comparable
            to a Pascal switch...case  construct or a C switch</listitem>
            <listitem>The <emphasis>searched</emphasis> <database>CASE</database>, which works like a series
            of <quote><function>if ... else if ... else if</function></quote> clauses.</listitem>
          </itemizedlist>
        </para>

        <section id="fblangref25-commons-conditional-case-simple">
          <title>Simple <database>CASE</database></title>
          <formalpara><title>Syntax</title>
            <programlisting>
       &hellip;
       CASE &lt;test-expr&gt;
         WHEN &lt;expr> THEN &lt;result&gt;
         [WHEN &lt;expr> THEN &lt;result&gt; ...]
         [ELSE &lt;defaultresult&gt;]
       END
       &hellip;
            </programlisting>
          </formalpara>
          <para>When this variant is used, <function> &lt;test-expr&gt; </function> is compared to
          &lt;expr&gt; 1, &lt;exp&gt; 2 etc., until a match is found and the corresponding
          result is returned. If no match is found, &lt;defaultresult&gt; from the optional
          <database>ELSE</database> clause is returned. If there are no matches and no
          <database>ELSE</database> clause, <database>NULL</database> is returned.</para>
          <para>The matching works identically to the &quot;=&quot; operator.  That is,
          if &lt;test-expr&gt; is <database>NULL</database>, it does not match any
          &lt;expr&gt;, not even an expression that resolves to <database>NULL</database>.</para>
          <para>The returned result does do not have to be a literal value: it might be a field
          or variable name, compound expression or <database>NULL</database> literal.</para>
          <para>A short form of the simple <database>CASE</database> construct is used in
          the <database>DECODE</database> function.
            <formalpara>
              <title>Example</title>
              <programlisting>
       SELECT
         NAME,
         AGE,
         CASE UPPER(SEX)
           WHEN 'M' THEN 'Male'
           WHEN 'F' THEN 'Female'
           ELSE 'Unknown'
         END GENDER,
	RELIGION
      FROM PEOPLE
              </programlisting>
            </formalpara>
          </para>
        </section> <!-- Simple CASE -->

        <section id="fblangref25-commons-conditional-case-srched">
          <title>Searched <database>CASE</database></title>
          <formalpara>
            <title>Syntax</title>
            <programlisting>
       CASE
         WHEN &lt;bool_expr&gt; THEN &lt;result&gt;
         [WHEN &lt;bool_expr&gt; THEN &lt;result&gt; &hellip;]
         [ELSE &lt;defaultresult&gt;]
         END
            </programlisting>
          </formalpara>
          <para>The &lt;bool_expr&gt; expression is one that gives a ternary logical result:
          <database>TRUE, FALSE</database> or <database>NULL</database>. The first expression
          to return <database>TRUE</database> determines the result. If no expressions return
          <database>TRUE</database>, &lt;defaultresult&gt; from the optional <database>ELSE</database>
          clause is returned as the result. If no expressions return <database>TRUE</database>
          and there is no <database>ELSE</database> clause, the result will
          be <database>NULL</database>.</para>
          <para>As with the simple <database>CASE</database> construct, the result must not
          be a literal value: it might be a field or variable name, a compound expression, or
          be <database>NULL</database>.</para>
          <formalpara>
            <title>Example</title>
            <programlisting>
       CANVOTE = CASE
         WHEN AGE &gt;= 18 THEN 'Yes'
         WHEN AGE &lt; 18 THEN 'No'
         ELSE 'Unsure'
         END
            </programlisting>
          </formalpara>
        </section> <!-- Searched CASE -->
      </section><!-- CASE -->
    </section> <!-- Conditional Expressions -->

    <section id="fblangref25-commons-null-in-expr">
      <title><database>NULL</database> in Expressions</title>
      <para><database>NULL</database> is not a value in SQL, but a <emphasis>state</emphasis>
      indicating that the value of the element either <emphasis>unknown</emphasis> or it does
      not exist. It is not a zero, nor a void, nor an <quote>empty string</quote>, and it does
      not act like any value.</para>
      <para>When you use <database>NULL</database> in numeric, string or date/time expressions,
      the result will always be <database>NULL</database>. When you use <database>NULL</database>
      in logical (Boolean) expressions, the result will depend on the type of the operation and
      on other participating values. When you compare a value to <database>NULL</database>, the
      result will be <emphasis>unknown</emphasis>.</para>
      <important>
        <title>Important to Note</title>
        <para><database>NULL</database> means <database>NULL</database> but,
        in Firebird, the logical result <emphasis>unknown</emphasis> is also <emphasis>represented
        by</emphasis> <database>NULL</database>.</para>
      </important>

      <section id="fblangref25-commons-returningnull">
        <title>Expressions Returning <database>NULL</database></title>
        <para>Expressions in this list will always return <database>NULL</database>:
          <literallayout class="monospaced">
       1 + 2 + 3 + NULL
       'Home ' || 'sweet ' || NULL
       MyField = NULL
       MyField &lt;&gt; NULL
       NULL = NULL
       not (NULL)
          </literallayout>
        If it seems difficult to understand why, remember that NULL is a state that stands for
        <quote>unknown</quote>.
        </para>
      </section>

      <section id="fblangref25-commons-nullinlogical">
        <title><database>NULL</database> in Logical Expressions</title>
        <para>It has already been shown that <function> not (NULL) </function> results in
        <database>NULL</database>. The interaction is a bit more complicated for the logical
        <database>AND</database> and logical <database>OR</database> operators:
          <literallayout class="monospaced">
       NULL or false = NULL
       NULL or true = true
       NULL or NULL = NULL
       NULL and false = false
       NULL and true = NULL
       NULL and NULL = NULL
          </literallayout>
        </para>
        <para>Up to and including Firebird 2.5.x, there is no implementation for a logical (Boolean)
        data type&mdash;that is coming in Firebird 3. However, there are logical expressions (predicates)
        that can return true, false or unknown.
          <formalpara>
            <title>Examples</title>
            <literallayout class="monospaced">
       (1 = NULL) or (1 &lt;&gt; 1) -- return NULL
       (1 = NULL) or (1 = 1) -- return TRUE
       (1 = NULL) or (1 = NULL) -- return NULL
       (1 = NULL) and (1 &lt;&gt; 1) -- return FALSE
       (1 = NULL) and (1 = 1) -- return NULL
       (1 = NULL) and (1 = NULL) -- return NULL
            </literallayout>
          </formalpara>
        </para>
      </section>
    </section> <!-- NULL in expressions -->

    <section id="fblangref25-commons-subqueries">
      <title>Subqueries</title>
      <para>A subquery is a special form of expression that is actually a reference to another table
      embedded within the main query specification. Subqueries are written in the same way as regular
      <database>SELECT</database> queries, but they must be enclosed in parentheses. Subquery
      expressions can be used in the following ways:
        <itemizedlist>
          <listitem>To specify the output column in the SELECT list</listitem>
          <listitem>To obtain values or conditions for search predicates (the
          <database>WHERE</database>, <database>HAVING</database> clauses).</listitem>
        </itemizedlist>
      </para>
      <section id="fblangref25-commons-correlatedsq">
        <title>Correlated Subqueries</title>
        <para>A subquery can be <emphasis>correlated</emphasis>. A query is correlated when the subquery
        and the main query are interdependent. To process each record in the subquery, it is necessary
        to fetch a record in the main query; i.e., the subquery fully depends on the main query.</para>
        <formalpara>
          <title>Sample Correlated Subquery</title>
          <programlisting>
       SELECT *
       FROM Customers C
       WHERE EXISTS
             (SELECT *
              FROM Orders O
              WHERE C.cnum = O.cnum
                AND O.adate = DATE '10.03.1990');
          </programlisting>
        </formalpara>

        <para>When subqueries are used to get the values of the output column in the SELECT list,
        a subquery must return a <emphasis>scalar</emphasis> result.</para>
      </section>

      <section id="fblangref25-commons-scalarsq">
        <title>Scalar Results (Singletons)</title>
        <para>Subqueries used in search predicates, other than existential predicates and quantified
        predicates, must return a <emphasis>scalar</emphasis> result;  that is, not more than one column from
        one matching row or aggregation.  If the result would return more, a run-time error will
        occur (<quote>Multiple rows in a singleton select...</quote>).</para>

        <formalpara>
          <title>Subquery Examples</title>
          <orderedlist>
            <listitem>A subquery as the output column in a <database>SELECT</database> list:
              <programlisting>
       SELECT
           e.first_name,
           e.last_name,
           (SELECT
                sh.new_salary
            FROM
                salary_history sh
            WHERE
                sh.emp_no = e.emp_no
            ORDER BY sh.change_date DESC ROWS 1) AS last_salary
       FROM
            employee e
              </programlisting>
            </listitem>
            <listitem>A subquery in the <database>WHERE</database> clause for obtaining the
            employee's maximum salary and filtering by it:
              <programlisting>
       SELECT
           e.first_name,
           e.last_name,
           e.salary
       FROM
           employee e
       WHERE
           e.salary = (
                       SELECT MAX(ie.salary)
                       FROM employee ie
                       )
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
      </section>
    </section> <!-- Subqueries -->
  </section> <!-- Expressions -->

<!-- ============================================================== -->
  <section id="fblangref25-commons-predicates">
    <title>Predicates</title>
    <para>A predicate is a simple expression asserting some fact. A predicate can be
    <database>TRUE, FALSE</database> or <database>UNKNOWN</database>. Both False and Unknown
    predicates are interpreted in SQL as False.</para>
    <para>In SQL, predicates are tested in <database>WHERE</database> clauses, <database>CASE</database>
    expressions, in the <database>ON</database> condition for <database>JOIN</database> clauses and in
    the <database>HAVING</database> clause for aggregations. In PSQL, flow-of-control statements test
    predicates in the <database>IF</database>, <database>WHILE</database> and <database>WHEN</database>
    clauses.</para>

    <section id="fblangref25-commons-assertions">
      <title>Assertions</title>
      <para>Tested conditions are not always simple predicates. They can be a group of predicates
      and each of them, once evaluated, contributes to the evaluation of the ultimate truth.
      Such complex conditions are called <emphasis>assertions</emphasis>. Assertions may consist
      of one or several predicates connected by the logical operators <database>AND</database>,
      <database>OR</database> and <database>NOT</database>.</para>
      <para>Each predicate may contain nested predicates. The result of evaluation as to whether
      an assertion is True or False results from the evaluation of all predicates, from the inner ones
      outward. Each <quote>level</quote> is evaluated in precedence order until it is possible to
      get to the ultimate assertion.</para>
    </section>

    <section id="fblangref25-commons-comppreds">
      <title>Comparison Predicates</title>
      <para>A comparison predicate consists of two expressions connected with a comparison operator.
      There are six traditional comparison operators:
        <literallayout>
       <command>=</command>, <command>&gt;</command>, <command>&lt;</command>, <command>&gt;=</command>, <command>&lt;=</command>, <command>&lt;&gt;</command>
        </literallayout>
      (For the complete list of comparison operators with their variant forms, see
      <link linkend= "fblangref25-commons-compar">Comparison Operators</link>.)
      </para>

      <para>If one of the sides (left or right) of a comparison predicate has <database>NULL</database>
      in it, the value of the predicate will be UNKNOWN.</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Retrieve information about computers with the CPU frequency not less than
          500 MHz and the price lower than $800:
            <programlisting>
       SELECT *
       FROM Pc
       WHERE speed &gt;= 500 AND price &lt; 800;
            </programlisting>
          </listitem>
          <listitem>Retrieve information about all dot matrix printers that cost less than $300:
             <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype = 'matrix' AND price &lt; 300;
            </programlisting>
          </listitem>
          <listitem>The following query will return not a single entry because the comparison
          is made to <database>NULL</database>, even if there are printers with no type specified
          for them.
            <programlisting>
       SELECT *
       FROM Printer
       WHERE ptrtype = NULL AND price &lt; 300;

            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>

      <section id="fblangref25-commons-othercomppreds">
        <title>Other Comparison Predicates</title>
        <para>Other comparison predicates are marked by keyword symbols.</para>
        <section id="fblangref25-commons-predbetween">
          <title><database>BETWEEN</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; [NOT] BETWEEN &lt;value_1&gt; AND &lt;value_2&gt;
            </programlisting>
          </formalpara>
          <para>The <database>BETWEEN</database> predicate tests whether a value falls within
          a specified range of two values. (<database>NOT BETWEEN</database> tests whether the value
          does not fall within that range.)</para>
          <para>The operands for <database>BETWEEN</database> predicate are two arguments of
          compatible data types. Unlike in some other DBMS, the <database>BETWEEN</database>
          predicate in Firebird is not symmetrical&mdash;if the lower value is not the first
          argument, the <database>BETWEEN</database> predicate will always return False.
          The search is inclusive (the values represented by both arguments are included in
          the search). In other words,, the <database>BETWEEN</database> predicate could be
          rewritten:
            <literallayout class="monospaced">
       &lt;value&gt; &gt;= &lt;value_1&gt; AND &lt;value&gt; &lt;= &lt;value_2&gt;
            </literallayout>
          </para>
          <para>When <database>BETWEEN</database> is used in the search conditions of DML queries,
          the Firebird optimizer can use an index on the searched column, if it is available.</para>
          <formalpara><title>Example</title>
            <programlisting>
       SELECT *
       FROM EMPLOYEE
       WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
            </programlisting>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predlike">
          <title><database>LIKE</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;match value&gt; [NOT] LIKE &lt;pattern&gt;
          [ESCAPE &lt;escape character&gt;]

       &lt;match value&gt; ::= <replaceable>character-type expression</replaceable>

       &lt;pattern&gt; ::= <replaceable>search pattern</replaceable>

       &lt;escape character&gt; :: = <replaceable>escape character</replaceable>
            </programlisting>
          </formalpara>
          <para>The <database>LIKE</database> predicate compares the character-type expression with
          the pattern defined in the second expression. Comparison to the pattern is case-sensitive,
          except where the field itself is defined with a case-insensitive collation.</para>

          <section id="fblangref25-commons-wildcards">
          <title>Wildcards</title>
          <para>Two wildcard symbols are available for use in the search pattern:
            <itemizedlist>
              <listitem>the percentage character (%) substitutes any sequence of zero or more
              characters in the tested value</listitem>
              <listitem>the underscore character (_) can be used instead of any single character
              in the tested value</listitem>
            </itemizedlist>
          </para>
          <para>If the tested value matches the pattern, taking into account wildcard symbols, the
          predicate is True.</para>
        </section>

        <section id="fblangref25-commons-escapechar">
          <title>Using the <database>ESCAPE</database> Character Option</title>
          <para>If the search string contains either of the wildcard symbols in it, you
          should specify a custom escape character in the <database>ESCAPE</database> clause.
          This custom escape character must be used in the pattern before the wildcard symbol,
          to register the fact that the standard wildcard symbol is to be interpreted as a
          literal character.</para>
        </section>

        <formalpara>
          <title>Examples using <database>LIKE</database></title>
            <orderedlist>
              <listitem>Find the numbers of departments whose names start with the
              word <quote>Software</quote>:
                <programlisting>
       SELECT DEPT_NO
       FROM DEPT
       WHERE DEPT_NAME LIKE 'Software%';
                </programlisting>
                <para>It is possible to use an index on the DEPT_NAME field if it exists.</para>
                <note>
                  <title>About <database>LIKE</database> and the Optimizer</title>
                  <para>Actually, the <database>LIKE</database> predicate does not use an index. However,
                  if the predicate takes the form of <function> LIKE 'string%' </function>, it will be
                  converted to the <database>STARTING WITH</database> predicate, which will use an index.</para>
                  <para>So&mdash;if you need to search for the beginning of a string, it is recommended to use the
                  STARTING WITH predicate instead of the LIKE predicate.</para>
                </note>
              </listitem>
              <listitem>Search for employees whose names consist of 5 letters, start with the letters <quote>Sm</quote>
              and end with <quote>th</quote>. The predicate will be true for such names as <quote>Smith</quote> and
              <quote>Smyth</quote>.
                <programlisting>
       SELECT
           first_name
       FROM
           employee
       WHERE first_name LIKE 'Sm_th'
                </programlisting>
              </listitem>
              <listitem>Search for all clients whose address contains the string <quote>Rostov</quote>:
                <programlisting>
       SELECT *
       FROM CUSTOMER
       WHERE ADDRESS LIKE '%Rostov%'
                </programlisting>
                <note>
                  <para>If you need to search for something <emphasis>enclosed inside</emphasis> a string
                  (<function> LIKE %Abc% </function>, use of the <database>CONTAINING</database> predicate is recommended,
                  in preference to the <database>LIKE</database> predicate.</para>
                </note>
              </listitem>
              <listitem>Search for tables containing the underscore character in their names. The <quote>#</quote>
              character is specified as the escape character in this case.
                <programlisting>
       SELECT
         RDB$RELATION_NAME
       FROM RDB$RELATIONS
       WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
                </programlisting>
              </listitem>
            </orderedlist>
          </formalpara>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-predstartwith"><database>STARTING WITH</database></link>,
            <link linkend="fblangref25-commons-predcontaining"><database>CONTAINING</database></link>,
            <link linkend="fblangref25-commons-predsiimilarto"><database>SIMILAR TO</database></link>
            </para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predstartwith">
          <title><database>STARTING WITH</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; [NOT] STARTING WITH &lt;value&gt;
            </programlisting>
          </formalpara>
          <para>The <database>STARTING WITH</database> predicate searches for a string
          or a string-like type that starts with the characters in its &lt;value&gt; argument.
          The search is case-sensitive.</para>
          <para>When <database>STARTING WITH</database> is used in the search conditions of
          DML queries, the Firebird optimizer can use an index on the searched column,
          if it exists.</para>
          <formalpara><title>Example</title>
            <para>Search for employees whose last names start with <quote>Jo</quote>:
              <programlisting>
       SELECT LAST_NAME, FIRST_NAME
       FROM EMPLOYEE
       WHERE LAST_NAME STARTING WITH 'Jo'
              </programlisting>
            </para>
          </formalpara>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-predlike"><database>LIKE</database></link></para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predcontaining">
          <title><database>CONTAINING</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; [NOT] CONTAINING &lt;value&gt;
            </programlisting>
          </formalpara>
          <para>The <database>CONTAINING</database> predicate searches for a string or a string-like
          type looking for the sequence of characters that matches its argument. It can be used for
          an alphanumeric (string-like) search on numbers and dates. A <database>CONTAINING</database>
          search is case-sensitive.</para>
          <para>When <database>CONTAINING</database> is used in the search conditions of DML queries,
          the Firebird optimizer can use an index on the searched column, if a suitable one exists.</para>
          <formalpara><title>Examples</title>
            <orderedlist>
              <listitem>Search for projects whose names contain the substring <quote>Map</quote>:
                <programlisting>
       SELECT *
       FROM PROJECT
       WHERE PROJ_NAME CONTAINING 'Map';
                </programlisting>
              Two rows with the names <quote>AutoMap</quote> and <quote>MapBrowser port</quote> are
              returned.</listitem>
              <listitem>Search for changes in salaries with the date containing number 84 (in this
              case, it means changes that took place in 1984):
                <programlisting>
       SELECT *
       FROM SALARY_HISTORY
       WHERE CHANGE_DATE CONTAINING 84;
                </programlisting>
              </listitem>
             </orderedlist>
          </formalpara>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-predlike"><database>LIKE</database></link></para>
          </formalpara>
        </section>

        <section id="fblangref25-commons-predsiimilarto">
          <title><database>SIMILAR TO</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       <replaceable>string-expression</replaceable> [NOT] SIMILAR TO &lt;pattern&gt; [ESCAPE &lt;escape-char&gt;]
       &lt;pattern&gt; ::= an SQL regular expression
       &lt;escape-char&gt; ::= a single character
            </programlisting>
          </formalpara>
          <para>SIMILAR TO matches a string against an SQL regular expression pattern.
          Unlike in some other languages, the pattern must match the entire string in
          order to succeed&mdash;matching a substring is not enough. If any operand is
          <database>NULL</database>, the result is <database>NULL</database>. Otherwise,
          the result is <database>TRUE</database> or <database>FALSE</database>.</para>

          <section id="fblangref25-commons-syntaxregex">
            <title>Syntax: SQL Regular Expressions</title>
            <para>The following syntax defines the SQL regular expression format. It is a
            complete and correct top-down definition. It is also highly formal, rather
            long and probably perfectly fit to discourage everybody who hasn't already
            some experience with regular expessions (or with highly formal, rather long
            top-down definitions). Feel free to skip it and read the next section,
            <link linkend="fblangref25-commons-buildregex">Building Regular Expressions</link>, which uses a
            bottom-up approach, aimed at the rest of us.</para>
            <programlisting>
  &lt;regular expression&gt; ::= &lt;regular term&gt; ['|' &lt;regular term&gt; ...]

  &lt;regular term&gt; ::= &lt;regular factor&gt; ...

  &lt;regular factor&gt; ::= &lt;regular primary&gt; [&lt;quantifier&gt;]

  &lt;quantifier&gt; ::= ?
               | *
               | +
               | '{' &lt;m&gt; [,[&lt;n&gt;]] '}'

  &lt;m&gt;, &lt;n&gt; ::= unsigned int, with &lt;m&gt; &lt;= &lt;n&gt; if both present

  &lt;regular primary&gt; ::= &lt;character&gt;
                    | &lt;character class&gt;
                    | %
                    | (&lt;regular expression&gt;)

  &lt;character&gt; ::= &lt;escaped character&gt;
              | &lt;non-escaped character&gt;

  &lt;escaped character&gt; ::= &lt;escape-char&gt; &lt;special character&gt;
                      | &lt;escape-char&gt; &lt;escape-char&gt;

  &lt;special character&gt; ::= any of the characters []()|^-+*%_?{

  &lt;non-escaped character&gt; ::= any character that is not a &lt;special character&gt;
                            and not equal to &lt;escape-char&gt; (if defined)
  &lt;character class&gt; ::= '_'
                    | '[' &lt;member&gt; ... ']'
                    | '[^' &lt;non-member&gt; ... ']'
                    | '[' &lt;member&gt; ... '^' &lt;non-member&gt; ... ']'

  &lt;member&gt;, &lt;non-member&gt; ::= &lt;character&gt;
                         | &lt;range&gt;
                         | &lt;predefined class&gt;

  &lt;range&gt; ::= &lt;character&gt;-&lt;character&gt;

  &lt;predefined class&gt; ::= '[:' &lt;predefined class name&gt; ':]'

  &lt;predefined class name&gt; ::= ALPHA | UPPER | LOWER | DIGIT
                             | ALNUM | SPACE | WHITESPACE

            </programlisting>
          </section>
          <section id="fblangref25-commons-buildregex">
            <title>Building Regular Expressions</title>
            <para>In this section are the elements and rules for building
            SQL regular expressions.</para>
            <section id="fblangref25-commons-regexchar">
              <title>Characters</title>
              <para>Within regular expressions, most characters represent themselves.
              The only exceptions are the special characters below:
                <literallayout><command>
       [ ] ( ) | ^ - + * % _ ? {
                </command></literallayout>
              ...and the escape character, if it is defined.</para>
              <para>A regular expression that contain no special or escape characters matches only
              strings that are identical to itself (subject to the collation in use). That is,
              it functions just like the <quote><command>=</command></quote> operator:
                <programlisting>
       'Apple' similar to 'Apple' -- true
       'Apples' similar to 'Apple' -- false
       'Apple' similar to 'Apples' -- false
       'APPLE' similar to 'Apple' -- depends on collation
                </programlisting>
              </para>
            </section><!-- regex characters -->

            <section id="fblangref25-commons-regexwildcards">
              <title>Wildcards</title>
              <para>The known SQL wildcards <command>_</command> and <command>%</command> match
              any single character and a string of any length, respectively:
                <programlisting>
       'Birne' similar to 'B_rne' -- true
       'Birne' similar to 'B_ne' -- false
       'Birne' similar to 'B%ne' -- true
       'Birne' similar to 'Bir%ne%' -- true
       'Birne' similar to 'Birr%ne' -- false
                </programlisting>
              Notice how % also matches the empty string.</para>
            </section> <!-- regex wildcards -->

            <section id="fblangref25-commons-regexcharclass">
              <title>Character Classes</title>
              <para>A bunch of characters enclosed in brackets define a character class. A character
              in the string matches a class in the pattern if the character is a member of the class:
                <programlisting>
       'Citroen' similar to 'Cit[arju]oen'     -- true
       'Citroen' similar to 'Ci[tr]oen'        -- false
       'Citroen' similar to 'Ci[tr][tr]oen'    -- true
                </programlisting>
              As can be seen from the second line, the class only matches a single character,
              not a sequence.</para>
              <para>Within a class definition, two characters connected by a hyphen define a range.
              A range comprises the two endpoints and all the characters that lie between them in the
              active collation. Ranges can be placed anywhere in the class definition without special
              delimiters to keep them apart from the other elements.
                <programlisting>
       'Datte' similar to 'Dat[q-u]e'          -- true
       'Datte' similar to 'Dat[abq-uy]e'       -- true
       'Datte' similar to 'Dat[bcg-km-pwz]e'   -- false
                </programlisting>
              </para>

              <section id="fblangref25-commons-regexpredefclass">
                <title>Predefined Character Classes</title>
                <para>The following predefined character classes can also be used in a class definition:
                  <formalpara><title>[:ALPHA:]</title>
                    <para>Latin letters a..z and A..z. With an accent-insensitive collation, this class
                    also matches accented forms of these characters.</para>
                  </formalpara>

                  <formalpara><title>[:DIGIT:]</title>
                    <para>Decimal digits 0..9.</para>
                  </formalpara>

                  <formalpara><title>[:ALNUM:]</title>
                    <para>Union of [:ALPHA:] and [:DIGIT:].</para>
                  </formalpara>

                  <formalpara><title>[:UPPER:]</title>
                    <para>Uppercase Latin letters A..Z. Also matches lowercase with case-insensitive
                    collation and accented forms with accent-insensitive collation.</para>
                  </formalpara>

                  <formalpara><title>[:LOWER:]</title>
                    <para>Lowercase Latin letters a..z. Also matches uppercase with case-insensitive
                    collation and accented forms with accent-insensitive collation.</para>
                  </formalpara>

                  <formalpara><title>[:SPACE:]</title>
                    <para>Matches the space character (ASCII 32).</para>
                  </formalpara>

                  <formalpara><title>[:WHITESPACE:]</title>
                    <para>Matches vertical tab (ASCII 9), linefeed (ASCII 10), horizontal
                    tab (ASCII 11), formfeed (ASCII 12), carriage return (ASCII 13) and space (ASCII 32).</para>
                  </formalpara>
                </para>
                <para>Including a predefined class has the same effect as including all its members.
                Predefined classes are only allowed within class definitions. If you need to match
                against a predefined class and nothing more, place an extra pair of brackets around it.
                  <programlisting>
       'Erdbeere' similar to 'Erd[[:ALNUM:]]eere'     -- true
       'Erdbeere' similar to 'Erd[[:DIGIT:]]eere'     -- false
       'Erdbeere' similar to 'Erd[a[:SPACE:]b]eere'   -- true
       'Erdbeere' similar to [[:ALPHA:]]              -- false
       'E'        similar to [[:ALPHA:]]              -- true
                  </programlisting>
              If a class definition starts with a caret, everything that follows is excluded from the
              class. All other characters match:
                  <programlisting>
       'Framboise' similar to 'Fra[^ck-p]boise'       -- false
       'Framboise' similar to 'Fr[^a][^a]boise'       -- false
       'Framboise' similar to 'Fra[^[:DIGIT:]]boise'  -- true
                  </programlisting>
              If the caret is not placed at the start of the sequence, the class contains everything 
              before the caret, except for the elements that also occur after the caret:
                  <programlisting>
       'Grapefruit' similar to 'Grap[a-m^f-i]fruit'   -- true
       'Grapefruit' similar to 'Grap[abc^xyz]fruit'   -- false
       'Grapefruit' similar to 'Grap[abc^de]fruit'    -- false
       'Grapefruit' similar to 'Grap[abe^de]fruit'    -- false

       '3' similar to '[[:DIGIT:]^4-8]'               -- true
       '6' similar to '[[:DIGIT:]^4-8]'               -- false
                  </programlisting>
              Lastly, the already mentioned wildcard <quote>_</quote> is a character class of its own,
              matching any single character.
                </para>
              </section>
            </section> <!-- regex character classes -->

            <section id="fblangref25-commons-regexquantifiers">
              <title>Quantifiers</title>
              <para>A question mark immediately following a character or class indicates that the
              preceding item may occur 0 or 1 times in order to match:
                <programlisting>
       'Hallon' similar to 'Hal?on'                   -- false
       'Hallon' similar to 'Hal?lon'                  -- true
       'Hallon' similar to 'Halll?on'                 -- true
       'Hallon' similar to 'Hallll?on'                -- false
       'Hallon' similar to 'Halx?lon'                 -- true
       'Hallon' similar to 'H[a-c]?llon[x-z]?'        -- true
                </programlisting>
              An asterisk immediately following a character or class indicates that the preceding
              item may occur 0 or more times in order to match:
                <programlisting>
       'Icaque' similar to 'Ica*que'                  -- true
       'Icaque' similar to 'Icar*que'                 -- true
       'Icaque' similar to 'I[a-c]*que'               -- true
       'Icaque' similar to '_*'                       -- true
       'Icaque' similar to '[[:ALPHA:]]*'             -- true
       'Icaque' similar to 'Ica[xyz]*e'               -- false
                </programlisting>
              A plus sign immediately following a character or class indicates that the preceding
              item must occur 1 or more times in order to match:
                <programlisting>
       'Jujube' similar to 'Ju_+'                     -- true
       'Jujube' similar to 'Ju+jube'                  -- true
       'Jujube' similar to 'Jujuber+'                 -- false
       'Jujube' similar to 'J[jux]+be'                -- true
       'Jujube' sililar to 'J[[:DIGIT:]]+ujube'       -- false
                </programlisting>
              If a character or class is followed by a number enclosed in braces, it must be
              repeated exactly that number of times in order to match:
                <programlisting>
       'Kiwi' similar to 'Ki{2}wi'                    -- false
       'Kiwi' similar to 'K[ipw]{2}i'                 -- true
       'Kiwi' similar to 'K[ipw]{2}'                  -- false
       'Kiwi' similar to 'K[ipw]{3}'                  -- true
                </programlisting>
              If the number is followed by a comma, the item must be repeated at least that
              number of times in order to match:
                <programlisting>
       'Limone' similar to 'Li{2,}mone'               -- false
       'Limone' similar to 'Li{1,}mone'               -- true
       'Limone' similar to 'Li[nezom]{2,}'            -- true
                </programlisting>
              If the braces contain two numbers seperated by a comma, the second number not
              smaller than the first, then the item must be repeated at least the first
              number and at most the second number of times in order to match:
                <programlisting>
       'Mandarijn' similar to 'M[a-p]{2,5}rijn'       -- true
       'Mandarijn' similar to 'M[a-p]{2,3}rijn'       -- false
       'Mandarijn' similar to 'M[a-p]{2,3}arijn'      -- true
                </programlisting>
              The quantifiers ?, * and + are shorthand for {0,1}, {0,} and {1,},
              respectively.
              </para>
            </section> <!-- regex quantifiers -->

            <section id="fblangref25-commons-regexoring">
              <title>OR-ing Terms</title>
              <para>Regular expression terms can be OR'ed with the | operator. A match is made
              when the argument string matches at least one of the terms:
                <programlisting>
       'Nektarin' similar to 'Nek|tarin'              -- false
       'Nektarin' similar to 'Nektarin|Persika'       -- true
       'Nektarin' similar to 'M_+|N_+|P_+'            -- true
                </programlisting>
              </para>
            </section> <!-- OR-ing terms -->

            <section id="fblangref25-commons-regexsubexpr">
              <title>Subexpressions</title>
              <para>One or more parts of the regular expression can be grouped into subexpressions
              (also called subpatterns) by placing them between parentheses. A subexpression is a
              regular expression in its own right. It can contain all the elements allowed in a
              regular expression, and can also have quantifiers added to it.
                <programlisting>
       'Orange' similar to 'O(ra|ri|ro)nge'           -- true
       'Orange' similar to 'O(r[a-e])+nge'            -- true
       'Orange' similar to 'O(ra){2,4}nge'            -- false
       'Orange' similar to 'O(r(an|in)g|rong)?e'      -- true
                </programlisting>
              </para>
            </section> <!-- subexpressions -->
            <section id="fblangref25-commons-regexescap">
              <title>Escaping Special Characters</title>
              <para>In order to match against a character that is special in regular expressions,
              that character has to be escaped. There is no default escape character; rather, the
              user specifies one when needed:
                <programlisting>
'Peer (Poire)' similar to 'P[^ ]+ \(P[^ ]+\)' escape '\'    -- true
'Pera [Pear]'  similar to 'P[^ ]+ #[P[^ ]+#]' escape '#'    -- true
                </programlisting>
              The last line demonstrates that the escape character can also escape
              itself, if needed.
              </para>
            </section> <!-- escaping special chars -->
          </section> <!-- Building regex expr -->
        </section><!-- Similar To -->

        <section id="fblangref25-commons-isnotdistinct">
          <title><database>IS [NOT] DISTINCT FROM</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       <replaceable>operand1</replaceable> IS [NOT] DISTINCT FROM <replaceable>operand2</replaceable>
            </programlisting>
          </formalpara>
          <para>Two operands are considered DISTINCT if they have a different value or if one of them
          is NULL and the other non-null. They are NOT DISTINCT if they have the same value or if both
          of them are NULL.</para>
          <formalpara><title>See also</title>
            <para><link linkend="fblangref25-commons-isnotnull"><database>IS [NOT] NULL</database></link></para>
          </formalpara>
        </section> <!-- is not distinct from -->

        <section id="fblangref25-commons-isnotnull">
          <title><database>IS [NOT] NULL</database></title>
          <formalpara><title>Available</title>
            <para>DSQL, PSQL</para>
          </formalpara>
          <formalpara><title>Syntax</title>
            <programlisting>
       &lt;value&gt; IS [NOT] NULL
            </programlisting>
          </formalpara>
          <para>Since NULL is not a value, these operators are not comparison operators. The
          <database>IS [NOT] NULL</database> predicate tests the assertion that the expression on
          the left side has a value (IS NOT NULL) or has no value (IS NULL).</para>
          <formalpara><title>Example</title>
            <para>&nbsp;Search for sales entries that have no shipment date set for them:
              <programlisting>
       SELECT * FROM SALES
         WHERE SHIP_DATE IS NULL;
              </programlisting>
            </para>
          </formalpara>
        </section> <!-- is not null -->
      </section><!-- Other comparison predicates -->
    </section><!-- Comparison predicates -->

    <section id="fblangref25-commons-existential">
      <title>Existential Predicates</title>
      <para>This group of predicates includes those that use subqueries to submit values for all
      kinds of assertions in search conditions. Existential predicates are so called because they
      use various methods to test the existence of the value on the left side of the predicate in
      the output results of subqueries on the right.</para>

      <section id="fblangref25-commons-exists">
        <title><database>EXISTS</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       [NOT] EXISTS(&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>The <database>EXISTS</database> predicate uses a subquery expression as its argument.
        It evaluates it as True if the subquery result contains one or more rows of data; otherwise
        it is evaluated as False. The subquery result may contain several columns because the values
        are not tested: the predicate tests the fact of the existence of any number of matching rows
        that is greater than none.</para>
        <formalpara><title>Examples</title>
          <orderedlist>
            <listitem>Find those employees who have projects.
              <programlisting>
       SELECT *
       FROM employee
       WHERE EXISTS(SELECT *
                    FROM  employee_project ep
                    WHERE ep.emp_no = employee.emp_no)
              </programlisting>
            </listitem>
            <listitem>Find those employees who have no projects.
              <programlisting>
       SELECT *
       FROM employee
       WHERE NOT EXISTS(SELECT *
                        FROM employee_project ep
                        WHERE ep.emp_no = employee.emp_no)
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
      </section>

      <section id="fblangref25-commons-in">
        <title><database>IN</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       &lt;value&gt; [NOT] IN(&lt;select_stmt&gt; | &lt;value_list&gt;)

       &lt;value_list&gt; ::= &lt;value_1&gt; [, &lt;value_2&gt; &hellip;]
          </programlisting>
        </formalpara>
        <para>The <database>IN</database> predicate tests whether the value of the expression on the left
        side is present in the set of values specified on the right side. The set of values cannot have
        more than 1500 items. The <database>IN</database> predicate could be replaced with the following
        equivalent form:
          <programlisting>
       (&lt;value&gt; = &lt;value_1&gt; [OR &lt;value&gt; = &lt;value_2&gt; &hellip;])
          </programlisting>
        When the <database>IN</database> predicate is used in the search conditions of DML queries,
        the Firebird optimizer can use an index on the searched column, if a suitable one exists.</para>

        <para>In its second form, the <database>IN</database> predicate tests whether the value of the
        expression on the left side is present (or not present, if <database>NOT IN</database> is used)
        in the result of the executed subquery on the right side.</para>
        <para>The subquery must be specified to result in only one column, otherwise the error
        <quote>count of column list and variable list do not match</quote> will occur.</para>

        <para>Queries specified using the <database>IN</database> predicate with a subquery can be
        replaced with a similar query using the <database>EXISTS</database> predicate.
        For instance, the following query:
          <programlisting>
       SELECT
         model, speed, hd
       FROM PC
       WHERE
       model IN (SELECT model
                   FROM product
                   WHERE maker = 'A');
          </programlisting>
        can be replaced with a similar one using the EXISTS predicate:
          <programlisting>
       SELECT
         model, speed, hd
       FROM PC
       WHERE
         EXISTS (SELECT *
                 FROM product
                   WHERE maker = 'A'
                   AND product.model = PC.model);
          </programlisting>
        However, this trick will not work with the <database>NOT IN</database> predicate, as illustrated
        in the next example. It can be seen in the following example. Suppose you have the following query:
          <programlisting>
       -- Looking for people who were not born
       -- on the same day as any famous New York citizen
       SELECT P1.name AS NAME
       FROM Personnel P1
       WHERE P1.birthday NOT IN (SELECT C1.birthday
                                 FROM Celebrities C1
                                 WHERE C1.birthcity = 'New York');
          </programlisting>
        It might be assumed that a query with the <database>NOT EXISTS</database> predicate
        would produce the same result:
          <programlisting>
       -- Looking for people who were not born
       -- on the same day as any famous New York citizen
       SELECT P1.name AS NAME
       FROM Personnel P1
       WHERE NOT EXISTS (SELECT *
                         FROM Celebrities C1
                         WHERE C1.birthcity = 'New York'
                           AND C1.birthday = P1.birthday);
          </programlisting>
        </para>
        <para>But&mdash;suppose there is only one famous citizen in New York and this citizen's birth date is
        unknown. If we use the <database>EXISTS</database> predicate, the embedded subquery
        will not return any results because birth dates compared to NULL will return UNKNOWN.
        That leads to the situation where the result of the <database>NOT EXISTS</database> predicate
        will be true for every row of the main query. From the same data the <database>NOT IN</database>
        predicate correctly returns TRUE no match is found.
        </para>
        <formalpara><title>Examples of use</title>
          <orderedlist>
            <listitem>Find employees with the names <quote>Pete</quote>, <quote>Ann</quote>
            and <quote>Roger</quote>:
              <programlisting>
       SELECT *
       FROM EMPLOYEE
       WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
              </programlisting>
            </listitem>
            <listitem>Find all computers that have models whose manufacturer starts with
            the letter <quote>A</quote>:
              <programlisting>
       SELECT
          model, speed, hd
       FROM PC
       WHERE
         model IN (SELECT model
                   FROM product
                   WHERE maker STARTING WITH 'A');
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
        <formalpara><title>See also</title>
          <para><link linkend="fblangref25-commons-exists">EXISTS</link></para>
        </formalpara>
      </section>

      <section id="fblangref25-commons-singular">
        <title><database>SINGULAR</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       [NOT] SINGULAR(&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>The <database>SINGULAR</database> predicate takes a subquery as its argument
        and evaluates it as True if the subquery returns exactly one result row; otherwise
        the predicate is evaluated as False. The subquery may return several columns since
        the values are not tested. This predicate can accept only two values: TRUE
        and FALSE.</para>
        <formalpara><title>Example</title>
          <para>&nbsp;Find those employees who have only one project.
            <programlisting>
       SELECT *
       FROM employee
       WHERE SINGULAR(SELECT *
                      FROM
                        employee_project ep
                      WHERE
                        ep.emp_no = employee.emp_no)
            </programlisting>
          </para>
        </formalpara>
      </section>
    </section> <!-- Existential Predicates -->

    <section id="fblangref25-commons-quantifiedsq">
      <title><database>Quantified Subquery Predicates</database></title>
      <para>A quantifier is a logical operator that sets the number of objects for which
      this assertion is true. It is not a numeric quantity, but a logical one that connects
      the assertion with the full set of possible objects. Such predicates are based on
      logical universal and existential quantifiers that are recognised in formal
      logic.</para>
      <para>In subquery expressions, quantified predicates make it possible to compare
      separate values with the results of subqueries; they have the following common form:
        <programlisting>
       &lt;value expression&gt; &lt;comparison operator&gt; &lt;quantifier&gt; &lt;subquery&gt;
        </programlisting>
      </para>

      <section id="fblangref25-commons-quant-all">
        <title><database>ALL</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       &lt;value&gt; &lt;op&gt; ALL(&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>When the <database>ALL</database> quantifier is used, the predicate is True
        if each value returned by the subquery satisfies the condition in the predicate of
        the main query. The assertion is true only if the subquery could not return at
        least one row;  in all other cases, it returns false.</para>
        <formalpara><title>Example</title>
          <para>&nbsp;Show only those clients whose ratings are higher than the rating of every
          client in Paris.
            <programlisting>
       SELECT c1.*
       FROM Customers c1
       WHERE c1.rating &gt; ALL
             (SELECT c2.rating
              FROM Customers c2
              WHERE c2.city = 'Paris')
            </programlisting>
          </para>
        </formalpara>
      </section>

      <section id="fblangref25-commons-quant-anysome">
        <title><database>ANY</database> and <database>SOME</database></title>
        <formalpara><title>Available</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara><title>Syntax</title>
          <programlisting>
       &lt;value&gt; &lt;op&gt; {ANY | SOME} (&lt;select_stmt&gt;)
          </programlisting>
        </formalpara>
        <para>The quantifiers <database>ANY</database> and <database>SOME</database> are
        identical in their behaviour. Apparently, both are present in the SQL standard
        so that they could be used interchangeably in order to improve the readability
        of operators. When the <database>ANY</database> or the <database>SOME</database>
        quantifier is used, the predicate is true if any of the values returned by the
        subquery satisfies the condition in the predicate of the main query. If the
        subquery would return no rows at all, the predicate is automatically considered
        as False.</para>
        <formalpara><title>Example</title>
          <para>&nbsp;Show only those clients whose ratings are higher than those of one or
          more clients in Rome.
            <programlisting>
       SELECT *
       FROM Customers
       WHERE rating &gt; ANY
             (SELECT rating
              FROM Customers
              WHERE city = 'Rome')
            </programlisting>
          </para>
        </formalpara>
      </section>
    </section><!-- quantified subquery predicates -->
  </section> <!-- Predicates  -->

</chapter>
