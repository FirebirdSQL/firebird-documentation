<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="fblangref25-ddl">
  <title>Data Definition (DDL) Statements</title>
  <para>DDL is the data definition language subset of Firebird's SQL language.
  DDL statements are used to create, modify and delete database objects that have
  been created by users.  When a DDL statement is committed, the metadata for the
  object are created, changed or deleted.</para>

  <section id="fblangref25-ddl-db">
    <title><database>DATABASE</database></title>
    <para>This section describes how to create a database, connect to an existing database,
    alter the file structure of a database and how to delete one.  It also explains how to back up
    a database in two quite different ways and how to switch the database to the <quote>copy-safe</quote>
    mode for performing an external backup safely.</para>
    <section id="fblangref25-ddl-db-create">
      <title><database>CREATE DATABASE</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <programlisting>
       CREATE {DATABASE | SCHEMA} '&lt;<replaceable>filespec</replaceable>&gt;'
       [USER <replaceable>'username'</replaceable> [PASSWORD <replaceable>'password'</replaceable>]]
       [PAGE_SIZE [=] <replaceable>size</replaceable>]
       [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]
       [SET NAMES '<replaceable>charset</replaceable>'] 
       [DEFAULT CHARACTER SET <replaceable>default_charset</replaceable>
         [COLLATION <replaceable>collation</replaceable>]] -- not supported in ESQL
       [&lt;<replaceable>sec_file</replaceable>&gt; [&lt;<replaceable>sec_file</replaceable>&gt; ...]]
       [DIFFERENCE FILE '<replaceable>diff_file</replaceable>']; -- not supported in ESQL

       &lt;<replaceable>filespec</replaceable>&gt; ::= [&lt;<replaceable>server_spec</replaceable>&gt;]{<replaceable>filepath</replaceable> | <replaceable>db_alias</replaceable>}

       &lt;<replaceable>server_spec</replaceable>&gt; ::= <replaceable>servername [/{port|service}]:</replaceable> | <replaceable>\\servername\</replaceable>

       &lt;<replaceable>sec_file</replaceable>&gt; ::= FILE '<replaceable>filepath</replaceable>'
       [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]] [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]
        </programlisting>
      </formalpara>

      <table id="fblangref25-ddl-tbl-createdatabase">
      <?dbfo keep-together='auto'?>
        <title>CREATE DATABASE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">filespec</entry>
              <entry align="left">File specification for primary database file</entry>
            </row>
            <row valign="middle">
              <entry align="center">server_spec</entry>
              <entry align="left">Remote server specification in TCP/IP or Windows Networking
              style.  Optionally includes a port number or service name</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Full path and file name including its extension. The file
              name must be specified according to the rules of the platform file system being
              used.</entry>
            </row>
            <row valign="middle">
              <entry align="center">db_alias</entry>
              <entry align="left">Database alias previously created in
              the <filename>aliases.conf</filename> file</entry>
            </row>
            <row valign="middle">
              <entry align="center">servername</entry>
              <entry align="left">Host name or IP address of the server where the database
              is to be created</entry>
            </row>
            <row valign="middle">
              <entry align="center">username</entry>
              <entry align="left">User name of the owner of the new database. It may consist
              of up to 31 characters. Case-insensitive</entry>
            </row>
            <row valign="middle">
              <entry align="center">password</entry>
              <entry align="left">Password of the user name as the database owner. The maximum 
              length is 31 characters;  however only the first 8 characters are considered. 
              Case-sensitive</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">Page size for the database, in bytes. Possible values are 4096
              (the default), 8192 and 16384</entry>
            </row>
            <row valign="middle">
              <entry align="center">num</entry>
              <entry align="left">Maximum size of the primary database file, or a secondary
              file, in pages</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Specifies the character set of the connection available to
              a client connecting after the database is successfully created. Single quotes 
              are required</entry>
            </row>
            <row valign="middle">
              <entry align="center">default_charset</entry>
              <entry align="left">Specifies the default character set for string data types</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Default collation for the default character set</entry>
            </row>
            <row valign="middle">
              <entry align="center">sec_file</entry>
              <entry align="left">File specificaton for a secondary file</entry>
            </row>
            <row valign="middle">
              <entry align="center">pagenum</entry>
              <entry align="left">Starting page number for a secondary database file</entry>
            </row>
            <row valign="middle">
              <entry align="center">diff_file</entry>
              <entry align="left">File path and name for DIFFERENCE files (.delta files)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE DATABASE</database> statement creates a new database. You can
      use <database>CREATE DATABASE</database> or <database>CREATE SCHEMA</database>. They
      are synonymous.</para>
      <para>A database may consist of one or several files. The first (main) file is called
      the <emphasis>primary file</emphasis>, subsequent files are called
      <emphasis>secondary file[s]</emphasis>.</para>
      <note>
        <title>Multi-file Databases</title>
        <para>Nowadays, multi-file databases are considered a throwback. It made sense to use
        multi-file databases on old file systems where the size of any file is limited. For
        instance, you could not create a file larger than 4 GB on FAT32.</para>
      </note>
      <para>The primary file specification is the name of the database file and its extension
      with the full path to it according to the rules of the OS platform file system being used.
      The database file must not exist at the moment when the database is being created. If it
      does exist, you will get an error message and the database will not be created.</para>
      <para>If the full path to the database is not specified, the database will be created
      in one of the system directories. The particular directory depends on the operating system.
      For this reason, unless you have a strong reason to prefer that situation, always specify
      the absolute path, when creating either the database or an <emphasis>alias</emphasis> for it.</para>

      <section id="fblangref25-ddl-db-alias">
        <title>Using a Database Alias</title>
        <para>You can use aliases instead of the full path to the primary database file. Aliases
        are defined in the <filename> aliases.conf </filename> file in the following format:
          <literallayout class="monospaced">
       alias = filepath
          </literallayout>
        </para>
      </section>

      <section id="fblangref25-ddl-db-createremote">
        <title>Creating a Database Remotely</title>
        <para>If you create a database on a remote server, you should specify the remote server
        specification. The remote server specification depends on the protocol being used.
        If you use the TCP/IP protocol to create a database, the primary file specification
        should look like this:
        <blockquote>
          <programlisting>
servername[/{port|service}]:{filepath | db_alias}
          </programlisting>
        </blockquote>
        If you use the Named Pipes protocol to create a database on a Windows server, the
        primary file specification should look like this:
        <blockquote>
          <programlisting>
\\servername\{filepath | db_alias}
          </programlisting>
        </blockquote>
        </para>
      </section>

      <section id="fblangref25-ddl-db-createdbopts">
        <title>Optional Parameters for <database>CREATE DATABASE</database></title>
        <formalpara><title>Optional <database>USER</database> and <database>PASSWORD</database></title>
          <para>Clauses for specifying the user name and the password, respectively, of an existing
          user in the security database <filename>security2.fdb</filename>. You do not have to specify
          the username and password if the <database>ISC_USER</database> and <database>ISC_PASSWORD</database>
          environment variables are set. The user specified in the process of creating the database
          will be its owner.  This will be important when considering database and object privileges.</para>
        </formalpara>
        <formalpara><title>Optional <database>PAGE_SIZE</database></title>
          <para>Clause for specifying the database page size. This size will be set for the primary file
          and all secondary files of the database. If you specify the database page size less than 4,096,
          it will be changed automatically to the default page size, 4,096. Other values not equal to
          either 4,096, 8,192 or 16,384 will be changed to the closest smaller supported value.&nbsp;If 
          the database page size is not specified, it is set to the default value of 4,096.</para>
        </formalpara>
        <formalpara><title>Optional <database>LENGTH</database></title>
          <para>Clause specifying the maximum size of the primary or secondary database file,
          in pages. When a database is created, its primary and secondary files will occupy the minimum number
          of pages necessary to store the system data, regardless of the value specified in the
          <database>LENGTH</database> clause. The <database>LENGTH</database> value does not affect the size
          of the only (or last, in a multi-file database) file. The file will keep increasing its size
          automatically when necessary.</para>
        </formalpara>
        <formalpara><title>Optional <database>SET NAMES</database></title>
          <para>Clause specifying the character set of the connection available after the database is 
          successfully created. The character set <database>NONE</database> is used by default. Notice 
          that the character set should be enclosed in a pair of apostrophes (single quotes).</para>
        </formalpara>
        <formalpara><title>Optional <database>DEFAULT CHARACTER SET</database></title>
          <para>Clause specifying the default character set for creating data structures of string data types.
          Character sets are applied to <database>CHAR</database>, <database>VARCHAR</database>
          and  <database>BLOB TEXT</database> data types. The character set <database>NONE</database>
          is used by default. It is also possible to specify the default <database>COLLATION</database>
          for the default character set, making that collation sequence the default for the default
          character set.  The default will be used for the entire database except where an alternative
          character set, with or without a specified collation, is used explicitly for a field, domain,
          variable, cast expression, etc.</para>
        </formalpara>
        <formalpara><title><database>STARTING AT</database></title>
          <para>Clause that specifies the database page number at
          which the next secondary database file should start. When the previous file is completely filled
          with data according to the specified page number, the system will start adding new data to the
          next database file.</para>
        </formalpara>
        <formalpara><title>Optional <database>DIFFERENCE FILE</database></title>
          <para><database></database>Clause specifying the path and name for the file delta that stores
          any mutations to the database file after it has been switched to the <quote>copy-safe</quote>
          mode by the <database>ALTER DATABASE BEGIN BACKUP</database> statement. For the detailed
          description of this clause, see <database>ALTER DATABASE</database>.</para>
        </formalpara>
        <formalpara><title><database>SET SQL DIALECT</database></title>
          <para>Databases are created in Dialect 3 by default. For the database to be created in
          SQL dialect 1, you will need to execute the statement <database>SET SQL DIALECT 1</database>
          from script or the client application, e.g. <emphasis>isql</emphasis>, before
          the <database>CREATE DATABASE</database> statement.</para>
        </formalpara>
      </section>

      <section id="fblangref25-ddl-db-createdbexamples">
        <title>Examples Using <database>CREATE DATABASE</database></title>
        <orderedlist>
          <listitem>Creating a database in Windows, located on disk D with a page size of 8,192.
          The owner of the database will be the user <emphasis>wizard</emphasis>. The database will
          be in Dialect 1 and it will use <database>WIN1251</database> as its default character set.
            <programlisting>
SET SQL DIALECT 1;
CREATE DATABASE 'D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192 DEFAULT CHARACTER SET WIN1251;
            </programlisting>
          </listitem>
          <listitem>Creating a database in the Linux operating system with a page size of 4,096.
          The owner of the database will be the user <emphasis>wizard</emphasis>. The database will
          be in Dialect 3 and it will use <database>UTF8</database> as its default character
          set, with <database>UNICODE_CI_AI</database> as the default collation.
            <programlisting>
CREATE DATABASE '/home/firebird/test.fdb'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8 COLLATION UNICODE_CI_AI;
            </programlisting>
          </listitem>
          <listitem>Creating a database on the remote server <quote>baseserver</quote> with the
          path specified in the alias <quote>test</quote> that has been defined previously in the file
          <filename>aliases.conf</filename>. The TCP/IP protocol is used. The owner of the database
          will be the user <emphasis>wizard</emphasis>. The database will be in Dialect 3 and will
          use <database>UTF8</database> as its default character set.
            <programlisting>
CREATE DATABASE 'baseserver:test'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8;
            </programlisting>
          </listitem>
          <listitem>Creating a database in Dialect 3 with <database>UTF8</database> as its default
          character set. The primary file will contain up to 10,000 pages with a page size of
          8,192. As soon as the primary file has reached the maximum number of pages, Firebird will
          start allocating pages to the secondary file <filename>test.fdb2</filename>.  If that file
          is filled up to its maximum as well, <filename>test.fdb3</filename> becomes the recipient
          of all new page allocations.  As the last file, it has no page limit imposed on it by
          Firebird.  New allocations will continue for as long as the file system allows it or
          until the storage device runs out of free space. If a <database>LENGTH</database> parameter
          were supplied for this last file, it would be ignored.
            <programlisting>
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
STARTING AT PAGE 10001
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
            </programlisting>
          </listitem>
          <listitem>Creating a database in Dialect 3 with <database>UTF8</database> as its default
          character set. The primary file will contain up to 10,000 pages with a page size of
          8,192. As far as file size and the use of secondary files are concerned, this database
          will behave exactly like the one in the previous example.
            <programlisting>
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
LENGTH 10000 PAGES
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
            </programlisting>
          </listitem>
        </orderedlist>
        <formalpara><title>See also</title>
          <para><link linkend="fblangref25-ddl-db-alter"><database>ALTER DATABASE</database></link>,
          <link linkend="fblangref25-ddl-db-drop"><database>DROP DATABASE</database></link></para>
        </formalpara>
      </section>
    </section> <!-- CREATE DATABASE -->

    <section id="fblangref25-ddl-db-alter">
      <title><database>ALTER DATABASE</database></title>
      <formalpara><title>Used for</title>
        <para>Altering the file organisation of a database or toggling its
        <quote>copy-safe</quote> state</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL&mdash;both functions. ESQL&mdash;file reorganisation only</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER {DATABASE | SCHEMA}
[&lt;add_sec_clause&gt; [&lt;add_sec_clause&gt; ...]]
[ADD DIFFERENCE FILE 'diff_file' | DROP DIFFERENCE FILE]
[{BEGIN | END} BACKUP];

&lt;add_sec_clause&gt; ::= ADD &lt;sec_file&gt; [&lt;sec_file&gt; ...]

&lt;sec_file&gt; ::= FILE 'filepath'

ADD FILE &lt;sec_file&gt;

          [STARTING [AT [PAGE]] pagenum]
          [LENGTH [=] num [PAGE[S]]
        </programlisting></blockquote>
      </formalpara>
      <note>
        <para>Multiple files can be added in one ADD clause:
          <literallayout class="monospaced">
  ALTER DATABASE
    ADD FILE x LENGTH 8000
        FILE y LENGTH 8000
        FILE z
          </literallayout>
        Multiple <database>ADD FILE</database> clauses are allowed;  and an
        <database>ADD FILE</database> clause that adds multiple files (as
        in the example above) can be mixed with others that add only one
        file.  The statement was incorrectly documented in the old <citetitle>InterBase 
        6 Language Reference</citetitle>.</para>
      </note>
      <table id="fblangref25-ddl-tbl-alterdatabase">
      <?dbfo keep-together='auto'?>
        <title>ALTER DATABASE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">add_sec_clause</entry>
              <entry align="left">Adding a secondary database file</entry>
            </row>
            <row valign="middle">
              <entry align="center">sec_file</entry>
              <entry align="left">File specification for secondary file</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Full path and file name of the delta file or the secondary database file</entry>
            </row>
            <row valign="middle">
              <entry align="center">pagenum</entry>
              <entry align="left">Page number from which the secondary database file is to start</entry>
            </row>
            <row valign="middle">
              <entry align="center">num</entry>
              <entry align="left">Maximum size of the secondary file in pages</entry>
            </row>
            <row valign="middle">
              <entry align="center">diff_file</entry>
              <entry align="left">File path and name of the .delta file (difference file)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <database>ALTER DATABASE</database> statement can
        <itemizedlist spacing="compact">
          <listitem>add secondary files to a database</listitem>
          <listitem>switch a single-file database into and out of
          the <quote>copy-safe</quote> mode (DSQL only)</listitem>
          <listitem>set or unset the path and name of the delta file for
          physical backups (DSQL only)</listitem>
        </itemizedlist>
      </para>
      
      <para>Only <link linkend="fblangref25-security-administrators">administrators</link> 
      have the authority to use <database>ALTER DATABASE</database>.</para>

      <section id="fblangref25-ddl-db-alterdbopts">
        <title>Parameters for <database>ALTER DATABASE</database></title>
        <formalpara><title>The <database>ADD FILE</database> clause</title>
          <para>adds a secondary file to the database. It is necessary to specify the
          full path to the file and the name of the secondary file. The description for
          the secondary file is similar to the one given for the
          <database>CREATE DATABASE</database> statement.</para>
        </formalpara>

        <formalpara><title>The <database>ADD DIFFERENCE FILE</database> clause</title>
          <para>specifies the path and name of the delta file that stores any mutations to the
          database whenever it is switched to the <quote>copy-safe</quote> mode. This clause
          does not actually add any file. It just overrides the default name and path of the
          .delta file. To change the existing settings, you should delete the previously
          specified description of the .delta file using the <database>DROP DIFFERENCE
          FILE</database> clause before specifying the new description of the delta file.</para>
          <para> If the path and name of the .delta file are not overridden, the file will have
          the same path and name as the database, but with the <filename> .delta </filename>
          file extension.</para>
          <caution>
            <para>If only a file name is specified, the .delta file will be created in
            the current directory of the server.  On Windows, this will be the system
            directory&mdash;a very unwise location to store volatile user files and contrary
            to Windows file system rules.</para>
          </caution>
        </formalpara>

        <formalpara><title><database>DROP DIFFERENCE FILE</database></title>
          <para>This is the clause that deletes the description (path and name) of the .delta
          file specified previously in the <database>ADD DIFFERENCE FILE</database> clause.
          The file is not actually deleted. <database>DROP DIFFERENCE FILE</database> deletes
          the path and name of the .delta file from the database header.  Next time the database
          is switched to the <quote>copy-safe</quote> mode, the default values will be used
          (i.e. the same path and name as those of the database, but with the .delta extension).</para>
        </formalpara>

        <formalpara><title><database>BEGIN BACKUP</database></title>
          <para>This is the clause that switches the database to the <quote>copy-safe</quote> mode.
          <database>ALTER DATABASE</database> with this clause freezes the main database file,
          making it possible to back it up safely using file system tools, even if users are
          connected and performing operations with data. Until the backup state of the database
          is reverted to <database>NORMAL</database>, all changes made to the database will
          be written to the .delta (difference) file.</para>
          <important>
            <para>Despite its syntax, a statement with the <database>BEGIN BACKUP</database> clause
            does not start a backup process but just creates the conditions for doing a task that
            requires the database file to be read-only temporarily.</para>
          </important>
        </formalpara>

        <formalpara><title><database>END BACKUP</database></title>
          <para> is the clause used to switch the database from the <quote>copy-safe</quote> mode
          to the normal mode. A statement with this clause merges the .delta file with the main
          database file and restores the normal operation of the database.  Once the
          <database>END BACKUP</database> process starts, the conditions  no longer exist for
          creating safe backups by means of file system tools.</para>
        </formalpara>
        <warning>
          <para>Use of <database>BEGIN BACKUP</database> and <database>END BACKUP</database>
          and copying the database files with filesystem tools, is <command>not safe</command>
          with multi-file databases! Use this method only on single-file databases.</para>
          <para>Making a safe backup with the <emphasis>gbak</emphasis> utility remains possible
          at all times, although it is not recommended to run <emphasis>gbak</emphasis> while the
          database is in LOCKED or MERGE state.</para>
        </warning>
      </section>

      <bridgehead renderas="sect4">Examples of <database>ALTER DATABASE</database> Usage</bridgehead>
      <orderedlist>
        <listitem>Adding a secondary file to the database. As soon as 30000 pages are filled
        in the previous primary or secondary file, the Firebird engine will start adding data
        to the secondary file <filename>test4.fdb</filename>.
          <programlisting>
ALTER DATABASE
ADD FILE 'D:\test4.fdb'
STARTING AT PAGE 30001;
          </programlisting>
        </listitem>
        <listitem>Specifying the path and name of the delta file:
          <programlisting>
ALTER DATABASE
ADD DIFFERENCE FILE 'D:\test.diff';
          </programlisting>
        </listitem>
        <listitem>Deleting the description of the delta file:
          <programlisting>
ALTER DATABASE
DROP DIFFERENCE FILE;
          </programlisting>
        </listitem>
        <listitem>Switching the database to the <quote>copy-safe</quote> mode:
          <programlisting>
ALTER DATABASE
BEGIN BACKUP;
          </programlisting>
        </listitem>
        <listitem>Switching the database back from the <quote>copy-safe</quote>
        mode to the normal operation mode:
          <programlisting>
ALTER DATABASE
END BACKUP;
          </programlisting>
        </listitem>
      </orderedlist>

      <formalpara><title>See also</title>
        <para><link linkend="fblangref25-ddl-db-create"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-ddl-db-drop"><database>DROP DATABASE</database></link></para>
      </formalpara>
    </section><!-- alter database -->

    <section id="fblangref25-ddl-db-drop">
      <title><database>DROP DATABASE</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting the database to which you are currently connected</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP DATABASE
        </programlisting></blockquote>
      </formalpara>
      <para>The <database>DROP DATABASE</database> statement deletes the current database.
      Before deleting a database, you have to connect to it. The statement deletes the primary file,
      all secondary files and all <link linkend="fblangref25-ddl-shadow">shadow files</link>.</para>

      <para>Only <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>DROP DATABASE</database>.</para>

      <formalpara>
        <title>Example</title>
        <para>Deleting the database the client is connected to.
          <blockquote><programlisting>
DROP DATABASE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-db-create"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-ddl-db-alter"><database>ALTER DATABASE</database></link>
        </para>
      </formalpara>
    </section><!-- drop database -->
  </section><!-- database -->

  <section id="fblangref25-ddl-shadow">
    <title>SHADOW</title>
    <para>A <emphasis>shadow</emphasis> is an exact, page-by-page copy of a database. Once a shadow
    is created, all changes made in the database are immediately reflected in the shadow. If the
    primary database file becomes unavailable for some reason, the DBMS will switch to the shadow.</para>
    <para>This section describes how to create and delete shadow files.</para>

    <section id="fblangref25-ddl-createshadow">
      <title><database>CREATE SHADOW</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a shadow for the current database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE SHADOW sh_num [AUTO | MANUAL] [CONDITIONAL]
'filepath' [LENGTH [=] num [PAGE[S]]]
[&lt;secondary_file&gt; ...];

&lt;secondary_file&gt; ::=
  FILE 'filepath'
  [STARTING [AT [PAGE]] pagenum]
  [LENGTH [=] num [PAGE[S]]]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-createshadow">
      <?dbfo keep-together='auto'?>
        <title>CREATE SHADOW Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sh_num</entry>
              <entry align="left">Shadow number&mdash;a positive number identifying the
              shadow set</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">The name of the shadow file and the path to it, in accord
              with the rules of the operating system</entry>
            </row>
            <row valign="middle">
              <entry align="center">num</entry>
              <entry align="left">Maximum shadow size, in pages</entry>
            </row>
            <row valign="middle">
              <entry align="center">secondary_file</entry>
              <entry align="left">Secondary file specification</entry>
            </row>
            <row valign="middle">
              <entry align="center">page_num</entry>
              <entry align="left">The number of the page at which the secondary shadow
              file should start</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <database>CREATE SHADOW</database> statement creates a new shadow. The shadow
      starts duplicating the database right at the moment it is created.  It is not possible
      for a user to connect to a shadow.</para>

      <para>Like a database, a shadow may be multi-file. The number and size of a shadow's
      files are not related to the number and size of the files of database it is
      shadowing.</para>

      <para>The page size for shadow files is set to be equal to the database page size and
      cannot be changed.</para>

      <para>If a calamity occurs involving the original database, the system converts the
      shadow to a copy of the database and switches to it.  The shadow is
      then <emphasis>unavailable</emphasis>.  What happens next depends on the
      <database>MODE</database> option.</para>

      <section id="fblangref25-ddl-createshadowmode">
        <title><database>AUTO | MANUAL</database> Modes</title>
        <para>When a shadow is converted to a database, it becomes unavailable. A shadow might
        alternatively become unavailable because someone accidentally deletes its file, or the
        disk space where the shadow files are stored is exhausted or is itself damaged.
          <itemizedlist>
            <listitem>
              <para>If the AUTO mode is selected (the default value), shadowing ceases
              automatically, all references to it are deleted from the database header and
              the database continues functioning normally.</para>
              <para>If the <database>CONDITIONAL</database> option was set, the system will
              attempt to create a new shadow to replace the lost one.  It does not always
              succeed, however, and a new one may need to be created manually.</para>
            </listitem>
            <listitem>
              <para>If the MANUAL mode attribute is set when the shadow becomes unavailable,
              all attempts to connect to the database and to query it will produce error messages.
              The database will remain inaccessible until either the shadow again becomes
              available or the database administrator deletes it using the
              <database>DROP SHADOW</database> statement.  MANUAL should be selected if
              continuous shadowing is more important than uninterrupted operation of the
              database.</para>
             </listitem>
           </itemizedlist>
        </para>
      </section>
      <section id="fblangref25-ddl-createshadowopts">
        <title>Options for <database>CREATE SHADOW</database></title>
        <formalpara><title>Optional LENGTH</title>
          <para> Clause specifying the maximum size of the primary or secondary shadow file in
          pages. The <database>LENGTH</database> value does not affect the size of the only shadow
           file, nor the last if it is a set. The last (or only) file will keep automatically 
           increasing in size as long as it is necessary.</para>
        </formalpara>

        <formalpara><title>STARTING AT</title>
          <para>Clause specifying the shadow page number at which the next shadow file should
          start. The system will start adding new data to the next shadow file when the
          previous file is filled with data up to the specified page number.</para>
        </formalpara>
      </section>
      <para>Only <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>CREATE SHADOW</database>.</para>
      <tip>
        <para>You can verify the sizes, names and location of the
        shadow files by connecting to the database using <emphasis>isql</emphasis> and
        running the command <database>SHOW DATABASE;</database></para>
      </tip>

      <formalpara><title>Examples Using <database>CREATE SHADOW</database></title>
        <orderedlist>
          <listitem>Creating a shadow for the current database as <quote>shadow number 1</quote>:
            <programlisting>
CREATE SHADOW 1 'g:\data\test.shd';
            </programlisting>
          </listitem>
          <listitem>Creating a multi-file shadow for the current database as
          <quote>shadow number 2</quote>:
            <programlisting>
CREATE SHADOW 2 'g:\data\test.sh1'
LENGTH 8000 PAGES
FILE 'g:\data\test.sh2';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>See also</title>
        <para><link linkend="fblangref25-ddl-db-create"><database>CREATE DATABASE</database></link>,
        <link linkend="fblangref25-ddl-dropshadow"><database>DROP SHADOW</database></link>
        </para>
      </formalpara>
    </section><!-- create shadow -->

    <section id="fblangref25-ddl-dropshadow">
      <title><database>DROP SHADOW</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting a shadow from the current database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP SHADOW sh_num
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropshadow">
      <?dbfo keep-together='auto'?>
        <title>DROP SHADOW Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sh_num</entry>
              <entry align="left">Shadow number&mdash;a positive number identifying the
              shadow set</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP SHADOW</database> statement deletes the specified shadow for
      the database one is connected to. When a shadow is dropped, all files related to
      it are deleted and shadowing to the specified <replaceable>sh_num</replaceable> ceases.</para>

      <para>Only <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>DROP SHADOW</database>.</para>

      <formalpara><title>Example of Dropping a Shadow</title>
        <para> Deleting <quote>shadow number 1</quote>.
          <blockquote><programlisting>
DROP SHADOW 1;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-createshadow"><database>CREATE SHADOW</database></link></para>
      </formalpara>
    </section><!-- drop shadow -->
  </section> <!-- shadow -->

  <section id="fblangref25-ddl-domn">
    <title><database>DOMAIN</database></title>
    <para><command>Domain</command> is one of the object types in a relational database.
    A domain is created as a specific data type with some attributes attached to it.  Once it
    has been defined in the database, it can be reused repeatedly to define table columns,
    PSQL arguments and PSQL local variables. Those objects inherit all of the attributes
    of the domain.  Some attributes can be overriden when the new object is defined, if
    required.</para>
    <para>This section describes the syntax of statements used to create, modify and delete
    domains. A detailed description of domains and their usage can be found in
    <link linkend="fblangref25-datatypes-custom">Custom Data Types&mdash;Domains</link>.</para>

    <section id="fblangref25-ddl-domn-create">
      <title><database>CREATE DOMAIN</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new domain</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE DOMAIN name [AS] &lt;datatype&gt;
[DEFAULT {literal | NULL | &lt;context_var&gt;}]
[NOT NULL] [CHECK (&lt;dom_condition&gt;)]
[COLLATE collation_name];

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT} [&lt;array_dim&gt;]
  | {FLOAT | DOUBLE PRECISION} [&lt;array_dim&gt;]
  | {DATE | TIME | TIMESTAMP} [&lt;array_dim&gt;]
  | {DECIMAL | NUMERIC} [(precision [, scale])] [&lt;array_dim&gt;]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [&lt;array_dim&gt;] [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)] [&lt;array_dim&gt;]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;array_dim&gt; ::= <command>[</command>[m:]n [,[m:]n ...]<command>]</command>

&lt;dom_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM &lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;dom_condition&gt;)
  | NOT &lt;dom_condition&gt;
  | &lt;dom_condition&gt; OR &lt;dom_condition&gt;
  | &lt;dom_condition&gt; AND &lt;dom_condition&gt;

&lt;operator&gt; ::= 
  &lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    VALUE
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-createdomn">
      <?dbfo keep-together='auto'?>
        <title>CREATE DOMAIN Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">name</entry>
              <entry align="left">Domain name consisting of up to 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">A literal value that is compatible with <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Any context variable whose type is compatible with <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">dom_condition</entry>
              <entry align="left">Domain condition</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation_name</entry>
              <entry align="left">Name of a collation sequence that is valid for <replaceable>charset_name</replaceable>,
              if it is supplied with <replaceable>datatype</replaceable> or, otherwise, is valid for
              the default character set of the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">array_dim</entry>
              <entry align="left">Array dimensions</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left"><database>INTEGER</database> numbers defining the index range
              of an array dimension</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">The total number of significant digits that a value of
              the <replaceable>datatype</replaceable> can hold (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">The number of digits after the decimal point
              (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">The name of a valid character set, if the character set
              of the domain is to be different to the default character set of the
              database</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">A scalar SELECT statement&mdash;selecting one column and
              returning only one row</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">A SELECT statement selecting one column and returning
              zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">A SELECT statement selecting one or more columns and
              returning zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">An expression resolving to a value that is compatible
              with <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequence (generator) name</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Internal function or UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE DOMAIN</database> statement creates a new domain.</para>
      <para>Any SQL data type can be specified as the domain type.</para>
      <section id="fblangref25-ddl-domn-typespec">
        <title>Type-specific Details</title>
        <formalpara>
          <title>ARRAY Types</title>
          <itemizedlist spacing="compact">
            <listitem>If the domain is to be an array, the base type can be any SQL
              data type except <database>BLOB</database> and <database>ARRAY</database>.
            </listitem>
            <listitem>The dimensions of the array are specified between square brackets.
            (In the Syntax block, these brackets appear in boldface to distinguish
            them from the square brackets that identify optional syntax elements.)
            </listitem>
            <listitem>For each array dimension, one or two integer numbers define the
            lower and upper boundaries of its index range:
              <itemizedlist spacing="compact">
                <listitem>By default, arrays are 1-based.  The lower boundary is implicit
                and only the upper boundary need be specified.  A single number smaller than
                1 defines the range <replaceable>num</replaceable>..1 and a number greater
                than 1 defines the range 1..<replaceable>num</replaceable>.</listitem>
                <listitem>Two numbers separated by a colon (':') and optional whitespace,
                the second greater than the first, can be used to define the range explicitly.
                One or both boundaries can be less than zero, as long as the upper boundary
                is greater than the lower.</listitem>
              </itemizedlist>
            </listitem>
            <listitem>When the array has multiple dimensions, the range definitions for
              each dimension must be separated by commas and optional whitespace.
            </listitem>
            <listitem>Subscripts are validated <emphasis>only</emphasis> if an array actually
            exists. It means that no error messages regarding invalid subscripts will be
            returned if selecting a specific element returns nothing or if an array field
            is <constant>NULL</constant>.</listitem>
          </itemizedlist>
        </formalpara>

        <formalpara><title>CHARACTER Types</title>
          <para>You can use the <database>CHARACTER SET</database> clause to specify the character
          set for the <database>CHAR, VARCHAR</database> and <database>BLOB</database>
          (<database>SUB_TYPE TEXT</database> ) types. If the character set is not specified, the
          character set specified as <database>DEFAULT CHARACTER SET</database> in creating the
          database will be used. If no character set was specified then, the character set
          <database>NONE</database> is applied by default when you create a character domain.
            <warning>
              <para>With character set <database>NONE</database>, character data are stored and
              retrieved the way they were submitted. Data in any encoding can be added to a column
              based on such a domain, but it is impossible to add this data to a column with a
              different encoding. Because no transliteration is performed between the source and
              destination encodings, errors may result.</para>
            </warning>
          </para>
        </formalpara>
        <formalpara><title><database>DEFAULT</database> Clause</title>
          <para> The optional <database>DEFAULT</database> clause allows you to specify a
          default value for the domain. This value will be added to the table column that
          inherits this domain when the <database>INSERT</database> statement is executed,
          if no value is specified for it in the DML statement.</para>
          <para> Local variables and arguments in PSQL modules that reference this domain
          will be initialized with the default value. For the default value, use a literal of a
          compatible type or a context variable of a compatible type.</para>
        </formalpara>
        <formalpara><title>NOT NULL Constraint</title>
          <para>Columns and variables based on a domain with the NOT NULL constraint will be
          prevented from being written as NULL, i.e., a value is <emphasis>required</emphasis>.</para>
        </formalpara>
        <caution>
          <para>When creating a domain, take care to avoid specifying limitations that would
          contradict one another. For instance, NOT NULL and DEFAULT NULL are contradictory.</para>
        </caution>
        <formalpara><title><database>CHECK Constraint[s]</database></title>
          <para>The optional <database>CHECK</database> clause specifies constraints for the domain.
          A domain constraint specifies conditions that must be satisfied by the values of table
          columns or variables that inherit from the domain.  A condition must be enclosed in
          parentheses.</para>
          <para> A condition is a logical expression (also called a predicate) that can return
          the Boolean results <database>TRUE, FALSE</database> and <database>UNKNOWN</database>.
          A condition is considered satisfied if the predicate returns the value <database>TRUE</database>
          or <quote>unknown value</quote> (equivalent to <database>NULL</database>). If the predicate
          returns <database>FALSE</database>, the condition for acceptance is not met.</para>
        </formalpara>
        <formalpara><title>VALUE Keyword</title>
          <para>The keyword <database>VALUE</database> in a domain constraint substitutes for
          the table column that is based on this domain or for a variable in a PSQL module.
          It contains the value assigned to the variable or the table column. <database>VALUE</database>
          can be used anywhere in the CHECK constraint, though it is usually used in the left part
          of the condition.</para>
        </formalpara>
        <formalpara><title>COLLATE</title>
          <para>The optional COLLATE clause allows you to specify the collation sequence if the
          domain is based on one of the string data types, including <database>BLOB</database>s 
          with text subtypes. If no collation sequence is specified, the collation sequence will 
          be the one that is default for the specified character set at the time the domain 
          is created.</para>
        </formalpara>
      </section>

      <para>Any user connected to the database can create a domain.</para>

      <section id="fblangref25-ddl-createdomnexmpls">
        <title><database>CREATE DOMAIN</database> Examples</title>
        <orderedlist>
          <listitem>Creating a domain that can take values greater than 1,000, with a
          default value of 10,000.
            <programlisting>
CREATE DOMAIN CUSTNO AS
INTEGER DEFAULT 10000
CHECK (VALUE > 1000);
            </programlisting>
          </listitem>
          <listitem>Creating a domain that can take the values 'Yes' and 'No' in the
          default character set specified during the creation of the database.
            <programlisting>
CREATE DOMAIN D_BOOLEAN AS
CHAR(3) CHECK (VALUE IN ('Yes', 'No'));
            </programlisting>
          </listitem>
          <listitem>Creating a domain with the <database>UTF8</database> character set and
          the <database>UNICODE_CI_AI</database> collation sequence.
            <programlisting>
CREATE DOMAIN FIRSTNAME AS
VARCHAR(30) CHARACTER SET UTF8
COLLATE UNICODE_CI_AI;
            </programlisting>
          </listitem>
          <listitem>Creating a domain of the <database>DATE</database> type that
        will not accept NULL and uses the current date as the default value.
            <programlisting>
CREATE DOMAIN D_DATE AS
DATE DEFAULT CURRENT_DATE
NOT NULL;
            </programlisting>
          </listitem>
          <listitem>Creating a domain defined as an array of 2 elements
          of the NUMERIC(18, 3) type. The starting array index is 1.
            <programlisting>
CREATE DOMAIN D_POINT AS
NUMERIC(18, 3) [2];
            </programlisting>
            <note>
              <para>Domains defined over an array type may be used only to define table
              columns. You cannot use array domains to define local variables in PSQL modules.</para>
            </note>
          </listitem>
          <listitem>Creating a domain whose elements can be only country codes defined in the COUNTRY table.
            <programlisting>
CREATE DOMAIN D_COUNTRYCODE AS CHAR(3)
CHECK (EXISTS(SELECT * FROM COUNTRY
       WHERE COUNTRYCODE = VALUE));
            </programlisting>
            <note>
              <para>The example is given only to show the possibility of using predicates with queries in
              the domain test condition. It is not recommended to create this style of domain in practice
              unless the lookup table contains data that are never deleted.</para>
            </note>
          </listitem>
        </orderedlist>
      </section><!-- examples -->
      <formalpara><title>See also</title>
        <para><link linkend="fblangref25-ddl-domn-alter"><database>ALTER DOMAIN</database></link>,
        <link linkend="fblangref25-ddl-domn-drop"><database>DROP DOMAIN</database></link></para>
      </formalpara>
    </section><!-- create domain -->

    <section id="fblangref25-ddl-domn-alter">
      <title><database>ALTER DOMAIN</database></title>
      <formalpara><title>Used for</title>
        <para>Altering the current attributes of a domain or renaming it</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER DOMAIN <replaceable>domain_name</replaceable>
  [TO &lt;new_name&gt;]
  [TYPE &lt;datatype&gt;]
  [SET DEFAULT {literal | NULL | &lt;context_var&gt;} | DROP DEFAULT]
  [ADD [CONSTRAINT] CHECK (&lt;dom_condition&gt;) | DROP CONSTRAINT]

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING] [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;dom_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM &lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;dom_condition&gt;)
  | NOT &lt;dom_condition&gt;
  | &lt;dom_condition&gt; OR &lt;dom_condition&gt;
  | &lt;dom_condition&gt; AND &lt;dom_condition&gt;

&lt;operator&gt; ::= 
  &lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    VALUE
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-alterdomn">
      <?dbfo keep-together='auto'?>
        <title>ALTER DOMAIN Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">new_name</entry>
              <entry align="left">New name for domain, consisting of up to 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">A literal value that is compatible with <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Any context variable whose type is compatible with <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">The total number of significant digits that a value of
              the <replaceable>datatype</replaceable> can hold (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">The number of digits after the decimal point
              (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">The name of a valid character set, if the character set
              of the domain is to be changed</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">A scalar SELECT statement&mdash;selecting one column and
              returning only one row</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">A SELECT statement selecting one column and returning
              zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">A SELECT statement selecting one or more columns and
              returning zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">An expression resolving to a value that is compatible
              with <replaceable>datatype</replaceable></entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequence (generator) name</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Internal function or UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>ALTER DOMAIN</database> statement enables changes to the current
      attributes of a domain, including its name. You can make any number of domain alterations
      in one <database>ALTER DOMAIN</database> statement.</para>
      <formalpara><title>TO &lt;name&gt;</title>
        <para> Use the TO clause to rename the domain, as long as there are no dependencies on the
        domain, i.e. table columns, local variables or procedure arguments referencing it.</para>
      </formalpara>
      <formalpara><title>SET DEFAULT</title>
        <para> With the SET DEFAULT clause you can set a new default value. If the domain already
        has a default value, there is no need to delete it first&mdash;it will be replaced by the new
        one.</para>
      </formalpara>
      <formalpara><title>DROP DEFAULT</title>
        <para>Use this clause to delete a previously specified default value and replace it
        with <database>NULL</database>.</para>
      </formalpara>
      <formalpara><title>ADD CONSTRAINT CHECK</title>
        <para> Use the <database>ADD CONSTRAINT CHECK</database> clause to add a
        <database>CHECK</database> constraint to the domain. If the
        domain already has a <database>CHECK</database> constraint, it will have to be deleted first, using
        an <database>ALTER DOMAIN</database> statement that includes a <database>DROP CONSTRAINT</database> 
        clause.</para>
      </formalpara>
      <formalpara><title>TYPE</title>
        <para> The <database>TYPE</database> clause is used to change the data type of the domain to
        a different, compatible one. The system will forbid any change to the type that could result
        in data loss.  An example would be if the number of characters in the new type were smaller
        than in the existing type.</para>
      </formalpara>
      <important>
         <para>When you alter the attributes of a domain, existing PSQL code may become invalid.
         For information on how to detect it, read the piece entitled <link
         linkend="fblangref25-appx01-supp-rdb_validblr"><citetitle>The RDB$VALID_BLR Field</citetitle></link>
         in Appendix A.</para>
       </important>

      <para>Any user connected to the database can alter a domain, provided it is not prevented
      by dependencies from objects to which that user does not have sufficient privileges.</para>

      <section id="fblangref25-ddl-domn-cannotalter">
        <title>What <database>ALTER DOMAIN</database> Cannot Alter</title>
        <itemizedlist spacing="compact">
          <listitem>If the domain was declared as an array, it is  not possible to change its type
          or its dimensions; nor can any other type be changed to an <database>ARRAY</database> type.
          </listitem>
          <listitem>In Firebird 2.5 and lower, the <database>NOT NULL</database> constraint can be neither
          enabled nor disabled for a domain.</listitem>
          <listitem>There is no way to change the default collation without dropping the domain
          and recreating it with the desired attributes.</listitem>
        </itemizedlist>
      </section>

      <section id="fblangref25-ddl-domn-alterdomnexmpls">
        <title><database>ALTER DOMAIN</database> Examples</title>
        <orderedlist>
          <listitem>Changing the data type to <database>INTEGER</database> and setting or changing
          the default value to 2,000:
            <programlisting>
ALTER DOMAIN CUSTNO
  TYPE INTEGER
  SET DEFAULT 2000;
            </programlisting>
          </listitem>
          <listitem>Renaming a domain.
            <programlisting>
ALTER DOMAIN D_BOOLEAN TO D_BOOL;
            </programlisting>
          </listitem>
          <listitem>Deleting the default value and adding a constraint for the domain:
            <programlisting>
ALTER DOMAIN D_DATE
  DROP DEFAULT
  ADD CONSTRAINT CHECK (VALUE >= date '01.01.2000');
            </programlisting>
          </listitem>
          <listitem>Changing the <database>CHECK</database> constraint:
            <programlisting>
ALTER DOMAIN D_DATE
  DROP CONSTRAINT;

ALTER DOMAIN D_DATE
  ADD CONSTRAINT CHECK
    (VALUE BETWEEN date '01.01.1900' AND date '31.12.2100');
            </programlisting>
          </listitem>
          <listitem>Changing the data type to increase the permitted number of characters:
            <programlisting>
ALTER DOMAIN FIRSTNAME
  TYPE VARCHAR(50) CHARACTER SET UTF8;
            </programlisting>
          </listitem>
        </orderedlist>
      </section>
      <formalpara><title>See also</title>
        <para><link linkend="fblangref25-ddl-domn-create"><database>CREATE DOMAIN</database></link>,
        <link linkend="fblangref25-ddl-domn-drop"><database>DROP DOMAIN</database></link></para>
      </formalpara>
    </section><!-- Alter domain -->

    <section id="fblangref25-ddl-domn-drop">
      <title><database>DROP DOMAIN</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting an existing domain</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP DOMAIN <replaceable>domain_name</replaceable>
        </programlisting></blockquote>
      </formalpara>
      <para>The <database>DROP DOMAIN</database> statement deletes a domain that exists
      in the database. It is  not possible to delete a domain if it is referenced by
      any database table columns or used in any PSQL module. In order to delete a domain
      that is in use, all columns in all tables that refer to the domain will have to be
      dropped and all references to the domain will have to be removed from PSQL modules.</para>

      <para>Any user connected to the database can drop a domain.</para>

      <bridgehead renderas="sect4">Example</bridgehead>
        <para>Deleting the COUNTRYNAME domain:
          <blockquote><programlisting>
DROP DOMAIN COUNTRYNAME;
          </programlisting></blockquote>
        </para>

      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-domn-create"><database>CREATE DOMAIN</database></link>,
        <link linkend="fblangref25-ddl-domn-alter"><database>ALTER DOMAIN</database></link></para>
      </formalpara>
    </section><!-- DROP DOMAIN -->
  </section><!-- Domain -->

  <section id="fblangref25-ddl-tbl">
    <title><database>TABLE</database></title>
    <para>As a relational DBMS, Firebird stores data in tables. A table is a flat,
    two-dimensional structure containing any number of rows. Table rows are often
    called <emphasis>records</emphasis>.</para>
    <para> All rows in a table have the same structure and consist of columns. Table
    columns are often called <emphasis>fields</emphasis>. A table must have at least
    one column. Each column contains a single type of SQL data.</para>
    <para>This section describes how to create, alter and delete tables in a
    database.</para>

    <section id="fblangref25-ddl-tbl-create">
      <title><database>CREATE TABLE</database></title>
      <formalpara><title>Used for</title>
        <para>creating a new table (relation)</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE [GLOBAL TEMPORARY] TABLE tablename
		[EXTERNAL [FILE] '&lt;filespec&gt;']
	(&lt;col_def&gt; [, {&lt;col_def&gt; | &lt;tconstraint&gt;} ...])
	[ON COMMIT {DELETE | PRESERVE} ROWS];

&lt;col_def&gt; ::= &lt;regular_col_def&gt; | &lt;computed_col_def&gt;

&lt;regular_col_def&gt; ::=
  colname {&lt;datatype&gt; | domainname}
  [DEFAULT {literal | NULL | &lt;context_var&gt;}]
  [NOT NULL]
  [&lt;col_constraint&gt;]
  [COLLATE collation_name]

&lt;computed_col_def&gt; ::=
  colname [&lt;datatype&gt;]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (&lt;expression&gt;)

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT} [&lt;array_dim&gt;]
  | {FLOAT | DOUBLE PRECISION} [&lt;array_dim&gt;]
  | {DATE | TIME | TIMESTAMP} [&lt;array_dim&gt;]
  | {DECIMAL | NUMERIC} [(precision [, scale])] [&lt;array_dim&gt;]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [&lt;array_dim&gt;] [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)] [&lt;array_dim&gt;]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;array_dim&gt; ::= <command>[</command>[m:]n [, [m:]n ...]<command>]</command>

&lt;col_constraint&gt; ::=
  [CONSTRAINT constr_name]
  {   PRIMARY KEY [&lt;using_index&gt;]
    | UNIQUE      [&lt;using_index&gt;]
    | REFERENCES other_table [(colname)] [&lt;using_index&gt;]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }

&lt;tconstraint&gt; ::=
  [CONSTRAINT constr_name]
  {   PRIMARY KEY (col_list) [&lt;using_index&gt;]
    | UNIQUE      (col_list) [&lt;using_index&gt;]
    | FOREIGN KEY (col_list)
        REFERENCES other_table [(col_list)] [&lt;using_index&gt;]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }"

&lt;col_list&gt; ::= colname [, colname ...]

&lt;using_index&gt; ::= USING
  [ASC[ENDING] | DESC[ENDING]] INDEX indexname

&lt;check_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM&lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;check_condition&gt;)
  | NOT &lt;check_condition&gt;
  | &lt;check_condition&gt; OR &lt;check_condition&gt;
  | &lt;check_condition&gt; AND &lt;check_condition&gt;

&lt;operator&gt; ::= 
&lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    colname [<command>[</command>&lt;array_idx&gt; [, &lt;array_idx&gt; ...]<command>]</command>]
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-createtbl">
      <?dbfo keep-together='auto'?>
        <title>CREATE TABLE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name (identifier) for the table. It may consist of up to 31 characters
              and must be unique in the database.</entry>
            </row>
            <row valign="middle">
              <entry align="center">filespec</entry>
              <entry align="left">File specification (only for external tables). Full file name
              and path, enclosed in single quotes, correct for the local file system and located on a 
              storage device that is physically connected to Firebird's host computer.</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name (identifier) for a column in the table. May consist of
              up to 31 characters and must be unique in the table.</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">col_constraint</entry>
              <entry align="left">Column constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">tconstraint</entry>
              <entry align="left">Table constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">constr_name</entry>
              <entry align="left">The name (identifier) of a constraint. May consist
              of up to 31 characters.</entry>
            </row>
            <row valign="middle">
              <entry align="center">other_table</entry>
              <entry align="left">The name of the table referenced by the foreign
              key constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">other_col</entry>
              <entry align="left">The name of the column in <replaceable>other_table</replaceable>
              that is referenced by the foreign key</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">A literal value that is allowed in the given context</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Any context variable whose data type is allowed in the 
              given context</entry>
            </row>
            <row valign="middle">
              <entry align="center">check_condition</entry>
              <entry align="left">The condition applied to a CHECK constraint, that will resolve
              as either true, false or <database>NULL</database></entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation</entry>
            </row>
            <row valign="middle">
              <entry align="center">array_dim</entry>
              <entry align="left">Array dimensions</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">INTEGER numbers defining the index range of an array dimension</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">The total number of significant digits that a value of the datatype
              can hold (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">The number of digits after the decimal point (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">The name of a valid character set, if the character set of the column 
              is to be different to the default character set of the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">A scalar SELECT statement&mdash;selecting one column and
              returning only one row</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">A SELECT statement selecting one column and returning
              zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">A SELECT statement selecting one or more columns and
              returning zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">An expression resolving to a value that is is allowed 
              in the given context</entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequence (generator) name</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Internal function or UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <database>CREATE TABLE</database> statement creates a new table. Any user can create it
      and its name must be unique among the names of all tables, views and stored procedures in the database.</para>
      <para>A table must contain at least one column that is not computed and the names of columns must be unique
      in the table.</para>

      <para>A column must have either an explicit <emphasis>SQL data type</emphasis>, the name of a
      <emphasis>domain</emphasis> whose attributes will be copied for the column, or be defined
      as <database>COMPUTED BY</database> an expression (a <emphasis>calculated field</emphasis>).</para>

      <para>A table may have any number of table constraints, including none.</para>

      <section id="fblangref25-ddl-tbl-nonnull">
      <title>Making a Column Non-nullable</title>
        <para>In Firebird, columns are nullable by default.  The optional <database>NOT NULL</database>
        clause specifies that the column cannot take <database>NULL</database> in place of a value.</para>
      </section><!-- non-nullable -->

      <section id="fblangref25-ddl-tbl-character">
        <title>Character Columns</title>
        <para>You can use the <database>CHARACTER SET</database> clause to specify the character set for
        the <database>CHAR, VARCHAR</database> and <database>BLOB</database> (text subtype) types. If the
        character set is not specified, the character set specified during the creation of the database
        will be used by default. If no character set was specified during the creation of the database,
        the NONE character set is applied by default. In this case, data is stored and retrieved the way
        it was submitted. Data in any encoding can be added to such a column, but it is not possible to
        add this data to a column with a different encoding. No transliteration is performed between the
        source and destination encodings, which may result in errors.</para>

        <para>The optional <database>COLLATE</database> clause allows you to specify the collation sequence
        for character data types, including <database>BLOB SUB_TYPE TEXT</database>. If no collation sequence
        is specified, the collation sequence that is default for the specified character set during the creation 
        of the column is applied by default.</para>
      </section> <!-- character columns -->

      <section id="fblangref25-ddl-tbl-default">
        <title>Setting a <database>DEFAULT</database> Value</title>
          <para>The optional <database>DEFAULT</database> clause allows you to specify the default value for
          the table column. This value will be added to the column when an <database>INSERT</database> statement
          is executed if no value was specified for it <emphasis>and</emphasis> that column was omitted from
          the <database>INSERT</database> command.</para>
          <para>The default value can be a literal of a compatible type, a context variable that is type-compatible
          with the data type of the column, or <database>NULL</database>, if the column allows it. If no default
          value is explicitly specified, NULL is implied.</para>
          <para>An expression cannot be used as a default value.</para>
      </section><!-- default value -->

      <section id="fblangref25-ddl-tbl-domainbased">
        <title>Domain-based Columns</title>
        <para>To define a column, you can use a previously defined domain. If the definition
        of a column is based on a domain, it may contain a new default value, additional <database>CHECK</database>
        constraints and a <database>COLLATE</database> clause that will override the values specified in
        the domain definition. The definition of such a column may contain additional column constraints
        (for instance, <database>NOT NULL</database>), if the domain does not have it.</para>
        <important>
          <para>It is  not possible to define a domain-based column that is nullable if the domain was
          defined with the <database>NOT NULL</database> attribute.  If you want to have a domain that
          might be used for defining both nullable and non-nullable columns and variables, it is
          better practice to make the domain nullable and apply <database>NOT NULL</database> in
          the downstream column definitions and variable declarations.</para>
        </important>
      </section> <!-- domain-based -->

      <section id="fblangref25-ddl-tbl-computedby">
        <title>Calculated Fields</title>
        <para>Calculated fields can be defined with the <database>COMPUTED [BY]</database> or
        <database>GENERATED ALWAYS AS</database> clause (according to the SQL:2003 standard). They mean
        the same. Describing the data type is not required (but possible) for calculated fields, as the
        DBMS calculates and stores the appropriate type as a result of the expression analysis. Appropriate
        operations for the data types included in an expression must be specified precisely.</para>
        <para>If the data type is explicitly specified for a calculated field, the calculation result
        is converted to the specified type.  This means, for instance, that the result of a numeric expression
        could be rendered as a string.</para>
        <para>In a query that selects a <database>COMPUTED BY</database> column, the expression is evaluated
        for each row of the selected data.</para>
        <tip>
          <para>Instead of a computed column, in some cases it makes sense to use a regular column whose
          value is evaluated in triggers for adding and updating data. It may reduce the performance of
          inserting/updating records, but it will increase the performance of data selection.</para>
        </tip>
      </section><!-- calculated fields -->

      <section id="fblangref25-ddl-tbl-array">
        <title>Defining an <database>ARRAY</database> Column</title>
        <itemizedlist spacing="compact">
          <listitem>If the column is to be an array, the base type can be any SQL
            data type except <database>BLOB</database> and <database>ARRAY</database>.
          </listitem>
          <listitem>The dimensions of the array are specified between square brackets.
          (In the <link linkend="fblangref25-ddl-tbl-create">Syntax block</link> these
          brackets appear in boldface to distinguish them from the square brackets that
          identify optional syntax elements.)
          </listitem>
          <listitem>For each array dimension, one or two integer numbers define the
          lower and upper boundaries of its index range:
            <itemizedlist spacing="compact">
              <listitem>By default, arrays are 1-based.  The lower boundary is implicit
              and only the upper boundary need be specified.  A single number smaller than
              1 defines the range <replaceable>num</replaceable>..1 and a number greater
              than 1 defines the range 1..<replaceable>num</replaceable>.</listitem>
              <listitem>Two numbers separated by a colon (':') and optional whitespace,
              the second greater than the first, can be used to define the range explicitly.
              One or both boundaries can be less than zero, as long as the upper boundary
              is greater than the lower.</listitem>
            </itemizedlist>
          </listitem>
          <listitem>When the array has multiple dimensions, the range definitions for
            each dimension must be separated by commas and optional whitespace.
          </listitem>
          <listitem>Subscripts are validated <emphasis>only</emphasis> if an array actually
          exists. It means that no error messages regarding invalid subscripts will be
          returned if selecting a specific element returns nothing or if an array field
          is <constant>NULL</constant>.</listitem>
        </itemizedlist>
      </section><!-- array column -->

      <section id="fblangref25-ddl-tbl-constraints">
        <title>Constraints</title>
        <para>Four types of constraints can be specified.  They are:
        <itemizedlist spacing="compact">
          <listitem>Primary key (<database>PRIMARY KEY</database>)</listitem>
          <listitem>Unique key (<database>UNIQUE</database>)</listitem>
          <listitem>Foreign key (<database>REFERENCES</database>)</listitem>
          <listitem><database>CHECK</database> constraint (<database>CHECK</database>)</listitem>
        </itemizedlist>
        </para>
        <para>Constraints can be specified at column level (<quote>column constraints</quote>)
        or at table level (<quote>table constraints</quote>).  Table-level constraints are needed
        when keys (uniqueness constraint, Primary Key, Foreign Key) are to be formed across multiple
        columns and when a CHECK constraint involves other columns in the row besides the
        column being defined. Syntax for some types of constraint may differ slightly according to
        whether the constraint is being defined at column or table level.
          <itemizedlist>
            <listitem>A column-level constraint is specified during a column definition, after
            all column attributes except <database>COLLATION</database> are specified, and can
            involve only the column specified in that definition</listitem>
            <listitem>Table-level constraints are specified after all of the column definitions.
            They are a more flexible way to set constraints, since they can cater for constraints
            involving multiple columns</listitem>
            <listitem>You can mix column-level and table-level constraints in the same
            <database>CREATE TABLE</database> statement</listitem>
          </itemizedlist>
        </para>
        <para>The system automatically creates the corresponding index for a primary key
        (<database>PRIMARY KEY</database>), a unique key (<database>UNIQUE</database>) and a
        foreign key (<database>REFERENCES</database> for a column-level constraint, <database>FOREIGN
        KEY REFERENCES</database> for one at the table level).</para>

        <section id="fblangref25-ddl-tbl-constraints-names">
          <title>Names for Constraints and Their Indexes</title>
          <para>Column-level constraints and their indexes are named automatically:
            <itemizedlist>
              <listitem>The constraint name has the form <database>INTEG_n</database>, where
             <database>n</database>represents one or more numerals</listitem>
             <listitem>The index name has the form <database>RDB$PRIMARYn</database> (for a
              primary key index), <database>RDB$FOREIGNn</database> (for a foreign key index)
              or <database>RDB$n</database> (for a unique key index).  Again, <database>n</database>
              represents one or more numerals</listitem>
            </itemizedlist>
          </para>
          <para>Automatic naming of table-level constraints and their indexes follows the same
          pattern, unless the names are supplied explicitly.</para>

          <section id="fblangref25-ddl-tbl-constraints-named">
            <title>Named Constraints</title>
            <para>A constraint can be named explicitly if the <database>CONSTRAINT</database> clause
            is used for its definition. While the <database>CONSTRAINT</database> clause is optional
            for defining column-level constraints, it is mandatory for table-level.  By default, the
            constraint index will have the same name as the constraint.  If a different name is wanted
            for the constraint index, a <database>USING</database> clause can be included.</para>
          </section>

          <section id="fblangref25-ddl-tbl-constraints-using">
            <title>The <database>USING</database> Clause</title>
            <para>The <database>USING</database> clause allows you to specify a user-defined name for
            the index that is created automatically and, optionally, to define the direction of the
            index&mdash;either ascending (the default) or descending.</para>
          </section>
        </section><!-- names for constraints and their indexes -->

        <section id="fblangref25-ddl-tbl-constraints-pk">
          <title><database>PRIMARY KEY</database></title>
          <para>The <database>PRIMARY KEY</database> constraint is built on one or more
          <firstterm>key columns</firstterm>, each column having the <database>NOT NULL</database>
          constraint specified for it.  The values across the key columns in any row must be unique.
          A table can have only one primary key.
          <itemizedlist spacing="compact">
            <listitem>A single-column Primary Key can be defined as a column level or a
            table-level constraint</listitem>
            <listitem>A multi-column Primary Key must be specified as a table-level
            constraint</listitem>
          </itemizedlist>
          </para>
        </section> <!-- primary key -->

        <section id="fblangref25-ddl-tbl-constraints-uq">
          <title>The <database>UNIQUE</database> Constraint</title>
          <para>The <database>UNIQUE</database> constraint defines the requirement of content
          uniqueness for the values in a key throughout the table. A table can contain any number
          of unique key constraints.</para>

          <para>As with the Primary Key, the Unique constraint can be multi-column.  If so, it must be
          specified as a table-level constraint.</para>

          <section id="fblangref25-ddl-tbl-uqkey-nulls">
            <title><database>NULL</database> in Unique Keys</title>
            <para>Firebird's SQL-99-compliant rules for <database>UNIQUE</database> constraints allow one
            or more <database>NULL</database>s in a column with a <database>UNIQUE</database> constraint.
            That makes it possible to define a <database>UNIQUE</database>constraint on a column
            that does not have the <database>NOT NULL</database> constraint.</para>

            <para>For <database>UNIQUE</database> keys that span multiple columns, the logic is a
            little complicated:
              <itemizedlist spacing="compact">
                <listitem>Multiple rows having null in all the columns of the key are allowed
                </listitem>
                <listitem>Multiple rows having keys with different combinations of nulls and non-null
                values are allowed</listitem>
                <listitem>Multiple rows having the same key columns null and the rest filled with
                non-null values are allowed, provided the values differ in at least one column</listitem>
                <listitem>Multiple rows having the same key columns null and the rest filled with
                non-null values that are the same in every column will violate the constraint</listitem>
              </itemizedlist>
            The rules for uniqueness can be summarised thus:
            <blockquote>In principle, all nulls are considered distinct. However, if two rows
            have exactly the same key columns filled with non-null values, the NULL columns are
            ignored and the uniqueness is determined on the non-null columns as though they
            constituted the entire key.</blockquote>
              <formalpara>
                <title>Illustration</title>
                <blockquote><programlisting>
RECREATE TABLE t( x int, y int, z int, unique(x,y,z));
INSERT INTO t values( NULL, 1, 1 );
INSERT INTO t values( NULL, NULL, 1 );
INSERT INTO t values( NULL, NULL, NULL );
INSERT INTO t values( NULL, NULL, NULL ); -- Permitted
INSERT INTO t values( NULL, NULL, 1 );    -- Not permitted
                </programlisting></blockquote>
              </formalpara>
            </para>
          </section> <!-- null in unique keys -->
        </section><!-- unique constraint -->

        <section id="fblangref25-ddl-tbl-constraints-refs">
          <title><database>FOREIGN KEY</database></title>
          <para>A Foreign Key ensures that the participating column(s) can contain
          only values that also exist in the referenced column(s) in the master table.
          These referenced columns are often called <firstterm>target columns</firstterm>.
          They must be the primary key or a unique key in the target table. They need not
          have a <database>NOT NULL</database> constraint defined on them although, if
          they are the primary key, they will, of course, have that constraint.</para>
          <para>The foreign key columns in the referencing table itself do not require
          a <database>NOT NULL</database> constraint.</para>
          <para>A single-column Foreign Key can be defined in the column declaration, using
          the keyword <database>REFERENCES</database>:
            <blockquote><programlisting>
... ,
ARTIFACT_ID INTEGER REFERENCES COLLECTION (ARTIFACT_ID),
            </programlisting></blockquote>
          The column <database>ARTIFACT_ID</database> in the example references a column of
          the same name in the table <database>COLLECTIONS</database>.
          </para>
          <para>Both single-column and multi-column foreign keys can be defined at the
          <firstterm>table level</firstterm>.  For a multi-column Foreign Key, the table-level
          declaration is is the only option. This method also enables the provision of an
          optional name for the constraint:
            <blockquote><programlisting>
...
CONSTRAINT FK_ARTSOURCE FOREIGN KEY(DEALER_ID, COUNTRY)
  REFERENCES DEALER (DEALER_ID, COUNTRY),
            </programlisting></blockquote>
          Notice that the column names in the referenced (<quote>master</quote>)
          table may differ from those in the Foreign Key.</para>
          <note>
            <para>If no target columns are specified, the Foreign Key automatically
            references the target table's Primary Key.</para>
          </note>
          <section id="fblangref25-ddl-tbl-constraints-fkactions">
            <title>Foreign Key Actions</title>
            <para>With the sub-clauses <database>ON UPDATE</database> and <database>ON
            DELETE</database> it is possible to specify an action to be taken on
            the affected foreign key column(s) when referenced values in the master table
            are changed:
              <itemizedlist>
                <listitem><database>NO ACTION</database> (the default) - Nothing is
                done</listitem>
                <listitem><database>CASCADE</database> - The change in the master table is
                propagated to the corresponding row(s) in the child table. If a key value
                changes, the corresponding key in the child records changes to the new value;
                if the master row is deleted, the child records are deleted.</listitem>
                <listitem><database>SET DEFAULT</database> - The Foreign Key columns in the
                affected rows will be set to their default values <emphasis>as they were when
                the foreign key constraint was defined</emphasis>.</listitem>
                <listitem><database>SET NULL</database> - The Foreign Key columns in the
                affected rows will be set to NULL.</listitem>
              </itemizedlist>
            The specified action, or the default <database>NO ACTION</database>, could cause
            a Foreign Key column to become invalid.  For example, it could get a value that is
            not present in the master table, or it could become <database>NULL</database> while
            the column has a <database>NOT NULL</database> constraint.  Such conditions will
            cause the operation on the master table to fail with an error message.
            </para>
            <formalpara>
              <title>Example</title>
              <blockquote><programlisting>
...
  CONSTRAINT FK_ORDERS_CUST
    FOREIGN KEY (CUSTOMER) REFERENCES CUSTOMERS (ID)
    ON UPDATE CASCADE ON DELETE SET NULL
              </programlisting></blockquote>
            </formalpara>
          </section> <!-- FK actions -->
        </section><!-- foreign key -->

        <section id="fblangref25-ddl-tbl-constraints-check">
          <title><database>CHECK</database> Constraint</title>
          <para>The <database>CHECK</database> constraint defines the condition the values inserted
          in this column must satisfy. A condition is a logical expression (also called a predicate)
          that can return the TRUE, FALSE and UNKNOWN values. A condition is considered satisfied
          if the predicate returns TRUE or value UNKNOWN (equivalent to NULL). If the predicate returns
          FALSE, the value will not be accepted. This condition is used for inserting a new row into the
          table (the <database>INSERT</database> statement) and for updating the existing value of the
          table column (the <database>UPDATE</database> statement) and also for statements where one of
          these actions may take place (UPDATE OR INSERT, MERGE).</para>
          <important>
            <para>A <database>CHECK</database> constraint on a domain-based column does not replace an
            existing <database>CHECK</database> condition on the domain, but becomes an addition to
            it.  The Firebird engine has no way, during definition, to verify that the extra
            <database>CHECK</database> does not conflict with the existing one.</para>
          </important>

          <para><database>CHECK</database> conditions&mdash;whether defined at table level or column
          level&mdash; refer to table columns <emphasis>by their names</emphasis>.  The use of the
          keyword <database>VALUE</database> as a placeholder, as in domain <database>CHECK</database>
          constraints, is not valid in the context of defining column constraints.</para>
          <formalpara>
            <title>Example</title>
            <para> with two column-level constraints and one at table-level:
              <blockquote><programlisting>
CREATE TABLE PLACES (
  ...
  LAT DECIMAL(9, 6) CHECK (ABS(LAT) &lt;=  90),
  LON DECIMAL(9, 6) CHECK (ABS(LON) &lt;= 180),
  ...
  CONSTRAINT CHK_POLES CHECK (ABS(LAT) &lt; 90 OR LON = 0)
                     );
              </programlisting></blockquote>
            </para>
          </formalpara>
        </section> <!-- check constraint -->
      </section> <!-- constraints -->

      <section id="fblangref25-ddl-tbl-gtt">
        <title>Global Temporary Tables (GTT)</title>
        <para>Global temporary tables have persistent metadata, but their contents are transaction-bound
        (the default) or connection-bound. Every transaction or connection has its own private instance of
        a GTT, isolated from all the others. Instances are only created if and when the GTT is referenced.
        They are destroyed when the transaction ends or on disconnection. The metadata of a GTT can be
        modified or removed using ALTER TABLE and DROP TABLE, respectively.</para>

        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE <replaceable>name</replaceable>
  (&lt;column_def&gt; [, {&lt;column_def&gt; | &lt;table_constraint&gt;} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
            </programlisting></blockquote>
          </para>
        </formalpara>
        <note>
          <title>Syntax notes</title>
          <itemizedlist spacing="compact">
            <listitem><database>ON COMMIT DELETE ROWS</database> creates a transaction-level GTT (the default),
            <database>ON COMMIT PRESERVE ROWS</database> a connection-level GTT</listitem>
            <listitem>An <database>EXTERNAL [FILE]</database> clause is not allowed in the definition of a
            global temporary table</listitem>
          </itemizedlist>
        </note>

        <section id="fblangref25-ddl-tbl-gtt-restrictions">
          <title>Restrictions on GTTs</title>
          <para>GTTs can be <quote>dressed up</quote> with all the features and paraphernalia of ordinary
          tables (keys, references, indexes, triggers and so on) but there are a few restrictions:
            <itemizedlist spacing="compact">
              <listitem>GTTs and regular tables cannot reference one another</listitem>
              <listitem>A connection-bound (<quote>PRESERVE ROWS</quote>) GTT cannot reference a
              transaction-bound (<quote>DELETE ROWS</quote>) GTT</listitem>
              <listitem>Domain constraints cannot reference any GTT</listitem>
              <listitem>The destruction of a GTT instance at the end of its life cycle does not
              cause any <database>BEFORE/AFTER</database> delete triggers to fire</listitem>
            </itemizedlist>
          </para>
        </section>

        <tip>
          <para>In an existing database, it is not always easy to distinguish a regular table
          from a GTT, or a transaction-level GTT from a connection-level GTT.  Use this query to
          find out what type of table you are looking at:
            <programlisting>
select t.rdb$type_name
  from rdb$relations r
  join rdb$types t on r.rdb$relation_type = t.rdb$type
    where t.rdb$field_name = 'RDB$RELATION_TYPE'
    and r.rdb$relation_name = '<replaceable>TABLENAME</replaceable>'
            </programlisting>
        For an overview of the types of all the relations in the database:
            <programlisting>
    select r.rdb$relation_name, t.rdb$type_name
    from rdb$relations r
    join rdb$types t on r.rdb$relation_type = t.rdb$type
    where t.rdb$field_name = 'RDB$RELATION_TYPE'
    and coalesce (r.rdb$system_flag, 0) = 0
            </programlisting>
          The <database>RDB$TYPE_NAME</database> field will show PERSISTENT for a regular
          table, VIEW for a view, GLOBAL_TEMPORARY_PRESERVE for a connection-bound GTT and
          GLOBAL_TEMPORARY_DELETE for a transaction_bound GTT.</para>
        </tip>
      </section> <!-- GTTs -->

      <section id="fblangref25-ddl-tbl-external">
      <title>External Tables</title>
        <para>The optional <database>EXTERNAL [FILE]</database> clause specifies that the table is stored outside the
        database in an external text file of fixed-length records. The columns of a table stored in an external
        file can be of any type except <database>BLOB</database> or <database>ARRAY</database>, although for most
        purposes, only columns of <database>CHAR</database> types would be useful.</para>
        <para>All you can do with a table stored in an external file is insert new rows (<database>INSERT</database>)
        and query the data (<database>SELECT</database>). Updating existing data (<database>UPDATE</database>) and deleting
        rows (<database>DELETE</database>) are not possible.</para>

        <para>A file that is defined as an external table must be located on a storage device that is physically
        present on the machine where the Firebird server runs and, if the parameter <emphasis>ExternalFileAccess</emphasis>
        in the <filename>firebird.conf</filename> configuration file is <function>Restrict</function>, it must be
        in one of the directories listed there as the argument for <function>Restrict</function>. If the file does not
        exist yet, Firebird will create it on first access.</para>

        <important>
          <para>The ability to use external files for a table depends on the value set for the
            <emphasis>ExternalFileAccess</emphasis> parameter in <filename>firebird.conf</filename>:
            <itemizedlist>
              <listitem>If it is set to <function>None</function> (the default), any attempt to access an
              external file will be denied.</listitem>
              <listitem>The <function>Restrict</function> setting is recommended, for restricting external
              file access to directories created explicitly for the purpose by the server administrator.  For example:
                <itemizedlist spacing="compact">
                  <listitem><function>ExternalFileAccess = Restrict externalfiles</function> will restrict
                  access to a directory named <function>externalfiles</function> directly beneath the
                  Firebird root directory</listitem>
                  <listitem><function>ExternalFileAccess = d:\databases\outfiles; e:\infiles</function> will restrict
                  access to just those two directories on the Windows host server.  Note that any path that is a network
                  mapping will not work.  Paths enclosed in single or double quotes will not work, either.</listitem>
                </itemizedlist>
              </listitem>
              <listitem>If this parameter is set to <function>Full</function>, external files may be accessed
              anywhere on the host file system.  It creates a security vulnerability and is not recommended.</listitem>
            </itemizedlist>
          </para>
        </important>

        <section id="fblangref25-ddl-tbl-ext-format">
          <title>External File Format</title>
          <para>The <quote>row</quote> format of the external table is fixed length.  There are no field
          delimiters: both field and row boundaries are determined by maximum sizes, in bytes, of the field
          definitions.  It is important to keep this in mind, both when defining the structure of the
          external table and when designing an input file for an external table that is to import data from
          another application.  The ubiquitous <quote>.csv</quote> format, for example, is of no use as an
          input file and cannot be generated directly into an external file.</para>

          <para>The most useful data type for the columns of external tables is the fixed-length
          <database>CHAR</database> type, of suitable lengths for the data they are to carry.  Date and number
          types are easily cast to and from strings whereas, unless the files are to be read by another Firebird
          database, the native data types will appear to external applications as unparseable <quote>alphabetti</quote>.</para>

          <para>Of course, there are ways to manipulate typed data so as to generate output files from Firebird
          that can be read directly as input files to other applications, using stored procedures, with or without
          employing external tables.  Such techniques are beyond the scope of a language reference.  Here, we
          provide some guidelines and tips for producing and working with simple text files, since the external
          table feature is often used as an easy way to produce or read transaction-independent logs that can
          be studied off-line in a text editor or auditing application.</para>

          <section id="fblangref25-ddl-tbl-ext-format-delimiter">
            <title>Row Delimiters</title>
            <para>Generally, external files are more useful if rows are separated by a delimiter, in the form
            of a <quote>newline</quote> sequence that is recognised by reader applications on the intended
            platform.  For most contexts on Windows, it is the two-byte 'CRLF' sequence, carriage return (ASCII
            code decimal 13) and line feed (ASCII code decimal 10). On POSIX, LF on its own is usual;  for some
            MacOSX applications, it may be LFCR.  There are various ways to populate this delimiter column.
            In our example below, it is done by using a Before Insert trigger and the internal function
            <database>ASCII_CHAR</database>.</para>
          </section> <!-- row delimiters -->

          <bridgehead renderas="sect4">External Table Example</bridgehead>
          <para>For our example, we will define an external log table that might be used by an exception handler
          in a stored procedure or trigger.  The external table is chosen because the messages from any
          handled exceptions will be retained in the log, even if the transaction that launched the process is
          eventually rolled back because of another, unhandled exception.  For demonstration purposes, it has
          just two data columns, a time stamp and a message.  The third column stores the row delimiter:
           <blockquote><programlisting>
CREATE TABLE ext_log
  EXTERNAL FILE 'd:\externals\log_me.txt' (
  stamp CHAR (24),
  message CHAR(100),
  crlf CHAR(2) );  -- for a Windows context
COMMIT;
           </programlisting></blockquote>
          Now, a trigger, to write the timestamp and the row delimiter each time a message is
          written to the file:
           <blockquote><programlisting>
SET TERM ^;
CREATE TRIGGER bi_ext_log FOR ext_log
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (new.stamp is NULL) then
    new.stamp = CAST (CURRENT_TIMESTAMP as CHAR(24));
  new.crlf = ASCII_CHAR(13) || ASCII_CHAR(10);
END ^
COMMIT ^
SET TERM ;^
           </programlisting></blockquote>
         Inserting some records (which could have been done by an exception handler or
         a fan of Shakespeare):
           <blockquote><programlisting>
insert into ext_log (message)
values('Shall I compare thee to a summer''s day?');
insert into ext_log (message)
values('Thou art more lovely and more temperate')
           </programlisting></blockquote>
         The output:
           <blockquote><literallayout class="monospaced">
2015-10-07 15:19:03.4110Shall I compare thee to a summer's day?
2015-10-07 15:19:58.7600Thou art more lovely and more temperate
           </literallayout></blockquote>
         </para>
        </section> <!-- external file format -->
      </section><!-- external table -->

      <section id="fblangref25-ddl-tbl-exmpls">
        <title><database>CREATE TABLE</database> Examples</title>
        <orderedlist>
          <listitem>Creating the COUNTRY table with the primary key specified as a column constraint.
            <programlisting>
CREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
            </programlisting>
          </listitem>
          <listitem>Creating the STOCK table with the named primary key specified at the column
          level and the named unique key specified at the table level.
            <programlisting>
CREATE TABLE STOCK (
  MODEL SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID));
            </programlisting>
          </listitem>
          <listitem>Creating the JOB table with a primary key constraint spanning two columns, a foreign key
          constraint for the COUNTRY table and a table-level CHECK constraint. The table also contains an array
          of 5 elements.
            <programlisting>
CREATE TABLE JOB (
    JOB_CODE         JOBCODE NOT NULL,
    JOB_GRADE        JOBGRADE NOT NULL,
    JOB_COUNTRY      COUNTRYNAME,
    JOB_TITLE        VARCHAR(25) NOT NULL,
    MIN_SALARY       NUMERIC(18, 2) DEFAULT 0 NOT NULL,
    MAX_SALARY       NUMERIC(18, 2) NOT NULL,
    JOB_REQUIREMENT  BLOB SUB_TYPE 1,
    LANGUAGE_REQ     VARCHAR(15) [1:5],
    PRIMARY KEY (JOB_CODE, JOB_GRADE),
    FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY)
    ON UPDATE CASCADE
    ON DELETE SET NULL,
    CONSTRAINT CHK_SALARY CHECK (MIN_SALARY &lt; MAX_SALARY)
);
            </programlisting>
          </listitem>
          <listitem>Creating the PROJECT table with primary, foreign and unique key constraints
          with custom index names specified with the USING clause.
            <programlisting>
CREATE TABLE PROJECT (
    PROJ_ID    PROJNO NOT NULL,
    PROJ_NAME  VARCHAR(20) NOT NULL UNIQUE USING DESC INDEX IDX_PROJNAME,
    PROJ_DESC    BLOB SUB_TYPE 1,
    TEAM_LEADER  EMPNO,
    PRODUCT      PRODTYPE,
    CONSTRAINT PK_PROJECT PRIMARY KEY (PROJ_ID) USING INDEX IDX_PROJ_ID,
    FOREIGN KEY (TEAM_LEADER) REFERENCES EMPLOYEE (EMP_NO)
      USING INDEX IDX_LEADER
);
            </programlisting>
          </listitem>
          <listitem>Creating the SALARY_HISTORY table with two computed fields. The first
          one is declared according to the SQL:2003 standard, while the second one is declared
          according to the traditional declaration of computed fields in Firebird.
            <programlisting>
CREATE TABLE SALARY_HISTORY (
    EMP_NO          EMPNO NOT NULL,
    CHANGE_DATE     TIMESTAMP DEFAULT 'NOW' NOT NULL,
    UPDATER_ID      VARCHAR(20) NOT NULL,
    OLD_SALARY      SALARY NOT NULL,
    PERCENT_CHANGE  DOUBLE PRECISION DEFAULT 0 NOT NULL,
    SALARY_CHANGE   GENERATED ALWAYS AS
      (OLD_SALARY * PERCENT_CHANGE / 100),
    NEW_SALARY      COMPUTED BY
      (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
);
            </programlisting>
          </listitem>
          <listitem>Creating a connection-scoped global temporary table.
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
ON COMMIT PRESERVE ROWS;
            </programlisting>
          </listitem>
          <listitem>Creating a transaction-scoped global temporary table that uses a
          foreign key to reference a connection-scoped global temporary table. The ON
          COMMIT sub-clause is optional because DELETE ROWS is the default.
            <programlisting>
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
    ID INTEGER NOT NULL PRIMARY KEY,
    PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
    TXT VARCHAR(32),
    TS TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
      ON COMMIT DELETE ROWS;
            </programlisting>
          </listitem>
        </orderedlist>
      </section> <!-- create table examples -->
    </section> <!-- Create table -->

    <section id="fblangref25-ddl-tbl-alter">
      <title><database>ALTER TABLE</database></title>
      <formalpara><title>Used for</title>
        <para>altering the structure of a table.</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER TABLE tablename
&lt;operation&gt; [, &lt;operation&gt; ...]

&lt;operation&gt; ::= ADD &lt;col_def&gt;
                      ADD &lt;tconstraint&gt;
                      DROP <replaceable>colname</replaceable>
                      DROP CONSTRAINT <replaceable>constr_name</replaceable>
                      ALTER [COLUMN] <replaceable>colname</replaceable> &lt;col_mod&gt;

&lt;col_def&gt; ::= &lt;regular_col_def&gt; | &lt;computed_col_def&gt;

&lt;regular_col_def&gt; ::=
  colname {&lt;datatype&gt; | domainname}
  [DEFAULT {literal | NULL | &lt;context_var&gt;}]
  [NOT NULL]
  [&lt;col_constraint&gt;]
  [COLLATE collation_name]

&lt;computed_col_def&gt; ::=
  colname [&lt;datatype&gt;]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (&lt;expression&gt;)

&lt;col_mod&gt; ::= &lt;regular_col_mod&gt; | &lt;computed_col_mod&gt;

&lt;regular_col_mod&gt; ::=
    TO <replaceable>newname</replaceable>
  | POSITION <replaceable>newpos</replaceable>
  | TYPE {&lt;datatype&gt; | <replaceable>domainname</replaceable>}
  | SET DEFAULT {<replaceable>literal</replaceable> | NULL | &lt;context_var&gt;}
  | DROP DEFAULT

&lt;computed_col_mod&gt; ::=
    TO <replaceable>newname</replaceable>
  | POSITION <replaceable>newpos</replaceable>
  | [TYPE &lt;datatype&gt;] {COMPUTED [BY] | GENERATED ALWAYS AS} (&lt;expression&gt;)

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT} [&lt;array_dim&gt;]
  | {FLOAT | DOUBLE PRECISION} [&lt;array_dim&gt;]
  | {DATE | TIME | TIMESTAMP} [&lt;array_dim&gt;]
  | {DECIMAL | NUMERIC} [(precision [, scale])] [&lt;array_dim&gt;]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [&lt;array_dim&gt;] [CHARACTER SET charset_name]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)] [&lt;array_dim&gt;]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset_name]
  | BLOB [(seglen [, subtype_num])]

&lt;array_dim&gt; ::= <command>[</command>[m]:n [,[m]:n ...]<command>]</command>

&lt;col_constraint&gt; ::=
  [CONSTRAINT constr_name]
  {   PRIMARY KEY [&lt;using_index&gt;]
    | UNIQUE      [&lt;using_index&gt;]
    | REFERENCES other_table [(colname)] [&lt;using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }

&lt;tconstraint&gt; ::=
  [CONSTRAINT <replaceable>constr_name</replaceable>]
  {   PRIMARY KEY (<replaceable>col_list</replaceable>) [&lt;using_index&gt;]
    | UNIQUE      (<replaceable>col_list</replaceable>) [&lt;using_index&gt;]
    | FOREIGN KEY (<replaceable>col_list</replaceable>)
        REFERENCES <replaceable>other_table</replaceable> [(<replaceable>col_list</replaceable>)] [&lt;using_index&gt;]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (&lt;check_condition&gt;) }

&lt;col_list&gt; ::= <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]

&lt;using_index&gt; ::= USING
[ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>indexname</replaceable>

&lt;check_condition&gt; ::=
    &lt;val&gt; &lt;operator&gt; &lt;val&gt;
  | &lt;val&gt; [NOT] BETWEEN &lt;val&gt; AND &lt;val&gt;
  | &lt;val&gt; [NOT] IN (&lt;val&gt; [, &lt;val&gt; ...] | &lt;select_list&gt;)
  | &lt;val&gt; IS [NOT] NULL
  | &lt;val&gt; IS [NOT] DISTINCT FROM &lt;val&gt;
  | &lt;val&gt; [NOT] CONTAINING &lt;val&gt;
  | &lt;val&gt; [NOT] STARTING [WITH] &lt;val&gt;
  | &lt;val&gt; [NOT] LIKE &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; [NOT] SIMILAR TO &lt;val&gt; [ESCAPE &lt;val&gt;]
  | &lt;val&gt; &lt;operator&gt; {ALL | SOME | ANY} (&lt;select_list&gt;)
  | [NOT] EXISTS (&lt;select_expr&gt;)
  | [NOT] SINGULAR (&lt;select_expr&gt;)
  | (&lt;search_condition&gt;)
  | NOT &lt;search_condition&gt;
  | &lt;search_condition&gt; OR &lt;search_condition&gt;
  | &lt;search_condition&gt; AND &lt;search_condition&gt;

&lt;operator&gt; ::= 
  &lt;&gt; | != | ^= | ~= | = | &lt; | &gt; | &lt;= | &gt;= | !&lt; | ^&lt; | ~&lt; | !&gt; | ^&gt; | ~&gt;

&lt;val&gt; ::=
    colname [<command>[</command>&lt;array_idx&gt; [, &lt;array_idx&gt; ...]<command>]</command>]
  | literal
  | &lt;context_var&gt;
  | &lt;expression&gt;
  | NULL
  | NEXT VALUE FOR genname
  | GEN_ID(genname, &lt;val&gt;)
  | CAST(&lt;val&gt; AS &lt;datatype&gt;)
  | (&lt;select_one&gt;)
  | func([&lt;val&gt; [, &lt;val&gt; ...]])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-altertbl">
      <?dbfo keep-together='auto'?>
        <title>ALTER TABLE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name (identifier) of the table</entry>
            </row>
            <row valign="middle">
              <entry align="center">operation</entry>
              <entry align="left">One of the available operations altering the structure of the table</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">Name (identifier) for a column in the table, max. 31 characters.
              Must be unique in the table.</entry>
            </row>
            <row valign="middle">
              <entry align="center">newname</entry>
              <entry align="left">New name (identifier) for the column, max. 31 characters. Must be 
              unique in the table.</entry>
            </row>
            <row valign="middle">
              <entry align="center">newpos</entry>
              <entry align="left">The new column position (an integer between 1 and the 
              number of columns in the table)</entry>
            </row>
            <row valign="middle">
              <entry align="center">col_constraint</entry>
              <entry align="left">Column constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">tconstraint</entry>
              <entry align="left">Table constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">constr_name</entry>
              <entry align="left">The name (identifier) of a constraint. May consist
              of up to 31 characters.</entry>
            </row>
            <row valign="middle">
              <entry align="center">other_table</entry>
              <entry align="left">The name of the table referenced by the foreign
              key constraint</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">A literal value that is allowed in the given context</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">A context variable whose type is allowed in the given context</entry>
            </row>
            <row valign="middle">
              <entry align="center">check_condition</entry>
              <entry align="left">The condition of a CHECK constraint that will be satisfied if it 
              evaluates to TRUE or UNKNOWN/NULL</entry>
            </row>
            <row valign="bottom">
              <entry align="center">collation</entry>
              <entry align="left">Name of a collation sequence that is valid for 
              <replaceable>charset_name</replaceable>, if it is supplied with 
              <replaceable>datatype</replaceable> or, otherwise, is valid for the default character 
              set of the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">array_dim</entry>
              <entry align="left">Array dimensions</entry>
            </row>
            <row valign="middle">
              <entry align="center">m, n</entry>
              <entry align="left">INTEGER numbers defining the index range of an array dimension</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">The total number of significant digits that a value of
              the <replaceable>datatype</replaceable> can hold (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">The number of digits after the decimal point
              (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset_name</entry>
              <entry align="left">The name of a valid character set, if the character set of the column 
              is to be different to the default character set of the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size (max. 65535)</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_one</entry>
              <entry align="left">A scalar SELECT statement&mdash;selecting one column and
              returning only one row</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_list</entry>
              <entry align="left">A SELECT statement selecting one column and returning
              zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_expr</entry>
              <entry align="left">A SELECT statement selecting one or more columns and
              returning zero or more rows</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">An expression resolving to a value that is is allowed in 
              the given context</entry>
            </row>
            <row valign="middle">
              <entry align="center">genname</entry>
              <entry align="left">Sequence (generator) name</entry>
            </row>
            <row valign="middle">
              <entry align="center">func</entry>
              <entry align="left">Internal function or UDF</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>ALTER TABLE</database> statement changes the structure of an existing table.
      With one <database>ALTER TABLE</database> statement it is possible to perform multiple operations,
      adding/dropping columns and constraints and also altering column specifications.</para>
      <para>Multiple operations in an <database>ALTER TABLE</database> statement are separated with
      commas.</para>

      <section id="fblangref25-ddl-tbl-altrvcount">
        <title>Version Count Increments</title>
        <para>Some changes in the structure of a table increment the metadata change counter (<quote>version count</quote>)
        assigned to every table. The number of metadata changes is limited to 255 for each table. Once the counter reaches
        the 255 limit, you will not be able to make any further changes to the structure of the table without resetting 
        the counter.
          <formalpara>
            <title>To reset the metadata change counter</title>
            <para> You should back up and restore the database using the <emphasis>gbak</emphasis> utility.</para>
          </formalpara>
        </para>
      </section>

      <section id="fblangref25-ddl-tbl-altradd">
        <title>The <database>ADD</database> Clause</title>
        <para>With the <database>ADD</database> clause you can add a new column or a new table constraint. The syntax for
        defining the column and the syntax of defining the table constraint correspond with those described for
        <database>CREATE TABLE</database> statement.</para>
        <formalpara>
          <title>Effect on Version Count</title>
          <itemizedlist spacing="compact">
            <listitem>Each time a new column is added, the metadata change counter grows by one</listitem>
            <listitem>Adding a new table constraint does not increase the metadata change counter</listitem>
          </itemizedlist>
        </formalpara>
        <caution>
          <title>Points to Be Aware of</title>
          <orderedlist>
            <listitem>
              <para>Be careful about adding a new column with the <database>NOT NULL</database> constraint set. It may
              lead to breaking the logical integrity of data, since you will have existing records containing <database>NULL</database>
              in a non-nullable column. When adding a non-nullable column, it is recommended either to set a default
              value for it or to update the column in existing rows with a non-null value.</para>
            </listitem>
            <listitem>
              <para>When a new <database>CHECK</database> constraint is added, existing data is not tested for compliance.
              Prior testing of existing data against the new <database>CHECK</database> expression is recommended.</para>
            </listitem>
          </orderedlist>
        </caution>
      </section>

      <section id="fblangref25-ddl-tbl-altrdropcol">
        <title>The <database>DROP</database> Clause</title>
        <para>The <database>DROP</database> <emphasis>&lt;column name&gt;</emphasis> clause deletes the specified
        column from the table.  An attempt to drop a column will fail if anything references it.  Consider the following
        items as sources of potential dependencies:
          <itemizedlist spacing="compact">
            <listitem>column or table constraints</listitem>
            <listitem>indexes</listitem>
            <listitem>stored procedures and triggers</listitem>
            <listitem>views</listitem>
          </itemizedlist>
        </para>
        <formalpara>
          <title>Effect on Version Count</title>
          <para> Each time a column is dropped, the table's metadata change counter is increased by one.</para>
        </formalpara>
      </section>

      <section id="fblangref25-ddl-tbl-altrdropconstr">
        <title>The <database>DROP CONSTRAINT</database> Clause</title>
        <para>The <database>DROP CONSTRAINT</database> clause deletes the specified column-level or table-level
        constraint.</para>
        <para>A <database>PRIMARY KEY</database> or <database>UNIQUE</database> key constraint cannot be deleted
        if it is referenced by a <database>FOREIGN KEY</database> constraint in another table. It will be
        necessary to drop that <database>FOREIGN KEY</database> constraint before attempting to drop the
        <database>PRIMARY KEY</database> or <database>UNIQUE</database> key constraint it references.</para>
        <formalpara>
          <title>Effect on Version Count</title>
          <para> Deleting a column constraint or a table constraint does not increase the metadata change
          counter.</para>
        </formalpara>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrcol">
        <title>The <database>ALTER [COLUMN]</database> Clause</title>
        <para>With the <database>ALTER [COLUMN]</database> clause, attributes of existing columns can be modified
        without the need to drop and re-add the column.  Permitted modifications are:
          <itemizedlist>
            <listitem>change the name (does not affect the metadata change counter)</listitem>
            <listitem>change the data type (increases the metadata change counter by one)</listitem>
            <listitem>change the column position in the column list of the table (does not affect the metadata change counter)</listitem>
            <listitem>delete the default column value (does not affect the metadata change counter)</listitem>
            <listitem>set a default column value or change the existing default (does not affect the metadata change counter)</listitem>
            <listitem>change the type and expression for a computed column (does not affect the metadata change counter)</listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrto">
        <title>Renaming a Column: the <database>TO</database> Keyword</title>
        <para>The TO keyword with a new identifier renames an existing column. The table must not have an existing column
        that has the same identifier.</para>
        <para>It will not be possible to change the name of a column that is included in any constraint:
        <database>PRIMARY KEY</database>, <database>UNIQUE</database> key, <database>FOREIGN KEY</database>, column constraint
        or the <database>CHECK</database> constraint of the table.</para>
        <para>Renaming a column will also be disallowed if the column is used in any trigger, stored procedure or view.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrtyp">
        <title>Changing the Data Type of a Column: the <database>TYPE</database> Keyword</title>
        <para>The keyword <database>TYPE</database> changes the data type of an existing column to another, allowable
        type. A type change that might result in data loss will be disallowed. As an example, the number of characters
        in the new type for a <database>CHAR</database> or <database>VARCHAR</database> column cannot be smaller than
        the existing specification for it.</para>
        <para>If the column was declared as an array, no change to its type or its number of dimensions is
        permitted.</para>
        <para>The data type of a column that is involved in a foreign key, primary key or unique constraint cannot be
        changed at all.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altraltrpos">
        <title>Changing the Position of a Column: the <database>POSITION</database> Keyword</title>
        <para>The POSITION keyword changes the position of an existing column in the notional <quote>left-to-right</quote>
        layout of the record.</para>
        <para>Numbering of column positions starts at 1.
          <itemizedlist spacing="compact">
            <listitem>If a position less than 1 is specified, an error message will be returned</listitem>
            <listitem>If a position number is greater than the number of columns in the table, its new position
            will be adjusted silently to match the number of columns.</listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="fblangref25-ddl-tbl-altrdefault">
        <title>The <database>DROP DEFAULT</database> and <database>SET DEFAULT</database> Clauses</title>
        <para>The optional <database>DROP DEFAULT</database> clause deletes the default
        value for the column if it was put there previously by a CREATE TABLE or ALTER TABLE statement.
          <itemizedlist>
            <listitem>If the column is based on a domain with a default value, the default value will revert
            to the domain default</listitem>
            <listitem>An execution error will be raised if an attempt is made to delete the
            default value of a column which has no default value or whose default value is domain-based</listitem>
          </itemizedlist>
        </para>
        <para>The optional <database>SET DEFAULT</database> clause sets a default value for the
        column. If the column already has a default value, it will be replaced with the new one.
        The default value applied to a column always overrides one inherited from a domain.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altrcmptd">
        <title>The <database>COMPUTED [BY]</database> or <database>GENERATED ALWAYS AS</database> Clauses</title>
        <para>The data type and expression underlying a computed column can be modified using a
        <database>COMPUTED [BY]</database> or <database>GENERATED ALWAYS AS</database> clause in the
        <database>ALTER TABLE ALTER [COLUMN]</database> statement.  Converting a regular column to a
        computed one and vice versa are not permitted.</para>
      </section>

      <section id="fblangref25-ddl-tbl-altrtblnogo">
        <title>Attributes that Cannot Be Altered</title>
        <para>The following alterations are not supported:
          <itemizedlist spacing="compact">
            <listitem>Enabling or disabling the <database>NOT NULL</database> constraint on a column</listitem>
            <listitem>Changing the default collation for a character type column</listitem>
          </itemizedlist>
        </para>
      </section>

      <para>Only the table owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>ALTER TABLE</database>.</para>

      <section id="fblangref25-ddl-tbl-altrtblexmpls">
        <title>Examples Using <database>ALTER TABLE</database></title>
        <orderedlist>
          <listitem>Adding the CAPITAL column to the COUNTRY table.
            <programlisting>
ALTER TABLE COUNTRY
ADD CAPITAL VARCHAR(25);
            </programlisting>
          </listitem>
          <listitem>Adding the CAPITAL column with the UNIQUE constraint and deleting
          the CURRENCY column.
            <programlisting>
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25) NOT NULL UNIQUE,
  DROP CURRENCY;
            </programlisting>
          </listitem>
          <listitem>Adding the CHK_SALARY check constraint and a foreign key to
          the JOB table.
            <programlisting>
ALTER TABLE JOB
ADD CONSTRAINT CHK_SALARY CHECK (MIN_SALARY &lt; MAX_SALARY),
ADD FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY);
            </programlisting>
          </listitem>
          <listitem>Setting default value for the MODEL field, changing the
          type of the ITEMID column and renaming the MODELNAME column.
            <programlisting>
ALTER TABLE STOCK
ALTER COLUMN MODEL SET DEFAULT 1,
ALTER COLUMN ITEMID TYPE BIGINT,
ALTER COLUMN MODELNAME TO NAME;
            </programlisting>
          </listitem>
          <listitem>Changing the computed columns NEW_SALARY and SALARY_CHANGE.
            <programlisting>
ALTER TABLE SALARY_HISTORY
ALTER NEW_SALARY GENERATED ALWAYS AS 
  (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
ALTER SALARY_CHANGE COMPUTED BY 
  (OLD_SALARY * PERCENT_CHANGE / 100);
            </programlisting>
          </listitem>
        </orderedlist>
      </section>

      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-tbl-create"><database>CREATE TABLE</database></link>,
               <link linkend="fblangref25-ddl-tbl-drop"><database>DROP TABLE</database></link>,
               <link linkend="fblangref25-ddl-domn-create"><database>CREATE DOMAIN</database></link>
        </para>
      </formalpara>
    </section> <!-- alter table -->

    <section id="fblangref25-ddl-tbl-drop">
      <title><database>DROP TABLE</database></title>
      <formalpara><title>Used for</title>
        <para>deleting a table</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
drop table <replaceable>tablename</replaceable>;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-droptbl">
      <?dbfo keep-together='auto'?>
        <title>DROP TABLE Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name (identifier) of the table</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP TABLE</database> statement deletes an existing table.
      If the table has dependencies, the <database>DROP TABLE</database> statement will fail with
      an execution error.</para>
      <para> When a table is dropped, all triggers for its events and indexes built for its fields
      will be deleted as well.</para>

      <para>Only the table owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>DROP TABLE</database>.</para>

      <formalpara>
        <title>Example</title>
        <para>Deleting the COUNTRY table.
          <blockquote><programlisting>
DROP TABLE COUNTRY;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-tbl-create"><database>CREATE TABLE</database></link>,
               <link linkend="fblangref25-ddl-tbl-alter"><database>ALTER TABLE</database></link>,
               <link linkend="fblangref25-ddl-tbl-recreate"><database>RECREATE TABLE</database></link>
        </para>
      </formalpara>
    </section> <!-- drop table -->

    <section id="fblangref25-ddl-tbl-recreate">
      <title><database>RECREATE TABLE</database></title>
      <formalpara><title>Used for</title>
        <para>creating a new table (relation) or recreating an existing one</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE [GLOBAL TEMPORARY] TABLE <replaceable>tablename</replaceable>
  [EXTERNAL [FILE] '&lt;filespec&gt;']
  (&lt;col_def&gt; [, {&lt;col_def&gt; | &lt;tconstraint&gt;} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
        </programlisting></blockquote>
      </formalpara>
      <para>See the <link linkend="fblangref25-ddl-tbl-create"><database>CREATE TABLE</database>
      section</link> for the full syntax of <database>CREATE TABLE</database> and descriptions of
      defining tables, columns and constraints.</para>

      <para><database>RECREATE TABLE</database> creates or recreates a table. If a table
      with this name already exists, the <database>RECREATE TABLE</database> statement
      will try to drop it and create a new one. Existing dependencies will prevent the
      statement from executing.</para>
      <formalpara>
        <title>Example</title>
        <para> Creating or recreating the COUNTRY table.
          <blockquote><programlisting>
RECREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL);
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-tbl-create"><database>CREATE TABLE</database></link>,
        <link linkend="fblangref25-ddl-tbl-drop"><database>DROP TABLE</database></link>
        </para>
      </formalpara>
    </section><!-- recreate table -->
  </section><!-- TABLE -->

  <section id="fblangref25-ddl-idx">
    <title><database>INDEX</database></title>
    <para>An index is a database object used for faster data retrieval from a table or for speeding up the
      sorting of query. Indexes are used also to enforce the refererential integrity constraints
      <database>PRIMARY KEY</database>, <database>FOREIGN KEY</database> and <database>UNIQUE</database>.</para>
      <para>This section describes how to create indexes, activate and deactivate them, delete them and
      collect statistics (recalculate selectivity) for them.</para>
    <section id="fblangref25-ddl-idx-create">
      <title><database>CREATE INDEX</database></title>
      <formalpara><title>Used for</title>
        <para>Creating an index for a table</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]]
INDEX indexname ON tablename
{(col [, col &hellip;]) | COMPUTED BY (&lt;expression&gt;)};
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-idx-createidx">
      <?dbfo keep-together='auto'?>
        <title>CREATE INDEX Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Index name. It may consist of up to 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">The name of the table for which the index is to be built</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Name of a column in the table. Columns of the types BLOB and ARRAY
              and computed fields cannot be used in an index</entry>
            </row>
            <row valign="middle">
              <entry align="center">expression</entry>
              <entry align="left">The expression that will compute the values for a computed index,
              also known as an <quote>expression index</quote></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE INDEX</database> statement creates an index for a table that can be
      used to speed up searching, sorting and grouping. Indexes are created automatically
      in the process of defining constraints, such as primary key, foreign key or unique constraints.</para>
      <para>An index can be built on the content of columns of any data type except for <database>BLOB</database>
      and arrays. The name (identifier) of an index must be unique among all index names.</para>
      <note>
        <title>Key Indexes</title>
        <para>When a primary key, foreign key or unique constraint is added to a table or column, an index
        with the same name is created automatically, without an explicit directive from the designer.  For
        example, the PK_COUNTRY index will be created automatically when you execute and commit the following
        statement:
          <blockquote><literallayout class="monospaced">
ALTER TABLE COUNTRY ADD CONSTRAINT PK_COUNTRY
	PRIMARY KEY (ID);
          </literallayout></blockquote>
        </para>
      </note>
      <section id="fblangref25-ddl-idx-uq">
        <title>Unique Indexes</title>
        <para>Specifying the keyword <database>UNIQUE</database> in the index creation statement creates an
        index in which uniqueness will be enforced throughout the table.  The index is referred to as
        a <quote>unique index</quote>.  A unique index is not a constraint.</para>
        <para>Unique indexes cannot contain duplicate key values (or duplicate key value combinations, in the
        case of <emphasis>compound</emphasis>, or multi-column, or multi-segment) indexes.  Duplicated
        <database>NULL</database>s are permitted, in accordance with the SQL:99 standard, in both
        single-segment and multi-segment indexes.</para>
      </section>

      <section id="fblangref25-ddl-idx-drctn">
        <title>Index Direction</title>
        <para>All indexes in Firebird are uni-directional.  An index may be constructed from the lowest value 
        to the highest (ascending order) or from the highest value to the lowest (descending order).  
        The keywords <database>ASC[ENDING]</database> and <database>DESC[ENDING]</database> are used to 
        specify the direction of the index.  The default index order is <database>ASC[ENDING]</database>.
        It is quite valid to define both an ascending and a descending index on the same column or key set.</para>
        <tip>
          <para>A descending index can be useful on a column that will be subjected to searches on the 
          high values (<quote>newest</quote>, maximum, etc.)</para>
        </tip>
      </section>    

      <section id="fblangref25-ddl-idx-exprssn">
        <title>Computed (Expression) Indexes</title>
        <para>In creating an index, you can use the <database>COMPUTED BY</database> clause
        to specify an expression instead of one or more columns. Computed indexes are used
        in queries where the condition in a <database>WHERE</database>, <database>ORDER
        BY</database> or <database>GROUP BY</database> clause exactly matches the expression
        in the index definition.  The expression in a computed index may involve several
        columns in the table.
          <note>
            <para>You can actually create a computed index on a computed field, but the index
            will never be used.</para>
          </note>
        </para>
      </section> <!-- computed indexes -->

      <section id="fblangref25-ddl-idx-limits">
        <title>Limits on Indexes</title>
        <para>Certain limits apply to indexes.</para>
        <para>The maximum length of a key in an index is limited to &frac14; of the page size.</para>

        <section id="fblangref25-ddl-idx-maxno">
          <title>Maximum Indexes per Table</title>
          <para>The number of indexes that can be accommodated for each table is limited.  The actual
          maximum for a specific table depends on the page size and the number of columns in the indexes.</para>

          <table id="fblangref25-ddl-idx-idxpertbl">
          <?dbfo keep-together='auto'?>
            <title>Maximum Indexes per Table</title>
            <tgroup cols="4">
              <colspec colname="colPgsize" colwidth="*"></colspec>
              <colspec colname="col1Col" colwidth="*"></colspec>
              <colspec colname="col2Col" colwidth="*"></colspec>
              <colspec colname="col3Col" colwidth="*"></colspec>
              <thead>
                <row valign="middle">
                  <entry align="center" morerows="1">Page Size</entry>
                  <entry align="center" nameend="col3Col" namest="col1Col">Number of Indexes Depending on Column Count</entry>
                </row>
                <row>
                  <entry align="center">Single</entry>
                  <entry align="center">2-Column</entry>
                  <entry align="center">3-Column</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center">4096</entry>
                  <entry align="center">203</entry>
                  <entry align="center">145</entry>
                  <entry align="center">113</entry>
                </row>
                <row valign="middle">
                  <entry align="center">8192</entry>
                  <entry align="center">408</entry>
                  <entry align="center">291</entry>
                  <entry align="center">227</entry>
                </row>
                <row valign="middle">
                  <entry align="center">16384</entry>
                  <entry align="center">818</entry>
                  <entry align="center">584</entry>
                  <entry align="center">454</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section id="fblangref25-ddl-idx-maxstrnglgth">
          <title>Character Index Limits</title>
          <para>The maximum indexed string length is 9 bytes less than the maximum key
          length. The maximum indexable string length depends on the page size and the
          character set.</para>
          <table id="fblangref25-ddl-idx-idxstrnglgth">
          <?dbfo keep-together='auto'?>
            <title>Maximum indexable (VAR)CHAR length</title>
            <tgroup cols="5">
              <colspec colname="colPgsize" colwidth="*"></colspec>
              <colspec colname="col1B" colwidth="*"></colspec>
              <colspec colname="col2B" colwidth="*"></colspec>
              <colspec colname="col3B" colwidth="*"></colspec>
              <colspec colname="col4B" colwidth="*"></colspec>
              <spanspec spanname="4cols" namest="col1B" nameend="col4B"></spanspec>
              <thead>
                <row valign="middle">
                  <entry align="center" morerows="1">Page Size</entry>
                  <entry align="center" spanname="4cols">Maximum Indexable String Length by Charset Type</entry>
                </row>
                <row>
                  <entry align="center">1 byte/char</entry>
                  <entry align="center">2 bytes/char</entry>
                  <entry align="center">3 bytes/char</entry>
                  <entry align="center">4 bytes/char</entry>
                </row>
              </thead>
              <tbody>
                <row valign="middle">
                  <entry align="center">4096</entry>
                  <entry align="center">1015</entry>
                  <entry align="center">507</entry>
                  <entry align="center">338</entry>
                  <entry align="center">253</entry>
                </row>
                <row valign="middle">
                  <entry align="center">8192</entry>
                  <entry align="center">2039</entry>
                  <entry align="center">1019</entry>
                  <entry align="center">679</entry>
                  <entry align="center">509</entry>
                </row>
                <row valign="middle">
                  <entry align="center">16384</entry>
                  <entry align="center">4087</entry>
                  <entry align="center">2043</entry>
                  <entry align="center">1362</entry>
                  <entry align="center">1021</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section> <!-- Index limits -->


      <para>Only the table owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>CREATE INDEX</database>.</para>

      <section id="fblangref25-ddl-tbl-crtidxexmpls">
        <title>Examples Using <database>CREATE INDEX</database></title>
        <orderedlist>
          <listitem>Creating an index for the UPDATER_ID table in the SALARY_HISTORY table
            <programlisting>
CREATE INDEX IDX_UPDATER
    ON SALARY_HISTORY (UPDATER_ID);
            </programlisting>
          </listitem>
          <listitem>Creating an index with keys sorted in the descending order for the
          CHANGE_DATE column in the SALARY_HISTORY table
            <programlisting>
CREATE DESCENDING INDEX IDX_CHANGE
   ON SALARY_HISTORY (CHANGE_DATE);
            </programlisting>
          </listitem>
          <listitem>Creating a multi-segment index for the ORDER_STATUS, PAID columns in the SALES table
            <programlisting>
CREATE INDEX IDX_SALESTAT
    ON SALES (ORDER_STATUS, PAID);
            </programlisting>
          </listitem>
          <listitem>Creating an index that does not permit duplicate values
          for the NAME column in the COUNTRY table
            <programlisting>
CREATE UNIQUE INDEX UNQ_COUNTRY_NAME
    ON COUNTRY (NAME);
            </programlisting>
          </listitem>
          <listitem>Creating a computed index for the PERSONS table
            <programlisting>
CREATE INDEX IDX_NAME_UPPER ON PERSONS
    COMPUTED BY (UPPER (NAME));
            </programlisting>
          An index like this can be used for a case-insensitive search:
            <programlisting>
SELECT *
    FROM PERSONS
    WHERE UPPER(NAME) STARTING WITH UPPER('Iv');
            </programlisting>
          </listitem>
        </orderedlist>
      </section> <!-- index examples -->

      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-idx-altridx"><database>ALTER INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-dropidx"><database>DROP INDEX</database></link>
        </para>
      </formalpara>
    </section> <!-- create index -->

    <section id="fblangref25-ddl-idx-altridx">
      <title><database>ALTER INDEX</database></title>
      <formalpara><title>Used for</title>
        <para>Activating or deactivating an index; rebuilding an index</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER INDEX indexname {ACTIVE | INACTIVE};
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-idx-alteridx">
      <?dbfo keep-together='auto'?>
        <title>ALTER INDEX Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Index name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <database>ALTER INDEX</database> statement activates or deactivates an index.
      There is no facility on this statement for altering any attributes of the index.
        <itemizedlist>
          <listitem>
            <para>With the <database>INACTIVE</database> option, the index is switched from the
            active to inactive state. The effect is similar to the <database>DROP INDEX</database> statement
            except that the index definition remains in the database.  Altering a constraint index to the
            inactive state is not permitted.</para>
            <para>An active index can be deactivated if there are no queries using that index; otherwise,
            an <quote>object in use</quote> error is returned.</para>
            <para>Activating an inactive index is also safe.  However, if there are active transactions
            modifying the table, the transaction containing the <database>ALTER INDEX</database>
            statement will fail if it has the <database>NOWAIT</database> attribute.  If the transaction is
            in <database>WAIT</database> mode, it will wait for completion of concurrent transactions.</para>
            <para>On the other side of the coin, if our <database>ALTER INDEX</database> succeeds and starts
            to rebuild the index at <database>COMMIT</database>, other transactions modifying that table
            will fail or wait, according to their <database>WAIT/NO WAIT</database> attributes. The situation
            is exactly the same for <database>CREATE INDEX</database>.</para>
            <note>
              <title>How is it Useful?</title>
              <para>It might be useful to switch an index to the inactive state whilst inserting,
              updating or deleting a large batch of records in the table that owns the index.</para>
            </note>
          </listitem>

          <listitem>With the ACTIVE option, if the index is in the inactive state, it will be switched to
          active state and the system rebuilds the index.
            <note>
              <title>How is it Useful?</title>
              <para>Even if the index is <emphasis>active</emphasis> when <database>ALTER INDEX ... ACTIVE</database>
              is executed, the index will be rebuilt.  Rebuilding indexes can be a useful piece of houskeeping to
              do, occasionally, on the indexes of a large table in a database that has frequent inserts, updates or
              deletes but is infrequently restored.</para>
            </note>
          </listitem>
        </itemizedlist>
      </para>

      <section id="fblangref25-ddl-idx-altrcnstrntidx">
        <title>Use of <database>ALTER INDEX</database> on a Constraint Index</title>
        <para>Altering the enforcing index of a <database>PRIMARY KEY, FOREIGN KEY</database>
        or <database>UNIQUE</database> constraint to <database>INACTIVE</database> is not permitted.
        However, <database>ALTER INDEX ... ACTIVE</database> works just as well with constraint
        indexes as it does with others, as an index rebuilding tool.</para>
      </section>

      <para>Only the table owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>ALTER INDEX</database>.</para>

      <formalpara>
        <title>ALTER INDEX Examples</title>
        <orderedlist>
          <listitem>Deactivating the IDX_UPDATER index
            <programlisting>
ALTER INDEX IDX_UPDATER INACTIVE;
            </programlisting>
          </listitem>
          <listitem>Switching the IDX_UPDATER index back to the active state and rebuilding it
            <programlisting>
ALTER INDEX IDX_UPDATER ACTIVE;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-idx-create"><database>CREATE INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-dropidx"><database>DROP INDEX</database></link>,
        <database>SET STATISTICS</database>
        </para>
      </formalpara>
    </section> <!-- Alter index -->

    <section id="fblangref25-ddl-idx-dropidx">
      <title><database>DROP INDEX</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting an index</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP INDEX indexname;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-idx-dropidx">
      <?dbfo keep-together='auto'?>
        <title>DROP INDEX Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Index name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP INDEX</database> statement deletes an the named index from
      the database.
        <note>
          <para>A constraint index cannot deleted using <database>DROP INDEX</database>.
          Constraint indexes are dropped during the process of executing the command
          <database>ALTER TABLE ... DROP CONSTRAINT ...</database>.</para>
        </note>
      </para>

      <para>Only the table owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>DROP INDEX</database>.</para>

      <formalpara>
        <title>DROP INDEX Example</title>
        <para> Deleting the IDX_UPDATER index
          <blockquote><programlisting>
DROP INDEX IDX_UPDATER;
           </programlisting></blockquote>
         </para>
       </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-idx-create"><database>CREATE INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-altridx"><database>ALTER INDEX</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop index -->

    <section id="fblangref25-ddl-idx-setsttstcs">
      <title><database>SET STATISTICS</database></title>
      <formalpara><title>Used for</title>
        <para>Recalculating the selectivity of an index</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
SET STATISTICS INDEX indexname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-idx-setsttstcs">
      <?dbfo keep-together='auto'?>
        <title>SET STATISTICS Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">indexname</entry>
              <entry align="left">Index name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>SET STATISTICS</database> statement recalculates the selectivity of the
      specified index.</para>
      <section id="fblangref25-ddl-idx-selectivity">
        <title>Index Selectivity</title>
        <para>The selectivity of an index is the result of evaluating the number of rows that can
        be selected in a search on every index value. A unique index has the maximum selectivity
        because it is impossible to select more than one row for each value of an index key if
        it is used. Keeping the selectivity of an index up to date is important for the optimizer's
        choices in seeking the most optimal query plan.</para>
        <para>Index statistics in Firebird are not automatically recalculated in response to large 
        batches of inserts, updates or deletions.  It may be beneficial to recalculate the selectivity 
        of an index after such operations because the selectivity tends to become outdated.
          <note>
            <para>The statements <database>CREATE INDEX</database> and <database>ALTER INDEX
            ACTIVE</database> both store index statistics that completely correspond to the
            contents of the newly-[re]built index.</para>
          </note>
        </para>
      </section>

      <para>The selectivity of an index can be recalculated by the owner of the table
      or an <link linkend="fblangref25-security-administrators">administrator</link>. It can be
      performed under concurrent load without risk of corruption.  However, be aware that,
      under concurrent load, the newly calculated statistics could become outdated as soon as
      <database>SET STATISTICS</database> finishes.</para>

      <formalpara>
        <title>Example Using SET STATISTICS</title>
        <para> Recalculating the selectivity of the index IDX_UPDATER
          <blockquote><programlisting>
SET STATISTICS INDEX IDX_UPDATER;
           </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-idx-create"><database>CREATE INDEX</database></link>,
        <link linkend="fblangref25-ddl-idx-altridx"><database>ALTER INDEX</database></link>
        </para>
      </formalpara>
    </section> <!-- set statistics -->
  </section> <!-- INDEX -->

  <section id="fblangref25-ddl-view">
  <title><database>VIEW</database></title>
    <para>A view is a virtual table that is actually a stored and named <database>SELECT</database> query
    for retrieving data of any complexity. Data can be retrieved from one or more tables,
    from other views and also from selectable stored procedures.</para>
    <para>Unlike regular tables in relational databases, a view is not an independent data
    set stored in the database. The result is dynamically created as a data set when the view
    is selected.</para>
    <para>The metadata of a view are available to the process that generates the binary code
    for stored procedures and triggers, just as though they were concrete tables storing
    persistent data.</para>
    <section id="fblangref25-ddl-view-create">
      <title><database>CREATE VIEW</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a view</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-view-createview">
      <?dbfo keep-together='auto'?>
        <title>CREATE VIEW Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">View name, maximum 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">The list of columns in the view</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">View column name. Duplicate column names are not allowed.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE VIEW</database> statement creates a new view. The identifier (name) of a
      view must be unique among the names of all views, tables and stored procedures in the database.</para>
      <para>The name of the new view can be followed by the list of column names that should be returned to
      the caller when the view is invoked. Names in the list do not have to be related to the names of the
      columns in the base tables from which they derive.</para>
      <para>If the view column list is omitted, the system will use the column names and/or aliases from the
      <database>SELECT</database> statement. If duplicate names or non-aliased expression-derived columns make
      this impossible to obtain a valid list, creation of the view fails with an error.</para>
      <para>The number of columns in the view's list must exactly match the number of columns in the selection
      list of the underlying SELECT statement in the view definition.</para>
      <note>
        <title>Additional Points</title>
        <itemizedlist>
          <listitem>If the full list of columns is specified, it makes no sense to specify aliases
          in the <database>SELECT</database> statement because the names in the column list will override
          them</listitem>
          <listitem>The column list is optional if all of the columns in the <database>SELECT</database>
          are explicitly named and are unique in the selection list</listitem>
        </itemizedlist>
      </note>
      <section id="fblangref25-ddl-view-create-updatable">
        <title>Updatable Views</title>
        <para>A view can be updatable or read-only. If a view is updatable, the data retrieved when this
        view is called can be changed by the DML statements <database>INSERT</database>,
        <database>UPDATE</database>, <database>DELETE</database>, <database>UPDATE OR INSERT</database>
        or <database>MERGE</database>. Changes made in an updatable view are applied to the underlying
        table(s).</para>
        <para>A read-only view can be made updateable with the use of triggers. Once triggers have been
        defined on a view, changes posted to it will never be written automatically to the underlying table,
        even if the view was updateable to begin with. It is the responsibility of the programmer to ensure
        that the triggers update (or delete from, or insert into) the base tables as needed.</para>
        <para>A view will be automatically updatable if all of the following conditions are met:
          <itemizedlist>
            <listitem>the <database>SELECT</database> statement queries only one table or one
            updatable view</listitem>
            <listitem>the <database>SELECT</database> statement does not call any stored
            procedures</listitem>
            <listitem>each base table (or base view) column not present in the view definition is covered
            by one of the following conditions:
              <itemizedlist spacing="compact">
                <listitem>it is nullable</listitem>
                <listitem>it has a non-NULL default value</listitem>
                <listitem>it has a trigger that supplies a permitted value</listitem>
              </itemizedlist>
            </listitem>
            <listitem>the <database>SELECT</database> statement contains no fields derived from subqueries
            or other expressions</listitem>
            <listitem>the <database>SELECT</database> statement does not contain fields defined through
            aggregate functions, such as <database>MIN</database>, <database>MAX</database>, <database>AVG</database>,
            <database>SUM</database>, <database>COUNT</database>, <database>LIST</database></listitem>
           <listitem>the <database>SELECT</database> statement contains no <database>ORDER BY</database> or
           <database>GROUP BY</database> clause</listitem>
           <listitem>the <database>SELECT</database> statement does not include the keyword <database>DISTINCT</database>
           or row-restrictive keywords such as <database>ROWS</database>, <database>FIRST</database>,
           <database>SKIP</database></listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="fblangref25-ddl-view-create-chkopt">
        <title><database>WITH CHECK OPTION</database></title>
        <para>The optional <database>WITH CHECK OPTION</database> clause requires an updatable view to
        check whether new or updated data meet the condition specified in the <database>WHERE</database>
        clause of the <database>SELECT</database> statement. Every attempt to insert a new record or to
        update an existing one is checked as to whether the new or updated record would meet the
        <database>WHERE</database> criteria. If they fail the check, the operation is not performed
        and an appropriate error message is returned.</para>
        <para><database>WITH CHECK OPTION</database> can be specified only in a CREATE VIEW statement
        in which a WHERE clause is present to restrict the output of the main <database>SELECT</database>
        statement. An error message is returned otherwise.</para>

        <important>
         <title>Please note:</title>
         <para>If <database>WITH CHECK OPTION</database> is used, the engine checks the input against
         the <database>WHERE</database> clause before passing anything to the base relation. Therefore,
         if the check on the input fails, any default clauses or triggers on the base relation that
         might have been designed to correct the input will never come into action.</para>
         <para>Furthermore, view fields omitted from the <database>INSERT</database> statement are
         passed as <database>NULL</database>s to the base relation, regardless of their presence or
         absence in the <database>WHERE</database> clause. As a result, base table defaults defined on
         such fields will not be applied. Triggers, on the other hand, will fire and work as
         expected.</para>
         <para>For views that do not have <database>WITH CHECK OPTION</database>, fields omitted
         from the <database>INSERT</database> statement are not passed to the base relation at all, so
         any defaults will be applied.</para>
       </important>
     </section>

      <section id="fblangref25-ddl-view-createwho">
        <title>Ownership of a View</title>
        <para>The creator of a view becomes its owner.</para>
        <para>To create a view, a non-admin user needs at least <database>SELECT</database>
        access to the underlying table(s) and/or view(s), and the <database>EXECUTE</database> 
        privilege on any selectable stored procedures involved.</para>
        <para>To enable insertions, updates and deletions through the view, the
        creator/owner must also possess the corresponding <database>INSERT</database>, 
        <database>UPDATE</database> and <database>DELETE</database> rights on the base 
        object(s).</para>
        <para>Granting other users privileges on the view is only possible if the view owner 
        himself has these privileges on the underlying objects <database>WITH GRANT 
        OPTION</database>. It will always be the case if the view owner is also the owner of 
        the underlying objects.</para>
      </section>

      <formalpara>
        <title>Examples of Creating Views</title>
        <orderedlist>
          <listitem>Creating view returning the JOB_CODE and JOB_TITLE columns only for those jobs
          where MAX_SALARY is less than $15,000.
            <programlisting>
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY &lt; 15000;
            </programlisting>
          </listitem>
          <listitem>Creating a view returning the JOB_CODE and JOB_TITLE columns only for those jobs
          where MAX_SALARY is less than $15,000. Whenever a new record is inserted or an existing
          record is updated, the MAX_SALARY &lt; 15000 condition will be checked. If the condition
          is not true, the insert/update operation will be rejected.
            <programlisting>
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY &lt; 15000
WITH CHECK OPTION;
            </programlisting>
          </listitem>
          <listitem>Creating a view with an explicit column list.
            <programlisting>
CREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1
FROM PRICE;
            </programlisting>
          </listitem>
          <listitem>Creating a view with the help of aliases for fields in the SELECT statement
          (the same result as in Example 3).
            <programlisting>
CREATE VIEW PRICE_WITH_MARKUP AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1 AS COST_WITH_MARKUP
FROM PRICE;
            </programlisting>
          </listitem>
          <listitem>Creating a read-only view based on two tables and a stored procedure.
            <programlisting>
CREATE VIEW GOODS_PRICE AS
SELECT
    goods.name AS goodsname,
    price.cost AS cost,
    b.quantity AS quantity
FROM
    goods
    JOIN price ON goods.code_goods = price.code_goods
    LEFT JOIN sp_get_balance(goods.code_goods) b ON 1 = 1;
           </programlisting>
         </listitem>
       </orderedlist>
     </formalpara>
     <formalpara><title>See also</title>
       <para> <link linkend="fblangref25-ddl-view-alter"><database>ALTER VIEW</database></link>,
       <link linkend="fblangref25-ddl-view-crtoralter"><database>CREATE OR ALTER VIEW</database></link>,
       <link linkend="fblangref25-ddl-view-recreate"><database>RECREATE VIEW</database></link>,
       <link linkend="fblangref25-ddl-view-drop"><database>DROP VIEW</database></link>
       </para>
     </formalpara>
   </section> <!-- create view -->

   <section id="fblangref25-ddl-view-alter">
      <title><database>ALTER VIEW</database></title>
      <formalpara><title>Used for</title>
        <para>Modifying an existing view</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-view-alterview">
      <?dbfo keep-together='auto'?>
        <title>ALTER VIEW Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">Name of an existing view</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">The list of columns in the view</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">View column name. Duplicate column names are not allowed.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Use the <database>ALTER VIEW</database> statement for changing the definition of an
      existing view. Privileges for views remain intact and dependencies are not affected.</para>

      <para>The syntax of the <database>ALTER VIEW</database> statement corresponds completely
      with that of <database>CREATE VIEW</database>.
        <caution>
          <para>Be careful when you change the number of columns in a view. Existing application code
          and PSQL modules that access the view may become invalid.
          For information on how to detect this kind of problem in stored procedures and trigger,
          see <link linkend="fblangref25-appx01-supp-rdb_validblr"><citetitle>The <database>RDB$VALID_BLR</database>
          Field</citetitle></link> in the Appendix.</para>
        </caution>
      </para>

      <para>Only the view owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>ALTER VIEW</database>.</para>

      <formalpara>
        <title>Example using ALTER VIEW</title>
        <para>Altering the view PRICE_WITH_MARKUP
          <blockquote><programlisting>
ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-view-create"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-crtoralter"><database>CREATE OR ALTER VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-recreate"><database>RECREATE VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- alter view -->

    <section id="fblangref25-ddl-view-crtoralter">
      <title><database>CREATE OR ALTER VIEW</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new view or altering an existing view.</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-view-crtalterview">
      <?dbfo keep-together='auto'?>
        <title>CREATE OR ALTER VIEW Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">Name of a view which may or may not exist</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">The list of columns in the view</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">View column name. Duplicate column names are not allowed.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Use the <database>CREATE OR ALTER VIEW</database> statement for changing the definition 
      of an existing view or creating it if it does not exist. Privileges for an existing view
      remain intact and dependencies are not affected.</para>
      <para>The syntax of the <database>CREATE OR ALTER VIEW</database> statement corresponds
      completely with that of <database>CREATE VIEW</database>.</para>
      <formalpara>
        <title>Example</title>
        <para> Creating the new view PRICE_WITH_MARKUP view or altering it if it already exists:
          <blockquote><programlisting>
CREATE OR ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-view-create"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-alter"><database>ALTER VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-recreate"><database>RECREATE VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- Create or alter view -->

    <section id="fblangref25-ddl-view-drop">
      <title><database>DROP VIEW</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting (dropping) a view</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP VIEW viewname;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-view-dropview">
      <?dbfo keep-together='auto'?>
        <title>DROP VIEW Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">View name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP VIEW</database> statement deletes an existing view.
      The statement will fail if the view has dependencies.</para>

      <para>Only the view owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to use <database>DROP VIEW</database>.</para>
      <formalpara>
        <title>Example</title>
        <para> Deleting the PRICE_WITH_MARKUP view.
          <blockquote><programlisting>
DROP VIEW PRICE_WITH_MARKUP;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-view-create"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-recreate"><database>RECREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-crtoralter"><database>CREATE OR ALTER VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop view -->

    <section id="fblangref25-ddl-view-recreate">
      <title><database>RECREATE VIEW</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new view or recreating an existing view</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE VIEW viewname [&lt;full_column_list&gt;]
AS &lt;select_statement&gt;
[WITH CHECK OPTION];

&lt;full_column_list&gt; ::= (colname [, colname ...])
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-view-recreate">
      <?dbfo keep-together='auto'?>
        <title>RECREATE VIEW Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">View name, maximum 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_statement</entry>
              <entry align="left">SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">full_column_list</entry>
              <entry align="left">The list of columns in the view</entry>
            </row>
            <row valign="middle">
              <entry align="center">colname</entry>
              <entry align="left">View column name. Duplicate column names are not allowed.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Creates or recreates a view. If there is a view with this name already,
      the engine will try to drop it before creating the new instance. If the existing view 
      cannot be dropped, because of dependencies or insufficient rights, for example, 
      <database>RECREATE VIEW</database> fails with an error.</para>
      <formalpara>
        <title>Example</title>
        <para> Creating the new view PRICE_WITH_MARKUP view or recreating it, if it already
        exists.
          <blockquote><programlisting>
RECREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-view-create"><database>CREATE VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-drop"><database>DROP VIEW</database></link>,
        <link linkend="fblangref25-ddl-view-crtoralter"><database>CREATE OR ALTER VIEW</database></link>
        </para>
      </formalpara>
    </section> <!-- Recreate view -->
  </section> <!--VIEW -->

  <section id="fblangref25-ddl-trgr">
    <title><database>TRIGGER</database></title>
    <para>A trigger is a special type of stored procedure that is not called directly,
    instead being executed when a specified event occurs in the associated table or view.
    A trigger is specific to one and only one relation (table or view) and one phase in
    the timing of the event (<emphasis>BEFORE</emphasis> or <emphasis>AFTER</emphasis>).
    It can be specified to execute for one specific event (insert, update, delete)
    or for some combination of two or three of those events.</para>
    <para>Another form of trigger&mdash;known as a <quote>database trigger</quote>&mdash;can
    be specified to fire in association with the start or end of a user session (connection)
    or a user transaction.</para>
    <section id="fblangref25-ddl-trgr-create">
      <title><database>CREATE TRIGGER</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new trigger</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE TRIGGER trigname  {
  &lt;relation_trigger_legacy&gt; |
  &lt;relation_trigger_sql2003&gt; |
  &lt;database_trigger&gt; }
AS
	[&lt;declarations&gt;]
BEGIN
	[&lt;PSQL_statements&gt;]
END

&lt;relation_trigger_legacy&gt; ::=
  FOR {tablename | viewname}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} &lt;mutation_list&gt;
  [POSITION number]

&lt;relation_trigger_sql2003&gt; ::=
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} &lt;mutation_list&gt;
  [POSITION number]
  ON {tablename | viewname}

&lt;database_trigger&gt; ::=
  [ACTIVE | INACTIVE] ON db_event [POSITION number]

&lt;mutation_list&gt; ::=
  &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::= {
  CONNECT |
  DISCONNECT |
  TRANSACTION START |
  TRANSACTION COMMIT |
  TRANSACTION ROLLBACK
}

&lt;declarations&gt; ::= {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
  [{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-trgr-createtrigger">
      <?dbfo keep-together='auto'?>
        <title>CREATE TRIGGER Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">trigname</entry>
              <entry align="left">Trigger name consisting of up to 31 characters.  It must be unique 
              among all trigger names in the database.</entry>
            </row>
            <row valign="middle">
              <entry align="center">relation_trigger_legacy</entry>
              <entry align="left">Legacy style of trigger declaration for a relation trigger</entry>
            </row>
            <row valign="middle">
              <entry align="center">relation_trigger_sql2003</entry>
              <entry align="left">Relation trigger declaration compliant with the SQL:2003 standard</entry>
            </row>
            <row valign="middle">
              <entry align="center">database_trigger</entry>
              <entry align="left">Database trigger declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">Name of the table with which the relation trigger is associated</entry>
            </row>
            <row valign="middle">
              <entry align="center">viewname</entry>
              <entry align="left">Name of the view with which the relation trigger is associated</entry>
            </row>
            <row valign="middle">
              <entry align="center">mutation_list</entry>
              <entry align="left">List of relation (table | view) events</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Position of the trigger in the firing order. From 0 to 32,767</entry>
            </row>
            <row valign="middle">
              <entry align="center">db_event</entry>
              <entry align="left">Connection or transaction event</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Section for declaring local variables and named cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Local variable declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Named cursor declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Statements in Firebird's programming language (PSQL)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE TRIGGER</database> statement is used for creating a new trigger.
      A trigger can be created either for a <emphasis>relation (table | view) event</emphasis>
      (or a combination of events), or for a <emphasis>database event</emphasis>.</para>
      <para><database>CREATE TRIGGER</database>, along with its associates <database>ALTER TRIGGER</database>,
      <database>CREATE OR ALTER TRIGGER</database> and <database>RECREATE TRIGGER</database>,
      is a <emphasis>compound statement</emphasis>, consisting of a header and a body.  The
      header specifies the name of the trigger, the name of the relation (for a relation
      trigger), the phase of the trigger and the event[s] it applies to.  The body consists of
      optional declarations of local variables and named cursors followed by one or more statements, or
      blocks of statements, all enclosed in an outer block that begins with the
      keyword <database>BEGIN</database> and ends with the keyword <database>END</database>.
      Declarations and embedded statements are terminated with semi-colons (<command>;</command>).</para>
      <para>The name of the trigger must be unique among all trigger names.</para>
      
      <section id="fblangref25-ddl-terminators01">
        <title>Statement Terminators</title>
        <para>Some SQL statement editors&mdash;specifically the <emphasis>isql</emphasis> utility that comes
        with Firebird and possibly some third-party editors&mdash;employ an internal convention that requires
        all statements to be terminated with a semi-colon.  This creates a conflict with PSQL syntax when
        coding in these environments.  If you are unacquainted with this problem and its solution, please study
        the details in the PSQL chapter in the section entitled <link linkend="fblangref25-sidebar01">Switching
        the Terminator in <emphasis>isql</emphasis></link>.</para>
      </section>

      <section id="fblangref25-ddl-trgr-relntrigger">
        <title>Relation Triggers (on Tables or Views)</title>
        <para>Relation triggers are executed at the row (record) level every time the row image changes.
        A trigger can be either <database>ACTIVE</database> or <database>INACTIVE</database>. Only
        active triggers are executed. Triggers are created <database>ACTIVE</database> by default.</para>

        <section id="fblangref25-ddl-trgr-relntrigger-form">
          <title>Forms of Declaration</title>
          <para>Firebird supports two forms of declaration for relation triggers:
          <itemizedlist spacing="compact">
            <listitem>The original, legacy syntax</listitem>
            <listitem>The SQL:2003 standard-compliant form (recommended)</listitem>
          </itemizedlist>
          The SQL:2003 standard-compliant form is the recommended one.</para>
        </section>

        <para>A relation trigger specifies&mdash;among other things&mdash;a <emphasis>phase</emphasis> and one or
        more <emphasis>events</emphasis>.</para>

        <section id="fblangref25-ddl-trgr-relntrigger-rowphase">
          <title>Phase</title>
          <para>Phase concerns the timing of the trigger with regard to the change-of-state event in
          the row of data:
            <itemizedlist spacing="compact">
              <listitem>A <database>BEFORE</database> trigger is fired before the specified database operation
              (insert, update or delete) is carried out</listitem>
              <listitem>An <database>AFTER</database> trigger is fired after the database operation has been
              completed</listitem>
            </itemizedlist>
          </para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-rowevent">
          <title>Row Events</title>
          <para>A relation trigger definition specifies at least one of the DML operations INSERT, UPDATE 
          and DELETE, to indicate one or more events on which the trigger should fire.  If multiple operations 
          are specified, they must be separated by the keyword <database>OR</database>. No operation may 
          occur more than once.</para>
          <para>Within the statement block, the Boolean context variables
          <link linkend="fblangref25-contextvars-inserting"><database>INSERTING</database></link>,
          <link linkend="fblangref25-contextvars-updating"><database>UPDATING</database></link> and
          <link linkend="fblangref25-contextvars-deleting"><database>DELETING</database></link>
          can be used to test which operation is currently executing.</para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-position">
          <title>Firing Order of Triggers</title>
          <para>The keyword <database>POSITION</database> allows an optional execution order
          (<quote>firing order</quote>) to be specified for a series of triggers that have the same phase
          and event as their target. The default position is 0. If no positions are specified, or if several
          triggers have a single position number, the triggers will be executed in the alphabetical order
          of their names.</para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-declrtns">
          <title>Variable Declarations</title>
          <para>The optional declarations section beneath the keyword <database>AS</database> in the header of
          the trigger is for defining variables and named cursors that are local to the trigger. For more 
          details, see <link linkend="fblangref25-psql-declare-variable"><database>DECLARE VARIABLE</database></link>
          and
          <link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link> in the
          <link linkend="fblangref25-psql">Procedural SQL</link> chapter.</para>
        </section>

        <section id="fblangref25-ddl-trgr-relntrigger-body">
          <title>The Trigger Body</title>
          <para>The local declarations (if any) are the final part of a trigger's header section.  The
          trigger body follows, where one or more blocks of PSQL statements are enclosed in a structure
          that starts with the keyword <database>BEGIN</database> and terminates with the
          keyword <database>END</database>.</para>
        </section>

        <para>Only the owner of the view or table and <link linkend="fblangref25-security-administrators">administrators</link>
        have the authority to use <database>CREATE TRIGGER</database>.</para>

        <formalpara>
          <title>Examples of CREATE TRIGGER for Tables and Views</title>
          <orderedlist>
            <listitem>Creating a trigger in the <quote>legacy</quote> form, firing before the
            event of inserting a new record into the CUSTOMER table occurs.
              <programlisting>
CREATE TRIGGER SET_CUST_NO FOR CUSTOMER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CUST_NO IS NULL) THEN
    NEW.CUST_NO = GEN_ID(CUST_NO_GEN, 1);
END
              </programlisting>
            </listitem>
            <listitem>Creating a trigger firing before the event of inserting a new record
            into the CUSTOMER table in the SQL:2003 standard-compliant form.
              <programlisting>
CREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
              </programlisting>
            </listitem>
            <listitem>Creating a trigger that will file after either inserting, updating
            or deleting a record in the CUSTOMER table.
              <programlisting>
CREATE TRIGGER TR_CUST_LOG
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
ON CUSTOMER
AS
BEGIN
  INSERT INTO CHANGE_LOG (LOG_ID,
                          ID_TABLE,
                          TABLE_NAME,
                          MUTATION)
  VALUES (NEXT VALUE FOR SEQ_CHANGE_LOG,
          OLD.CUST_NO,
          'CUSTOMER',
          CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING  THEN 'UPDATE'
            WHEN DELETING  THEN 'DELETE'
          END);
END
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
      </section><!-- Relation triggers -->

      <section id="fblangref25-ddl-trgr-dbtrigger">
        <title>Database Triggers</title>
        <para>Triggers can be defined to fire upon <quote>database events</quote>,
        which really refers to a mixture of events that act across the scope of a
        session (connection) and events that act across the scope of an individual
        transaction:
          <blockquote><itemizedlist spacing="compact">
            <listitem>CONNECT</listitem>
            <listitem>DISCONNECT</listitem>
            <listitem>TRANSACTION START</listitem>
            <listitem>TRANSACTION COMMIT</listitem>
            <listitem>TRANSACTION ROLLBACK</listitem>
          </itemizedlist></blockquote>
        </para>

        <section id="fblangref25-ddl-trgr-dbtrigger-exec">
          <title>Execution of Database Triggers and Exception Handling</title>
          <para><database>CONNECT</database> and <database>DISCONNECT</database> triggers
          are executed in a transaction created specifically for this purpose. If all goes
          well, the transaction is committed. Uncaught exceptions cause the transaction to
          roll back, and
            <itemizedlist>
              <listitem>for a <database>CONNECT</database> trigger, the connection is
            then broken and the exception is returned to the client</listitem>
              <listitem>for a <database>DISCONNECT</database> trigger, exceptions are not
              reported.  The connection is broken as intended</listitem>
            </itemizedlist>
          </para>

          <para><database>TRANSACTION</database> triggers are executed within the transaction
          whose start, commit or rollback evokes them. The action taken after an uncaught
          exception depends on the event:
            <itemizedlist>
              <listitem>In a <database>TRANSACTION START</database> trigger, the exception
              is reported to the client and the transaction is rolled back</listitem>
              <listitem>In a <database>TRANSACTION COMMIT</database> trigger, the exception
              is reported, the trigger's actions so far are undone and the commit is
              cancelled</listitem>
              <listitem>In a <database>TRANSACTION ROLLBACK</database> trigger, the exception
              is not reported and the transaction is rolled back as intended.</listitem>
            </itemizedlist>
          </para>

          <section id="fblangref25-ddl-trgr-dbtrigger-traps">
            <title>Traps</title>
            <para>Obviously there is no direct way of knowing if a <database>DISCONNECT</database>
            or <database>TRANSACTION ROLLBACK</database> trigger caused an exception. It also follows
            that the connection to the database cannot happen if a <database>CONNECT</database>
            trigger causes an exception and a transaction cannot start if a <database>TRANSACTION
            START</database> trigger causes one, either. Both phenomena effectively lock you out
            of your database until you get in there with database triggers suppressed and fix the 
            bad code.</para>
            
            <section id="fblangref25-ddl-trgr-dbtrigger-notrgr">
              <title>Trigger Suppression</title>
              <para>Some Firebird command-line tools have been supplied with switches that an 
              administrator can use to suppress the automatic firing of database triggers.  
              So far, they are:
                <blockquote><literallayout class="monospaced">
gbak -nodbtriggers
isql -nodbtriggers
nbackup -T
                </literallayout></blockquote>
              </para>
            </section>
          </section>

          <section id="fblangref25-ddl-trgr-dbtrigger-2pc">
            <title>Two-phase Commit</title>
            <para>In a two-phase commit scenario, <database>TRANSACTION COMMIT</database> triggers
            fire in the prepare phase, not at the commit.</para>
          </section>

          <section id="fblangref25-ddl-trgr-dbtrigger-caveats">
            <title>Some Caveats</title>
            <orderedlist>
              <listitem>The use of the <database>IN AUTONOMOUS TRANSACTION DO</database> statement
              in the database event triggers related to transactions (<database>TRANSACTION START</database>,
              <database>TRANSACTION ROLLBACK</database>, <database>TRANSACTION COMMIT</database>) may
              cause the autonomous transaction to enter an infinite loop</listitem>
              <listitem>The <database>DISCONNECT</database> and <database>TRANSACTION ROLLBACK</database>
              event triggers will not be executed when clients are disconnected via monitoring tables
              (<database>DELETE FROM MON$ATTACHMENTS</database>)</listitem>
            </orderedlist>
          </section>
        </section> <!-- Excecution etc. -->

      <para>Only the database owner and <link linkend="fblangref25-security-administrators">administrators</link>
      have the authority to create database triggers.</para>

        <formalpara>
          <title>Examples of CREATE TRIGGER for <quote>Database Triggers</quote></title>
          <orderedlist>
            <listitem>Creating a trigger for the event of connecting to the database that
            logs users logging into the system. The trigger is created as inactive.
              <programlisting>
CREATE TRIGGER tr_log_connect
INACTIVE ON CONNECT POSITION 0
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_TIMESTAMP);
END
              </programlisting>
            </listitem>
            <listitem>Creating a trigger for the event of connecting to the database that
            does not permit any users, except for SYSDBA, to log in during off hours.
              <programlisting>
CREATE EXCEPTION E_INCORRECT_WORKTIME 'The working day has not started yet.';

CREATE TRIGGER TR_LIMIT_WORKTIME ACTIVE
ON CONNECT POSITION 1
AS
BEGIN
  IF ((CURRENT_USER &lt;&gt; 'SYSDBA') AND
      NOT (CURRENT_TIME BETWEEN time '9:00' AND time '17:00')) THEN
     EXCEPTION E_INCORRECT_WORKTIME;
END
              </programlisting>
            </listitem>
          </orderedlist>
        </formalpara>
        <formalpara><title>See also</title>
          <para> <link linkend="fblangref25-ddl-trgr-alter"><database>ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-crtalter"><database>CREATE OR ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-recreate"><database>RECREATE TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-drop"><database>DROP TRIGGER</database></link>
          </para>
        </formalpara>
      </section> <!-- Database triggers -->
    </section> <!-- Create trigger -->

    <section id="fblangref25-ddl-trgr-alter">
      <title><database>ALTER TRIGGER</database></title>
      <formalpara><title>Used for</title>
        <para>Modifying and deactivating an existing trigger </para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER TRIGGER trigname
[ACTIVE | INACTIVE]
[{BEFORE | AFTER} &lt;mutation_list&gt; | ON db_event]
[POSITION number]
[
 AS
  [&lt;declarations&gt;]
	 BEGIN
    [&lt;PSQL_statements&gt;]
	 END
]

&lt;mutation_list&gt; ::=
  &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::= {
  CONNECT |
  DISCONNECT |
  TRANSACTION START |
  TRANSACTION COMMIT |
  TRANSACTION ROLLBACK
}

&lt;declarations&gt; ::= {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
	[{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-altertrigger">
      <?dbfo keep-together='auto'?>
        <title>ALTER TRIGGER Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">trigname</entry>
              <entry align="left">Name of an existing trigger</entry>
            </row>
            <row valign="middle">
              <entry align="center">mutation_list</entry>
              <entry align="left">List of relation (table | view) events</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">Position of the trigger in the firing order. From 0 to 32,767</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Section for declaring local variables and named cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Local variable declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Named cursor declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Statements in Firebird's programming language (PSQL)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>ALTER TRIGGER</database> statement allows certain changes to the header
      and body of a trigger.</para>

      <section id="fblangref25-ddl-trgr-alterwhat">
        <title>Permitted Changes to Triggers</title>
        <itemizedlist>
          <listitem>Status (<database>ACTIVE | INACTIVE</database>)</listitem>
          <listitem>Phase (<database>BEFORE | AFTER</database>)</listitem>
          <listitem>Events; but relation trigger events cannot be changed to database trigger
          events, nor vice versa</listitem>
          <listitem>Position in the firing order</listitem>
          <listitem>Modifications to code in the trigger body</listitem>
        </itemizedlist>

        <para>If some element was not specified, it remains unchanged.</para>
        <note>
          <title>Reminders</title>
          <para>The BEFORE keyword directs that the trigger be executed before the
          associated event occurs; the AFTER keyword directs that it be executed
          after the event.</para>
          <para>More than one relation event&mdash;<database>INSERT, UPDATE,
          DELETE</database>&mdash;can be covered in a single trigger.  The events should
          be separated with the keyword <database>OR</database>.  No event should
          be mentioned more than once.</para>
          <para>The keyword <database>POSITION</database> allows an optional execution order
          (<quote>firing order</quote>) to be specified for a series of triggers that have the same phase
          and event as their target. The default position is 0. If no positions are specified, or if several
          triggers have a single position number, the triggers will be executed in the alphabetical order
          of their names.</para>
        </note>
       </section>

      <para><link linkend="fblangref25-security-administrators">Administrators</link> and the following 
      users have the authority to use <database>ALTER TRIGGER</database>:
        <itemizedlist spacing="compact">
          <listitem>For relation triggers, the owner of the table</listitem>
          <listitem>For database triggers, the owner of the database</listitem>
        </itemizedlist>
      </para>

      <formalpara>
        <title>Examples using ALTER TRIGGER</title>
        <orderedlist>
          <listitem>Deactivating the set_cust_no trigger (switching it to the inactive status).
            <programlisting>
ALTER TRIGGER set_cust_no INACTIVE;
            </programlisting>
          </listitem>

          <listitem>Changing the firing order position of the set_cust_no trigger.
            <programlisting>
ALTER TRIGGER set_cust_no POSITION 14;
            </programlisting>
          </listitem>

          <listitem>Switching the TR_CUST_LOG trigger to the inactive status and modifying
          the list of events.
            <programlisting>
ALTER TRIGGER TR_CUST_LOG
INACTIVE AFTER INSERT OR UPDATE;
            </programlisting>
          </listitem>

          <listitem>Switching the tr_log_connect trigger to the active status, changing its position and body.
            <programlisting>
ALTER TRIGGER tr_log_connect
ACTIVE POSITION 1
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ROLENAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_ROLE,
          CURRENT_TIMESTAMP);
END
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-trgr-create"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-crtalter"><database>CREATE OR ALTER TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-recreate"><database>RECREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-drop"><database>DROP TRIGGER</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter trigger -->

    <section id="fblangref25-ddl-trgr-crtalter">
      <title><database>CREATE OR ALTER TRIGGER</database></title>
      <formalpara><title>Used for</title>
        <para> Creating a new trigger or altering an existing trigger</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER TRIGGER trigname  {
  &lt;relation_trigger_legacy&gt; |
  &lt;relation_trigger_sql2003&gt; |
  &lt;database_trigger&gt; }
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
      </formalpara>
      <para>For the full detail of the syntax,
      see <link linkend="fblangref25-ddl-trgr-create"><database>CREATE TRIGGER</database></link>.</para>
      <para>The <database>CREATE OR ALTER TRIGGER</database> statement creates a new trigger if it does
      not exist; otherwise it alters and recompiles it with the privileges intact and dependencies
      unaffected.</para>
      <formalpara>
        <title>Example using CREATE OR ALTER TRIGGER</title>
        <para> Creating a new trigger if it does not exist or altering it if it does exist.
          <blockquote><programlisting>
CREATE OR ALTER TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-trgr-create"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-alter"><database>ALTER TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-recreate"><database>RECREATE TRIGGER</database></link>
        </para>
      </formalpara>
    </section><!-- create or alter trigger -->

    <section id="fblangref25-ddl-trgr-drop">
      <title><database>DROP TRIGGER</database></title>
      <formalpara><title>Used for</title>
        <para> Deleting an existing trigger</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP TRIGGER trigname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-droptrigger">
      <?dbfo keep-together='auto'?>
        <title>DROP TRIGGER Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">trigname</entry>
              <entry align="left">Trigger name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP TRIGGER</database> statement deletes an existing trigger.</para>

      <para><link linkend="fblangref25-security-administrators">Administrators</link> and the following
      users have the authority to use <database>DROP TRIGGER</database>:
        <itemizedlist spacing="compact">
          <listitem>For relation triggers, the owner of the table</listitem>
          <listitem>For database triggers, the owner of the database</listitem>
        </itemizedlist>
      </para>

      <formalpara>
        <title>Example using DROP TRIGGER</title>
        <para> Deleting the set_cust_no trigger.
          <blockquote><programlisting>
DROP TRIGGER set_cust_no;
          </programlisting></blockquote>
        </para>
      </formalpara>

      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-trgr-create"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-recreate"><database>RECREATE TRIGGER</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop trigger -->

    <section id="fblangref25-ddl-trgr-recreate">
      <title><database>RECREATE TRIGGER</database></title>
      <formalpara><title>Used for</title>
        <para> Creating a new trigger or recreating an existing trigger</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE TRIGGER trigname {
  &lt;relation_trigger_legacy&gt; | 
  &lt;relation_trigger_sql2003&gt; | 
  &lt;database_trigger&gt; }
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
      </formalpara>
      <para>For the full detail of the syntax,
      see <link linkend="fblangref25-ddl-trgr-create"><database>CREATE TRIGGER</database></link>.</para>
      <para>The <database>RECREATE TRIGGER</database> statement creates a new trigger if no trigger
      with the specified name exists; otherwise the <database>RECREATE TRIGGER</database> statement 
      tries to delete the existing trigger and create a new one.  The operation will fail on
      <database>COMMIT</database> if the trigger dependencies.</para>
      <warning>
        <para>Be aware that dependency errors are not detected until the <database>COMMIT</database> phase
        of this operation.</para>
      </warning>
      <formalpara>
        <title>Example using RECREATE TRIGGER</title>
        <para> Creating or recreating the set_cust_no trigger.
          <blockquote><programlisting>
RECREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-trgr-create"><database>CREATE TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-drop"><database>DROP TRIGGER</database></link>,
        <link linkend="fblangref25-ddl-trgr-crtalter"><database>CREATE OR ALTER TRIGGER</database></link>
        </para>
      </formalpara>
    </section><!-- create or alter trigger -->
  </section> <!-- TRIGGER -->

  <section id="fblangref25-ddl-procedure">
    <title><database>PROCEDURE</database></title>
    <para>A stored procedure is a software module that can be called from a client, another procedure,
    an executable block or a trigger. Stored procedures, executable blocks and triggers are written in
    procedural SQL (PSQL). Most SQL statements are available in PSQL as well, sometimes with limitations
    or extensions.  Among notable exceptions are DDL and transaction control statements.</para>
    <para>Stored procedures can have many input and output parameters.</para>

    <section id="fblangref25-ddl-proc-create">
      <title><database>CREATE PROCEDURE</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new stored procedure</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END

	&lt;inparam&gt; ::= &lt;param_decl&gt; [{= | DEFAULT} &lt;value&gt;]

	&lt;outparam&gt; ::= &lt;param_decl&gt;

	&lt;value&gt; ::= {literal | NULL | context_var}

	&lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL]
	[COLLATE collation]

&lt;type&gt; ::=
  &lt;datatype&gt; |
  [TYPE OF] domain |
  TYPE OF COLUMN rel.col

&lt;datatype&gt; ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

&lt;declarations&gt; ::=
  {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
    [{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-proc-createproc">
      <?dbfo keep-together='auto'?>
        <title>CREATE PROCEDURE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Stored procedure name consisting of up to 31 characters.
              Must be unique among all table, view and procedure names in the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">inparam</entry>
              <entry align="left">Input parameter description</entry>
            </row>
            <row valign="middle">
              <entry align="center">outparam</entry>
              <entry align="left">Output parameter description</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Section for declaring local variables and named cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Local variable declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Named cursor declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Procedural SQL statements</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">A literal value that is assignment-compatible with the data type 
              of the parameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Any context variable whose type is compatible with the
              data type of the parameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">The name of an input or output parameter of the procedure.
              It may consist of up to 31 characters. The name of the parameter must be unique
              among input and output parameters of the procedure and its local variables</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation sequence</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Domain name</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel</entry>
              <entry align="left">Table or view name</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Table or view column name</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">The total number of significant digits that the parameter should 
              be able to hold (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">The number of digits after the decimal point (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string type parameter or variable, in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Character set of a string type parameter or variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size (max. 65535)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE PROCEDURE</database> statement creates a new stored procedure. The name
      of the procedure must be unique among the names of all stored procedures, tables and views in the
      database.</para>

      <para><database>CREATE PROCEDURE</database> is a <emphasis>compound statement</emphasis>, consisting
      of a header and a body.  The header specifies the name of the procedure and declares input
      parameters and the output parameters, if any, that are to be returned by the procedure.</para>
      <para>The procedure body consists of declarations for any local variables and named cursors that will 
      be used by the procedure, followed by one or more statements, or blocks of statements, all enclosed
      in an outer block that begins with the keyword <database>BEGIN</database> and ends with the
      keyword <database>END</database>.  Declarations and embedded statements are terminated with semi-colons
      (<command>;</command>).</para>
      
      <section id="fblangref25-ddl-terminators02">
        <title>Statement Terminators</title>
        <para>Some SQL statement editors&mdash;specifically the <emphasis>isql</emphasis> utility that comes 
        with Firebird and possibly some third-party editors&mdash;employ an internal convention that requires 
        all statements to be terminated with a semi-colon.  This creates a conflict with PSQL syntax when 
        coding in these environments.  If you are unacquainted with this problem and its solution, please study
        the details in the PSQL chapter in the section entitled <link linkend="fblangref25-sidebar01">Switching
        the Terminator in <emphasis>isql</emphasis></link>.</para>
      </section>

      <section id="fblangref25-ddl-proc-params">
        <title><database>Parameters</database></title>
        <para>Each parameter has a data type specified for it. The <database>NOT NULL</database> constraint
        can also be specified for any parameter, to prevent <database>NULL</database> being passed or
        assigned to it.</para>
        <para>A collation sequence can be specified for string-type parameters, using
        the <database>COLLATE</database> clause.</para>
        
        <formalpara>
          <title>Input Parameters</title>
          <blockquote><para> Input parameters are presented as a parenthesized list following the name of the
          procedure.  They are passed into the procedure as values, so anything that changes them
          inside the procedure has no effect on the parameters in the calling program.</para>
          <para> Input parameters may have default values. Those that do have values specified for them
          must be located at the end of the list of parameters.</para></blockquote>
        </formalpara>
        <formalpara><title>Output Parameters</title>
          <blockquote><para> The optional <database>RETURNS</database> clause is for specifying a parenthesised
          list of output parameters for the stored procedure.</para></blockquote>
        </formalpara>

        <section id="fblangref25-ddl-proc-paramsdomns">
          <title>Use of Domains in Declarations</title>
          <para>A domain name can be specified as the type of a parameter. The parameter will inherit all
          domain attributes. If a default value is specified for the parameter, it overrides the default
          value specified in the domain definition.</para>

          <para>If the <database>TYPE OF</database> clause is added before the domain name,
          only the data type of the domain is used:  any of the other attributes of the domain&mdash;
          <database>NOT NULL constraint</database>, <database>CHECK</database> constraints, default
          value&mdash; are neither checked nor used. However, if the domain is of a text type,
          its character set and collation sequence are always used.</para>
        </section> <!-- Use of domains -->

        <section id="fblangref25-ddl-proc-paramscoltype">
          <title>Use of Column Type in Declarations</title>
          <para>Input and output parameters can also be declared using the data type of columns in
          existing tables and views. The <database>TYPE OF COLUMN</database> clause is used for that,
          specifying <replaceable>relationname.columnname</replaceable> as its argument.</para>
          <para>When <database>TYPE OF COLUMN</database> is used, the parameter inherits only the data
          type and, for string types, the character set and collation sequence. The constraints and default
          value of the column are ignored.</para>
          <warning>
            <title>Bug warning for pre-Firebird 3 versions:</title>
            <para>For input parameters, the collation that comes with the column's type is ignored in 
            comparisons (e.g. equality tests). For local variables, the behaviour varies.</para>
            <para>The bug was fixed for Firebird 3.</para>
          </warning>
        </section>
      </section> <!-- Parameters -->

      <section id="fblangref25-ddl-proc-declarations">
        <title>Variable and Cursor Declarations</title>
        <para>The optional declarations section, located last in the header section of the procedure
        definition, defines variables local to the procedure and its named cursors. Local variable
        declarations follow the same rules as parameters regarding specification of the data
        type.  See details in the <link linkend="fblangref25-psql">PSQL chapter</link> for
        <link linkend="fblangref25-psql-declare-variable"><database>DECLARE VARIABLE</database></link>
        and
        <link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link>.</para>
      </section> <!-- Declarations -->

      <section id="fblangref25-ddl-proc-procbody">
        <para>The header section is followed by the procedure body, consisting of one or more PSQL
        statements enclosed between the outer keywords <database>BEGIN</database>
        and <database>END</database>.  Multiple <database>BEGIN ... END</database> blocks of
        terminated statements may be embedded inside the procedure body.</para>
      </section>

      <para>Any user connected to the database can create a new stored procedure. The user who creates
      a stored procedure becomes its owner.</para>

      <formalpara id="create-procedure-examples">
        <title>Examples</title>
        <para> Creating a stored procedure that inserts a record into the BREED table and returns
        the code of the inserted record:
          <blockquote><programlisting>
CREATE PROCEDURE ADD_BREED (
  NAME D_BREEDNAME, /* Domain attributes are inherited */
  NAME_EN TYPE OF D_BREEDNAME, /* Only the domain type is inherited */
  SHORTNAME TYPE OF COLUMN BREED.SHORTNAME, 
    /* The table column type is inherited */
  REMARK VARCHAR(120) CHARACTER SET WIN1251 COLLATE PXW_CYRL,
  CODE_ANIMAL INT NOT NULL DEFAULT 1
)
RETURNS (
  CODE_BREED INT
)
AS
BEGIN
  INSERT INTO BREED (
    CODE_ANIMAL, NAME, NAME_EN, SHORTNAME, REMARK)
  VALUES (
    :CODE_ANIMAL, :NAME, :NAME_EN, :SHORTNAME, :REMARK)
  RETURNING CODE_BREED INTO CODE_BREED;
END
          </programlisting></blockquote>
        </para>
        <para>Creating a selectable stored procedure that generates data for
        mailing labels (from <function>employee.fdb</function>):
          <blockquote><programlisting>
CREATE PROCEDURE mail_label (cust_no INTEGER)
RETURNS (line1 CHAR(40), line2 CHAR(40), line3 CHAR(40),
         line4 CHAR(40), line5 CHAR(40), line6 CHAR(40))
AS
  DECLARE VARIABLE customer VARCHAR(25);
  DECLARE VARIABLE first_name VARCHAR(15);
  DECLARE VARIABLE last_name VARCHAR(20);
  DECLARE VARIABLE addr1 VARCHAR(30);
  DECLARE VARIABLE addr2 VARCHAR(30);
  DECLARE VARIABLE city VARCHAR(25);
  DECLARE VARIABLE state VARCHAR(15);
  DECLARE VARIABLE country VARCHAR(15);
  DECLARE VARIABLE postcode VARCHAR(12);
  DECLARE VARIABLE cnt INTEGER;
BEGIN
	line1 = '';
	line2 = '';
	line3 = '';
	line4 = '';
	line5 = '';
	line6 = '';

	SELECT customer, contact_first, contact_last, address_line1,
		address_line2, city, state_province, country, postal_code
	FROM CUSTOMER
	WHERE cust_no = :cust_no
	INTO :customer, :first_name, :last_name, :addr1, :addr2,
		:city, :state, :country, :postcode;

	IF (customer IS NOT NULL) THEN
		line1 = customer;
	IF (first_name IS NOT NULL) THEN
		line2 = first_name || ' ' || last_name;
	ELSE
		line2 = last_name;
	IF (addr1 IS NOT NULL) THEN
		line3 = addr1;
	IF (addr2 IS NOT NULL) THEN
		line4 = addr2;

	IF (country = 'USA') THEN
	BEGIN
		IF (city IS NOT NULL) THEN
			line5 = city || ', ' || state || '  ' || postcode;
		ELSE
			line5 = state || '  ' || postcode;
	END
	ELSE
	BEGIN
		IF (city IS NOT NULL) THEN
			line5 = city || ', ' || state;
		ELSE
			line5 = state;
		line6 = country || '    ' || postcode;
	END

	SUSPEND; -- the statement that sends an output row to the buffer
	         -- and makes the procedure &quot;selectable&quot;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para>
        <link linkend="fblangref25-ddl-proc-crtoralter"><database>CREATE OR ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-alter"><database>ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate"><database>RECREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-drop"><database>DROP PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Create procedure -->

    <section id="fblangref25-ddl-proc-alter">
      <title><database>ALTER PROCEDURE</database></title>
      <formalpara><title>Used for</title>
        <para>Modifying an existing stored procedure</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END

	&lt;inparam&gt; ::= &lt;param_decl&gt; [{= | DEFAULT} value]

	&lt;outparam&gt; ::= &lt;param_decl&gt;

	&lt;param_decl&gt; ::= paramname &lt;type&gt; [NOT NULL]
	[COLLATE collation]

&lt;type&gt; ::=
  &lt;datatype&gt; |
  [TYPE OF] domain |
  TYPE OF COLUMN rel.col

&lt;datatype&gt; ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISSION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

	&lt;declarations&gt; ::= {&lt;declare_var&gt; | &lt;declare_cursor&gt;};
	[{&lt;declare_var&gt; | &lt;declare_cursor&gt;}; &hellip;]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-proc-alterproc">
      <?dbfo keep-together='auto'?>
        <title>ALTER PROCEDURE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name of an existing stored procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">inparam</entry>
              <entry align="left">Input parameter description</entry>
            </row>
            <row valign="middle">
              <entry align="center">outparam</entry>
              <entry align="left">Output parameter description</entry>
            </row>
            <row valign="middle">
              <entry align="center">declarations</entry>
              <entry align="left">Section for declaring local variables and named cursors</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_var</entry>
              <entry align="left">Local variable declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">declare_cursor</entry>
              <entry align="left">Named cursor declaration</entry>
            </row>
            <row valign="middle">
              <entry align="center">PSQL_statements</entry>
              <entry align="left">Procedural SQL statements</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">A literal value that is assignment-compatible with the data type of the 
              parameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Any context variable whose type is compatible with the
              data type of the parameter</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">The name of an input or output parameter of the procedure.
              It may consist of up to 31 characters. The name of the parameter must be unique
              among input and output parameters of the procedure and its local variables</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation sequence</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">Domain name</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel</entry>
              <entry align="left">Table or view name</entry>
            </row>
            <row valign="middle">
              <entry align="center">col</entry>
              <entry align="left">Table or view column name</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">The total number of significant digits that the parameter should 
              be able to hold (1..18)</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">The number of digits after the decimal point (0..<replaceable>precision</replaceable>)</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string type parameter or variable, in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Character set of a string type parameter or variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size (max. 65535)</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>ALTER PROCEDURE</database> statement allows the following changes to a stored procedure definition:
        <itemizedlist spacing="compact">
          <listitem>the set and characteristics of input and output parameters</listitem>
          <listitem>local variables</listitem>
          <listitem>code in the body of the stored procedure</listitem>
        </itemizedlist>
      After <database>ALTER PROCEDURE</database> executes, existing privileges remain intact and dependencies
      are not affected.</para>
      <caution>
        <para>Take care about changing the number and type of input and output parameters in stored procedures.
        Existing application code and procedures and triggers that call it could become invalid because the new 
        description of the parameters is incompatible with the old calling format. For information on
        how to troubleshoot such a situation, see the article
        <link linkend="fblangref25-appx01-supp-rdb_validblr">The <database>RDB$VALID_BLR</database> Field</link>
        in the Appendix.</para>
      </caution>

      <para>The procedure owner and <link linkend="fblangref25-security-administrators">Administrators</link> 
      have the authority to use <database>ALTER PROCEDURE</database>.</para>

      <formalpara><title>ALTER PROCEDURE Example</title>
        <para>&nbsp;Altering the GET_EMP_PROJ stored procedure.
          <blockquote><programlisting>
ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-crtoralter"><database>CREATE OR ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate"><database>RECREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-drop"><database>DROP PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter procedure -->

    <section id="fblangref25-ddl-proc-crtoralter">
      <title><database>CREATE OR ALTER PROCEDURE</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new stored procedure or altering an existing one</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
        <para>For the full syntax detail,
        see <link linkend="fblangref25-ddl-proc-create"><database>CREATE DATABASE</database></link>.</para>
      </formalpara>
      <para>The <database>CREATE OR ALTER PROCEDURE</database> statement creates a new stored procedure
      or alters an existing one. If the stored procedure does not exist, it will be created by invoking
      a <database>CREATE PROCEDURE</database> statement transparently. If the procedure already exists,
      it will be altered and compiled without affecting its existing privileges and dependencies.</para>

      <formalpara><title>Example</title>
        <para>&nbsp;Creating or altering the GET_EMP_PROJ procedure.
          <blockquote><programlisting>
CREATE OR ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-alter"><database>ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate"><database>RECREATE PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Create or alter procedure -->

    <section id="fblangref25-ddl-proc-drop">
      <title><database>DROP PROCEDURE</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting a stored procedure</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP PROCEDURE procname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-procdrop">
      <?dbfo keep-together='auto'?>
        <title>DROP PROCEDURE Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name of an existing stored procedure</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP PROCEDURE</database> statement deletes an existing stored
      procedure. If the stored procedure has any dependencies, the attempt to delete it
      will fail and the appropriate error will be raised.</para>
      
      <para>The procedure owner and <link linkend="fblangref25-security-administrators">Administrators</link>
      have the authority to use <database>DROP PROCEDURE</database>.</para>

      <formalpara><title>Example</title>
        <para>&nbsp;Deleting the GET_EMP_PROJ stored procedure.
          <blockquote><programlisting>
DROP PROCEDURE GET_EMP_PROJ;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate"><database>RECREATE PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop procedure -->

    <section id="fblangref25-ddl-proc-recreate">
      <title><database>RECREATE PROCEDURE</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new stored procedure or recreating an existing one</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
        <para>For the full syntax detail,
        see <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>.</para>
      </formalpara>
      <para>The <database>RECREATE PROCEDURE</database> statement creates a new stored procedure 
      or recreates an existing one. If there is a procedure with this name already, the engine will 
      try to delete it and create a new one. Recreating an existing procedure will fail at the
      <database>COMMIT</database> request if the procedure has dependencies.</para>
      <warning>
        <para>Be aware that dependency errors are not detected until the <database>COMMIT</database> phase
        of this operation.</para>
      </warning>
      <para>After a procedure is successfully recreated, privileges to execute the stored
      procedure and the privileges of the stored procedure itself are dropped.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;Creating the new GET_EMP_PROJ stored procedure or recreating the
        existing GET_EMP_PROJ stored procedure.
          <blockquote><programlisting>
RECREATE PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
          PROJ_ID
      FROM
          EMPLOYEE_PROJECT
      WHERE
          EMP_NO = :emp_no
      INTO :proj_id
  DO
    SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-drop"><database>DROP PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-crtoralter"><database>CREATE OR ALTER PROCEDURE</database></link>
        </para>
      </formalpara>
    </section> <!-- Recreate procedure -->
  </section> <!-- Procedure -->
  
  <section id="fblangref25-ddl-extfunc">
    <title><database>EXTERNAL FUNCTION</database></title>
  <!-- Review status notice -->
  <important>
    <title>REVIEW STATUS</title>
    <para>All sections from this point forward to the end of the chapter are awaiting
    technical and editorial review.</para>
  </important>


    <para>External functions, also known as <quote>user-defined functions</quote> (UDFs) are programs
    written in an external programming language and stored in dynamically loaded libraries.  Once
    declared to a database, they become available in dynamic and procedural statements as though
    they were implemented in the SQL language internally.</para>
    <para>External functions extend the possibilities for processing data with SQL considerably.
    To make a function available to a database, it is declared using the statement <database>DECLARE
    EXTERNAL FUNCTON</database>.</para>
    <para>The library containing a function is loaded when any function included in it is called.</para>
    <note>
      <para>External functions may be contained in more than one library&mdash;or <quote>module</quote>,
      as it is referred to in the syntax.</para>
    </note>

    <section id="fblangref25-ddl-extfunc-declare">
      <title><database>DECLARE EXTERNAL FUNCTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Declaring a user-defined function (UDF) to the database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DECLARE EXTERNAL FUNCTION funcname
[&lt;arg_type_decl&gt; [, &lt;arg_type_decl&gt; ...]]
RETURNS {
  sqltype [BY {DESCRIPTOR | VALUE}] |
  CSTRING(length) |
  PARAMETER param_num }
[FREE_IT]
ENTRY_POINT 'entry_point' MODULE_NAME 'library_name';

&lt;arg_type_decl&gt; ::=
  sqltype [{BY DESCRIPTOR} | NULL] |
  CSTRING(length) [NULL]
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-declarefunc">
      <?dbfo keep-together='auto'?>
        <title>DECLARE EXTERNAL FUNCTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">funcname</entry>
              <entry align="left">Function name in the database. It may consist of up to 31 characters.  It should
              be unique among all internal and external function names in the database and need not be the
              same name as the name exported from the UDF library via <database>ENTRY_POINT</database>.</entry>
            </row>
            <row valign="middle">
              <entry align="center">entry_point</entry>
              <entry align="left">The exported name of the function</entry>
            </row>
            <row valign="middle">
              <entry align="center">library_name</entry>
              <entry align="left">The name of the module (<database>MODULE_NAME</database> from which
              the function is exported.  This will be the name of the file, without the <quote>.dll</quote>
              or <quote>.so</quote> file extension.</entry>
            </row>
            <row valign="middle">
              <entry align="center">sqltype</entry>
              <entry align="left">SQL data type. It cannot be an array or an array element</entry>
            </row>
            <row valign="middle">
              <entry align="center">length</entry>
              <entry align="left">The maximum length of a null-terminated string, specified in bytes</entry>
            </row>
            <row valign="middle">
              <entry align="center">param_num</entry>
              <entry align="left">The number of the input parameter, numbered from 1 in the list of
              input parameters in the declaration, describing the data type that will be returned by
              the function</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DECLARE EXTERNAL FUNCTION</database> statement makes a user-defined function available in
      the database. UDF declarations must be made in <emphasis>each database</emphasis> that is going to use them.
      There is no need to declare UDFs that will never be used.</para>
      <para>The name of the external function must be unique among all function names. It may be different from
      the exported name of the function, as specified in the <database>ENTRY_POINT</database> argument.</para>
      <section id="fblangref25-ddl-extfunc-inp">
      <title><database>DECLARE EXTERNAL FUNCTION</database> Input Parameters</title>
      <para>The input parameters of the function follow the name of the function and are separated with commas.
      Each parameter has an SQL data type specified for it. Arrays cannot be used as function parameters. As
      well as the SQL types, the CSTRING type is available for specifying a null-terminated string with a maximum
      length of <database>LENGTH</database> bytes.</para>
      <para>By default, input parameters are passed <emphasis>by reference</emphasis>. The <database>BY
      DESCRIPTOR</database> clause may be specified instead, if the input parameter is passed by descriptor.
      Passing a parameter by descriptor makes it possible to process <database>NULLs</database>.</para>

      <section id="fblangref25-ddl-extfunc-keywords">
        <title>Clauses and Keywords</title>
        <formalpara><title>RETURNS clause</title>
          <para>&nbsp;(Required) specifies the output parameter returned by the function. A function is scalar: it
          returns one and only one parameter. The output parameter can be of any SQL type (except an array or an
          array element) or a null-terminated string (<database>CSTRING</database>). The output parameter can be
          passed by reference (the default), by descriptor or by value.
          If the <database>BY DESCRIPTOR</database> clause is specified, the output parameter is passed
          by descriptor. If the <database>BY VALUE</database> clause is specified, the output parameter is
          passed by value.</para>
        </formalpara>
        <formalpara><title>PARAMETER keyword</title>
          <para>&nbsp;specifies that the function returns the value from the parameter under number
          <emphasis>param_num</emphasis>. It is necessary if you need to return a value of data type
          <database>BLOB</database>.</para>
        </formalpara>
        <formalpara><title>FREE_IT keyword</title>
          <para>&nbsp;means that the memory allocated for storing the return value will be freed after the function
          is executed. It is used only if the memory was allocated dynamically in the UDF. In such a UDF, the memory
          must be allocated with the help of the <function>ib_util_malloc</function> function from the
          <filename>ib_util</filename> module, a requirement for compatibility with the functions used in Firebird code
          and in the code of the shipped UDF modules, for allocating and freeing memory.</para>
        </formalpara>
        <formalpara><title>ENTRY_POINT clause</title>
          <para>&nbsp;specifies the name of the entry point (the name of the imported function), as exported from
          the module.</para>
        </formalpara>
        <formalpara><title>MODULE_NAME clause</title>
          <para>&nbsp;defines the name of the module where the exported function is located. The link to the module
          should not be the full path and extension of the file, if that can be avoided. If the module is located in
          the default location (in the ../UDF subdirectory of the Firebird server root) or in a location
          explicitly configured in <filename>firebird.conf</filename>, it makes it easier to move the database
          between different platforms. The <emphasis>UDFAccess</emphasis> parameter in the firebird.conf file
          allows access restrictions to external functions modules to be configured.</para>
        </formalpara>
      </section><!-- Clauses and keywords -->
    </section> <!-- Parameters -->
    <para>&nbsp;Any user connected to the database can declare an external function (UDF).</para>

    <formalpara><title>Examples using DECLARE EXTERNAL FUNCTION</title>
      <orderedlist>
        <listitem>Declaring the addDate external function located in the fbudf module.
        The input and output parameters are passed by reference.
          <programlisting>
DECLARE EXTERNAL FUNCTION addDay
TIMESTAMP, INT
RETURNS TIMESTAMP
ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
        <listitem>Declaring the invl external function located in the fbudf module.
        The input and output parameters are passed by descriptor.
          <programlisting>
DECLARE EXTERNAL FUNCTION invl
INT BY DESCRIPTOR, INT BY DESCRIPTOR
RETURNS INT BY DESCRIPTOR
ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
        <listitem>Declaring the isLeapYear external function located in the fbudf module.
        The input parameter is passed by reference, while the output parameter is passed by value.
          <programlisting>
DECLARE EXTERNAL FUNCTION isLeapYear
TIMESTAMP
RETURNS INT BY VALUE
ENTRY_POINT 'isLeapYear' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
        <listitem>Declaring the i64Truncate external function located in the fbudf module.
        The input and output parameters are passed by descriptor. The second parameter of
        the function is used as the return value.
          <programlisting>
DECLARE EXTERNAL FUNCTION i64Truncate
NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
RETURNS PARAMETER 2
ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';
          </programlisting>
        </listitem>
      </orderedlist>
    </formalpara>
    <formalpara><title>See also</title>
      <para> <link linkend="fblangref25-ddl-extfunc-alter"><database>ALTER EXTERNAL FUNCTION</database></link>,
      <link linkend="fblangref25-ddl-extfunc-drop"><database>DROP EXTERNAL FUNCTION</database></link>
      </para>
    </formalpara>
    </section> <!-- Declare external function -->


    <section id="fblangref25-ddl-extfunc-alter">
      <title><database>ALTER EXTERNAL FUNCTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Changing the entry point and/or the module name for a user-defined
        function (UDF)</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER EXTERNAL FUNCTION funcname
[ENTRY_POINT 'new_entry_point']
[MODULE_NAME 'new_library_name'];
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-alterfunc">
      <?dbfo keep-together='auto'?>
        <title>ALTER EXTERNAL FUNCTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">funcname</entry>
              <entry align="left">Function name in the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_entry_point</entry>
              <entry align="left">The new exported name of the function</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_library_name</entry>
              <entry align="left">The new name of the module (<database>MODULE_NAME</database> from which
              the function is exported.  This will be the name of the file, without the <quote>.dll</quote>
              or <quote>.so</quote> file extension.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>ALTER EXTERNAL FUNCTION</database> statement changes the entry point and/or
      the module name for a user-defined function (UDF). Existing dependencies remain intact after
      the statement containing the change[s] is executed.</para>
      <formalpara>
        <title>The <database>ENTRY_POINT</database> clause</title>
        <para>&nbsp;is for specifying the new entry point (the name of the function as exported from the
        module).</para>
      </formalpara>
      <formalpara><title>The <database>MODULE_NAME</database> clause</title>
        <para>&nbsp;Is for specifying the new name of the module where the exported function is
        located.</para>
      </formalpara>

      <para>&nbsp;Any user connected to the database can change the entry point and the
      module name.</para>

      <formalpara>
        <title>Examples using ALTER EXTERNAL FUNCTION</title>
        <orderedlist>
          <listitem>Changing the entry point for an external function
            <programlisting>
ALTER EXTERNAL FUNCTION invl ENTRY_POINT 'intNvl';
            </programlisting>
          </listitem>
          <listitem>Changing the module name for an external function
            <programlisting>
ALTER EXTERNAL FUNCTION invl MODULE_NAME 'fbudf2';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
    <formalpara><title>See also</title>
      <para> <link linkend="fblangref25-ddl-extfunc-declare"><database>DECLARE EXTERNAL FUNCTION</database></link>,
      <link linkend="fblangref25-ddl-extfunc-drop"><database>DROP EXTERNAL FUNCTION</database></link>
      </para>
    </formalpara>
    </section><!-- Alter external function -->

    <section id="fblangref25-ddl-extfunc-drop">
      <title><database>DROP EXTERNAL FUNCTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Removing a user-defined function (UDF) from a database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP EXTERNAL FUNCTION funcname
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropfunc">
      <?dbfo keep-together='auto'?>
        <title>DROP EXTERNAL FUNCTION Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">funcname</entry>
              <entry align="left">Function name in the database</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP EXTERNAL FUNCTION</database> statement deletes the declaration
      of a user-defined function from the database. If there are any dependencies on the external
      function, the statement will fail and the appropriate error will be raised.</para>

      <para>&nbsp;Any user connected to the database can delete the declaration
      of an internal function.</para>

      <formalpara>
        <title>Example using DROP EXTERNAL FUNCTION</title>
        <para>&nbsp;Deleting the declaration of the addDay function.
          <blockquote><programlisting>
DROP EXTERNAL FUNCTION addDay;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-extfunc-declare"><database>DECLARE EXTERNAL FUNCTION</database></link>
        </para>
      </formalpara>
    </section><!-- Drop external function -->
  </section><!-- External function -->

  <section id="fblangref25-ddl-filter">
    <title><database>FILTER</database></title>
    <para>A <database>BLOB FILTER</database> filter is a database object that is actually a
    special type of external function, with the sole purpose of taking a <database>BLOB</database>
    object in one format and converting it to a <database>BLOB</database> object in another
    format. The formats of the <database>BLOB</database> objects are specifed with user-defined
    <database>BLOB</database> subtypes.</para>
    <para>External functions for converting <database>BLOB</database> types are stored in dynamic
    libraries and loaded when necessary.</para>
    <para>For more details on <database>BLOB</database> subtypes, see
    <link linkend="fblangref25-datatypes-bnrytypes">Binary Data Types</link>.</para>

    <section id="fblangref25-ddl-filter-declare">
      <title><database>DECLARE FILTER</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Declaring a <database>BLOB</database> filter to the database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DECLARE FILTER filtername
INPUT_TYPE &lt;sub_type&gt; OUTPUT_TYPE &lt;sub_type&gt;
ENTRY_POINT 'function_name' MODULE_NAME 'library_name';

&lt;sub_type&gt; ::= number | &lt;mnemonic&gt;

&lt;mnemonic&gt; ::= binary | text | blr | acl | ranges
             | summary | format | transaction_description
             | external_file_description | user_defined
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-declarefiltr">
      <?dbfo keep-together='auto'?>
        <title>DECLARE FILTER Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">filtername</entry>
              <entry align="left">Filter name in the database. It may consist of up to 31 characters.  It
              need not be the same name as the name exported from the filter library via
              <database>ENTRY_POINT</database>.</entry>
            </row>
            <row valign="middle">
              <entry align="center">sub_type</entry>
              <entry align="left"><database>BLOB</database> subtype</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left"><database>BLOB SUB_TYPE</database> number (must be negative)</entry>
            </row>
            <row valign="middle">
              <entry align="center">mnemonic</entry>
              <entry align="left"><database>BLOB SUB_TYPE</database> mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">function_name</entry>
              <entry align="left">The exported name (entry point) of the function</entry>
            </row>
            <row valign="middle">
              <entry align="center">library_name</entry>
              <entry align="left">The name of the module where the filter is located</entry>
            </row>
            <row valign="middle">
              <entry align="center">user_defined</entry>
              <entry align="left">User-define <database>BLOB SUB_TYPE</database> mnemonic name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DECLARE FILTER</database> statement makes a <database>BLOB</database> filter
      available to the database. The name of the <database>BLOB</database> filter must be unique among
      the names of <database>BLOB</database> filters.</para>
      <section id="fblangref25-ddl-filter-subtype">
        <title>Specifying the Subtypes</title>
        <para>The subtypes can be specified as the subtype number or as the subtype mnemonic name. Custom
        subtypes must be represented by negative numbers (from -1 to -32,768). An attempt to declare
        more than one <database>BLOB</database> filter with the same combination of the input and output
        types will fail with an error.
          <formalpara>
            <title>INPUT_TYPE</title>
            <para>&nbsp;clause defining the <database>BLOB</database> subtype of the object to be converted</para>
          </formalpara>
          <formalpara>
            <title>OUTPUT_TYPE</title>
            <para>&nbsp;clause definimg the <database>BLOB</database> subtype of the object to be created.</para>
          </formalpara>
        </para>
      </section>
      <note>
        <para>Mnemonic names can be defined for custom <database>BLOB</database> subtypes and inserted manually
        into the system table <database>RDB$TYPES</database> system table:
          <programlisting>
       INSERT INTO RDB$TYPES (RDB$FIELD_NAME, RDB$TYPE, RDB$TYPE_NAME)
       VALUES ('RDB$FIELD_SUB_TYPE', -33, 'MIDI');
          </programlisting>
        After the transaction is confirmed, the mnemonic names can be used in declarations when you
        create new filters.</para>

        <para>The value of the column RDB$FIELD_NAME must always be 'RDB$FIELD_SUB_TYPE'. If mnemonic
        names in upper case, they can be used case-insensitively and without quotation marks when
        a filter is declared.</para>
        <formalpara><title>Warning</title>
          <para>&nbsp;From Firebird 3 onward, the system tables will no longer be writable by users.</para>
        </formalpara>
      </note>

      <section id="fblangref25-ddl-filter-params">
        <title>Parameters</title>
        <formalpara>
          <title>ENTRY_POINT</title>
          <para>&nbsp;clause defining the name of the entry point (the name of the imported function)
          in the module.</para>
        </formalpara>
        <formalpara>
          <title>MODULE_NAME</title>
          <para>&nbsp;The  clause defining the name of the module where the exported function is
          located. By default, modules must be located in the UDF folder of the root directory
          on the server. The <emphasis>UDFAccess</emphasis> parameter in <filename>firebird.conf</filename>
          allows editing of access restrictions to filter libraries.</para>
          <blockquote>
            <para>* * * * * * * * * * * * * * * * * * * * *</para>
          </blockquote>
        </formalpara>
      </section>
      <para>&nbsp;Any user connected to the database can declare a BLOB filter.</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Creating a BLOB filter using subtype numbers.
            <programlisting>
DECLARE FILTER DESC_FILTER
INPUT_TYPE 1
OUTPUT_TYPE -4
ENTRY_POINT 'desc_filter'
MODULE_NAME 'FILTERLIB';
            </programlisting>
          </listitem>
          <listitem>Creating a BLOB filter using subtype mnemonic names.
            <programlisting>
DECLARE FILTER FUNNEL
INPUT_TYPE blr OUTPUT_TYPE text
ENTRY_POINT 'blr2asc' MODULE_NAME 'myfilterlib';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-extfunc-drop"><database>DROP FILTER</database></link>
        </para>
      </formalpara>
    </section><!-- Declare Filter -->

    <section id="fblangref25-ddl-filter-drop">
      <title><database>DROP FILTER</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Removing a <database>BLOB</database> filter declaration from the database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP FILTER filtername;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-dropfiltr">
      <?dbfo keep-together='auto'?>
        <title>DROP FILTER Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">filtername</entry>
              <entry align="left">Filter name in the database</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP FILTER</database> statement removes the declaration of a <database>BLOB</database>
      filter from the database. Removing a <database>BLOB</database> filter from a database makes it unavailable
      for use rom that database. The dynamic library where the conversion function is located remains intact
      and the removal from one database does not affect other databases in which the same <database>BLOB</database>
      filter is still declared.</para>

      <para>&nbsp;Any user connected to the database can drop a BLOB filter.</para>

      <formalpara>
        <title>Example</title>
        <para>&nbsp;Deleting a BLOB filter.
          <blockquote><programlisting>
DROP FILTER DESC_FILTER;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para> <link linkend="fblangref25-ddl-extfunc-declare"><database>DECLARE FILTER</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop filter -->
  </section> <!-- Filters -->

  <section id="fblangref25-ddl-sequence">
    <title><database>SEQUENCE (GENERATOR)</database></title>
    <para>A sequence or a generator is a database object used to get unique number values to fill a series.
    <quote>Sequence</quote> is the SQL-compliant term for the same thing which, in Firebird, has traditionally been
    known as <quote>generator</quote>. Both terms are implemented in Firebird, which recognises and has syntax for
    both terms.</para>
    <para>Sequences (or generators) are always stored as 64-bit integers, regardless of the SQL dialect of the
    database.
      <caution>
        <para>If a client is connected using Dialect 1, the server sends sequence values to it as 32-bit
        integers.  Passing a sequence value to a 32-bit field or variable will not cause errors as long as
        the current value of the sequence does not exceed the limits of a 32-bit number. However, as soon
        as the sequence value exceeds this limit, a database in Dialect 3 will produce an error.  A database
        in Dialect 1 will keep cutting the values, which will compromise the uniqueness of the series.</para>
      </caution>
    </para>
    <para>This section describes how to create, set and delete sequences.</para>

    <section id="fblangref25-ddl-sequence-create">
      <title><database>CREATE SEQUENCE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Creating a new <database>SEQUENCE (GENERATOR)</database></para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE {SEQUENCE | GENERATOR} seq_name
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-crtseq">
      <?dbfo keep-together='auto'?>
        <title>CREATE SEQUENCE | CREATE GENERATOR Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Sequence (generator) name. It may consist of up to 31 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statements <database>CREATE SEQUENCE</database> and <database>CREATE GENERATOR</database>
      are synonymous&mdash;both create a new sequence. Either can be used but <database>CREATE SEQUENCE</database>
      is recommended if standards-compliant metadata management is important.</para>

      <para>When a sequence is created, its value is set to 0. Each time the
      <database><link linkend="fblangref25-commons-conditional-nxtvlufor">NEXT VALUE FOR seq_name</link></database>
      operator is used with that sequence, its value increases by 1. The <database>GEN_ID(seq_name, &lt;step&gt;)</database>
      function can be called instead, to <quote>step</quote> the series by a different integer number.</para>

      <para>Any user connected to the database can create a sequence (generator).</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Creating the EMP_NO_GEN series using <database>CREATE SEQUENCE</database>.
            <programlisting>
CREATE SEQUENCE EMP_NO_GEN;
            </programlisting>
          </listitem>
          <listitem>Creating the EMP_NO_GEN series using <database>CREATE GENERATOR</database>.
            <programlisting>
CREATE GENERATOR EMP_NO_GEN;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-sequence-alter"><database>ALTER SEQUENCE</database></link>,
        <link linkend="fblangref25-ddl-sequence-setgen"><database>SET GENERATOR</database></link>,
        <link linkend="fblangref25-ddl-sequence-drop"><database>DROP SEQUENCE (GENERATOR)</database></link>,
        <link linkend="fblangref25-commons-conditional-nxtvlufor"><database>NEXT VALUE FOR</database></link>,
        <link linkend="fblangref25-functions-scalarfuncs-gen_id"><database>GEN_ID() function</database></link>
        </para>
      </formalpara>
    </section> <!-- Create sequence -->

    <section id="fblangref25-ddl-sequence-alter">
      <title><database>ALTER SEQUENCE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Setting the value of a sequence or generator to a specified value</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER SEQUENCE seq_name RESTART WITH new_val
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-alterseq">
      <?dbfo keep-together='auto'?>
        <title>ALTER SEQUENCE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Sequence (generator) name</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_val</entry>
              <entry align="left">New sequence (generator) value. A 64-bit integer
              from -2<superscript>-63</superscript> to 2<superscript>63</superscript>-1.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>ALTER SEQUENCE</database> statement sets the current value of a sequence or
      generator to the specified value.
        <warning>
          <para>Incorrect use of the <database>ALTER SEQUENCE</database> statement (changing the current
          value of the sequence or generator) is likely to break the logical integrity of data.</para>
        </warning>
      </para>
      <para>Any user connected to the database can set the sequence (generator) value.</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Setting the value of the EMP_NO_GEN sequence to 145.
            <programlisting>
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
            </programlisting>
          </listitem>
          <listitem>Doing the same thing, using <database>SET GENERATOR</database>:
            <programlisting>
SET GENERATOR EMP_NO_GEN TO 145;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-sequence-setgen"><database>SET GENERATOR</database></link>,
        <link linkend="fblangref25-ddl-sequence-create"><database>CREATE SEQUENCE (GENERATOR)</database></link>,
        <link linkend="fblangref25-ddl-sequence-drop"><database>DROP SEQUENCE (GENERATOR)</database></link>,
        <link linkend="fblangref25-commons-conditional-nxtvlufor"><database>NEXT VALUE FOR</database></link>,
        <link linkend="fblangref25-functions-scalarfuncs-gen_id"><database>GEN_ID() function</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter sequence -->

    <section id="fblangref25-ddl-sequence-setgen">
      <title><database>SET GENERATOR</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Setting the value of a sequence or generator to a specified value</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
SET GENERATOR seq_name TO new_val
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-setgen">
      <?dbfo keep-together='auto'?>
        <title>SET GENERATOR Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Generator (sequence) name</entry>
            </row>
            <row valign="middle">
              <entry align="center">new_val</entry>
              <entry align="left">New sequence (generator) value. A 64-bit integer
              from -2<superscript>-63</superscript> to 2<superscript>63</superscript>-1.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>SET GENERATOR</database> statement sets the current value of a sequence or
      generator to the specified value.</para>
      <note>
        <para>Although <database>SET GENERATOR</database> is considered outdated, it is retained
        for backward compatibility.  Using the standards-compliant <database>ALTER SEQUENCE</database>
        is current and is recommended.</para>
      </note>

      <para>Any user connected to the database can set the sequence (generator) value.</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Setting the value of the EMP_NO_GEN sequence to 145:
            <programlisting>
SET GENERATOR EMP_NO_GEN TO 145;
            </programlisting>
          </listitem>
          <listitem>Doing the same thing, using <database>ALTER SEQUENCE</database>:
            <programlisting>
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para> <link linkend="fblangref25-ddl-sequence-alter"><database>ALTER SEQUENCE</database></link>,
        <link linkend="fblangref25-ddl-sequence-create"><database>CREATE SEQUENCE (GENERATOR)</database></link>
        </para>
      </formalpara>
    </section> <!-- Set Generator -->

    <section id="fblangref25-ddl-sequence-drop">
      <title><database>DROP SEQUENCE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Deleting <database>SEQUENCE (GENERATOR)</database></para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP {SEQUENCE | GENERATOR} seq_name
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropseq">
      <?dbfo keep-together='auto'?>
        <title>DROP SEQUENCE | DROP GENERATOR Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">seq_name</entry>
              <entry align="left">Sequence (generator) name. It may consist of up to 31 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statements <database>DROP SEQUENCE</database> and <database>DROP GENERATOR</database>
      statements are equivalent: both delete an existing sequence (generator). Either is valid but
      <database>DROP SEQUENCE</database>, being current, is recommended.</para>
      <para>The statements will fail if the sequence (generator) has dependencies.</para>

      <para>Any user connected to the database can drop a sequence (generator).</para>

      <formalpara>
        <title>Example</title>
        <para>&nbsp;Dropping the EMP_NO_GEN series:
            <blockquote><programlisting>
DROP SEQUENCE EMP_NO_GEN;
            </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-sequence-create"><database>CREATE SEQUENCE (GENERATOR</database></link>,
        <link linkend="fblangref25-ddl-sequence-alter"><database>ALTER SEQUENCE</database></link>,
        <link linkend="fblangref25-ddl-sequence-setgen"><database>SET GENERATOR</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop sequence -->
  </section> <!-- sequence / generator -->

  <section id="fblangref25-ddl-exception">
    <title><database>EXCEPTION</database></title>
    <para>This section describes how to create, modify and delete <firstterm>custom
      exceptions</firstterm> for use in error handlers in PSQL modules.</para>

    <section id="fblangref25-ddl-exception-create">
      <title><database>CREATE EXCEPTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Creating a new exception for use in PSQL modules</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-crtexcep">
      <?dbfo keep-together='auto'?>
        <title>CREATE EXCEPTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name. The maximum length is 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Default error message. The maximum length is 1,021 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>CREATE EXCEPTION</database> creates a new exception for use in
      PSQL modules. If an exception of the same name exists, the statement will fail with an appropriate
      error message.</para>
      <para>The exception name is a standard identifier.  In a Dialect 3 database, it can be enclosed 
      in double quotes to make it case-sensitive and, if required, to use characters that are
      not valid in regular identifiers.  See <link linkend="fblangref25-structure-identifiers">Identifiers</link>
      for more information.</para>
      <para>The default message is stored in character set <database>NONE</database>, i.e., in
      characters of any single-byte character set. The text can be overridden in the PSQL code when the
      exception is thrown.</para>

      <para>Any user connected to the database can create an exception.</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Creating an exception named E_LARGE_VALUE:
            <programlisting>
CREATE EXCEPTION E_LARGE_VALUE
       'The value is out of range';
            </programlisting>
          </listitem>
          <listitem>Creating an exception named ERROR_REFIN_RATE:
            <programlisting>
CREATE EXCEPTION ERROR_REFIN_RATE
  'Error detected in the spread of discount rates';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <tip>
        <title>Tips</title>
        <para>Grouping <database>CREATE EXCEPTION</database> statements together in system update
        scripts will simplify working with them and documenting them. A system of prefixes for
        naming and categorising groups of exceptions is recommended.</para>
        <para>Custom exceptions are stored in the system table
        <link linkend="fblangref-appx04-exceptions"><database>RDB$EXCEPTIONS</database></link>.
        </para>
      </tip>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-alter"><database>ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-crtalter"><database>CREATE OR ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-drop"><database>DROP EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Create exception -->

    <section id="fblangref25-ddl-exception-alter">
      <title><database>ALTER EXCEPTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Modifying a the message returned from a custom exception</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-altrexcep">
      <?dbfo keep-together='auto'?>
        <title>ALTER EXCEPTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">New default error message. The maximum length is 1,021 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>ALTER EXCEPTION</database> can be used at any time, to modify the 
      default text of the message. Any user connected to the database can alter an exception message.</para>
      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Changing the default message for the exception E_LARGE_VALUE:
            <programlisting>
ALTER EXCEPTION E_LARGE_VALUE
       'The value exceeds the prescribed limit of 32,765 bytes';
            </programlisting>
          </listitem>
          <listitem>Changing the default message for the exception ERROR_REFIN_RATE:
            <programlisting>
ALTER EXCEPTION ERROR_REFIN_RATE 'Rate is outside the allowed range';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-crtalter"><database>CREATE OR ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-drop"><database>DROP EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Alter exception -->

    <section id="fblangref25-ddl-exception-crtalter">
      <title><database>CREATE OR ALTER EXCEPTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Modifying a the message returned from a custom exception, if the exception
        exists;  otherwise, creating a new exception</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE OR ALTER EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-crtaltrexcep">
      <?dbfo keep-together='auto'?>
        <title>CREATE OR ALTER EXCEPTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Error message. The maximum length is limited to 1,021 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>CREATE OR ALTER EXCEPTION</database> is used
      to create the specified exception if it does not exist, or to modify the text of the
      error message returned from it if it exists already.  If an existing exception is
      altered by this statement, any existing dependencies will remain intact.</para>
      <para>Any user connected to the database can use this statement to create an exception
      or alter the text of one that already exists.</para>

      <formalpara>
        <title>Example</title>
        <para>&nbsp;Changing the message for the exception E_LARGE_VALUE:
            <blockquote><programlisting>
CREATE OR ALTER EXCEPTION E_LARGE_VALUE
       'The value is higher than the permitted range 0 to 32,765';
            </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-alter"><database>ALTER EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Create or alter exception -->

    <section id="fblangref25-ddl-exception-drop">
      <title><database>DROP EXCEPTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Deleting a custom exception</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP EXCEPTION exception_name
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-dropexcep">
      <?dbfo keep-together='auto'?>
        <title>DROP EXCEPTION Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>DROP EXCEPTION</database> is used to delete an exception.
      Any dependencies on the exception will cause the statement to fail and the exception
      will not be deleted.</para>
      <para>If an exception is used only in stored procedures, it can be deleted
      at any time. If it is used in a trigger, it cannot be deleted.</para>
      <para>In planning to delete an exception, all references to it should first be
      removed from the code of stored procedures, to avoid its absence causing errors.</para>

      <para>Any user connected to the database can delete an exception.</para>

      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Deleting exception ERROR_REFIN_RATE:
            <programlisting>
DROP EXCEPTION ERROR_REFIN_RATE;
            </programlisting>
          </listitem>
          <listitem>Deleting exception E_LARGE_VALUE:
            <programlisting>
DELETE EXCEPTION E_LARGE_VALUE;
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-recreate"><database>RECREATE EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Drop exception -->

    <section id="fblangref25-ddl-exception-recreate">
      <title><database>RECREATE EXCEPTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Creating a new custom exception or recreating an
        existing one</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
RECREATE EXCEPTION exception_name 'message'
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-recrtexcep">
      <?dbfo keep-together='auto'?>
        <title>RECREATE EXCEPTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name. The maximum length is 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">message</entry>
              <entry align="left">Error message. The maximum length is limited to 1,021 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>RECREATE EXCEPTION</database> creates a new exception for use in
      PSQL modules. If an exception of the same name exists already, the <database>RECREATE EXCEPTION</database>
      statement will try to delete it and create a new one. If there are any dependencies on the existing exception,
      the attempted deletion fails and <database>RECREATE EXCEPTION</database> is not executed.</para>

      <para>Any user connected to the database can [re]create an exception.</para>

      <formalpara>
        <title>Example</title>
        <para>&nbsp;Recreating the E_LARGE_VALUE exception:
            <blockquote><programlisting>
RECREATE EXCEPTION E_LARGE_VALUE 
       'The value exceeds its limit';
            </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-exception-create"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-drop"><database>DROP EXCEPTION</database></link>,
        <link linkend="fblangref25-ddl-exception-crtalter"><database>CREATE OR ALTER EXCEPTION</database></link>
        </para>
      </formalpara>
    </section> <!-- Recreate exception -->
  </section> <!-- Exception -->

  <section id="fblangref25-ddl-collation">
    <title><database>COLLATION</database></title>
    <para></para>

    <section id="fblangref25-ddl-collation-create">
      <title><database>CREATE COLLATION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Making a new collation for a supported character set
        available to the database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE COLLATION collname
FOR charset
[FROM basecoll | FROM EXTERNAL ('extname')]
[NO PAD | PAD SPACE]
[CASE [IN]SENSITIVE]
[ACCENT [IN]SENSITIVE]
['&lt;specific-attributes&gt;'];

&lt;specific-attributes&gt; ::= &lt;attribute&gt; [; &lt;attribute&gt; ...]

&lt;attribute&gt; ::= attrname=attrvalue
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-collatcrt">
      <?dbfo keep-together='auto'?>
        <title>CREATE COLLATION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">collname</entry>
              <entry align="left">The name to use for the new collation. The maximum length is 31 characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">A character set present in the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">basecoll</entry>
              <entry align="left">A collation already present in the database</entry>
            </row>
            <row valign="middle">
              <entry align="center">extname</entry>
              <entry align="left">The collation name used in the <filename>.conf</filename> file</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>CREATE COLLATION</database> statement does not <quote>create</quote> anything: its
      purpose is to make a collation known to a database. The collation must already be present on the system,
      typically in a library file, and must be properly registered in a <filename>.conf</filename> file in
      the <filename>intl</filename> subdirectory of the Firebird installation.</para>
      <para>The collation may alternatively be based on one that is already present in the database.</para>

      <section id="fblangref25-ddl-collation-createhow">
        <title>How the Engine Detects the Collation</title>
        <para>If no <database>FROM</database> clause is present, Firebird will scan the <filename>.conf</filename>
        file(s) in the <filename>intl</filename> subdirectory for a collation with the name specified as the object of
        <database>CREATE COLLATION</database>. In other words, omitting the <database>FROM basecoll</database> clause
        is equivalent to specifying <database>FROM EXTERNAL ('collname')</database>.</para>
        <para>The single-quoted <replaceable>'extname'</replaceable> is case-sensitive and must correspond exactly
        with the collation name in the <filename>.conf</filename> file. The <replaceable>collname</replaceable>,
        <replaceable>charset</replaceable> and <replaceable>basecoll</replaceable> parameters are case-insensitive
        unless enclosed in double-quotes.</para>
      </section>

      <section id="fblangref25-ddl-collation-specatt">
        <title>Specific Attributes</title>
        <para>The available specific attributes are listed in the table below. Not all specific attributes apply to
        every collation, even if specifying them does not cause an error.
        <important>
          <para>Specific attributes are case sensitive.</para>
        </important>
        In the table, <quote>1 bpc</quote> indicates that an attribute is valid for collations of character sets
        using 1 byte per character (so-called narrow character sets). <quote>UNI</quote> stands for
        <quote>UNICODE collations</quote>.
        </para>

        <table id="fblangref25-ddl-tbl-specific-colls">
        <?dbfo keep-together='auto'?>
          <title>Specific Collation Attributes</title>
          <tgroup cols="4">
            <colspec colname="colAttr" colwidth="2*"></colspec>
            <colspec colname="colVals" colwidth="1*"></colspec>
            <colspec colname="colValidFor" colwidth="1*"></colspec>
            <colspec colname="colComment" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Atrribute</entry>
                <entry align="center">Values</entry>
                <entry align="center">Valid for</entry>
                <entry align="center">Comment</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">DISABLE-COMPRESSIONS</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Disables compressions (a.k.a. contractions). Compressions cause certain
                character sequences to be sorted as atomic units, e.g. Spanish c+h as a single character ch</entry>
              </row>
              <row valign="middle">
                <entry align="center">DISABLE-EXPANSIONS</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Disables expansions. Expansions cause certain characters (e.g. ligatures or
                umlauted vowels) to be treated as character sequences and sorted accordingly</entry>
              </row>
              <row valign="middle">
                <entry align="center">ICU-VERSION</entry>
                <entry align="center">default or M.m</entry>
                <entry align="center">UNI</entry>
                <entry align="left">Specifies the ICU library version to use. Valid values are the ones defined
                in the applicable &lt;intl_module&gt; element in <filename>intl/fbintl.conf</filename>.
                Format: either the string literal <quote>default</quote> or a major+minor version number
                like <quote>3.0</quote> (both unquoted).</entry>
              </row>
              <row valign="middle">
                <entry align="center">LOCALE</entry>
                <entry align="center">xx_YY</entry>
                <entry align="center">UNI</entry>
                <entry align="left">Specifies the collation locale. Requires complete version of ICU libraries.
                Format: a locale string like <quote>du_NL</quote> (unquoted)</entry>
              </row>
              <row valign="middle">
                <entry align="center">MULTI-LEVEL</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Uses more than one ordering level</entry>
              </row>
              <row valign="middle">
                <entry align="center">NUMERIC-SORT</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">UNI</entry>
                <entry align="left">Treats contiguous groups of decimal digits in the string as atomic units
                and sorts them numerically. (This is also known as natural sorting)</entry>
              </row>
              <row valign="middle">
                <entry align="center">SPECIALS-FIRST</entry>
                <entry align="center">0, 1</entry>
                <entry align="center">1 bpc</entry>
                <entry align="left">Orders special characters (spaces, symbols etc.) before alphanumeric characters</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <tip>
          <para>If you want to add a new character set with its default collation into your database, declare
          and run the stored procedure <function>sp_register_character_set(name, max_bytes_per_character)</function>,
          found in <filename>misc/intl.sql/</filename> under the Firebird installation directory.</para>
          <para><command>Note:</command> in order for this to work, the character set must be present on the
          system and registered in a <filename>.conf</filename> file in the <filename>intl</filename>
          subdirectory.</para>
        </tip>
      </section> <!-- collation attributes -->

      <para>Any user connected to the database can use <database>CREATE COLLATION</database> to
      add a new collation.</para>

      <formalpara>
        <title>Examples using CREATE COLLATION</title>
        <orderedlist>
          <listitem>Creating a collation using the name found in the <filename>fbintl.conf</filename> file
          (case-sensitive).
            <programlisting>
CREATE COLLATION ISO8859_1_UNICODE FOR ISO8859_1;
            </programlisting>
          </listitem>
          <listitem>Creating a collation using a special (user-defined) name (the <quote>external</quote>
          name must completely match the name in the <filename>fbintl.conf</filename> file).
            <programlisting>
CREATE COLLATION LAT_UNI
FOR ISO8859_1
FROM EXTERNAL ('ISO8859_1_UNICODE');
            </programlisting>
          </listitem>
          <listitem>Creating a case-insensitive collation based on one already existing in
          the database.
            <programlisting>
CREATE COLLATION ES_ES_NOPAD_CI
FOR ISO8859_1
FROM ES_ES
NO PAD
CASE INSENSITIVE;
            </programlisting>
          </listitem>
          <listitem>Creating a case-insensitive collation based on one already existing in the
          database with specific attributes.
            <programlisting>
CREATE COLLATION ES_ES_CI_COMPR
FOR ISO8859_1
FROM ES_ES
CASE INSENSITIVE
'DISABLE-COMPRESSIONS=0';
            </programlisting>
          </listitem>
          <listitem>Creating a case-insensitive collation by the value of numbers
          (the so-called natural collation).
            <programlisting>
CREATE COLLATION nums_coll FOR UTF8
FROM UNICODE
CASE INSENSITIVE 'NUMERIC-SORT=1';

CREATE DOMAIN dm_nums AS varchar(20)
CHARACTER SET UTF8 COLLATE nums_coll; -- original (manufacturer) numbers

CREATE TABLE wares(id int primary key, articul dm_nums ...);
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara><title>See also</title>
        <para><link linkend="fblangref25-ddl-collation-drop"><database>DROP COLLATION</database></link>
        </para>
      </formalpara>
    </section><!-- Create collation -->

    <section id="fblangref25-ddl-collation-drop">
      <title><database>DROP COLLATION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Removing a collation from the database</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP COLLATION collname
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-ddl-tbl-collatdrp">
      <?dbfo keep-together='auto'?>
        <title>DROP COLLATION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">collname</entry>
              <entry align="left">The name of the collation</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DROP COLLATION</database> statement removes the specified collation
      from the database, if is there. An error will be raised if the specified collation is
      not present.</para>
      <tip>
        <para>If you want to remove an entire character set with all its collations from the
        database, declare and execute the stored procedure <function>sp_unregister_character_set(name)</function>
        from the <filename>misc/intl.sql</filename> subdirectory of the Firebird installation.</para>
      </tip>

      <para>Any user connected to the database can use <database>DROP COLLATION</database> to
      remove a collation.</para>

      <formalpara>
        <title>Example using DROP COLLATION</title>
        <para>&nbsp;Deleting the ES_ES_NOPAD_CI collation.
          <blockquote><programlisting>
DROP COLLATION ES_ES_NOPAD_CI;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para><link linkend="fblangref25-ddl-tbl-collatcrt"><database>CREATE COLLATION</database></link>
        </para>
      </formalpara>
    </section><!-- Drop collation -->
  </section> <!-- Collation -->

  <section id="fblangref25-ddl-charset">
    <title><database>CHARACTER SET</database></title>
    <para></para>

    <section id="fblangref25-ddl-charset-alter">
      <title><database>ALTER CHARACTER SET</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Setting the default collation for a character set</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
ALTER CHARACTER SET charset
SET DEFAULT COLLATION collation;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-charsetalter">
      <?dbfo keep-together='auto'?>
        <title>ALTER CHARACTER SET Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Character set identifier</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">The name of the collation</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>ALTER CHARACTER SET</database> statement changes the default
      collation for the specified character set. It will affect the future usage of the character
      set, except for cases where the <database>COLLATE</database> clause is explicitly overridden.
      In that case, the collation sequence of existing domains, columns and PSQL variables will remain
      intact after the change to the default collation of the underlying character set.</para>
      <note>
        <title>NOTES</title>
        <para>If you change the default collation for the database character set (the one defined when
        the database was created), it will change the default collation for the database.</para>
        <para>If you change the default collation for the character set that was specified during the
        connection, string constants will be interpreted according to the new collation value, except
        in those cases where the character set and/or the collation have been overridden.</para>
      </note>
      <formalpara>
        <title>Example of use</title>
        <para>&nbsp;Setting the default UNICODE_CI_AI collation for the UTF8 encoding.
          <blockquote><programlisting>
ALTER CHARACTER SET UTF8
       SET DEFAULT COLLATION UNICODE_CI_AI;
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- Alter character set -->
  </section> <!-- Character set -->

  <section id="fblangref25-ddl-role">
    <title><database>ROLE</database></title>
    <para>A role is a database object that packages a set of <link linkend="fblangref25-security-privs">SQL
    privileges</link>. Roles implement the concept of access control at a group level.  Multiple privileges
    are granted to the role and then that role can be granted to or revoked from one or many users.</para>

    <para>A user that is granted a role must supply that role in his login credentials in order to exercise the
    associated privileges.  Any other privileges granted to the user are not affected by his login with the
    role.  Logging in with multiple roles simultaneously is not supported.</para>
    <para>In this section the tasks of creating and dropping roles are discussed.</para>

    <section id="fblangref25-ddl-createrole">
      <title><database>CREATE ROLE</database></title>
      <formalpara><title>Used for</title>
        <para>Creating a new <database>ROLE</database> object</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
CREATE ROLE rolename;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-createrole">
      <?dbfo keep-together='auto'?>
        <title>CREATE ROLE Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">rolename</entry>
              <entry align="left">Role name. The maximum length is 31 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>CREATE ROLE</database> creates a new role object, to which
      one or more privileges can be granted subsequently. The name of a role must be
      unique among the names of roles in the current database.
        <warning>
          <para>It is advisable to make the name of a role unique among user names as well.
          The system will not prevent the creation of a role whose name clashes with an existing
          user name but, if it happens, the user will be unable to connect to the database.</para>
        </warning>
      </para>
      <para>&nbsp;Any user connected to the database can create a role. The user that
      creates a role becomes its owner.</para>

      <formalpara>
        <title>Example</title>
        <para>&nbsp;Creating a role named SELLERS:
          <blockquote><programlisting>
CREATE ROLE SELLERS;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-droprole"><database>DROP ROLE</database></link>,
        <link linkend="fblangref25-security-privs-grant"><database>GRANT</database></link>,
        <link linkend="fblangref25-security-privs-revoke"><database>REVOKE</database></link>
        </para>
      </formalpara>
    </section><!-- create role -->

    <section id="fblangref25-ddl-alterrole">
      <title><database>ALTER ROLE</database></title>
      <para><database>ALTER ROLE</database> has no place in the create-alter-drop paradigm for
      database objects since a role has no attributes that can be modified. Its actual effect is
      to alter an attribute of the database: Firebird uses it to enable and disable the
      capability for Windows Adminstrators to assume
      <link linkend="fblangref25-security-administrators">administrator privileges</link>
      automatically when logging in.</para>
      <para>This procedure can affect only one role: the system-generated role
      <database>RDB$ADMIN</database> that exists in every database of ODS 11.2 or higher.
      Several factors are involved in enabling this feature.</para>
      <para>For details, see <link linkend="fblangref25-security-autoadminmapping"><citetitle>AUTO ADMIN
      MAPPING</citetitle></link> in the <citetitle>Security</citetitle> chapter.</para>
    </section>

    <section id="fblangref25-ddl-droprole">
      <title><database>DROP ROLE</database></title>
      <formalpara><title>Used for</title>
        <para>Deleting a role</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DROP ROLE rolename;
        </programlisting></blockquote>
      </formalpara>
      <para>The statement <database>DROP ROLE</database> deletes an existing role. 
      It takes just a single argument, the name of the role. Once the role is deleted, 
      the entire set of privileges is revoked from all users and objects that were 
      granted the role.</para>
      <para>A role can be deleted by its owner or by an 
      <link linkend="fblangref25-security-administrators">administrator</link>.</para>

      <formalpara>
        <title>Example</title>
        <para>&nbsp;Deleting the role SELLERS:
          <blockquote><programlisting>
DROP ROLE SELLERS;
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara><title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-ddl-createrole"><database>CREATE ROLE</database></link>,
        <link linkend="fblangref25-security-privs-grant"><database>GRANT</database></link>,
        <link linkend="fblangref25-security-privs-revoke"><database>REVOKE</database></link>
        </para>
      </formalpara>
    </section> <!-- drop role -->
  </section> <!-- ROLE -->

  <section id="fblangref25-ddl-comment">
    <title><database>COMMENTS</database></title>
    <para>Database objects and a database itself may contain comments. It is a convenient 
    mechanism for documenting the development and maintenance of a database.  Comments 
    created with <database>COMMENT ON</database> will survive a <emphasis>gbak</emphasis> 
    backup and restore.</para>

    <section id="fblangref25-ddl-comment-create">
      <title><database>COMMENT ON</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Documenting metadata</para>
      </formalpara>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
COMMENT ON &lt;object&gt; IS {'sometext' | NULL}

&lt;object&gt; ::=
    DATABASE
  | &lt;basic-type&gt; objectname
  | COLUMN relationname.fieldname
  | PARAMETER procname.paramname

&lt;basic-type&gt; ::=
  CHARACTER SET |
  COLLATION |
  DOMAIN |
  EXCEPTION |
  EXTERNAL FUNCTION |
  FILTER |
  GENERATOR |
  INDEX |
  PROCEDURE |
  ROLE |
  SEQUENCE |
  TABLE |
  TRIGGER |
  VIEW
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-ddl-tbl-commenton">
      <?dbfo keep-together='auto'?>
        <title>COMMENT ON Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
           </thead>
           <tbody>
            <row valign="middle">
              <entry align="center">sometext</entry>
              <entry align="left">Comment text</entry>
            </row>
            <row valign="middle">
              <entry align="center">basic-type</entry>
              <entry align="left">Metadata object type</entry>
            </row>
            <row valign="middle">
              <entry align="center">objectname</entry>
              <entry align="left">Metadata object name</entry>
            </row>
            <row valign="middle">
              <entry align="center">relationname</entry>
              <entry align="left">Name of table or view</entry>
            </row>

            <row valign="middle">
              <entry align="center">procname</entry>
              <entry align="left">Name of stored procedure</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">Name of a stored procedure parameter</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>COMMENT ON</database> statement adds comments for database objects
      (metadata). Comments are saved to text fields of the <database>BLOB</database> type
      in the RDB$DESCRIPTION column of the corresponding system tables. Client applications
      can view comments from these fields.
        <note>
          <para>If you add an empty comment (''), it will be saved as NULL in the
          database.</para>
        </note>
      </para>

      <para>The table or procedure owner and <link linkend="fblangref25-security-administrators">Administrators</link>
      have the authority to use <database>COMMENT ON</database>.</para>

      <formalpara>
        <title>Examples using COMMENT ON</title>
        <orderedlist>
          <listitem>Adding a comment for the current database
            <programlisting>
COMMENT ON DATABASE IS 'It is a test (''my.fdb'') database';
            </programlisting>
          </listitem>
          <listitem>Adding a comment for the METALS table
            <programlisting>
COMMENT ON TABLE METALS IS 'Metal directory';
            </programlisting>
          </listitem>
          <listitem>Adding a comment for the ISALLOY field in the METALS table
            <programlisting>
COMMENT ON COLUMN METALS.ISALLOY IS '0 = fine metal, 1 = alloy';
            </programlisting>
          </listitem>
          <listitem>Adding a comment for a parameter
            <programlisting>
COMMENT ON PARAMETER ADD_EMP_PROJ. EMP_NO IS 'Employee ID';
            </programlisting>
          </listitem>
        </orderedlist>
      </formalpara>
    </section> <!-- Comment on -->
  </section> <!-- Comments -->

</chapter>
