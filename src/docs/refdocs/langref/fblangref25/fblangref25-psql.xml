<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-psql">
  <title>Procedural SQL (PSQL) Statements</title>
  <para>Procedural SQL (PSQL) is a procedural extension of SQL. This language subset is used for writing
   stored procedures, triggers, and PSQL blocks.</para>
  <para>PSQL provides all the basic constructs of traditional structured programming languages, and also
  includes DML statements (SELECT, INSERT, UPDATE, DELETE, etc.), with slight modifications to syntax in
  some cases.</para>
  <section id="fblangref25-psql-elements">
    <title>Elements of PSQL</title>
    <para>A procedural extension may contain declarations of local variables and cursors, assignments,
    conditional statements, loops, statements for raising custom exceptions, error handling and sending
    messages (events) to client applications. Triggers have access to special context variables, two
    arrays that store, respectively, the NEW values for all columns during insert and update activity and
    the OLD values during update and delete work.</para>
    <para>Statements that modify metadata (DDL) are not available in PSQL.</para>

    <section id="fblangref25-psql-elements-dml">
      <title>DML Statements with Parameters</title>
      <para>If DML statements (SELECT, INSERT, UPDATE, DELETE, etc.) in the body of the module (procedure,
      trigger or block) use parameters, only named parameters can be used and they must <quote>exist</quote>
      before the statements can use them.  They can be made available by being declared either as input
      or output parameters in the module's header or as local variables, in DECLARE [VARIABLE] statements
      at the bottom of the header.</para>

      <para>When a DML statement with parameters is included in PSQL code, the parameter name must be
      prefixed by a colon (<quote>:</quote>) in most situations. The colon is optional in statement
      syntax that is specific to PSQL, such as assignments and conditionals.  The colon
      prefix on parameters is not required when calling stored procedures from within another PSQL module
      or in DSQL.</para>
    </section>

    <section id="fblangref25-psql-elements-transacs">
      <title>Transactions</title>
      <para>Stored procedures are executed in the context of the transaction in which they are called.
      Triggers are executed as an intrinsic part of the operation of the DML statement:  thus, their
      execution is within the same transaction context as the statement itself. Individual transactions are
      launched for database event triggers.</para>
      <para>Statements that start and end transactions are not available in PSQL, but it is possible to run a
      statement or a block of statements in an autonomous transaction.</para>
    </section>

    <section id="fblangref25-psql-elements-structure">
      <title>Module Structure</title>
      <para>PSQL code modules consist of a header and a body.  The DDL statements for 
      defining them are <emphasis>complex statements</emphasis>;  that is, the consist of 
      a single statement that encloses blocks of multiple statements.  These statements 
      begin with a verb (CREATE, ALTER, DROP, RECREATE, CREATE OR ALTER) and end with 
      the last END statement of the body.</para>

      <section id="fblangref25-psql-elements-header">
        <title>The Module Header</title>
        <para>The header provides the module name and defines any parameters and variables that are used in
        the body.  Stored procedures and PSQL blocks may have input and output parameters. Triggers do not have
        either input or output parameters.</para>

        <para>The header of a trigger indicates the database event (insert, update or delete, or a combination)
        and the phase of operation (BEFORE or AFTER that event) that will cause it to <quote>fire</quote>.</para>
      </section>

      <section id="fblangref25-psql-elements-body">
        <title>The Module Body</title>
        <para>The body of a PSQL module is a block of statements that run in a logical sequence, like a
        program. A block of statements is contained within a BEGIN and an END statement.  The main BEGIN...END block
        may contain any number of other BEGIN...END blocks, both embedded and sequential.  All statements except BEGIN
        and END are terminated by semicolons (;).  No other character is valid for use as a terminator for PSQL
        statements.</para>
      </section>
    </section>
  </section><!-- Elements of -->

  <sidebar id="fblangref25-sidebar01">
    <title>Switching the Terminator in <emphasis>isql</emphasis></title>
    <para>Here we digress a little, to explain how to switch the terminator character in the
    <emphasis>isql</emphasis> utility to make it possible to define PSQL modules in that
    environment without conflicting with <emphasis>isql</emphasis> itself, which uses the
    same character, semicolon (;), as its own statement terminator.</para>
    <formalpara>
      <title>isql Command SET TERM</title>
    </formalpara>
    <formalpara>
      <title>Used for</title>
      <para>&nbsp;Changing the terminator character[s] to avoid
      conflict with the terminator character in PSQL statements</para>
    </formalpara>
    <formalpara>
      <title>Available in</title>
      <para>&nbsp;ISQL only</para>
    </formalpara>
    <formalpara>
      <title>Syntax</title>
      <blockquote><literallayout class="monospaced">
SET TERM &lt;new_terminator&gt; &lt;old_terminator&gt;
      </literallayout></blockquote>
    </formalpara>

    <table id="fblangref25-psql-tbl-setterm">
    <?dbfo keep-together='auto'?>
      <title>SET TERM Parameters</title>
      <tgroup cols="2">
        <colspec colname="colParam" colwidth="*"></colspec>
        <colspec colname="colDes" colwidth="3*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Argument</entry>
            <entry align="center">Description</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="center">new_terminator</entry>
            <entry align="left">New terminator</entry>
          </row>
          <row valign="middle">
            <entry align="center">old_terminator</entry>
            <entry align="left">Old terminator</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>When you write your triggers and stored procedures in <emphasis>isql</emphasis>, either in
    the interactive interface or in scripts, running a <database>SET TERM</database> statement
    is needed to switch the normal <emphasis>isql</emphasis> statement terminator from the semicolon
    to some other character or short string, to avoid conflict with the non-changeable semicolon
    terminator in PSQL.  The switch to an alternative terminator needs to be done before you begin
    defining PSQL objects or running your scripts.</para>

    <para>The alternative terminator can be any string of characters except for a space, an apostrophe
    or the current terminator character[s]. Any letter character[s] used will be case-sensitive.</para>
    <formalpara>
      <title>Example</title>
      <para>&nbsp;Changing the default semicolon to '^' (caret) and using it to submit a stored procedure
      definition: character as an alternative terminator character:
        <blockquote><literallayout class="monospaced">
SET TERM ^;

CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
BEGIN
  /* Stored procedure body */
END^

/* Other stored procedures and triggers */

SET TERM ;^

/* Other DDL statements */
        </literallayout></blockquote>
      </para>
    </formalpara>
  </sidebar>

  <section id="fblangref25-psql-storedprocs">
    <title>Stored Procedures</title>
    <para>A stored procedure is a program stored in the database metadata for execution on the server. A stored
    procedure can be called by stored procedures (including itself), triggers and client applications. A procedure
    that calls itself is known as <emphasis>recursive</emphasis>.</para>
    <section id="fblangref25-psql-storedprocs-benefits">
      <title>Benefits of Stored Procedures</title>
      <para>Stored procedures have the following advantages:
        <orderedlist>
          <listitem>Modularity&mdash;applications working with the database can use the same stored procedure,
          thereby reducing the size of the application code and avoiding code duplication.</listitem>
          <listitem>Simpler Application Support&mdash;when a stored procedure is modified, changes appear immediately
          to all host applications, without the need to recompile them if the parameters were unchanged.</listitem>
          <listitem>Enhanced Performance&mdash;since stored procedures are executed on a server instead of at the
          client, network traffic is reduced, which improves performance.</listitem>
        </orderedlist>
      </para>
    </section>

    <section id="fblangref25-psql-storedprocs-types">
      <title>Types of Stored Procedures</title>
      <para>Firebird supports two types of stored procedures: <emphasis>executable</emphasis> and
      <emphasis>selectable</emphasis>.</para>

      <section id="fblangref25-psql-storedprocs-executable">
        <title>Executable Procedures</title>
        <para>Executable procedures usually modify data in a database. They can receive input parameters
        and return a single set of output (RETURNS) parameters. They are called using the
        <database>EXECUTE PROCEDURE</database> statement.  See <link linkend="create-procedure-examples">an example 
        of an executable stored procedure</link> at the end of 
        the <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database> section</link> 
        of Chapter 5.</para>
      </section>
      <section id="fblangref25-psql-storedprocs-selectable">
        <title>Selectable Procedures</title>
        <para>Selectable stored procedures usually retrieve data from a database, returning an arbitrary
        number of rows to the caller.  The caller receives the output one row at a time from a row buffer
        that the database engine prepares for it.</para>
        <para>Selectable procedures can be useful for obtaining complex sets of data that are often impossible
        or too difficult or too slow to retrieve using regular DSQL SELECT queries.  Typically, this style
        of procedure iterates through a looping process of extracting data, perhaps transforming it before
        filling the output variables (parameters) with fresh data at each iteration of the loop.  A SUSPEND
        statement at the end of the iteration fills the buffer and waits for the caller to fetch the row.
        Execution of the next iteration of the loop begins when the buffer has been cleared.</para>
        <para>Selectable procedures may have input parameters and the output set is specified by the
        <database>RETURNS</database> clause in the header.</para>

        <para>A selectable stored procedure is called with a SELECT statement.
        See <link linkend="create-procedure-examples">an example of a selectable stored procedure</link>
        at the end of the <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database> 
        section</link> of Chapter 5.</para>

      </section> <!-- selectable procedures -->
    </section><!-- Types of Stored Procedures -->

    <section id="fblangref25-psql-storedprocs-creating">
      <title>Creating a Stored Procedure</title>
      <para>The syntax for creating executable stored procedures and selectable stored procedures is
      exactly the same.  The difference comes in the logic of the program code.</para>
      <formalpara>
        <title>Syntax (partial)</title>
        <blockquote><programlisting>
CREATE PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
      </formalpara>
      <para>The header of a stored procedure must contain the procedure name, and it must be unique
      among the names of stored procedures, tables, and views. It may also define some input
      and output parameters.  Input parameters are listed after the procedure name inside a pair of
      brackets.  Output parameters, which are mandatory for selectable procedures, are bracketed
      inside one <database>RETURNS</database> clause.</para>
      <para>The final item in the header (or the first item in the body, depending on your opinion of
      where the border lies) is one or more declarations of any local variables and/or named cursors
      that your procedure might require.</para>
      <para>Following the declarations is the main BEGIN...END block that delineates the procedure's
      PSQL code.  Within that block could be PSQL and DML statements, flow-of-control blocks, sequences
      of other BEGIN...END blocks, including embedded blocks.  Blocks, including the main block, may
      be empty and the procedure will still compile.  It is not unusual to develop a procedure in
      stages, from an outline.</para>
      <formalpara>
        <title>For more information about creating stored procedures</title>
        <para>&nbsp;See <link linkend="fblangref25-ddl-proc-create"><database>CREATE PROCEDURE</database></link>
        in Chapter 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- CREATE PROCEDURE -->

    <section id="fblangref25-psql-storedprocs-modifying">
      <title>Modifying a Stored Procedure</title>
      <para>An existing stored procedure can be altered, to change the sets of input and output
      parameters and anything in the procedure body.</para>
      <formalpara>
        <title>Syntax (partial)</title>
        <blockquote><programlisting>
ALTER PROCEDURE procname
[(&lt;inparam&gt; [, &lt;inparam&gt; ...])]
[RETURNS (&lt;outparam&gt; [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>For more information about modifying stored procedures</title>
        <para>&nbsp;See
        <link linkend="fblangref25-ddl-proc-alter"><database>ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-crtoralter"><database>CREATE OR ALTER PROCEDURE</database></link>,
        <link linkend="fblangref25-ddl-proc-recreate"><database>RECREATE PROCEDURE</database></link>,
        in Chapter 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- MODIFY PROCEDURE -->

    <section id="fblangref25-psql-storedprocs-deleting">
      <title>Deleting a Stored Procedure</title>
      <para>The <database>DROP PROCEDURE</database> statement is used to delete stored
      procedures.</para>
      <formalpara>
        <title>Syntax (complete)</title>
        <blockquote><programlisting>
DROP PROCEDURE procname;
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>For more information about deleting stored procedures</title>
        <para>&nbsp;See <link linkend="fblangref25-ddl-proc-drop"><database>DROP
        PROCEDURE</database></link>
        in Chapter 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- DELETE PROCEDURE -->
  </section> <!-- Stored Procedures -->

  <section id="fblangref25-psql-storedfuncs">
    <title>Stored Functions</title>
    <para>Stored PSQL scalar functions are not supported in this version but they are coming
    in Firebird 3. In Firebird 2.5 and below, you can instead write a selectable stored procedure 
    that returns a scalar result and SELECT it from your DML query or subquery.
      <formalpara>
        <title>Example</title>
        <blockquote><programlisting>
SELECT
  PSQL_FUNC(T.col1, T.col2) AS col3,
  col3
FROM T
        </programlisting></blockquote>
    can be replaced with
        <blockquote><programlisting>
SELECT
  (SELECT output_column FROM  PSQL_PROC(T.col1)) AS col3,
  col2
FROM T
        </programlisting></blockquote>
    or
        <blockquote><programlisting>
SELECT
  output_column AS col3,
  col2,
FROM T
LEFT JOIN PSQL_PROC(T.col1)
        </programlisting></blockquote>
      </formalpara>
    </para>
  </section> <!-- stored functions -->


  <section id="fblangref25-psql-dynblocks">
    <title>PSQL Blocks</title>
    <para>A self-contained, unnamed (<quote>anonymous</quote>) block of PSQL code can be executed
    dynamically in DSQL, using the <database>EXECUTE BLOCK</database> syntax. The header of an
    anonymous PSQL block may optionally contain input and output parameters. The body may contain
    local variable and cursor declarations;  and a block of PSQL statements follows.</para>
    <para>An anonymous PSQL block is not defined and stored as an object, unlike stored procedures
    and triggers.  It executes in run-time and cannot reference itself.</para>
    <para>Just like stored procedures, anonymous PSQL blocks can be used to process data and to
    retrieve data from the database.</para>
    <formalpara>
      <title>Syntax (incomplete)</title>
      <blockquote><programlisting>
EXECUTE BLOCK
[(&lt;inparam&gt; = ? [, &lt;inparam&gt; = ? ...])]
[RETURNS (&lt;outparam> [, &lt;outparam&gt; ...])]
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END
      </programlisting></blockquote>
    </formalpara>
    <table id="fblangref25-psql-tbl-dynblock">
    <?dbfo keep-together='auto'?>
      <title>PSQL Block Parameters</title>
      <tgroup cols="2">
        <colspec colname="colParam" colwidth="*"></colspec>
        <colspec colname="colDes" colwidth="3*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Argument</entry>
            <entry align="center">Description</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry align="center">inparam</entry>
            <entry align="left">Input parameter description</entry>
          </row>
          <row valign="middle">
            <entry align="center">outparam</entry>
            <entry align="left">Output parameter description</entry>
          </row>
          <row valign="middle">
            <entry align="center">declarations</entry>
            <entry align="left">A section for declaring local variables and named cursors</entry>
          </row>
          <row valign="middle">
            <entry align="center">PSQL statements</entry>
            <entry align="left">PSQL and DML statements</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <formalpara>
      <title>Read more</title>
      <para>&nbsp;See 
      <link linkend="fblangref25-dml-execblock"><database>EXECUTE BLOCK</database></link> for details.
      </para>
    </formalpara>
  </section><!-- PSQL Blocks -->

  <section id="fblangref25-psql-triggers">
    <title>Triggers</title>
    <para>A trigger is another form of executable code that is stored in the metadata of the database
    for execution by the server. A trigger cannot be called directly. It is called automatically
    (<quote>fired</quote>) when data-changing events involving one particular table or view occur.</para>
    <para>One trigger applies to exactly one table or view and only one <emphasis>phase</emphasis> in an
    event (BEFORE or AFTER the event).  A single trigger might be written to fire only when one specific
    data-changing event occurs (INSERT/UPDATE/DELETE) or it might be written to apply to more than one
    of those.</para>

    <para>A DML trigger is executed in the context of the transaction in which the data-changing DML
    statement is running. For triggers that respond to database events, the rule is different: for some
    of them, a default transaction is started.</para>

    <section id="fblangref25-psql-firingorder">
      <title>Firing Order (Order of Execution)</title>
      <para>More than one trigger can be defined for each phase-event combination. The order in which they
      are executed (known as <quote>firing order</quote> can be specified explicitly with the optional
      <database>POSITION</database> argument in the trigger definition.  You have 32,767 numbers to choose
      from.  Triggers with the lowest position numbers fire first.</para>
      <para>If a <database>POSITION</database> clause is omitted, or if several matching event-phase triggers
      have the same position number, then the triggers will fire in alphabetical order.</para>
    </section>

    <section id="fblangref25-psql-dmltriggers">
    <title>DML Triggers</title>
    <para>DML triggers are those that fire when a DML operation changes the state of data: modifies
    rows in tables, inserts new rows or deletes rows.  They can be defined for both tables and
    views.</para>

      <section id="fblangref25-psql-triggeroptions">
        <title>Trigger Options</title>
        <para>Six base options are available for the event-phase combination for tables and views:

          <informaltable id="fblangref25-psql-tbl-dmltriggers" frame="none" rowsep="1" colsep="1">
          <?dbfo keep-together='auto'?>
            <tgroup cols="2">
              <colspec colname="colEvent" colwidth="*"></colspec>
              <colspec colname="colKeywords" colwidth="*"></colspec>
              <tbody>
                <row valign="middle">
                  <entry align="right">Before a new row is inserted</entry>
                  <entry align="left"><database>(BEFORE INSERT)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">After a new row is inserted</entry>
                  <entry align="left"><database>(AFTER INSERT)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Before a row is updated</entry>
                  <entry align="left"><database>(BEFORE UPDATE)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">After a row is updated</entry>
                  <entry align="left"><database>(AFTER UPDATE)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">Before a row is deleted</entry>
                  <entry align="left"><database>(BEFORE DELETE)</database></entry>
                </row>
                <row valign="middle">
                  <entry align="right">After a row is deleted</entry>
                  <entry align="left"><database>(AFTER DELETE)</database></entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        These base forms are for creating single phase/single-event triggers.  Firebird also supports
        forms for creating triggers for one phase and multiple-events, <database>BEFORE INSERT OR UPDATE
        OR DELETE</database>, for example, or <database>AFTER UPDATE OR DELETE</database>:  the
        combinations are your choice.
          <note>
            <para><quote>Multi-phase</quote> triggers, such as BEFORE OR AFTER..., are not possible.</para>
          </note>
        </para>
      </section> <!-- TRIGGER OPTIONS -->

      <section id="fblangref25-psql-oldnew">
        <title>OLD and NEW Context Variables</title>
        <para>For DML triggers, the Firebird engine provides access to sets of OLD and NEW context variables.
        Each is an array of the values of the entire row:  one for the values as they are before the data-changing
        event (the BEFORE phase) and one for the values as they will be after the event (the AFTER phase).
        They are referenced in statements using the form <database>NEW.column_name</database>
        and <database>OLD.column_name</database>, respectively.  The <database>column_name</database> can
        be any column in the table's definition, not just those that are being updated.</para>
        <para>The NEW and OLD variables are subject to some rules:
          <itemizedlist spacing="compact">
            <listitem>In all triggers, the OLD value is read-only</listitem>
            <listitem>In BEFORE UPDATE and BEFORE INSERT code, the NEW value is read/write, unless
            it is a <database>COMPUTED BY</database> column</listitem>
            <listitem>In INSERT triggers, references to the OLD variables are invalid and will throw
            an exception</listitem>
            <listitem>In DELETE triggers, references to either the NEW or the OLD variables are invalid
            and will throw an exception</listitem>
            <listitem>In all AFTER trigger code, the NEW variables are read-only</listitem>
          </itemizedlist>
        </para>
      </section> <!-- OLD / NEW -->
    </section> <!-- DML triggers -->

    <section id="fblangref25-psql-dbtriggers">
      <title>Database Triggers</title>
      <para>A trigger associated with a database or transaction event can be defined for
      the following events:

      <informaltable id="fblangref25-psql-tbl-dbtriggers" frame="none" rowsep="1" colsep="1">
      <?dbfo keep-together='auto'?>
        <tgroup cols="3">
          <colspec colname="colEvent" colwidth="4*"></colspec>
          <colspec colname="colKeywords" colwidth="3*"></colspec>
          <colspec colname="colDesc" colwidth="5*"></colspec>
          <tbody>
            <row valign="middle">
              <entry align="left">Connecting to a database</entry>
              <entry align="center"><database>(ON CONNECT)</database></entry>
              <entry align="left">Before the trigger is executed, a default transaction is automatically started</entry>
            </row>
            <row valign="middle">
              <entry align="left">Disconnecting from a database</entry>
              <entry align="center"><database>(ON DISCONNECT)</database></entry>
              <entry align="left">Before the trigger is executed, a default transaction is automatically started</entry>
            </row>
            <row valign="middle">
              <entry align="left">When a transaction is started</entry>
              <entry align="center"><database>(ON TRANSACTION START)</database></entry>
              <entry align="left">The trigger is executed in the current transaction context</entry>
            </row>
            <row valign="middle">
              <entry align="left">When a transaction is committed</entry>
              <entry align="center"><database>(ON TRANSACTION COMMIT)</database></entry>
              <entry align="left">The trigger is executed in the current transaction context</entry>
            </row>
            <row valign="middle">
              <entry align="left">When a transaction is cancelled</entry>
              <entry align="center"><database>(ON TRANSACTION ROLLBACK)</database></entry>
              <entry align="left">The trigger is executed in the current transaction context</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      </para>
    </section> <!-- database triggers -->

    <section id="fblangref25-psql-triggercreate">
      <title>Creating Triggers</title>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
CREATE TRIGGER trigname {
    &lt;relation_trigger_legacy&gt;
  | &lt;relation_trigger_sql2003&gt;
  | &lt;database_trigger&gt; }
AS
[&lt;declarations&gt;]
BEGIN
[&lt;PSQL_statements&gt;]
END

&lt;relation_trigger_legacy&gt; ::= FOR {tablename | viewname}
[ACTIVE | INACTIVE]
{BEFORE | AFTER} &lt;mutation_list&gt;
[POSITION number]

&lt;relation_trigger_sql2003&gt; ::= [ACTIVE | INACTIVE]
{BEFORE | AFTER} &lt;mutation_list&gt;
[POSITION number]
ON {tablename | viewname}

&lt;database_trigger&gt; ::= [ACTIVE | INACTIVE]
ON db_event
[POSITION number]

&lt;mutation_list&gt; ::= &lt;mutation&gt; [OR &lt;mutation&gt;
   [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::=
    CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK
        </programlisting></blockquote>
      </formalpara>
      <para>The header must contain a name for the trigger that is unique among trigger names.
      It must include the event or events that will fire the trigger. Also, for a DML trigger
      it is mandatory to specify the event phase and the name of the table or view that is
      to <quote>own</quote> the trigger.</para>
      <para>The body of the trigger can be headed by the declarations of local variables and
      cursors, if any. Within the enclosing main <database>BEGIN...END</database> wrapper
      will be one or more blocks of PSQL statements, which may be empty.</para>

      <formalpara>
        <title>For more information about creating triggers</title>
        <para>&nbsp;See
        <link linkend="fblangref25-ddl-trgr-create">"><database>CREATE TRIGGER</database></link>
        in Chapter 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- Creating Triggers -->

    <section id="fblangref25-psql-triggermodify">
      <title>Modifying Triggers</title>
      <para>Altering the status, phase, table or view event(s), firing position and code in the body of
      a DML trigger are all possible. However, you cannot modify a DML trigger to convert it to a
      database trigger, nor vice versa. Any element not specified is left unchanged by 
      <database>ALTER TRIGGER</database>.  The alternative statements <database>CREATE OR ALTER TRIGGER</database>
      and <database>RECREATE TRIGGER</database> will replace the original trigger definition entirely.</para>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
ALTER TRIGGER trigname
[ACTIVE | INACTIVE]
[{BEFORE | AFTER} &lt;mutation_list&gt;]
[POSITION number]
[
 AS
 [&lt;declarations&gt;]
 BEGIN
 [&lt;PSQL_statements&gt;]
 END
]

&lt;mutation_list&gt; ::= 
  &lt;mutation&gt; [OR &lt;mutation&gt; [OR &lt;mutation&gt;]]

&lt;mutation&gt; ::= { INSERT | UPDATE | DELETE }

&lt;db_event&gt; ::=
    CONNECT 
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>For more information about modifying triggers</title>
        <para>&nbsp;See
          <link linkend="fblangref25-ddl-trgr-alter"><database>ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-crtalter"><database>CREATE OR ALTER TRIGGER</database></link>,
          <link linkend="fblangref25-ddl-trgr-recreate"><database>RECREATE TRIGGER</database></link>
        in Chapter 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- MODIFY TRIGGER -->

    <section id="fblangref25-psql-triggerdelete">
      <title>Deleting a Trigger</title>
      <para>The <database>DROP TRIGGER</database> statement is used to delete stored
      procedures.</para>
      <formalpara>
        <title>Syntax (complete)</title>
        <blockquote><programlisting>
DROP TRIGGER trigname;
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>For more information about deleting triggers</title>
        <para>&nbsp;See <link linkend="fblangref25-ddl-trgr-drop"><database>DROP
        TRIGGER</database></link>
        in Chapter 5, <citetitle>Data Definition (DDL) Statements</citetitle>.
        </para>
      </formalpara>
    </section> <!-- DELETE TRIGGER -->
  </section> <!-- triggers -->

  <section id="fblangref25-psql-coding">
    <title>Writing the Body Code</title>
    <para>This section takes a closer look at the procedural SQL language constructs and
    statements that are available for coding the body of a stored procedure, trigger or
    anonymous PSQL block.</para>

    <sidebar>
      <title>Colon Marker (:)</title>
      <para>The colon marker prefix (:) is used in PSQL to mark a reference to a variable in
      a DML statement. The colon marker is not required before variable names in other code
      and it should never be applied to context variables.</para>
    </sidebar>

    <section id="fblangref25-psql-coding-assign">
      <title>Assignment Statements</title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Assigning a value to a variable</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
varname = &lt;value_expr&gt;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-assign">
      <?dbfo keep-together='auto'?>
        <title>Assignment Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name of a parameter or local variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">value_expr</entry>
              <entry align="left">An expression, constant or variable whose value
              resolves to the same data type as &lt;varname&gt;</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>PSQL uses the equivalence symbol (=) as its assignment operator.  The assignment
      statement assigns an SQL expression value on the right to the variable on the left of
      the operator.  The expression can be any valid SQL expression:  it may contain literals,
      internal variable names, arithmetic, logical and string operations, calls to internal
      functions or to external functions (UDFs).</para>
      <formalpara>
        <title>Example using assignment statements</title>
        <blockquote><programlisting>
CREATE PROCEDURE MYPROC (
    a INTEGER,
    b INTEGER,
    name VARCHAR (30)
)
RETURNS (
    c INTEGER,
    str VARCHAR(100))
AS
BEGIN
  -- assigning a constant
  c = 0;
  str = '';
  SUSPEND;
  -- assigning expression values
  c = a + b;
  str = name || CAST(b AS VARCHAR(10));
  SUSPEND;
  -- assigning expression value
  -- built by a query
  c = (SELECT 1 FROM rdb$database);
  -- assigning a value from a context variable
  str = CURRENT_USER;
  SUSPEND;
END
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>
        <link linkend="fblangref25-psql-declare-variable"><database>DECLARE VARIABLE</database></link>
        </para>
      </formalpara>
    </section> <!-- assignment statement -->

    <section id="fblangref25-psql-declare-cursor">
      <title><database>DECLARE CURSOR</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Declaring a named cursor</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
DECLARE [VARIABLE] cursorname CURSOR FOR (&lt;select&gt;) [FOR UPDATE]
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-psql-tbl-declare-cursor">
      <?dbfo keep-together='auto'?>
        <title>DECLARE CURSOR Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Cursor name</entry>
            </row>
            <row valign="middle">
              <entry align="center">select</entry>
              <entry align="left">SELECT statement</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>DECLARE CURSOR ... FOR</database> statement binds a named cursor
      to the result set obtained in the SELECT statement specified in the <database>FOR</database>
      clause. In the body code, the cursor can be opened, used to walk row-by-row through the
      result set and closed. While the cursor is open, the code can perform positioned updates and deletes
      using the <database>WHERE CURRENT OF</database> in the <database>UPDATE</database> or
      <database>DELETE</database> statement.</para>
      <section id="fblangref25-psql-idio-cursor">
        <title>Cursor Idiosyncrasies</title>
        <itemizedlist>
          <listitem>
            <para>The optional <database>FOR UPDATE</database> clause can be included in the SELECT statement
            but its absence does not prevent successful execution of a positioned update or delete</para>
          </listitem>
          <listitem>
            <para>Care should be taken to ensure that the names of declared cursors do not conflict with
            any names used subsequently in statements for <database>AS CURSOR</database> clauses</para>
          </listitem>
          <listitem>
            <para>If the cursor is needed only to walk the result set, it is nearly always easier
            and less error-prone to use a <database>FOR SELECT</database> statement with
            the <database>AS CURSOR</database> clause. Declared cursors must be explicitly opened, used
            to fetch data and closed. The context variable <database>ROW_COUNT</database> has to be
            checked after each fetch and, if its value is zero, the loop has to be terminated.
            A <database>FOR SELECT</database> statement checks it automatically.</para>
            <para>Nevertheless, declared cursors provide a high level of control over sequential events
            and allow several cursors to be managed in parallel.</para>
          </listitem>
          <listitem>
            <para>The <database>SELECT</database> statement may contain parameters. For instance:
              <blockquote><literallayout class="monospaced">
SELECT NAME || :SFX FROM NAMES WHERE NUMBER = :NUM
              </literallayout></blockquote>
            Each parameter has to have been declared beforehand as a PSQL variable, even if they originate
            as input and output parameters. When the cursor is opened, the parameter is assigned the current
            value of the variable.</para>
          </listitem>
        </itemizedlist>
        <warning>
          <title>Attention!</title>
          <para>If the value of a PSQL variable used in the SELECT statement changes during the loop,
          its new value may (but not always) be used for the remaining rows. It is better to avoid having
          such situations arise unintentionally. If you really need this behaviour, you should test your
          code carefully to be certain that you know exactly how changes in the variable affect the
          result.</para>
          <para>Note particularly that the behaviour may depend on the query plan, specifically on the
          indexes being used. No strict rules are in place for situations like this currently, but that
          could change in future versions of Firebird.</para>
        </warning>
      </section> <!-- Cursor idiosyncrasies -->

      <section id="fblangref25-psql-cursor-examples">
        <title>Examples Using Named Cursors</title>
        <orderedlist>
          <listitem>Declaring a named cursor in the trigger.
            <blockquote><programlisting>
CREATE OR ALTER TRIGGER TBU_STOCK
BEFORE UPDATE ON STOCK
AS
  DECLARE C_COUNTRY CURSOR FOR (
    SELECT
      COUNTRY,
      CAPITAL
    FROM COUNTRY
  );
BEGIN
  /* PSQL statements */
END
            </programlisting></blockquote>
          </listitem>
          <listitem>A collection of scripts for creating views with a PSQL block using named cursors.
            <blockquote><programlisting>
EXECUTE BLOCK
RETURNS (
    SCRIPT BLOB SUB_TYPE TEXT)
AS
DECLARE VARIABLE FIELDS VARCHAR(8191);
DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
DECLARE VARIABLE RELATION RDB$RELATION_NAME;
DECLARE VARIABLE SOURCE   TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
DECLARE VARIABLE CUR_R      CURSOR FOR (
    SELECT
        RDB$RELATION_NAME,
        RDB$VIEW_SOURCE
    FROM
        RDB$RELATIONS
    WHERE
        RDB$VIEW_SOURCE IS NOT NULL);
-- Declaring a named cursor where
-- a local variable is used
DECLARE CUR_F      CURSOR FOR (
    SELECT
        RDB$FIELD_NAME
    FROM
        RDB$RELATION_FIELDS
    WHERE
        -- It is important that the variable must be declared earlier
        RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SOURCE;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
    -- The CUR_F cursor will use the value
    -- of the RELATION variable initiated above
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SOURCE;

    SUSPEND;
  END
  CLOSE CUR_R;
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
      </section> <!-- Cursor examples -->
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-open"><database>OPEN</database></link>,
        <link linkend="fblangref25-psql-fetch"><database>FETCH</database></link>,
        <link linkend="fblangref25-psql-close"><database>CLOSE</database></link>
        </para>
      </formalpara>
    </section> <!-- DECLARE CURSOR -->

    <section id="fblangref25-psql-declare-variable">
      <title><database>DECLARE VARIABLE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Declaring a local variable</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
DECLARE [VARIABLE] &lt;varname&gt;
  {&lt;datatype&gt; | &lt;domain&gt; | TYPE OF {&lt;domain&gt; | COLUMN &lt;rel.col&gt;}
    [NOT NULL]  [CHARACTER SET &lt;charset&gt;] [COLLATE &lt;collation&gt;]
    [{DEFAULT | = } &lt;initvalue&gt;];

&lt;datatype&gt; ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(precision [, scale])]
  | {CHAR | CHARACTER | CHARACTER VARYING | VARCHAR} [(size)]
    [CHARACTER SET charset]
  | {NCHAR | NATIONAL CHARACTER | NATIONAL CHAR} [VARYING]
    [(size)]
  | BLOB [SUB_TYPE {subtype_num | subtype_name}]
    [SEGMENT SIZE seglen] [CHARACTER SET charset]
  | BLOB [(seglen [, subtype_num])]

&lt;initvalue&gt; ::= &lt;literal&gt; | &lt;context_var&gt;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-declare-variable">
      <?dbfo keep-together='auto'?>
        <title>DECLARE VARIABLE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Name of the local variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">datatype</entry>
              <entry align="left">An SQL data type</entry>
            </row>
            <row valign="middle">
              <entry align="center">domain</entry>
              <entry align="left">The name of an existing domain in this database</entry>
            </row>
            <row valign="middle">
              <entry align="center">rel.col</entry>
              <entry align="left">Relation name (table or view) in this database
              and the name of a column in that relation</entry>
            </row>
            <row valign="middle">
              <entry align="center">precision</entry>
              <entry align="left">Precision. From 1 to 18</entry>
            </row>
            <row valign="middle">
              <entry align="center">scale</entry>
              <entry align="left">Scale. From 0 to 18, it must be less than or equal to precision</entry>
            </row>
            <row valign="middle">
              <entry align="center">size</entry>
              <entry align="left">The maximum size of a string in characters</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_num</entry>
              <entry align="left">BLOB subtype number</entry>
            </row>
            <row valign="middle">
              <entry align="center">subtype_name</entry>
              <entry align="left">BLOB subtype mnemonic name</entry>
            </row>
            <row valign="middle">
              <entry align="center">seglen</entry>
              <entry align="left">Segment size, not greater than 65,535</entry>
            </row>
            <row valign="middle">
              <entry align="center">initvalue</entry>
              <entry align="left">Initial value for this variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">literal</entry>
              <entry align="left">Literal of a type compatible with the type of the local variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">context_var</entry>
              <entry align="left">Any context variable whose type is compatible with the type of the local variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">charset</entry>
              <entry align="left">Character set</entry>
            </row>
            <row valign="middle">
              <entry align="center">collation</entry>
              <entry align="left">Collation sequence</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The statement <database>DECLARE [VARIABLE]</database> is used for declaring a
      local variable. The keyword <database>VARIABLE</database> can be omitted.
      One <database>DECLARE [VARIABLE]</database> statement is required for each local variable.
      Any number of <database>DECLARE [VARIABLE]</database> statements can be included and in any
      order. The name of a local variable must be unique among the names of local variables and input
      and output parameters declared for the module.</para>

      <section id="fblangref25-psql-variable-type">
        <title>Data Type for Variables</title>
        <para>A local variable can be of any SQL type other than an array.
          <itemizedlist spacing="compact">
            <listitem>A domain name can be specified as the type and the variable will inherit all of
            its attributes.</listitem>
            <listitem>If the TYPE OF &lt;domain&gt; clause is used instead, the variable will inherit
            only the domain's data type, and, if applicable, its character set and collation attributes.
            Any default value or constraints such as NOT NULL or CHECK constraints are not
            inherited.</listitem>
            <listitem>If the TYPE OF COLUMN &lt;relation.column&gt;> option is used to <quote>borrow</quote>
            from a column in a table or view, the variable will inherit only the column's data type, and,
            if applicable, its character set and collation attributes.  Any other attributes
            are ignored.</listitem>
          </itemizedlist>
        </para>
      </section>
      
      <formalpara>
        <title>NOT NULL Constraint</title>
          <para>&nbsp;The variable can be constrained NOT NULL if required.  If a domain has been specified
          as the data type and already carries the NOT NULL constraint, it will not be necessary.  With the
          other forms, including use of a domain that is nullable, the NOT NULL attribute should be included
          if needed.</para>
       </formalpara>
       <formalpara>
         <title>CHARACTER SET and COLLATE clauses</title>
         <para>&nbsp;Unless specified, the character set and collation sequence of a string variable will
         be the database defaults.  A <database>CHARACTER SET</database> clause can be included, if required,
         to handle string data that is going to be in a different character set.  A valid collation sequence
         (<database>COLLATE</database> clause) can also be included, with or without the character set
         clause.</para>
      </formalpara>
      <formalpara>
        <title>Initializing a Variable</title>
        <para>Local variables are NULL when execution of the module begins.  They can be initialized so
        that a starting or default value is available when they are first referenced.
        The <database>DEFAULT</database> &lt;initvalue&gt; form can be used, or just the assignment operator,
        &quot;=&quot;: = &lt;initvalue&gt;.  The value can be any type-compatible literal or context variable.
          <important>
            <para>Be sure to use this clause for any variables that are constrained to be NOT NULL 
            and do not otherwise have a default value available.</para>
          </important>
        </para>
      </formalpara>

      <formalpara>
        <title>Examples of various ways to declare local variables</title>
        <blockquote><programlisting>
CREATE OR ALTER PROCEDURE SOME_PROC
AS
  -- Declaring a variable of the INT type
  DECLARE I INT;
  -- Declaring a variable of the INT type that does not allow NULL
  DECLARE VARIABLE J INT NOT NULL;
  -- Declaring a variable of the INT type with the default value of 0
  DECLARE VARIABLE K INT DEFAULT 0;
  -- Declaring a variable of the INT type with the default value of 1
  DECLARE VARIABLE L INT = 1;
  -- Declaring a variable based on the COUNTRYNAME domain
  DECLARE FARM_COUNTRY COUNTRYNAME;
  -- Declaring a variable of the type equal to the COUNTRYNAME domain
  DECLARE FROM_COUNTRY TYPE OF COUNTRYNAME;
  -- Declaring a variable with the type of the CAPITAL column in the COUNTRY table
  DECLARE CAPITAL TYPE OF COLUMN COUNTRY.CAPITAL;
BEGIN
  /* PSQL statements */
END
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-datatypes">Data Types and Subtypes</link>,
        <link linkend="fblangref25-datatypes-custom">Custom Data Types&mdash;Domains</link>,
        <link linkend="fblangref25-ddl-domn"><database>CREATE DOMAIN</database></link>
        </para>
      </formalpara>
    </section><!-- DECLARE VARIABLE -->

    <section id="fblangref25-psql-beginend">
      <title><database>BEGIN ... END</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Delineating a block of statements</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
&lt;block&gt; ::=
BEGIN
  &lt;compound_statement&gt;
  [&lt;compound_statement&gt;
  &hellip;]
END

&lt;compound_statement&gt; ::= {&lt;block&gt; | &lt;statement&gt;;}
        </programlisting></blockquote>
      </formalpara>
      <para>The <database>BEGIN ... END</database> construct is a two-part statement that wraps a block
      of statements that are executed as one unit of code. Each block starts with the
      half-statement <database>BEGIN</database> and ends with the other half-statement <database>END</database>.
      Blocks can be nested to unlimited depth.  They may be empty, allowing them to act as stubs, without the need
      to write dummy statements.</para>
      <para>The BEGIN and END statements have no line terminators. However, when defining or altering
      a PSQL module in the <emphasis>isql</emphasis> utility, that application requires that the last
      <database>END</database> statement be followed by its own terminator character, that was
      previously switched, using <database>SET TERM</database>, to some string other than a semicolon.
      That terminator is not part of the PSQL syntax.</para>
      <para>The final, or outermost, <database>END</database> statement in a trigger terminates the trigger.
      What the final <database>END</database> statement does in a stored procedure depends on the
      type of procedure:
        <itemizedlist spacing="compact">
          <listitem>In a selectable procedure, the final <database>END</database> statement
          returns control to the caller, returning SQLCODE 100, indicating that there are no more rows
          to retrieve</listitem>
          <listitem>In an executable procedure, the final <database>END</database> statement returns
          control to the caller, along with the current values of any output parameters defined.</listitem>
        </itemizedlist>
      </para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;A sample procedure from the <filename>employee.fdb</filename> database,
        showing simple usage of <database>BEGIN...END</database> blocks:
          <blockquote><programlisting>
SET TERM ^;
CREATE OR ALTER PROCEDURE DEPT_BUDGET (
    DNO CHAR(3))
RETURNS (
    TOT DECIMAL(12,2))
AS
    DECLARE VARIABLE SUMB DECIMAL(12,2);
    DECLARE VARIABLE RDNO CHAR(3);
    DECLARE VARIABLE CNT  INTEGER;
BEGIN
  TOT = 0;

  SELECT
      BUDGET
  FROM
      DEPARTMENT
  WHERE DEPT_NO = :DNO
  INTO :TOT;

  SELECT
      COUNT(BUDGET)
  FROM
      DEPARTMENT
  WHERE HEAD_DEPT = :DNO
  INTO :CNT;

  IF (CNT = 0) THEN
    SUSPEND;

  FOR
      SELECT
          DEPT_NO
      FROM
          DEPARTMENT
      WHERE HEAD_DEPT = :DNO
      INTO :RDNO
  DO
  BEGIN
    EXECUTE PROCEDURE DEPT_BUDGET(:RDNO)
    RETURNING_VALUES :SUMB;
    TOT = TOT + SUMB;
  END

  SUSPEND;
END^
SET TERM ;^
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exit"><database>EXIT</database></link>,
        <link linkend="fblangref25-psql-leave"><database>LEAVE</database></link>,
        <link linkend="fblangref25-sidebar01"><database>SET TERM</database></link>
        </para>
      </formalpara>
    </section> <!-- begin ... end -->

    <section id="fblangref25-psql-ifthen">
      <title><database>IF ... THEN ... ELSE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Conditional jumps</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
IF (&lt;condition&gt;)
	THEN &lt;single_statement&gt; ; | BEGIN &lt;compound_statement&gt; END
[ELSE &lt;single_statement&gt; ; | BEGIN &lt;compound_statement&gt; END]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-ifthen">
      <?dbfo keep-together='auto'?>
        <title>IF ... THEN ... ELSE Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">A logical condition returning TRUE, FALSE or UNKNOWN</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">A single statement terminated with a semicolon</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Two or more statements wrapped in BEGIN ... END</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The conditional jump statement <database>IF ... THEN</database> is used to branch
      the execution process in a PSQL module. The condition is always enclosed in parentheses.
      If it returns the value <database>TRUE</database>, execution branches to the statement
      or the block of statements after the keyword <database>THEN</database>. If an
      <database>ELSE</database> is present and the condition returns FALSE or UNKNOWN,
      execution branches to the statement or the block of statements after it.</para>

      <sidebar id="multijump">
        <title>Multi-branch Jumps</title>
        <para>PSQL does not provide multi-branch jumps, such as CASE or SWITCH.
        Nevertheless, the CASE search statement from DSQL is available in PSQL and is able
        to satisfy at least some use cases in the manner of a switch:
          <blockquote><programlisting>
CASE &lt;test_expr&gt;
  WHEN &lt;expr&gt; THEN result
  [WHEN &lt;expr&gt; THEN result ...]
  [ELSE defaultresult]
END

CASE
  WHEN &lt;bool_expr&gt; THEN result
  [WHEN &lt;bool_expr&gt; THEN result ...]
  [ELSE defaultresult]
END
          </programlisting></blockquote>
          <formalpara>
            <title>Example in PSQL</title>
            <blockquote><programlisting>
...
C = CASE
      WHEN A=2 THEN 1
      WHEN A=1 THEN 3
      ELSE 0
    END;
...
            </programlisting></blockquote>
          </formalpara>
        </para>
      </sidebar> <!-- multi-branch jumps -->

      <formalpara>
        <title>Example</title>
        <para>&nbsp;An example using the IF statement. Assume that the FIRST,
        LINE2 and LAST variables were declared earlier.
          <blockquote><programlisting>
...
IF (FIRST IS NOT NULL) THEN
     LINE2 = FIRST || ' ' || LAST;
ELSE
     LINE2 = LAST;
...
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-while"><database>WHILE ... DO</database></link>,
        <link linkend="fblangref25-commons-conditional-case"><database>CASE</database></link>
        </para>
      </formalpara>
    </section> <!-- if ... then ... do -->

    <section id="fblangref25-psql-while">
      <title><database>WHILE ... DO</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Looping constructs</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
WHILE &lt;condition&gt; DO
&lt;single_statement&gt; ; | BEGIN &lt;compound_statement&gt; END
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-while">
      <?dbfo keep-together='auto'?>
        <title>WHILE ... DO Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">A logical condition returning TRUE, FALSE or UNKNOWN</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">A single statement terminated with a semicolon</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">Two or more statements wrapped in BEGIN ... END</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>A <database>WHILE</database> statement implements the looping construct in PSQL.
      The statement or the block of statements will be executed until the condition returns TRUE.
      Loops can be nested to any depth.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;A procedure calculating the sum of numbers from 1 to I shows how the looping
        construct is used.
          <blockquote><programlisting>
CREATE PROCEDURE SUM_INT (I INTEGER)
RETURNS (S INTEGER)
AS
BEGIN
  s = 0;
  WHILE (i > 0) DO
  BEGIN
    s = s + i;
    i = i - 1;
  END
END
          </programlisting></blockquote>
        Executing the procedure in <emphasis>isql</emphasis>:
          <blockquote><programlisting>
EXECUTE PROCEDURE SUM_INT(4);
          </programlisting></blockquote>
        the result is:
          <blockquote><programlisting>
S
==========
10
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-ifthen"><database>IF ... THEN ... ELSE</database></link>,
        <link linkend="fblangref25-psql-leave"><database>LEAVE</database></link>,
        <link linkend="fblangref25-psql-exit"><database>EXIT</database></link>,
        <link linkend="fblangref25-psql-forselect"><database>FOR SELECT</database></link>,
        <link linkend="fblangref25-psql-forexec"><database>FOR EXECUTE STATEMENT</database></link>
        </para>
      </formalpara>
    </section> <!-- while -->

    <section id="fblangref25-psql-leave">
      <title><database>LEAVE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Terminating a loop</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
[label:]
&lt;loop&gt;
BEGIN
  ...
  LEAVE [label];
  ...
END
&lt;loop_stmt&gt; ::=
    FOR &lt;select_stmt&gt; INTO &lt;var_list&gt; DO
  | FOR EXECUTE STATEMENT ... INTO &lt;var_list&gt; DO
  | WHILE (&lt;condition&gt;)} DO
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-leave">
      <?dbfo keep-together='auto'?>
        <title>LEAVE Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">label</entry>
              <entry align="left">Label</entry>
            </row>
            <row valign="middle">
              <entry align="center">select_stmt	</entry>
              <entry align="left">SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">condition</entry>
              <entry align="left">A logical condition returning TRUE, FALSE or UNKNOWN</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>A <database>LEAVE</database> statement immediately terminates the inner loop of a
      <database>WHILE</database> or <database>FOR</database> looping statement. The
      <database>LABEL</database> parameter is optional.</para>
      <para><database>LEAVE</database> can cause an exit from outer loops as well. Code continues to
      be executed from the first statement after the termination of the outer loop block.</para>
      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Leaving a loop if an error occurs on an insert into the NUMBERS table. The
          code continues to be executed from the line C = 0.
            <blockquote><programlisting>
...
WHILE (B &lt; 10) DO
BEGIN
    INSERT INTO NUMBERS(B)
    VALUES (:B);
    B = B + 1;
    WHEN ANY DO
    BEGIN
        EXECUTE PROCEDURE LOG_ERROR (
             CURRENT_TIMESTAMP,
             'ERROR IN B LOOP');
        LEAVE;
    END
END
C = 0;
...
            </programlisting></blockquote>
          </listitem>

          <listitem>A example using labels in the <database>LEAVE</database> statement.
          <function>LEAVE LOOPA</function> terminates the outer loop and <function>LEAVE LOOPB</function>
          terminates the inner loop. Note that the plain <database>LEAVE</database> statement would
          be enough to terminate the inner loop.
            <blockquote><programlisting>
...
STMT1 = 'SELECT NAME FROM FARMS';
LOOPA:
FOR EXECUTE STATEMENT :STMT1
INTO :FARM DO
BEGIN
  STMT2 = 'SELECT NAME ' || 'FROM ANIMALS WHERE FARM = ''';
  LOOPB:
  FOR EXECUTE STATEMENT :STMT2 || :FARM || ''''
  INTO :ANIMAL DO
  BEGIN
    IF (ANIMAL = 'FLUFFY') THEN
      LEAVE LOOPB;
    ELSE IF (ANIMAL = FARM) THEN
      LEAVE LOOPA;
    ELSE
      SUSPEND;
  END
END
...
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exit"><database>EXIT</database></link>
        </para>
      </formalpara>
    </section> <!-- leave -->

    <section id="fblangref25-psql-exit">
      <title><database>EXIT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Terminating module execution</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
EXIT;
        </programlisting></blockquote>
      </formalpara>
      <para>The <database>EXIT</database> statement causes execution of the procedure or
      trigger to jump to the final <database>END</database> statement from any point in
      the code, thus terminating the program.</para>
      <formalpara>
        <title>Example</title>
        <para>Using the EXIT statement in a selectable procedure:
          <blockquote><programlisting>
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-leave"><database>LEAVE</database></link>,
        <link linkend="fblangref25-psql-suspend"><database>SUSPEND</database></link>
        </para>
      </formalpara>
    </section> <!-- EXIT -->

    <section id="fblangref25-psql-suspend">
      <title><database>SUSPEND</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Passing output to the buffer and suspending execution
        while waiting for caller to fetch it</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
SUSPEND;
        </programlisting></blockquote>
      </formalpara>
      <para>The <database>SUSPEND</database> statement is used in a selectable stored procedure to pass
      the values of output parameters to a buffer and suspend execution. Execution remains suspended until
      the calling application fetches the contents of the buffer. Execution resumes from the statement
      directly after the <database>SUSPEND</database> statement.  In practice, this is likely to be a new
      iteration of a looping process.
        <important>
          <title>Important Notes</title>
          <orderedlist>
            <listitem><para>Applications using interfaces that wrap the API perform the fetches from
            selectable procedures transparently.</para></listitem>
            <listitem><para>When a <database>SUSPEND</database> statement is executed in an executable
            stored procedure, it is the same as executing the <database>EXIT</database> statement,
            resulting in immediate termination of the procedure.</para></listitem>
            <listitem><para><database>SUSPEND</database> <quote>breaks</quote> the atomicity of the block
            in which it is located. If an error occurs in a selectable procedure, statements executed after
            the final <database>SUSPEND</database> statement will be rolled back. Statements that executed
            before the final <database>SUSPEND</database> statement will not be rolled back unless the
            transaction is rolled back.</para></listitem>
          </orderedlist>
        </important>
      </para>
      <formalpara>
        <title>Example</title>
        <para>Using the <database>SUSPEND</database> statement in a selectable procedure:
          <blockquote><programlisting>
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exit"><database>EXIT</database></link>
      </para>
      </formalpara>
    </section> <!-- suspend -->

    <section id="fblangref25-psql-execstmt">
      <title><database>EXECUTE STATEMENT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Executing dynamically created SQL statements</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara><title>Syntax</title>
        <blockquote><programlisting>
&lt;execute_statement&gt; ::= EXECUTE STATEMENT &lt;argument&gt;
  [&lt;option&gt; &hellip;]
  [INTO &lt;variables&gt;]

&lt;argument&gt; ::= paramless_stmt
            | (paramless_stmt)
            | (&lt;stmt_with_params&gt;) (&lt;param_values&gt;)

&lt;param_values&gt; ::= &lt;named_values&gt; | &lt;positional_values&gt;

&lt;named_values&gt; ::= paramname := value_expr
   [, paramname := value_expr ...]

&lt;positional_values&gt; ::= value_expr [, value_expr ...]

&lt;option&gt; ::= WITH {AUTONOMOUS | COMMON} TRANSACTION
           | WITH CALLER PRIVILEGES
           | AS USER user
           | PASSWORD password
           | ROLE role
           | ON EXTERNAL [DATA SOURCE] &lt;connect_string&gt;

&lt;connect_string&gt; ::= [&lt;hostspec&gt;] {filepath | db_alias}

&lt;hostspec&gt; ::= &lt;tcpip_hostspec&gt; | &lt;NamedPipes_hostspec&gt;

&lt;tcpip_hostspec&gt; ::= hostname:

&lt;NamePipes_hostspec&gt; ::= \\hostname\

&lt;variables&gt; ::= [:]varname [, [:]varname ...]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-execstmt">
      <?dbfo keep-together='auto'?>
        <title>EXECUTE STATEMENT Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">paramless_stmt</entry>
              <entry align="left">Literal string or variable containing a non-parameterized
              SQL query</entry>
            </row>
            <row valign="middle">
              <entry align="center">stmt_with_params</entry>
              <entry align="left">Literal string or variable containing a parameterized
              SQL query</entry>
            </row>
            <row valign="middle">
              <entry align="center">paramname</entry>
              <entry align="left">SQL query parameter name</entry>
            </row>
            <row valign="middle">
              <entry align="center">value_expr</entry>
              <entry align="left">SQL expression resolving to a value</entry>
            </row>
            <row valign="middle">
              <entry align="center">user</entry>
              <entry align="left">User name. It can be a string, <database>CURRENT_USER</database>
              or a string variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">password</entry>
              <entry align="left">Password. It can be a string or a string variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">role</entry>
              <entry align="left">Role. It can be a string, <database>CURRENT_ROLE</database>
              or a string variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">connection_string</entry>
              <entry align="left">Connection string. It can be a string or a string variable</entry>
            </row>
            <row valign="middle">
              <entry align="center">filepath</entry>
              <entry align="left">Path to the primary database file</entry>
            </row>
            <row valign="middle">
              <entry align="center">db_alias</entry>
              <entry align="left">Database alias</entry>
            </row>
            <row valign="middle">
              <entry align="center">hostname</entry>
              <entry align="left">Computer name or IP address</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variable</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>EXECUTE STATEMENT</database> takes a string parameter and executes
      it as if it were a DSQL statement. If the statement returns data, it can be passed to local
      variables by way of an <database>INTO</database> clause.</para>

      <section id="fblangref25-psql-execstmt-wparams">
        <title>Parameterized Statements</title>
        <para>You can use parameters&mdash;either named or positional&mdash; in the DSQL statement string.
        Each parameter must be assigned a value.</para>
        <section id="fblangref25-psql-execstmt-wparams01">
          <title>Special Rules for Parameterized Statements</title>
          <orderedlist>
            <listitem>
              <para>Named and positional parameters cannot be mixed in one query</para>
            </listitem>
            <listitem>
              <para>If the statement has parameters, they must be enclosed in parentheses
              when <database>EXECUTE STATEMENT</database> is called, regardless of whether they come directly
              as strings, as variable names or as expressions</para>
            </listitem>
            <listitem>
              <para>Each named parameter must be prefixed by a colon (:) in the statement string itself,
              but not when the parameter is assigned a value</para>
            </listitem>
            <listitem>
              <para>Positional parameters must be assigned their values in the same order as they
              appear in the query text</para>
            </listitem>
            <listitem>
              <para>The assignment operator for parameters is the special operator &quot;:=&quot;, similar to
              the assignment operator in Pascal</para>
            </listitem>
            <listitem>
              <para>Each named parameter can be used in the statement more than once, but its value must
              be assigned only once
              <comment>Editor note: I suspect something got lost in translation here.  Needs confirmation
              or correction.</comment>
              </para>
            </listitem>
            <listitem>
              <para>With positional parameters, the number of assigned values must match the number of parameter
              placeholders (question marks) in the statement exactly</para>
            </listitem>
          </orderedlist>
        </section> <!-- special rules -->

        <formalpara>
          <title>Examples</title>
          <para>&nbsp;With named parameters:
            <blockquote><programlisting>
...
DECLARE license_num VARCHAR(15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = :driver AND location = :loc';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  INTO connect_string;
  ...
  FOR
    SELECT id
    FROM drivers
    INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
        (driver := current_driver,
         loc := current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...
            </programlisting></blockquote>
          The same code with positional parameters:
            <blockquote><programlisting>
DECLARE license_num VARCHAR (15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = ? AND location = ?';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  into connect_string;
  ...
  FOR SELECT id
      FROM drivers
      INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
        (current_driver, current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...
            </programlisting></blockquote>
           </para>
         </formalpara>
      </section> <!-- parameterised statements -->

      <section id="fblangref25-psql-execstmt-wautonomous">
        <title><database>WITH {AUTONOMOUS | COMMON} TRANSACTION</database></title>
        <para>Traditionally, the executed SQL statement always ran within the current transaction,
        and this is still the default. <database>WITH AUTONOMOUS TRANSACTION</database> causes a
        separate transaction to be started, with the same parameters as the current transaction.
        It will be committed if the statement runs to completion without errors and rolled back
        otherwise. <database>WITH COMMON TRANSACTION</database> uses the current transaction if
        possible.</para>
        <para>If the statement must run in a separate connection, an already started transaction
        within that connection is used, if available. Otherwise, a new transaction is started
        with the same parameters as the current transaction. Any new transactions started under
        the <quote>COMMON</quote> regime are committed or rolled back with the
        current transaction.</para>
      </section> <!-- with autonomous -->

      <section id="fblangref25-psql-execstmt-wcaller">
        <title><database>WITH WITH CALLER PRIVILEGES</database></title>
        <para>By default, the SQL statement is executed with the privileges of the current user.
        Specifying <database>WITH WITH CALLER PRIVILEGES</database> adds to this the privileges
        of the calling procedure or trigger, just as if the statement were executed directly by
        the routine. <database>WITH WITH CALLER PRIVILEGES</database> has no effect if
        the <database>ON EXTERNAL</database> clause is also present.</para>
      </section> <!-- with caller privileges -->

      <section id="fblangref25-psql-execstmt-onexternal">
        <title><database>ON EXTERNAL [DATA SOURCE]</database></title>
        <para>With <database>ON EXTERNAL [DATA SOURCE]</database>, the SQL statement is executed
        in a separate connection to the same or another database, possibly even on another server.
        If the connect string is NULL or '' (empty string), the entire <database>ON EXTERNAL
        [DATA SOURCE]</database> clause is considered absent and the statement is executed against
        the current database.</para>
        <section id="fblangref25-psql-execstmt-onext-connpool">
          <title>Connection Pooling</title>
          <itemizedlist>
            <listitem>External connections made by statements <database>WITH COMMON TRANSACTION</database>
            (the default) will remain open until the current transaction ends. They can be reused by
            subsequent calls to <database>EXECUTE STATEMENT</database>, but only if the connect string
            is exactly the same, including case</listitem>
            <listitem>External connections made by statements <database>WITH AUTONOMOUS TRANSACTION</database>
            are closed as soon as the statement has been executed</listitem>
            <listitem>Notice that statements <database>WITH AUTONOMOUS TRANSACTION</database> can and will
            re-use connections that were opened earlier by statements <database>WITH COMMON
            TRANSACTION</database>. If this happens, the reused connection will be left open after the statement
            has been executed. (It must be, because it has at least one un-committed transaction!)</listitem>
          </itemizedlist>
        </section>
        <section id="fblangref25-psql-execstmt-onext-transpool">
          <title>Transaction Pooling</title>
          <itemizedlist>
            <listitem>If <database>WITH COMMON TRANSACTION</database> is in effect, transactions will be
            reused as much as possible.  They will be committed or rolled back together with the current
            transaction</listitem>
            <listitem>If <database>WITH AUTONOMOUS TRANSACTION</database> is specified, a fresh transaction
            will always be started for the statement. This transaction will be committed or rolled back
            immediately after the statement's execution</listitem>
          </itemizedlist>
        </section>
        <section id="fblangref25-psql-execstmt-onext-errhandling">
          <title>Exception Handling</title>
          <para>Exception handling: When <database>ON EXTERNAL</database> is used, the extra connection is
          always made via a so-called external provider, even if the connection is to the current database.
          One of the consequences is that exceptions cannot be caught in the usual way. Every exception
          caused by the statement is wrapped in either an <function>eds_connection</function> or
          an <function>eds_statement</function> error. In order to catch them in your PSQL code, you have
          to use <database>WHEN GDSCODE eds_connection</database>, <database>WHEN GDSCODE eds_statement</database>
          or <database>WHEN ANY</database>.
            <note>
              <para>Without <database>ON EXTERNAL</database>, exceptions are caught in the usual way,
              even if an extra connection is made to the current database.</para>
            </note>
          </para>
        </section>
        <section id="fblangref25-psql-execstmt-onext-morenotes">
          <title>Miscellaneous Notes</title>
          <itemizedlist>
            <listitem>The character set used for the external connection is the same as that for the current connection</listitem>
            <listitem>Two-phase commits are not supported</listitem>
          </itemizedlist>
        </section>
      </section> <!-- onexternal -->

      <section id="fblangref25-psql-execstmt-asuser">
        <title><database>AS USER, PASSWORD</database> and <database>ROLE</database></title>
        <para>The optional <database>AS USER, PASSWORD</database> and <database>ROLE</database> clauses
        allow specificaton of which user will execute the SQL statement and with which role. The method of
        user log-in and whether a separate connection is open depend on the presence and values of the
        <database>ON EXTERNAL [DATA SOURCE]</database>, <database>AS USER</database>,
        <database>PASSWORD</database> and <database>ROLE</database> clauses:
        <itemizedlist>
          <listitem>If <database>ON EXTERNAL</database> is present, a new connection is always opened, and:
            <itemizedlist spacing="compact">
              <listitem>If at least one of <database>AS USER, PASSWORD</database> and <database>ROLE</database>
              is present, native authentication is attempted with the given parameter values (locally or
              remotely, depending on the connect string). No defaults are used for missing parameters</listitem>
              <listitem>If all three are absent and the connect string contains no hostname, then the new
              connection is established on the local host with the same user and role as the current connection.
              The term 'local' means 'on the same machine as the server' here. This is not necessarily the
              location of the client</listitem>
              <listitem>If all three are absent and the connect string contains a hostname, then trusted
              authentication is attempted on the remote host (again, 'remote' from the perspective of the
              server). If this succeeds, the remote operating system will provide the user name (usually the
              operating system account under which the Firebird process runs)</listitem>
             </itemizedlist>
          </listitem>
          <listitem>If <database>ON EXTERNAL</database> is absent:
            <itemizedlist spacing="compact">
              <listitem>If at least one of <database>AS USER, PASSWORD</database> and <database>ROLE</database>
              is present, a new connection to the current database is opened with the suppled parameter values.
              No defaults are used for missing parameters</listitem>
              <listitem>If all three are absent, the statement is executed within the current connection</listitem>
            </itemizedlist>
          </listitem>
        </itemizedlist>
        <note>
          <title>Notice</title>
          <para>If a parameter value is NULL or '' (empty string), the entire parameter is considered absent.
          Additionally, <database>AS USER</database> is considered absent if its value is equal to
          <database>CURRENT_USER</database>, and <database>ROLE</database> if it is the same
          as <database>CURRENT_ROLE</database>.</para>
        </note>
        </para>
      </section> <!-- AS USER, etc. -->

      <section id="fblangref25-psql-execstmt-caveats">
        <title>Caveats with <database>EXECUTE STATEMENT</database></title>
        <orderedlist>
          <listitem>There is no way to validate the syntax of the enclosed statement</listitem>
          <listitem>There are no dependency checks to discover whether tables or columns have been dropped</listitem>
          <listitem>Even though the performance in loops has been significantly improved in Firebird 2.5, execution
          is still considerably slower than when the same statements are launched directly</listitem>
          <listitem>Return values are strictly checked for data type in order to avoid unpredictable type-casting
          exceptions. For example, the string '1234' would convert to an integer, 1234, but 'abc' would give a
          conversion error</listitem>
        </orderedlist>
        <para>All in all, this feature is meant to be used very cautiously and you should always take the caveats into
        account. If you can achieve the same result with PSQL and/or DSQL, it will almost always be preferable.</para>
      </section> <!-- caveats -->

      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-forexec"><database>FOR EXECUTE STATEMENT</database></link>
        </para>
      </formalpara>
    </section> <!-- execute statement -->

    <section id="fblangref25-psql-forselect">
      <title><database>FOR SELECT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Looping row-by-row through a selected result set</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
FOR &lt;select_stmt&gt; [AS CURSOR cursorname]
DO {&lt;single_statement&gt; | BEGIN &lt;compound_statement&gt; END}
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-forselect">
      <?dbfo keep-together='auto'?>
        <title>FOR SELECT Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">select_stmt</entry>
              <entry align="left">SELECT statement</entry>
            </row>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Cursor name. It must be unique among cursor names in the PSQL module
              (stored procedure, trigger or PSQL block)</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">A single statement, terminated with a colon, that performs all the
              processing for this FOR loop</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">A block of statements wrapped in BEGIN...END, that performs all the
              processing for this FOR loop</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>A <database>FOR SELECT</database> statement
        <itemizedlist>
          <listitem>
            <para>retrieves each row sequentially from the result set and executes the statement or block of
            statements on the row. In each iteration of the loop, the field values of the current row are copied
            into pre-declared variables.</para>
            <para>Including the <database>AS CURSOR</database> clause enables positioned deletes and updates to
            be performed&mdash;see notes below</para>
          </listitem>
          <listitem>can embed other <database>FOR SELECT</database> statements</listitem>
          <listitem>
            can carry named parameters that must be previously declared in the <database>DECLARE
            VARIABLE</database> statement or exist as input or output parameters of the procedure</listitem>
          <listitem>requires an <database>INTO</database> clause that is located at the end of the
            <database>SELECT ... FROM ...</database> specification. In each iteration of the loop, the
            field values in the current row are copied to the list of variables specified in the
            <database>INTO</database> clause. The loop repeats until all rows are retrieved, after which
            it terminates</listitem>
          <listitem>can be terminated before all rows are retrieved by using a
            <database>LEAVE statement</database></listitem>
        </itemizedlist>
      </para>
      <section id="fblangref25-psql-undeclaredcursor">
        <title>The Undeclared Cursor</title>
        <para>The optional <database>AS CURSOR</database> clause surfaces the set in the <database>FOR
        SELECT</database> structure as an undeclared, named cursor that can be operated on using the
        <database>WHERE CURRENT OF</database> clause inside the statement or block following the
        <database>DO</database> command, in order to delete or update the current row before execution
        moves to the next iteration.</para>
        <para>Other points to take into account regarding undeclared cursors:
          <orderedlist>
            <listitem>the <database>OPEN</database>, <database>FETCH</database> and <database>CLOSE</database>
            statements cannot be applied to a cursor surfaced by the <database>AS CURSOR</database>
            clause</listitem>
            <listitem>the cursor name argument associated with an <database>AS CURSOR</database> clause must
            not clash with any names created by <database>DECLARE VARIABLE</database> or <database>DECLARE
            CURSOR</database> statements at the top of the body code, nor with any other cursors surfaced
            by an <database>AS CURSOR</database> clause</listitem>
            <listitem>The optional <database>FOR UPDATE</database> clause in the <database>SELECT</database>
            statement is not required for a positioned update</listitem>
          </orderedlist>
        </para>
      </section><!-- the undeclared cursor -->

      <formalpara>
        <title>Examples using FOR SELECT</title>
        <orderedlist>
          <listitem>A simple loop through query results:
            <blockquote><programlisting>
CREATE PROCEDURE SHOWNUMS
RETURNS (
  AA INTEGER,
  BB INTEGER,
  SM INTEGER,
  DF INTEGER)
AS
BEGIN
  FOR SELECT DISTINCT A, B
      FROM NUMBERS
    ORDER BY A, B
    INTO AA, BB
  DO
  BEGIN
    SM = AA + BB;
    DF = AA - BB;
    SUSPEND;
  END
END
            </programlisting></blockquote>
          </listitem>
          <listitem>Nested FOR SELECT loop:
            <blockquote><programlisting>
CREATE PROCEDURE RELFIELDS
RETURNS (
  RELATION CHAR(32),
  POS INTEGER,
  FIELD CHAR(32))
AS
BEGIN
  FOR SELECT RDB$RELATION_NAME
      FROM RDB$RELATIONS
      ORDER BY 1
      INTO :RELATION
  DO
  BEGIN
    FOR SELECT
          RDB$FIELD_POSITION + 1,
          RDB$FIELD_NAME
        FROM RDB$RELATION_FIELDS
        WHERE
          RDB$RELATION_NAME = :RELATION
        ORDER BY RDB$FIELD_POSITION
        INTO :POS, :FIELD
    DO
    BEGIN
      IF (POS = 2) THEN
        RELATION = ' "';

      SUSPEND;
    END
  END
END
            </programlisting></blockquote>
          </listitem>
          <listitem>Using the <database>AS CURSOR</database> clause to surface a cursor for
          the positioned delete of a record:
            <blockquote><programlisting>
CREATE PROCEDURE DELTOWN (
  TOWNTODELETE VARCHAR(24))
RETURNS (
  TOWN VARCHAR(24),
  POP INTEGER)
AS
BEGIN
  FOR SELECT TOWN, POP
      FROM TOWNS
      INTO :TOWN, :POP AS CURSOR TCUR
  DO
  BEGIN
    IF (:TOWN = :TOWNTODELETE) THEN
      -- Positional delete
      DELETE FROM TOWNS
      WHERE CURRENT OF TCUR;
    ELSE
      SUSPEND;
  END
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link>,
        <link linkend="fblangref25-psql-leave"><database>LEAVE</database></link>,
        <link linkend="fblangref25-dml-select"><database>SELECT</database></link>,
        <link linkend="fblangref25-dml-update"><database>UPDATE</database></link>,
        <link linkend="fblangref25-dml-delete"><database>DELETE</database></link>
        </para>
      </formalpara>
    </section> <!-- for select -->

    <section id="fblangref25-psql-forexec">
      <title><database>FOR EXECUTE STATEMENT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Executing dynamically created SQL statements that return
        a row set</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
FOR &lt;execute_statement&gt; DO {&lt;single_statement&gt; | BEGIN &lt;compound_statement&gt; END}
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-forexec">
      <?dbfo keep-together='auto'?>
        <title>FOR EXECUTE STATEMENT Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">execute_stmt</entry>
              <entry align="left">An EXECUTE STATEMENT string</entry>
            </row>
            <row valign="middle">
              <entry align="center">single_statement</entry>
              <entry align="left">A single statement, terminated with a colon, that performs all the
              processing for this FOR loop</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">A block of statements wrapped in BEGIN...END, that performs all the
              processing for this FOR loop</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>FOR EXECUTE STATEMENT</database> is used, in a manner analogous to
      <database>FOR SELECT</database>, to loop through the result set of a dynamically executed query
      that returns multiple rows.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;Executing a dynamically constructed <database>SELECT</database> query that returns
        a data set:
          <blockquote><programlisting>
CREATE PROCEDURE DynamicSampleThree (
   Q_FIELD_NAME VARCHAR(100),
   Q_TABLE_NAME VARCHAR(100)
) RETURNS(
  LINE VARCHAR(32000)
)
AS
  DECLARE VARIABLE P_ONE_LINE VARCHAR(100);
BEGIN
  LINE = '';
  FOR
    EXECUTE STATEMENT
      'SELECT T1.' || :Q_FIELD_NAME ||
      ' FROM ' || :Q_TABLE_NAME || ' T1 '
    INTO :P_ONE_LINE
  DO
    IF (:P_ONE_LINE IS NOT NULL) THEN
      LINE = :LINE || :P_ONE_LINE || ' ';
  SUSPEND;
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-execstmt"><database>EXECUTE STATEMENT</database></link>
        </para>
      </formalpara>
    </section> <!-- FOR EXECUTE STATEMENT -->

    <section id="fblangref25-psql-open">
      <title><database>OPEN</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Opening a declared cursor</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
OPEN cursorname;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-open">
      <?dbfo keep-together='auto'?>
        <title>OPEN Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Cursor name. A cursor with this name must be previously
              declared with a <database>DECLARE CURSOR</database> statement</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>An <database>OPEN</database> statement opens a previously declared cursor, executes
      the <database>SELECT</database> statement declared for it and makes the first record
      the result data set ready to fetch. <database>OPEN</database> can be applied only to
      cursors previously declared in a <database>DECLARE VARIABLE</database> statement.
        <note>
          <para>If the <database>SELECT</database> statement declared for the cursor has parameters,
          they must be declared as local variables or exist as input or output parameters before
          the cursor is declared. When the cursor is opened, the parameter is assigned the current
          value of the variable.</para>
        </note>
      </para>
      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Using the OPEN statement:
            <blockquote><programlisting>
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^
            </programlisting></blockquote>
          </listitem>
          <listitem>A collection of scripts for creating views using
          a PSQL block with named cursors:
            <blockquote><programlisting>
EXECUTE BLOCK
RETURNS (
    SCRIPT BLOB SUB_TYPE TEXT)
AS
DECLARE VARIABLE FIELDS VARCHAR(8191);
DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
DECLARE VARIABLE RELATION RDB$RELATION_NAME;
DECLARE VARIABLE SOURCE   TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
-- named cursor
DECLARE VARIABLE CUR_R      CURSOR FOR (
    SELECT
        RDB$RELATION_NAME,
        RDB$VIEW_SOURCE
    FROM
        RDB$RELATIONS
    WHERE
        RDB$VIEW_SOURCE IS NOT NULL);
-- named cursor with local variable
DECLARE CUR_F      CURSOR FOR (
    SELECT
        RDB$FIELD_NAME
    FROM
        RDB$RELATION_FIELDS
    WHERE
          -- Important! The variable shall be declared earlier
        RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SOURCE;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
        -- The CUR_F cursor will use
        -- variable value of RELATION initialized above
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SOURCE;

    SUSPEND;
  END
  CLOSE CUR_R;
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link>,
          <link linkend="fblangref25-psql-fetch"><database>FETCH</database></link>,
          <link linkend="fblangref25-psql-close"><database>CLOSE</database></link>
        </para>
      </formalpara>
    </section> <!-- OPEN -->

    <section id="fblangref25-psql-fetch">
      <title><database>FETCH</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Fetching successive records from a data set retrieved
        by a cursor</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
FETCH cursorname INTO [:]varname [, [:]varname ...];
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-fetch">
      <?dbfo keep-together='auto'?>
        <title>FETCH Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Cursor name. A cursor with this name must be previously
              declared with a <database>DECLARE CURSOR</database> statement and opened
              by an <database>OPEN</database> statement.</entry>
            </row>
            <row valign="middle">
              <entry align="center">varname</entry>
              <entry align="left">Variable name</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>A <database>FETCH</database> statement fetches the first and successive rows from
      the result set of the cursor and assigns the column values to PSQL variables. The 
      <database>FETCH</database> statement can be used only with a cursor declared with
      the <database>DECLARE CURSOR</database> statement.</para>
      <para>The <database>INTO</database> clause gets data from the current row of the cursor 
      and loads them into PSQL variables.</para>
      <para>For checking whether all of the the data set rows have been fetched, the
      context variable <database>ROW_COUNT</database> returns the number of rows fetched by the
      statement. It is positive until all rows have been checked.  A  <database>ROW_COUNT</database>
      of 1 indicates that the next fetch will be the last.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;Using the FETCH statement:
          <blockquote><programlisting>
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link>,
          <link linkend="fblangref25-psql-open"><database>OPEN</database></link>,
          <link linkend="fblangref25-psql-close"><database>CLOSE</database></link>
        </para>
      </formalpara>
    </section> <!-- FETCH -->

    <section id="fblangref25-psql-close">
      <title><database>CLOSE</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Closing a declared cursor</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
CLOSE cursorname;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-close">
      <?dbfo keep-together='auto'?>
        <title>CLOSE Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">cursorname</entry>
              <entry align="left">Cursor name. A cursor with this name must be previously
              declared with a <database>DECLARE CURSOR</database> statement and
              opened by an <database>OPEN</database> statement</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>A <database>CLOSE</database> statement closes an open cursor. Any cursors that are
      still open will be automatically closed after the module code completes execution.
      Only a cursor that was declared with <database>DECLARE CURSOR</database>
      can be closed with a <database>CLOSE</database> statement.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;Using the CLOSE statement:
          <blockquote><programlisting>
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-declare-cursor"><database>DECLARE CURSOR</database></link>,
          <link linkend="fblangref25-psql-open"><database>OPEN</database></link>,
          <link linkend="fblangref25-psql-fetch"><database>FETCH</database></link>
        </para>
      </formalpara>
    </section> <!-- CLOSE -->

    <section id="fblangref25-psql-inauton">
      <title><database>IN AUTONOMOUS TRANSACTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Executing a statement or a block of statements in an
        autonomous transaction</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
IN AUTONOMOUS TRANSACTION DO &lt;compound_statement&gt;
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-inauton">
      <?dbfo keep-together='auto'?>
        <title>IN AUTONOMOUS TRANSACTION Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">A statement or a block of statements</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>An <database>IN AUTONOMOUS TRANSACTION</database> statement enables execution of
      a statement or a block of statements in an autonomous transaction. Code running in an
      autonomous transaction will be committed right after its successful execution, regardless
      of the status of its parent transaction. It might be needed when certain operations must
      not be rolled back, even if an error occurs in the parent transaction.</para>
      <para>An autonomous transaction has the same isolation level as its parent transaction.
      Any exception that is thrown in the block of the autonomous transaction code will result
      in the autonomous transaction being rolled back and all made changes being cancelled.
      If the code executes successfully, the autonomous transaction will be committed.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;Using an autonomous transaction in a trigger for the database
        <database>ON CONNECT</database> event, in order to log all connection attempts,
        including those that failed:
          <blockquote><programlisting>
CREATE TRIGGER TR_CONNECT ON CONNECT
AS
BEGIN
  -- Logging all attempts to connect to the database
  IN AUTONOMOUS TRANSACTION DO
    INSERT INTO LOG(MSG)
    VALUES ('USER ' || CURRENT_USER || ' CONNECTS.');
  IF (CURRENT_USER IN (SELECT
                           USERNAME
                       FROM
                           BLOCKED_USERS)) THEN
  BEGIN
    -- Logging that the attempt to connect
    -- to the database failed and sending
    -- a message about the event
    IN AUTONOMOUS TRANSACTION DO
    BEGIN
      INSERT INTO LOG(MSG)
      VALUES ('USER ' || CURRENT_USER || ' REFUSED.');
      POST_EVENT 'CONNECTION ATTEMPT' || ' BY BLOCKED USER!';
    END
    -- now calling an exception
    EXCEPTION EX_BADUSER;
  END
END
          </programlisting></blockquote>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-transacs"><database>Transsaction Control</database></link>
        </para>
      </formalpara>
    </section><!-- in autonomous transaction -->

    <section id="fblangref25-psql-postevent">
      <title><database>POST_EVENT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Notifying listening clients about database events in a module</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
POST_EVENT event_name;
        </programlisting></blockquote>
      </formalpara>
      <table id="fblangref25-psql-tbl-postevent">
      <?dbfo keep-together='auto'?>
        <title>POST_EVENT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">event_name</entry>
              <entry align="left">Event name (message) limited to 64 characters</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>POST_EVENT</database> statement notifies the event manager about
      the event, which saves it to an event table. When the transaction is committed, the
      event manager notifies applications that are signalling their interest in the event.</para>
      <para>The event name can be some sort of code or a short message:  the choice is open
      as it is just a string up to 64 characters.

      <comment>Editor's note :: Please check
      whether this really means 64 characters or 64 bytes.</comment>

      </para>
      <para>The content of the string can be a string literal, a variable or any valid
      SQL expression that resolves to a string.</para>
      <formalpara>
        <title>Example</title>
        <para>&nbsp;Notifying the listening applications about inserting a record into the
        SALES table:
          <blockquote><programlisting>
SET TERM ^;
CREATE TRIGGER POST_NEW_ORDER FOR SALES
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
  POST_EVENT 'new_order';
END^
SET TERM ;^
          </programlisting></blockquote>
        </para>
      </formalpara>
    </section> <!-- post_event -->

  </section> <!-- body code -->

  <section id="fblangref25-psql-handleexceptions">
    <title>Statements for Handling Errors</title>
    <para>Firebird has a useful lexicon of PSQL statements and resources for handling errors and
    exceptions in modules.  Internally-implemented exceptions exist for stalling execution when
    every sort of standard error occurs in DDL, DML and the physical environment.  A full listing
    of them can be found in
    <link linkend="fblangref25-appx02-errorcodes"><citetitle>Appendix B: Exception Handling,
    Codes and Messages</citetitle></link>,
    in the sections starting at
    <link linkend="fblangref25-appx02-tbl-errcodes01"><citetitle>SQLCODE and GDSCODE Error Codes
    and Message Texts (1)</citetitle></link>.  There are more than 700 of them&mdash;hence the
    need to split them into four sections for practical purposes.</para>
    <para>In the same Appendix are the DDL instructions for creating custom exceptions that are 
    specific to your own applications, along with tips about using them.  See 
    <link linkend="fblangref25-appx02-createexcept"><database>CREATE EXCEPTION</database></link>.
    </para>
    <para>Also in that Appendix is a detailed description and discussion of the different types 
    of exception that can be handled in PSQL&mdash;see <link 
    linkend="fblangref25-appx02-exceptypes">Exception Types</link>&mdash;including the newer,
    SQL-standard <database>SQLSTATE</database> type that Firebird began to support in version 2.5.
    The list of <database>SQLSTATE</database> codes and message can be found in
    <link linkend="fblangref25-appx02-tbl-sqlstates"><citetitle>>SQLSTATE Codes and 
    Message Texts</citetitle></link>.</para>
    <para>Custom exceptions are stored in the system table
    <ulink linkend="fblangref-appx04-exceptions"><database>RDB$EXCEPTIONS</database></ulink>.
    </para>

    <section id="fblangref25-psql-exception">
      <title><database>EXCEPTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Throwing a user-defined exception or re-throwing an exception</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
EXCEPTION [exception_name [custom_message]]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-exception">
      <?dbfo keep-together='auto'?>
        <title>EXCEPTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name</entry>
            </row>
            <row valign="middle">
              <entry align="center">custom_message</entry>
              <entry align="left">Alternative message text to be returned to the caller interface
              when an exception is thrown. Maximum length of the text message is 1,021 bytes</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>An <database>EXCEPTION</database> statement throws the user-defined exception with the
      specified name. An alternative message text of up to 1,021 bytes can optionally replace the
      message text defined when the exception was created.</para>
      <para>The exception can be handled in the statement, by just leaving it with no specific
      <database>WHEN ... DO</database> handler and allowing the trigger or stored procedure to terminate and
      roll back all operations.  The calling application application gets the alternative message text, if
      any was specified;  otherwise, it receives the message originally defined for that exception.</para>
      <para>Within the exception-handling block&mdash;and only within it&mdash;the caught exception can
      be re-thrown by executing the <database>EXCEPTION</database> statement without parameters. If located
      outside the block, the re-thrown <database>EXCEPTION</database> call has no effect.</para>
      <formalpara>
        <title>Examples</title>
        <orderedlist>
          <listitem>Throwing an exception upon a condition in the SHIP_ORDER stored procedure:
            <blockquote><programlisting>
CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
DECLARE VARIABLE ord_stat  CHAR(7);
DECLARE VARIABLE hold_stat CHAR(1);
DECLARE VARIABLE cust_no   INTEGER;
DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
      s.order_status,
      c.on_hold,
      c.cust_no
  FROM
      sales s, customer c
  WHERE
      po_number = :po_num AND
      s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped;
  /* Other statements */
END
            </programlisting></blockquote>
          </listitem>
          <listitem>Throwing an exception upon a condition and replacing the
          original message with an alternative message:
            <blockquote><programlisting>
CREATE OR ALTER PROCEDURE SHIP_ORDER (
    PO_NUM CHAR(8))
AS
DECLARE VARIABLE ord_stat  CHAR(7);
DECLARE VARIABLE hold_stat CHAR(1);
DECLARE VARIABLE cust_no   INTEGER;
DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
      s.order_status,
      c.on_hold,
      c.cust_no
  FROM
      sales s, customer c
  WHERE
      po_number = :po_num AND
      s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped
      'Order status is "' || ord_stat || '"';
  /* Other statements */
END
            </programlisting></blockquote>
          </listitem>
          <listitem>Logging an error and re-throwing it in the WHEN block:
            <blockquote><programlisting>
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
        -- write an error in log
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              GDSCODE,
              SQLCODE,
              SQLSTATE);
    -- Re-throw exception
    EXCEPTION;
  END
END
            </programlisting></blockquote>
          </listitem>
        </orderedlist>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-appx02-createexcept"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-psql-when"><database>WHEN ... DO</database></link>
        </para>
      </formalpara>
    </section><!-- EXCEPTION -->

    <section id="fblangref25-psql-when">
      <title><database>WHEN ... DO</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Catching an exception and handling the error</para>
      </formalpara>
      <formalpara><title>Available in</title>
        <para>&nbsp;PSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
WHEN {&lt;error&gt; [, &lt;error&gt; &hellip;] | ANY}
DO &lt;compound_statement&gt;

&lt;error&gt; ::= {
    EXCEPTION exception_name
  | SQLCODE number
  | GDSCODE errcode
}
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-psql-tbl-when">
      <?dbfo keep-together='auto'?>
        <title>WHEN ... DO Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Argument</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">exception_name</entry>
              <entry align="left">Exception name</entry>
            </row>
            <row valign="middle">
              <entry align="center">number</entry>
              <entry align="left">SQLCODE error code</entry>
            </row>
            <row valign="middle">
              <entry align="center">errcode</entry>
              <entry align="left">Symbolic GDSCODE error name</entry>
            </row>
            <row valign="middle">
              <entry align="center">compound_statement</entry>
              <entry align="left">A statement or a block of statements</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The <database>WHEN ... DO</database> statement is used to handle errors and user-defined
      exceptions. The statement catches all errors and user-defined exceptions listed after the
      keyword <database>WHEN</database> keyword. If <database>WHEN</database> is followed by the
      keyword <database>ANY</database>, the statement catches any error or user-defined exception,
      even if they have already been handled in a <database>WHEN</database> block located higher up.</para>
      <para>The <database>WHEN ... DO</database> block must be located at the very end of a block of
      statements, before the block's <database>END</database> statement.</para>
      <para>The keyword <database>DO</database>is followed by a statement, or a block of statements
      inside a BEGIN ... END wrapper, that handle the exception. The <database>SQLCODE, GDSCODE,
      </database> and  <database>SQLSTATE</database> context variables are available in the context
      of this statement or block. The <database>EXCEPTION</database> statement, with no parameters,
      can also be used in this context to re-throw the error or exception.</para>

      <section id="fblangref25-psql-when-gdscode">
        <title>Targeting <database>GDSCODE</database></title>
        <para>The argument for the <database>WHEN GDSCODE</database> clause is the symbolic name
        associated with the internally-defined exception, such as <function>grant_obj_notfound</function>
        for GDS error 335544551.</para>
        <para>After the <database>DO</database> clause, another <database>GDSCODE</database>
        context variable, containing the numeric code, becomes available for use in the statement
        or the block of statements that code the error handler. That numeric code is required if you
        want to compare a <database>GDSCODE</database> exception with a targeted error.</para>
      </section> <!--  Targeting GDSCODE -->

      <para>The <database>WHEN ... DO</database> statement or block is never executed unless
      one of the events targeted by its conditions occurs in run-time. If the statement is executed,
      even if it actually does nothing, execution will continue as if no error occurred: the error
      or user-defined exception neither terminates nor rolls back the operations of the trigger or
      stored procedure.</para>
      <para>However, if the <database>WHEN ... DO</database> statement or block does nothing to handle
      or resolve the error, the DML statement (<database>SELECT, INSERT, UPDATE, DELETE,
      MERGE</database>) that caused the error will be rolled back and none of the statements below it
      in the same block of statements are executed.
        <important>
          <title>Attention!</title>
          <para>If the error is not caused by one of the DML statements (<database>SELECT, INSERT,
          UPDATE, DELETE, MERGE</database>), the entire block of statements will be rolled back, not
          just the one that caused an error. Any operations in the <database>WHEN ... DO</database>
          statement will be rolled back as well. The same limitation applies to the
          <database>EXECUTE PROCEDURE</database> statement. Read an interesting discussion of the
          phenomenon in Firebird Tracker ticket
          <ulink url="http://tracker.firebirdsql.org/browse/CORE-4483">CORE-4483</ulink>.</para>
        </important>
      </para>
      <section id="fblangref25-psql-whendo-scope">
        <title>Scope of a <database>WHEN ... DO</database> Statement</title>
        <para>A <database>WHEN ... DO</database> statement catches errors and exceptions in the current
        block of statements. It also catches similar exceptions in nested blocks, if those exceptions
        have not been handled in them.</para>
        <para>All changes made before the statement that caused the error are visible to a
        <database>WHEN ... DO</database> statement. However, if you try to log them in an autonomous
        transaction, those changes are unavailable, because the transaction where the changes took place
        is not committed at the point when the autonomous transaction is started. Example 4, below,
        demonstrates this behaviour.</para>
      </section> <!-- Scope of WHEN ... Do -->

      <formalpara>
        <title>Examples using WHEN...DO</title>
        <para>
          <orderedlist>
            <listitem>Replacing the standard error with a custom one:
              <blockquote><programlisting>
CREATE EXCEPTION COUNTRY_EXIST '';
SET TERM ^;
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country, currency)
  VALUES (:ACountryName, :ACurrency);

  WHEN SQLCODE -803 DO
    EXCEPTION COUNTRY_EXIST 'Country already exists!';
END^
SET TERM ^;
              </programlisting></blockquote>
            </listitem>
            <listitem>Logging an error and re-throwing it in the <database>WHEN</database> block:
              <blockquote><programlisting>
CREATE PROCEDURE ADD_COUNTRY (
    ACountryName COUNTRYNAME,
    ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
    -- write an error in log
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              GDSCODE,
              SQLCODE,
              SQLSTATE);
    -- Re-throw exception
    EXCEPTION;
  END
END
              </programlisting></blockquote>
            </listitem>
            <listitem>Handling several errors in one <database>WHEN</database> block
              <blockquote><programlisting>
...
WHEN GDSCODE GRANT_OBJ_NOTFOUND,
	   GDSCODE GRANT_FLD_NOTFOUND,
	   GDSCODE GRANT_NOPRIV,
	   GDSCODE GRANT_NOPRIV_ON_BASE
DO
BEGIN
	EXECUTE PROCEDURE LOG_GRANT_ERROR(GDSCODE);
	EXIT;
END
...
              </programlisting></blockquote>
            </listitem>
          </orderedlist>
        </para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-psql-exception"><database>EXCEPTION</database></link>,
        <link linkend="fblangref25-appx02-createexcept"><database>CREATE EXCEPTION</database></link>,
        <link linkend="fblangref25-appx02-tbl-errcodes01">SQLCODE and GDSCODE
        Error Codes and Message Texts</link>,
        <link linkend="fblangref25-appx02-tbl-sqlstates">SQLSTATE Codes and Message Texts</link>
        and <link linkend="fblangref25-appx02-exceptypes"><database>SQLCODE, GDSCODE, SQLCODE,
        SQLSTATE</database></link>
        </para>
      </formalpara>
    </section> <!-- WHEN ... DO -->



  </section> <!-- handling errors and exceptions -->
</chapter>