<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-datatypes">
  <title>Data Types and Subtypes</title>
  <para>Data of various types are used to:
  <itemizedlist>
    <listitem>
      <para>define columns in a database table in the <database>CREATE TABLE</database> statement or
      change columns using <database>ALTER TABLE</database></para>
    </listitem>
    <listitem>
      <para>declare or change a <emphasis>domain</emphasis> using the
      <database>CREATE DOMAIN</database> or <database>ALTER DOMAIN</database> statements</para>
    </listitem>
    <listitem>
      <para>declare local variables in stored procedures, PSQL blocks and triggers and specify
      parameters in stored procedures</para>
    </listitem>
    <listitem>
      <para>indirectly specify arguments and return values when declaring external functions
      (UDFs&mdash;user-defined functions)</para>
    </listitem>
    <listitem>
      <para>provide arguments for the CAST() function when explicitly converting data from one
      type to another</para>
    </listitem>
  </itemizedlist>
  </para>

  <table id="fblangref25-dtyp-tbl-dtypinfo">
    <?dbfo keep-together='auto'?>
    <title>Overview of Data Types</title>
    <tgroup cols="4">
      <colspec colname="colName" colwidth="1*"></colspec>
      <colspec colname="colSize" colwidth="1*"></colspec>
      <colspec colname="colPrecision" colwidth="1*"></colspec>
      <colspec colname="colDesc" colwidth="2*"></colspec>
      <thead>
        <row valign="middle">
          <entry align="center">Name</entry>
          <entry align="center">Size</entry>
          <entry align="center">Precision &amp; Limits</entry>
          <entry align="center">Description</entry>
        </row>
      </thead>
      <tbody>
          <row valign="top">
            <entry>BIGINT</entry>
            <entry>64 bits</entry>
            <entry>From -2<superscript>63</superscript> to (2<superscript>63</superscript> - 1)</entry>
            <entry>The data type is available in Dialect 3 only</entry>
          </row>

          <row valign="top">
            <entry>BLOB</entry>
            <entry>Varying</entry>
            <entry>The size of a BLOB segment is limited to 64K. The maximum size
            of a BLOB field is 4 GB</entry>
            <entry>A data type of a dynamically variable size for storing large
            amounts of data, such as images, text, digital sounds. The basic
            structural unit is a segment. The Blob subtype defines its content</entry>
          </row>

          <row valign="top">
            <entry>CHAR(n), CHARACTER(n)</entry>
            <entry>n characters. Size in bytes depends on the encoding, the number of bytes in a character</entry>
            <entry>from 1 to 32,767 bytes</entry>
            <entry>A fixed-length character data type. When its data is displayed, trailing spaces are added to
            the string up to the specified length. Trailing spaces are not stored in the database but are
            restored to match the defined length when the column is displayed on the client side. Network traffic
            is reduced by not sending spaces over the LAN. If the number of characters is not specified, 1
            is used by default.</entry>
          </row>

          <row valign="top">
            <entry>DATE</entry>
            <entry>32 bits</entry>
            <entry>From 01.01.0001 AD to 31.12.9999 AD</entry>
            <entry>ISC_DATE.  Date only, no time element</entry>
          </row>

          <row valign="top">
            <entry>DECIMAL (<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)</entry>
            <entry>Varying (16, 32 or 64 bits)</entry>
            <entry><replaceable>precision</replaceable> = from 1 to 18, defines the least
            possible number of digits to store; <replaceable>scale</replaceable> = from 0 to 18,
            defines the number of digits after the decimal point</entry>
            <entry><replaceable>scale</replaceable> must be less than or equal
            to <replaceable>precision</replaceable>. A number with a decimal point that
            has <replaceable>scale</replaceable> digits after the point. Example: DECIMAL(10,3) contains
            a number in exactly the following format: ppppppp.sss</entry>
          </row>

          <row valign="top">
            <entry>DOUBLE PRECISION</entry>
            <entry>64 bits</entry>
            <entry>2.225 * 10<superscript>-308</superscript> to 1.797 * 10<superscript>308</superscript></entry>
            <entry>Double-precision IEEE, ~15 digits, reliable size depends on the platform</entry>
          </row>

          <row valign="top">
            <entry>FLOAT</entry>
            <entry>32 bits</entry>
            <entry>1.175 * 10<superscript>-38</superscript> to 3.402 * 10<superscript>38</superscript></entry>
            <entry>Single-precision IEEE, ~7 digits</entry>
          </row>

          <row valign="top">
            <entry>INTEGER, INT</entry>
            <entry>32 bits</entry>
            <entry>-2,147,483,648 up to 2,147,483,647</entry>
            <entry>Signed long</entry>
          </row>

          <row valign="top">
            <entry>NUMERIC (<replaceable>precision</replaceable>, <replaceable>scale</replaceable>)</entry>
            <entry>Varying (16, 32 or 64 bits)</entry>
            <entry><replaceable>precision</replaceable> = from 1 to 18, defines the exact number of digits to
            store; <replaceable>scale</replaceable> = from 0 to 18,
            defines the number of digits after the decimal point</entry>
            <entry><replaceable>scale</replaceable> must be less than or equal
            to <replaceable>precision</replaceable>. A number with a decimal point that
            has <replaceable>scale</replaceable> digits after the point. Example: NUMERIC(10,3) contains
            a number in exactly the following format: ppppppp.sss</entry>
          </row>

          <row valign="top">
            <entry>SMALLINT</entry>
            <entry>16 bits</entry>
            <entry>-32,768 to 32,767</entry>
            <entry>Signed short (word)</entry>
          </row>

          <row valign="top">
            <entry>TIME</entry>
            <entry>32 bits</entry>
            <entry>0:00 to 23:59:59.9999</entry>
            <entry>ISC_TIME. Time of day.  It cannot be used to store an interval of time</entry>
          </row>

          <row valign="top">
            <entry>TIMESTAMP</entry>
            <entry>64 bits (2 X 32 bits)</entry>
            <entry>From start of day 01.01.0001 AD to end of day 31.12.9999 AD</entry>
            <entry>Date and time of day</entry>
          </row>

          <row valign="top">
            <entry>VARCHAR(n), CHAR VARYING, CHARACTER VARYING</entry>
            <entry>n characters. Size in bytes depends on the encoding, the number of bytes in a character</entry>
            <entry>from 1 to 32,765 bytes</entry>
            <entry>Variable length string type. The total size of characters in bytes cannot be larger than (32KB-2),
            taking into account their encoding. Two remaining two bytes store the declared length. There is no default size: the
            <replaceable>n</replaceable> argument is mandatory. Leading and trailing spaces are stored and they are not trimmed,
            except for those trailing characters that are past the declared length.</entry>
          </row>
      </tbody>
    </tgroup>
  </table>

  <remark><para>Editor's note:  The Descriptions for CHAR and VARCHAR are suspect, I think.</para></remark>
  <note>
    <title>Note About Dates</title>
    <para>Bear in mind that a time series consisting of dates in past centuries is processed
    without taking into account the actual historical facts, as though the Gregorian calendar
    were applicable throughout the entire series.</para>
  </note>

  <section id="fblangref25-datatypes-inttypes">
    <title><database>Integer Data Types</database></title>
    <para>The SMALLINT, INTEGER and BIGINT data types are used for integers of various precision in Dialect 3.
    Firebird does not support an unsigned integer data type.</para>
    <section id="fblangref25-datatypes-smallint">
      <title><database>SMALLINT</database></title>
      <para>The SMALLINT data type is for compact data storage of integer data for which only a narrow
      range of possible values is required for storing them.  Numbers of the <database>SMALLINT</database>
      type are within the range from -2<superscript>16</superscript> to 2<superscript>16</superscript> - 1,
      that is, from -32,768 to 32,767.</para>
      <formalpara>
        <title>SMALLINT Examples</title>
        <programlisting>
      CREATE DOMAIN DFLAG AS SMALLINT DEFAULT 0 NOT NULL
        CHECK (VALUE=-1 OR VALUE=0 OR VALUE=1);

      CREATE DOMAIN RGB_VALUE AS SMALLINT;
        </programlisting>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-int">
      <title><database>INTEGER</database></title>
      <para>The INTEGER data type is a 4-byte integer.  The shorthand name of the data type is INT.
      Numbers of the <database>INTEGER</database>
      type are within the range from -2<superscript>32</superscript> to 2<superscript>32</superscript> - 1,
      that is, from -2,147,483,648 to 2,147,483,647.</para>
      <formalpara>
        <title>INTEGER Examples</title>
        <programlisting>
       Examples to come
        </programlisting>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-bigint">
      <title><database>BIGINT</database></title>
      <para><database>BIGINT</database> is an SQL:99-compliant 64-bit integer data type, available
      only in Dialect 3. If a client uses Dialect 1, the generator value sent by the server is reduced
      to a 32-bit integer (INTEGER). When Dialect 3 is used for connection, the generator value is of
      type BIGINT.</para>
      <para>Numbers of the BIGINT type are within the range from -2<superscript>63</superscript>
      to 2<superscript>63</superscript> - 1, or from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</para>
      <formalpara>
        <title>Hexadecimal Format for BIGINT Numbers</title>
        <para>Starting from Firebird 2.5, numbers of the BIGINT type can be specified in hexadecimal format
        by means of 9 to 16 hexadecimal digits. Shorter hexadecimal numbers are interpreted as the
        INTEGER data type.</para>
       </formalpara>
       <formalpara>
         <title>BIGINT Examples</title>
        <programlisting>
       CREATE TABLE WHOLELOTTARECORDS (
         ID BIGINT NOT NULL PRIMARY KEY,
         DESCRIPTION VARCHAR(32)
        );

       INSERT INTO MYBIGINTS VALUES (
         -236453287458723,
         328832607832,
         22,
         -56786237632476,
         0X6F55A09D42, -- 478177959234
         0X7FFFFFFFFFFFFFFF, -- 9223372036854775807
         0XFFFFFFFFFFFFFFFF, -- -1
         0X80000000, -- -2147483648, ?.?. INTEGER
         0X080000000, -- 2147483648, ?.?. BIGINT
         0XFFFFFFFF, -- -1, ?.?. INTEGER
         0X0FFFFFFFF -- 4294967295, ?.?. BIGINT
        );
        </programlisting>
        <para>The hexadecimal INTEGER is automatically cast to the BIGINT type before being
        inserted into the table. However, because it happens after the numeric value is
        determined, 0x80000000 (8 digits) and 0x080000000 (9 digits) will be saved in different
        formats. The value 0x80000000 (8 digits) will be saved in the INTEGER format,
        while 0x080000000 (9 digits) will be saved as BIGINT.</para>
      </formalpara>
    </section>

  </section><!-- Integer Data Types -->

  <section id="fblangref25-datatypes-floattypes">
    <title><database>Floating-Point Data Types</database></title>
    <para>Floating-point data types are examples of data stored in the DBMS with the precision matching the
    scale of the number. <database>FLOAT</database> and <database>DOUBLE PRECISION</database> (DOUBLE)
    are examples.</para>
    <para>Considering the peculiarities of storing floating-point numbers in a database, these data types
    are not recommended for storing monetary data. For the same reasons, columns with floating-point data
    are not recommended for use as keys or to have uniqueness constraints applied to them.</para>
    <para>For testing data in columns with floating-point data types, expressions should check using a
    range, for instance, BETWEEN, rather than searching for exact matches.</para>
    <para>When using these data types in expressions, extreme care is advised regarding the rounding of
    evaluation results.</para>

    <section id="fblangref25-datatypes-float">
      <title><database>FLOAT</database></title>
      <para>This data type has an approximate precision of 7 digits after the decimal point.
      To ensure the safety of storage, rely on 6 digits.</para>
    </section>
    <section id="fblangref25-datatypes-double">
      <title><database>DOUBLE PRECISION</database></title>
      <para>This data type is stored with an approximate precision of
      15 digits.</para>
    </section>
  </section><!-- Floating Point Data Types -->

  <section id="fblangref25-datatypes-fixedtypes">
    <title><database>Fixed-Point Data Types</database></title>
    <para>Fixed-point data types ensure the predictability of multiplication and division operations,
    making them the choice for storing monetary values.  Firebird implements two fixed-point data types:
    <database>NUMERIC</database> and <database>DECIMAL</database>. According to the standard, both types
    limit the stored number to the declared scale (the number of digits after the decimal point).</para>
    <para>Different treatments limit precision for each type: precision for NUMERIC columns
    is exactly <quote>as declared</quote>, while DECIMAL columns accepts numbers whose precision is at least
    equal to what was declared.</para>
    <para>For instance, NUMERIC(4, 2) defines a number consisting altogether of four digits, including
    two digits after the decimal point; that is, it can have up to two digits before the point and no more
    than two digits after the point. If the number 3.1415 is written to a column with this data type
    definition, the value of 3.14 will be saved in the NUMERIC(4, 2) column.</para>
    <para>The form of declaration for fixed-point data, for instance,
    NUMERIC(<replaceable>p</replaceable>, <replaceable>s</replaceable>), is common to both types. It is
    important to realise that the <replaceable>s</replaceable> argument in this template is <command>scale</command>,
    rather than <quote>a count of digits after the decimal point</quote>. Understanding the mechanism
    for storing and retrieving fixed-point data should help to visualise why: for storage, the number
    is multiplied by 10<superscript>s</superscript> (10 to the power of <replaceable>s</replaceable>),
    converting it to an integer;  when read, the integer is converted back.</para>

    <para>The method of storing fixed-point data in the DBMS depends on several factors: declared
    precision, database dialect, declaration type.</para>

    <table id="fblangref25-dtyp-tbl-realnums">
      <title>Method of Physical Storage for Real Numbers</title>
      <tgroup cols="4">
        <colspec colname="colScale" colwidth="2*"></colspec>
        <colspec colname="colType" colwidth="3*"></colspec>
        <colspec colname="colDial01" colwidth="3*"></colspec>
        <colspec colname="colDial03" colwidth="3*"></colspec>
        <thead>
          <row valign="middle">
            <entry align="center">Scale</entry>
            <entry align="center">Data type</entry>
            <entry align="center">Dialect 1</entry>
            <entry align="center">Dialect 3</entry>
          </row>
        </thead>
        <tbody>
          <row valign="middle">
            <entry>1 - 4</entry>
            <entry>NUMERIC</entry>
            <entry>SMALLINT</entry>
            <entry>SMALLINT</entry>
          </row>
          <row valign="middle">
            <entry>1 - 4</entry>
            <entry>DECIMAL</entry>
            <entry>INTEGER</entry>
            <entry>INTEGER</entry>
          </row>
          <row valign="middle">
            <entry>5 - 9</entry>
            <entry>NUMERIC OR DECIMAL</entry>
            <entry>INTEGER</entry>
            <entry>INTEGER</entry>
          </row>
          <row valign="middle">
            <entry>10 - 18</entry>
            <entry>NUMERIC OR DECIMAL</entry>
            <entry>DOUBLE PRECISION</entry>
            <entry>BIGINT</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="fblangref25-datatypes-numeric">
      <title><database>NUMERIC</database></title>
      <formalpara>
        <title>Data Declaration Format</title>
        <literallayout class="monospaced">
       NUMERIC(<replaceable>p</replaceable>, <replaceable>s</replaceable>)
        </literallayout>
      </formalpara>
      <formalpara>
        <title>Storage Examples</title>
        <para>Further to the explanation above, the DBMS will store NUMERIC data
        according the declared precision (<replaceable>p</replaceable>) and
        scale (<replaceable>s</replaceable>).  Some more examples are:</para>
        <literallayout class="monospaced">
       NUMERIC(4) stored as      SMALLINT (exact data)
       NUMERIC(4,2)              SMALLINT (data * 10<superscript>2</superscript>)
       NUMERIC(10,4) (Dialect 1) DOUBLE PRECISION
                     (Dialect 3) BIGINT (data * 10<superscript>4</superscript>)
        </literallayout>
      </formalpara>
      <caution>
        <para>Always keep in mind that the storage format depends on the precision.
        For instance, you define the column type as NUMERIC(2,2) presuming that its
        range of values will be -0.99...0.99. However, the actual range of
        values for the column will be -327.68..327.68, which is due to storing the
        NUMERIC(2,2) data type in the SMALLINT format. In storage, the NUMERIC(4,2),
        NUMERIC(3,2) and NUMERIC(2,2) data types are the same, in fact.  It means
        that if you really want to store data in a column with
        the NUMERIC(2,2) data type and limit the range to -0.99...0.99, you will have
        to create a constraint for it.</para>
      </caution>
    </section>
    <section id="fblangref25-datatypes-decimal">
      <title><database>DECIMAL</database></title>
      <formalpara>
        <title>Data Declaration Format</title>
        <literallayout class="monospaced">
       DECIMAL(<replaceable>p</replaceable>, <replaceable>s</replaceable>)
        </literallayout>
      </formalpara>
      <formalpara>
        <title>Storage Examples</title>
        <para>The storage format in the database for DECIMAL is very similar to NUMERIC,
        with some differences that are easier to observe with the help of some more examples:</para>
        <literallayout class="monospaced">
       DECIMAL(4) stored as      INTEGER (exact data)
       DECIMAL(4,2)              INTEGER (data * 10<superscript>2</superscript>)
       DECIMAL(10,4) (Dialect 1) DOUBLE PRECISION
                     (Dialect 3) BIGINT (data * 10<superscript>4</superscript>)
        </literallayout>
      </formalpara>
    </section>
  </section><!-- Fixed Point Data Types -->

  <section id="fblangref25-datatypes-datetime">
    <title>Data Types for Dates and Times</title>
    <para>The <database>DATE</database>, <database>TIME</database> and <database>TIMESTAMP</database>
    data types are used to work with data containing dates and times.
    Dialect 3 supports all the three types, while Dialect 1 has only <database>DATE</database>. The
    <database>DATE</database> type in Dialect 3 is <quote>date-only</quote>, whereas the Dialect 1
    <database>DATE</database> type stores both date and time-of-day, equivalent
    to <database>TIMESTAMP</database> in Dialect 3.  Dialect 1 has no <quote>date-only</quote> type.</para>
    <note>
      <para>Dialect 1 <database>DATE</database> data can be defined alternatively
      as <database>TIMESTAMP</database> and this is recommended for new definitions in Dialect 1
      databases.</para>
    </note>
    <formalpara>
      <title>Fractions of Seconds</title>
      <para>If fractions of seconds are stored in date and time data types, Firebird stores them by default to
      ten-thousandths of a second.  If a lower granularity is preferred, the fraction can be specified
      explicitly as thousandths, hundredths or tenths of a second in Dialect 3 databases of ODS 11 or
      higher.</para>
    </formalpara>

    <section id="fblangref25-datatypes-date">
      <title><database>DATE</database></title>
      <para>The <database>DATE</database> data type in Dialect 3 stores only date without time.
      The available range for storing data is from January 01, 1 to December 31, 9999.</para>
      <para>Dialect 1 has no <quote>date-only</quote> type.
      <tip>
        <para>If you need to store Dialect 1 date values with no time, append
        a <quote>zero time-part</quote>&mdash;'00:00:00.0000'&mdash; to the date part literal for
        writing to the table.</para>
      </tip></para>
    </section>

    <section id="fblangref25-datatypes-time">
      <title><database>TIME</database></title>
      <para>The <database>TIME</database> data type is available in Dialect 3 only. It stores the time
      of day within the range from 00:00:00.0000 to 23:59:59.9999.</para>
      <para>If you need to get the time-part from <database>DATE</database> in Dialect 1, you can
      use the <database>EXTRACT</database> function.</para>
      <formalpara>
        <title>Examples Using <database>EXTRACT</database></title>
        <programlisting>
       EXTRACT (HOUR FROM DATE_FIELD)
       EXTRACT (MINUTE FROM DATE_FIELD)
       EXTRACT (SECOND FROM DATE_FIELD)
        </programlisting>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-timestamp">
      <title><database>TIMESTAMP</database></title>
      <para>The <database>TIMESTAMP</database> data type is available in Dialect 3 and Dialect 1.
      It comprises two 32-bit words&mdash;a date-part and a time-part&mdash;to form a structure that
      stores both date and time-of-day. It is the same as the DATE type in Dialect 1.</para>
      <para>The <database>EXTRACT</database> function works equally well with <database>TIMESTAMP</database>
      as with the Dialect 1 <database>DATE</database> type.</para>
    </section>

    <section id="fblangref25-datatypes-datetimeops">
      <title>Operations Using Date and Time Values</title>
      <para>The method of storing date and time values makes it possible to involve them as
      operands in some arithmetic operations. In storage, a date value or date-part of a timestamp
      is represented as the number of days elapsed since <quote>date
      zero</quote>&mdash;November 17, 1898&mdash;whilst a time value or the time-part of a timestamp
      is represented as the number of seconds (with fractions of seconds taken into account) since midnight.</para>
      <para>An example is to subtract an earlier date, time or timestamp from a later one,
      resulting in an interval of time, in days and fractions of days.</para>

      <table id="fblangref25-dtyp-tbl-dateops">
      <?dbfo keep-together='auto'?>
        <title>Arithmetic Operations for Date and Time Data Types</title>
        <tgroup cols="4">
          <colspec colname="colOp01" colwidth="1*"></colspec>
          <colspec colname="colOp" colwidth="1*"></colspec>
          <colspec colname="colOp02" colwidth="*1"></colspec>
          <colspec colname="colResult" colwidth="2*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Operand 1</entry>
              <entry align="center">Operation</entry>
              <entry align="center">Operand 2</entry>
              <entry align="center">Result</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">+</entry>
              <entry>TIME</entry>
              <entry>TIMESTAMP</entry>
            </row>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">+</entry>
              <entry>Numeric value <replaceable>n</replaceable></entry>
              <entry>DATE increased by n <replaceable>n</replaceable>whole days. The fractional part is ignored</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">+</entry>
              <entry>DATE</entry>
              <entry>TIMESTAMP</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">+</entry>
              <entry>Numeric value <replaceable>n</replaceable></entry>
              <entry>TIME increased by <replaceable>n</replaceable> seconds. The fractional part is taken into account</entry>
            </row>
            <row valign="middle">
              <entry>TIMESTAMP</entry>
              <entry align="center">+</entry>
              <entry>Numeric value <replaceable>n</replaceable></entry>
              <entry>TIMESTAMP where days are increased by the integer part of
              number <replaceable>n</replaceable> plus the fractional part of number
              <replaceable>n</replaceable> (if it is specified) as the number of
              seconds in the day (with precision of up to ten-thousandths of a second)</entry>
            </row>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">-</entry>
              <entry>DATE</entry>
              <entry>Number of days elapsed, within the range DECIMAL(9, 0)</entry>
            </row>
            <row valign="middle">
              <entry>DATE</entry>
              <entry align="center">-</entry>
              <entry>Numeric value <replaceable>n</replaceable></entry>
              <entry>DATE reduced by <replaceable>n</replaceable> whole days. The fractional part is ignored</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">-</entry>
              <entry>TIME</entry>
              <entry>Number of seconds elapsed, within the range DECIMAL(9, 4)</entry>
            </row>
            <row valign="middle">
              <entry>TIME</entry>
              <entry align="center">-</entry>
              <entry>Numeric value <replaceable>n</replaceable></entry>
              <entry>TIME reduced by <replaceable>n</replaceable> seconds. The fractional part is taken into account</entry>
            </row>
            <row valign="middle">
              <entry>TIMESTAMP</entry>
              <entry align="center">-</entry>
              <entry>TIMESTAMP</entry>
              <entry>Number of days and part-day, within the range DECIMAL(18, 9)</entry>
            </row>
            <row valign="middle">
              <entry>TIMESTAMP</entry>
              <entry align="center">-</entry>
              <entry>Numeric value <replaceable>n</replaceable> as the number of days and
              part-days, expressed as a real number which may encompass sub-seconds
              precision of up to ten-thousandths of a second</entry>
              <entry>TIMESTAMP, where the overall date- and time-parts are reduced by the number of
              seconds and sub-seconds (if specified) implicit in number <replaceable>n</replaceable>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note><title>Notes</title>
        <para>The DATE type is considered as TIMESTAMP in Dialect 1.</para>
        <para>See also: &lt;LINK MISSING&gt;</para>
      </note>
    </section>
  </section><!-- Date and Time Data Types -->

  <section id="fblangref25-datatypes-chartypes">
    <title>Character Data Types</title>
    <para>For working with character data, Firebird has the fixed-length <database>CHAR</database>
    and the variable-length <database>VARCHAR</database> data types. The maximum size of text data
    stored in these data types is 32,767 bytes for <database>CHAR</database> and 32,765 bytes
    for <database>VARCHAR</database>. The maximum number of <emphasis>characters</emphasis> that
    will fit within these limits depends on the <database>CHARACTER SET</database> being used
    and the collation sequence specified or defaulted to in the <database>COLLATE</database> clause
    for the data under consideration.</para>

    <para>If no character set is explicitly specified when defining a character object, the 
    default character set specified when the database was created will be used. If the database
    does not have a default character set defined, the field gets the character set NONE.</para>

    <!-- The following passage is specifically for readers who work with Cyrillic alphabets.

    <para>If the database contains strings with only the Russian alphabet in it, the WIN1251 encoding is
    recommended to be used. If you use it, one character occupies 1 byte, therefore the maximum size of
    text fields for this encoding will be 32,767 characters. It is not necessary to specify the collation
    sequence (COLLATE) for the standard collation operations in case WIN1251 is used.</para>

    <para>Most current development tools support Unicode. In case you need to use Western European texts
    or alphabets that are more exotic in string fields of your database, it is recommended to work with
    the UTF8 character set. In this case, you should bear in mind that one character in this set occupies
    up to 4 bytes. Therefore, the maximum size of character fields will be 32,676/4 (8,192) characters. </para>

    -->

    <section id="fblangref25-datatypes-chartypes-unicode">
      <title>Unicode</title>
      <para>Most current development tools support Unicode, implemented in Firebird with the character sets
      <database>UTF8</database> and <database>UNICODE_FSS</database>. <database>UTF8</database> comes with
      collations for many languages.  <database>UNICODE_FSS</database> is more limited and is used mainly
      by Firebird internally for storing metadata. Keep in mind that one <database>UTF8</database> character
      occupies up to 4 bytes, thus limiting the size of <database>CHAR</database> fields to
      8,192 characters (32,767/4).</para>
      <note>
        <para>The actual <quote>bytes per character</quote> value depends on the range the character belongs to.
        Non-accented Latin letters occupy 1 byte, Cyrillic letters from the WIN1251 encoding occupy 2 bytes,
        characters from other encodings may occupy up to 4 bytes.</para>
      </note>
      <para>The <database>UTF8</database> character set implemented in Firebird supports the latest version
      of the Unicode standard, thus recommending its use for international databases.</para>
    </section>

    <section id="fblangref25-datatypes-chartypes-client">
      <title>Client Character Set</title>
      <para>While working with strings, it is essential to keep the character set of the client connection
      in mind. If there is a mismatch between the character sets of the stored data and that of the client
      connection, the output results for string columns are automatically re-encoded, both when data are
      sent from the client to the server and when they are sent back from the server to the client.
      For example, if the database was created in the <database>WIN1251</database> encoding but
      <database>KOI8R</database> or <database>UTF8</database> is specified in the client's connection
      parameters, the mismatch will be transparent.</para>
    </section>

    <section id="fblangref25-datatypes-chartypes-special">
      <title>Special Character Sets</title>
      <formalpara><title>Character set <database>NONE</database></title>
        <para>The character set <database>NONE</database> is a <emphasis>special character set</emphasis>
        in Firebird. It can be characterized such that each byte is a part of a string, but the string
        is stored in the system without any clues about what constitutes any character:
        character encoding, collation, case, etc. are simply unknown. </para>

        <para>It is the responsibility of the client application to deal with the data and provide
        the means to interpret the string of bytes in some way that is meaningful to the application
        and the human user.</para>
      </formalpara>
      <formalpara><title>Character set <database>OCTETS</database></title>
        <para>Data in <database>OCTETS</database> encoding are treated as bytes that may not actually
        be interpreted as characters. <database>OCTETS</database> provides a way to store binary data, which
        could be the results of some Firebird functions. </para>
        <para>The database engine has no concept of what it is meant to do with a string of bits
        in <database>OCTETS</database>, other than just store it and retrieve it.  Again, the client
        side is responsible for validating the data, presenting them in formats that are meaningful
        to the application and its users and handling any exceptions arising from decoding and
        encoding them.</para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-chartypes-collation">
      <title>Collation Sequence</title>
      <para>Each character set has a default collation sequence (<database>COLLATE</database>) that
      specifies the collation order. Usually, it provides nothing more than ordering based on the
      numeric code of the characters and a basic mapping of upper- and lower-case characters.
      If some behaviour is needed for strings that is not provided by the default collation sequence
      and a suitable alternative collation is supported for that character set,
      a <database>COLLATE</database> <replaceable>collation</replaceable> clause can be specified
      in the column definition.</para>
      <para>A <database>COLLATE</database> <replaceable>collation</replaceable> clause can be applied
      in other contexts besides the column definition. For greater-than/less-than comparison
      operations, it can be added in the <database>WHERE</database> clause of a <database>SELECT</database>
      statement.  If output needs to be sorted in a special alphabetic sequence, or case-insensitively, and
      the appropriate collation exists, then a <database>COLLATE</database> clause can be included
      with the <database>ORDER BY</database> clause when rows are being sorted on a character field
      and with the <database>GROUP BY</database> clause in case of grouping operations.</para>

      <section id="fblangref25-datatypes-chartypes-caseinsenstv">
        <title>Case-Insensitive Searching</title>
        <para>For a case-insensitive search, the UPPER function could be used to convert both
        the search argument and the searched strings to upper-case before attempting a match:
          <literallayout class="monospaced">
         &hellip;
         where upper(name) = upper(:flt_name)
          </literallayout>
        </para>
        <para>For strings in a character set that has a case-insensitive collation available, you can
        simply apply the collation, to compare the search argument and the searched strings
        directly.  For example, using the <database>WIN1251</database> character set, the
        collation <database>PXW_CYRL</database> is case-insensitive for this purpose:
          <literallayout class="monospaced">
         &hellip;
         WHERE FIRST_NAME COLLATE PXW_CYRL &gt;= :FLT_NAME
         &hellip;
         ORDER BY NAME COLLATE PXW_CYRL
          </literallayout>
        </para>
        <formalpara><title>See also</title>
          <para>CONTAINING</para>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-chartypes-utf8collations">
        <title><database>UTF8</database> Collation Sequences</title>
        <para>The following table shows the possible collation sequences for the
        <database>UTF8</database> character set.</para>
        <table id="fblangref25-dtyp-tbl-utfcollats">
          <title>Collation Sequences for Character Set UTF8</title>
          <tgroup cols="2">
          <colspec colname="colColl" colwidth="1*"></colspec>
          <colspec colname="colDesc" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Collation</entry>
                <entry align="center">Characteristics</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center"><database>UCS_BASIC</database></entry>
                <entry>Collation works according to the position of the character in
                the table (binary). Added in Firebird 2.0</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UNICODE</database></entry>
                <entry>Collation works according to the UCA algorithm (Unicode Collation
                Algorithm) (alphabetical). Added in
                Firebird 2.0</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UTF-8</database></entry>
                <entry>Case-insensitive collation, works without taking character case
                into account.  Added in Firebird 2.1</entry>
              </row>
              <row valign="middle">
                <entry align="center"><database>UNICODE_CI_AI</database></entry>
                <entry>Case-insensitive, accent-insensitive collation, works alphabetically
                without taking character case or accents into account. Added in
                Firebird 2.5</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <formalpara><title>Example</title>
          <para>An example of collation for the UTF8 character set without taking into account
        the case or accentuation of characters (similar to <database>COLLATE PXW_CYRL</database>).
            <programlisting>
       ...
       ORDER BY NAME COLLATE UNICODE_CI_AI
            </programlisting>
          </para>
        </formalpara>
      </section>

    </section>

    <section id="fblangref25-datatypes-chartypes-charindxs">
      <title>Character Indexes</title>
      <para>In Firebird earlier than version 2.0, a problem can occur with building an index for
      character columns that use a non-standard collation sequence: the length of an indexed field
      is limited to 252 bytes with no <database>COLLATE</database> specified or 84 bytes
      if <database>COLLATE</database> is specified.  Multi-byte character sets and compound indexes
      consume more bytes from this figure.</para>
      <para>Starting from Firebird 2.0, the maximum length for an index equals one quarter of the
      page size, i.e. from 1,024 to 4,096 bytes. The maximum length of an indexed string is 9 bytes
      less than that quarter-page limit.</para>

      <formalpara>
        <title>Calculating Maximum Length of an Indexed String Field</title>
        <para>The following formula calculates the maximum length of an indexed string (in
        characters):
        <programlisting>
       max_char_length = FLOOR((page_size / 4 - 9) / N)
        </programlisting>
         where N is the number of bytes per character in the character set.
        </para>
      </formalpara>
      <para>The table below shows the maximum length of an indexed string (in characters), according
      to page size and character set, calculated using this formula.</para>

      <table id="fblangref25-dtyp-tbl-charindxsz">
        <title>Maximum Index Lengths by Page Size and Character Size</title>
        <tgroup cols="6">
          <colspec colname="colPgsz" colwidth="1*"></colspec>
          <colspec colname="col1B" colwidth="1*"></colspec>
          <colspec colname="col2B" colwidth="1*"></colspec>
          <colspec colname="col3B" colwidth="1*"></colspec>
          <colspec colname="col4B" colwidth="1*"></colspec>
          <colspec colname="col6B" colwidth="1*"></colspec>
          <spanspec spanname="span5" nameend="col6B" namest="col1B"/>
          <thead>
            <row valign="middle">
              <entry align="center" morerows="1">Page Size</entry>
              <entry align="center" nameend="col6B" namest="col1B">Maximum length
              of an indexed string for a character set, bytes/character</entry>
            </row>
            <row>
              <entry align="center">1</entry>
              <entry align="center">2</entry>
              <entry align="center">3</entry>
              <entry align="center">4</entry>
              <entry align="center">6</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">4,096</entry>
              <entry align="center">1,015</entry>
              <entry align="center">507</entry>
              <entry align="center">338</entry>
              <entry align="center">253</entry>
              <entry align="center">169</entry>
            </row>
            <row valign="middle">
              <entry align="center">8,192</entry>
              <entry align="center">2,039</entry>
              <entry align="center">1,019</entry>
              <entry align="center">679</entry>
              <entry align="center">509</entry>
              <entry align="center">339</entry>
            </row>
            <row valign="middle">
              <entry align="center">16,384</entry>
              <entry align="center">4,087</entry>
              <entry align="center">2,043</entry>
              <entry align="center">1,362</entry>
              <entry align="center">1,021</entry>
              <entry align="center">682</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note>
        <para>In case-insensitive encodings (<quote>_CI</quote>), one character in the <command>index</command>
        will occupy not 4, but 6 (six) bytes, so the maximum key length for a page of, for example, 4,096
        bytes, will be 169 characters.</para>
      </note>
      <formalpara><title>See also</title>
        <para><database>CREATE DATABASE</database>, <database>COLLATION</database>,
        <database>CREATE INDEX</database>, <emphasis>others, lost references...</emphasis></para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-chartypes-detail">
      <title>Character Types in Detail</title>
      <section id="fblangref25-datatypes-chartypes-char">
        <title><database>CHAR</database></title>
        <para><database>CHAR</database> is a fixed-length data type. If the entered number of
        characters is less than the declared length, trailing spaces will be added to the field.
        Generally, the pad character does not have to be a space: it depends on the character
        set,  For example, the pad character for the <database>OCTETS</database> character set
        is zero.</para>
        <para>The full name of this data type is <database>CHARACTER</database>, but 
        there is no requirement to use full names and people rarely do so.</para>
        <para>Fixed-length character data can be used to store codes whose length is standard
        and has a definite <quote>width</quote> in directories. An example of such a code
        is an EAN13 barcode&mdash;13 characters, all filled.</para>
        <formalpara>
          <title>Declaration Syntax</title>
          <programlisting>
       CHAR [(<replaceable>length</replaceable>)] [CHARACTER SET &lt;set&gt;] [COLLATE &lt;name&gt;]
          </programlisting>
          <note>
            <para>If no <replaceable>length</replaceable> is specified, it is taken to be 1.</para>
            <para>A valid <replaceable>length</replaceable> is from 1 to the maximum number of
            characters that can be accommodated within 32,767 bytes.</para>
          </note>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-chartypes-varchar">
        <title><database>VARCHAR</database></title>
        <para><database>VARCHAR</database> is the basic string type for storing texts of variable 
        length, up to a maximum of 32,765 bytes.  The stored structure is equal to the actual size 
        of the data plus 2 bytes where the length of the data is recorded.</para>
        <para>All characters that are sent from the client application to the database are 
        considered meaningful, including the leading and trailing spaces.  However, trailing
        spaces are not stored:  they will be restored upon retrieval, up to the recorded length
        of the string.</para>
        <para>The full name of this type is <database>CHARACTER VARYING</database>. Another 
        variant of the name is written as <database>CHAR VARYING</database>.</para>
        <formalpara>
          <title>Syntax</title>
          <programlisting>
       VARCHAR (<replaceable>length</replaceable>) [CHARACTER SET &lt;set&gt;] [COLLATE &lt;name&gt;]
          </programlisting>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-chartypes-nchar">
        <title><database>NCHAR</database></title>
        <para><database>NCHAR</database> is a fixed-length character data type with the
        <database>ISO8859_1</database> character set predefined.  In all other respects
        it is the same as <database>CHAR</database>.</para>
        <formalpara>
          <title>Syntax</title>
          <programlisting>
       NCHAR (<replaceable>length</replaceable>)
          </programlisting>
          <para>The synonymous name is <database>NATIONAL CHAR</database>.  A similar data 
          type is available for the variable-length string type: <database>NATIONAL 
          CHARACTER VARYING</database>.</para>
        </formalpara>
      </section>
    </section>
  </section><!-- Character data types -->

  <section id="fblangref25-datatypes-bnrytypes">
    <title>Binary Data Types</title>
    <para><database>BLOB</database>s (Binary Large Objects) are complex structures used to
    store text and binary data of an undefined length, often very large.</para>
    <formalpara>
      <title>Syntax</title>
      <programlisting>
     BLOB [SUB_TYPE &lt;subtype&gt;]
         [SEGMENT SIZE &lt;segment size&gt;]
         [CHARACTER SET &lt;character set&gt;]
      </programlisting>
    </formalpara>
    <formalpara>
      <title>Shortened syntax</title>
      <programlisting>
     BLOB (&lt;segment size&gt;)
     BLOB (&lt;segment size&gt;, &lt;subtype&gt;)
     BLOB (, &lt;subtype&gt;)
      </programlisting>
    </formalpara>
    <formalpara>
      <title>Segment Size</title>
      <para>Specifying the BLOB segment is throwback to times past, when applications for
      working with BLOB data were written in C (Embedded SQL) with the help of
      the <emphasis>gpre</emphasis> pre-compiler. Nowadays, it is effectively irrelevant.
      The segment size for BLOB data is determined by the client side and is usually
      larger than the data page size, in any case.</para>
    </formalpara>

    <section id="fblangref25-datatypes-bnrytypes-sub">
      <title>BLOB Subtypes</title>
      <para>The optional <database>SUB_TYPE</database> parameter specifies
      the nature of data written to the column.  Firebird provides two
      pre-defined subtypes for storing user data:</para>
      <formalpara>
        <title>Subtype 0: <database>BINARY</database></title>
        <para>If a subtype is not specified, the specification is assumed to be
        for untyped data and the default <database>SUB_TYPE 0</database> is
        applied. The alias for subtype zero is BINARY.  This is the subtype
        to specify when the data are any form of binary file or stream: images,
        audio, word-processor files, PDFs and so on.</para>.
      </formalpara>
      <formalpara>
        <title>Subtype 1: <database>TEXT</database></title>
        <para>Subtype 1 has an alias, <database>TEXT</database>, which can be used in declarations
        and definitions. For instance, &nbsp;<function>BLOB SUB_TYPE TEXT</function>.&nbsp; It is
        a specialized subtype used to store plain text data that is too large to fit into a string
        type. A <database>CHARACTER SET</database> may be specified, if the field is to store text
        with a different encoding to that specified for the database. From Firebird 2.0, a
        <database>COLLATE</database> clause is also supported.</para>
      </formalpara>
      <formalpara>
        <title>Custom Subtypes</title>
        <para>It is also possible to add custom data subtypes, for which the range of enumeration
        from -1 to -32,768 is reserved.  Custom subtypes enumerated with positive numbers are not
        allowed, as the Firebird engine uses the numbers from 2-upward for some internal subtypes
        in metadata.</para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-bnrytypes-more">
      <title><database>BLOB</database> Specifics</title>
      <formalpara>
        <title>Size</title>
        <para>The maximum size of a <database>BLOB</database> field is limited to 4GB, regardless
        of whether the server is 32-bit or 64-bit. (The internal structures related
        to <database>BLOB</database>s maintain their own 4-byte counters.)  For a page size of
        4 KB (4096 bytes) the maximum size is lower&mdash;slightly less than 2GB.</para>
      </formalpara>

      <formalpara>
        <title>Operations and Expressions</title>
        <para>Text BLOBs of any length and any character set&mdash;including multi-byte&mdash;can
        be operands for practically any statement or internal functions.  The
        following operators are supported completely:
        <simplelist type="horiz" columns="2">
          <member>=</member>
          <member>(assignment)</member>

          <member>=, &lt;&gt;, &lt;, &tl;=, &gt;, &gt;=</member>
          <member>(comparison)</member>

          <member>||</member>
          <member>(concatenation)</member>

          <member>BETWEEN,<database></database></member>
          <member><database>IS [NOT] DISTINCT FROM,</database></member>

          <member><database>IN,</database></member>
          <member><database>ANY|SOME,</database></member>

          <member><database>ALL</database></member>
          <member>&nbsp;</member>
        </simplelist></para>
        <para>Partial support:
          <itemizedlist>
            <listitem>
              <para>An error occurs with these if the search argument is larger than or equal to 32 KB:
                <simplelist type="horiz" columns="2">
                  <member><database>STARTING [WITH],</database></member>
                  <member><database>LIKE,</database></member>

                  <member><database>CONTAINING</database></member>
                  <member>&nbsp;</member>
                </simplelist>
              </para>
            </listitem>
            <listitem>
              <para>Aggregation clauses work not on the contents of the field itself, but on
              the BLOB ID. Aside from that, there are some quirks:
              <simplelist type="horiz" columns="2">
                <member><database>SELECT DISTINCT</database></member>
                <member>returns several NULL values by mistake if they are present</member>

                <member><database>ORDER BY</database></member>
                <member>&mdash;</member>

                <member><database>GROUP BY</database></member>
                <member>concatenates the same strings if they are adjacent to each
                other, but not do it if they remote from each other</member>
              </simplelist>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </formalpara>

      <formalpara>
        <title><database>BLOB</database> Storage</title>
        <itemizedlist>
          <listitem>
            <para>By default, a regular record is created for each BLOB and it is stored on
            a data page that is allocated for it. If the entire BLOB fits onto this page, it
            is called a <emphasis>level 0 BLOB</emphasis>.  The number of this special record
            is stored in the table record and occupies 8 bytes.</para>
          </listitem>
          <listitem>
            <para>If a BLOB does not fit onto one data page, its contents are put onto separate
            pages allocated exclusively to it (blob pages), while the numbers of these pages
            are stored into the BLOB record.  This is a <emphasis>level 1 BLOB</emphasis>.</para>
          </listitem>
          <listitem>
            <para>If the array of page numbers containing the BLOB data does not fit onto a
            data page, the array is put on separate blob pages, while the numbers of these
            pages are put into the BLOB record. This is a <emphasis>level 2 BLOB</emphasis>.</para>
          </listitem>
          <listitem>
            <para>Levels higher than 2 are not supported.</para>
          </listitem>
        </itemizedlist>
      </formalpara>

      <formalpara>
        <title>See also</title>
        <para><database>FILTER</database>, <database>DECLARE FILTER</database>.</para>
      </formalpara>
    </section>

    <section id="fblangref25-datatypes-array">
      <title><database>ARRAY</database> Type</title>
      <para>The support of arrays in the Firebird DBMS is a departure from the traditional relational
      model. Supporting arrays in the DBMS could make it easier to solve some data-processing tasks
      involving large sets of similar data.</para>
      <para>Arrays in Firebird are stored in <database>BLOB</database> of a specialized type.
      Arrays can be one-dimensional and multidimensional and of any data type
      except <database>BLOB</database> and <database>ARRAY</database>.</para>
      <formalpara>
        <title>Example</title>
        <programlisting>
       CREATE TABLE SAMPLE_ARR (
           ID INTEGER NOT NULL PRIMARY KEY,
           ARR_INT INTEGER [4]);
        </programlisting>
        <para>This example will create a table with a field of the array type consisting of four integers.
        The subscripts of this array are from 1 to 4.</para>
      </formalpara>

      <section id="fblangref25-datatypes-array-bounds">
        <title>Specifying Explicit Boundaries for Dimensions</title>
        <para>By default, dimensions are 1-based&mdash;subscripts are numbered from 1. To specify
        explicit upper and lower bounds of the subscript values, use the following syntax:
          <programlisting>
       [&lt;lower&gt;:&lt;upper&gt;]
          </programlisting>
        </para>
      </section>

      <section id="fblangref25-datatypes-array-adddim">
        <title>Adding More Dimensions</title>
        <para>A new dimension is added after a comma in the syntax. In this example
        we create a table with a two-dimensional array, with the lower bound of subscripts
        in both dimensions starting from zero:
          <programlisting>
       CREATE TABLE SAMPLE_ARR2 (
           ID INTEGER NOT NULL PRIMARY KEY,
           ARR_INT INTEGER [0:3, 0:3]);
          </programlisting>
        </para>
      </section>

      <para>The DBMS does not offer much in the way of language or tools for working with the
      contents of arrays. The database <filename>employee.fdb</filename>, found in the
      <filename>../examples/empbuild</filename> directory of any Firebird distribution package,
      contains a sample stored procedure showing some simple work with arrays:</para>
      <formalpara>
        <title>PSQL Source for <database>SHOW_LANGS</database>, a procedure involving an array</title>
        <programlisting>
    CREATE OR ALTER PROCEDURE SHOW_LANGS (
        CODE VARCHAR(5),
        GRADE SMALLINT,
        CTY VARCHAR(15))
      RETURNS (LANGUAGES VARCHAR(15))
      AS
        DECLARE VARIABLE I INTEGER;
      BEGIN
         I = 1;
         WHILE (I &lt;= 5) DO
         BEGIN
            SELECT LANGUAGE_REQ[:I]
            FROM JOB
            WHERE (JOB_CODE = :CODE)
              AND (JOB_GRADE = :GRADE)
              AND (JOB_COUNTRY = :CTY)
              AND (LANGUAGE_REQ IS NOT NULL))
            INTO :LANGUAGES;

            IF (LANGUAGES = '') THEN
            /* PRINTS 'NULL' INSTEAD OF BLANKS */
              LANGUAGES = 'NULL';
            I = I +1;
            SUSPEND;
         END
      END
        </programlisting>
      </formalpara>
      <para>If the features described are enough for your tasks, you might consider using arrays
      in your projects. Currently, no improvements are planned to enhance support for arrays
      in Firebird.</para>
    </section>
  </section><!-- Binary data types -->

  <section id="fblangref25-datatypes-special">
    <title>Special Data Types</title>
    <para><quote>Special</quote> data types ...</para>

    <section id="fblangref25-datatypes-special-sqlnull">
      <title><database>SQL_NULL</database> Data Type</title>
      <para>The <database>SQL_NULL</database> type holds no data, but only a state:
      <database>NULL</database> or <database>NOT NULL</database>. It is not available as
      a data type for declaring table fields, PSQL variables or parameter descriptions.
      It was added to improve the support of untyped parameters in expressions involving
      the <database>IS NULL</database> predicate.</para>
      <para>An evaluation problem occurs when optional filters are used to write queries
      of the following type:
        <literallayout class="monospaced">
       WHERE col1 = :param1 OR :param1 IS NULL
        </literallayout>
      After processing, at the API level, the query will look like this:
        <literallayout class="monospaced">
       WHERE col1 = ? OR ? IS NULL
        </literallayout>
      </para>

      <para>This is a case where the developer writes an SQL query and considers
      <function>:param1</function> as though it were a <emphasis>variable</emphasis>
      that he can refer to twice.  However, at the API level, the query contains two separate and
      independent <emphasis>parameters</emphasis>. The server cannot determine the type of
      the second parameter since it comes in association with <database>IS NULL</database>.</para>

      <para>It was to solve the <quote>? IS NULL</quote> enigma that this special
      <database>SQL_NULL</database> data type was added. When the query and its parameters are
      sent to the server, the application sends each placeholder positionally, in the form <quote>?</quote>.
      Duplicated parameters are allowed to merge into one. Two filters (named parameters) would
      require four positional parameters. (Familiarity with the Firebird API is assumed.)
        <programlisting>
       SELECT
         SH.SIZE, SH.COLOUR, SH.PRICE
       FROM SHIRTS SH
       WHERE (SH.SIZE = ? OR ? IS NULL)
         AND (SH.COLOUR = ? OR ? IS NULL)
        </programlisting>
       </para>
       <para>After <function>isc_dsql_describe_bind()</function> is executed, the sqltype of the second
       and fourth parameters is set to <database>SQL_NULL</database>. As before, the Firebird server
       has no information about their associations with the first and third parameters&mdash;the
       application developer is completely responsible for that.</para>
       <para>Once the values for the first and third parameters are specified (or set to NULL) and the
       query is prepared, each pair of XSQLVARs must be filled as follows:</para>
       <formalpara>
         <title>The user has specified the parameters</title>
         <simplelist type="horiz" columns="2">
           <member>First parameter (value comparison):</member>
           <member>set *sqldata to the sent value and *sqlind to 0 (for NOT NULL)</member>
           <member>Second parameter (test for NULL):</member>
           <member>set *sqldata to NULL (not SQL_NULL) and *sqlind to 0 (for NOT NULL)</member>
         </simplelist>
       </formalpara>
       <formalpara>
         <title>The user has specified no parameters (NULL)</title>
         <simplelist type="horiz" columns="2">
           <member>Both parameters (test for NULL):</member>
           <member>set *sqldata to NULL (not SQL_NULL) and *sqlind to -1 (NULL indication)</member>
 .       </simplelist>
       </formalpara>
       <para>In other words, the value of the comparison parameter is still set, as usual.
       The <database>SQL_NULL</database> parameter is set in the same way, except when sqldata
       is sent as NULL.</para>
    </section>
  </section><!-- Special data types -->

  <section id="fblangref25-datatypes-conversion">
    <title>Conversion of Data Types</title>
    <para>When composing an expression or specifying an operation, the aim should be to
    use compatible data types for the operands. When a need arises to use a mixture of
    data types, it should prompt you to look for a way to convert incompatible
    operands before subjecting them to the operation.  The ability to convert data may well
    be an issue if you are working with Dialect 1 data.</para>

    <section id="fblangref25-datatypes-convert-explicit">
      <title>Explicit Data Type Conversion</title>
      <para>The <database>CAST</database> function enables explicit conversion between
      many pairs of data types.</para>
      <formalpara>
        <title>Syntax</title>
        <programlisting>
       CAST (&lt;value&gt; | NULL AS &lt;data_type&gt;)

       &lt;data_type&gt; ::= sql_datatype |
                        [TYPE OF] <replaceable>domain</replaceable> |
                        TYPE OF COLUMN relname.colname
        </programlisting>
      </formalpara>
      <section id="fblangref25-datatypes-convert-domain">
        <title>Casting to a Domain</title>
        <para>When you cast to a domain, any constraints declared for it are taken into account,
        i.e., NOT NULL or CHECK constraints.  If the &lt;value&gt; does not pass the check, the
        cast will fail.</para>
        <para>If <database>TYPE OF</database> is additionally specified&mdash;casting to its
        base type&mdash;any domain constraints are ignored during the cast. If
        <database>TYPE OF</database> is used with a character type (<database>CHAR/VARCHAR</database>,
        the character set and collation are retained.</para>
      </section>
      <section id="fblangref25-datatypes-convert-typeof">
        <title>Casting to <database>TYPE OF COLUMN</database></title>
        <para>When operands are cast to the type of a column, the specified column may be
        from a table or a view.</para>
        <para>Only the type of the column itself is used. For character types, the cast includes
        the character set, but not the collation. The constraints and default values of the
        source column are not applied.</para>
        <formalpara>
          <title>Example</title>
          <programlisting>
       CREATE TABLE TTT (
           S VARCHAR (40)
           CHARACTER SET UTF8 COLLATE UNICODE_CI_AI);
       COMMIT;

       SELECT
         CAST ('I have many friends' AS TYPE OF COLUMN TTT.S)
       FROM RDB$DATABASE;
          </programlisting>
        </formalpara>
      </section>

      <section id="fblangref25-datatypes-convert-conversions">
        <title>Conversions Possible for the <database>CAST</database> Function</title>
        <table id="fblangref25-dtyp-tbl-conversions">
        <?dbfo keep-together='auto'?>
          <title>Conversions with CAST</title>
          <tgroup cols="2">
            <colspec colname="colFrom" colwidth="1*"></colspec>
            <colspec colname="colTo" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">From Data Type</entry>
                <entry align="left">To Data Type</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">Numeric types</entry>
                <entry align="left">Numeric types, [VAR]CHAR, BLOB</entry>
              </row>

              <row valign="middle">
                <entry align="center">[VAR]CHAR</entry>
                <entry align="left">[VAR]CHAR, BLOB, Numeric types, DATE, TIME, TIMESTAMP</entry>
              </row>

              <row valign="middle">
                <entry align="center">BLOB</entry>
                <entry align="left">[VAR]CHAR, BLOB, Numeric types, DATE, TIME, TIMESTAMP</entry>
              </row>

              <row valign="middle">
                <entry align="center">DATE, TIME</entry>
                <entry align="left">[VAR]CHAR, BLOB, TIMESTAMP</entry>
              </row>

              <row valign="middle">
                <entry align="center">TIMESTAMP</entry>
                <entry align="left">[VAR]CHAR, BLOB, DATE, TIME</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <important>
          <para>Keep in mind that partial information loss is possible.  For instance, when you cast
          the TIMESTAMP data type to the DATE data type, the time-part is lost.</para>
        </important>
      </section>
      <section id="fblangref25-datatypes-convert-literalformats">
        <title>Literal Formats</title>
        <para>To cast string data types to the DATE, TIME or TIMESTAMP data types, you need the
        string argument to be one of the predefined date and time literals (see Table 3.7) or a
        representation of the date in one of the allowed <emphasis>date-time literal</emphasis> formats:
          <programlisting>
       &lt;datetime_literal> ::= {
         [YYYY&lt;p&gt;]MM&lt;p&gt;DD[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]] |
         MM&lt;p&gt;DD[&lt;p&gt;YYYY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         DD&lt;p&gt;MM[&lt;p&gt;YYYY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         MM&lt;p&gt;DD[&lt;p&gt;YY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         DD&lt;p&gt;MM[&lt;p&gt;YY[&lt;p&gt;HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]]] |
         NOW |
         TODAY |
         TOMORROW |
         YESTERDAY
       }

       &lt;date_literal&gt; ::= {
         [YYYY&lt;p&gt;]MM&lt;p&gt;DD |
         MM&lt;p&gt;DD[&lt;p&gt;YYYY] |
         DD&lt;p&gt;MM[&lt;p&gt;YYYY] |
         MM&lt;p&gt;DD[&lt;p&gt;YY] |
         DD&lt;p&gt;MM[&lt;p&gt;YY] |
         TODAY |
         TOMORROW |
         YESTERDAY
       }

       &lt;time_literal&gt; := HH[&lt;p&gt;mm[&lt;p&gt;SS[&lt;p&gt;NNNN]]]

       &lt;p&gt; ::= whitespace | . | : | , | - | /

          </programlisting>
        </para>
        <table id="fblangref25-dtyp-tbl-keydesc">
        <?dbfo keep-together='auto'?>
          <title>Date and Time Literal Format Arguments</title>
          <tgroup cols="2">
            <colspec colname="colArg" colwidth="2*"></colspec>
            <colspec colname="colDesc" colwidth="3*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center">Argument</entry>
                <entry align="center">Description</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">datetime_literal</entry>
                <entry align="left">Date and time literal</entry>
              </row>
              <row valign="middle">
                <entry align="center">time_literal</entry>
                <entry align="left">Time literal</entry>
              </row>
              <row valign="middle">
                <entry align="center">date_literal</entry>
                <entry align="left">Date literal</entry>
              </row>
              <row valign="middle">
                <entry align="center">YYYY</entry>
                <entry align="left">Four-digit year</entry>
              </row>
              <row valign="middle">
                <entry align="center">YY</entry>
                <entry align="left">Two-digit year</entry>
              </row>
              <row valign="middle">
                <entry align="center">MM</entry>
                <entry align="left">Month. It may contain 1 or 2 digits (1-12 or 01-12). You can
                also specify the three-letter shorthand name or the full name of a month in English. Case-insensitive</entry>
              </row>
              <row valign="middle">
                <entry align="center">DD</entry>
                <entry align="left">Day. It may contain 1 or 2 digits (1-31 or 01-31)</entry>
              </row>
              <row valign="middle">
                <entry align="center">HH</entry>
                <entry align="left">Hour. It may contain 1 or 2 digits (0-23 or 00-23)</entry>
              </row>
              <row valign="middle">
                <entry align="center">mm</entry>
                <entry align="left">Minutes. It may contain 1 or 2 digits (0-59 or 00-59)</entry>
              </row>
              <row valign="middle">
                <entry align="center">SS</entry>
                <entry align="left">Seconds. It may contain 1 or 2 digits (0-59 or 00-59)</entry>
              </row>
              <row valign="middle">
                <entry align="center">NNNN</entry>
                <entry align="left">Ten-thousandths of a second. It may contain from 1 to 4 digits (0-9999)</entry>
              </row>
              <row valign="middle">
                <entry align="center">p</entry>
                <entry align="left">A separator, any of permitted characters. Leading and trailing spaces are ignored</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table id="fblangref25-dtyp-tbl-predliterals">
        <?dbfo keep-together='auto'?>
          <title>Literals with Predefined Values of Date and Time</title>
          <tgroup cols="4">
            <colspec colname="colLit" colwidth="2*"></colspec>
            <colspec colname="colValue" colwidth="3*"></colspec>
            <colspec colname="colDlct01" colwidth="3*"></colspec>
            <colspec colname="colDlct03" colwidth="2*"></colspec>
            <thead>
              <row valign="middle">
                <entry align="center" morerows="1">Literal</entry>
                <entry align="center" morerows="1">Description</entry>
                <entry align="center" nameend="colDlct03" namest="ColDlct01">Data Type</entry>
              </row>
              <row valign="middle">
                <entry align="center">Dialect 1</entry>
                <entry align="center">Dialect 3</entry>
              </row>
            </thead>
            <tbody>
              <row valign="middle">
                <entry align="center">'NOW'</entry>
                <entry align="center">Current date and time</entry>
                <entry align="center">DATE</entry>
                <entry align="center">TIMESTAMP</entry>
              </row>
              <row valign="middle">
                <entry align="center">'TODAY'</entry>
                <entry align="center">Current date</entry>
                <entry align="center">DATE with zero time</entry>
                <entry align="center">DATE</entry>
              </row>
              <row valign="middle">
                <entry align="center">'TOMORROW'</entry>
                <entry align="center">Current date + 1 (day)</entry>
                <entry align="center">DATE with zero time</entry>
                <entry align="center">DATE</entry>
              </row>
              <row valign="middle">
                <entry align="center">'YESTERDAY'</entry>
                <entry align="center">Current date - 1 (day)</entry>
                <entry align="center">DATE with zero time</entry>
                <entry align="center">DATE</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <important>
          <para>Use of the complete specification of the year in the four-digit
          form&mdash;<database>YYYY</database> is strongly recommended, to avoid
          confusion in date calculations and aggregations.</para>
        </important>
        <formalpara>
          <title>Sample Date Literal Interpretations</title>
          <programlisting>
       select
         cast('04.12.2014' as date) as d1, -- DD.MM.YYYY
         cast('04 12 2014' as date) as d2, -- MM DD YYYY
         cast('4-12-2014' as date) as d3,  -- MM-DD-YYYY
         cast('04/12/2014' as date) as d4, -- MM/DD/YYYY
         cast('04,12,2014' as date) as d5, -- MM,DD,YYYY
         cast('04.12.14' as date) as d6,   -- DD.MM.YY
         -- DD.MM with current year
         cast('04.12' as date) as d7,
         -- MM/DD with current year
         cast('04/12' as date) as d8,
         cast('2014/12/04' as date) as d9, -- YYYY/MM/DD
         cast('2014 12 04' as date) as d10, -- YYYY MM DD
         cast('2014.12.04' as date) as d11, -- YYYY.MM.DD
         cast('2014-12-04' as date) as d12, -- YYYY-MM-DD
         cast('4 Jan 2014' as date) as d13, -- DD MM YYYY
         cast('2014 Jan 4' as date) as dt14, -- YYYY MM DD
         cast('Jan 4, 2014' as date) as dt15, -- MM DD, YYYY
         cast('11:37' as time) as t1, -- HH:mm
         cast('11:37:12' as time) as t2, -- HH:mm:ss
         cast('11:31:12.1234' as time) as t3, -- HH:mm:ss.nnnn
         cast('11.37.12' as time) as t4, -- HH.mm.ss
         -- DD.MM.YYYY HH:mm
         cast('04.12.2014 11:37' as timestamp) as dt1,
         -- MM/DD/YYYY HH:mm:ss
         cast('04/12/2014 11:37:12' as timestamp) as dt2,
         -- DD.MM.YYYY HH:mm:ss.nnnn
         cast('04.12.2014 11:31:12.1234' as timestamp) as dt3,
         -- MM/DD/YYYY HH.mm.ss
         cast('04/12/2014 11.37.12' as timestamp) as dt4
       from rdb$database
          </programlisting>
        </formalpara>
      </section>
      <section id="fblangref25-datatypes-convert-shortcasts">
        <title>Shorthand Casts for Date and Time Data Types</title>
        <para>Firebird allows the use of a shorthand <quote>C-style</quote> type syntax
        for casts from string to the <database>DATE</database>, <database>TIME</database>
        and <database>TIMESTAMP</database> types.</para>
        <formalpara>
          <title>Syntax</title>
          <literallayout class="monospaced">
       data_type 'date_literal_string'
          </literallayout>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <programlisting>
-- 1
       UPDATE PEOPLE
       SET AGECAT = 'SENIOR'
       WHERE BIRTHDATE &lt; DATE '1-Jan-1943';
-- 2
       INSERT INTO APPOINTMENTS
       (EMPLOYEE_ID, CLIENT_ID, APP_DATE, APP_TIME)
       VALUES (973, 8804, DATE 'today' + 2, TIME '16:00');
-- 3
       NEW.LASTMOD = TIMESTAMP 'now';
          </programlisting>
          <note>
            <para>These shorthand expressions are evaluated directly during parsing,
            as though the statement were already prepared for execution. Thus, even if
            the query is run several times, the value of, for instance,
            <function> timestamp 'now' </function> remains the same no matter how much
            time passes.</para>
            <para>If you need the time to be evaluated at each execution, use the full
            CAST syntax. An example of using such an expression in a trigger:
              <literallayout class="monospaced">
       NEW.CHANGE_DATE = CAST('now' AS TIMESTAMP);
              </literallayout>
            </para>
          </note>
        </formalpara>
      </section>
    </section><!-- Explicit casts -->

    <section id="fblangref25-datatypes-convert-implicit">
      <title>Implicit Data Type Conversion</title>
      <para>Implicit data conversion is not possible in Dialect 3&mdash;the <database>CAST</database>
      function is almost always required to avoid data type clashes.</para>

      <para>In Dialect 1, in many expressions, one type is implicitly cast to another without the need
      to use the CAST function.  For instance, the following clause in a Dialect 1 <database>SELECT</database>
      statement is valid:
        <programlisting>
       WHERE DOC_DATE &lt; '31.08.2014'
        </programlisting>
      and the string type will be cast to the date type implicitly.</para>
      <para>In Dialect 1, mixing integer data and numeric strings is usually possible because the parser will
      try to cast the string implicitly.  For example,
        <programlisting>
       2 + '1'
        </programlisting>
       will be executed correctly.</para>
       <para>In Dialect 3, an expression like this will raise an error, so you will need to write it as a
       <database>CAST</database> expression:
        <programlisting>
       2 + CAST('1' AS SMALLINT)
        </programlisting>
      The exception to the rule is during <emphasis>string concatenation</emphasis>.
      </para>
      <section id="fblangref25-datatypes-convert-implicit-concat">
        <title>Implicit Conversion During String Concatenation</title>
        <para>When multiple data elements are being concatenated, all non-string data will undergo implicit
        conversion to string, if possible.</para>
        <formalpara><title>Example</title>
          <programlisting>
       SELECT 30||' days hath September, April, June and November' CONCAT$
         FROM RDB$DATABASE

       CONCAT$
       ------------------------------------------------
       30 days hath September, April, June and November
          </programlisting>
        </formalpara>
      </section> <!-- ... during concatenation -->
    </section> <!-- Implicit casts -->
  </section><!-- Conversion of data types -->

  <section id="fblangref25-datatypes-custom">
    <title>Custom Data Types&mdash;Domains</title>
    <para>In Firebird, the concept of a <quote>user-defined data type</quote> is implemented in the form of
    the <emphasis>domain</emphasis>.  Creating a domain does not truly create a new data type, of course.
    A domain provides the means to encapsulate an existing data type with a set of attributes and make
    this <quote>capsule</quote> available for multiple usage across the whole database.  If several tables
    need columns defined with identical or nearly identical attributes, a domain makes sense.</para>
    <para>Domain usage is not limited to column definitions for tables and views. Domains can be used
    to declare input and output parameters and variables in PSQL code.</para>

    <section id="fblangref25-datatypes-domainattribs">
      <title>Domain Attributes</title>
      <para>A domain definition contains required and optional attributes. The <emphasis>data type</emphasis>
      is a required attribute. Optional attributes include:
        <itemizedlist>
          <listitem>a default value</listitem>
          <listitem>to allow or forbid NULL</listitem>
          <listitem>CHECK constraints</listitem>
          <listitem>character set (for character data types and text BLOB fields)</listitem>
          <listitem>collation (for character data types)</listitem>

        </itemizedlist>
      </para>
      <formalpara>
	<title>Sample domain definition</title>
	<programlisting>
       CREATE DOMAIN BOOL3 AS SMALLINT
         CHECK (VALUE IS NULL OR VALUE IN (0, 1));
	</programlisting>
      </formalpara>

      <formalpara>
        <title>See also</title>
        <para><link linkend="fblangref25-datatypes-convert-typeof">Explicit Data Type Conversion</link>
        for the description of differences in the data conversion mechanism when domains are specified
        for the <database>TYPE OF</database> and <database>TYPE OF COLUMN</database> modifiers.</para>
      </formalpara>
    </section>
    <section id="fblangref25-datatypes-domainoverride">
      <title>Domain Override</title>
      <para>While defining a column using a domain, it is possible to override some of the attributes
      inherited from the domain. Table 3.9 summarises the rules for domain override.</para>

      <table id="fblangref25-dtyp-tbl-domoverride">
      <?dbfo keep-together='auto'?>
        <title>Rules for Overriding Domain Attributes in Column Definition</title>
        <tgroup cols="3">
          <colspec colname="colAtt" colwidth="2*"></colspec>
          <colspec colname="colYesNo" colwidth="1*"></colspec>
          <colspec colname="colComment" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Attribute</entry>
              <entry align="center">Override?</entry>
              <entry align="center">Comments</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">Data type</entry>
              <entry align="center">No</entry>
              <entry align="left"> </entry>
            </row>
            <row valign="middle">
              <entry align="center">Default value</entry>
              <entry align="center">Yes</entry>
              <entry align="left"> </entry>
            </row>
            <row valign="middle">
              <entry align="center">Text character set</entry>
              <entry align="center">Yes</entry>
              <entry align="left">It can be also used to restore the default database values for the column</entry>
            </row>
            <row valign="middle">
              <entry align="center">Text collation sequence</entry>
              <entry align="center">Yes</entry>
              <entry align="left"> </entry>
            </row>
            <row valign="middle">
              <entry align="center">CHECK constraints</entry>
              <entry align="center">Yes</entry>
              <entry align="left">To add new conditions to the check, you can use the corresponding
              <database>CHECK</database> clauses in the CREATE and ALTER statements at the table level.</entry>
            </row>
            <row valign="middle">
              <entry align="center">NOT NULL</entry>
              <entry align="center">No</entry>
              <entry align="left">Often it is better to leave domain nullable in its definition and decide
              whether to make it NOT NULL when using the domain to define columns.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="fblangref25-datatypes-domaincreate">
      <title>Creating and Administering Domains</title>
      <para>A domain is created with the DDL statement <database>CREATE DOMAIN</database>.</para>
      <formalpara><title>Short Syntax</title>
        <programlisting>
       CREATE DOMAIN &lt;name&gt; [AS] &lt;type&gt;
       [DEFAULT {&lt;const&gt; | &lt;literal&gt; | NULL | &lt;context_var&gt;}]
       [NOT NULL] [CHECK (&lt;condition&gt;)]
       [COLLATE collation];
        </programlisting>
      </formalpara>
      <formalpara><title>See also</title>
          <para><link linkend="fblangref25-ddl-domn-create"><database>CREATE DOMAIN</database></link>
          in the Data Definition Language (DDL) section.</para>
      </formalpara>

      <section id="fblangref25-datatypes-domainalter">
        <title>Altering a Domain</title>
        <para>To change the attributes of a domain, use the DDL statement <database>ALTER DOMAIN</database>.
        With this statement you can
          <itemizedlist>
            <listitem>rename the domain</listitem>
            <listitem>change the data type</listitem>
            <listitem>delete the current default value</listitem>
            <listitem>set a new default value</listitem>
            <listitem>delete an existing <database>CHECK</database> constraint</listitem>
            <listitem>add a new <database>CHECK</database> constraint</listitem>
          </itemizedlist>
        </para>
        <formalpara>
          <title>Short Syntax</title>
          <programlisting>
       ALTER DOMAIN <replaceable>name</replaceable>
       [{TO <replaceable>new_name</replaceable>}]
       [{SET DEFAULT {<replaceable>literal</replaceable> | NULL | &lt;context_var&gt;} |
        DROP DEFAULT}]
       [{ADD [CONSTRAINT] CHECK (&lt;dom_condition&gt;) |
         DROP CONSTRAINT}]
       [{TYPE &lt;datatype&gt;}];
          </programlisting>
        </formalpara>
        <para>When planning to alter a domain, its dependencies must be taken into account:
        whether there are table columns, any variables, input and/or output parameters with
        the type of this domain declared in the PSQL code. If you change domains in haste,
        without carefully checking them, your code may stop working!</para>
        <important>
          <para>When you convert data types in a domain, you must not perform any conversions
          that may result in data loss. Also, for example, if you convert <database>VARCHAR</database>
          to <database>INTEGER</database>, check carefully that all data using this domain
          can be successfully converted.</para>
        </important>
        <formalpara><title>See also</title>
          <para><link linkend="fblangref25-ddl-domn-alter"><database>ALTER DOMAIN</database></link>
          in the Data Definition Language (DDL) section.</para>
        </formalpara>
      </section>
      <section id="fblangref25-datatypes-domaindrop">
        <title>Deleting (Dropping) a Domain</title>
        <para>The DDL statement <database>DROP DOMAIN</database> deletes a domain from the
        database, provided it is not in use by any other database objects.</para>
        <formalpara>
          <title>Syntax</title>
          <programlisting>
       DROP DOMAIN <replaceable>name</replaceable>
          </programlisting>
        </formalpara>
        <important>
          <para>Any user connected to the database can delete a domain.</para>
        </important>
        <formalpara><title>Example</title>
          <programlisting>
       DROP DOMAIN Test_Domain
          </programlisting>
        </formalpara>
        <formalpara><title>See also</title>
          <para><link linkend="fblangref25-ddl-domn-drop"><database>DROP DOMAIN</database></link>
          in the Data Definition Language (DDL) section.</para>
        </formalpara>
      </section>
    </section>
  </section><!-- Custom data types -->

  </chapter>
