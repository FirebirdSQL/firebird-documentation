<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../../tools/docbook-dtd/docbookx.dtd">
<chapter id="fblangref25-transacs">
  <title>Transaction Control</title>
  
  <para>Everything in Firebird happens in transactions.  Units of work are isolated between
  a start point and an end point.  Changes to data remain reversible until the moment
  the client application instructs the server to commit them.</para>
  <section id="fblangref25-transacs-statements">
    <title>Transaction Statements</title>
    <para>Firebird has a small lexicon of SQL statements that are used by
    client applications to start, manage, commit and reverse (roll back) the transactions
    that form the boundaries of all database tasks:
      <formalpara>
        <title><link linkend="fblangref25-transacs-settransac">SET TRANSACTION</link></title>
        <para>&nbsp;for configuring and starting a transaction</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-commit">COMMIT</link></title>
        <para>&nbsp;to signal the end of a unit of work and write changes
        permanently to the database</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-rollback">ROLLBACK</link></title>
        <para>&nbsp;to reverse the changes performed in the transaction</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-savepoint">SAVEPOINT</link></title>
        <para>&nbsp;to mark a position in the log of work done, in case a
        partial rollback is needed</para>
      </formalpara>
      <formalpara>
        <title><link linkend="fblangref25-transacs-releasesp">RELEASE SAVEPOINT</link></title>
        <para>&nbsp;to erase a savepoint</para>
      </formalpara>
    </para>

    <section id="fblangref25-transacs-settransac">
      <title><database>SET TRANSACTION</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Configuring and starting a transaction</para>
      </formalpara>
      <formalpara><title>Available</title>
        <para>&nbsp;DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
SET TRANSACTION
   [NAME tr_name]
   [READ WRITE | READ ONLY]
   [[ISOLATION LEVEL] {
       SNAPSHOT [TABLE STABILITY]
     | READ COMMITTED [[NO] RECORD_VERSION] }]
   [WAIT | NO WAIT]
   [LOCK TIMEOUT seconds]
   [NO AUTO UNDO]
   [IGNORE LIMBO]
   [RESERVING &lt;tables&gt; | USING &lt;dbhandles&gt;]

    &lt;tables&gt; ::= &lt;table_spec&gt; [, &lt;table_spec&gt; ...]

    &lt;table_spec&gt; ::= tablename [, tablename ...]
      [FOR [SHARED | PROTECTED] {READ | WRITE}]

    &lt;dbhandles&gt; ::= dbhandle [, dbhandle ...]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-settransac">
      <?dbfo keep-together='auto'?>
        <title>SET TRANSACTION Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tr_name</entry>
              <entry align="left">Transaction name. Available only in ESQL</entry>
            </row>
            <row valign="middle">
              <entry align="center">seconds</entry>
              <entry align="left">The time in seconds for the statement to wait in case a conflict occurs</entry>
            </row>
            <row valign="middle">
              <entry align="center">tables</entry>
              <entry align="left">The list of tables to reserve</entry>
            </row>
            <row valign="middle">
              <entry align="center">dbhandles</entry>
              <entry align="left">The list of databases the database can access. Available only in ESQL</entry>
            </row>
            <row valign="middle">
              <entry align="center">table_spec</entry>
              <entry align="left">Table reservation specification</entry>
            </row>
            <row valign="middle">
              <entry align="center">tablename</entry>
              <entry align="left">The name of the table to reserve</entry>
            </row>
            <row valign="middle">
              <entry align="center">dbhandle</entry>
              <entry align="left">The handle of the database the database can access. Available only in ESQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <database>SET TRANSACTION</database> statement configures the transaction and starts it.
      As a rule, only client applications start transactions.  The exceptions are the occasions when the
      server starts an autonomous transaction or transactions for certain background system threads/processes,
      such as sweeping.</para>
      <para>A client application can start any number of concurrently running transactions. A limit does exist,
      for the total number of running transactions in all client applications working with one particular database
      from the moment the database was restored from its backup copy or from the moment the database was created
      originally. The limit is 2<superscript>31</superscript>-1, or 2,147,483,647.</para>
      <para>All clauses in the <database>SET TRANSACTION</database> statement are optional. If the statement
      starting a transaction has no clauses specified in it, it the transaction will be started with default
      values for access mode, lock resolution mode and isolation level, which are:
        <blockquote><programlisting>
SET TRANSACTION
  READ WRITE
  WAIT
  ISOLATION LEVEL SNAPSHOT;
        </programlisting></blockquote>
      </para>

      <para>The server assigns integer numbers to transactions sequentially. Whenever a client starts any transaction,
      either explicitly defined or by default, the server sends the transaction ID to the client. This number can
      be retrieved in SQL using the context variable <database>CURRENT_TRANSACTION</database>.</para>

      <section id="fblangref25-transacs-settransac-params">
        <title>Transaction Parameters</title>
        <para>The main parameters of a transaction are:
          <itemizedlist spacing="compact">
            <listitem>data access mode (READ WRITE, READ ONLY)</listitem>
            <listitem>lock resolution mode (WAIT, NO WAIT) with an optional LOCK TIMEOUT specification</listitem>
            <listitem>isolation level (READ COMMITTED, SNAPSHOT, TABLE STABILITY)</listitem>
            <listitem>a mechanism for reserving or releasing tables (the RESERVING clause)</listitem>
          </itemizedlist>
        </para>

        <section id="fblangref25-transacs-settransac-params01">
          <title>Transaction Name</title>
          <para>The optional NAME attribute defines the name of a transaction. Use of this attribute is available
          only in Embedded SQL. In ESQL applications, named transactions make it possible to have several transactions
          active simultaneously in one application. If named transactions are used, a host-language variable with the
          same name must be declared and initialized for each named transaction. This is a limitation that prevents
          dynamic specification of transaction names and thus, rules out transaction naming in DSQL.</para>
        </section>

        <section id="fblangref25-transacs-settransac-params02">
          <title>Access Mode</title>
          <para>The two database access modes for transactions are READ WRITE and READ ONLY.
            <itemizedlist>
              <listitem>If the access mode is READ WRITE, operations in the context of this
              transaction can be both read operations and data update operations. This is the
              default mode.</listitem>
              <listitem>If the access mode is READ ONLY, only SELECT operations can be executed
              in the context of this transaction. Any attempt to change data in the context of
              such a transaction will result in database exceptions. However, it does not apply
              to global temporary tables (GTT) that are allowed to be changed in READ ONLY
              transactions.</listitem>
            </itemizedlist>
          </para>
        </section>

        <section id="fblangref25-transacs-settransac-params03">
          <title>Lock Resolution Mode</title>
          <para>When several client processes work with the same database, locks may
          occur when one process makes uncommitted changes in a table row, or deletes
          a row, and another process tries to update or delete the same row. Such locks
          are called <emphasis>update conflicts</emphasis>.</para>
          <para>Locks may occur in other situations when multiple transaction isolation
          levels are used.</para>
          <para>The two lock resolution modes are WAIT and NO WAIT.</para>

          <section id="fblangref25-transacs-settransac-params03-wait">
            <title>WAIT Mode</title>
            <para>In the WAIT mode (the default mode), if a conflict occurs between two
            parallel processes executing concurrent data updates in the same database, a
            WAIT transaction will wait till the other transaction has finished&mdash;by
            committing (COMMIT) or rolling back (ROLLBACK). The client application
            with the WAIT transaction will be put on hold until the conflict is resolved.</para>

            <para>If a LOCK TIMEOUT is specified for the WAIT transaction, waiting will continue
            only for the number of seconds specified in this clause. If the lock is unresolved
            at the end of the specified interval, the error message <quote>Lock time-out on
            wait transaction</quote> is returned to the client.</para>

            <para>Lock resolution behaviour can vary a little, depending on the transaction
            isolation level.</para>
          </section>
          <section id="fblangref25-transacs-settransac-params03-nowait">
            <title>NO WAIT Mode</title>
            <para>In the NO WAIT mode, a transaction will immediately throw a database exception
            if a conflict occurs.</para>
          </section>
        </section>

        <section id="fblangref25-transacs-settransac-params04">
          <title>Isolation Level</title>
          <para>Keeping the work of one database task separated from others is what isolation is
          about.  Changes made by one statement become visible to all remaining statements executing
          within the same transaction, regardless of its isolation level.  Changes that are
          in process within other transactions remain invisible to the current transaction as long
          as they remain uncommitted. The isolation level and, sometimes, other attributes, determine
          how transactions will interact when another transaction wants to commit work.</para>

          <para>The ISOLATION LEVEL attribute defines the isolation level for the transaction being
          started. It is the most significant transaction parameter for determining its behavior
          towards other concurrently running transactions.</para>

          <para>The three isolation levels supported in Firebird are:
            <itemizedlist spacing="compact">
              <listitem>SNAPSHOT</listitem>
              <listitem>SNAPSHOT TABLE STABILITY</listitem>
              <listitem>READ COMMITTED with two specifications (NO RECORD_VERSION and RECORD_VERSION)</listitem>
            </itemizedlist>
          </para>
          <section id="fblangref25-transacs-settransac-params04a">
            <title>SNAPSHOT Isolation Level</title>
            <para>SNAPSHOT isolation level&mdash;the default level&mdash;allows the transaction to see
            only those changes that were committed before this one was started. Any committed changes made
            by concurrent transactions will not be seen in a SNAPSHOT transaction while it is active.
            The changes will become visible to a new transaction once the current transaction is either
            committed or rolled back completely, but not if it is just rolled back to a savepoint.</para>
            <note>
              <title>Autonomous Transactions</title>
              <para>Changes made by autonomous transactions are not seen in the context of the SNAPSHOT
              transaction that launched it.</para>
            </note>
           </section>

          <section id="fblangref25-transacs-settransac-params04b">
            <title>SNAPSHOT TABLE STABILITY Isolation Level</title>
            <para>The SNAPSHOT TABLE STABILITY isolation level is the most restrictive.
            As in SNAPSHOT, a transaction in SNAPSHOT TABLE STABILITY isolation sees only
            those changes that were committed before the current transaction was started.
            After a SNAPSHOT TABLE STABILITY is started, no other transactions can make
            any changes to any table in the database that has changes pending. Other 
            transactions are able to read other data, but any attempt at inserting, updating 
            or deleting by a parallel process will cause conflict exceptions.</para>
            <para>The RESERVING clause can be used to allow other transactions to change data in some
            tables.</para>
            <para>If any other transaction has an uncommitted change of data pending in any database
            table before a transaction with the SNAPSHOT TABLE STABILITY isolation level is started,
            trying to start a SNAPSHOT TABLE STABILITY transaction will result in an exception.</para>
          </section>

          <section id="fblangref25-transacs-settransac-params04c">
            <title>READ COMMITTED Isolation Level</title>
            <para>The READ COMMITTED isolation level allows all data changes that other transactions have
            committed since it started to be seen immediately by the uncommitted current transaction.
            Uncommitted changes are not visible to a READ COMMITTED transaction.</para>

            <para>To retrieve the updated list of rows in the table you are interested
            in&mdash;<quote>refresh</quote>&mdash;the SELECT statement just needs to be requested again,
            whilst still in the uncommitted READ COMMITTED transaction.</para>

            <section id="fblangref25-transacs-settransac-params04c1">
              <title>RECORD_VERSION</title>
              <para>One of two modifying parameters can be specified for READ COMMITTED transactions,
              depending on the kind of conflict resolution desired: RECORD_VERSION and NO
              RECORD_VERSION. As the names suggest, they are mutually exclusive.
                <itemizedlist>
                  <listitem>NO RECORD_VERSION (the default value) is a kind of two-phase locking
                  mechanism:  it will make the transaction unable to write to any row that has an update
                  pending from another transaction.
                    <itemizedlist>
                      <listitem>if NO WAIT is the lock resolution strategy specified, it will throw
                      a lock conflict error immediately</listitem>
                      <listitem>with WAIT specified, it will wait until the other transaction either
                      commits or is rolled back.  If the other transaction is rolled back, or if it
                      is committed and its transaction ID is older than the current transaction's ID,
                      then the current transaction's change is allowed.  A lock conflict error is
                      returned if the other transaction was committed and its ID was newer than that
                      of the current transaction.</listitem>
                    </itemizedlist>
                  </listitem>
                  <listitem>With RECORD_VERSION specified, the transaction reads the latest committed
                  version of the row, regardless of other pending versions of the row.
                  The lock resolution strategy (WAIT or NO WAIT) does not affect the behavior of the
                  transaction at its start in any way.</listitem>
                </itemizedlist>
              </para>
            </section>
          </section> <!-- read committed -->
        </section> <!-- isolation level -->

        <section id="fblangref25-transacs-settransac-params05">
          <title>NO AUTO UNDO</title>
          <para>The NO AUTO UNDO option affects the handling of unused record versions (garbage) in the
          event of rollback.  With NO AUTO UNDO flagged, the ROLLBACK statement just marks the transaction
          as rolled back without deleting the unused record versions created in the transaction.  They are
          left to be mopped up later by garbage collection.</para>
          <para>NO AUTO UNDO might be useful when a lot of separate statements are executed that change data
          in conditions where the transaction is likely to be committed successfully most of the time.</para>
          <para>The NO AUTO UNDO option is ignored for transactions where no changes are made.</para>
        </section>

        <section id="fblangref25-transacs-settransac-params06">
          <title>IGNORE LIMBO</title>
          <para>This flag is used to signal that records created by limbo transactions are to be ignored.
          Transactions are left <quote>in limbo</quote> if the second stage of a two-phase commit
          fails.</para>
          <note>
            <title>Historical Note</title>
            <para>IGNORE LIMBO surfaces the TPB parameter <function>isc_tpb_ignore_limbo</function>,
            available in the API since InterBase times and mainly used by <emphasis>gfix</emphasis>.</para>
          </note>
        </section>

        <section id="fblangref25-transacs-settransac-params07">
          <title>RESERVING</title>
          <para>The RESERVING clause in the SET TRANSACTION statement reserves tables specified in the table list.
          Reserving a table prevents other transactions from making changes in them or even, with the inclusion
          of certain parameters, from reading data from them while this transaction is running.</para>
          <para>A RESERVING clause can also be used to specify a list of tables that can be changed by other
          transactions, even if the transaction is started with the SNAPSHOT TABLE STABILITY isolation level.</para>
          <para>One RESERVING clause is used to specify as many reserved tables as required.</para>

          <section id="fblangref25-transacs-settransac-params07a">
            <title>Options for RESERVING Clause</title>
            <para>If one of the keywords SHARED or PROTECTED is omitted, SHARED is assumed. If the whole FOR
            clause is omitted, FOR SHARED READ is assumed. The names and compatibility of the four access
            options for reserving tables are not obvious.</para>

            <table id="fblangref25-transacs-tbl-accesscompat">
            <?dbfo keep-together='auto'?>
              <title>Compatibility of Access Options for RESERVING</title>
              <tgroup cols="5">
                <colspec colname="colOne" colwidth="1*"></colspec>
                <colspec colname="colTwo" colwidth="1*"></colspec>
                <colspec colname="colThree" colwidth="1*"></colspec>
                <colspec colname="colFour" colwidth="1*"></colspec>
                <colspec colname="colFive" colwidth="1*"></colspec>
                <tbody>
                  <row valign="middle">
                    <entry align="center">&nbsp;</entry>
                    <entry align="center">SHARED READ</entry>
                    <entry align="center">SHARED WRITE</entry>
                    <entry align="center">PROTECTED READ</entry>
                    <entry align="center">PROTECTED WRITE</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">SHARED READ</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">Yes</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">SHARED WRITE</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">No</entry>
                    <entry align="center">No</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">PROTECTED READ</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">No</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">No</entry>
                  </row>
                  <row valign="middle">
                    <entry align="center">PROTECTED WRITE</entry>
                    <entry align="center">Yes</entry>
                    <entry align="center">No</entry>
                    <entry align="center">No</entry>
                    <entry align="center">No</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
            <para>The combinations of these RESERVING clause flags for concurrent access depend on the
            isolation levels of the concurrent transactions:
              <itemizedlist>
                <listitem>SNAPSHOT isolation
                  <itemizedlist spacing="compact">
                    <listitem>Concurrent SNAPSHOT transactions with SHARED READ do not affect one other's
                    access</listitem>
                    <listitem>A concurrent mix of SNAPSHOT and READ COMMITTED transactions with SHARED
                    WRITE do not affect one another's access but they block transactions with SNAPSHOT
                    TABLE STABILITY isolation from either reading from or writing to the specified table[s]</listitem>
                    <listitem>Concurrent transactions with any isolation level and PROTECTED READ can
                    only read data from the reserved tables.  Any attempt to write to them will cause
                    an exception</listitem>
                    <listitem>With PROTECTED WRITE, concurrent transactions with SNAPSHOT and READ COMMITTED
                    isolation cannot write to the specified tables.  Transactions with SNAPSHOT TABLE
                    STABILITY isolation cannot read from or write to the reserved tables at all.</listitem>
                  </itemizedlist>
                </listitem>

                <listitem>SNAPSHOT TABLE STABILITY isolation
                  <itemizedlist spacing="compact">
                    <listitem>All concurrent transactions with SHARED READ, regardless of their isolation
                    levels, can read from or write (if in READ WRITE mode) to the reserved tables</listitem>
                    <listitem>Concurrent transactions with SNAPSHOT and READ COMMITTED isolation levels
                    and SHARED WRITE can read data from and write (if in READ WRITE mode) to the specified
                    tables but concurrent access to those tables from transactions with SNAPSHOT TABLE
                    STABILITY is blocked completely whilst these transactions are active</listitem>
                    <listitem>Concurrent transactions with any isolation level and PROTECTED READ can only read
                    from the reserved tables</listitem>
                    <listitem>With PROTECTED WRITE, concurrent SNAPSHOT and READ COMMITTED transactions can
                    read from but not write to the reserved tables. Access by transactions with the SNAPSHOT
                    TABLE STABILITY isolation level is blocked completely.</listitem>
                  </itemizedlist>
                </listitem>

                <listitem>READ COMMITTED isolation
                  <itemizedlist spacing="compact">
                    <listitem>With SHARED READ, all concurrent transactions with any isolation level can
                    both read from and write (if in READ WRITE mode) to the reserved tables</listitem>
                    <listitem>SHARED WRITE allows all transactions in SNAPSHOT and READ COMMITTED isolation
                    to read from and write (if in READ WRITE mode) to the specified tables and blocks access
                    completely from transactions with SNAPSHOT TABLE STABILITY isolation</listitem>
                    <listitem>With PROTECTED READ, concurrent transactions with any isolation level can only read from
                    the reserved tables</listitem>
                    <listitem>With PROTECTED WRITE, concurrent transactions in SNAPSHOT and READ COMMITTED isolation
                    can read from but not write to the specified tables. Access from transactions in SNAPSHOT TABLE
                    STABILITY isolation is blocked completely.</listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist>
              <tip>
                <para>In Embedded SQL, the USING clause can be used to conserve system resources by limiting the
                databases the transaction can access to an enumerated list (of databases). USING is incompatible
                with RESERVING.  A USING clause in SET TRANSACTION syntax is not supported in DSQL.</para>
              </tip>
            </para>
          </section> <!-- options for RESERVING -->
        </section> <!-- RESERVING -->
      </section> <!-- transaction parameters -->
      <formalpara><title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-commit"><database>COMMIT</database></link>,
        <link linkend="fblangref25-transacs-rollback"><database>ROLLBACK</database></link></para>
      </formalpara>
    </section> <!-- SET TRANSACTION -->

    <section id="fblangref25-transacs-commit">
      <title><database>COMMIT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Committing a transaction</para>
      </formalpara>
      <formalpara><title>Available</title>
        <para>&nbsp;DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
COMMIT [WORK] [TRANSACTION tr_name]
  [RELEASE] [RETAIN [SNAPSHOT]];
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-commit">
      <?dbfo keep-together='auto'?>
        <title>COMMIT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tr_name</entry>
              <entry align="left">Transaction name. Available only in ESQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The COMMIT statement commits all work carried out in the context of this transaction
      (inserts, updates, deletes, selects, execution of procedures). New record versions become
      available to other transactions and, unless the RETAIN clause is employed, all server resources
      allocated to its work are released.</para>
      <para>If any conflicts or other errors occur in the database during the process of committing
      the transaction, the transaction is not committed and the reasons are passed back to the
      user application for handling and the opportunity to attempt another commit or to roll the
      transaction back.</para>

      <section id="fblangref25-transacs-commit-options">
        <title><database>COMMIT</database> Options</title>
        <itemizedlist>
          <listitem>
            <para>The optional <database>TRANSACTION &lt;tr_name&gt;</database> clause, available only
            in Embedded SQL,  specifies the name of the transaction to be committed. With no
            <database>TRANSACTION</database> clause, COMMIT is applied to the default transaction.
              <note>
                <para>In ESQL applications, named transactions make it possible to have several transactions
                active simultaneously in one application. If named transactions are used, a host-language
                variable with the same name must be declared and initialized for each named transaction.
                This is a limitation that prevents dynamic specification of transaction names and thus,
                rules out transaction naming in DSQL.</para>
              </note>
            </para>
          </listitem>

          <listitem>The optional keyword <database>WORK</database> is supported just for compatibility with
          other relational database management systems that require it.</listitem>

          <listitem>The keyword <database>RELEASE</database> is available only in Embedded SQL and enables
          disconnection from all databases after the transaction is committed. <database>RELEASE</database>
          is retained in Firebird only for compatibility with legacy versions of InterBase. It has been
          superseded in ESQL by the <database>DISCONNECT</database> statement.</listitem>

          <listitem>
            <para>The <database>RETAIN [SNAPSHOT]</database> clause is used for the <quote>soft</quote>,
            variously referred to amongst host languages and their practitioners as <database>COMMIT WITH
            RETAIN</database>, CommitRetaining, <quote>warm commit</quote>, et al.  The transaction is
            committed but some server resources are retained and the transaction is restarted transparently
            with the same Transaction ID.  The state of row caches and cursors is kept as it was before the
            soft commit.</para>
            <para>For soft-committed transactions whose isolation level is SNAPSHOT or SNAPSHOT TABLE STABILITY,
            the view of database state is not updated to reflect changes by other transactions and the user
            of the application instance continues to have the same view as when the transaction started
            originally.  Changes made during the life of the retained transaction are visible to that
            transaction, of course.</para>
          </listitem>
        </itemizedlist>
      </section> <!-- Commit options -->
      <note>
        <title>Recommendation</title>
        <para>Use of the <database>COMMIT</database> statement in preference to <database>ROLLBACK</database>
        is recommended for ending transactions that only read data from the database, because
        <database>COMMIT</database> consumes fewer server resources and helps to optimize the
        performance of subsequent transactions.</para>
      </note>
      <formalpara><title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-settransac"><database>SET TRANSACTION</database></link>,
        <link linkend="fblangref25-transacs-rollback"><database>ROLLBACK</database></link></para>
      </formalpara>
    </section> <!-- commit -->

    <section id="fblangref25-transacs-rollback">
      <title><database>ROLLBACK</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Rolling back a transaction</para>
      </formalpara>
      <formalpara><title>Available</title>
        <para>&nbsp;DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
ROLLBACK [WORK] [TRANSACTION tr_name]
[RETAIN [SNAPSHOT] | TO [SAVEPOINT] sp_name | RELEASE]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-rollback">
      <?dbfo keep-together='auto'?>
        <title>ROLLBACK Statement Parameters</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">tr_name</entry>
              <entry align="left">Transaction name. Available only in ESQL</entry>
            </row>
            <row valign="middle">
              <entry align="center">sp_name</entry>
              <entry align="left">Savepoint name. Available only in DSQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The ROLLBACK statement rolls back all work carried out in the context of this transaction
      (inserts, updates, deletes, selects, execution of procedures). ROLLBACK never fails and, thus,
      never causes exceptions.Unless the RETAIN clause is employed, all server resources
      allocated to the work of the transaction are released.</para>

      <section id="fblangref25-transacs-rollback-options">
        <title><database>ROLLBACK</database> Options</title>
        <itemizedlist>
          <listitem>
            <para>The optional <database>TRANSACTION &lt;tr_name&gt;</database> clause, available only
            in Embedded SQL,  specifies the name of the transaction to be committed. With no
            <database>TRANSACTION</database> clause, COMMIT is applied to the default transaction.
              <note>
                <para>In ESQL applications, named transactions make it possible to have several transactions
                active simultaneously in one application. If named transactions are used, a host-language
                variable with the same name must be declared and initialized for each named transaction.
                This is a limitation that prevents dynamic specification of transaction names and thus,
                rules out transaction naming in DSQL.</para>
              </note>
            </para>
          </listitem>

          <listitem>The optional keyword <database>WORK</database> is supported just for compatibility with
          other relational database management systems that require it.</listitem>

          <listitem>
            <para>The keyword RETAIN keyword specifies that, although all of the work of the transaction
            is to be rolled back, the transaction context is to be retained. Some server resources are retained
            and the transaction is restarted transparently with the same Transaction ID.  The state of row caches
            and cursors is kept as it was before the <quote>soft</quote> rollback.</para>

            <para>For transactions whose isolation level is SNAPSHOT or SNAPSHOT TABLE STABILITY, the view of
            database state is not updated by the soft rollback to reflect changes by other transactions. The
            user of the application instance continues to have the same view as when the transaction started
            originally.  Changes that were made and soft-committed during the life of the retained transaction
            are visible to that transaction, of course.</para>
          </listitem>
        </itemizedlist>

        <formalpara><title>See also</title>
          <para>&nbsp;<link linkend="fblangref25-transacs-settransac"><database>SET TRANSACTION</database></link>,
          <link linkend="fblangref25-transacs-commit"><database>COMMIT</database></link></para>
        </formalpara>

        <section id="fblangref25-transacs-rollback-tosavepoint">
          <title><database>ROLLBACK TO SAVEPOINT</database></title>
          <para>The optional <database>TO SAVEPOINT</database> clause in the <database>ROLLBACK</database>
          statement specifies the name of a savepoint to which changes are to be rolled back.
          The effect is to roll back all changes made within the transaction, from the created savepoint
          forward until the point when <database>ROLLBACK TO SAVEPOINT</database> is requested.</para>
          <para> <database>ROLLBACK TO SAVEPOINT</database> performs the following operations:
            <itemizedlist>
              <listitem>Any database mutations performed since the savepoint was created are undone. User
              variables set with RDB$SET_CONTEXT() remain unchanged.</listitem>

              <listitem>Any savepoints that were created after the one named are destroyed. Savepoints earlier
              than the one named are preserved, along with the named savepoint itself. Repeated rollbacks to
              the same savepoint are thus allowed.</listitem>

              <listitem>All implicit and explicit record locks that were acquired since the savepoint are
              released. Other transactions that have requested access to rows locked after the savepoint
              must continue to wait until the transaction is committed or rolled back. Other transactions
              that have not already requested the rows can request and access the unlocked rows
              immediately.</listitem>
            </itemizedlist>
          </para>

          <formalpara><title>See also</title>
            <para>&nbsp;<link linkend="fblangref25-transacs-savepoint"><database>SAVEPOINT</database></link>
            </para>
          </formalpara>
        </section> <!-- rollback to savepoint -->

      </section> <!-- rollback options -->
    </section> <!-- rollback -->

    <section id="fblangref25-transacs-savepoint">
      <title><database>SAVEPOINT</database></title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Creating a savepoint</para>
      </formalpara>
      <formalpara><title>Available</title>
        <para>&nbsp;DSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
SAVEPOINT sp_name
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-savepoint">
      <?dbfo keep-together='auto'?>
        <title>SAVEPOINT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sp_name</entry>
              <entry align="left">Savepoint name. Available only in DSQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The <database>SAVEPOINT</database> statement creates an SQL:99-compliant savepoint
      that acts as a marker in the <quote>stack</quote> of data activities within a transaction.
      Subsequently, the tasks performed in the <quote>stack</quote> can be undone back to this
      savepoint, leaving the earlier work and older savepoints untouched. Savepoint mechanisms are
      sometimes characterised as <quote>nested transactions</quote>.</para>
      <para>If a savepoint already exists with the same name as the name supplied for the new one,
      the existing savepoint is deleted and a new one is created using the supplied name.</para>
      <para>To roll changes back to the savepoint, the statement <database>ROLLBACK TO SAVEPOINT</database>
      is used.</para>
      <note>
        <title><database>Memory Considerations</database></title>
        <para>The internal mechanism beneath savepoints can consume large amounts of memory, especially
        if the same rows receive multiple updates in one transaction. When a savepoint is no longer
        needed but the transaction still has work to do, a
        <link linkend="fblangref25-transacs-releasesp"><database>RELEASE SAVEPOINT</database></link>
        statement will erase it and thus free the resources.</para>
      </note>
      <formalpara>
        <title>Sample DSQL session with savepoints</title>
        <blockquote><programlisting>
     CREATE TABLE TEST (ID INTEGER);
      COMMIT;
      INSERT INTO TEST VALUES (1);
      COMMIT;
      INSERT INTO TEST VALUES (2);
      SAVEPOINT Y;
      DELETE FROM TEST;
      SELECT * FROM TEST; -- returns no rows
      ROLLBACK TO Y;
      SELECT * FROM TEST; -- returns two rows
      ROLLBACK;
      SELECT * FROM TEST; -- returns one row
        </programlisting></blockquote>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-rollback-tosavepoint"><database>ROLLBACK TO SAVEPOINT</database></link>,
        <link linkend="fblangref25-transacs-releasesp"><database>RELEASE SAVEPOINT</database></link></para>
      </formalpara>
    </section> <!-- savepoint statement -->

    <section id="fblangref25-transacs-releasesp">
      <title>RELEASE SAVEPOINT</title>
      <formalpara><title>Used for</title>
        <para>&nbsp;Erasing a savepoint</para>
      </formalpara>
      <formalpara><title>Available</title>
        <para>&nbsp;DSQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <blockquote><programlisting>
RELEASE SAVEPOINT sp_name [ONLY]
        </programlisting></blockquote>
      </formalpara>

      <table id="fblangref25-transacs-tbl-rlssavepoint">
      <?dbfo keep-together='auto'?>
        <title>RELEASE SAVEPOINT Statement Parameter</title>
        <tgroup cols="2">
          <colspec colname="colParam" colwidth="*"></colspec>
          <colspec colname="colDes" colwidth="3*"></colspec>
          <thead>
            <row valign="middle">
              <entry align="center">Parameter</entry>
              <entry align="center">Description</entry>
            </row>
          </thead>
          <tbody>
            <row valign="middle">
              <entry align="center">sp_name</entry>
              <entry align="left">Savepoint name. Available only in DSQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The statement <database>RELEASE SAVEPOINT</database> erases a named savepoint,
      freeing up all the resources it encompasses.  By default, all the savepoints created after
      the named savepoint are released as well.  The qualifier <database>ONLY</database> directs
      the engine to release only the named savepoint.</para>
      <formalpara>
        <title>See also</title>
        <para>&nbsp;<link linkend="fblangref25-transacs-savepoint"><database>SAVEPOINT</database></link>
        </para>
      </formalpara>
    </section> <!-- release savepoint -->

    <section id="fblangref25-transacs-internalsp">
      <title>Internal Savepoints</title>
      <para>By default, the engine uses an automatic transaction-level system savepoint to perform
      transaction rollback. When a <database>ROLLBACK</database> statement is issued, all changes
      performed in this transaction are backed out via a transaction-level savepoint and the
      transaction is then committed. This logic reduces the amount of garbage collection caused by
      rolled back transactions.</para>
      <para>When the volume of changes performed under a transaction-level savepoint is getting large
      (~50000 records affected), the engine releases the transaction-level savepoint and uses the
      Transaction Inventory Page (TIP) as a mechanism to roll back the transaction if needed.</para>
      <tip>
        <para>If you expect the volume of changes in your transaction to be large, you can specify
        the <database>NO AUTO UNDO</database> option in your SET TRANSACTION statement to block
        the creation of the transaction-level savepoint.  Using the API instead, you would set the
        TPB flag <function>isc_tpb_no_auto_undo</function>.</para>
      </tip>
    </section>

    <section id="fblangref25-transacs-psqlandsp">
      <title>Savepoints and PSQL</title>
      <para>Transaction control statements are not allowed in PSQL, as that would break the atomicity
      of the statement that calls the procedure.  However, Firebird does support the raising and
      handling of exceptions in PSQL, so that actions performed in stored procedures and triggers
      can be selectively undone without the entire procedure failing.</para>
      <para>Internally, automatic savepoints are used to:
        <itemizedlist>
          <listitem>undo all actions in the <database>BEGIN...END</database> block where an
          exception occurs</listitem>
          <listitem>undo all actions performed by the procedure or trigger or, in for a
          selectable procedure, all actions performed since the last SUSPEND, when execution
          terminates prematurely because of an uncaught error or exception</listitem>
        </itemizedlist>
      </para>
      <para>Each PSQL exception handling block is also bounded by automatic system savepoints.</para>
      <note>
        <para>A <database>BEGIN...END</database> block does not itself create an automatic savepoint. A
        savepoint is created only in blocks that contain the WHEN statement for handling exceptions.</para>
      </note>
    </section>
  </section> <!-- Transaction statements -->
</chapter>