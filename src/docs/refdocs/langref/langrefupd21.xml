<?xml version="1.0" encoding="UTF-8"?>
<!--
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-->
<book id="langrefupd21">
  <!--******************************************
*                                        *
*            W A R N I N G               *
*                                        *
*   DO NOT PUBLISH! WORK IN PROGRESS!!   *
*                                        *
******************************************-->

  <bookinfo>
    <title>Firebird 2.1 Language Reference Update</title>

    <subtitle>Everything new in Firebird SQL since InterBase 6</subtitle>

    <titleabbrev>Firebird 2.1 Language Ref. Update</titleabbrev>

    <author>
      <firstname>Paul</firstname>

      <surname>Vinkenoog et al.</surname>
    </author>

    <edition>00 --maand-- 2009, document version 0.x — covers Firebird 2.1–2.1.1</edition>
  </bookinfo>

  <!--fbsvcmgr is totally absent from Win Firebird 2.1.1 installation!-->

  <chapter id="langrefupd21-intro">
    <title>Introduction</title>

    <para>This guide documents the <emphasis role="bold">changes</emphasis> made in the Firebird SQL
    language between InterBase 6 and Firebird 2.1.<replaceable>x</replaceable>. It covers the
    following areas:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Reserved words</para>
      </listitem>

      <listitem>
        <para>Data types and subtypes</para>
      </listitem>

      <listitem>
        <para>DDL statements (Data Definition Language)</para>
      </listitem>

      <listitem>
        <para>DML statements (Data Manipulation Language)</para>
      </listitem>

      <listitem>
        <para>Transaction control statements</para>
      </listitem>

      <listitem>
        <para>PSQL statements (Procedural SQL, used in stored procedures and triggers)</para>
      </listitem>

      <listitem>
        <para>Context variables</para>
      </listitem>

      <listitem>
        <para>Operators and predicates</para>
      </listitem>

      <listitem>
        <para>Internal functions</para>
      </listitem>

      <listitem>
        <para>UDFs (User Defined Functions, also known as external functions)</para>
      </listitem>
    </itemizedlist>

    <para>To have a complete Firebird 2.1 SQL reference, you need:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>The InterBase 6.0 beta SQL Reference (<filename>LangRef.pdf</filename> and/or
        <filename>SQLRef.html</filename>)</para>
      </listitem>

      <listitem>
        <para>This document</para>
      </listitem>
    </itemizedlist>

    <para>Non-SQL topics are <emphasis role="bold">not</emphasis> discussed in this document. These
    include:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>ODS versions</para>
      </listitem>

      <listitem>
        <para>Bug listings</para>
      </listitem>

      <listitem>
        <para>Installation and configuration</para>
      </listitem>

      <listitem>
        <para>Upgrade, migration and compatibility</para>
      </listitem>

      <listitem>
        <para>Server architectures</para>
      </listitem>

      <listitem>
        <para>API functions</para>
      </listitem>

      <listitem>
        <para>Connection protocols</para>
      </listitem>

      <listitem>
        <para>Tools and utilities</para>
      </listitem>
    </itemizedlist>

    <para>Consult the Release Notes for information on these subjects. You can find the Release
    Notes and other documentation via the Firebird Documentation Index at <ulink
    url="http://www.firebirdsql.org/index.php?op=doc">http://www.firebirdsql.org/index.php?op=doc</ulink>.</para>

    <section id="langrefupd21-intro-versions">
      <title>Versions covered</title>

      <para>This document covers all Firebird versions up to and including 2.1.1.</para>
    </section>

    <section id="langrefupd21-intro-authors">
      <title>Authorship</title>

      <!--Percentage and author list may change for 2.0 and 2.1!-->

      <para>Roughly 90% of the text in this document is new. The remainder was lifted from various
      Firebird Release Notes editions, which in turn contain material from preceding sources like
      the Whatsnew documents. Authors and editors of the included material are:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>J. Beesley</para>
        </listitem>

        <listitem>
          <para>Helen Borrie</para>
        </listitem>

        <listitem>
          <para>Arno Brinkman</para>
        </listitem>

        <listitem>
          <para>Alex Peshkov</para>
        </listitem>

        <listitem>
          <para>Nickolay Samofatov</para>
        </listitem>

        <listitem>
          <para>Dmitry Yemanov</para>
        </listitem>
      </itemizedlist>

      <!--You don't get on this list unless your last name starts with 'B' or ends with 'ov'! :-)-->
    </section>
  </chapter>

  <chapter id="langrefupd21-reskeywords">
    <title>Reserved words and keywords</title>

    <para>Reserved words are part of the Firebird SQL language. They cannot be used as identifiers
    (e.g. table or procedure names), except when enclosed in double quotes in Dialect 3. However,
    you should avoid this unless you have a compelling reason.</para>

    <para>Keywords are also part of the language. They have a special meaning when used in the
    proper context, but they are not reserved for Firebird's own and exclusive use. You can use them
    as identifiers without double-quoting.</para>

    <section id="langrefupd21-reskeywords-added">
      <title>Added since InterBase 6</title>

      <section id="langrefupd21-reswords-added">
        <title>Newly reserved words</title>

        <para>The following reserved words have been added to Firebird:</para>

        <blockquote>
          <simplelist>
            <member><database>BIGINT</database></member>

            <member><database>BIT_LENGTH</database></member>

            <member><database>BOTH</database></member>

            <member><database>CASE</database></member>

            <member><database>CHAR_LENGTH</database></member>

            <member><database>CHARACTER_LENGTH</database></member>

            <member><database>CLOSE</database></member>

            <member><database>CONNECT<!--2.1--></database></member>

            <member><database>CROSS</database></member>

            <member><database>CURRENT_CONNECTION</database></member>

            <member><database>CURRENT_ROLE</database></member>

            <member><database>CURRENT_TRANSACTION</database></member>

            <member><database>CURRENT_USER</database></member>

            <member><database>DISCONNECT<!--2.1--></database></member>

            <member><database>FETCH</database></member>

            <member><database>GLOBAL<!--2.1--></database></member>

            <member><database>INSENSITIVE<!--2.1--></database></member>

            <member><database>LEADING</database></member>

            <member><database>LOWER</database></member>

            <member><database>OCTET_LENGTH</database></member>

            <member><database>OPEN</database></member>

            <member><database>RECREATE</database></member>

            <member><database>RELEASE</database></member>

            <member><database>ROW_COUNT</database></member>

            <member><database>ROWS</database></member>

            <member><database>SAVEPOINT</database></member>

            <member><database>START<!--2.1--></database></member>

            <member><database>TRAILING</database></member>

            <member><database>TRIM</database></member>

            <member><database>USING</database></member>
          </simplelist>
        </blockquote>
      </section>

      <section id="langrefupd21-keywords-added">
        <title>New keywords</title>

        <para>The following words have been added to Firebird as non-reserved keywords. Most of them
        are names of internal functions added between 2.0 and 2.1.</para>

        <blockquote>
          <simplelist>
            <member><database>ABS<!--2.1--></database></member>

            <member><database>ACCENT<!--2.1--></database></member>

            <member><database>ACOS<!--2.1--></database></member>

            <member><database>ALWAYS<!--2.1--></database></member>

            <member><database>ASCII_CHAR<!--2.1--></database></member>

            <member><database>ASCII_VAL<!--2.1--></database></member>

            <member><database>ASIN<!--2.1--></database></member>

            <member><database>ATAN<!--2.1--></database></member>

            <member><database>ATAN2<!--2.1--></database></member>

            <member><database>BACKUP</database></member>

            <member><database>BIN_AND<!--2.1--></database></member>

            <member><database>BIN_OR<!--2.1--></database></member>

            <member><database>BIN_SHL<!--2.1--></database></member>

            <member><database>BIN_SHR<!--2.1--></database></member>

            <member><database>BIN_XOR<!--2.1--></database></member>

            <member><database>BLOCK</database></member>

            <member><database>CEIL<!--2.1--></database></member>

            <member><database>COALESCE</database></member>

            <member><database>COLLATION</database></member>

            <member><database>COMMENT</database></member>

            <member><database>COS<!--2.1--></database></member>

            <member><database>COSH<!--2.1--></database></member>

            <member><database>COT<!--2.1--></database></member>

            <member><database>DATEADD<!--2.1--></database></member>

            <member><database>DATEDIFF<!--2.1--></database></member>

            <member><database>DECODE<!--2.1--></database></member>

            <member><database>DELETING</database></member>

            <member><database>DIFFERENCE</database></member>

            <member><database>EXP<!--2.1--></database></member>

            <member><database>FLOOR<!--2.1--></database></member>

            <member><database>GEN_UUID<!--2.1--></database></member>

            <member><database>GENERATED<!--2.1--></database></member>

            <member><database>HASH<!--2.1--></database></member>

            <member><database>IIF</database></member>

            <member><database>INSERTING</database></member>

            <member><database>LAST</database></member>

            <member><database>LEAVE</database></member>

            <member><database>LIST<!--2.1--></database></member>

            <member><database>LN<!--2.1--></database></member>

            <member><database>LOCK</database></member>

            <member><database>LOG<!--2.1--></database></member>

            <member><database>LOG10<!--2.1--></database></member>

            <member><database>LPAD<!--2.1--></database></member>

            <member><database>MATCHED<!--2.1--></database></member>

            <member><database>MATCHING<!--2.1--></database></member>

            <member><database>MAXVALUE<!--2.1--></database></member>

            <member><database>MILLISECOND<!--2.1--></database></member>

            <member><database>MINVALUE<!--2.1--></database></member>

            <member><database>MOD<!--2.1--></database></member>

            <member><database>NEXT</database></member>

            <member><database>NULLIF</database></member>

            <member><database>NULLS</database></member>

            <member><database>OVERLAY<!--2.1--></database></member>

            <member><database>PAD<!--2.1--></database></member>

            <member><database>PI<!--2.1--></database></member>

            <member><database>PLACING<!--2.1--></database></member>

            <member><database>POWER<!--2.1--></database></member>

            <member><database>PRESERVE<!--2.1--></database></member>

            <member><database>RAND<!--2.1--></database></member>

            <member><database>REPLACE<!--2.1--></database></member>

            <member><database>RESTART</database></member>

            <member><database>RETURNING</database></member>

            <member><database>REVERSE<!--2.1--></database></member>

            <member><database>ROUND<!--2.1--></database></member>

            <member><database>RPAD<!--2.1--></database></member>

            <member><database>SCALAR_ARRAY</database></member>

            <member><database>SEQUENCE</database></member>

            <member><database>SIGN<!--2.1--></database></member>

            <member><database>SIN<!--2.1--></database></member>

            <member><database>SINH<!--2.1--></database></member>

            <member><database>SPACE<!--2.1--></database></member>

            <member><database>SQRT<!--2.1--></database></member>

            <member><database>STATEMENT</database></member>

            <member><database>TAN<!--2.1--></database></member>

            <member><database>TANH<!--2.1--></database></member>

            <member><database>TEMPORARY<!--2.1--></database></member>

            <member><database>TRUNC<!--2.1--></database></member>

            <member><database>WEEK<!--2.1--></database></member>

            <member><database>UPDATING</database></member>
          </simplelist>
        </blockquote>
      </section>
    </section>

    <section id="langrefupd21-reskeywords-dropped">
      <title>Dropped since InterBase 6</title>

      <section id="langrefupd21-reswords-dropped">
        <title>No longer reserved</title>

        <para>The following words are no longer reserved in Firebird 2.1, but are still recognized
        as keywords:</para>

        <blockquote>
          <simplelist>
            <member><database>ACTION</database></member>

            <member><database>CASCADE</database></member>

            <member><database>FREE_IT</database></member>

            <member><database>RESTRICT</database></member>

            <member><database>ROLE</database></member>

            <member><database>TYPE</database></member>

            <member><database>WEEKDAY</database></member>

            <member><database>YEARDAY</database></member>
          </simplelist>
        </blockquote>
      </section>

      <section id="langrefupd21-keywords-dropped">
        <title>No longer keywords</title>

        <para>The following are no longer keywords in Firebird 2.1:</para>

        <blockquote>
          <simplelist>
            <member><database>BASENAME</database></member>

            <member><database>CACHE</database></member>

            <member><database>CHECK_POINT_LEN</database></member>

            <member><database>GROUP_COMMIT_WAIT</database></member>

            <member><database>LOG_BUF_SIZE</database></member>

            <member><database>LOGFILE</database></member>

            <member><database>NUM_LOG_BUFS</database></member>

            <member><database>RAW_PARTITIONS</database></member>
          </simplelist>
        </blockquote>
      </section>
    </section>

    <section id="langrefupd21-reswords-future">
      <title>Possibly reserved in future versions</title>

      <para>The following words are not reserved in Firebird 2.1, but are better avoided as
      identifiers because they will likely be reserved – or added as keywords – in future
      versions:</para>

      <blockquote>
        <simplelist>
          <member><database>BOOLEAN</database></member>

          <member><database>FALSE</database></member>

          <member><database>TRUE</database></member>

          <member><database>UNKNOWN</database></member>
        </simplelist>
      </blockquote>
    </section>
  </chapter>

  <chapter id="langrefupd21-misc">
    <title>Miscellaneous language elements</title>

    <section id="langrefupd21-linecomment">
      <title>-- (single-line comment)</title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>A line starting with <quote><literal>--</literal></quote> (two dashes) is a comment
        and will be ignored. This also makes it easy to quickly comment out a line of SQL.</para>
      </formalpara>

      <para>In Firebird 1.5 and up, the <quote><literal>--</literal></quote> can be placed anywhere
      on the line, e.g. after an SQL statement. Everything from the double dash to the end of the
      line will be ignored.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>-- a table to store our valued customers in:
create table Customers (
  name varchar(32),
  added_by varchar(24),
  custno varchar(8),
  purchases integer      -- number of purchases
)</programlisting>

            <para>Notice that the second comment is only allowed in Firebird 1.5 and up.</para>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-case">
      <title><database>CASE</database> construct</title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--KW_CASE is defined in ESQL to recognize Pascal case constructs. No support for SQL CASE found.-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>A <database>CASE</database> construct returns exactly one value from a number of
        possibilities. There are two syntactic variants:<itemizedlist spacing="compact">
            <listitem>
              <para>The simple <database>CASE</database>, comparable to a Pascal <code>case</code>
              or a C <code>switch</code>.</para>
            </listitem>

            <listitem>
              <para>The searched <database>CASE</database>, which works like a series of
              <quote><code>if ... else if ... else if</code></quote> clauses.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <section id="langrefupd21-case-simple">
        <title>Simple <database>CASE</database></title>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>CASE <replaceable>&lt;expression&gt;</replaceable>
   WHEN <replaceable>&lt;exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>

        <para>When this variant is used, <replaceable>&lt;expression&gt;</replaceable> is compared
        to <replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> etc.,
        until a match is found, upon which the corresponding result is returned. If there is no
        match and there is an <database>ELSE</database> clause,
        <replaceable>defaultresult</replaceable> is returned. If there is no match and no
        <database>ELSE</database> clause, <constant>NULL</constant> is returned.</para>

        <para>The match is determined with the <quote>=</quote> operator, so if
        <replaceable>&lt;expression&gt;</replaceable> is <constant>NULL</constant>, it won't match
        any of the <replaceable>&lt;expN&gt;</replaceable>s, not even those that are
        <constant>NULL</constant>.</para>

        <para>The results don't have to be literal values: they may also be field or variable names,
        compound expressions, or <constant>NULL</constant> literals.</para>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select name,
       age,
       case upper(sex)
         when 'M' then 'Male'
         when 'F' then 'Female'
         else 'Unknown'
       end,
       religion
from people</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-case-searched">
        <title>Searched <database>CASE</database></title>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>CASE
   WHEN <replaceable>&lt;bool_exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;bool_exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Here, the <replaceable>&lt;bool_expN&gt;</replaceable>s are tests that give a ternary
        boolean result: <constant>true</constant>, <constant>false</constant>, or
        <constant>NULL</constant>. The first expression evaluating to <constant>TRUE</constant>
        determines the result. If no expression is <constant>TRUE</constant> and there is an
        <database>ELSE</database> clause, <replaceable>defaultresult</replaceable> is returned. If
        no expression is <constant>TRUE</constant> and there is no <database>ELSE</database> clause,
        <constant>NULL</constant> is returned.</para>

        <para>As with the simple <database>CASE</database>, the results don't have to be literal
        values: they may also be field or variable names, compound expressions, or
        <constant>NULL</constant> literals.</para>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>CanVote = case
            when Age &gt;= 18 then 'Yes'
            when Age &lt;  18 then 'No'
            else 'Unsure'
          end;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
  </chapter>

  <chapter id="langrefupd21-datatypes">
    <title>Data types and subtypes</title>

    <section id="langrefupd21-bigint">
      <title><database>BIGINT</database> data type</title>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>BIGINT</database> is the SQL99-compliant 64-bit signed integer type. It is
        available in Dialect 3 only.</para>
      </formalpara>

      <para><database>BIGINT</database> numbers range from -2<superscript>63</superscript> ..
      2<superscript>63</superscript>-1, or -9,223,372,036,854,775,808 ..
      9,223,372,036,854,775,807.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>create table WholeLottaRecords (
  id bigint not null primary key,
  description varchar(32)
)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-blob">
      <title><database>BLOB</database> data type</title>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Several enhancements have been implemented for
        <database>BLOB</database>s:<itemizedlist>
            <listitem>
              <para>DML <database>COLLATE</database> clauses are now supported.</para>
            </listitem>

            <listitem>
              <para>Equality comparisons can be performed on the full <database>BLOB</database>
              contents.</para>
            </listitem>

            <listitem>
              <para>Character set conversions are possible when assigning a
              <database>BLOB</database> to a <database>BLOB</database> or a string to a
              <database>BLOB</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-charsets">
      <title>New character sets</title>

      <!--Find out if (apart from the numerous UNICODE collations) there are any charsets/collations in
fbintl.conf that are NOT predeclared in RDB$CHARACTER_SETS/COLLATIONS.-->

      <formalpara>
        <title>Added in</title>

        <para>1.0, 1.5, 2.0, 2.1</para>
      </formalpara>

      <para>The following table lists the character sets added in Firebird.</para>

      <table id="langrefupd21-tbl-charsets">
        <title>Character sets new in Firebird</title>

        <tgroup cols="4">
          <colspec colname="colName" colwidth="2*" />

          <colspec colname="colBytes" colwidth="*" />

          <colspec colname="colLang" colwidth="2*" />

          <colspec colname="colAdded" colwidth="*" />

          <thead>
            <row>
              <entry align="center">Name</entry>

              <entry align="center">Max bytes/ch.</entry>

              <entry align="center">Languages</entry>

              <entry align="center">Added in</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>CP943C</entry>

              <entry>2</entry>

              <entry>Japanese</entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry>DOS737</entry>

              <entry>1</entry>

              <entry>Greek</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>DOS775</entry>

              <entry>1</entry>

              <entry>Baltic</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>DOS858</entry>

              <entry>1</entry>

              <entry>= DOS850 plus € sign</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>DOS862</entry>

              <entry>1</entry>

              <entry>Hebrew</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>DOS864</entry>

              <entry>1</entry>

              <entry>Arabic</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>DOS866</entry>

              <entry>1</entry>

              <entry>Russian</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>DOS869</entry>

              <entry>1</entry>

              <entry>Modern Greek</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>GBK</entry>

              <entry>2</entry>

              <entry>Chinese</entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry>ISO8859_2</entry>

              <entry>1</entry>

              <entry>Latin-2, Central European</entry>

              <entry>1.0</entry>
            </row>

            <row>
              <entry>ISO8859_3</entry>

              <entry>1</entry>

              <entry>Latin-3, Southern European</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_4</entry>

              <entry>1</entry>

              <entry>Latin-4, Northern European</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_5</entry>

              <entry>1</entry>

              <entry>Cyrillic</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_6</entry>

              <entry>1</entry>

              <entry>Arabic</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_7</entry>

              <entry>1</entry>

              <entry>Greek</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_8</entry>

              <entry>1</entry>

              <entry>Hebrew</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_9</entry>

              <entry>1</entry>

              <entry>Latin-5, Turkish</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO8859_13</entry>

              <entry>1</entry>

              <entry>Latin-7, Baltic Rim</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>KOI8R</entry>

              <entry>1</entry>

              <entry>Russian</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>KOI8U</entry>

              <entry>1</entry>

              <entry>Ukrainian</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>TIS620</entry>

              <entry>1</entry>

              <entry>Thai</entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry>UTF8 <footnote label="(*)">
                  <para>In Firebird 1.5, <database>UTF8</database> is an alias for
                  <database>UNICODE_FSS</database>. This character set has some inherent problems.
                  In Firebird 2, <database>UTF8</database> is a character set in its own right,
                  without the drawbacks of <database>UNICODE_FSS</database>.</para>
                </footnote></entry>

              <entry>4</entry>

              <entry>All</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>WIN1255</entry>

              <entry>1</entry>

              <entry>Hebrew</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>WIN1256</entry>

              <entry>1</entry>

              <entry>Arabic</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>WIN1257</entry>

              <entry>1</entry>

              <entry>Baltic</entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>WIN1258</entry>

              <entry>1</entry>

              <entry>Vietnamese</entry>

              <entry>2.0</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="langrefupd21-charset-none">
      <title>Character set <database>NONE</database> handling changed</title>

      <formalpara>
        <title>Changed in</title>

        <para>1.5.1</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
        moved to and from fields or variables with another character set, resulting in fewer
        transliteration errors. For more details, see the <link
        linkend="langrefupd21-notes-charset-none">Note</link> at the end of the book.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-collations">
      <title>New collations</title>

      <formalpara>
        <title>Added in</title>

        <para>1.0, 1.5, 1.5.1, 2.0, 2.1</para>
      </formalpara>

      <para>The following table lists the collations added in Firebird. The <quote>Details</quote>
      column is based on what has been reported in the Release Notes and other documents. This
      information in this column is probably incomplete; some collations with an empty Details field
      may still be case insensitive (ci), accent insensitive (ai) or dictionary-sorted (dic).</para>

      <para>Please note that the default – binary – collations for new character sets are not listed
      here, as doing so would add no meaningful information to this section.</para>

      <table id="langrefupd21-tbl-collations">
        <title>Collations new in Firebird</title>

        <tgroup cols="5">
          <colspec colname="colCharset" colwidth="2*" />

          <colspec colname="colCollation" colwidth="2*" />

          <colspec colname="colLang" colwidth="2*" />

          <colspec colname="colDetails" colwidth="*" />

          <colspec colname="colAdded" colwidth="*" />

          <thead>
            <row>
              <entry align="center">Character set</entry>

              <entry align="center">Collation</entry>

              <entry align="center">Language</entry>

              <entry align="center">Details</entry>

              <entry align="center">Added in</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>CP943C</entry>

              <entry>CP943C_UNICODE</entry>

              <entry>Japanese</entry>

              <entry></entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry>GBK</entry>

              <entry>GBK_UNICODE</entry>

              <entry>Chinese</entry>

              <entry></entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry morerows="2">ISO8859_1</entry>

              <entry>ES_ES_CI_AI</entry>

              <entry>Spanish</entry>

              <entry>ci, ai</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>FR_FR_CI_AI</entry>

              <entry>French</entry>

              <entry>ci, ai</entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry>PT_BR</entry>

              <entry>Brazilian Portuguese</entry>

              <entry>ci, ai</entry>

              <entry>2.0</entry>
            </row>

            <row valign="top">
              <entry morerows="2">ISO8859_2</entry>

              <entry>CS_CZ</entry>

              <entry>Czech</entry>

              <entry></entry>

              <entry>1.0</entry>
            </row>

            <row>
              <entry>ISO_HUN</entry>

              <entry>Hungarian</entry>

              <entry></entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>ISO_PLK</entry>

              <entry>Polish</entry>

              <entry></entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>ISO8859_13</entry>

              <entry>LT_LT</entry>

              <entry>Lithuanian</entry>

              <entry></entry>

              <entry>1.5.1</entry>
            </row>

            <row>
              <entry morerows="2">UTF8</entry>

              <entry>UCS_BASIC</entry>

              <entry>All</entry>

              <entry></entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>UNICODE</entry>

              <entry>All</entry>

              <entry>dic</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>UNICODE_CI</entry>

              <entry>All</entry>

              <entry>ci</entry>

              <entry>2.1</entry>
            </row>

            <row>
              <entry morerows="3">WIN1250</entry>

              <entry>BS_BA</entry>

              <entry>Bosnian</entry>

              <entry></entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>PXW_HUN</entry>

              <entry>Hungarian</entry>

              <entry>ci</entry>

              <entry>1.0</entry>
            </row>

            <row>
              <entry>WIN_CZ</entry>

              <entry>Czech</entry>

              <entry>ci</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>WIN_CZ_CI_AI</entry>

              <entry>Czech</entry>

              <entry>ci, ai</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>WIN1251</entry>

              <entry>WIN1251_UA</entry>

              <entry>Ukrainian and Russian</entry>

              <entry></entry>

              <entry>1.5</entry>
            </row>

            <row>
              <entry>WIN1252</entry>

              <entry>WIN_PTBR</entry>

              <entry>Brazilian Portuguese</entry>

              <entry>ci, ai</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry morerows="2">WIN1257</entry>

              <entry>WIN1257_EE</entry>

              <entry>Estonian</entry>

              <entry>dic</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>WIN1257_LT</entry>

              <entry>Lithuanian</entry>

              <entry>dic</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>WIN1257_LV</entry>

              <entry>Latvian</entry>

              <entry>dic</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>KOI8R</entry>

              <entry>KOI8R_RU</entry>

              <entry>Russian</entry>

              <entry>dic</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>KOI8U</entry>

              <entry>KOI8U_UA</entry>

              <entry>Ukrainian</entry>

              <entry>dic</entry>

              <entry>2.0</entry>
            </row>

            <row>
              <entry>TIS620</entry>

              <entry>TIS620_UNICODE</entry>

              <entry>Thai</entry>

              <entry></entry>

              <entry>2.1</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <note>
        <title>A note on the UTF8 collations</title>

        <para>The <database>UCS_BASIC</database> collation sorts in Unicode code-point order: A, B,
        a, b, á... This is exactly the same as <database>UTF8</database> with no collation
        specified. <database>UCS_BASIC</database> was added to comply with the SQL standard.</para>

        <para>The <database>UNICODE</database> collation sorts using UCA (Unicode Collation
        Algorithm): a, A, á, b, B...</para>

        <!--So why was UNICODE_CI added? Or maybe UNICODE orders lower- and uppercase
versions of letters back to back but still considers them different?-->
      </note>

      <!--RlsNotes:
  Collation Changes in V.2.1
  Spanish
  ES_ES (as well as the new ES_ES_CI_AI) collation automatically uses attributes
  DISABLE-COMPRESSIONS=1;SPECIALS-FIRST=1.
  Note: The attributes are stored at database creation time, so the changes do not
  apply to databases with ODS < 11.1.
  The ES_ES_CI_AI collation was standardised to current usage.

So: 
- was ES_ES changed or not?
- was ES_ES_CI_AI (BTW, *not* new in 2.1) changed in 2.1 or not?-->

      <section id="langrefupd21-collations-unicode">
        <title>Unicode collations for all character sets</title>

        <!--Explain how to register UNICODE collations for (almost) all character sets.-->

        <para></para>
      </section>
    </section>
  </chapter>

  <chapter id="langrefupd21-ddl">
    <title>DDL statements</title>

    <para>Rather than ordering the statements in this chapter alphabetically, we have grouped them
    by the type of database object they operate on. For instance, <database>ALTER
    DATABASE</database>, <database>CREATE DATABASE</database> and <database>DROP DATABASE</database>
    are all found under <citetitle><database>DATABASE</database></citetitle>; <database>DECLARE
    EXTERNAL FUNCTION</database> and <database>ALTER EXTERNAL FUNCTION</database> are under
    <citetitle><database>EXTERNAL FUNCTION</database></citetitle>; etc.</para>

    <para><database>GRANT</database> and <database>REVOKE</database>, which can operate on a variety
    of object types, are together under <citetitle>Privileges</citetitle>.</para>

    <section id="langrefupd21-ddl-collation">
      <title><database>COLLATION</database></title>

      <para></para>

      <section id="langrefupd21-ddl-collation-create">
        <title><database>CREATE COLLATION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--and ESQL?-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.1</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Declares a collation to the database. The collation must already be present on your
          system and must either be properly registered in the file <filename>fbintl.conf</filename>
          in the <filename class="directory">intl</filename> subdirectory of your Firebird
          installation, or be based on a registered collation. <!--registered in the database, or does registration in *.conf suffice?-->
          See the <citetitle>Firebird 2.1.x Release Notes</citetitle>, chapter
          <citetitle>International Language Support (INTL)</citetitle>, section <citetitle>New INTL
          Interface for Non-ASCII Character Sets</citetitle> for details on this.</para>

          <!--Registration in other .conf files also OK? Multiple .conf files allowed in intl subdir?-->
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>CREATE COLLATION <replaceable>name</replaceable>
   FOR <replaceable>charset</replaceable>
   [FROM <replaceable>base</replaceable> | FROM EXTERNAL ('<replaceable>name</replaceable>')]
   [NO PAD | PAD SPACE]
   [CASE [IN]SENSITIVE]
   [ACCENT [IN]SENSITIVE]
   ['<replaceable>&lt;specific-attributes&gt;</replaceable>']

<replaceable>charset</replaceable>                ::=  an existing, registered character set
<replaceable>base</replaceable>                   ::=  an existing, registered collation
<replaceable>&lt;specific-attributes&gt;</replaceable>  ::=  <replaceable>&lt;attribute&gt;</replaceable> [; <replaceable>&lt;attribute&gt;</replaceable> ...]
<replaceable>&lt;attribute&gt;</replaceable>            ::=  <replaceable>attrname</replaceable>=<replaceable>attrvalue</replaceable></programlisting>

              <!--How and when do you use EXTERNAL?
And should *name* be the same as the one after CREATE COLLATION?-->
            </blockquote><tip>
              <para>I you want to register a new character set with its default collation in your
              database, declare and run the stored procedure
              <function>sp_register_character_set(name, max_bytes_per_character)</function>, found
              in <filename>misc/intl.sql</filename> under your Firebird installation
              directory.</para>
            </tip></para>
        </formalpara>

        <formalpara>
          <title>Specific attributes</title>

          <para>The table below lists the available specific attributes. Not all specific attributes
          apply to every collation, even if specifying them doesn't cause an error. Please note that
          specific attributes are case sensitive. <quote><emphasis>1 bpc</emphasis></quote>
          indicates that an attribute is valid for collations of character sets using 1 byte per
          character (so-called <firstterm>narrow character sets</firstterm>).
          <quote><emphasis>UNI</emphasis></quote> stands for <quote>UNICODE and
          UNICODE_CI</quote>.</para>
        </formalpara>

        <!--The comment text is (still?) largely as provided by Adriano, so give him credit!-->

        <table id="langrefupd21-tbl-speccollattrs">
          <title>Specific collation attributes</title>

          <tgroup cols="4">
            <colspec colname="colName" colwidth="2*" />

            <colspec colname="colValues" colwidth="1*" />

            <colspec colname="colValidFor" colwidth="1*" />

            <colspec colname="colComment" colwidth="4*" />

            <thead>
              <row>
                <entry align="center">Name</entry>

                <entry align="center">Values</entry>

                <entry align="center">Valid for</entry>

                <entry align="center">Comment</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>DISABLE-COMPRESSIONS</entry>

                <entry>0, 1</entry>

                <entry>1 bpc</entry>

                <entry>Disables compressions (aka contractions). Compressions cause certain
                character sequences to be sorted as atomic units, e.g. Spanish
                <literal>c</literal>+<literal>h</literal> as a single character
                <literal>ch</literal>.</entry>
              </row>

              <row>
                <entry>DISABLE-EXPANSIONS</entry>

                <entry>0, 1</entry>

                <entry>1 bpc</entry>

                <entry>Disables expansions. Expansions cause certain characters (e.g. ligatures or
                umlauted vowels) to be treated as character sequences and sorted
                accordingly.</entry>
              </row>

              <row>
                <entry>ICU-VERSION</entry>

                <entry><literal>default</literal> or
                <replaceable>M</replaceable>.<replaceable>m</replaceable></entry>

                <entry>UNI</entry>

                <entry>Specifies the ICU library version to use. Valid values are the ones defined
                in the applicable <sgmltag class="starttag">intl_module</sgmltag> element in
                <filename>intl/fbintl.conf</filename>. Format: either the string literal
                <quote><literal>default</literal></quote> or a major+minor version number like
                <quote>3.0</quote> (unquoted).</entry>
              </row>

              <row>
                <entry>LOCALE</entry>

                <entry><replaceable>xx</replaceable>_<replaceable>YY</replaceable></entry>

                <entry>UNI</entry>

                <entry>Specifies the collation locale. Requires complete version of ICU libraries.
                Format: a locale string like <quote><literal>du_NL</literal></quote>
                (unquoted).</entry>
              </row>

              <row>
                <entry>MULTI-LEVEL</entry>

                <entry>0, 1</entry>

                <entry>1 bpc</entry>

                <entry>Uses more than one ordering level.</entry>
              </row>

              <row>
                <entry>SPECIALS-FIRST</entry>

                <entry>0, 1</entry>

                <entry>1 bpc</entry>

                <entry>Orders special characters (spaces, symbols etc.) before alphanumeric
                characters.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <!--ADD SOME EXAMPLES!-->
      </section>

      <section id="langrefupd21-ddl-collation-drop">
        <title><database>DROP COLLATION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--and ESQL?-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.1</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Unregisters a collation from the database.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DROP COLLATION <replaceable>name</replaceable></programlisting>

              <!--Find out if this is correct and if there are any more syntax elements-->
            </blockquote></para>
        </formalpara>

        <tip>
          <para>I you want to remove an entire character set with all its collations from your
          database, declare and run the stored procedure
          <function>sp_unregister_character_set(name)</function>, found in
          <filename>misc/intl.sql</filename> under your Firebird installation directory.</para>
        </tip>
      </section>
    </section>

    <section id="langrefupd21-ddl-comment">
      <title><database>COMMENT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Allows you to enter comments for metadata objects. The comments will be stored in the
        various <database>RDB$DESCRIPTION</database> text <database>BLOB</database> fields in the
        system tables, from where client applications can pick them up.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>COMMENT ON <replaceable>&lt;object&gt;</replaceable> IS {'<replaceable>sometext</replaceable>' | NULL}

<replaceable>&lt;object&gt;</replaceable>      ::=  DATABASE
                   | <replaceable>&lt;basic-type&gt;</replaceable> <replaceable>objectname</replaceable>
                   | COLUMN <replaceable>relationname</replaceable>.<replaceable>fieldname</replaceable>
                   | PARAMETER <replaceable>procname</replaceable>.<replaceable>paramname</replaceable>

<replaceable>&lt;basic-type&gt;</replaceable>  ::=  CHARACTER SET | COLLATION | DOMAIN | EXCEPTION
                   | EXTERNAL FUNCTION | FILTER | GENERATOR | INDEX
                   | PROCEDURE | ROLE | SEQUENCE | TABLE | TRIGGER | VIEW</programlisting>

            <note>
              <para>If you enter an empty comment (<literal>''</literal>), it will end up as
              <constant>NULL</constant> in the database.</para>
            </note>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>comment on database is 'Here''s where we keep all our customer records.'</programlisting>

            <programlisting>comment on table Metals is 'Also for alloys'</programlisting>

            <programlisting>comment on column Metals.IsAlloy is '0 = pure metal, 1 = alloy'</programlisting>

            <programlisting>comment on index ix_sales is 'Set inactive during bulk inserts!'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-ddl-database">
      <title><database>DATABASE</database></title>

      <para></para>

      <section id="langrefupd21-create-database">
        <title><database>CREATE DATABASE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-cr-db-pagesize16k">
          <title>16 Kb page size supported, 1 and 2 Kb deprecated</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0, 2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 1.0 has raised the maximum database page size from 8192 to 16384 bytes.
            In Firebird 2.1 and up, page sizes 1024 and 2048 are deprecated as inefficient. Firebird
            will no longer create databases with these page sizes, but it will connect to existing
            small-page databases without any problem.</para>
          </formalpara>

          <formalpara>
            <title>Syntax (partial)</title>

            <para><blockquote>
                <programlisting>CREATE {DATABASE | SCHEMA}
   ...
   [PAGE_SIZE [=] <replaceable>size</replaceable>]
   ...

<replaceable>size</replaceable>  ::=  4096 | 8192 | 16384</programlisting>

                <itemizedlist>
                  <listitem>
                    <para>If the user supplies a size smaller than 4096, it will be silently
                    converted to 4096. Other numbers not equal to one of the supported sizes will be
                    silently converted to the next lower supported size.</para>
                  </listitem>
                </itemizedlist>
              </blockquote></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-alter-db">
        <title><database>ALTER DATABASE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Alters a database's file organisation or toggles its <quote>safe-to-copy</quote>
          state.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ALTER {DATABASE | SCHEMA}
   [<replaceable>&lt;add_sec_clause&gt;</replaceable> [<replaceable>&lt;add_sec_clause&gt;</replaceable> ...]]
   [ADD DIFFERENCE FILE '<replaceable>filepath</replaceable>']
   [DROP DIFFERENCE FILE]
   [{BEGIN | END} BACKUP]

<replaceable>&lt;add_sec_clause&gt;</replaceable>  ::=  ADD <replaceable>&lt;sec_file&gt;</replaceable> [<replaceable>&lt;sec_file&gt;</replaceable> ...]

<replaceable>&lt;sec_file&gt;</replaceable>        ::=  FILE '<replaceable>filepath</replaceable>'
                          [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]
                          [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]</programlisting>

              <para>The <database>DIFFERENCE FILE</database> and <database>BACKUP</database>
              clauses, added in Firebird 2.0, are not available in ESQL.</para>
            </blockquote></para>
        </formalpara>

        <!--Strange: in gpre/sql.cpp, under ALTER DATABASE, there is support for things not found in the
docs, like DROP LOG/CASCADE/CACHE, ADD FILE, ADD LOGFILE, an OVERFLOW keyword, BASE_NAME...
And a number of SET clauses:
  CHECK_POINT_LENGTH, NUM_LOG_BUFFERS, LOG_BUFFER_SIZE, GROUP_COMMIT_WAIT_TIME-->

        <section id="langrefupd21-alter-db-begin-backup">
          <title><database>BEGIN BACKUP</database></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Freezes the main database file so that it can be backed up safely by filesystem
            means, even while users are connected and perform operations on the data. Any mutations
            to the database will be written to a separate file, the <firstterm>delta
            file</firstterm>. Contrary to what the syntax suggests, this statement does
            <emphasis>not</emphasis> initiate the backup itself; it merely creates the
            conditions.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter database begin backup</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-db-end-backup">
          <title><database>END BACKUP</database></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Merges the delta file back into the main database file and restores the normal
            state of operation, thus closing the time window during which safe backups could be made
            via the filesystem. (Safe backups with <application>gbak</application> are still
            possible.)</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter database end backup</programlisting>
              </blockquote></para>
          </formalpara>

          <tip>
            <para>Instead of <database>BEGIN</database> and <database>END BACKUP</database>,
            consider using Firebird's <application>nbackup</application> tool: it can freeze and
            unfreeze the main database file as well as make full and incremental backups. A manual
            for nbackup is available via the <ulink
            url="http://www.firebirdsql.org/index.php?op=doc">Firebird Documentation
            Index</ulink>.</para>
          </tip>
        </section>

        <section id="langrefupd21-alter-db-add-diff">
          <title><database>ADD DIFFERENCE FILE</database></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Presets path and name of the delta file to which mutations are written when the
            database goes into <quote>copy-safe</quote> mode after an <database>ALTER DATABASE BEGIN
            BACKUP</database> command.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter database add difference file 'C:\Firebird\Databases\Fruitbase.delta'</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>This statement doesn't really add any file. It just overrides the default
                  path and name for the delta file that will be created if and when the database
                  enters copy-safe mode.</para>
                </listitem>

                <listitem>
                  <para>If you provide a relative path or a bare filename here, it will be appended
                  to the current directory as seen from the server. On Windows, this is often the
                  system directory.</para>
                </listitem>

                <listitem>
                  <para>If you want to change an existing setting, <link
                  linkend="langrefupd21-alter-db-drop-diff"><database>DROP</database></link> the old
                  one first and then <database>ADD</database> the new one.</para>
                </listitem>

                <listitem>
                  <para>When not overridden, the delta file gets the same path and filename as the
                  database itself, but with the extension <filename
                  class="extension">.delta</filename></para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-db-drop-diff">
          <title><database>DROP DIFFERENCE FILE</database></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Removes the delta file path and name that were previously set with <database>ALTER
            DATABASE ADD DIFFERENCE FILE</database>. This statement doesn't really drop a file. It
            only erases the preset path and/or filename that would otherwise have been used the next
            time the database goes into copy-safe mode, and reverts to the default behaviour.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter database drop difference file</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
    </section>

    <section id="langrefupd21-ddl-domain">
      <title><database>DOMAIN</database></title>

      <para></para>

      <section id="langrefupd21-create-domain">
        <title><database>CREATE DOMAIN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-create-domain-contextvars">
          <title>Context variables as defaults</title>

          <formalpara>
            <title>Changed in</title>

            <para>IB</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Any context variable that is assignment-compatible to the new domain's datatype
            can be used as a default. This was already the case in InterBase 6, but the
            <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create domain DDate as
  date
  default current_date
  not null</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-alter-domain">
        <title><database>ALTER DOMAIN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <!--(for when we construct the formal syntax:)
In IB6 and Fb (tested 2.0) you cannot provide a default after ALTER DOMAIN ... TYPE-->

        <section id="langrefupd21-alter-domain-default">
          <title><database>SET DEFAULT</database> to any context variable</title>

          <formalpara>
            <title>Changed in</title>

            <para>IB</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Any context variable that is assignment-compatible to the domain's datatype can be
            used as a default. This was already the case in InterBase 6, but the <citetitle>Language
            Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter domain DDate
  set default current_date</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
    </section>

    <section id="langrefupd21-ddl-exception">
      <title><database>EXCEPTION</database></title>

      <para></para>

      <section id="langrefupd21-create-exception">
        <title><database>CREATE EXCEPTION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-create-exception-msglength">
          <title>Message length increased</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 and higher, the maximum length of the exception message has been
            raised from 78 to 1021.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create exception Ex_TooManyManagers
  'Too many managers: An attempt was made to create more managers than the
   maximum defined in the Limits table. If you really need to create more
   managers than you have now, raise the limit first. However, please consult
   your department''s manager before doing so. Otherwise, your decision may
   be overturned later and the additional manager(s) removed.'</programlisting>
              </blockquote></para>
          </formalpara>

          <note>
            <para>The maximum exception message length depends on a certain system table field.
            Therefore, pre-2.0 databases need to be backed up and restored under Firebird
            2.<replaceable>x</replaceable> before they can store exception messages of up to 1021
            bytes.</para>
          </note>
        </section>
      </section>

      <section id="langrefupd21-create-or-alter-exception">
        <title><database>CREATE OR ALTER EXCEPTION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>If the exception does not yet exist, it is created just as if <database>CREATE
          EXCEPTION</database> were used. If it already exists, it is altered. Existing dependencies
          are preserved.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as for <database>CREATE EXCEPTION</database>.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-recreate-exception">
        <title><database>RECREATE EXCEPTION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates or recreates an exception. If an exception with the same name already
          exists, <database>RECREATE EXCEPTION</database> will try to drop it and create a new
          exception. This wlll fail if there are existing dependencies on the exception.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as <database>CREATE EXCEPTION</database>.</para>
        </formalpara>

        <note>
          <para>If you use <database>RECREATE EXCEPTION</database> on an exception that has
          dependent objects, you may not get an error message until you try to commit your
          transaction.</para>

          <!--I wonder why that is? It's not very practical. (Asked Dmitry.)-->
        </note>

        <!--LangRef says that an exception can be dropped or altered by:
- its creator
- SYSDBA
- OS superuser
But where is the creator/owner of an exception kept? Not in rdb$exceptions...

OK, just created a new user without any privileges on whatever and he can just connect
and drop any exception (as long as there are no dependencies on it).
He can also ALTER existing exceptions that have dependencies.
Now find out how this is in Fb 1.5, 1.0 and IB6 - and DOCUMENT it.


(Asked Dmitry about this.)-->
      </section>
    </section>

    <section id="langrefupd21-ddl-extfunc">
      <title><database>EXTERNAL FUNCTION</database></title>

      <para></para>

      <section id="langrefupd21-declare-extfunc">
        <title><database>DECLARE EXTERNAL FUNCTION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>This statement makes an external function (UDF) known to the database.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DECLARE EXTERNAL FUNCTION <replaceable>localname</replaceable>
   [<replaceable>&lt;arg_type_decl&gt;</replaceable> [, <replaceable>&lt;arg_type_decl&gt;</replaceable> ...]]
   RETURNS {<replaceable>&lt;return_type_decl&gt;</replaceable> | PARAMETER <replaceable>1-based_pos</replaceable>} [FREE_IT]
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;arg_type_decl&gt;</replaceable>     ::=  <replaceable>sqltype</replaceable> [BY DESCRIPTOR] | CSTRING(<replaceable>length</replaceable>)
<replaceable>&lt;return_type_decl&gt;</replaceable>  ::=  <replaceable>sqltype</replaceable> [BY {DESCRIPTOR|VALUE}] | CSTRING(<replaceable>length</replaceable>)</programlisting>

              <note>
                <title>Restrictions</title>

                <itemizedlist spacing="compact">
                  <listitem>
                    <para>The <database>BY DESCRIPTOR</database> passing method is not supported in
                    ESQL.</para>
                  </listitem>
                </itemizedlist>
              </note>
            </blockquote></para>
        </formalpara>

        <para>You may choose <replaceable>localname</replaceable> freely; this is the name by which
        the function will be known to your database. You may also vary the
        <replaceable>length</replaceable> argument of <database>CSTRING</database> parameters (more
        about <database>CSTRING</database>s in the <link
        linkend="langrefupd21-notes-cstring">note</link> near the end of the book).</para>

        <section id="langrefupd21-declareext-bydescriptor">
          <title><database>BY DESCRIPTOR</database> parameter passing</title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird introduces the possibility to pass parameters <database>BY
            DESCRIPTOR</database>; this mechanism facilitates the processing of
            <constant>NULL</constant>s in a meaningful way. Notice that this only works if the
            person who wrote the function has implemented it. Simply adding <quote><database>BY
            DESCRIPTOR</database></quote> to an existing declaration does not make it work – on the
            contrary! Always use the declaration block provided by the function designer.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-declareext-retparamn">
          <title><database>RETURNS PARAMETER</database> <replaceable>n</replaceable></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL, ESQL</para>
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>IB 6</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In order to return a <database>BLOB</database>, an extra input parameter must be
            declared and a <quote><database>RETURNS PARAMETER</database>
            <replaceable>n</replaceable></quote> clause added – <replaceable>n</replaceable> being
            the position of said parameter. This clause dates back to InterBase 6 beta, but somehow
            didn't make it into the <citetitle>Language Reference</citetitle> (it is documented in
            the <citetitle>Developer's Guide</citetitle> though).</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-alter-ext-func">
        <title><database>ALTER EXTERNAL FUNCTION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Alters an external function's module name and/or entry point. Existing dependencies
          are preserved.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ALTER EXTERNAL FUNCTION <replaceable>funcname</replaceable>
   <replaceable>&lt;modification&gt;</replaceable> [<replaceable>&lt;modification&gt;</replaceable>]

<replaceable>&lt;modification&gt;</replaceable>  ::=  ENTRY_POINT '<replaceable>new-entry-point</replaceable>'
                     | MODULE_NAME '<replaceable>new-module-name</replaceable>'</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>alter external function Phi module_name 'NewUdfLib'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-ddl-filter">
      <title><database>FILTER</database></title>

      <para></para>

      <section id="langrefupd21-declare-filter">
        <title><database>DECLARE FILTER</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Makes a <database>BLOB</database> filter known to the database.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DECLARE FILTER <replaceable>filtername</replaceable>
   INPUT_TYPE <replaceable>&lt;blobtype&gt;</replaceable> OUTPUT_TYPE <replaceable>&lt;blobtype&gt;</replaceable>
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;blobtype&gt;</replaceable>  ::=  <replaceable>number</replaceable> | <replaceable>&lt;mnemonic&gt;</replaceable>
<replaceable>&lt;mnemonic&gt;</replaceable>  ::=  binary | text | blr | acl | ranges | summary | format
                 | transaction_description | external_file_description</programlisting>

              <para>The possibility to indicate the <database>BLOB</database> types with mnemonics
              instead of numbers was added in Firebird 2. The predefined mnemonics are
              case-insensitive.</para>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>declare filter Funnel
  input_type blr output_type text
  entry_point 'blr2asc' module_name 'myfilterlib'</programlisting>
            </blockquote></para>
        </formalpara>

        <tip>
          <para>If you want to define mnemonics for your own <database>BLOB</database> subtypes, you
          can add them to <database>the RDB$TYPES</database> system table as shown below. Once
          committed, the mnemonics can be used in subsequent filter declarations.</para>

          <blockquote>
            <programlisting>insert into rdb$types (rdb$field_name, rdb$type, rdb$type_name)
  values ('RDB$FIELD_SUB_TYPE', -33, 'MIDI')</programlisting>
          </blockquote>

          <para>The value for <literal>rdb$field_name</literal> must always be
          <database>'RDB$FIELD_SUB_TYPE'</database>. If you define your mnemonics in all-uppercase,
          you can use them case-insensitively and unquoted in your filter declarations.</para>
        </tip>
      </section>
    </section>

    <section id="langrefupd21-ddl-index">
      <title><database>INDEX</database></title>

      <para></para>

      <section id="langrefupd21-create-index">
        <title><database>CREATE INDEX</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates an index on a table for faster searching, sorting and/or grouping.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>CREATE [UNIQUE] [ASC[ENDING] | [DESC[ENDING]] INDEX <replaceable>indexname</replaceable>
   ON <replaceable>tablename</replaceable>
   { (<replaceable>&lt;col&gt;</replaceable> [, <replaceable>&lt;col&gt;</replaceable> ...]) | COMPUTED BY (<replaceable>expression</replaceable>) }

<replaceable>&lt;col&gt;</replaceable>  ::=  a column not of type ARRAY, BLOB or COMPUTED BY</programlisting>
            </blockquote></para>
        </formalpara>

        <section id="langrefupd21-creatind-unique-nulls">
          <title><database>UNIQUE</database> indices now allow <constant>NULL</constant>s</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple
            – are now allowed in columns that have a <database>UNIQUE</database> index defined on
            them. For a full discussion, see <link
            linkend="langrefupd21-ct-unique-keys"><citetitle><database>CREATE TABLE</database> ::
            <database>UNIQUE</database> constraints now allow
            <constant>NULL</constant>s</citetitle></link>. As far as <constant>NULL</constant>s are
            concerned, the rules for unique indices are exactly the same as those for unique
            keys.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-creatind-on-expr">
          <title>Indexing on expressions</title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Instead of one or more columns, you can now also specify a single
            <database>COMPUTED BY</database> expression in an index definition. Expression indices
            will be used in appropriate queries, provided that the expression in the
            <database>WHERE</database>, <database>ORDER BY</database> or <database>GROUP
            BY</database> clause exactly matches the expression in the index definition.
            Multi-segment expression indices are not supported, but the expression itself may
            involve multiple columns.</para>

            <!--Moet de héle WHERE of ORDER BY overeenkomen met de index of gaat het per item? Uitgezocht:
- Hele ORDER/GROUP BY moet overeenkomen, m.a.w. er mag maar één order/group-by-item zijn.
  Dit geldt overigens ook voor kolomindexen: een index op 1 kolom wordt nooit gebruikt in
  een meerkoloms ORDER/GROUP BY. Een meerkolomsindex kan wel gebruikt worden voor een
  meerkoloms ORDER/GROUP BY, mits er volledige overeenkomst is.
- bij WHERE blijft de index gebruikt worden, ook als de expressie niet de hele WHERE-claus
  uitmaakt, maar met AND (niet OR!) gekoppeld is aan andere predikaten.

En hoe zit het met HAVING? Zo te zien wordt daarin de index niet gebruikt. Een kolomindex wordt
in gelijksoortige gevallen wel gebruikt voor het evalueren van de HAVING-claus.
(Aan Dmitry gevraagd.)-->
          </formalpara>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <programlisting>create index ix_upname on persons computed by (upper(name));
commit;

-- the following queries will use ix_upname:
select * from persons order by upper(name);
select * from persons where upper(name) starting with 'VAN';
delete from persons where upper(name) = 'BROWN';
delete from persons where upper(name) = 'BROWN' and age &gt; 65;</programlisting>

                <programlisting>create descending index ix_events_yt
  on MyEvents
  computed by (extract(year from StartDate) || Town);
commit;

-- the following query will use ix_events_yt:
select * from MyEvents
  order by extract(year from StartDate) || Town desc;</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-creatind-keylength">
          <title>Maximum index key length increased</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>The maximum length of index keys, which used to be fixed at 252 bytes, is now
            equal to 1/4 of the page size, i.e. varying from 256 to 4096. The maximum indexable
            string length in bytes is 9 less than the key length. The table below shows the
            indexable string lengths in characters for the various page sizes and character
            sets.</para>
          </formalpara>

          <!--Table still valid for 2.1 ?-->

          <table id="langrefupd21-tbl-max-indexable-strlen">
            <title>Maximum indexable <database>(VAR)CHAR</database> length</title>

            <tgroup cols="5">
              <colspec align="left" colname="colPageSize" />

              <colspec align="center" colname="col1bpc" />

              <colspec align="center" colname="col2bpc" />

              <colspec align="center" colname="col3bpc" />

              <colspec align="center" colname="col4bpc" />

              <spanspec align="center" nameend="col4bpc" namest="col1bpc" spanname="spanAllCharsets" />

              <thead>
                <row valign="top">
                  <entry align="left" morerows="1">Page size</entry>

                  <entry spanname="spanAllCharsets">Maximum indexable string length per charset
                  type</entry>
                </row>

                <row>
                  <entry>1 byte/char</entry>

                  <entry>2 bytes/char</entry>

                  <entry>3 bytes/char</entry>

                  <entry>4 bytes/char</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>1024</entry>

                  <entry>247</entry>

                  <entry>123</entry>

                  <entry>82</entry>

                  <entry>61</entry>
                </row>

                <row>
                  <entry>2048</entry>

                  <entry>503</entry>

                  <entry>251</entry>

                  <entry>167</entry>

                  <entry>125</entry>
                </row>

                <row>
                  <entry>4096</entry>

                  <entry>1015</entry>

                  <entry>507</entry>

                  <entry>338</entry>

                  <entry>253</entry>
                </row>

                <row>
                  <entry>8192</entry>

                  <entry>2039</entry>

                  <entry>1019</entry>

                  <entry>679</entry>

                  <entry>509</entry>
                </row>

                <row>
                  <entry>16384</entry>

                  <entry>4087</entry>

                  <entry>2043</entry>

                  <entry>1362</entry>

                  <entry>1021</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>

        <section id="langrefupd21-creatind-maxnumber">
          <title>Maximum number of indices per table increased</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0.3, 1.5, 2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>The maximum number of 65 indices per table has been removed in Firebird 1.0.3,
            reintroduced at the higher level of 257 in Firebird 1.5, and removed once again in
            Firebird 2.0.</para>
          </formalpara>

          <para>Although there is no longer a <quote>hard</quote> ceiling, the number of indices
          creatable in practice is still limited by the database page size and the number of columns
          per index, as shown in the table below.</para>

          <!--Why has the max. number of indices gone down again in 2.0?
According to Arno Brinkman, this *might* be due to extensions to the index root page,
probably the added segment selectivity.-->

          <!--Check if table below still valid for 2.1. If so, change 2.0 -> 2.0/2.1 in title!-->

          <table id="langrefupd21-tbl-maxindices">
            <title>Max. indices per table, Firebird 2.0</title>

            <tgroup cols="4">
              <colspec align="left" colname="colPageSize" />

              <colspec align="center" colname="colFb20_1" />

              <colspec align="center" colname="colFb20_2" />

              <colspec align="center" colname="colFb20_3" />

              <spanspec align="center" nameend="colFb20_3" namest="colFb20_1"
                        spanname="spanColCounts" />

              <thead>
                <row valign="top">
                  <entry align="left" morerows="1">Page size</entry>

                  <entry spanname="spanColCounts">Number of indices depending on column
                  count</entry>
                </row>

                <row>
                  <entry>1 col</entry>

                  <entry>2 cols</entry>

                  <entry>3 cols</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>1024</entry>

                  <entry>50</entry>

                  <entry>35</entry>

                  <entry>27</entry>
                </row>

                <row>
                  <entry>2048</entry>

                  <entry>101</entry>

                  <entry>72</entry>

                  <entry>56</entry>
                </row>

                <row>
                  <entry>4096</entry>

                  <entry>203</entry>

                  <entry>145</entry>

                  <entry>113</entry>
                </row>

                <row>
                  <entry>8192</entry>

                  <entry>408</entry>

                  <entry>291</entry>

                  <entry>227</entry>
                </row>

                <row>
                  <entry>16384</entry>

                  <entry>818</entry>

                  <entry>584</entry>

                  <entry>454</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Please be aware that under normal circumstances, even 50 indices is way too many and
          will drastically reduce mutation speeds. The maximum was removed to accommodate
          data-warehousing applications and the like, which perform lots of bulk operations with the
          indices temporarily inactivated.</para>

          <para>For a full table also including Firebird versions 1.0–1.5, see the <link
          linkend="langrefupd21-notes-maxindices">Notes</link> at the end of the book.</para>
        </section>
      </section>

      <!--ALTER INDEX

Fb1 RlsNotes say:

Allow FK indexes to be disabled
It is now possible to set FOREIGN KEY indexes inactive using ALTER INDEX. This should resolve
some performance issues related to maintaining indexes with low selectivity.

In practice, this doesn't work and has never been implemented (confirmed by Dmitry).
It should have been removed from the Rlsnotes.-->
    </section>

    <section id="langrefupd21-ddl-privileges">
      <title>Privileges: <database>GRANT</database> and <database>REVOKE</database></title>

      <para></para>

      <section id="langrefupd21-revoke-admin-option">
        <title><database>REVOKE ADMIN OPTION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources. Even the older WITH ADMIN OPTION is not supported.-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Revokes a previously granted admin option (the right to pass on a granted role to
          others) from the grantee, without revoking the role itself. Multiple roles and/or multiple
          grantees can be handled in one statement.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>REVOKE ADMIN OPTION FOR <replaceable>&lt;role-list&gt;</replaceable> FROM <replaceable>&lt;grantee-list&gt;</replaceable>

<replaceable>&lt;role-list&gt;</replaceable>     ::=  <replaceable>role</replaceable> [, <replaceable>role</replaceable> ...]
<replaceable>&lt;grantee-list&gt;</replaceable>  ::=  [USER] <replaceable>&lt;grantee&gt;</replaceable> [, [USER] <replaceable>&lt;grantee&gt;</replaceable> ...]
<replaceable>&lt;grantee&gt;</replaceable>       ::=  <replaceable>username</replaceable> | PUBLIC</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>revoke admin option for manager from john, paul, george, ringo</programlisting>
            </blockquote></para>
        </formalpara>

        <para>If a user has received the admin option from several grantors, each of those grantors
        must revoke it or the user will still be able to grant the role(s) in question to
        others.</para>
      </section>
    </section>

    <section id="langrefupd21-ddl-procedure">
      <title><database>PROCEDURE</database></title>

      <para></para>

      <section id="langrefupd21-create-proc">
        <title><database>CREATE PROCEDURE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-create-proc-defaults">
          <title>Default argument values</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>It is now possible to provide default values for stored procedure arguments,
            allowing the caller to omit one or more items (possibly even all) from the end of the
            argument list.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>CREATE PROCEDURE <replaceable>procname</replaceable> (<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])
   ...

<replaceable>&lt;inparam&gt;</replaceable>  ::=  <replaceable>paramname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>]</programlisting>

                <para><emphasis role="bold">Important:</emphasis> If you provide a default value for
                a parameter, you must do the same for any and all parameters following it.</para>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-create-proc-empty">
          <title><database>BEGIN ... END</database> blocks may be empty</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
            allowing you to write stub code without having to resort to dummy statements.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create procedure grab_ints (a integer, b integer)
as
begin
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-alter-proc">
        <title><database>ALTER PROCEDURE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-alter-proc-argdefaults">
          <title>Default argument values</title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>You can now provide default values for stored procedure arguments, allowing the
            caller to omit one or more items from the end of the argument list.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>ALTER PROCEDURE <replaceable>procname</replaceable> (<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])
   ...

<replaceable>&lt;inparam&gt;</replaceable>  ::=  <replaceable>paramname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>]</programlisting>

                <para><emphasis role="bold">Important:</emphasis> If you give a parameter a default
                value, all parameters coming after it must also get default values.</para>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter procedure TestProc
  (a int, b int default 1007, s varchar(12) = '-')
  ...</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-proc-restr">
          <title>Restriction on altering used procedures</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0, 2.0.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-create-or-alter-proc">
        <title><database>CREATE OR ALTER PROCEDURE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>If the procedure does not yet exist, it is created just as if <database>CREATE
          PROCEDURE</database> were used. If it already exists, it is altered and recompiled.
          Existing permissions and dependencies are preserved.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as for <database>CREATE PROCEDURE</database>.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-drop-proc">
        <title><database>DROP PROCEDURE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-drop-proc-restr">
          <title>Restriction on dropping used procedures</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0, 2.0.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-recreate-proc">
        <title><database>RECREATE PROCEDURE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates or recreates a stored procedure. If a procedure with the same name already
          exists, <database>RECREATE PROCEDURE</database> will try to drop it and create a new
          procedure. <database>RECREATE PROCEDURE</database> will fail if the existing
          <database>SP</database> is in use.<!--Make sure this last statement is true!--></para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as <link linkend="langrefupd21-create-proc"><database>CREATE
          PROCEDURE</database></link>.</para>
        </formalpara>

        <section id="langrefupd21-recreate-proc-restr">
          <title>Restriction on recreating used procedures</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0, 2.0.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>
    </section>

    <section id="langrefupd21-ddl-sequence">
      <title><database>SEQUENCE</database> or <database>GENERATOR</database></title>

      <para></para>

      <section id="langrefupd21-create-seq">
        <title><database>CREATE SEQUENCE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates a new sequence or generator. <database>SEQUENCE</database> is the
          SQL-compliant term for what InterBase and Firebird have always called a generator.
          <database>CREATE SEQUENCE</database> is fully equivalent to <database>CREATE
          GENERATOR</database> and is the recommended syntax from Firebird 2.0 onward.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>CREATE SEQUENCE <replaceable>sequence-name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>create sequence seqtest</programlisting>
            </blockquote></para>
        </formalpara>

        <para>Because internally sequences and generators are the same thing, you can freely mix the
        generator and sequence syntaxes, even when operating on the same object. This is not
        recommended however.</para>

        <para>Sequences (or generators) are always stored as 64-bit integer values, regardless of
        the database dialect. However:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If the <emphasis>client</emphasis> dialect is set to 1, the server passes
            generator values as truncated 32-bit values to the client.</para>
          </listitem>

          <listitem>
            <para>If generator values are fed into a 32-bit field or variable, all goes well until
            the actual value exceeds the 32-bit range. At that point, a dialect 3 database will
            raise an error whereas a dialect 1 database will silently truncate the value (which
            could also lead to an error, e.g. if the receiving field has a unique key defined on
            it).</para>
          </listitem>
        </itemizedlist>

        <formalpara>
          <title>See also</title>

          <para><link linkend="langrefupd21-alter-seq"><database>ALTER SEQUENCE</database></link>,
          <link linkend="langrefupd21-nextvaluefor"><database>NEXT VALUE FOR</database></link>,
          <link linkend="langrefupd21-drop-seq"><database>DROP SEQUENCE</database></link></para>
        </formalpara>
      </section>

      <section id="langrefupd21-create-gen">
        <title><database>CREATE GENERATOR</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Deprecated in</title>

          <para>2.0 – use <link linkend="langrefupd21-create-seq">CREATE SEQUENCE</link></para>
        </formalpara>

        <section id="langrefupd21-creatgen-creatseq">
          <title><database>CREATE SEQUENCE</database> preferred</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>From Firebird 2.0 onward, the SQL-compliant <link
            linkend="langrefupd21-create-seq"><database>CREATE SEQUENCE</database></link> syntax is
            preferred.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-creatgen-limitraised">
          <title>Maximum number of generators significantly raised</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>InterBase reserved only one database page for generators, limiting the total
            number to 123 (on 1K pages) – 1019 (on 8K pages). Firebird has done away with that
            limit; you can now create more than 32,000 generators per database.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-alter-seq">
        <title><database>ALTER SEQUENCE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>(Re)initializes a sequence or generator to the given value.
          <database>SEQUENCE</database> is the SQL-compliant term for what InterBase and Firebird
          have always called a generator. <quote><database>ALTER SEQUENCE ... RESTART
          WITH</database></quote> is fully equivalent to <quote><database>SET GENERATOR ...
          TO</database></quote> and is the recommended syntax from Firebird 2.0 onward.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ALTER SEQUENCE <replaceable>sequence-name</replaceable> RESTART WITH <replaceable>&lt;newval&gt;</replaceable>

<replaceable>&lt;newval&gt;</replaceable>  ::=  A signed 64-bit integer value.</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>alter sequence seqtest restart with 0</programlisting>
            </blockquote></para>
        </formalpara>

        <warning>
          <para>Careless use of <database>ALTER SEQUENCE</database> is a mighty fine way of screwing
          up your database! Under normal circumstances you should only use it right after
          <database>CREATE SEQUENCE</database>, to set the initial value.</para>
        </warning>

        <formalpara>
          <title>See also</title>

          <para><link linkend="langrefupd21-create-seq"><database>CREATE
          SEQUENCE</database></link></para>
        </formalpara>
      </section>

      <section id="langrefupd21-set-generator">
        <title><database>SET GENERATOR</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Deprecated in</title>

          <para>2.0 – use <link linkend="langrefupd21-alter-seq"><database>ALTER
          SEQUENCE</database></link></para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>(Re)initializes a generator or sequence to the given value. From Firebird 2 onward,
          the SQL-compliant <link linkend="langrefupd21-alter-seq"><database>ALTER
          SEQUENCE</database></link> syntax is preferred.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SET GENERATOR <replaceable>generator-name</replaceable> TO <replaceable>&lt;new-value&gt;</replaceable>

<replaceable>&lt;new-value&gt;</replaceable>  ::=  A 64-bit integer.</programlisting>
            </blockquote></para>
        </formalpara>

        <warning>
          <para>Once a generator or sequence is up and running, you should not tamper with its value
          (other than retrieving next values with <database>GEN_ID</database> or <database>NEXT
          VALUE FOR</database>) unless you know exactly what you are doing.</para>
        </warning>
      </section>

      <section id="langrefupd21-drop-seq">
        <title><database>DROP SEQUENCE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Removes a sequence or generator from the database. Its (very small) storage space
          will be freed for re-use after a backup-restore cycle. <database>SEQUENCE</database> is
          the SQL-compliant term for what InterBase and Firebird have always called a generator.
          <database>DROP SEQUENCE</database> is fully equivalent to <database>DROP
          GENERATOR</database> and is the recommended syntax from Firebird 2.0 onward.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DROP SEQUENCE <replaceable>sequence-name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>drop sequence seqtest</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>See also</title>

          <para><link linkend="langrefupd21-create-seq"><database>CREATE
          SEQUENCE</database></link></para>
        </formalpara>
      </section>

      <section id="langrefupd21-drop-generator">
        <title><database>DROP GENERATOR</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in source-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.0</para>
        </formalpara>

        <formalpara>
          <title>Deprecated in</title>

          <para>2.0 – use <link linkend="langrefupd21-drop-seq">DROP SEQUENCE</link></para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Removes a generator or sequence from the database. Its (very small) storage space
          will be freed for re-use after a backup-restore cycle.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DROP GENERATOR <replaceable>generator-name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <para>From Firebird 2.0 onward, the SQL-compliant <link
        linkend="langrefupd21-drop-seq"><database>DROP SEQUENCE</database></link> syntax is
        preferred.</para>
      </section>
    </section>

    <section id="langrefupd21-ddl-table">
      <title><database>TABLE</database></title>

      <para><!--From Tracker, assigned to PV:

SFID: 458863#
Submitted By: prenosil

In Language Reference, there is written for REFERENCES
keyword used in CREATE TABLE and ALTER TABLE commands:

=====
<col_constraint> = [CONSTRAINT constraint] ...
  REFERENCES other_table [( other_col [,
other_col ...])] ...

REFERENCES Specifies that the column values are
derived from column values in
another table; if you do not specify column names,
InterBase looks for
a column with the same name as the referencing column
in the
referenced table.
=====

Current (and I think that correct) behaviour is that
if you do not specify column names, primary key
from referenced table is used.


Comment from Dmitry:

Date: 2005-10-03 17:40
Sender: dimitr
Logged In: YES
user_id=61270

Our current behaviour is 100% standard compliant. I'm
assigning this issue to Paul Vinkenoog to ensure our doc
makers are aware about that.--></para>

      <section id="langrefupd21-create-table">
        <title><database>CREATE TABLE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-ct-gtts">
          <title>Global Temporary Tables (GTTs)</title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Global temporary tables have persistent metadata, but their contents are
            transaction-bound (the default) or connection-bound. Every transaction or connection has
            its own private instance of a GTT, isolated from all the others. Instances are only
            created if and when the GTT is referenced, and destroyed upon transaction end or
            disconnection. To modify or remove a GTT's metadata, <database>ALTER TABLE</database>
            and <database>DROP TABLE</database> can be used.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>CREATE GLOBAL TEMPORARY TABLE <replaceable>name</replaceable>
   (<replaceable>column_def</replaceable> [, <replaceable>column_def</replaceable> | <replaceable>table_constraint</replaceable> ...])
   [ON COMMIT {DELETE | PRESERVE} ROWS]</programlisting>

                <itemizedlist>
                  <listitem>
                    <para><database>ON COMMIT DELETE ROWS</database> creates a transaction-level GTT
                    (the default), <database>ON COMMIT PRESERVE ROWS</database> a connection-level
                    GTT.</para>
                  </listitem>

                  <listitem>
                    <para>An <database>EXTERNAL [FILE]</database> clause is not allowed on a global
                    temporary table.</para>
                  </listitem>
                </itemizedlist>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Restrictions</title>

            <para>GTTs can be <quote>dressed up</quote> with all the features and paraphernalia of
            ordinary tables (keys, references, indices, triggers...) but there are a few
            restrictions:<itemizedlist>
                <listitem>
                  <para>GTTs and regular tables cannot reference one another.</para>
                </listitem>

                <listitem>
                  <para>A connection-bound (<quote><database>PRESERVE ROWS</database></quote>) GTT
                  cannot reference a transaction-bound (<quote><database>DELETE
                  ROWS</database></quote>) GTT.</para>
                </listitem>

                <listitem>
                  <para>Domain constraints cannot reference any GTT.</para>

                  <!--Ummm... I didn't know that a domain constraint could reference a table at all.
Check with Dmitry!-->
                </listitem>

                <listitem>
                  <para>The destruction of a GTT instance at the end of its life cycle does
                  <emphasis>not</emphasis> cause any before/after delete triggers to fire.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create global temporary table MyConnGTT (
  id int not null primary key,
  txt varchar(32),
  ts timestamp default current_timestamp
)
on commit preserve rows;

commit;

create global temporary table MyTxGTT (
  id int not null primary key,
  parent_id int not null references MyConnGTT(id),
  txt varchar(32),
  ts timestamp default current_timestamp
);

commit;</programlisting>
              </blockquote></para>
          </formalpara>

          <tip>
            <para>In an existing database, it's not always easy to tell a regular table from a GTT,
            or a transaction-level from a connection-level GTT. Use this query to find out a table's
            type:</para>

            <blockquote>
              <programlisting>select t.rdb$type_name
  from rdb$relations r
  join rdb$types t on r.rdb$relation_type = t.rdb$type
  where t.rdb$field_name = 'RDB$RELATION_TYPE'
  and r.rdb$relation_name = '<replaceable>TABLENAME</replaceable>'</programlisting>
            </blockquote>

            <para>Or, for an overview of all your relations:</para>

            <blockquote>
              <programlisting>select r.rdb$relation_name, t.rdb$type_name
  from rdb$relations r
  join rdb$types t on r.rdb$relation_type = t.rdb$type
  where t.rdb$field_name = 'RDB$RELATION_TYPE'
  and coalesce (r.rdb$system_flag, 0) = 0</programlisting>
            </blockquote>
          </tip>

          <!--From the 2.1.1 RlsNotes:

  The data and index pages of all GTT instances are placed in separate temporary files.
  Each connection has its own temporary file created the first time the connection
  references some GTT.

This is probably incorrect. With 2 or 3 connections referencing the same connection-level GTT,
I saw ONE file appear in Windows\Temp. It disappeared after the last disconnect.-->
        </section>

        <section id="langrefupd21-ct-gen-always-as">
          <title><database>GENERATED ALWAYS AS</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Instead of <database>COMPUTED [BY]</database>, you may also use the
            SQL-2003-compliant equivalent <database>GENERATED ALWAYS AS</database> for computed
            fields.</para>

            <!--Is GENERATED ALWAYS AS also supported in CREATE INDEX ? If not, feature request.-->
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting><replaceable>colname</replaceable> [<replaceable>coltype</replaceable>] GENERATED ALWAYS AS (<replaceable>expression</replaceable>)</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create table Persons (
  id int primary key,
  firstname varchar(24) not null,
  middlename varchar(24),
  lastname varchar(24) not null,
  fullname varchar(74) generated always as
    (firstname || coalesce(' ' || middlename, '') || ' ' || lastname),
  street varchar(32),
  ...
  ...
)</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-ct-check">
          <title><database>CHECK</database> accepts <constant>NULL</constant> outcome</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>If a <database>CHECK</database> constraint resolves to <constant>NULL</constant>,
            Firebird versions before 2.0 reject the input. Following the SQL standard to the letter,
            Firebird 2.0 and above let <constant>NULL</constant>s pass and only consider the check
            failed if the outcome is <constant>false</constant>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <para>Checks like these:</para>

                <programlisting>check (value &gt; 10000)</programlisting>

                <programlisting>check (Town like 'Amst%')</programlisting>

                <programlisting>check (upper(value) in ( 'A', 'B', 'X' ))</programlisting>

                <programlisting>check (Minimum &lt;= Maximum)</programlisting>

                <para>all <emphasis>fail</emphasis> in pre-2.0 Firebird versions if the value to be
                checked is <constant>NULL</constant>. In 2.0 and above they
                <emphasis>succeed</emphasis>.</para>
              </blockquote></para>
          </formalpara>

          <warning>
            <para>This change may cause existing databases to behave differently when migrated to
            Firebird 2.0+. Carefully examine your <database>CREATE/ALTER TABLE</database> statements
            and add <quote><code>and XXX is not null</code></quote> predicates to your
            <database>CHECK</database>s if they should continue to reject <constant>NULL</constant>
            input.</para>
          </warning>
        </section>

        <section id="langrefupd21-ct-contextvars">
          <title>Context variables as column defaults</title>

          <formalpara>
            <title>Changed in</title>

            <para>IB</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Any context variable that is assignment-compatible to the column datatype can be
            used as a default. This was already the case in InterBase 6, but the <citetitle>Language
            Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create table MyData (
  id int not null primary key,
  record_created timestamp default current_timestamp,
  ...
)</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-ct-fk-noexclusive">
          <title><database>FOREIGN KEY</database> creation no longer requires exclusive
          access</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 and above, creating a foreign key constraint no longer requires
            exclusive access to the database.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-ct-unique-keys">
          <title><database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple
            – are now allowed in columns with a <database>UNIQUE</database> constraint. It is
            therefore possible to define a <database>UNIQUE</database> key on a column that has no
            <database>NOT NULL</database> constraint.</para>
          </formalpara>

          <para>For <database>UNIQUE</database> keys that span multiple columns, the logic is a
          little complicated:</para>

          <itemizedlist>
            <listitem>
              <para>Multiple rows having <emphasis>all</emphasis> the <database>UK</database>
              columns <constant>NULL</constant> are allowed.</para>
            </listitem>

            <listitem>
              <para>Multiple rows having a <emphasis>different subset</emphasis> of
              <database>UK</database> colums <constant>NULL</constant> are allowed.</para>
            </listitem>

            <listitem>
              <para>Multiple rows having the <emphasis>same subset</emphasis> of
              <database>UK</database> columns <constant>NULL</constant> and the rest filled with
              regular values and those regular values <emphasis>differ</emphasis> in at least one
              column, are allowed.</para>
            </listitem>

            <listitem>
              <para>Multiple rows having the <emphasis>same subset</emphasis> of
              <database>UK</database> columns <constant>NULL</constant> and the rest filled with
              regular values and those regular values are the <emphasis>same</emphasis> in every
              column, are forbidden.</para>
            </listitem>
          </itemizedlist>

          <para>One way of summarizing this is as follows: In principle, all
          <constant>NULL</constant>s are considered distinct. But if two rows have exactly the same
          subset of <database>UK</database> columns filled with non-<constant>NULL</constant>
          values, the <constant>NULL</constant> columns are ignored and the
          non-<constant>NULL</constant> columns are decisive, just as if they constituted the entire
          unique key.</para>

          <!--Give example tables to show what is and isn't allowed?-->
        </section>

        <section id="langrefupd21-ct-using-index">
          <title><database>USING INDEX</database> subclause</title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>

            <!--ESQL: no support found in source-->
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>A <database>USING INDEX</database> subclause can be placed at the end of a
            primary, unique or foreign key definition. Its purpose is to<itemizedlist
                spacing="compact">
                <listitem>
                  <para>provide a user-defined name for the automatically created index that
                  enforces the constraint, and</para>
                </listitem>

                <listitem>
                  <para>optionally define the index to be ascending or descending (the default being
                  ascending).</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <para>Without <database>USING INDEX</database>, indices enforcing named constraints are
          named after the constraint (this is new behaviour in Firebird 1.5) and indices for unnamed
          constraints get names like <database>RDB$FOREIGN13</database> or something equally
          romantic.</para>

          <note>
            <para>You must always provide a <emphasis>new</emphasis> name for the index. It is not
            possible to use pre-existing indices to enforce constraints.</para>
          </note>

          <para><database>USING INDEX</database> can be applied at field level, at table level, and
          (in <database>ALTER TABLE</database>) with <database>ADD CONSTRAINT</database>. It works
          with named as well as unnamed key constraints. It does <emphasis>not</emphasis> work with
          <database>CHECK</database> constraints, as these don't have their own enforcing
          index.</para>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>[CONSTRAINT <replaceable>constraint-name</replaceable>]
   <replaceable>&lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>The first example creates a primary key constraint
                <database>PK_CUST</database> using an index named
                <database>IX_CUSTNO</database>:</para>

                <programlisting>create table customers (
  custno int not null constraint pk_cust primary key using index ix_custno,
  ...</programlisting>

                <para>This, however:</para>

                <programlisting>create table customers (
  custno int not null primary key using index ix_custno,
  ...</programlisting>

                <para>...will give you a PK constraint called <database>INTEG_7</database> or
                something similar, and an index <database>IX_CUSTNO</database>.</para>

                <para>Some more examples:</para>

                <programlisting>create table people (
  id int not null,
  nickname varchar(12) not null,
  country char(4),
  ..
  ..
  constraint pk_people primary key (id),
  constraint uk_nickname unique (nickname) using index ix_nick
)</programlisting>

                <programlisting>alter table people
  add constraint fk_people_country
  foreign key (country) references countries(code)
  using desc index ix_people_country</programlisting>
              </blockquote></para>
          </formalpara>

          <important>
            <para>If you define a descending constraint-enforcing index on a primary or unique key,
            be sure to make any foreign keys referencing it descending as well.<!--Or else?--></para>
          </important>
        </section>
      </section>

      <section id="langrefupd21-alter-table">
        <title><database>ALTER TABLE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <!--(for when we construct the formal syntax:)
- In IB6 and Fb (tested 2.0) you cannot provide a default after ALTER [COLUMN] ... TYPE
- ALTER COLUMN ADD/DROP/ DEFAULT are not supported in ESQL-->

        <section id="langrefupd21-at-contextvars">
          <title><database>ADD</database> column: Context variables as defaults</title>

          <formalpara>
            <title>Changed in</title>

            <para>IB</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Any context variable that is assignment-compatible to the new column's datatype
            can be used as a default. This was already the case in InterBase 6, but the
            <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter table MyData
  add MyDay date default current_date</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-at-ac-dropdefault">
          <title><database>ALTER COLUMN</database>: <database>DROP DEFAULT</database></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>

            <!--ESQL: no-->
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2 adds the possibility to drop a column-level default. Once the default
            is dropped, there will either be no default in place or – if the column's type is a
            <database>DOMAIN</database> with a default – the domain default will resurface.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> DROP DEFAULT</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter table Trees alter Girth drop default</programlisting>
              </blockquote></para>
          </formalpara>

          <para>An error is raised if you use <database>DROP DEFAULT</database> on a column that
          doesn't have a default or whose effective default is domain-based.</para>
        </section>

        <section id="langrefupd21-at-ac-setdefault">
          <title><database>ALTER COLUMN</database>: <database>SET DEFAULT</database></title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>

            <!--ESQL: no-->
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2 adds the possibility to set/alter defaults on existing columns. If the
            column already had a default, the new default will replace it. Column-level defaults
            always override domain-level defaults.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> SET DEFAULT <replaceable>&lt;default&gt;</replaceable>

<replaceable>&lt;default&gt;</replaceable>  ::=  <replaceable>literal-value</replaceable> | <replaceable>context-variable</replaceable> | NULL</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter table Customers alter EnteredBy set default current_user</programlisting>
              </blockquote></para>
          </formalpara>

          <tip>
            <para>If you want to switch off a domain-based default on a column, set the column
            default to <constant>NULL</constant>.</para>
          </tip>
        </section>

        <section id="langrefupd21-at-position">
          <title><database>ALTER COLUMN</database>: <database>POSITION</database> now
          1-based</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>When changing a column's position, the engine now interprets the new position as
            1-based. This is in accordance with the SQL standard and the InterBase documentation,
            but in practice InterBase interpreted the position as 0-based.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> POSITION <replaceable>&lt;newpos&gt;</replaceable>

<replaceable>&lt;newpos&gt;</replaceable>  ::=  an integer between 1 and the number of columns</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>alter table Stock alter Quantity position 3</programlisting>
              </blockquote></para>
          </formalpara>

          <note>
            <para>Don't confuse this with the <database>POSITION</database> in
            <database>CREATE/ALTER TRIGGER</database>. Trigger positions are and will remain
            0-based.</para>
          </note>
        </section>

        <section id="langrefupd21-at-check">
          <title><database>CHECK</database> accepts <constant>NULL</constant> outcome</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>If a <database>CHECK</database> constraint resolves to <constant>NULL</constant>,
            Firebird versions before 2.0 reject the input. Following the SQL standard to the letter,
            Firebird 2.0 and above let <constant>NULL</constant>s pass and only consider the check
            failed if the outcome is <constant>false</constant>. For more information see under
            <link linkend="langrefupd21-ct-check"><database>CREATE TABLE</database></link>.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-at-fk-noexclusive">
          <title><database>FOREIGN KEY</database> creation no longer requires exclusive
          access</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 and above, adding a foreign key constraint no longer requires
            exclusive access to the database.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-at-unique-keys">
          <title><database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple
            – are now allowed in columns with a <database>UNIQUE</database> constraint. For a full
            discussion, see <link linkend="langrefupd21-ct-unique-keys"><citetitle><database>CREATE
            TABLE</database> :: <database>UNIQUE</database> constraints now allow
            <constant>NULL</constant>s</citetitle></link>.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-at-using-index">
          <title><database>USING INDEX</database> subclause</title>

          <formalpara>
            <title>Available in</title>

            <para>DSQL</para>

            <!--ESQL: no support found in source-->
          </formalpara>

          <formalpara>
            <title>Added in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>A <database>USING INDEX</database> subclause can be placed at the end of a
            primary, unique or foreign key definition. Its purpose is to<itemizedlist
                spacing="compact">
                <listitem>
                  <para>provide a user-defined name for the automatically created index that
                  enforces the constraint, and</para>
                </listitem>

                <listitem>
                  <para>optionally define the index to be ascending or descending (the default being
                  ascending).</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>[ADD] [CONSTRAINT <replaceable>constraint-name</replaceable>]
<replaceable>   &lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
              </blockquote></para>
          </formalpara>

          <para>For a full discussion and examples, see <link
          linkend="langrefupd21-ct-using-index"><citetitle><database>CREATE TABLE</database> ::
          <database>USING INDEX</database> subclause</citetitle></link>.</para>
        </section>
      </section>

      <section id="langrefupd21-recreate-table">
        <title><database>RECREATE TABLE</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates or recreates a table. If a table with the same name already exists,
          <database>RECREATE TABLE</database> will try to drop it (destroying all its data in the
          process!) and create a new table. <database>RECREATE TABLE</database> will fail if the
          existing table is in use.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as <link linkend="langrefupd21-create-table"><database>CREATE
          TABLE</database></link>.</para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-ddl-trigger">
      <title><database>TRIGGER</database></title>

      <para></para>

      <section id="langrefupd21-create-trigger">
        <title><database>CREATE TRIGGER</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates a trigger, i.e. a block of PSQL code that is executed automatically upon
          certain database events or mutations to a table or view.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <!--DATABASE TRIGGERS SUPPORTED IN ESQL ???-->

              <programlisting>CREATE TRIGGER <replaceable>name</replaceable>
   {<replaceable>&lt;relation_trigger_legacy&gt;</replaceable>
      | <replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>
      | <replaceable>&lt;database_trigger&gt;</replaceable>        }
   AS
      [<replaceable>&lt;declarations&gt;</replaceable>]
   BEGIN
      [<replaceable>&lt;statements&gt;</replaceable>]
   END

<replaceable>&lt;relation_trigger_legacy&gt;</replaceable>   ::=  FOR {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
                                 [ACTIVE | INACTIVE]
                                 {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
                                 [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>  ::=  [ACTIVE | INACTIVE]
                                 {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
                                 [POSITION <replaceable>number</replaceable>]
                                 ON {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}

<replaceable>&lt;database_trigger&gt;</replaceable>          ::=  [ACTIVE | INACTIVE]
                                 ON <replaceable>db_event</replaceable>
                                 [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;mutation_list&gt;</replaceable>             ::=  <replaceable>mutation</replaceable> [OR <replaceable>mutation</replaceable> [OR <replaceable>mutation</replaceable>]]
<replaceable>mutation</replaceable>                    ::=  INSERT | UPDATE | DELETE

<replaceable>db_event</replaceable>                    ::=  CONNECT | DISCONNECT | TRANSACTION START
                                   | TRANSACTION COMMIT | TRANSACTION ROLLBACK

<replaceable>number</replaceable>                      ::=  0..32767 (default is 0)

<replaceable>&lt;declarations&gt;</replaceable>              ::=  See <link
                  linkend="langrefupd21-psql-declare">PSQL::DECLARE</link> for the exact syntax</programlisting>

              <itemizedlist>
                <listitem>
                  <para><quote>Legacy</quote> and <quote>sql2003</quote> relation triggers are
                  exactly the same. The only thing that differs is the creation syntax.</para>
                </listitem>

                <listitem>
                  <para>Triggers with lower position numbers fire first. Position numbers need not
                  be unique, but if two or more triggers have the same position, the firing order
                  between them is undefined.</para>
                </listitem>

                <listitem>
                  <para>When defining relation triggers, each mutation type
                  (<database>INSERT</database>, <database>UPDATE</database> or
                  <database>DELETE</database>) may occur at most once in the mutation list.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>

        <section id="langrefupd21-create-trigger-on-syntax">
          <title>SQL-2003-compliant syntax for relation triggers</title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Since Firebird 2.1, an alternative, SQL-2003-compliant syntax can be used for
            triggers on tables and views. Instead of specifying <quote><database>FOR</database>
            <replaceable>relationname</replaceable></quote> before the event type and the optional
            directives surrounding it, you can now put <quote><database>ON</database>
            <replaceable>relationname</replaceable></quote> after it, as shown in the syntax earlier
            in this chapter.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create trigger biu_books
  active before insert or update position 3
  on books
as
begin
  if (new.id is null)
    then new.id = next value for gen_bookids;
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-create-trigger-dbtriggers">
          <title>Database triggers</title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Since Firebird 2.1, triggers can be defined to fire upon the database events
            <database>CONNECT</database>, <database>DISCONNECT</database>, <database>TRANSACTION
            START</database>, <database>TRANSACTION COMMIT</database> and <database>TRANSACTION
            ROLLBACK</database>. Only the database owner and <database>SYSDBA</database> can create,
            alter and drop these triggers.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>CREATE TRIGGER <replaceable>name</replaceable>
   [ACTIVE | INACTIVE]
   ON <replaceable>db_event</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
      [<replaceable>&lt;declarations&gt;</replaceable>]
   BEGIN
      [<replaceable>&lt;statements&gt;</replaceable>]
   END

<replaceable>db_event</replaceable>                    ::=  CONNECT | DISCONNECT | TRANSACTION START
                                   | TRANSACTION COMMIT | TRANSACTION ROLLBACK

<replaceable>number</replaceable>                      ::=  0..32767 (default is 0)

<replaceable>&lt;declarations&gt;</replaceable>              ::=  See <link
                    linkend="langrefupd21-psql-declare">PSQL::DECLARE</link> for the exact syntax</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create trigger tr_connect
  on connect
as
begin
  insert into dblog (wie, wanneer, wat)
    values (current_user, current_timestamp, 'verbind');
end</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Execution of database triggers and handling of exceptions</title>

            <para><itemizedlist>
                <listitem>
                  <para><database>CONNECT</database> and <database>DISCONNECT</database> triggers
                  are executed in a transaction created specifically for this purpose. If all goes
                  well, the transaction is committed. Uncaught exceptions roll back the transaction,
                  and:</para>

                  <itemizedlist spacing="compact">
                    <listitem>
                      <para>In the case of a <database>CONNECT</database> trigger, the connection is
                      then broken and the exception returned to the client.</para>
                    </listitem>

                    <listitem>
                      <para>With a <database>DISCONNECT</database> trigger, exceptions are not
                      reported and the connection is broken as foreseen.</para>
                    </listitem>
                  </itemizedlist>

                  <!--Bovenstaande heb ik uitgeprobeerd en het klopt. Als een CONNECT-trigger een exceptie
geeft, kun je dus NIET in de database, tenzij met isql -nodbtriggers !-->

                  <!--Do TRANSACTION triggers fire in this specific transaction?-->
                </listitem>

                <listitem>
                  <para><database>TRANSACTION</database> triggers are executed within the
                  transaction whose opening, committing or rolling-back evokes them. The actions
                  taken after an uncaught exception depend on the type:</para>

                  <itemizedlist spacing="compact">
                    <listitem>
                      <para>In a <database>START</database> trigger, the exception is reported to
                      the client and the transaction is rolled back.</para>
                    </listitem>

                    <listitem>
                      <para>In a <database>COMMIT</database> trigger, the exception is reported, the
                      trigger's actions so far are undone and the commit is canceled.</para>
                    </listitem>

                    <listitem>
                      <para>In a <database>ROLLBACK</database> trigger, the exception is not
                      reported and the transaction is rolled back as foreseen.</para>
                    </listitem>
                  </itemizedlist>

                  <!--Find out: if the 3rd TRANSACTION COMMIT trigger excepts, is the work of the previous two
also undone?-->
                </listitem>

                <listitem>
                  <para>It follows from the above that there is no direct way of knowing if a
                  <database>DISCONNECT</database> or <database>TRANSACTION ROLLBACK</database>
                  trigger caused an exception.</para>
                </listitem>

                <listitem>
                  <para>It also follows that you can't connect to a database if a
                  <database>CONNECT</database> trigger causes an exception, and that you can't start
                  a transaction if a <database>TRANSACTION START</database> trigger does the same.
                  Both phenomena effectively lock you out of your database while you need to get in
                  there to fix the problem. See the note below for a way around this Catch-22
                  situation.</para>
                </listitem>

                <listitem>
                  <para>In the case of a two-phase commit, <database>TRANSACTION COMMIT</database>
                  triggers fire in the prepare, not the commit phase.</para>

                  <!--And how about START and ROLLBACK triggers?-->
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <note>
            <para>Some Firebird command-line tools have been supplied with new switches to suppress
            the automatic firing of database triggers:</para>

            <blockquote>
              <programlisting>gbak -nodbtriggers
isql -nodbtriggers
nbackup -T</programlisting>
            </blockquote>

            <para>These switches can only be used by the database owner and
            <database>SYSDBA</database>.</para>

            <!--Find out: is there an API equivalent for this? Otherwise you can't access
databases with an exception-raising CONNECT trigger other than with isql !-->
          </note>
        </section>

        <section id="langrefupd21-create-trigger-multiaction">
          <title>Multi-action triggers</title>

          <formalpara>
            <title>Added in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Relation triggers can be defined to fire upon multiple operations
            (<database>INSERT</database> and/or <database>UPDATE</database> and/or
            <database>DELETE</database>). Three new boolean context variables
            (<varname>INSERTING</varname>, <varname>UPDATING</varname> and
            <varname>DELETING</varname>) have been added so you can execute code conditionally
            within the trigger body depending on the type of operation.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create trigger biu_parts for parts
  before insert or update
as
begin
  /* conditional code when inserting: */
  if (inserting and new.id is null)
    then new.id = gen_id(gen_partrec_id, 1);
  
  /* common code: */
  new.partname_upper = upper(new.partname);
end</programlisting>
              </blockquote></para>
          </formalpara>

          <note>
            <para>In multi-action triggers, both context variables <database>OLD</database> and
            <database>NEW</database> are always available. If you use them in the wrong situation
            (i.e. <database>OLD</database> while inserting or <database>NEW</database> while
            deleting), the following happens:</para>

            <itemizedlist spacing="compact">
              <listitem>
                <para>If you try to read their field values, <constant>NULL</constant> is
                returned.</para>
              </listitem>

              <listitem>
                <para>If you try to assign values to them, a runtime exception is thrown.</para>
              </listitem>
            </itemizedlist>
          </note>
        </section>

        <section id="langrefupd21-create-trigger-empty">
          <title><database>BEGIN ... END</database> blocks may be empty</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
            allowing you to write stub code without having to resort to dummy statements.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-create-trigger-changecount">
          <title><database>CREATE TRIGGER</database> no longer increments table change count</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In contrast to InterBase, Firebird does not increment the metadata change counter
            of the associated table when <database>CREATE</database>, <database>ALTER</database> or
            <database>DROP TRIGGER</database> is used. For a full discussion, see <link
            linkend="langrefupd21-alter-trigger-changecount"><citetitle><database>ALTER
            TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-create-trigger-plan">
          <title><database>PLAN</database> allowed in trigger code</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
            would be rejected by the compiler. Now a valid plan can be included and will be
            used.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-alter-trigger">
        <title><database>ALTER TRIGGER</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Alters an existing trigger. Relation triggers cannot be changed into database
          triggers or vice versa. The associated table or view of a relation trigger cannot be
          changed.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <!--DATABASE TRIGGERS SUPPORTED IN ESQL ???-->

              <programlisting>ALTER TRIGGER <replaceable>name</replaceable>
   [ACTIVE | INACTIVE]
   [{BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable> | ON <replaceable>db_event</replaceable>]
   [POSITION <replaceable>number</replaceable>]
   [AS
       [<replaceable>&lt;declarations&gt;</replaceable>]
    BEGIN
       [<replaceable>&lt;statements&gt;</replaceable>]
    END                ]</programlisting>

              <itemizedlist>
                <listitem>
                  <para>See <link linkend="langrefupd21-create-trigger"><database>CREATE
                  TRIGGER</database></link> syntax for the meaning of
                  <replaceable>&lt;mutation_list&gt;</replaceable> etc.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>

        <section id="langrefupd21-alter-trigger-dbtriggers">
          <title>Database triggers</title>

          <formalpara>
            <title>Added in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>The <database>ALTER TRIGGER</database> syntax (see above) has been extended to
            support database triggers. For a full discussion of this feature, see <link
            linkend="langrefupd21-create-trigger-dbtriggers"><citetitle><database>CREATE
            TRIGGER</database> :: Database triggers</citetitle></link>.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-trigger-multiaction">
          <title>Multi-action triggers</title>

          <formalpara>
            <title>Added in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>The <database>ALTER TRIGGER</database> syntax (see above) has been extended to
            support multi-action triggers. For a full discussion of this feature, see <link
            linkend="langrefupd21-create-trigger-multiaction"><citetitle><database>CREATE
            TRIGGER</database> :: Multi-action triggers</citetitle></link>.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-trigger-restr">
          <title>Restriction on altering used triggers</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0, 2.0.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-trigger-plan">
          <title><database>PLAN</database> allowed in trigger code</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
            would be rejected by the compiler. Now a valid plan can be included and will be
            used.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-alter-trigger-changecount">
          <title><database>ALTER TRIGGER</database> no longer increments table change count</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Each time you use <database>CREATE</database>, <database>ALTER</database> or
            <database>DROP TRIGGER</database>, InterBase increments the metadata change counter of
            the associated table. Once that counter reaches 255, no more metadata changes are
            possible on the table (you can still work with the data though). A backup-restore cycle
            is needed to reset the counter and perform metadata operations again.</para>
          </formalpara>

          <para>While this obligatory cleanup after many metadata changes is in itself a useful
          feature, it also means that users who regularly use <database>ALTER TRIGGER</database> to
          deactivate triggers during e.g. bulk import operations are forced to backup and restore
          much more often then needed.</para>

          <para>Since changes to triggers don't imply structural changes to the table itself,
          Firebird no longer increments the table change counter when <database>CREATE</database>,
          <database>ALTER</database> or <database>DROP TRIGGER</database> is used. One thing has
          remained though: once the counter is at 255, you can no longer create, alter or drop
          triggers for that table.</para>
        </section>
      </section>

      <section id="langrefupd21-create-or-alter-trigger">
        <title><database>CREATE OR ALTER TRIGGER</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>If the trigger does not yet exist, it is created just as if <database>CREATE
          TRIGGER</database> were used. If it already exists, it is altered and recompiled. Existing
          permissions and dependencies are preserved.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as for <database>CREATE TRIGGER</database>.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-drop-trigger">
        <title><database>DROP TRIGGER</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-drop-trigger-restr">
          <title>Restriction on dropping used triggers</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0, 2.0.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-drop-trigger-changecount">
          <title><database>DROP TRIGGER</database> no longer increments table change count</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In contrast to InterBase, Firebird does not increment the metadata change counter
            of the associated table when <database>CREATE</database>, <database>ALTER</database> or
            <database>DROP TRIGGER</database> is used. For a full discussion, see <link
            linkend="langrefupd21-alter-trigger-changecount"><citetitle><database>ALTER
            TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-recreate-trigger">
        <title><database>RECREATE TRIGGER</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates or recreates a trigger. If a trigger with the same name already exists,
          <database>RECREATE TRIGGER</database> will try to drop it and create a new trigger.
          <database>RECREATE TRIGGER</database> will fail if the existing trigger is in use.<!--Make sure this last statement is true!--></para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as <link linkend="langrefupd21-create-trigger"><database>CREATE
          TRIGGER</database></link>.</para>
        </formalpara>

        <section id="langrefupd21-recreate-trigger-restr">
          <title>Restriction on recreating used triggers</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0, 2.0.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>
    </section>

    <section id="langrefupd21-ddl-view">
      <title><database>VIEW</database></title>

      <para></para>

      <section id="langrefupd21-create-view">
        <title><database>CREATE VIEW</database></title>

        <!--In the 2.0 Rlsnotes:
  Changed Logic for View Updates
  Apply NOT NULL constraints to base tables only, ignoring the ones inherited by view columns
  from domain definitions.

This looked weird: view columns can't specify a datatype or domain, so how in the world
can they inherit a NOT NULL constraint from a domain, *other than through the base table* ?!

Reaction Dmitry: "IIRC, this change allows to pass NULLs to views that are made updateable 
via triggers (as they can override that value with something valid)."

Some testing revealed that 1.5 had a problem, not with not-null fields that participated in the
view (as long as a trigger converted the nulls before submitting the data to the table), but with
not-null fields that were left out of the view - even if a trigger supplied a valid value for
them. For those columns you would get a validation error. This has been fixed in 2.0-->

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>
        </formalpara>

        <section id="langrefupd21-creatview-colaliases">
          <title>Per-column aliases supported in view definition</title>

          <!--Aangezien in 2.0 de volledige SELECT-syntaxis al was toegestaan voor views, ga in 2.0 na:
- of column aliases in de SELECT zijn toegestaan, en zo ja:
- of ze inderdaad worden overgenomen als viewkolomnaam, en zo ja:
- of ze in voorkomende gevallen de volledige kolomnamenlijst overbodig kunnen maken.-->

          <formalpara>
            <title>Changed in</title>

            <para>2.1</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2.1 and up allow the use of column aliases in the
            <database>SELECT</database> statement. You can alias none, some or all of the columns;
            each alias used becomes the name of the corresponding view column.</para>
          </formalpara>

          <formalpara>
            <title>Syntax (partial)</title>

            <para><blockquote>
                <programlisting>CREATE VIEW viewname [<replaceable>&lt;full_column_list&gt;</replaceable>]
   AS
   SELECT <replaceable>&lt;column_def&gt;</replaceable> [, <replaceable>&lt;column_def&gt;</replaceable> ...]
   FROM ...
   [WITH CHECK OPTION]

<replaceable>&lt;full_column_list&gt;</replaceable>  ::=  (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])

<replaceable>&lt;column_def&gt;</replaceable>        ::=  {<replaceable>source_col</replaceable> | <replaceable>expr</replaceable>} [[AS] <replaceable>colalias</replaceable>]</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>If the full column list is also present, specifying column aliases is futile
                  as they will be overridden by the names in the column list.</para>
                </listitem>

                <listitem>
                  <para>The full column list used to be mandatory for views whose
                  <database>SELECT</database> statement contains expression-based columns or
                  identical column names. Now you can omit the full column list, provided that you
                  alias the offending columns in the <database>SELECT</database> clause.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>

        <section id="langrefupd21-creatview-fullselect">
          <title>Full <database>SELECT</database> syntax supported</title>

          <!--IB6 LangRef p.88: UNIONs in views supported in ESQL, but not in DSQL.-->

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>From Firebird 2.0 onward view definitions are considered full-fledged
            <database>SELECT</database> statements. Consequently, the following elements are
            (re)allowed in view definitions: <database>FIRST</database>, <database>SKIP</database>,
            <database>ROWS</database>, <database>ORDER BY</database>, <database>PLAN</database> and
            <database>UNION</database>.</para>

            <!--Views with unions only work in 2.0 if you include a view column list.
See tracker item CORE-1402 (for 2.1, unresolved as of 29 Oct 2008).-->
          </formalpara>

          <note>
            <para>The use of a <database>UNION</database> within a view is currently only supported
            if you supply a column list for the view (this list is normally optional):</para>

            <programlisting>create view vplanes <emphasis role="bold">(make, model)</emphasis> as
  select make, model from jets
    union
  select make, model from props
    union
  select make, model from gliders</programlisting>
          </note>
        </section>

        <section id="langrefupd21-creatview-noplan">
          <title><database>PLAN</database> subclause disallowed in 1.5</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5, 2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird versions 1.5.x forbid the use of a <database>PLAN</database> subclause in
            a view definition. From 2.0 onward a PLAN is allowed again.</para>
          </formalpara>
        </section>

        <section id="langrefupd21-creatview-triggers">
          <title>Triggers on updatable views block auto-writethrough</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In versions prior to 2.0, Firebird often did not block the automatic writethrough
            to the underlying table if one or more triggers were defined on a naturally updatable
            view. This could cause mutations to be performed twice unintentionally, sometimes
            leading to data corruption and other mishaps. Starting at Firebird 2.0, this
            misbehaviour has been corrected: now if you define a trigger on a naturally updatable
            view, no mutations to the view will be automatically passed on to the table; either your
            trigger takes care of that, or nothing will. This is in accordance with the description
            in the InterBase 6 <citetitle>Data Definition Guide</citetitle> under
            <citetitle>Updating views with triggers</citetitle>.</para>
          </formalpara>

          <warning>
            <para>Some people have developed code that counts on or takes advantage of the prior
            behaviour. Such code should be corrected for Firebird 2.0 and higher, or mutations may
            not reach the table at all.</para>
          </warning>
        </section>

        <section id="langrefupd21-creatview-insertable">
          <title>View with non-participating <database>NOT NULL</database> columns in base table can
          be made insertable</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Any view whose base table contains one or more non-participating <database>NOT
            NULL</database> columns is read-only by nature. It can be made updatable by the use of
            triggers, but even with those, all <database>INSERT</database> attempts into such views
            used to fail because the <database>NOT NULL</database> constraint on the base table was
            checked before the view trigger got a chance to put things right. In Firebird 2.0 and up
            this is no longer the case: provided the right trigger is in place, such views are now
            insertable.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <para>The view below would give validation errors for any insert attempts in
                Firebird 1.5 and earlier. In Firebird 2.0 and up it is insertable:</para>

                <programlisting>create table base (x int not null, y int not null);

create view vbase as select x from base;

set term #;
create trigger bi_base for vbase before insert
as
begin
  if (new.x is null) then new.x = 33;
  insert into base values (new.x, 0);
end#
set term ;#</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>Please notice that the problem described above only occured for
                  <database>NOT NULL</database> columns that were left <emphasis>outside</emphasis>
                  the view.</para>
                </listitem>

                <listitem>
                  <para>Oddly enough, the problem would be gone if the base table itself had a
                  trigger converting <constant>NULL</constant> input to something valid.<!--Geldt dat ook als het toevoegen van de trigger de view NIET updatable maakt in de ogen van
Firebird? Test uit met bijv. een join.--> But then there was a risk that the insert would take place
                  twice, due to the <link
                  linkend="langrefupd21-creatview-triggers">auto-writethrough bug</link> that has
                  also been fixed in Firebird 2.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-recreate-view">
        <title><database>RECREATE VIEW</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: No support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Creates or recreates a view. If a view with the same name already exists,
          <database>RECREATE VIEW</database> will try to drop it and create a new view.
          <database>RECREATE VIEW</database> will fail if the existing view is in use.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para>Exactly the same as <link linkend="langrefupd21-create-view"><database>CREATE
          VIEW</database></link>.</para>
        </formalpara>
      </section>
    </section>

    <!--None of the "CREATE OR ALTER" statements seems available in ESQL:-->

    <!--RECREATE seems totally absent from ESQL-->
  </chapter>

  <chapter id="langrefupd21-dml">
    <title>DML statements</title>

    <!--Rlsnotes 1.0:
  New PLANONLY option for statements
  Support for PLANONLY setting, allows for a statement/query to be submitted to the engine and
  the plan retrieved, without executing the statement/query.

As it turns out, this refers to SET PLANONLY in isql. You can NOT just add PLANONLY
to SQL statements!-->

    <section id="langrefupd21-delete">
      <title><database>DELETE</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Deletes rows from a database table (or from one or more tables underlying a view),
        depending on the <database>WHERE</database> and <database>ROWS</database> clauses.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <!--Both IB6 LangRef and IBP RefGuide forget to mention views.-->

            <!--DELETE and UPDATE allow a table/view alias, also in 1.5.3.
Find out since when (this is not mentioned in IB LangRef) and document it
with DELETE and UPDATE, possibly also in LangRefUpd-1.5-->

            <programlisting>DELETE
   [TRANSACTION <replaceable>name</replaceable>]
   FROM {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [<replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>

            <note>
              <title>Restrictions</title>

              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>

                <listitem>
                  <para><database>WHERE CURRENT OF</database> is only available in ESQL and
                  PSQL.</para>
                </listitem>

                <listitem>
                  <para>The <database>PLAN</database>, <database>ORDER BY</database> and
                  <database>ROWS</database> clauses are not available in ESQL.</para>
                </listitem>
              </itemizedlist>
            </note>

            <!--Are only 'loose' plan_items allowed, or also JOIN, SORT, MERGE ?-->
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-delete-orderby">
        <title><database>ORDER BY</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>DELETE</database> now allows an <database>ORDER BY</database> clause. This
          only makes sense in combination with <database>ROWS</database>, but is also valid without
          it.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-delete-plan">
        <title><database>PLAN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>DELETE</database> now allows a <database>PLAN</database> clause, so users
          can optimize the operation manually.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-delete-rows">
        <title><database>ROWS</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Limits the amount of rows deleted to a specified number or range.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            </blockquote></para>
        </formalpara>

        <para>With a single argument <replaceable>m</replaceable>, the deletion is limited to the
        first <replaceable>m</replaceable> rows of the dataset defined by the table or view and the
        optional <database>WHERE</database> and <database>ORDER BY</database> clauses.</para>

        <para>Points to note:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is deleted.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> = 0, no rows are deleted.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>

        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, the
        deletion is limited to rows <replaceable>m</replaceable> to <replaceable>n</replaceable>
        inclusively. Row numbers are 1-based.</para>

        <para>Points to note when using two arguments:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, no
            rows are deleted.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are deleted.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, no rows are
            deleted.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>

        <!--Neem wat de laatste 2 punten betreft contact op met Dmitry: is dit zo bedoeld?
Zo nee, tekst eventueel aanpassen.-->

        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd21-select-rows"><database>SELECT</database></link> and <link
        linkend="langrefupd21-update-rows"><database>UPDATE</database></link> statements.</para>
      </section>
    </section>

    <section id="langrefupd21-execblock">
      <title><database>EXECUTE BLOCK</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Executes a block of PSQL code as if it were a stored procedure, optionally with input
        and output parameters and variable declarations. This allows the user to perform
        <quote>on-the-fly</quote> PSQL within a DSQL context.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
[<replaceable>&lt;var-decls&gt;</replaceable>]
BEGIN
  <replaceable>PSQL statement(s)</replaceable>
END

<replaceable>&lt;inparams&gt;</replaceable>   ::=  <replaceable>paramname</replaceable> <replaceable>type</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable>]
<replaceable>&lt;outparams&gt;</replaceable>  ::=  <replaceable>paramname</replaceable> <replaceable>type</replaceable> [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;var-decls&gt;</replaceable>  ::=  <replaceable>&lt;var-decl&gt;</replaceable> [<replaceable>&lt;var-decls&gt;</replaceable>]
<replaceable>&lt;var-decl&gt;</replaceable>   ::=  DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>type</replaceable> [= <replaceable>initvalue</replaceable>];</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>This example injects the numbers 0 through 127 and their corresponding ASCII
            characters into the table <database>ASCIITABLE</database>:</para>

            <programlisting>execute block
as
declare i int = 0;
begin
  while (i &lt; 128) do
  begin
    insert into AsciiTable values (:i, ascii_char(:i));
    i = i + 1;
  end
end</programlisting>
          </blockquote><blockquote>
            <para>The next example calculates the geometric mean of two numbers and returns it to
            the user:</para>

            <programlisting>execute block (x double precision = ?, y double precision = ?)
returns (gmean double precision)
as
begin
  gmean = sqrt(x*y);
  suspend;
end</programlisting>

            <para>Because this block has input parameters, it has to be prepared first. Then the
            parameters can be set and the block executed. It depends on the client software how this
            must be done and even if it is possible at all – see the notes below.</para>

            <para>Our last example takes two integer values, <varname>smallest</varname> and
            <varname>largest</varname>. For all the numbers in the range <varname>smallest</varname>
            .. <varname>largest</varname>, the block outputs the number itself, its square, its cube
            and its fourth power.</para>

            <programlisting>execute block (smallest int = ?, largest int = ?)
returns (number int, square bigint, cube bigint, fourth bigint)
as
begin
  number = smallest;
  while (number &lt;= largest) do
  begin
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    suspend;
    number = number + 1;
  end
end</programlisting>

            <para>Again, it depends on the client software if and how you can set the parameter
            values.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Some clients, especially those allowing the user to submit several statements at
              once, may require you to surround the <database>EXECUTE BLOCK</database> statement
              with <database>SET TERM</database> lines, like this:</para>

              <programlisting>set term #;
execute block (...)
as
begin
  statement1;
  statement2;
end
#
set term ;#</programlisting>

              <para>In Firebird's <application>isql</application> client you must set the terminator
              to something other than <quote><literal>;</literal></quote> before you type in the
              <database>EXECUTE BLOCK</database> statement. Otherwise
              <application>isql</application>, being line-oriented, will try to execute the part you
              have entered as soon as it encounters the first semicolon.</para>
            </listitem>

            <listitem>
              <para>Executing a block without input parameters should be possible with every
              Firebird client that allows the user to enter his or her own DSQL statements. If there
              are input parameters, things get trickier: these parameters must get their values
              after the statement is prepared but before it is executed. This requires special
              provisions, which not every client application offers. (Firebird's own
              <application>isql</application>, for one, doesn't.)</para>
            </listitem>

            <listitem>
              <para>The server only accepts question marks (<quote><literal>?</literal></quote>) as
              placeholders for the input values, not <quote><literal>:a</literal></quote>,
              <quote><literal>:MyParam</literal></quote> etc., or literal values. Client software
              may support the <quote><literal>:xxx</literal></quote> form though, which it will
              preprocess before sending it to the server.</para>
            </listitem>

            <listitem>
              <para>If the block has output parameters, you <emphasis>must</emphasis> use
              <database>SUSPEND</database> or nothing will be returned.</para>
            </listitem>

            <listitem>
              <para>Output is always returned in the form of a result set, just as with a
              <database>SELECT</database> statement. You can't use
              <database>RETURNING_VALUES</database> or execute the block <database>INTO</database>
              some variables, even if there's only one result row.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Executes a stored procedure. In Firebird 1.0.x as well as in InterBase, any input
        parameters for the SP must be supplied as literals, host language variables (in ESQL) or
        local variables (in PSQL). In Firebird 1.5 and above, input parameters may also be
        (compound) expressions, except in static ESQL.</para>
      </formalpara>

      <!--Calling SP's with SELECT already allowed compound expressions as parameters in IB and Fb1.-->

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [TRANSACTION <replaceable>transaction</replaceable>]
   [<replaceable>&lt;in_item&gt;</replaceable> [, <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>   ::=  <replaceable>&lt;inparam&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable>  ::=  <replaceable>&lt;outvar&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;inparam&gt;</replaceable>   ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>    ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>   ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>

            <note>
              <title>Notes</title>

              <itemizedlist>
                <listitem>
                  <para><database>TRANSACTION</database> clauses are not supported in PSQL.</para>

                  <!--And in DSQL they are? That would surprise me. Find out!-->
                </listitem>

                <listitem>
                  <para>Expression parameters are not supported in static ESQL, and not in Firebird
                  versions below 1.5.</para>
                </listitem>

                <listitem>
                  <para><constant>NULL</constant> indicators are only valid in ESQL code. They must
                  be host language variables of type integer.</para>
                </listitem>

                <listitem>
                  <para>In ESQL, variable names used as parameters or outvars must be preceded by a
                  colon (<quote>:</quote>). In PSQL the colon is generally optional, but forbidden
                  for the trigger context variables <database>OLD</database> and
                  <database>NEW</database>.</para>

                  <!--When called with SELECT, the colon must always be present
if the parameter is a variable (except OLD/NEW).
(does this go for inparms as well as INTO outparms?)-->
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <para>In PSQL (with optional colons):</para>

            <programlisting>execute procedure MakeFullName
  :FirstName, :Middlename, :LastName
  returning_values :FullName;</programlisting>

            <para>The same call in ESQL (with obligatory colons):</para>

            <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :Middlename, :LastName
    returning_values :FullName;</programlisting>

            <para>...and in Firebird's command-line utility <application>isql (with literal
            parameters)</application>:</para>

            <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>

            <para><emphasis role="bold">Note:</emphasis> In isql, don't use
            <database>RETURNING_VALUES</database>. Any output values are shown automatically.</para>

            <para>Finally, a PSQL example with expression parameters, only possible in Firebird 1.5
            and up:</para>

            <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, Middlename, upper(LastName)
  returning_values FullName;</programlisting>
          </blockquote></para>
      </formalpara>

      <!--1.5 Release Notes say:

  Dmitry Yemanov
  Calls to EXECUTE PROCEDURE ProcName(<Argument-list>) and SELECT <Output-list> FROM
  ProcName(<Argument-list>) can now accept local variables (in PSQL) and expressions
  (in DSQL and PSQL) as arguments.

However:
- Local variables were already usable as arguments in InterBase.
- With SELECT, even expressions were already allowed as arguments in InterBase.
So the only novelty in Firebird 1.5 is:
- Using expressions as arguments when calling an SP with EXECUTE PROCEDURE.-->
    </section>

    <section id="langrefupd21-insert">
      <title><database>INSERT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Adds rows to a database table, or to one or more tables underlying a view. Field
        values can be given in the <database>VALUES</database> clause (in which case exactly one row
        is inserted) or they can come from a <database>SELECT</database> statement.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>INSERT [TRANSACTION <replaceable>name</replaceable>]
   INTO {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [(<replaceable>&lt;columns&gt;</replaceable>)]
   {VALUES (<replaceable>&lt;values&gt;</replaceable>) [RETURNING <replaceable>&lt;columns&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]
    | <replaceable>select_expr</replaceable>}

<replaceable>&lt;columns&gt;</replaceable>    ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>

            <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->

            <note>
              <title>Restrictions</title>

              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>

                <listitem>
                  <para>The <database>RETURNING</database> clause is not available in ESQL.</para>
                </listitem>

                <listitem>
                  <para>The <quote><database>INTO</database>
                  <replaceable>&lt;variables&gt;</replaceable></quote> subclause is only available
                  in PSQL.</para>
                </listitem>

                <listitem>
                  <para>The trigger context variables <database>OLD</database> and
                  <database>NEW</database> must not be preceded by a colon
                  (<quote><literal>:</literal></quote>).</para>
                </listitem>

                <listitem>
                  <para>New in 2.0: No column may appear more than once in the insert list.</para>
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-insert-returning">
        <title><database>RETURNING</database> clause</title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>An <database>INSERT</database> query – unless it is
          <database>SELECT</database>-based – may optionally specify a
          <database>RETURNING</database> clause to produce a result set containing the values that
          have been actually stored. The clause, if present, need not contain all of the insert
          columns and may also contain other columns or expressions. The returned values reflect any
          changes that may have been made in <database>BEFORE</database> tiggers, but not those in
          <database>AFTER</database> triggers.</para>

          <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->

          <!--Ga na of het ECHT onmogelijk is met een SELECT-gebaseerde INSERT. In 2.1 schijnt het vlg. rlsnotes wel te kunnen,
al moet het ook daar om singletonoperaties gaan.-->
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>insert into Scholars (firstname, lastname, address, phone, email)
  values ('Henry', 'Higgins', '27A Wimpole Street', '3231212', null)
  returning lastname, fullname, id</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-insert-from-union">
        <title><database>UNION</database> allowed in feeding <database>SELECT</database></title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A <database>SELECT</database> query used in an <database>INSERT</database> statement
          may now be a <database>UNION</database>.</para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>insert into Members (number, name)
  select number, name from NewMembers where Accepted = 1
    union
  select number, name from SuspendedMembers where Vindicated = 1</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-select">
      <title><database>SELECT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <section id="langrefupd21-aggregates">
        <title>Aggregate functions: Extended functionality</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Several types of mixing and nesting aggragate functions are supported since Firebird
          1.5. They will be discussed in the following subsections. To get the complete picture,
          also look at the <database>SELECT</database> :: <database>GROUP BY</database>
          sections.</para>
        </formalpara>

        <section id="langrefupd21-aggregates-mix">
          <title>Mixing aggregate functions from different contexts</title>

          <para>Firebird 1.5 and up allow the use of aggregate functions from different contexts
          inside a single expression.</para>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
              </blockquote></para>
          </formalpara>

          <para>This admittedly rather contrived query shows, in the second column, the maximum
          index selectivity of any index defined on a table, followed by the table's field count
          between parentheses. Of course you would normally display the field count in a separate
          column, or in the column with the table name, but the purpose here is to demonstrate that
          you can combine aggregates from different contexts in a single expression.</para>

          <warning>
            <para>Firebird 1.0 also executes this type of query, but gives the wrong results!</para>
          </warning>
        </section>

        <section id="langrefupd21-aggregates-in-subqueries">
          <title>Aggregate functions and <database>GROUP BY</database> items inside
          subqueries</title>

          <para>Since Firebird 1.5 it is possible to use aggregate functions and/or expressions
          contained in the <database>GROUP BY</database> clause inside a subquery.</para>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>This query returns each table's ID and field count. The subquery refers to
                <literal><systemitem>flds.rdb$relation_name</systemitem></literal>, which is also a
                <database>GROUP BY</database> item:</para>

                <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>

                <para>The next query shows the last field from each table and and its 1-based
                position. It uses the aggregate function <database>MAX</database> in a
                subquery.</para>

                <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>

                <para>The subquery also contains the <database>GROUP BY</database> item
                <systemitem>flds.rdb$relation_name</systemitem>, but that's not immediately obvious
                because in this case the <database>GROUP BY</database> clause uses the column
                number.</para>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-subqueries-in-aggregates">
          <title>Subqueries inside aggregate functions</title>

          <para>Using a singleton subselect inside (or as) an aggregate function argument is
          supported in Firebird 1.5 and up.</para>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>

                <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-aggregates-nesting">
          <title>Nesting aggregate function calls</title>

          <para>Firebird 1.5 allows the indirect nesting of aggregate functions, provided that the
          inner function is from a lower SQL context. Direct nesting of aggregate function calls, as
          in <quote><database>COUNT</database>( <database>MAX</database>( price ) )</quote>, is
          still forbidden and punishable by exception.</para>

          <formalpara>
            <title>Example</title>

            <para>See under <link
            linkend="langrefupd21-subqueries-in-aggregates"><citetitle>Subqueries inside aggregate
            functions</citetitle></link>, where <database>COUNT()</database> is used inside a
            <database>SUM()</database>.</para>
          </formalpara>

          <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
        </section>

        <section id="langrefupd21-aggregates-having-orderby">
          <title>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></title>

          <para>Firebird 1.5 and above are stricter than previous versions about what can be
          included in the <database>HAVING</database> and <database>ORDER BY</database> clauses. If,
          in the context of an aggregate statement, an operand in a <database>HAVING</database> or
          <database>ORDER BY</database> item contains a column name,<!--Dit zou vermoedelijk eigenlijk moeten zijn: ...contains a column name from the query context
(dwz van de tabel of join in de FROM-claus).--> it is only accepted if one of the following is
          true:</para>

          <itemizedlist>
            <listitem>
              <para>The column name appears in an aggregate function call (e.g. <quote><code>HAVING
              MAX(SALARY) &gt; 10000</code></quote>).</para>
            </listitem>

            <listitem>
              <para>The operand equals or is based upon a non-aggregate column that appears in the
              <database>GROUP BY</database> list (by name or position).</para>
            </listitem>
          </itemizedlist>

          <!--This listitem commented out for now, needs research:
  o  The operand equals or is based upon a subquery, whether or not it is also a GROUP BY item.-->

          <!--Zie ook onder GROUP BY. Ga na of het mogelijk is om een niet-geaggregeerde subquery in
de HAVING / ORDER BY op te nemen als die subquery kolommen bevat die niet in de GROUP BY
zitten. En als dit kan, kijk dan ook wat er gebeurt als die subquery binnen een groep
verschillende waarden retourneert.-->

          <para><quote>Is based upon</quote> means that the operand need not be exactly the same as
          the column name. Suppose there's a non-aggregate column
          <quote><database>STR</database></quote> in the select list. Then it's OK to use
          expressions like <quote><database>UPPER(STR)</database></quote>, <quote><database>STR ||
          '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4 FOR 2)</database></quote>
          in the <database>HAVING</database> clause – even if these expressions don't appear as such
          in the <database>SELECT</database> or <database>GROUP BY</database> list.</para>

          <!--If and when the subquery thing gets mentioned again, the above para must also be changed
("...as the column name or subquery." etc.)-->
        </section>
      </section>

      <!--1.5 Rlsnotes say:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used in the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->

      <!--*******

Misschien moet dat hele GROUP BY-gedoe zoiets worden:

Elke kolom die in niet-geaggregeerde vorm op het hoogste niveau in de context van een
geaggregeerde query voorkomt (dus een kolom is van de tabel(len) in de FROM)
moet in de GROUP BY voorkomen

Vraag: als zo'n kolom in een subquery voorkomt maar met het tabelalias van de bovenste
querycontext, moet-ie dan in de GROUP BY? Denk het wel... maar test!
Vraag 2: als hierboven, maar dan met een eigen alias, dus behorend bij de subselect?
Denk dat hij dan niet in de GROUP BY hoeft, maar test!
Vraag 3: als een tabel geen alias heeft in de bovenste FROM, en hij wordt in een subselect
ook zonder alias gebruikt, hebben ze dan dezelfde context? Ik hoop van niet...-->

      <section id="langrefupd21-select-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>

          <!--Not exactly specific for SELECT. Also for UPDATE and DELETE.-->
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-select-cte">
        <title>Common Table Expressions (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL? Suppose not, but do find out / ask-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.1</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A common table expression or <database>CTE</database> can best be decribed as a
          volatile view, defined on-the-fly in a preamble to a SELECT statement. The main statement
          can select from the <database>CTE</database>s defined in the preamble as if they were
          regular tables or views. <database>CTE</database>s can be recursive, i.e.
          self-referencing, but they can not be nested. Once the main statement has been executed,
          the <database>CTE</database>s go out of scope.</para>

          <!--Can the main statement also be a DELETE, UPDATE or INSERT?-->
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting><replaceable>&lt;cte-select&gt;</replaceable>        ::=  <replaceable>&lt;cte-preamble&gt;</replaceable>
                         <replaceable>&lt;select-statement&gt;</replaceable>

<replaceable>&lt;cte-preamble&gt;</replaceable>      ::=  WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]

<replaceable>&lt;cte&gt;</replaceable>               ::=  <replaceable>cte-name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-def&gt;</replaceable>)

<replaceable>&lt;column-list&gt;</replaceable>       ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]

<replaceable>&lt;cte-def&gt;</replaceable>           ::=  any <database>SELECT</database> query or <database>UNION

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  the main SELECT statement, which can tap from the
                         <database>CTE</database>s defined in the preamble</database></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <!--Example adapted from the one made by Vlad Khorsun (or Paul Ruizendaal?)-->

              <programlisting>with dept_year_budget as (
  select fiscal_year,
         dept_no,
         sum(projected_budget) as budget
  from proj_dept_budget
  group by fiscal_year, dept_no
)
select d.dept_no,
       d.department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from department d
     left join dept_year_budget dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join dept_year_budget dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009
where exists (
  select * from proj_dept_budget b
  where d.dept_no = b.dept_no
)</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>A <database>CTE</database> definition can contain any legal
                <database>SELECT</database> statement, as long as it doesn't have a
                <quote><database>WITH...</database></quote> preamble of its own (no nesting).</para>
              </listitem>

              <listitem>
                <para><database>CTE</database>s defined for the same query can reference each other,
                but care should be taken to avoid loops.</para>

                <!--Can a CTE also refer to another one that comes *after* it in the WITH clause?-->
              </listitem>

              <listitem>
                <para>Just like regular views, <database>CTE</database>s can be referenced from
                anywhere in the main query.</para>
              </listitem>

              <listitem>
                <para>Just like a regular view, a <database>CTE</database> can be referenced
                multiple times in the main query, possibly with different aliases.</para>
              </listitem>

              <!--Table expressions (as subqueries) can be used in INSERT, UPDATE and DELETE statements
-> find out more about this before documenting it-->
            </itemizedlist></para>
        </formalpara>

        <section id="langrefupd21-select-cte-recursive">
          <title>Recursive <database>CTE</database>s</title>

          <para>A recursive (self-referencing) <database>CTE</database> is a
          <database>UNION</database> which must have at least one non-recursive member, the
          <firstterm>anchor</firstterm>. The non-recursive member(s) must be placed before the
          recursive member(s). Recursive members are linked to each other and to their non-recursive
          neighbour by <database>UNION ALL</database> operators. The unions between non-recursive
          members may be of any type.</para>

          <para>Recursive <database>CTE</database>s require the <database>RECURSIVE</database>
          keyword to be present right after <database>WITH</database>. Each recursive union member
          may reference itself only once, and it must do so in a <database>FROM</database>
          clause.</para>

          <para>A great benefit of recursive <database>CTE</database>s is that they use far less
          memory and CPU cycles than an equivalent recursive stored procedure.</para>

          <!--Find out:
- May the recursive reference occur in any FROM clause in the recursive union member, or only
  in the member's main (outermost) FROM clause?
- Can the RECURSIVE keyword be repeated before each (recursive) CTE?-->

          <para>The execution pattern of a recursive <database>CTE</database> is as follows:</para>

          <itemizedlist>
            <listitem>
              <para>The engine begins execution from a non-recursive member.</para>
            </listitem>

            <listitem>
              <para>For each row evaluated, it starts executing each recursive member one-by-one,
              using the current values from the outer row as parameters.</para>
            </listitem>

            <listitem>
              <para>If the currently executing instance of a recursive member produces no rows,
              execution loops back one level and gets the next row from the outer result set.</para>
            </listitem>
          </itemizedlist>

          <!--I wonder if this is entirely correct. Don't all the recursive union members each present a next
lower level in the execution pattern?
Also, to whom should I give credit for this text (if I use it): Vlad or Paul?-->

          <formalpara>
            <title>Example with a recursive <database>CTE</database></title>

            <para><blockquote>
                <!--Example adapted from the one made by Vlad Khorsun (or Paul Ruizendaal?)-->

                <programlisting>with recursive
  dept_year_budget as (
    select fiscal_year,
           dept_no,
           sum(projected_budget) as budget
    from proj_dept_budget
    group by fiscal_year, dept_no
  ),
  dept_tree as (
    select dept_no,
           head_dept,
           department,
           cast('' as varchar(255)) as indent
    from department
    where head_dept is null
    union all
    select d.dept_no,
           d.head_dept,
           d.department,
           h.indent || '  '
    from department d
         join dept_tree h on d.head_dept = h.dept_no
  )
select d.dept_no,
       d.indent || d.department as department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from dept_tree d
     left join dept_year_budget dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join dept_year_budget dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Notes on recursive <database>CTE</database>s</title>

            <para><itemizedlist>
                <listitem>
                  <para>Aggregates (<database>DISTINCT</database>, <database>GROUP BY</database>,
                  <database>HAVING</database>) and aggregate functions (<database>SUM</database>,
                  <database>COUNT</database>, <database>MAX</database> etc) are not allowed in
                  recursive union members.</para>
                </listitem>

                <listitem>
                  <para>A recursive reference cannot participate in an outer join.</para>
                </listitem>

                <listitem>
                  <para>The maximum recursion depth is hard-coded as 1024.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-derived-tables">
        <title>Derived tables (<quote><database>SELECT FROM SELECT</database></quote>)</title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A derived table is the result set of a <database>SELECT</database> query, used in an
          outer <database>SELECT</database> as if it were an ordinary table. Syntactically, it is a
          subquery in the <database>FROM</database> clause.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>(<replaceable>select-query</replaceable>)
   [[AS] <replaceable>derived-table-alias</replaceable>]
   [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

<replaceable>&lt;derived-column-aliases&gt;</replaceable>  :=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>The derived table in the query below (shown in boldface) contains all the
              relation names in the database followed by their field count. The outer
              <database>SELECT</database> produces, for each existing field count, the number of
              relations having that field count.</para>

              <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>

              <para>A trivial example demonstrating the use of a derived table alias and column
              aliases list (both are optional):</para>

              <programlisting>select dbinfo.descr,
       dbinfo.def_charset
from   <emphasis role="bold">(select * from rdb$database) dbinfo
         (descr, rel_id, sec_class, def_charset)</emphasis></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Notes</title>

          <para><itemizedlist>
              <listitem>
                <para>Derived tables can be nested.</para>
              </listitem>

              <listitem>
                <para>Derived tables can be unions and can be used in unions. They can contain
                aggregate functions, subselects and joins, and can themselves be used in aggregate
                functions, subselects and joins. They can also be or contain queries on selectable
                stored procedures. They can have <database>WHERE</database>, <database>ORDER
                BY</database> and <database>GROUP BY</database> clauses, <database>FIRST</database>,
                <database>SKIP</database> or <database>ROWS</database> directives, etc. etc.</para>
              </listitem>

              <listitem>
                <para>Every column in a derived table <emphasis>must</emphasis> have a name. If it
                doesn't have one by nature (e.g. because it's a constant) it must either be given an
                alias in the usual way, or a column aliases list must be added to the derived table
                specification.</para>
              </listitem>

              <listitem>
                <para>The column aliases list is optional, but if it is used it must be complete.
                That is: it must contain an alias for every column in the derived table.</para>
              </listitem>

              <listitem>
                <para>The optimizer can handle a derived table very efficiently. However, if the
                derived table is involved in an inner join and contains a subquery, then no join
                order can be made.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>

      <section id="langrefupd21-first-skip">
        <title><database>FIRST</database> and <database>SKIP</database></title>

        <!--Seem unavailable in ESQL. But Dmitry writes to me: "Available since v1.0, I believe."
Checked again in gpre source (using SKIP search), and it really really really isn't there. So:-->

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.0</para>
        </formalpara>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Deprecated in</title>

          <para>2.0 – use <link
          linkend="langrefupd21-select-rows"><database>ROWS</database></link></para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>FIRST</database> limits the output of a query to the first so-many rows.
          <database>SKIP</database> will suppress the given number of rows before starting to return
          output.<tip>
              <para>In Firebird 2.0 and up, use the SQL-compliant <link
              linkend="langrefupd21-select-rows"><database>ROWS</database></link> syntax
              instead.</para>
            </tip></para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>

              <note>
                <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an integer literal or a
                query parameter, the <quote><literal>()</literal></quote> may be omitted. Subselects
                on the other hand require an extra pair of parentheses.</para>
              </note>
            </blockquote></para>
        </formalpara>

        <para><database>FIRST</database> and <database>SKIP</database> are both optional. When used
        together as in <quote><database>FIRST</database> <replaceable>m</replaceable>
        <database>SKIP</database> <replaceable>n</replaceable></quote>, the
        <replaceable>n</replaceable> topmost rows of the output set are discarded and the first
        <replaceable>m</replaceable> rows of the remainder are returned.</para>

        <para><database>SKIP</database> 0 is allowed, but of course rather pointless.
        <database>FIRST</database> 0 is allowed in version 1.5 and up, where it returns an empty
        set. In 1.0.x, <database>FIRST</database> 0 causes an error. Negative
        <database>SKIP</database> and/or <database>FIRST</database> values always result in an
        error.</para>

        <para>If a <database>SKIP</database> lands past the end of the dataset, an empty set is
        returned. If the number of rows in the dataset (or the remainder after a
        <database>SKIP</database>) is less than the value given after <database>FIRST</database>,
        that smaller number of rows is returned. These are valid results, not error
        situations.</para>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>The following query will return the first 10 names from the People table:</para>

              <programlisting>select first 10 id, name from People
  order by name asc</programlisting>

              <para>The following query will return everything <emphasis>but</emphasis> the first 10
              names:</para>

              <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>

              <para>And this one returns the last 10 rows. Notice the double parentheses:</para>

              <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>

              <para>This query returns rows 81–100 of the People table:</para>

              <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
            </blockquote></para>
        </formalpara>

        <caution>
          <title>Two Gotchas with <database>FIRST</database> in subselects</title>

          <itemizedlist>
            <listitem>
              <para>This:</para>

              <blockquote>
                <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
              </blockquote>

              <para>will delete all of the rows in the table. Ouch! The sub-select is evaluating
              each 10 candidate rows for deletion, deleting them, slipping forward 10 more... ad
              infinitum, until there are no rows left. Beware! Or better: use the
              <database>ROWS</database> syntax, available since Firebird 2.0.</para>
            </listitem>

            <listitem>
              <para>Queries like:</para>

              <blockquote>
                <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
              </blockquote>

              <para>won't work as expected, because the optimization performed by the engine
              transforms the <database>IN</database> predicate to the correlated
              <database>EXISTS</database> predicate shown below. It's obvious that in this case
              <database>FIRST</database> <replaceable>N</replaceable> doesn't make any sense:</para>

              <blockquote>
                <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
              </blockquote>

              <!--This still so with ROWS? BTW, I think this is a grave error in the optimizer!-->
            </listitem>
          </itemizedlist>
        </caution>
      </section>

      <section id="langrefupd21-groupby">
        <title><database>GROUP BY</database></title>

        <formalpara>
          <title>Description</title>

          <para><database>GROUP BY</database> merges rows that have the same combination of values
          and/or <constant>NULL</constant>s in the item list into a single row. Any aggregate
          functions in the select list are applied to each group individually instead of to the
          dataset as a whole.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>  ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
               | <replaceable>column-alias</replaceable>
               | <replaceable>column-position</replaceable>
               | <replaceable>expression</replaceable></programlisting>

              <itemizedlist>
                <listitem>
                  <para>Only non-negative integer <emphasis>literals</emphasis> will be interpreted
                  as column positions. If they are outside the range from 1 to the number of
                  columns, an error is raised. Integer values resulting from expressions or
                  parameter substitutions are simply invariables and will be used as such in the
                  grouping. They will have no effect though, as their value is the same for each
                  row.</para>
                </listitem>

                <listitem>
                  <para>A <database>GROUP BY</database> item cannot be a reference to an aggregate
                  function (including one that is buried inside an expression) from the same
                  context.</para>
                </listitem>

                <listitem>
                  <para>The select list may not contain expressions that can have different values
                  within a group. To avoid this, the rule of thumb is to include each non-aggregate
                  item from the select list in the <database>GROUP BY</database> list (whether by
                  copying, alias or position).</para>

                  <!--Some exceptions and variations are possible, but they could be discussed
later in notes. For instance, a GROUP BY item may be 'narrower' than the
corresponding select item (SELECT upper(ColA) GROUP BY ColA is fine, but
the reverse isn't). Also think of certain subselects, and items that don't
refer to the current context.-->
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Note</title>

          <para>If you group by a column position, the expression at that position is copied
          internally from the select list. If it concerns a subquery, that subquery will be executed
          at least twice.<!--I suppose the same goes for grouping by aliases?--></para>
        </formalpara>

        <section id="langrefupd21-groupby-extensions">
          <title>Grouping by alias, position and expressions</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0, 1.5, 2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In addition to column names, Firebird 2 allows column aliases, column positions
            and arbitrary valid expressions as <database>GROUP BY</database> items.</para>
          </formalpara>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>These three queries all achieve the same result:</para>

                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by len_name</programlisting>

                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by 1</programlisting>

                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by strlen(lastname)</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>History</title>

            <para>Grouping by UDF results was added in Firebird 1. Grouping by column positions,
            <database>CASE</database> outcomes and a limited number of internal functions in
            Firebird 1.5. Firebird 2 added column aliases and expressions in general as valid
            <database>GROUP BY</database> items (<quote>expressions in general</quote> absorbing the
            UDF, <database>CASE</database> and internal functions lot).</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-having-stricter">
        <title><database>HAVING</database>: Stricter rules</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>See <link linkend="langrefupd21-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-join">
        <title><database>JOIN</database></title>

        <section id="langrefupd21-join-amb-fields">
          <title>Ambiguous field names rejected</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>InterBase 6 accepts and executes statements like the one below, which refers to an
            unqualified column name even though that name exists in both tables participating in the
            <database>JOIN</database>:</para>
          </formalpara>

          <blockquote>
            <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
          </blockquote>

          <para>The results of such a query are unpredictable. Firebird Dialect 3 returns an error
          if there are ambiguous field names in <database>JOIN</database> statements. Dialect 1
          gives a warning but will execute the query anyway.</para>
        </section>

        <section id="langrefupd21-join-crossjoin">
          <title><database>CROSS JOIN</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2.0 supports <database>CROSS JOIN</database>, which performs a full set
            multiplication on the tables involved. Previously you had to achieve this by joining on
            a tautology (a condition that is always true) or by using the comma syntax, now
            deprecated.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>SELECT ... 
   FROM <replaceable>table1</replaceable> CROSS JOIN <replaceable>table2</replaceable>
   [WHERE ...]
   ...</programlisting>

                <para><emphasis role="bold">Note:</emphasis> If you use <database>CROSS
                JOIN</database>, you can't use <database>ON</database>.</para>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select * from Men cross join Women
order by Men.age, Women.age

-- old syntax:
--   select * from Men join Women on 1 = 1
--   order by Men.age, Women.age

-- comma syntax:
--   select * from Men, Women
--   order by Men.age, Women.age</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-orderby">
        <title><database>ORDER BY</database></title>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
            </blockquote></para>
        </formalpara>

        <section id="langrefupd21-orderby-alias">
          <title>Order by colum alias</title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 2.0 and above support ordering by column alias.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select rdb$character_set_id as charset_id,
       rdb$collation_id as coll_id,
       rdb$collation_name as name
from rdb$collations
order by charset_id, coll_id</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-order-star-by-colpos">
          <title>Ordering by column position causes * expansion</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>If you order by column position in a <quote><database>SELECT</database> *</quote>
            query, the engine will now expand the * to determine the sort column(s).</para>
          </formalpara>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <para>The following wasn't possible in pre-2.0 versions:</para>

                <programlisting>select * from rdb$collations
order by 3, 2</programlisting>

                <para>The following would sort the output set on <literal>Films.Director</literal>
                in previous versions. In Firebird 2 and up, it will sort on the second column of
                <literal>Books</literal>:</para>

                <programlisting>select Books.*, Films.Director from Books, Films
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-orderby-expr">
          <title>Ordering by expressions</title>

          <formalpara>
            <title>Added in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 1.5 introduced the possibility to use expressions as ordering items.
            Please note that expressions consisting of a single non-negative whole number will be
            interpreted as column positions and cause an exception if they're not in the range from
            1 to the number of columns.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select x, y, note from Pairs
order by x+y desc</programlisting>
              </blockquote></para>
          </formalpara>

          <note>
            <para>The number of function or procedure invocations resulting from a sort based on a
            UDF or stored procedure is unpredictable, regardless whether the ordering is specified
            by the expression itself or by the column position number.</para>
          </note>

          <formalpara>
            <title>Notes</title>

            <para><itemizedlist>
                <listitem>
                  <para>The number of function or procedure invocations resulting from a sort based
                  on a UDF or stored procedure is unpredictable, regardless whether the ordering is
                  specified by the expression itself or by the column position number.</para>
                </listitem>

                <listitem>
                  <para>Only non-negative whole number <emphasis>literals</emphasis> are interpreted
                  as column positions. A whole number resulting from an expression evaluation or
                  parameter substitution is seen as an integer invariable and will lead to a dummy
                  sort, since its value is the same for each row.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>

          <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->

          <!--Rlsnotes 1.5 say (by Nickolay):

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice? Maybe with ARRAYs?-->
        </section>

        <section id="langrefupd21-orderby-nulls">
          <title><constant>NULL</constant>s placement</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5, 2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firebird 1.5 has introduced the per-column <database>NULLS FIRST</database> and
            <database>NULLS LAST</database> directives to specify where <constant>NULL</constant>s
            appear in the sorted column. Firebird 2.0 has changed the default placement of
            <constant>NULL</constant>s.</para>
          </formalpara>

          <para>Unless overridden by <database>NULLS FIRST</database> or <database>NULLS
          LAST</database>, <constant>NULL</constant>s in ordered columns are placed as
          follows:</para>

          <itemizedlist>
            <listitem>
              <para>In Firebird 1.0 and 1.5: at the end of the sort, regardless whether the order is
              ascending or descending.</para>
            </listitem>

            <listitem>
              <para>In Firebird 2.0 and up: at the <emphasis>start</emphasis> of ascending orderings
              and at the <emphasis>end</emphasis> of descending orderings.</para>
            </listitem>
          </itemizedlist>

          <para>See also the table below for an overview of the different versions.</para>

          <table id="langrefupd21-tbl-null-placement">
            <title><constant>NULL</constant>s placement in ordered columns</title>

            <tgroup cols="4">
              <colspec colname="colStatement" colwidth="2*" />

              <colspec colname="colPlac10" colwidth="1*" />

              <colspec colname="colPlac15" colwidth="1*" />

              <colspec colname="colPlac2" colwidth="1*" />

              <thead>
                <row valign="top">
                  <entry morerows="1">Ordering</entry>

                  <entry align="center" nameend="colPlac2"
                  namest="colPlac10"><constant>NULL</constant>s placement</entry>
                </row>

                <row valign="top">
                  <entry align="center">Firebird 1</entry>

                  <entry align="center">Firebird 1.5</entry>

                  <entry align="center">Firebird 2</entry>
                </row>
              </thead>

              <tbody>
                <row valign="top">
                  <entry>order by Field [asc]</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>

                  <entry>top</entry>
                </row>

                <row valign="top">
                  <entry>order by Field desc</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>
                </row>

                <row valign="top">
                  <entry>order by Field [asc | desc] nulls first</entry>

                  <entry>—</entry>

                  <entry>top</entry>

                  <entry>top</entry>
                </row>

                <row valign="top">
                  <entry>order by Field [asc | desc] nulls last</entry>

                  <entry>—</entry>

                  <entry>bottom</entry>

                  <entry>bottom</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <note>
            <title>Notes</title>

            <itemizedlist>
              <listitem>
                <para>Pre-existing databases may need a backup-restore cycle before they show the
                correct <constant>NULL</constant> ordering behaviour under Firebird 2.0 and
                up.</para>

                <!--CHECK! Is this always true, or only when the column is indexed?-->
              </listitem>

              <listitem>
                <para>No index will be used on columns for which a non-default
                <constant>NULLS</constant> placement is chosen. In Firebird 1.5, that is the case
                with <database>NULLS FIRST</database>. In 2.0 and higher, with <database>NULLS
                LAST</database> on ascending and <database>NULLS FIRST</database> on descending
                sorts.</para>
              </listitem>
            </itemizedlist>
          </note>

          <formalpara>
            <title>Examples</title>

            <para><blockquote>
                <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>

                <programlisting>select * from document
  order by strlen(description) desc
  rows 10</programlisting>

                <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-orderby-stricter">
          <title>Stricter ordering rules with aggregate statements</title>

          <formalpara>
            <title>Changed in</title>

            <para>1.5</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>See <link linkend="langrefupd21-aggregates-having-orderby"><citetitle>Aggregate
            statements: Stricter <database>HAVING</database> and <database>ORDER
            BY</database></citetitle></link>.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-select-plan">
        <title><database>PLAN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL, PSQL</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Specifies a user plan for the data retrieval, overriding the plan that the optimizer
          would have generated automatically.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <para><!--This is (a modified view of) the syntax as given in the IB6 LangRef, with the
Fb 2.0 extension of optionally providing an INDEX list after ORDER:--><programlisting>PLAN <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;plan_expr&gt;</replaceable>   ::=  [JOIN | [SORT] [MERGE]] (<replaceable>&lt;plan_item&gt;</replaceable> [, <replaceable>&lt;plan_item&gt;</replaceable> ...])

<replaceable>&lt;plan_item&gt;</replaceable>   ::=  <replaceable>&lt;basic_item&gt;</replaceable> | <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;basic_item&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>alias</replaceable>}
                   {NATURAL
                    | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>))
                    | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;indexlist&gt;</replaceable>   ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]</programlisting><!--The syntax given in the 2.0 Rlsnotes differs considerably, but contains at
least some errors. However, the same is probably true for the above.
Points to investigate wrt syntax in Rlsnotes 2.0:
- Must MERGE always take place on *exactly* 2 streams?
- Must MERGE always take place on explicitly SORTed streams?

Points to improve in the syntax above (either in the syntax itself, or
in notes):
- With JOIN and MERGE, the number of plan_items must be at least 2.--></para>
            </blockquote></para>
        </formalpara>

        <section id="langrefupd21-select-plan-improved">
          <title>Handling of user <database>PLAN</database>s improved</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>Firbird 2 has implemented the following improvements in the handling of
            user-specified <database>PLAN</database>s:<itemizedlist>
                <listitem>
                  <para>Plan fragments are propagated to nested levels of joins, enabling manual
                  optimization of complex outer joins.</para>
                </listitem>

                <listitem>
                  <para>User-supplied plans will be checked for correctness in outer joins.</para>
                </listitem>

                <listitem>
                  <para>Short-circuit optimization for user-supplied plans has been added.</para>
                </listitem>

                <listitem>
                  <para>A user-specified access path can be supplied for any
                  <database>SELECT</database>-based statement or clause.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>

        <section id="langrefupd21-select-plan-order-index">
          <title><database>ORDER</database> with <database>INDEX</database></title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>A single plan item can now contain both an <database>ORDER</database> and an
            <database>INDEX</database> directive (in that order).</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>plan (MyTable order ix_myfield index (ix_this, ix_that))</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-select-plan-alltables">
          <title><database>PLAN</database> must include all tables</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>In Firebird 2 and up, a <database>PLAN</database> clause must handle all the
            tables in the query. Previous versions sometimes accepted incomplete plans, but this is
            no longer the case.</para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-select-rows">
        <title><database>ROWS</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Limits the amount of rows returned by the <database>SELECT</database> statement to a
          specified number or range.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <para>With a single <database>SELECT</database>:</para>

              <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;columns&gt;</replaceable>  ::=  The usual output column specifications.
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>   ::=  Any expression evaluating to an integer.</programlisting>

              <para>With a <database>UNION</database>:</para>

              <programlisting>SELECT [FIRST <replaceable>p</replaceable>] [SKIP <replaceable>q</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]

UNION [ALL | DISTINCT]

SELECT [FIRST <replaceable>r</replaceable>] [SKIP <replaceable>s</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]

ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>

        <para>With a single argument <replaceable>m</replaceable>, the first
        <replaceable>m</replaceable> rows of the dataset are returned.</para>

        <para>Points to note:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> = 0, an empty set is returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>

        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, rows
        <replaceable>m</replaceable> to <replaceable>n</replaceable> of the dataset are returned,
        inclusively. Row numbers are 1-based.</para>

        <para>Points to note when using two arguments:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, an
            empty set is returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, an empty set is
            returned.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>

        <!--Neem wat de laatste 2 punten betreft contact op met Dmitry: is dit zo bedoeld?
Zo nee, tekst eventueel aanpassen.-->

        <para>The SQL-compliant <database>ROWS</database> syntax obviates the need for <link
        linkend="langrefupd21-first-skip"><database>FIRST</database> and
        <database>SKIP</database></link>, except in one case: a <database>SKIP</database> without
        <database>FIRST</database>, which returns the entire remainder of the set after skipping a
        given number of rows. (You can often <quote>fake it</quote> though, by supplying a second
        argument that you know to be bigger than the number of rows in the set.)</para>

        <para>You cannot use <database>ROWS</database> together with <database>FIRST</database>
        and/or <database>SKIP</database> in a single <database>SELECT</database> statement, but is
        it valid to use one form in the top-level statement and the other in subselects, or to use
        the two syntaxes in different subselects.</para>

        <para>When used with a <database>UNION</database>, the <database>ROWS</database> subclause
        applies to the UNION as a whole and must be placed after the last
        <database>SELECT</database>. If you want to limit the output of one or more individual
        <database>SELECT</database>s within the <database>UNION</database>, you have two options:
        either use <database>FIRST</database>/<database>SKIP</database> on those
        <database>SELECT</database> statements, or convert them to <link
        linkend="langrefupd21-derived-tables">derived tables</link> with <database>ROWS</database>
        clauses.</para>

        <!--De SELECT-syntax van Dmitry in de 2.0 Rlsnotes klopt op dit punt niet, want geeft aan
dat je ROWS op elke SELECT in een UNION kunt gebruiken. Laat hem dit t.z.t. weten.-->

        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd21-update-rows"><database>UPDATE</database></link> and <link
        linkend="langrefupd21-delete-rows"><database>DELETE</database></link> statements.</para>

        <!--SKIP en FIRST kunnen - en konden ook in 1.5 al - met UNIONs en in subquery's.
Dit in tegenstelling tot wat de 2.0 Rlsnotes schijnen te suggereren.-->
      </section>

      <section id="langrefupd21-select-alias-use">
        <title>Table alias must be used if present</title>

        <!--Also applies to DELETE and UPDATE I'd say.-->

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>If you give a table an alias in Firebird 2.0 and above, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that table.</para>

          <!--Similar rule for column aliases?-->
        </formalpara>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <para>Correct usage:</para>

              <programlisting>select pears from Fruit</programlisting>

              <programlisting>select Fruit.pears from Fruit</programlisting>

              <programlisting>select pears from Fruit F</programlisting>

              <programlisting>select F.pears from Fruit F</programlisting>

              <para>No longer allowed:</para>

              <programlisting>select Fruit.pears from Fruit F</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-union">
        <title><database>UNION</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL, PSQL</para>
        </formalpara>

        <section id="langrefupd21-union-in-subqueries">
          <title><database>UNION</database>s in subqueries</title>

          <formalpara>
            <title>Changed in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para><database>UNION</database>s are now allowed in subqueries. This applies not only
            to column-level subqueries in a <database>SELECT</database> list, but also to subqueries
            in <database>ANY</database>|<database>SOME</database>, <database>ALL</database> and
            <database>IN</database> predicates, as well as the optional <database>SELECT</database>
            expression that feeds an <database>INSERT</database>.</para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
              </blockquote></para>
          </formalpara>
        </section>

        <section id="langrefupd21-union-distinct">
          <title><database>UNION DISTINCT</database></title>

          <formalpara>
            <title>Added in</title>

            <para>2.0</para>
          </formalpara>

          <formalpara>
            <title>Description</title>

            <para>You can now use the optional <database>DISTINCT</database> keyword when defining a
            <database>UNION</database>. This will show duplicate rows only once instead of every
            time they occur in one of the tables. Since <database>DISTINCT</database>, being the
            opposite of <database>ALL</database>, is the default mode anyway, this doesn't add any
            new functionality.</para>
          </formalpara>

          <formalpara>
            <title>Syntax</title>

            <para><blockquote>
                <programlisting>SELECT (...) FROM (...)
UNION [DISTINCT | ALL]
SELECT (...) FROM (...)</programlisting>
              </blockquote></para>
          </formalpara>

          <formalpara>
            <title>Example</title>

            <para><blockquote>
                <programlisting>select name, phone from translators
  union distinct
select name, phone from proofreaders</programlisting>

                <para>Translators who also work as proofreaders (a not uncommon combination) will
                show up only once in the result set, provided their phone number is the same in both
                tables. The same result would have been obtained without
                <database>DISTINCT</database>. With <database>ALL</database>, they would appear
                twice.</para>
              </blockquote></para>
          </formalpara>
        </section>
      </section>

      <section id="langrefupd21-with-lock">
        <title><database>WITH LOCK</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no support found in sources-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description:</title>

          <para><database>WITH LOCK</database> provides a limited explicit pessimistic locking
          capability for cautious use in conditions where the affected row set is:<orderedlist
              numeration="loweralpha" spacing="compact">
              <listitem>
                <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
              </listitem>

              <listitem>
                <para>precisely controlled by the application code.</para>
              </listitem>
            </orderedlist></para>
        </formalpara>

        <caution>
          <title>This is for experts only!</title>

          <para>The need for a pessimistic lock in Firebird is very rare indeed and should be well
          understood before use of this extension is considered.</para>

          <para>It is essential to understand the effects of transaction isolation and other
          transaction attributes before attempting to implement explicit locking in your
          application.</para>
        </caution>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
            </blockquote></para>
        </formalpara>

        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>

        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>

        <para><database>WITH LOCK</database> can only be used with a top-level, single-table
        <database>SELECT</database> statement. It is <emphasis>not</emphasis> available:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>in a subquery specification;</para>
          </listitem>

          <listitem>
            <para>for joined sets;</para>
          </listitem>

          <listitem>
            <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
            clause or any other aggregating operation;</para>
          </listitem>

          <listitem>
            <para>with a view;</para>
          </listitem>

          <listitem>
            <para>with the output of a selectable stored procedure;</para>
          </listitem>

          <listitem>
            <para>with an external table.</para>
          </listitem>
        </itemizedlist>

        <para>A lengthier, more in-depth discussion of <quote><database>SELECT ... WITH
        LOCK</database></quote> is included in the <link
        linkend="langrefupd21-notes-withlock">Notes</link>. It is a must-read for everybody who
        considers using this feature.</para>
      </section>
    </section>

    <section id="langrefupd21-update">
      <title><database>UPDATE</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Changes values in a table (or in one or more tables underlying a view). The columns
        affected are specified in the <database>SET</database> clause; the rows affected may be
        limited by the <database>WHERE</database> and <database>ROWS</database> clauses.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>UPDATE [TRANSACTION <replaceable>name</replaceable>] {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [<replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>

            <note>
              <title>Restrictions</title>

              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>

                <listitem>
                  <para><database>WHERE CURRENT OF</database> is only available in ESQL and
                  PSQL.</para>
                </listitem>

                <listitem>
                  <para>The <database>PLAN</database>, <database>ORDER BY</database> and
                  <database>ROWS</database> clauses are not available in ESQL.</para>
                </listitem>

                <listitem>
                  <para>New in 2.0: No column may be <database>SET</database> more than once in the
                  same <database>UPDATE</database> statement.</para>
                </listitem>
              </itemizedlist>
            </note>

            <!--Mogen alleen losse plan_items voorkomen of ook JOIN, SORT, MERGE ?-->
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-update-orderby">
        <title><database>ORDER BY</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>UPDATE</database> now allows an <database>ORDER BY</database> clause. This
          only makes sense in combination with <database>ROWS</database>, but is also valid without
          it.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-update-plan">
        <title><database>PLAN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para><database>UPDATE</database> now allows a <database>PLAN</database> clause, so users
          can optimize the operation manually.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-update-rows">
        <title><database>ROWS</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, PSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Limits the amount of rows updated to a specified number or range.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            </blockquote></para>
        </formalpara>

        <para>With a single argument <replaceable>m</replaceable>, the update is limited to the
        first <replaceable>m</replaceable> rows of the dataset defined by the table or view and the
        optional <database>WHERE</database> and <database>ORDER BY</database> clauses.</para>

        <para>Points to note:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is updated.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> = 0, no rows are updated.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>

        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, the
        update is limited to rows <replaceable>m</replaceable> to <replaceable>n</replaceable>
        inclusively. Row numbers are 1-based.</para>

        <para>Points to note when using two arguments:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, no
            rows are updated.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are updated.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, no rows are
            updated.</para>
          </listitem>

          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>

        <!--Neem wat de laatste 2 punten betreft contact op met Dmitry: is dit zo bedoeld?
Zo nee, tekst eventueel aanpassen.-->

        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd21-select-rows"><database>SELECT</database></link> and <link
        linkend="langrefupd21-delete-rows"><database>DELETE</database></link> statements.</para>
      </section>
    </section>
  </chapter>

  <chapter id="langrefupd21-transcontrol">
    <title>Transaction control statements</title>

    <section id="langrefupd21-release-savepoint">
      <title><database>RELEASE SAVEPOINT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Deletes a named savepoint, freeing up all the resources it binds.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
          </blockquote></para>
      </formalpara>

      <para>Unless <database>ONLY</database> is added, all the savepoints created after the named
      savepoint are released as well.</para>

      <para>For a full discussion of savepoints, see <link
      linkend="langrefupd21-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>

    <section id="langrefupd21-rollback">
      <title><database>ROLLBACK</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>ROLLBACK [WORK]
   [TRANSACTION <replaceable>tr_name</replaceable>]
   [RETAIN [SNAPSHOT] | TO [SAVEPOINT] <replaceable>sp_name</replaceable> | RELEASE]</programlisting>

            <itemizedlist>
              <listitem>
                <para>The <database>TRANSACTION</database> clause is only available in ESQL.</para>
              </listitem>

              <listitem>
                <para>The <database>RELEASE</database> clause is only available in ESQL, and is
                discouraged.</para>
              </listitem>

              <listitem>
                <para><database>RETAIN</database> and <database>TO</database> are only available in
                DSQL.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-rollback-retain">
        <title><database>ROLLBACK RETAIN</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Undoes all the database changes carried out in the transaction without closing it.
          User variables set with <link
          linkend="langrefupd21-set-context"><database>RDB$SET_CONTEXT()</database></link> remain
          unchanged.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ROLLBACK [WORK] RETAIN [SNAPSHOT]</programlisting>

              <!--IB6 LangRef says for COMMIT RETAIN [SNAPSHOT]:
  "Make the transaction’s changes visible to subsequent SNAPSHOT transactions or
   READ COMMITTED transactions."
But since ROLLBACK doesn't apply any changes, I wonder what SNAPSHOT would
do here... still, the syntax IS supported.-->
            </blockquote></para>
        </formalpara>

        <note>
          <para>The functionality provided by <database>ROLLBACK RETAIN</database> has been present
          since InterBase 6, but the only way to access it was through the API call
          <function>isc_rollback_retaining()</function>.</para>
        </note>
      </section>

      <section id="langrefupd21-rollback-to-savepoint">
        <title><database>ROLLBACK TO SAVEPOINT</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>Undoes everything that happened in a transaction since the creation of the
          savepoint.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>

        <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>

        <!--Keep this itemizedlist synchronized with the one under SAVEPOINT !-->

        <itemizedlist>
          <listitem>
            <para>All the database mutations performed within the transaction since the savepoint
            was created are undone. User variables set with <link
            linkend="langrefupd21-set-context"><database>RDB$SET_CONTEXT()</database></link> remain
            unchanged.</para>
          </listitem>

          <listitem>
            <para>All savepoints created after the one named are destroyed. All earlier savepoints
            are preserved, as is the savepoint itself. This means that you can rollback to the same
            savepoint several times.</para>
          </listitem>

          <listitem>
            <para>All implicit and explicit record locks acquired since the savepoint are released.
            Other transactions that have requested access to rows locked after the savepoint must
            continue to wait until the transaction is committed or rolled back. Other transactions
            that have not already requested the rows can request and access the unlocked rows
            immediately.</para>
          </listitem>
        </itemizedlist>

        <para>For a full discussion of savepoints, see <link
        linkend="langrefupd21-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
      </section>
    </section>

    <section id="langrefupd21-savepoint">
      <title><database>SAVEPOINT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL</para>
      </formalpara>

      <!--ESQL: no-->

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Creates an SQL-99 compliant savepoint, to which you can later rollback your work
        without rolling back the entire transaction. Savepoint mechanisms are also known as
        <quote>nested transactions</quote>.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SAVEPOINT <replaceable>&lt;name&gt;</replaceable>

<replaceable>&lt;name&gt;</replaceable>  ::=  a user-chosen identifier, unique within the transaction</programlisting>
          </blockquote></para>
      </formalpara>

      <para>If the supplied name exists already within the same transaction, the existing savepoint
      is deleted and a new one is created with the same name.</para>

      <para>If you later want to rollback your work to the point where the savepoint was created,
      use:</para>

      <blockquote>
        <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
      </blockquote>

      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>

      <!--Keep this itemizedlist synchronized with the one under ROLLBACK TO SAVEPOINT !-->

      <itemizedlist>
        <listitem>
          <para>All the database mutations performed within the transaction since the savepoint was
          created are undone. User variables set with <link
          linkend="langrefupd21-set-context"><database>RDB$SET_CONTEXT()</database></link> remain
          unchanged.</para>
        </listitem>

        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are
          preserved, as is the savepoint itself. This means that you can rollback to the same
          savepoint several times.</para>
        </listitem>

        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released.
          Other transactions that have requested access to rows locked after the savepoint must
          continue to wait until the transaction is committed or rolled back. Other transactions
          that have not already requested the rows can request and access the unlocked rows
          immediately.</para>
        </listitem>
      </itemizedlist>

      <para>The internal savepoint bookkeeping can consume huge amounts of memory, especially if you
      update the same records multiple times in one transaction. If you don't need a savepoint
      anymore but you're not yet ready to end the transaction, you can delete the savepoint and free
      the resources it uses with:</para>

      <blockquote>
        <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
      </blockquote>

      <para>With <database>ONLY</database>, the named savepoint is the only one that gets released.
      Without it, all savepoints created after it are released as well.</para>

      <formalpara>
        <title>Example DSQL session using a savepoint</title>

        <para><blockquote>
            <programlisting>create table test (id integer);
commit;
insert into test values (1);
commit;
insert into test values (2);
savepoint y;
delete from test;
select * from test;   -- returns no rows
rollback to y;
select * from test;   -- returns two rows
rollback;
select * from test;   -- returns one row</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-savepoint-internal">
        <title>Internal savepoints</title>

        <!--Does this belong here? Is it SQL? The TPB is an API thing, right?-->

        <para>By default, the engine uses an automatic transaction-level system savepoint to perform
        transaction rollback. When you issue a <database>ROLLBACK</database> statement, all changes
        performed in this transaction are backed out via a transaction-level savepoint and the
        transaction is then committed. This logic reduces the amount of garbage collection caused by
        rolled back transactions.</para>

        <para>When the volume of changes performed under a transaction-level savepoint is getting
        large (10<superscript>4</superscript>–10<superscript>6</superscript> records affected), the
        engine releases the transaction-level savepoint and uses the TIP mechanism to roll back the
        transaction if needed.</para>

        <tip>
          <para>If you expect the volume of changes in your transaction to be large, you can specify
          the <database>NO AUTO UNDO</database> option in your <database>SET TRANSACTION</database>
          statement, or – if you use the API – set the TPB flag <systemitem
          class="constant">isc_tpb_no_auto_undo</systemitem>. Both prevent the transaction-level
          savepoint from being created.</para>
        </tip>
      </section>

      <section id="langrefupd21-savepoint-psql">
        <title>Savepoints and PSQL</title>

        <!--Here again the question whether it belongs here.-->

        <para>Transaction control statements are not allowed in PSQL, as that would break the
        atomicity of the statement that calls the procedure. But Firebird does support the raising
        and handling of exceptions in PSQL, so that actions performed in stored procedures and
        triggers can be selectively undone without the entire procedure failing. Internally,
        automatic savepoints are used to:</para>

        <itemizedlist>
          <listitem>
            <para>undo all actions in a <database>BEGIN...END</database> block where an exception
            occurs;<!--Even if the exception is caught by a WHEN at the end of the block? Test!--></para>
          </listitem>

          <listitem>
            <para>undo all actions performed by the SP/trigger (or, in the case of a selectable SP,
            all actions performed since the last <database>SUSPEND</database>) when it terminates
            prematurely due to an uncaught error or exception.</para>
          </listitem>
        </itemizedlist>

        <para>Each PSQL exception handling block is also bounded by automatic system
        savepoints.</para>
      </section>
    </section>

    <section id="langrefupd21-set-trans">
      <title><database>SET TRANSACTION</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Starts and optionally configures a transaction.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SET TRANSACTION
   [NAME <replaceable>hostvar</replaceable>]
   [READ WRITE | READ ONLY]
   [ [ISOLATION LEVEL] { SNAPSHOT [TABLE STABILITY]
                         | READ COMMITTED [[NO] RECORD_VERSION] } ]
   [WAIT | NO WAIT]
   [LOCK TIMEOUT <replaceable>seconds</replaceable>]
   [NO AUTO UNDO]
   [IGNORE LIMBO]
   [RESERVING <replaceable>&lt;tables&gt;</replaceable> | USING <replaceable>&lt;dbhandles&gt;</replaceable>]

<replaceable>&lt;tables&gt;</replaceable>      ::=  <replaceable>&lt;table_spec&gt;</replaceable> [, <replaceable>&lt;table_spec&gt;</replaceable> ...]

<replaceable>&lt;table_spec&gt;</replaceable>  ::=  <replaceable>tablename</replaceable> [, <replaceable>tablename</replaceable> …]
                      [FOR [SHARED | PROTECTED] {READ | WRITE}]

<replaceable>&lt;dbhandles&gt;</replaceable>   ::=  <replaceable>dbhandle</replaceable> [, <replaceable>dbhandle</replaceable> …]</programlisting>

            <!--In Fb 1.0 gpre I find "NO_AUTO_UNDO" (with underscores).
In DSQL, the underscored version is rejected.
Dmitry says: "I suspect it was inherited from InterBase 6.0 and nobody
cared to document it there."
- It's still not documented in IB 6.5 LangRef and EmbedSQL-->

            <itemizedlist>
              <listitem>
                <para>The <database>NAME</database> option is only available in ESQL. It must be
                followed by a previously declared and initialized host-language variable. Without
                <database>NAME</database>, <database>SET TRANSACTION</database> applies to the
                default transaction.</para>
              </listitem>

              <listitem>
                <para>The <database>USING</database> option is also ESQL-only. It limits the
                databases that the transaction can access to the ones mentioned here.</para>
              </listitem>

              <listitem>
                <para><database>IGNORE LIMBO</database> and <database>LOCK TIMEOUT</database> are
                not supported in ESQL.</para>
              </listitem>

              <listitem>
                <para><database>LOCK TIMEOUT</database> and <database>NO WAIT</database> are
                mutually exclusive.</para>
              </listitem>

              <listitem>
                <para>Default option settings are: <database>READ WRITE</database> +
                <database>WAIT</database> + <database>SNAPSHOT</database>.</para>
              </listitem>
            </itemizedlist>

            <!--Ask Claudio or Dmitry:
- Is LOCK TIMEOUT 0 the same as no timeout, or as NO WAIT?-->
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-set-trans-ignore-limbo">
        <title><database>IGNORE LIMBO</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>With this option, records created by limbo transactions are ignored. Transactions
          are in limbo if the second stage of a two-phase commit fails.</para>
        </formalpara>

        <note>
          <para><database>IGNORE LIMBO</database> surfaces the <systemitem
          class="constant">isc_tpb_ignore_limbo</systemitem> TPB parameter, available in the API
          since <application>InterBase</application> times and mainly used by
          <application>gfix</application>.</para>
        </note>
      </section>

      <section id="langrefupd21-set-trans-lock-timeout">
        <title><database>LOCK TIMEOUT</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL</para>

          <!--ESQL: no-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>This option is only available for <database>WAIT</database> transactions. It takes a
          non-negative integer as argument, prescribing the maximum number of seconds that the
          transaction should wait when a lock conflict occurs. If the the waiting time has passed
          and the lock has still not been released, an error is generated.</para>
        </formalpara>

        <note>
          <para>This is a brand new feature in Firebird 2. Its API equivalent is the new <systemitem
          class="constant">isc_tpb_lock_timeout</systemitem> TPB parameter.</para>
        </note>
      </section>

      <section id="langrefupd21-set-trans-no-auto-undo">
        <title><database>NO AUTO UNDO</database></title>

        <formalpara>
          <title>Available in</title>

          <para>DSQL, ESQL</para>

          <!--In ESQL probably as NO_AUTO_UNDO, i.e. with underscores! See comment under Syntax, above.-->
        </formalpara>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>With <database>NO AUTO UNDO</database>, the transaction refrains from keeping the
          log that is normally used to undo changes in the event of a rollback. Should the
          transaction be rolled back after all, other transactions will pick up the garbage
          (eventually).<!--Is that correct? Under SAVEPOINT, it says that the TIP mechanism is used. What is that?-->
          This option can be useful for massive insertions that don't need to be rolled back. For
          transactions that don't perform any mutations, <database>NO AUTO UNDO</database> makes no
          difference at all.</para>
        </formalpara>

        <note>
          <para><database>NO AUTO UNDO</database> is the SQL equivalent of the <systemitem
          class="constant">isc_tpb_no_auto_undo</systemitem> TPB parameter, available in the API
          since <application>InterBase</application> times.</para>
        </note>
      </section>
    </section>
  </chapter>

  <chapter id="langrefupd21-psql">
    <title>PSQL statements</title>

    <para>PSQL – Procedural SQL – is the Firebird stored procedure and trigger language.</para>

    <section id="langrefupd21-psql-begin-end">
      <title><database>BEGIN ... END</database> blocks may be empty</title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
        allowing you to write stub code without having to resort to dummy statements.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-break">
      <title><database>BREAK</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>1.5 – use <link
        linkend="langrefupd21-psql-leave"><database>LEAVE</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>BREAK</database> immediately terminates a <database>WHILE</database> or
        <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>create procedure selphrase(num int)
returns (phrase varchar(40))
as
begin
  for select Phr from Phrases into phrase do
  begin
    if (num &lt; 1) then <emphasis role="bold">break;</emphasis>
    suspend;
    num = num - 1;
  end
  phrase = '***  Ready!  ***';
  suspend;
end</programlisting>

            <para>This selectable SP returns at most <replaceable>num</replaceable> rows from the
            table Phrases. The variable <replaceable>num</replaceable> is decremented in each
            iteration; once it is smaller than 1, the loop is terminated with
            <database>BREAK</database>. The program then continues at the line
            <quote><literal>phrase = '*** Ready! ***';</literal></quote>.</para>
          </blockquote></para>
      </formalpara>

      <important>
        <para>Since Firebird 1.5, <database>BREAK</database> is deprecated in favor of the SQL-99
        compliant alternative <link
        linkend="langrefupd21-psql-leave"><citetitle><database>LEAVE</database></citetitle></link>.</para>

        <!--Not synonyms anymore, for in 2.0 LEAVE supports a label whereas BREAK doesn't.-->
      </important>

      <!--TESTED:
Contrary to what Fb 1.5 rlsnotes suggest, BREAK works in SPs *and* triggers as from 1.0.
In IB6 it doesn't exist.-->
    </section>

    <section id="langrefupd21-psql-close-cursor">
      <title><database>CLOSE</database> cursor</title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Closes an open cursor. Any cursors still open when the trigger, stored procedure or
        <database>EXECUTE BLOCK</database> statement they belong to is exited, will be closed
        automatically.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>CLOSE <replaceable>cursorname</replaceable>;</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para>See <link linkend="langrefupd21-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-declare">
      <title><database>DECLARE</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <section id="langrefupd21-psql-declare-cursor">
        <title><database>DECLARE</database> ... <database>CURSOR</database></title>

        <formalpara>
          <title>Added in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <!--LET OP: DECLARE CURSOR was ook al beschikbaar in ESQL! Kijk of er verschillen zijn.
Ja, vlg. LangRef hoeft in ESQL het select-stmt niet tussen ().
Verder kan in ESQL optioneel dit erachter: FOR UPDATE OF <col> [, <col>…]

Dan is er ook nog een DSQL-vorm:
  DECLARE cursor CURSOR FOR <statement_id>
Hierin is <statement_id> het id van een al geprepareerd stmt. Hoe doe je dat in DSQL? PREPARE
schijnt alleen in ESQL te mogen. Moet je dat dan via de API doen, en is de handle het ID?

En is in DSQL en ESQL het optionele [VARIABLE] toegestaan?-->

          <para>Declares a named cursor and binds it to its own <database>SELECT</database>
          statement. The cursor can later be opened, used to walk the result set, and closed again.
          Positioned updates and deletes are also supported. PSQL cursors are available in triggers,
          stored procedures and <link linkend="langrefupd21-execblock"><database>EXECUTE
          BLOCK</database></link> statements.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DECLARE [VARIABLE] <replaceable>cursorname</replaceable> CURSOR FOR (<replaceable>select-statement</replaceable>);</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>execute block
returns (relation char(31), sysflag int)
as
declare cur cursor for 
  (select rdb$relation_name, rdb$system_flag from rdb$relations);
begin
  open cur;
  while (1=1) do
  begin
    fetch cur into relation, sysflag;
    if (row_count = 0) then leave;
    suspend;
  end
  close cur;
end</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>See also</title>

          <para><link linkend="langrefupd21-psql-open-cursor"><database>OPEN</database>
          cursor</link>, <link linkend="langrefupd21-psql-fetch-cursor"><database>FETCH</database>
          cursor</link>, <link linkend="langrefupd21-psql-close-cursor"><database>CLOSE</database>
          cursor</link></para>
        </formalpara>
      </section>

      <section id="langrefupd21-psql-declare-init">
        <title><database>DECLARE [VARIABLE]</database> with initialization</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>In Firebird 1.5 and above, a PSQL local variable can be initialized upon
          declaration. The <database>VARIABLE</database> keyword has become optional.</para>
        </formalpara>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>];</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>create procedure proccie (a int)
returns (b int)
as
declare p int;
declare q int = 8;
declare r int default 9;
declare variable s int;
declare variable t int = 10;
declare variable u int default 11;
begin
  <replaceable>&lt;intelligent code here&gt;</replaceable>
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-psql-exception">
      <title><database>EXCEPTION</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The <database>EXCEPTION</database> syntax has been extended so that the user
        can<orderedlist numeration="loweralpha" spacing="compact">
            <listitem>
              <para>Rethrow a caught exception or error.</para>
            </listitem>

            <listitem>
              <para>Provide a custom message when throwing a user-defined exception.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>EXCEPTION [<replaceable>&lt;exception-name&gt;</replaceable> [<replaceable>custom-message</replaceable>]]

<replaceable>&lt;exception-name&gt;</replaceable>  ::=  A previously defined exception name</programlisting>
          </blockquote></para>
      </formalpara>

      <section id="langrefupd21-psql-exception-rethrow">
        <title>Rethrowing a caught exception</title>

        <para>Within the exception handling block only, you can rethrow the caught exception or
        error by giving the <database>EXCEPTION</database> command without any arguments. Outside
        such blocks, this <quote>bare</quote> command has no effect.</para>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>when any do
begin
  insert into error_log (...) values (sqlcode, ...);
  exception;
end</programlisting>

              <para>This example first logs some information about the exception or error, and then
              rethrows it.</para>

              <!--So it also works with SQL en GDS errors? Answered by Dmitry: YES.-->
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-psql-exception-custom-msg">
        <title>Providing a custom error message</title>

        <para>Firebird 1.5 and up allow you to override an exception's default error message by
        supplying an alternative one when throwing the exception.</para>

        <formalpara>
          <title>Examples</title>

          <para><blockquote>
              <programlisting>exception ex_data_error 'You just lost some valuable data';</programlisting>

              <programlisting>exception ex_bad_type 'Wrong type for record with id ' || new.id;</programlisting>
            </blockquote></para>
        </formalpara>

        <note>
          <para>Starting at version 2.0, the maximum message length is 1021 instead of 78
          characters.</para>
        </note>
      </section>
    </section>

    <section id="langrefupd21-psql-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>In Firebird 1.5 and above, (compound) expressions are allowed as input parameters for
        stored procedures called with <database>EXECUTE PROCEDURE</database>. See <link
        linkend="langrefupd21-execproc"><citetitle>DML statements :: <database>EXECUTE
        PROCEDURE</database></citetitle></link> for full info and examples.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-execstat">
      <title><database>EXECUTE STATEMENT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>EXECUTE STATEMENT</database> takes a single string argument and executes it
        as if it had been submitted as a DSQL statement. The exact syntax depends on the number of
        data rows that the supplied statement may return.</para>
      </formalpara>

      <section id="langrefupd21-psql-execstat-nooutput">
        <title>No data returned</title>

        <para>This form is used with <database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database> and <database>EXECUTE PROCEDURE</database> statements that
        return no data.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;statement&gt;</replaceable>

<replaceable>&lt;statement&gt;</replaceable>  ::=  An SQL statement returning no data.</programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>create procedure DynamicSampleOne (ProcName varchar(100))
as
declare variable stmt varchar(1024);
declare variable param int;
begin
   select min(SomeField) from SomeTable into param;
   stmt = 'execute procedure ' 
          || ProcName 
          || '(' 
          || cast(param as varchar(20)) 
          || ')';
   execute statement stmt;
end</programlisting>
            </blockquote></para>
        </formalpara>

        <warning>
          <para>Although this form of <database>EXECUTE STATEMENT</database> can also be used with
          all kinds of DDL strings (except <database>CREATE/DROP DATABASE</database>), it is
          generally very, very unwise to use this trick in order to circumvent the no-DDL rule in
          PSQL.</para>
        </warning>
      </section>

      <section id="langrefupd21-psql-execstat-singleton">
        <title>One row of data returned</title>

        <para>This form is used with singleton <database>SELECT</database> statements.</para>

        <!--EXECUTE PROCEDURE with RETURNING_VALUES is NOT possible in EXECUTE STATEMENT
(Token unknown - line 1, char 25 returning_values). Why?-->

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  An SQL statement returning at most one row of data.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>create procedure DynamicSampleTwo (TableName varchar(100))
as
declare variable param int;
begin
  execute statement
    'select max(CheckField) from ' || TableName into :param;
  if (param &gt; 100) then
    exception Ex_Overflow 'Overflow in ' || TableName;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-psql-execstat-multirow">
        <title>Any number of data rows returned</title>

        <para>This form – analogous to <quote><database>FOR SELECT ... DO</database></quote> – is
        used with <database>SELECT</database> statements that may return a multi-row dataset.</para>

        <formalpara>
          <title>Syntax</title>

          <para><blockquote>
              <programlisting>FOR EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   DO <replaceable>&lt;compound-statement&gt;</replaceable>

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  Any SELECT statement.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>

        <formalpara>
          <title>Example</title>

          <para><blockquote>
              <programlisting>create procedure DynamicSampleThree 
  ( TextField varchar(100),
    TableName varchar(100) )
returns 
  ( LongLine varchar(32000) )
as
declare variable Chunk varchar(100);
begin
  Chunk = '';
  for execute statement
    'select ' || TextField || ' from ' || TableName into :Chunk
  do
    if (Chunk is not null) then
      LongLine = LongLine || Chunk || ' ';
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>

      <section id="langrefupd21-psql-execstat-caveats">
        <title>Caveats with <database>EXECUTE STATEMENT</database></title>

        <orderedlist>
          <listitem>
            <para>There is no way to validate the syntax of the enclosed statement.</para>
          </listitem>

          <listitem>
            <para>There are no dependency checks to discover whether tables or columns have been
            dropped.</para>
          </listitem>

          <listitem>
            <para>Operations will be slow because the embedded statement has to be prepared every
            time it is executed.</para>
          </listitem>

          <listitem>
            <para>The argument string cannot contain any parameters. All variable substitution into
            the static part of the SQL statement should be performed before <database>EXECUTE
            STATEMENT</database> is called.</para>
          </listitem>

          <listitem>
            <para>Return values are strictly checked for data type in order to avoid unpredictable
            type-casting exceptions. For example, the string <literal>'1234'</literal> would convert
            to an integer, 1234, but <literal>'abc'</literal> would give a conversion error.</para>
          </listitem>

          <listitem>
            <para>If the stored procedure has special privileges on some objects, the dynamic
            statement submitted in the <database>EXECUTE STATEMENT</database> string does not
            inherit them. Privileges are restricted to those granted to the user who is executing
            the procedure.</para>
          </listitem>
        </orderedlist>

        <para>All in all, this feature is intended only for very cautious use and you should always
        take the above factors into account. Bottom line: use <database>EXECUTE STATEMENT</database>
        only when other methods are impossible, or perform even worse than <database>EXECUTE
        STATEMENT</database>.</para>
      </section>
    </section>

    <section id="langrefupd21-psql-exit">
      <title><database>EXIT</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>In Firebird 1.5 and up, <database>EXIT</database> can be used in all PSQL. In earlier
        versions it is only supported in stored procedures, not in triggers.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-fetch-cursor">
      <title><database>FETCH</database> cursor</title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Fetches the next data row from a cursor's result set and stores the column values in
        PSQL variables.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>FETCH <replaceable>cursorname</replaceable> INTO [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...];</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>The <link linkend="langrefupd21-row_count"><varname>ROW_COUNT</varname></link>
              context variable will be 1 if the fetch returned a data row and 0 if the end of the
              set has been reached.</para>
            </listitem>

            <listitem>
              <para>You can do a positioned <link
              linkend="langrefupd21-update"><database>UPDATE</database></link> or <link
              linkend="langrefupd21-delete"><database>DELETE</database></link> on the fetched row
              with the <database>WHERE CURRENT OF</database> clause.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para>See <link linkend="langrefupd21-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-forexecstatdo">
      <title><database>FOR EXECUTE STATEMENT ... DO</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>See <link linkend="langrefupd21-psql-execstat-multirow"><citetitle><database>EXECUTE
        STATEMENT</database> :: Any number of data rows returned</citetitle></link>.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-leave">
      <title><database>LEAVE</database></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>LEAVE</database> immediately terminates the innermost
        <database>WHILE</database> or <database>FOR</database> loop. With the optional
        <replaceable>label</replaceable> argument introduced in Firebird 2.0,
        <database>LEAVE</database> can break out of surrounding loops as well. Execution continues
        with the first statement after the outermost terminated loop.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>[<replaceable>label</replaceable>:]
{FOR | WHILE} ... DO
   ...
   (possibly nested loops, with or without labels)
   ...
   LEAVE [<replaceable>label</replaceable>];</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <para>If an error occurs during the insert in the example below, the event is logged and
            the loop terminated. The program continues at the line of code reading <quote><literal>c
            = 0;</literal></quote></para>

            <programlisting>while (b &lt; 10) do
begin
  insert into Numbers(B) values (:b);
  b = b + 1;
  when any do
  begin
    execute procedure log_error (current_timestamp, 'Error in B loop');
    <emphasis role="bold">leave;</emphasis>
  end
end
c = 0;</programlisting>

            <para>The next example uses labels. <quote><code>Leave LoopA</code></quote> terminates
            the outer loop, <quote><code>leave LoopB</code></quote> the inner loop. Notice that a
            plain <quote><code>leave</code></quote> would also suffice to terminate the inner
            loop.</para>

            <programlisting>stmt1 = 'select Name from Farms';
<emphasis role="bold">LoopA:</emphasis>
for execute statement :stmt1 into :farm do
begin
  stmt2 = 'select Name from Animals where Farm = ''';
  <emphasis role="bold">LoopB:</emphasis>
  for execute statement :stmt2 || :farm || '''' into :animal do
  begin
    if  (animal = 'Fluffy') then <emphasis role="bold">leave LoopB</emphasis>;
    else if (animal = farm) then <emphasis role="bold">leave LoopA</emphasis>;
    else suspend;
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-open-cursor">
      <title><database>OPEN</database> cursor</title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Opens a previously declared cursor, executing its <database>SELECT</database>
        statement and enabling it to fetch records from the result set.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>OPEN <replaceable>cursorname</replaceable>;</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para>See <link linkend="langrefupd21-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-plan">
      <title><database>PLAN</database> allowed in trigger code</title>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would
        be rejected by the compiler. Now a valid plan can be included and will be used.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-psql-udf-as-proc">
      <title>UDFs callable as void functions</title>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>In Firebird 2.0 and above, PSQL code may call UDFs without assigning the result value,
        i.e. like a Pascal procedure or C void function. In most cases this is senseless, because
        the main purpose of almost every UDF is to produce the result value. Some functions however
        perform a specific task, and if you're not interested in the result value you can now spare
        yourself the trouble of assigning it to a dummy variable.<!--Also possible in DSQL? No. And ESQL? Asked Dmitry, but he forgot to answer that one.--></para>
      </formalpara>

      <note>
        <para><link linkend="langrefupd21-get-context"><function>RDB$GET_CONTEXT</function></link>
        and <link linkend="langrefupd21-set-context"><function>RDB$SET_CONTEXT</function></link>,
        though classified in this guide under internal functions, are actually a kind of
        auto-declared UDFs. You may therefore call them without catching the result. Of course this
        only makes sense for <function>RDB$SET_CONTEXT</function>.</para>
      </note>
    </section>
  </chapter>

  <chapter id="langrefupd21-variables">
    <title>Context variables</title>

    <section id="langrefupd21-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><varname>CURRENT_CONNECTION</varname> contains the system identifier of the active
        connection context.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>

            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page
      and reset upon restore. Since the engine itself is not interested in this value, it is only
      incremented if the client reads it during a session. Hence it is only useful as a unique
      identifier, not as an indicator of the number of connections since the creation or latest
      restoration of the database.</para>

      <!--Starting with Fb 2.1, the value is incremented with every connection.-->
    </section>

    <section id="langrefupd21-current_role">
      <title><varname>CURRENT_ROLE</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the
        currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is
        <database>NONE</database>.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>VARCHAR(31)</database></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>

      <para><varname>CURRENT_ROLE</varname> always represents a valid role or
      <database>NONE</database>. If a user connects with a non-existing role, the engine silently
      resets it to <database>NONE</database> without returning an error.</para>
    </section>

    <section id="langrefupd21-current_time">
      <title><varname>CURRENT_TIME</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL, ESQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The fractional part of <varname>CURRENT_TIME</varname> used to be always
        <quote><literal>.0000</literal></quote>, giving an effective precision of 0 decimals. Now
        you can specify a precision when polling this variable. The default is still 0 decimals,
        i.e. seconds precision.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>TIME</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>CURRENT_TIME [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>

            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select current_time from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>

            <programlisting>select current_time(2) from rdb$database
-- returns e.g. 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>

      <note>
        <para>The default precision of <varname>CURRENT_TIMESTAMP</varname> is now 3 decimals, so
        <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum of
        <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you explicitly
        specify a precision.</para>
      </note>
    </section>

    <section id="langrefupd21-current_timestamp">
      <title><varname>CURRENT_TIMESTAMP</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL, ESQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The fractional part of <varname>CURRENT_TIMESTAMP</varname> used to be always
        <quote><literal>.0000</literal></quote>, giving an effective precision of 0 decimals. Now
        you can specify a precision when polling this variable. The default is 3 decimals, i.e.
        milliseconds precision.<!--This new functionality also available in ESQL? Dimtry says about the new ms precision:
"I believe it should be supported automagically." About the precision arg: "Not supported."--></para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>CURRENT_TIMESTAMP [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>

            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select current_timestamp from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>

            <programlisting>select current_timestamp(2) from rdb$database
-- returns e.g. 2008-08-13 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>

      <note>
        <para>The default precision of <varname>CURRENT_TIME</varname> is still 0 decimals, so
        <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum of
        <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you explicitly
        specify a precision.</para>
      </note>
    </section>

    <section id="langrefupd21-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><varname>CURRENT_TRANSACTION</varname> contains the system identifier of the current
        transaction context.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>

            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>

      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header
      page and reset upon restore. Unlike <varname>CURRENT_CONNECTION</varname>, it is incremented
      with every new transaction, whether the client reads the value or not.</para>
    </section>

    <section id="langrefupd21-current_user">
      <title><varname>CURRENT_USER</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <database>USER</database>.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>VARCHAR(31)</database></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-deleting">
      <title><varname>DELETING</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired
        because of a <database>DELETE</database> operation. Intended for use in <link
        linkend="langrefupd21-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para>boolean</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-gdscode">
      <title><varname>GDSCODE</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>In a <database>WHEN GDSCODE</database> handling block, the <varname>GDSCODE</varname>
        context variable contains a numerical representation of the current Firebird error code.
        Starting with Firebird 2.0, the same is true in a <database>WHEN ANY</database> block if its
        execution was triggered by a Firebird error; otherwise it contains 0.
        <varname>GDSCODE</varname> is also 0 in <database>WHEN SQLCODE</database> and <database>WHEN
        EXCEPTION</database> handlers, as well as everywhere else in PSQL.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>when gdscode 335544551, gdscode 335544552,
     gdscode 335544553, gdscode 335544707
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-inserting">
      <title><varname>INSERTING</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger
        fired because of an <database>INSERT</database> operation. Intended for use in <link
        linkend="langrefupd21-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para>boolean</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-new">
      <title><varname>NEW</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL, triggers only</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><varname>NEW</varname> contains the new version of a database record that has just
        been inserted or updated. Starting with Firebird 2.0 it is read-only in
        <database>AFTER</database> triggers.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database><database>Data row</database></database></para>
      </formalpara>

      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>NEW</varname> is
        always available. But if the trigger is fired by a <database>DELETE</database>, there will
        be no new version of the record. In that situation, reading from <varname>NEW</varname> will
        always return <constant>NULL</constant>; writing to it will cause a runtime
        exception.</para>
      </note>
    </section>

    <section id="langrefupd21-now">
      <title><literal>'NOW'</literal></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL, ESQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><literal>'NOW'</literal> is not a variable but a string literal. It is, however,
        special in the sense that when you <database>CAST()</database> it to a date/time type, you
        will get the current date and/or time. The fractional part of the time used to be always
        <quote><literal>.0000</literal></quote>, giving an effective seconds precision. In Firebird
        2.0 the precision is 3 decimals, i.e. milliseconds. <literal>'NOW'</literal> is
        case-insensitive, and the engine ignores leading or trailing spaces when casting.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database><database>CHAR(3)</database></database></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select 'Now' from rdb$database
-- returns 'Now'</programlisting>

            <programlisting>select cast('Now' as date) from rdb$database
-- returns e.g. 2008-08-13</programlisting>

            <programlisting>select cast('now' as time) from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>

            <programlisting>select cast('NOW' as timestamp) from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
          </blockquote></para>
      </formalpara>

      <note>
        <para>Using the date/time variables <varname>CURRENT_DATE</varname>, <link
        linkend="langrefupd21-current_time"><varname>CURRENT_TIME</varname></link> and <link
        linkend="langrefupd21-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link> is
        generally preferable to casting <literal>'NOW'</literal>. Be aware though that
        <varname>CURRENT_TIME</varname> defaults to seconds precision; to get milliseconds
        precision, use <varname>CURRENT_TIME</varname>(<parameter>3</parameter>).</para>
      </note>
    </section>

    <section id="langrefupd21-old">
      <title><varname>OLD</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL, triggers only</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><varname>OLD</varname> contains the existing version of a database record just before
        a deletion or update. Starting with Firebird 2.0 it is read-only.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database><database>Data row</database></database></para>
      </formalpara>

      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>OLD</varname> is
        always available. But if the trigger is fired by an <database>INSERT</database>, there is
        obviously no pre-existing version of the record. In that situation, reading from
        <varname>OLD</varname> will always return <constant>NULL</constant>; writing to it will
        cause a runtime exception.</para>
      </note>
    </section>

    <section id="langrefupd21-row_count">
      <title><varname>ROW_COUNT</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The <varname>ROW_COUNT</varname> context variable contains the number of rows affected
        by the most recent DML statement (<database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database>, <database>SELECT</database> or <database>FETCH</database>) in
        the current trigger, stored procedure or executable block.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Behaviour with <database>SELECT</database> and <database>FETCH</database></title>

        <para><itemizedlist>
            <listitem>
              <para>After a singleton <database>SELECT</database>, <varname>ROW_COUNT</varname> is 1
              if a data row was retrieved and 0 otherwise.</para>
            </listitem>

            <listitem>
              <para>In a <database>FOR SELECT</database> loop, <varname>ROW_COUNT</varname> is
              incremented with every iteration (starting at 0 before the first).</para>
            </listitem>

            <listitem>
              <para>After a <database>FETCH</database> from a cursor, <varname>ROW_COUNT</varname>
              is 1 if a data row was retrieved and 0 otherwise. Fetching more records from the same
              cursor does <emphasis>not</emphasis> increment <varname>ROW_COUNT</varname> beyond
              1.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.<replaceable>x</replaceable>, <varname>ROW_COUNT</varname> is 0
              after any type of <database>SELECT</database> statement.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <note>
        <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows affected
        by an <database>EXECUTE STATEMENT</database> or <database>EXECUTE PROCEDURE
        </database>command.</para>
      </note>
    </section>

    <section id="langrefupd21-sqlcode">
      <title><varname>SQLCODE</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>In a <database>WHEN SQLCODE</database> handling block, the <varname>SQLCODE</varname>
        context variable contains the current SQL error code. The same is true in a <database>WHEN
        ANY</database> block if its execution was triggered by an SQL error; otherwise it contains
        0. <varname>SQLCODE</varname> is also 0 in <database>WHEN GDSCODE</database> and
        <database>WHEN EXCEPTION</database> handlers, as well as everywhere else in PSQL.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-updating">
      <title><varname>UPDATING</varname></title>

      <formalpara>
        <title>Available in</title>

        <para>PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired
        because of an <database>UPDATE</database> operation. Intended for use in <link
        linkend="langrefupd21-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>

      <formalpara>
        <title>Type</title>

        <para>boolean</para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>

  <chapter id="langrefupd21-operators">
    <title>Operators and predicates</title>

    <section id="langrefupd21-operators-null">
      <title><constant>NULL</constant> literals allowed as operands</title>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Before Firebird 2.0, most operators and predicates did not allow
        <constant>NULL</constant> literals as operands. Tests or operations like <quote><code>A
        &lt;&gt; NULL</code></quote>, <quote><code>B + NULL</code></quote> or <quote><code>NULL &lt;
        ANY(...)</code></quote> would be rejected by the parser. Now they are allowed almost
        everywhere, but please be aware of the following:<blockquote>
            <para><emphasis>The vast majority of these newly allowed expressions return
            <constant>NULL</constant> regardless of the state or value of the other operand, and are
            therefore worthless for any practicle purpose whatsoever.</emphasis></para>
          </blockquote></para>
      </formalpara>

      <!--Made this a separate para because otherwise there is no space between it and the blockquote
above in the PDF version:-->

      <para>In particular, don't try to determine (non-)nullness of a field or variable by testing
      with <quote><code>= NULL</code></quote> or <quote><code>&lt;&gt; NULL</code></quote>. Always
      use <quote><code>IS [NOT] NULL</code></quote>.</para>

      <formalpara>
        <title>Predicates</title>

        <para>The <database>IN</database>, <database>ANY</database>/<database>SOME</database> and
        <database>ALL</database> predicates now also allow <constant>NULL</constant> literals where
        they were previously taboo. Here too, there is no practical benefit to enjoy, but the
        situation is a little more complicated in that predicates with <constant>NULL</constant>s do
        not always return a <constant>NULL</constant> result. For details, see the
        <citetitle>Firebird Null Guide</citetitle>, section <ulink
        url="http://www.firebirdsql.org/manual/nullguide-predicates.html"><citetitle>Predicates</citetitle></ulink>.</para>
      </formalpara>
    </section>

    <section id="langrefupd21-concat">
      <title>|| (string concatenator)</title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <section id="langrefupd21-concat-overflow">
        <title>Overflow checking</title>

        <formalpara>
          <title>Changed in</title>

          <para>1.0, 1.5</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>In Firebird versions 1.0.x, an error would be raised if, based on the declared
          string lengths, there was a <emphasis>possibility</emphasis> that a concatenation result
          would exceed the maximum string length of 32767 bytes. In Firebird 1.5 and above, the
          error is only raised if the <emphasis>actual outcome</emphasis> exceeds 32767
          bytes.</para>

          <!--Run-time Checking for Concatenation Overflow
D. Yemanov

Compile-time checking for concatenation overflow has been replaced by run-time checking.
From Firebird 1.0 onward, concatenation operations have been checked for the possibility
that the resulting string might exceed the string length limit of 32,000 bytes, i.e. overflow.

This check was performed during the statement prepare, using the declared operand sizes and
would throw an error for an expressions such as:
  CAST('qwe' AS VARCHAR(30000)) || CAST('rty' AS VARCHAR(30000))

**
  comment from PV: this is not correct: the above works fine in 2.0 *and* 1.5.3, returning
  a varchar(32765)
  (tested with:
     select
       cast('Aap' as varchar(30000)) || cast('Noot' as varchar(30000))
     from rdb$database)

  If I set up tables with varchar(30000) or char(30000) columns, the concatenation
  of the columns works fine. Both char and varchar, both in 2.0 and 1.5.3

  More testing: Fine in IB 6.0.1
                Explodes in Fb 1.0.3
                Fine in Fb 1.5.0

  CONCLUSION: Fixed in 1.5, not in 2.0 !!

  Also, 
  "select cast ('Aap' as varchar(30000)) || cast('Noot' as varchar(30000)) from rdb$database"
  prepares fine in Fb 1.0.3. It is during execution that things go wrong.
  -> but not everywhere! in 1.0.3 , using 1.0's isql it works fine. (with char and varchar).
    What is this?

  Get back to Dmitry about this.
**


From Firebird 2.0 onward, this expression throws only a warning at prepare time and the
overflow check is repeated at runtime, using the sizes of the actual operands. The result is
that our example will be executed without errors being thrown. The isc_concat_overflow exception
is now thrown only for actual overflows, thus bringing the behaviour of overflow detection for
concatenation into line with that for arithmetic operations.-->
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-all">
      <title><database>ALL</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <section id="langrefupd21-all-null">
        <title><constant>NULL</constant> literals allowed</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>The <database>ALL</database> predicate now allows a <constant>NULL</constant> as the
          test value. Notice that this brings no practical benefits. In particular, a
          <constant>NULL</constant> test value will not be considered equal to
          <constant>NULL</constant>s in the subquery result set. Even if the entire set is filled
          with <constant>NULL</constant>s and the operator chosen is <quote>=</quote>, the predicate
          will not return <constant>true</constant>, but <constant>NULL</constant>.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-all-union">
        <title><database>UNION</database> as subselect</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>The subselect in an <database>ALL</database> predicate may now also be a
          <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-any">
      <title><database>ANY</database> / <database>SOME</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <section id="langrefupd21-any-null">
        <title><constant>NULL</constant> literals allowed</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>The <database>ANY</database> (or <database>SOME</database>) predicate now allows a
          <constant>NULL</constant> as the test value. Notice that this brings no practical
          benefits. In particular, a <constant>NULL</constant> test value will not be considered
          equal to a <constant>NULL</constant> in the subquery result set.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-any-union">
        <title><database>UNION</database> as subselect</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>The subselect in an <database>ANY</database> (or <database>SOME</database>)
          predicate may now also be a <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-in">
      <title><database>IN</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <section id="langrefupd21-in-null">
        <title><constant>NULL</constant> literals allowed</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>The <database>IN</database> predicate now allows <constant>NULL</constant> literals,
          both as the test value and in the list. Notice that this brings no practical benefits. In
          particular, <quote><constant>NULL</constant> <database>IN</database> (...,
          <constant>NULL</constant>, ..., ...)</quote> will not return <constant>true</constant> and
          <quote><constant>NULL</constant> <database><database>NOT</database></database>
          <database>IN</database> (..., <constant>NULL</constant>, ..., ...)</quote> will not return
          <constant>false</constant>.</para>
        </formalpara>
      </section>

      <section id="langrefupd21-in-union">
        <title><database>UNION</database> as subselect</title>

        <formalpara>
          <title>Changed in</title>

          <para>2.0</para>
        </formalpara>

        <formalpara>
          <title>Description</title>

          <para>A subselect in an <database>IN</database> predicate may now also be a
          <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>

    <section id="langrefupd21-distinct">
      <title><database>IS [NOT] DISTINCT FROM</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Two operands are considered <database>DISTINCT</database> if they have a different
        value or if one of them is <constant>NULL</constant> and the other isn't. They are
        <database>NOT DISTINCT</database> if they have the same value or if both of them are
        <constant>NULL</constant>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>Boolean</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting><replaceable>op1</replaceable> IS [NOT] DISTINCT FROM <replaceable>op2</replaceable></programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select id, name, teacher from courses
  where start_day is not distinct from end_day</programlisting>

            <programlisting>if (New.Job is distinct from Old.Job)
  then post_event 'job_changed';</programlisting>
          </blockquote></para>
      </formalpara>

      <para><database>IS [NOT] DISTINCT FROM</database> always returns <constant>true</constant> or
      <constant>false</constant>, never <constant>NULL</constant> (unknown). The
      <quote><literal>=</literal></quote> and <quote><literal>&lt;&gt;</literal></quote> operators,
      by contrast, return <constant>NULL</constant> if one or both operands are
      <constant>NULL</constant>. See also the table below.</para>

      <table id="langrefupd21-tbl-distinct">
        <title>Comparison of <database>[NOT] DISTINCT</database> to
        <quote><literal>=</literal></quote> and <quote><literal>&lt;&gt;</literal></quote></title>

        <tgroup cols="5">
          <colspec colname="colOperands" />

          <colspec align="center" colname="colResult1" />

          <colspec align="center" colname="colResult2" />

          <colspec align="center" colname="colResult3" />

          <colspec align="center" colname="colResult4" />

          <spanspec nameend="colResult4" namest="colResult1" spanname="spanResults" />

          <thead>
            <row>
              <entry align="center" morerows="1">Operand characteristics</entry>

              <entry align="center" spanname="spanResults">Results with the different
              operators</entry>
            </row>

            <row>
              <entry align="center">=</entry>

              <entry align="center">NOT DISTINCT</entry>

              <entry align="center">&lt;&gt;</entry>

              <entry align="center">DISTINCT</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Same value</entry>

              <entry><constant>true</constant></entry>

              <entry><constant>true</constant></entry>

              <entry><constant>false</constant></entry>

              <entry><constant>false</constant></entry>
            </row>

            <row>
              <entry>Different values</entry>

              <entry><constant>false</constant></entry>

              <entry><constant>false</constant></entry>

              <entry><constant>true</constant></entry>

              <entry><constant>true</constant></entry>
            </row>

            <row>
              <entry>Both <constant>NULL</constant></entry>

              <entry><constant>NULL</constant></entry>

              <entry><constant>true</constant></entry>

              <entry><constant>NULL</constant></entry>

              <entry><constant>false</constant></entry>
            </row>

            <row>
              <entry>One <constant>NULL</constant></entry>

              <entry><constant>NULL</constant></entry>

              <entry><constant>false</constant></entry>

              <entry><constant>NULL</constant></entry>

              <entry><constant>true</constant></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="langrefupd21-nextvaluefor">
      <title><database>NEXT VALUE FOR</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL<!--ESQL: no--></para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the next value in a sequence. <database>SEQUENCE</database> is the
        SQL-compliant term for what InterBase and Firebird have always called a generator.
        <database>NEXT VALUE FOR</database> is fully equivalent to <database>GEN_ID(...,
        1)</database> and is the recommended syntax from Firebird 2.0 onward.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>NEXT VALUE FOR <replaceable>sequence-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>new.cust_id = next value for custseq;</programlisting>
          </blockquote></para>
      </formalpara>

      <para><database>NEXT VALUE FOR</database> doesn't support increment values other than 1. If
      you absolutely need other step values, use the legacy GEN_ID function.</para>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-create-seq"><database>CREATE SEQUENCE</database></link>,
        <link linkend="langrefupd21-genid"><database>GEN_ID()</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-some">
      <title><database>SOME</database></title>

      <para>See <link linkend="langrefupd21-any"><database>ANY</database></link></para>
    </section>
  </chapter>

  <chapter id="langrefupd21-functions">
    <title>Internal functions</title>

    <section id="langrefupd21-bit-length">
      <title><database>BIT_LENGTH()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Gives the length in bits of the input string. For multi-byte character sets, this may
        be less than the number of characters times 8 times the <quote>formal</quote> number of
        bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>BIT_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <note>
        <para>With arguments of type <database>CHAR</database>, this function usually takes the
        entire formal string length (e.g. the declared length of a field or variable) into account.
        In such cases, <database>TRIM</database> the argument first if you want to obtain the
        <quote>real</quote> bit length, without counting the trailing spaces.</para>
      </note>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select bit_length('Hello!') from rdb$database
  -- returns 48</programlisting>

            <programlisting>select bit_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 64: ü and ß take up one byte each in ISO8859_1</programlisting>

            <programlisting>select bit_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 80: ü and ß take up two bytes each in UTF8</programlisting>

            <programlisting>select bit_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 208: all 24 <database>CHAR</database> positions count, and two of them are 16-bit</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-octet-length"><database>OCTET_LENGTH()</database></link>,
        <link linkend="langrefupd21-char-length"><database>CHARACTER_LENGTH</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-cast">
      <title><database>CAST()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>CAST</database> converts an expression to the desired datatype. If the
        conversion is not possible, an error is thrown.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>User-chosen.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>CAST (<replaceable>expression</replaceable> AS <replaceable>datatype</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Shorthand syntax</title>

        <para><blockquote>
            <para>Alternative syntax, supported only when casting a string literal to a
            <database>DATE</database>, <database>TIME</database> or
            <database>TIMESTAMP</database>:</para>

            <programlisting><replaceable>datatype</replaceable> <replaceable>'date/timestring'</replaceable></programlisting>

            <para>This syntax was already available in InterBase, but was never properly
            documented.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select cast ('12' || '-June-' || '1959' as date) from rdb$database</programlisting>

            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; date '1-Jan-1943'</programlisting>

            <para>Notice that you can drop even the shorthand cast from the example above, as the
            engine will understand from the context (comparison to a <database>DATE</database>
            field) how to interpret the string:</para>

            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; '1-Jan-1943'</programlisting>

            <para>But this is not always possible. The cast below cannot be dropped, for otherwise
            the engine would find itself with an integer to be subtracted from a string:</para>

            <programlisting>select date 'today' - 7 from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>

      <para>The following table shows the type conversions possible with
      <database>CAST</database>.</para>

      <table id="langrefupd21-tbl-cast">
        <title>Possible <database>CAST</database>s</title>

        <tgroup cols="2">
          <colspec colname="colFromType" />

          <colspec colname="colToType" />

          <thead>
            <row>
              <entry>From</entry>

              <entry>To</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><simplelist>
                  <member>Numeric types</member>
                </simplelist></entry>

              <entry><simplelist>
                  <member>Numeric types</member>

                  <member><database>[VAR]CHAR</database></member>
                </simplelist></entry>
            </row>

            <row>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                </simplelist></entry>

              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>

                  <member>Numeric types</member>

                  <member><database>DATE</database></member>

                  <member><database>TIME</database></member>

                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
            </row>

            <row>
              <entry><simplelist>
                  <member><database>DATE</database></member>

                  <member><database>TIME</database></member>
                </simplelist></entry>

              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>

                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
            </row>

            <row>
              <entry><simplelist>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>

              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>

                  <member><database>DATE</database></member>

                  <member><database>TIME</database></member>
                </simplelist></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Keep in mind that sometimes information gets lost, for instance when you cast a
      <database>TIMESTAMP</database> to a <database>DATE</database>. Also, the fact that types are
      <database>CAST</database>-compatible is in itself no guarantee that a conversion will succeed.
      <database>CAST</database>(123456789 as <database>SMALLINT</database>) will definitely result
      in an error, as will <database>CAST</database>('Judgement Day' as
      <database>DATE</database>).</para>

      <formalpara>
        <title>New in Firebird 2.0:</title>

        <para>You can now cast statement parameters to a datatype, like in:</para>
      </formalpara>

      <blockquote>
        <programlisting>cast (? as integer)</programlisting>
      </blockquote>

      <!--It is now possible to use CAST to advise the engine about the data type of a parameter.
(D. Yemanov in Rlsnotes 2.0)-->
    </section>

    <section id="langrefupd21-char-length">
      <title><database>CHAR_LENGTH()</database>, <database>CHARACTER_LENGTH()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Gives the length in characters of the input string.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>CHAR_LENGTH (<replaceable>str</replaceable>)
CHARACTER_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <note>
        <para>With arguments of type <database>CHAR</database>, this function usually returns the
        formal string length (e.g. the declared length of a field or variable). In such cases,
        <database>TRIM</database> the argument first if you want to obtain the <quote>real</quote>
        length, without counting the trailing spaces.</para>

        <!--This is the case when
- CASTing to CHAR(n)
- Reading a CHAR(n) variable or table field

But e.g. a SUBSTRING result, although formally of the same length as the first
argument, has a CHAR_LENGTH (and strlen) equal to the 'FOR' argument or the
length to the end of the string, e.g:
SUBSTRING('Hello' from 3 for 2) is a CHAR(5) with CHAR_LENGTH 2
SUBSTRING('Hello' from 2) is a CHAR(5) with CHAR_LENGTH 4
SUBSTRING('Hello' from 2 for 8) is a CHAR(5) with CHAR_LENGTH 4

However, as soon as you CAST such substrings to a CHAR(n) or store them
in a CHAR(n) field or variable, the CHAR_LENGTH becomes n.

Another example: if you have a char(12) column with the string 'AB', it has
a CHAR_LENGTH of 12 and concatenation with '.' shows the 10 spaces. Now if
you select SUBSTRING(field from 2 for 2), you get a CHAR(12) with CHAR_LENGTH 2.
You see only an A, but concatenation with '.' shows there's a space behind it.

The conclusion must be (I think) that SUBSTRING puts a zero character after the
result, or maybe fills the entire formal length with zero chars.-->
      </note>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select char_length('Hello!') from rdb$database
  -- returns 6</programlisting>

            <programlisting>select char_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 8</programlisting>

            <programlisting>select char_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 8; the fact that ü and ß take up two bytes each is irrelevant</programlisting>

            <programlisting>select char_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 24: all 24 <database>CHAR</database> positions count</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-bit-length"><database>BIT_LENGTH()</database></link>,
        <link linkend="langrefupd21-octet-length"><database>OCTET_LENGTH</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-coalesce">
      <title><database>COALESCE()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The <database>COALESCE</database> function takes two or more arguments and returns the
        value of the first non-<constant>NULL</constant> argument. If all the arguments evaluate to
        <constant>NULL</constant>, <constant>NULL</constant> is returned.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>Depends on input.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>select 
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
  as FullName
from Persons</programlisting>
          </blockquote></para>
      </formalpara>

      <para>This example picks the Nickname from the Persons table. If it happens to be
      <constant>NULL</constant>, it goes on to FirstName. If that too is <constant>NULL</constant>,
      <quote>Mr./Mrs.</quote> is used. Finally, it adds the family name. All in all, it tries to use
      the available data to compose a full name that is as informal as possible. Notice that this
      scheme only works if absent nicknames and first names are really <constant>NULL</constant>: if
      one of them is an empty string instead, <database>COALESCE</database> will happily return that
      to the caller.</para>

      <note>
        <para>In Firebird 1.0.x, where <database>COALESCE</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd21-udf-nvl"><function>*nvl</function></link> external functions.</para>
      </note>
    </section>

    <section id="langrefupd21-extract">
      <title><database>EXTRACT()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>IB 6</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Extracts and returns an element from a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database> expression. It was already added
        in InterBase 6, but not documented in the <citetitle>Language Reference</citetitle> at the
        time.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>SMALLINT</database> or <database>DECIMAL(6,4)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | DAY | WEEKDAY | YEARDAY
                   | HOUR | MINUTE | SECOND
<replaceable>&lt;datetime&gt;</replaceable>  ::=  An expression of type DATE, TIME or TIMESTAMP</programlisting>
          </blockquote></para>
      </formalpara>

      <para>The returned datatype is <database>DECIMAL(6,4)</database> for the
      <database>SECOND</database> part and <database>SMALLINT</database> for all others. The ranges
      are shown in the table below.</para>

      <para>If you try to extract a part that isn't present in the date/time argument (e.g.
      <database>SECOND</database> from a <database>DATE</database> or <database>YEAR</database> from
      a <database>TIME</database>), an error occurs.</para>

      <table id="langrefupd21-tbl-extractranges">
        <title>Ranges for <database>EXTRACT</database> results</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry>Part</entry>

              <entry>Range</entry>

              <entry>Comment</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><database>YEAR</database></entry>

              <entry>1–9999</entry>

              <entry></entry>
            </row>

            <row>
              <entry><database>MONTH</database></entry>

              <entry>1–12</entry>

              <entry></entry>
            </row>

            <row>
              <entry><database>DAY</database></entry>

              <entry>1–31</entry>

              <entry></entry>
            </row>

            <row>
              <entry><database>WEEKDAY</database></entry>

              <entry>0–6</entry>

              <entry>0 = Sunday</entry>
            </row>

            <row>
              <entry><database>YEARDAY</database></entry>

              <entry>0–365</entry>

              <entry>0 = January 1</entry>
            </row>

            <row>
              <entry><database>HOUR</database></entry>

              <entry>0–23</entry>

              <entry></entry>
            </row>

            <row>
              <entry><database>MINUTE</database></entry>

              <entry>0–59</entry>

              <entry></entry>
            </row>

            <row>
              <entry><database>SECOND</database></entry>

              <entry>0.0000–59.999</entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <!--Tested: year in a DATE (when casting from dd.mm.yyyy string) can be 0-9999 in Fb1.5;
0 and 10000 give errors.
IB 6.5 doc specifies 0-5400 here
Oddly enough, DatDef sez DATE and TIMESTAMP can range from 1 Jan 100 a.d. to 29 Feb 32768 a.d.-->
    </section>

    <section id="langrefupd21-genid">
      <title><database>GEN_ID()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Increments a generator or sequence and returns its new value. From Firebird 2.0
        onward, the SQL-compliant <database>NEXT VALUE FOR</database> syntax is preferred, except
        when an increment other than 1 is needed.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>BIGINT</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>GEN_ID (<replaceable>generator-name</replaceable>, <replaceable>&lt;step&gt;</replaceable>)

<replaceable>&lt;step&gt;</replaceable>  ::=  An integer expression.</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>new.rec_id = gen_id(gen_recnum, 1);</programlisting>
          </blockquote></para>
      </formalpara>

      <warning>
        <para>Unless you know very well what you are doing, using <database>GEN_ID()</database> with
        step values lower than 1 may compromise your data's integrity.</para>
      </warning>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-nextvaluefor"><database>NEXT VALUE FOR</database></link>,
        <link linkend="langrefupd21-create-gen"><database>CREATE GENERATOR</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-iif">
      <title><database>IIF()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>IIF</database> takes three arguments. If the first evaluates to
        <constant>true</constant>, the second argument is returned; otherwise the third is
        returned.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>Depends on input.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>IIF (<replaceable>&lt;condition&gt;</replaceable>, <replaceable>ResultT</replaceable>, <replaceable>ResultF</replaceable>)

<replaceable>&lt;condition&gt;</replaceable>  ::=  A boolean expression.</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>select iif( sex = 'M', 'Sir', 'Madam' ) from Customers</programlisting>
          </blockquote></para>
      </formalpara>

      <para><database>IIF</database>(<parameter>Cond</parameter>, <parameter>Result1</parameter>,
      <parameter>Result2</parameter>) is a shortcut for <quote><database>CASE</database>
      <database>WHEN</database> <parameter>Cond</parameter> <database>THEN</database>
      <parameter>Result1</parameter> <database>ELSE</database> <parameter>Result2</parameter>
      <database>END</database></quote>. You can also compare <database>IIF</database> to the ternary
      <quote><literal>?</literal> <literal>:</literal></quote> operator in C-like languages.</para>
    </section>

    <section id="langrefupd21-lower">
      <title><database>LOWER()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the lower-case equivalent of the input string. This function also correctly
        lowercases non-ASCII characters, even if the default (binary) collation is used. The
        character set must be appropriate though: with <database>ASCII</database> or
        <database>NONE</database> for instance, only ASCII characters are lowercased; with
        <database>OCTETS</database>, the entire string is returned unchanged.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VAR(CHAR)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>LOWER (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>select Sheriff from Towns
  where lower(Name) = 'cooper''s valley'</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-upper"><database>UPPER</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-nullif">
      <title><database>NULLIF()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para><database>NULLIF</database> returns the value of the first argument, unless it is
        equal to the second. In that case, <constant>NULL</constant> is returned.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>Depends on input.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
          </blockquote></para>
      </formalpara>

      <para>This will return the average weight of the persons listed in FatPeople, excluding those
      having a weight of -1, since <database>AVG</database> skips <constant>NULL</constant> data.
      Presumably, -1 indicates <quote>weight unknown</quote> in this table. A plain
      <database>AVG</database>(Weight) would include the -1 weights, thus skewing the result.</para>

      <note>
        <para>In Firebird 1.0.x, where <database>NULLIF</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd21-udf-nullif"><function>*nullif</function></link> external
        functions.</para>
      </note>
    </section>

    <section id="langrefupd21-octet-length">
      <title><database>OCTET_LENGTH()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Gives the length in bytes (octets) of the input string. For multi-byte character sets,
        this may be less than the number of characters times the <quote>formal</quote> number of
        bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
      </formalpara>

      <note>
        <para>With arguments of type <database>CHAR</database>, this function usually takes the
        entire formal string length (e.g. the declared length of a field or variable) into account.
        In such cases, <database>TRIM</database> the argument first if you want to obtain the
        <quote>real</quote> byte length, without counting the trailing spaces.</para>
      </note>

      <formalpara>
        <title>Result type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>OCTET_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select octet_length('Hello!') from rdb$database
  -- returns 6</programlisting>

            <programlisting>select octet_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 8: ü and ß take up one byte each in ISO8859_1</programlisting>

            <programlisting>select octet_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 10: ü and ß take up two bytes each in UTF8</programlisting>

            <programlisting>select octet_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 26: all 24 <database>CHAR</database> positions count, and two of them are 2-byte</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-bit-length"><database>BIT_LENGTH()</database></link>,
        <link linkend="langrefupd21-char-length"><database>CHARACTER_LENGTH</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-get-context">
      <title><database>RDB$GET_CONTEXT()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>

        <!--Since it's a declared UDF, it should be availabe in ESQL-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Retrieves the value of a context variable from one of the namespaces
        <database>SYSTEM</database>, <database>USER_SESSION</database> and
        <database>USER_TRANSACTION</database>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(255)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>RDB$GET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>')

<replaceable>&lt;namespace&gt;</replaceable>  ::=  SYSTEM | USER_SESSION | USER_TRANSACTION
<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title role="block">The namespaces</title>

        <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
        namespaces are initially empty. The user can create and set variables in them with
        <database>RDB$SET_CONTEXT()</database> and retrieve them with
        <database>RDB$GET_CONTEXT()</database>. The <database>SYSTEM</database> namespace is
        read-only. It contains a number of predefined variables, shown in the table below.<table
            border="topbot" id="langrefupd21-tbl-systemnamespace">
            <title>Context variables in the SYSTEM namespace</title>

            <tgroup cols="2">
              <colspec colname="colVarname" colwidth="1*" />

              <colspec colname="colVardescr" colwidth="3*" />

              <tbody>
                <row valign="top">
                  <entry><varname>DB_NAME</varname></entry>

                  <entry>Either the full path to the database or – if connecting via the path is
                  disallowed – its alias.</entry>
                </row>

                <row valign="top">
                  <entry><varname>NETWORK_PROTOCOL</varname></entry>

                  <entry>The protocol used for the connection. Can be <literal>'TCPv4'</literal>,
                  <literal>'WNET'</literal>, <literal>'XNET'</literal> or
                  <constant>NULL</constant>.</entry>
                </row>

                <row valign="top">
                  <entry><varname>CLIENT_ADDRESS</varname></entry>

                  <entry>For TCPv4, this is the IP address. For XNET, the local process ID. For all
                  other protocols this variable is <constant>NULL</constant>.</entry>
                </row>

                <row valign="top">
                  <entry><varname>CURRENT_USER</varname></entry>

                  <entry>Same as general <link
                  linkend="langrefupd21-current_user"><varname>CURRENT_USER</varname></link>
                  variable.</entry>
                </row>

                <row valign="top">
                  <entry><varname>CURRENT_ROLE</varname></entry>

                  <entry>Same as general <link
                  linkend="langrefupd21-current_role"><varname>CURRENT_ROLE</varname></link>
                  variable.</entry>
                </row>

                <row valign="top">
                  <entry><varname>SESSION_ID</varname></entry>

                  <entry>Same as general <link
                  linkend="langrefupd21-current_connection"><varname>CURRENT_CONNECTION</varname></link>
                  variable.</entry>
                </row>

                <row valign="top">
                  <entry><varname>TRANSACTION_ID</varname></entry>

                  <entry>Same as general <link
                  linkend="langrefupd21-current_transaction"><varname>CURRENT_TRANSACTION</varname></link>
                  variable.</entry>
                </row>

                <row valign="top">
                  <entry><varname>ISOLATION_LEVEL</varname></entry>

                  <entry>The isolation level of the current transaction; can be
                  <literal>'READ</literal> <literal>COMMITTED'</literal>,
                  <literal>'SNAPSHOT'</literal> or <literal>'CONSISTENCY'</literal>.</entry>
                </row>
              </tbody>
            </tgroup>
          </table><!--Ik moet bovenstaande variabelen ook op de een of andere manier opnemen in het hoofdstuk
"Context Variables", al is het maar als verwijzingen.--></para>
      </formalpara>

      <formalpara>
        <title>Return values and error behaviour</title>

        <para>If the polled variable exists in the given namespace, its value will be returned as a
        string of max. 255 characters. If the namespace doesn't exist or if you try to access a
        non-existing variable in the <database>SYSTEM</database> namespace, an error is raised. If
        you poll a non-existing variable in one of the other namespaces, <constant>NULL</constant>
        is returned. Both namespace and variable names must be given as single-quoted,
        case-sensitive, non-<constant>NULL</constant> strings.</para>

        <!--Funny enough, a variable's name may be the empty string.-->
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database</programlisting>
          </blockquote><blockquote>
            <programlisting>New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');</programlisting>

            <programlisting>insert into MyTable (TestField)
  values (rdb$get_context('USER_SESSION', 'MyVar'))</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link
        linkend="langrefupd21-set-context"><database>RDB$SET_CONTEXT()</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-set-context">
      <title><database>RDB$SET_CONTEXT()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>

        <!--Since it's a declared UDF, it should be availabe in ESQL-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Creates, sets or unsets a variable in one of the user-writable namespaces
        <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>INTEGER</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>RDB$SET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>', <replaceable>&lt;value&gt;</replaceable> | <constant>NULL</constant>)

<replaceable>&lt;namespace&gt;</replaceable>  ::=  USER_SESSION | USER_TRANSACTION
<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters
<replaceable>&lt;value&gt;</replaceable>      ::=  A value of any type, as long as it's castable
                  to a VARCHAR(255)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title role="block">The namespaces</title>

        <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
        namespaces are initially empty. The user can create and set variables in them with
        <database>RDB$SET_CONTEXT()</database> and retrieve them with
        <database>RDB$GET_CONTEXT()</database>. The <database>USER_SESSION</database> context is
        bound to the current connection. Variables in <database>USER_TRANSACTION</database> only
        exist in the transaction in which they have been set. When the transaction ends, the context
        and all the variables defined in it are destroyed.</para>
      </formalpara>

      <formalpara>
        <title role="block">Return values and error behaviour</title>

        <para>The function returns 1 if the variable already existed before the call and 0 if it
        didn't. To remove a variable from a context, set it to <constant>NULL</constant>. If the
        given namespace doesn't exist, an error is raised. Both namespace and variable names must be
        entered as single-quoted, case-sensitive, non-<constant>NULL</constant> strings.</para>

        <!--Funny enough, a variable's name may be the empty string.-->
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database</programlisting>
          </blockquote><blockquote>
            <programlisting>rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);</programlisting>

            <programlisting>select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
  from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>The maximum number of variables in any single context is 1000.</para>
            </listitem>

            <listitem>
              <para>All <database>USER_TRANSACTION</database> variables will survive a <link
              linkend="langrefupd21-rollback-retain"><database>ROLLBACK RETAIN</database></link> or
              <link linkend="langrefupd21-rollback-to-savepoint"><database>ROLLBACK TO
              SAVEPOINT</database></link> unaltered, no matter when in the transaction they were
              set.</para>
            </listitem>

            <listitem>
              <para>To the user, <database>RDB$SET_CONTEXT()</database> and
              <database>RDB$GET_CONTEXT()</database> are built-in functions. Internally, they are a
              kind of <quote>auto-declared UDFs</quote>, even though they're not in an external
              library. It is because of this UDF-like nature that they can – in PSQL only – be
              called like a void function, without assigning the result, as in the second example
              above. With regular internal functions this is not allowed.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link
        linkend="langrefupd21-get-context"><database>RDB$GET_CONTEXT()</database></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-substring">
      <title><database>SUBSTRING()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns a string's substring starting at the given position, either to the end of the
        string or with a given length.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>CHAR(<replaceable>n</replaceable>)</database><!--Also if used with BLOBs ?--></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>SUBSTRING (<replaceable>&lt;str&gt;</replaceable> FROM <replaceable>startpos</replaceable> [FOR <replaceable>length</replaceable>])

&lt;str&gt;  ::=  any expression evaluating to a string</programlisting>
          </blockquote></para>
      </formalpara>

      <para><database>SUBSTRING</database> returns the stream of bytes starting at byte position
      <replaceable>startpos</replaceable> (the first byte position being 1). Without the
      <database>FOR</database> argument, it returns all the remaining bytes in the string. With
      <database>FOR</database>, it returns <replaceable>length</replaceable> bytes or the remainder
      of the string, whichever is shorter.</para>

      <para>In Firebird 1.x, <replaceable>startpos</replaceable> and
      <replaceable>length</replaceable> must be integer literals. In 2.0 and above they can be any
      valid integer expression.</para>

      <para>The width of the result field is always equal to the length of
      <replaceable>str</replaceable>, regardless of <replaceable>startpos</replaceable> and
      <replaceable>length</replaceable>. So, <code>substring('pinhead' from 4 for 2)</code> will
      return a <database>CHAR(7)</database> containing the string <literal>'he'</literal>.</para>

      <para><database>SUBSTRING</database> can be used with:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>Any string or (var)char argument, regardless of its character set;</para>
        </listitem>

        <listitem>
          <para>Subtype 0 (binary) <database>BLOB</database>s;</para>
        </listitem>

        <listitem>
          <para>Subtype 1 (text) <database>BLOB</database>s, if the character set has 1 byte per
          character.</para>
        </listitem>
      </itemizedlist>

      <para><database>SUBSTRING</database> can <emphasis>not</emphasis> be used with text
      <database>BLOB</database>s that have an underlying multi-byte character set.</para>

      <formalpara>
        <title>Example</title>

        <para><blockquote>
            <programlisting>insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames</programlisting>
          </blockquote></para>
      </formalpara>

      <note>
        <title>Effect of <constant>NULL</constant>s</title>

        <itemizedlist>
          <listitem>
            <para>If <replaceable>str</replaceable> is <constant>NULL</constant>, the function
            returns <constant>NULL</constant>.</para>

            <!--With a NULL string, the result type is the type the NULL was cast to
(possibly after subsequent conversion to char). If the NULL was a literal
(2.0+), the result type is CHAR(1).-->
          </listitem>

          <listitem>
            <para>If <replaceable>str</replaceable> is a valid string but
            <replaceable>startpos</replaceable> and/or <replaceable>length</replaceable> is
            <constant>NULL</constant> (only possible in 2.0+), the function returns
            <constant>NULL</constant> but describes the result field as non-nullable. As a result,
            most clients (including <application>isql</application>) will incorrectly show the
            result as an empty string.</para>

            <!--Nullguide says: This bug seems to be fixed in 2.1.-->
          </listitem>
        </itemizedlist>
      </note>
    </section>

    <section id="langrefupd21-trim">
      <title><database>TRIM()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, PSQL</para>

        <!--ESQL: no-->
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Removes leading and/or trailing blanks (or optionally other characters) from the input
        string.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VAR(CHAR)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>TRIM ([<replaceable>&lt;adjust&gt;</replaceable>] <replaceable>str</replaceable>)

<replaceable>&lt;adjust&gt;</replaceable>  ::=  {[<replaceable>&lt;where&gt;</replaceable>] [<replaceable>&lt;what&gt;</replaceable>]} FROM

<replaceable>&lt;where&gt;</replaceable>   ::=  BOTH | LEADING | TRAILING       /* default is BOTH */

<replaceable>&lt;what&gt; </replaceable>   ::=  The substring to be trimmed (repeatedly if necessary)
               from <replaceable>str</replaceable>'s head and/or tail. Default is ' ' (space).</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select trim ('  Waste no space   ') from rdb$database
  -- returns 'Waste no space'</programlisting>

            <programlisting>select trim (leading from '  Waste no space   ') from rdb$database
  -- returns 'Waste no space   '</programlisting>

            <programlisting>select trim (leading '.' from '  Waste no space   ') from rdb$database
  -- returns '  Waste no space   '</programlisting>

            <programlisting>select trim (trailing '!' from 'Help!!!!') from rdb$database
  -- returns 'Help'</programlisting>

            <programlisting>select trim ('la' from 'lalala I love you Ella') from rdb$database
  -- returns ' I love you El'</programlisting>

            <programlisting>select trim ('la' from 'Lalala I love you Ella') from rdb$database
  -- returns 'Lalala I love you El'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-upper">
      <title><database>UPPER()</database></title>

      <formalpara>
        <title>Available in</title>

        <para>DSQL, ESQL, PSQL</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the upper-case equivalent of the input string. Since Firebird 2 this function
        also correctly uppercases non-ASCII characters, even if the default (binary) collation is
        used. The character set must be appropriate though: with <database>ASCII</database> or
        <database>NONE</database> for instance, only ASCII characters are uppercased; with
        <database>OCTETS</database>, the entire string is returned unchanged.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VAR(CHAR)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>UPPER (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Examples</title>

        <para><blockquote>
            <programlisting>select upper(_iso8859_1 'Débâcle')
from rdb$database
  -- returns 'DÉBÂCLE' (before Firebird 2.0: 'DéBâCLE')</programlisting>

            <programlisting>select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
  -- returns 'DEBACLE', following French uppercasing rules</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-upper"><database>UPPER</database></link></para>
      </formalpara>
    </section>
  </chapter>

  <chapter id="langrefupd21-udf">
    <title>External functions (UDFs)</title>

    <para>External functions must be <quote>declared</quote> (made known) to the database before
    they can be used. Firebird ships with two external function libraries:</para>

    <itemizedlist>
      <listitem>
        <para><systemitem class="library">ib_udf</systemitem> – inherited from InterBase;</para>
      </listitem>

      <listitem>
        <para><systemitem class="library">fbudf</systemitem> – a new library using <link
        linkend="langrefupd21-declareext-bydescriptor">descriptors</link>, present as from Firebird
        1.0 (Windows) and 1.5 (Linux).</para>
      </listitem>
    </itemizedlist>

    <para>Users can also create their own UDF libraries or acquire them from third parties.</para>

    <!--Wherever appropriate I used 32767 as a max string length, not 32765 (max. VARCHAR-length).
This is about what the function itself and the Firebird engine can handle when you call it
from your SQL, *not* about whether the result subsequently fits in a VARCHAR.-->

    <section id="langrefupd21-udf-addday">
      <title><function>addDay</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> days added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addday (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addDay
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addDay' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addhour">
      <title><function>addHour</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> hours added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addhour (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addHour
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addHour' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addmillisecond">
      <title><function>addMilliSecond</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> milliseconds added.
        Use negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addmillisecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMilliSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addminute">
      <title><function>addMinute</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> minutes added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addminute (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMinute
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addmonth">
      <title><function>addMonth</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> months added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addmonth (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMonth
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addsecond">
      <title><function>addSecond</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> seconds added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addsecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addweek">
      <title><function>addWeek</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> weeks added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addweek (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addWeek
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-addyear">
      <title><function>addYear</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the first argument with <replaceable>number</replaceable> years added. Use
        negative numbers to subtract.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>addyear (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addYear
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addYear' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-ascii_char">
      <title><function>ascii_char</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.0, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the ASCII character corresponding to the integer value passed in.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(1)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax (unchanged)</title>

        <para><blockquote>
            <programlisting>ascii_char (<parameter>intval</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ascii_char
   INTEGER <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(1) FREE_IT
   ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf'</programlisting>

            <para>The declaration reflects the fact that the UDF as such returns a 1-character C
            string, not an SQL <database>CHAR(1)</database> as stated in the InterBase declaration.
            The engine will pass the result to the caller as a <database>VARCHAR(1)</database>
            though.</para>

            <para>The <emphasis role="bold">NULL</emphasis> after INTEGER is an optional addition
            that became available in Firebird 2. When declared with the <database>NULL</database>
            keyword, the engine will pass a <constant>NULL</constant> argument unchanged to the
            function. This causes a <constant>NULL</constant> result, which is correct. Without the
            <database>NULL</database> keyword (your only option in pre-2.0 versions),
            <constant>NULL</constant> is passed to the function as 0 and the result is an empty
            string.</para>

            <!--Actually, the UDF fills in a \0 here (NUL character), but since it's a
C string, this acts as a string terminator so the result is an empty string.-->

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para><function>ascii_char(0)</function> returns an empty string in all versions, not
              a character with ASCII value 0.</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was <database>CHAR(1)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-dow">
      <title><function>dow</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the day of the week from a timestamp argument. The returned name may be
        localized.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(15)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>dow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dow
   TIMESTAMP,
   VARCHAR(15) RETURNS PARAMETER 2
   ENTRY_POINT 'DOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-udf-sdow"><function>sdow</function></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-dpower">
      <title><function>dpower</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th
        power.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>dpower (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dPower
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR,
   DOUBLE PRECISION BY DESCRIPTOR
   RETURNS PARAMETER 3
   ENTRY_POINT 'power' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-getexacttimestamp">
      <title><function>getExactTimestamp</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>2.0 – use the improved <link
        linkend="langrefupd21-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link> context
        variable</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the system time with milliseconds precision. This function was added because
        in pre-2.0 versions, <varname>CURRENT_TIMESTAMP</varname> always had
        <literal>.0000</literal> in the fractional part of the second. In Firebird 2.0 and up it is
        better to use <link
        linkend="langrefupd21-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>, which
        now also defaults to milliseconds precision.</para>

        <!--Check: is precision indeed ms, or tenths-of-ms ? In isql 4 decimals are returned, but 4th
seems to be always 0. (This may differ per OS however.)-->
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>TIMESTAMP</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>getexacttimestamp()</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION getExactTimestamp
   TIMESTAMP RETURNS PARAMETER 1
   ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-i64round">
      <title><function>i64round</function></title>

      <para>See <link linkend="langrefupd21-udf-round"><function>round</function></link>.</para>
    </section>

    <section id="langrefupd21-udf-i64truncate">
      <title><function>i64truncate</function></title>

      <para>See <link
      linkend="langrefupd21-udf-truncate"><function>truncate</function></link>.</para>
    </section>

    <section id="langrefupd21-udf-log">
      <title><function>log</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>In Firebird 1.5 and up, <function>log</function> returns the the
        base-<parameter>x</parameter> logarithm of <parameter>y</parameter>. In Firebird 1.0.x and
        InterBase, it erroneously returns the base-<parameter>y</parameter> logarithm of
        <parameter>x</parameter>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax (unchanged)</title>

        <para><blockquote>
            <programlisting>log (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration (unchanged)</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION log
   DOUBLE PRECISION, DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>

      <warning>
        <para>If any of your pre-1.5 databases uses <function>log</function>, check your PSQL and
        application code. It may contain workarounds to return the right results. Under Firebird 1.5
        and up, any such workarounds should be removed or you'll get the wrong results.</para>
      </warning>
    </section>

    <section id="langrefupd21-udf-lower">
      <title><function>lower</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>2.0 – use the internal function <link
        linkend="langrefupd21-lower"><database>LOWER()</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the lower-case version of the input string. Please notice that only ASCII
        characters are handled correctly. If possible, use the new, superior internal function
        <database>LOWER</database> instead. Just dropping the declaration of the
        <function>lower</function> UDF should do the trick, unless you gave it an alternative
        name.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>"LOWER" (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION "LOWER"
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lower' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>.
            <quote><database>LOWER</database></quote> has been surrounded by double-quotes to avoid
            confusion with the new internal function <database>LOWER</database>.</para>

            <para>The <emphasis role="bold">NULL</emphasis> after CSTRING(255) is an optional
            addition that became available in Firebird 2. When declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument unchanged to the function. This leads to a <constant>NULL</constant> result,
            which is correct. Without the <database>NULL</database> keyword (your only option in
            pre-2.0 versions), <constant>NULL</constant> is passed to the function as an empty
            string and the result is an empty string as well.</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-lpad">
      <title><function>lpad</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5.2, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the input string left-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>lpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, INTEGER, CSTRING(1) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis>s after the CSTRING arguments are an optional
            addition that became available in Firebird 2. If an argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant>s are passed to the function as
            empty strings and the result is a string with <replaceable>endlengh</replaceable>
            padchars (if <replaceable>str</replaceable> is <constant>NULL</constant>) or a copy of
            <replaceable>str</replaceable> itself (if <replaceable>padchar</replaceable> is
            <constant>NULL</constant>).</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>When calling this function, make sure <replaceable>endlength</replaceable> does
              not exceed the declared result length.</para>
            </listitem>

            <listitem>
              <para>If <replaceable>endlength</replaceable> is less than
              <replaceable>str</replaceable>'s length, <replaceable>str</replaceable> is truncated
              to <replaceable>endlength</replaceable>. If <replaceable>endlength</replaceable> is
              negative, the result is <constant>NULL</constant>.</para>
            </listitem>

            <listitem>
              <para>A <constant>NULL</constant> <replaceable>endlength</replaceable> is treated as
              if it were 0.</para>
            </listitem>

            <listitem>
              <para>If <replaceable>padchar</replaceable> is empty, or if
              <replaceable>padchar</replaceable> is <constant>NULL</constant> and the function has
              been declared without the <database>NULL</database> keyword after the last argument,
              <replaceable>str</replaceable> is returned unchanged (or truncated to
              <replaceable>endlength</replaceable>).</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>A bug that caused an endless loop if <replaceable>padchar</replaceable> was
              empty or <constant>NULL</constant> has been fixed in 2.0.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-ltrim">
      <title><function>ltrim</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5, 1.5.2, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>2.0 – use <link linkend="langrefupd21-trim"><database>TRIM()</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the input string with any leading space characters removed. In new code, you
        are advised to use the internal function <database>TRIM</database> instead, as it is both
        more powerful and more versatile.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax (unchanged)</title>

        <para><blockquote>
            <programlisting>ltrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ltrim
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.0.x, this function returned <constant>NULL</constant> if the input
              string was either empty or <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-nullif">
      <title><function>*nullif</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>1.5 – use the internal function <link
        linkend="langrefupd21-nullif"><database>NULLIF()</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The four <function>*nullif</function> functions – for integers, bigints, doubles and
        strings, respectively – each return the first argument if it is not equal to the second. If
        the arguments are equal, the functions return <constant>NULL</constant>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>Varies, see declarations.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>inullif   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nullif (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnullif   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snullif   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>As from Firebird 1.5 these functions are all deprecated. Use the new internal function
      <link linkend="langrefupd21-nullif"><database>NULLIF</database></link> instead.</para>

      <warning>
        <title>Warnings</title>

        <itemizedlist>
          <listitem>
            <para>These functions return <constant>NULL</constant> when the second argument is
            <constant>NULL</constant>, even if the first argument is a proper value. This is a wrong
            result. The <database>NULLIF</database> internal function doesn't have this bug.</para>
          </listitem>

          <listitem>
            <para><function>i64nullif</function> and <function>dnullif</function> will return wrong
            and/or bizarre results if it is not 100% clear to the engine that each argument is of
            the intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE
            PRECISION</database>). If in doubt, cast them both explicitly to the declared type (see
            declarations below).</para>
          </listitem>
        </itemizedlist>
      </warning>

      <formalpara>
        <title>Declarations</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION inullif
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION i64nullif
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS NUMERIC(18,4) BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>

            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->

            <programlisting>DECLARE EXTERNAL FUNCTION dnullif
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION snullif
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-nvl">
      <title><function>*nvl</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>1.5 – use <link
        linkend="langrefupd21-coalesce"><database>COALESCE()</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>The four <function>nvl</function> functions – for integers, bigints, doubles and
        strings, respectively – are <constant>NULL</constant> replacers. They each return the first
        argument's value if it is not <constant>NULL</constant>. If the first argument is
        <constant>NULL</constant>, the value of the second argument is returned.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para>Varies, see declarations.</para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>invl   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nvl (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnvl   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snvl   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <para>As from Firebird 1.5 these functions are all deprecated. Use the new internal function
      <link linkend="langrefupd21-coalesce"><database>COALESCE</database></link> instead.</para>

      <warning>
        <para><function>i64nvl</function> and <function>dnvl</function> will return wrong and/or
        bizarre results if it is not absolutely clear to the engine that each argument is of the
        intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE PRECISION</database>).
        If in doubt, cast both arguments explicitly to the declared type (see declarations
        below).</para>
      </warning>

      <formalpara>
        <title>Declarations</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION invl
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION i64nvl
   NUMERIC(18,0) BY DESCRIPTOR, NUMERIC(18,0) BY DESCRIPTOR
   RETURNS NUMERIC(18,0) BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION dnvl
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION snvl
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-rand">
      <title><function>rand</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns a pseudo-random number. Before Firebird 2.0, this function would first seed
        the random number generator with the current time in seconds. Multiple
        <function>rand()</function> calls within the same second would therefore return the same
        value. If you want that old behaviour in Firebird 2 and up, use the new function <link
        linkend="langrefupd21-udf-srand"><function>srand()</function></link>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>rand ()</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rand
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_rand' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-right">
      <title><function>right</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the rightmost <replaceable>numchars</replaceable> characters of the input
        string.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(100)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>right (<parameter>str</parameter>, <parameter>numchars</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION right
   VARCHAR(100) BY DESCRIPTOR, SMALLINT,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'right' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-round">
      <title><function>round</function>, <function>i64round</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>These functions return the whole number that is nearest to their (scaled
        numeric/decimal) argument. They do not work with floats or doubles.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>INTEGER</database> / <database>NUMERIC(18,4)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>round    (<parameter>number</parameter>)
i64round (<parameter>big</parameter>number)</programlisting>
          </blockquote></para>
      </formalpara>

      <warning>
        <title>Bug warning</title>

        <para>These functions are <emphasis>broken</emphasis> for negative numbers:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Anything between 0 and -0.6 (that's right: -0.6, not -0.5) is rounded to 0.</para>
          </listitem>

          <listitem>
            <para>Anything between -0.6 and -1 is rounded to +1 (<emphasis>plus</emphasis>
            1).</para>
          </listitem>

          <listitem>
            <para>Anything between -1 and -1.6 is rounded to -1.</para>
          </listitem>

          <listitem>
            <para>Anything between -1.6 and -2 is rounded to -2.</para>
          </listitem>

          <listitem>
            <para>Etcetera.</para>
          </listitem>
        </itemizedlist>

        <!--Tested in 1.0 and 1.5 -> same shit.-->
      </warning>

      <formalpara>
        <title>Declarations</title>

        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>round</function>:</para>

            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>

            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->

            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbround</function>:</para>

            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>

            <!--Keep the line below in sync with that under truncate:-->

            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names.</para>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-rpad">
      <title><function>rpad</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5.2, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the input string right-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>rpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rpad
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, INTEGER, CSTRING(1) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis>s after the CSTRING arguments are an optional
            addition that became available in Firebird 2. If an argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant>s are passed to the function as
            empty strings and the result is a string with <replaceable>endlengh</replaceable>
            padchars (if <replaceable>str</replaceable> is <constant>NULL</constant>) or a copy of
            <replaceable>str</replaceable> itself (if <replaceable>padchar</replaceable> is
            <constant>NULL</constant>).</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>When calling this function, make sure <replaceable>endlength</replaceable> does
              not exceed the declared result length.</para>
            </listitem>

            <listitem>
              <para>If <replaceable>endlength</replaceable> is less than
              <replaceable>str</replaceable>'s length, <replaceable>str</replaceable> is truncated
              to <replaceable>endlength</replaceable>. If <replaceable>endlength</replaceable> is
              negative, the result is <constant>NULL</constant>.</para>
            </listitem>

            <listitem>
              <para>A <constant>NULL</constant> <replaceable>endlength</replaceable> is treated as
              if it were 0.</para>
            </listitem>

            <listitem>
              <para>If <replaceable>padchar</replaceable> is empty, or if
              <replaceable>padchar</replaceable> is <constant>NULL</constant> and the function has
              been declared without the <database>NULL</database> keyword after the last argument,
              <replaceable>str</replaceable> is returned unchanged (or truncated to
              <replaceable>endlength</replaceable>).</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>A bug that caused an endless loop if <replaceable>padchar</replaceable> was
              empty or <constant>NULL</constant> has been fixed in 2.0.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-rtrim">
      <title><function>rtrim</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5, 1.5.2, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>2.0 – use <link linkend="langrefupd21-trim"><database>TRIM()</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the input string with any trailing space characters removed. In new code, you
        are advised to use the internal function <database>TRIM</database> instead, as it is both
        more powerful and more versatile.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax (unchanged)</title>

        <para><blockquote>
            <programlisting>rtrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rtrim
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.0.x, this function returned <constant>NULL</constant> if the input
              string was either empty or <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-sdow">
      <title><function>sdow</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the abbreviated day of the week from a timestamp argument. The returned
        abbreviation may be localized.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(5)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>sdow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sdow
   TIMESTAMP,
   VARCHAR(5) RETURNS PARAMETER 2
   ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>See also</title>

        <para><link linkend="langrefupd21-udf-dow"><function>dow</function></link></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-srand">
      <title><function>srand</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Seeds the random number generator with the current time in seconds and then returns
        the first number. Multiple <function>srand()</function> calls within the same second will
        return the same value. This is exactly how <link
        linkend="langrefupd21-udf-srand"><function>rand()</function></link> behaved before Firebird
        2.0.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>srand ()</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION srand
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_srand' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-string2blob">
      <title><function>string2blob</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the input string as a <database>BLOB</database>.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>BLOB</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>string2blob (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION string2blob
   VARCHAR(300) BY DESCRIPTOR,
   BLOB RETURNS PARAMETER 2
   ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>

    <section id="langrefupd21-udf-substr">
      <title><function>substr</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.0, 1.5.2, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns a string's substring from <parameter>startpos</parameter> to
        <parameter>endpos</parameter>, inclusively. Positions are 1-based. If
        <parameter>endpos</parameter> is past the end of the string, <function>substr</function>
        returns all the characters from <parameter>startpos</parameter> to the end of the string.
        This function only works correctly with single-byte characters.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax (unchanged)</title>

        <para><blockquote>
            <programlisting>substr (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>endpos</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substr
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>

            <listitem>
              <para>In InterBase, <function>substr</function> returned <constant>NULL</constant> if
              <parameter>endpos</parameter> lay past the end of the string.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <tip>
        <para>Although the function arguments are slightly different, consider using the internal
        SQL function <database><link linkend="langrefupd21-substring">SUBSTRING</link></database>
        instead, for better compatibility and multi-byte character set support.</para>
      </tip>
    </section>

    <section id="langrefupd21-udf-substrlen">
      <title><function>substrlen</function></title>

      <formalpara>
        <title>Library</title>

        <para>ib_udf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5.2, 2.0</para>
      </formalpara>

      <formalpara>
        <title>Deprecated in</title>

        <para>1.0 – use <link
        linkend="langrefupd21-substring"><database>SUBSTRING()</database></link></para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>Returns the substring starting at <parameter>startpos</parameter> and having
        <parameter>length</parameter> characters (or less, if the end of the string is reached
        first). Positions are 1-based. If either <parameter>startpos</parameter> or
        <parameter>length</parameter> is smaller than 1, an empty string is returned. This function
        only works correctly with single-byte characters.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>substrlen (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>length</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Declaration</title>

        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substrlen
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf'</programlisting>

            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>

            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd21-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>

      <formalpara>
        <title>Notes</title>

        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd21-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>

            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>

            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>

      <tip>
        <para>Firebird 1.0 has also implemented the internal SQL function <database><link
        linkend="langrefupd21-substring">SUBSTRING</link></database>, effectively rendering
        <function>substrlen</function> obsolete in the same version in which it was introduced.
        <database>SUBSTRING</database> also supports multi-byte character sets. In new code, use
        <database>SUBSTRING</database>.</para>
      </tip>
    </section>

    <section id="langrefupd21-udf-truncate">
      <title><function>truncate</function>, <function>i64truncate</function></title>

      <formalpara>
        <title>Library</title>

        <para>fbudf</para>
      </formalpara>

      <formalpara>
        <title>Added in</title>

        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>

      <formalpara>
        <title>Changed in</title>

        <para>1.5</para>
      </formalpara>

      <formalpara>
        <title>Description</title>

        <para>These functions return the whole-number portion of their (scaled numeric/decimal)
        argument. They do not work with floats or doubles.</para>
      </formalpara>

      <formalpara>
        <title>Result type</title>

        <para><database>INTEGER</database> / <database>NUMERIC(18)</database></para>
      </formalpara>

      <formalpara>
        <title>Syntax</title>

        <para><blockquote>
            <programlisting>truncate    (<parameter>number</parameter>)
i64truncate (<parameter>big</parameter>number)</programlisting>
          </blockquote></para>
      </formalpara>

      <warning>
        <para>Both functions round to the nearest whole number that is lower than or equal to the
        argument. This means that negative numbers are <quote>truncated</quote> downward. For
        instance, <function>truncate(<parameter>-2.37</parameter>)</function> returns
        <literal>-3</literal>. A rather peculiar exception is formed by the numbers between -1 and
        0, which are all truncated to 0. The only number that truncates to -1 is -1 itself.</para>

        <!--Tested in 1.0 and 1.5 -> same shit. This is floor, not truncate. Except on <-1,0]-->
      </warning>

      <formalpara>
        <title>Declarations</title>

        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>truncate</function>:</para>

            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>

            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbtruncate</function>:</para>

            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>

            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>

            <!--Keep the line below in sync with that under round:-->

            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names.</para>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>

  <appendix id="langrefupd21-notes">
    <title>Notes</title>

    <section id="langrefupd21-notes-charset-none">
      <title>Character set <database>NONE</database> data accepted <quote>as is</quote></title>

      <subtitle>In Firebird 1.5.1 and up</subtitle>

      <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
      moved to and from fields or variables with another character set, resulting in fewer
      transliteration errors.</para>

      <para>In Firebird 1.5.0, from a client connected with character set <database>NONE</database>,
      you could read data in two incompatible character sets – such as <database>SJIS</database>
      (Japanese) and <database>WIN1251</database> (Russian) – even though you could not read one of
      those character sets while connected from a client with the other character set. Data would be
      received <quote>as is</quote> and be stored without raising an exception.</para>

      <para>However, from this character set <database>NONE</database> client connection, an attempt
      to update any Russian or Japanese data columns using either parameterized queries or literal
      strings without introducer syntax would fail with transliteration errors; and subsequent
      queries on the stored <quote><database>NONE</database></quote> data would similarly
      fail.</para>

      <para>In Firebird 1.5.1, both problems have been circumvented. Data received from the client
      in character set <database>NONE</database> are still stored <quote>as is</quote> but what is
      stored is an exact, binary copy of the received string. In the reverse case, when stored data
      are read into this client from columns with specific character sets, there will be no
      transliteration error. When the connection character set is <database>NONE</database>, no
      attempt is made in either case to resolve the string to well-formed characters, so neither the
      write nor the read will throw a transliteration error.</para>

      <para>This opens the possibility for working with data from multiple character sets in a
      single database, as long as the connection character set is <database>NONE</database>. The
      client has full responsibility for submitting strings in the appropriate character set and
      converting strings returned by the engine, as needed.</para>

      <para>Abstraction layers that have to manage this can read the low byte of the
      <structfield>sqlsubtype</structfield> field in the <structname>XSQLVAR</structname> structure,
      which contains the character set identifier.</para>

      <para>While character set <database>NONE</database> literals are accepted and implicitly
      stored in the character set of their context, the use of introducer syntax to coerce the
      character sets of literals is highly recommended when the application is handling literals in
      a mixture of character sets. This should avoid the string's being misinterpreted when the
      application shifts the context for literal usage to a different character set.</para>

      <note>
        <para>Coercion of the character set, using the introducer syntax or casting, is still
        required when handling heterogeneous character sets from a client context that is anything
        other than <database>NONE</database>. Both methods are shown below, using character set
        <database>ISO8859_1</database> as an example target. Notice the
        <quote><literal>_</literal></quote> prefix in the introducer syntax.</para>

        <variablelist>
          <varlistentry>
            <term>Introducer syntax:</term>

            <listitem>
              <para><code>_ISO8859_1 <replaceable>mystring</replaceable></code></para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Casting:</term>

            <listitem>
              <para><code>CAST (<replaceable>mystring</replaceable> AS
              VARCHAR(<replaceable>n</replaceable>) CHARACTER SET ISO8859_1)</code></para>
            </listitem>
          </varlistentry>
        </variablelist>
      </note>
    </section>

    <section id="langrefupd21-notes-withlock">
      <title>Understanding the <database>WITH LOCK</database> clause</title>

      <para>This note looks a little deeper into explicit locking and its ramifications. The
      <database>WITH LOCK</database> feature, added in Firebird 1.5, provides a limited explicit
      pessimistic locking capability for cautious use in conditions where the affected row set
      is:<orderedlist numeration="loweralpha" spacing="compact">
          <listitem>
            <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
          </listitem>

          <listitem>
            <para>precisely controlled by the application code.</para>
          </listitem>
        </orderedlist></para>

      <para>Pessimistic locks are rarely needed in Firebird. This is an expert feature, intended for
      use by those who thoroughly understand its consequences. Knowledge of the various levels of
      transaction isolation is essential. <database>WITH LOCK</database> is available in DSQL and
      PSQL, and only for top-level, single-table <database>SELECT</database>s. As stated in the
      reference part of this guide, <database>WITH LOCK</database> is <emphasis>not</emphasis>
      available:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification;</para>
        </listitem>

        <listitem>
          <para>for joined sets;</para>
        </listitem>

        <listitem>
          <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
          clause or any other aggregating operation;</para>
        </listitem>

        <listitem>
          <para>with a view;</para>
        </listitem>

        <listitem>
          <para>with the output of a selectable stored procedure;</para>
        </listitem>

        <listitem>
          <para>with an external table.</para>
        </listitem>
      </itemizedlist>

      <section id="langrefupd21-appx-withlock-syntax">
        <title>Syntax and behaviour</title>

        <blockquote>
          <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
        </blockquote>

        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>

        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>

        <para>As the engine considers, in turn, each record falling under an explicit lock
        statement, it returns either the record version that is the most currently committed,
        regardless of database state when the statement was submitted, or an exception.</para>

        <para>Wait behaviour and conflict reporting depend on the transaction parameters specified
        in the TPB block:</para>

        <table id="langrefupd21-tbl-tpb-effects">
          <title>How TPB settings affect explicit locking</title>

          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />

            <colspec align="left" colname="behaviour" colwidth="3*" />

            <thead>
              <row>
                <entry align="center">TPB mode</entry>

                <entry align="center">Behaviour</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry align="center"><para>isc_tpb_consistency</para></entry>

                <entry align="left"><para>Explicit locks are overridden by implicit or explicit
                table-level locks and are ignored</para></entry>
              </row>

              <row>
                <entry align="center"><para>isc_tpb_concurrency</para><para>+
                isc_tpb_nowait</para></entry>

                <entry align="left"><para>If a record is modified by any transaction that was
                committed since the transaction attempting to get explicit lock started, or an
                active transaction has performed a modification of this record, an update conflict
                exception is raised immediately</para></entry>
              </row>

              <row>
                <entry align="center"><para>isc_tpb_concurrency</para><para>+
                isc_tpb_wait</para></entry>

                <entry align="left"><para>If the record is modified by any transaction that has
                committed since the transaction attempting to get explicit lock started, an update
                conflict exception is raised immediately.</para><para>If an active transaction is
                holding ownership on this record (via explicit locking or by a normal optimistic
                write-lock) the transaction attempting the explicit lock waits for the outcome of
                the blocking transaction and, when it finishes, attempts to get the lock on the
                record again. This means that, if the blocking transaction committed a modified
                version of this record, an update conflict exception will be raised.</para></entry>
              </row>

              <row>
                <entry align="center"><para>isc_tpb_read_committed</para><para>+
                isc_tpb_nowait</para></entry>

                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or normal update), an update conflict exception is
                raised immediately.</para></entry>
              </row>

              <row>
                <entry align="center"><para>isc_tpb_read_committed</para><para>+
                isc_tpb_wait</para></entry>

                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or by a normal optimistic write-lock), the
                transaction attempting the explicit lock waits for the outcome of blocking
                transation and when it finishes, attempts to get the lock on the record
                again.</para><para>Update conflict exceptions can never be raised by an explicit
                lock statement in this TPB mode.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section id="langrefupd21-appx-withlock-engine">
        <title>How the engine deals with <database>WITH LOCK</database></title>

        <para>When an <database>UPDATE</database> statement tries to access a record that is locked
        by another transaction, it either raises an update conflict exception or waits for the
        locking transaction to finish, depending on TPB mode. Engine behaviour here is the same as
        if this record had already been modified by the locking transaction.</para>

        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>

        <para>The engine guarantees that all records returned by an explicit lock statement are
        actually locked and <emphasis>do</emphasis> meet the search conditions specified in
        <database>WHERE</database> clause, as long as the search conditions do not depend on any
        other tables, via joins, subqueries, etc. It also guarantees that rows not meeting the
        search conditions will not be locked by the statement. It can <emphasis>not</emphasis>
        guarantee that there are no rows which, though meeting the search conditions, are not
        locked.</para>

        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during
          the course of the locking statement's execution.</para>
        </note>

        <para>The engine locks rows at fetch time. This has important consequences if you lock
        several rows at once. Many access methods for Firebird databases default to fetching output
        in packets of a few hundred rows (<quote>buffered fetches</quote>). Most data access
        components cannot bring you the rows contained in the last-fetched packet, where an error
        occurred.</para>
      </section>

      <section id="langrefupd21-appx-withlock-of">
        <title>The optional <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> sub-clause</title>

        <para>The <database>FOR UPDATE</database> clause provides a technique to prevent usage of
        buffered fetches, optionally with the <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> subclause to enable positioned
        updates.</para>

        <tip>
          <para>Alternatively, it may be possible in your access components to set the size of the
          fetch buffer to 1. This would enable you to process the currently-locked row before the
          next is fetched and locked, or to handle errors without rolling back your
          transaction.</para>
        </tip>
      </section>

      <section id="langrefupd21-appx-withlock-caveats">
        <title>Caveats using <database>WITH LOCK</database></title>

        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were
            taken under that savepoint, but it doesn't notify waiting transactions. Applications
            should not depend on this behaviour as it may get changed in the future.</para>
          </listitem>

          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict
            errors, the volume of deadlock errors will grow unless you design your locking strategy
            carefully and control it rigorously.</para>
          </listitem>

          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit
            locks are (1) to prevent expensive handling of update conflict errors in heavily loaded
            applications and (2) to maintain integrity of objects mapped to a relational database in
            a clustered environment. If your use of explicit locking doesn't fall in one of these
            two categories, then it's the wrong way to do the task in Firebird.</para>
          </listitem>

          <listitem>
            <para>Explicit locking is an advanced feature; do not misuse it! While solutions for
            these kinds of problems may be very important for web sites handling thousands of
            concurrent writers, or for ERP/CRM systems operating in large corporations, most
            application programs do not need to work in such conditions.</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="langrefupd21-appx-withlock-examples">
        <title>Examples using explicit locking</title>

        <orderedlist numeration="lowerroman">
          <listitem>
            <para>Simple:</para>

            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK        </programlisting>
          </listitem>

          <listitem>
            <para>Multiple rows, one-by-one processing with DSQL cursor:</para>

            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK        </programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section id="langrefupd21-notes-cstring">
      <title>A note on <database>CSTRING</database> parameters</title>

      <para>External functions involving strings often use the type
      <database>CSTRING(<replaceable>n</replaceable>)</database> in their declarations. This type
      represents a zero-terminated string of maximum length <replaceable>n</replaceable>. Most of
      the functions handling <database>CSTRING</database>s are programmed in such a way that they
      can accept and return zero-terminated strings of any length. So why the
      <replaceable>n</replaceable>? Because the Firebird engine has to set up space to process the
      input an output parameters, and convert them to and from SQL data types. Most strings used in
      databases are only dozens to hundreds of bytes long; it would be a waste to reserve 32 KB of
      memory each time such a string is processed. Therefore, the <emphasis>standard</emphasis>
      declarations of most <database>CSTRING</database> functions – as found in the file
      <filename>ib_udf.sql</filename> – specifiy a length of 255 bytes. (In Firebird 1.5.1 and
      below, this default length is 80 bytes.) As an example, here's the SQL declaration of
      <function>lpad</function>:</para>

      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
      </blockquote>

      <para>Once you've declared a <database>CSTRING</database> parameter with a certain length, you
      cannot call the function with a longer input string, or cause it to return a string longer
      than the declared output length. But the standard declarations are just reasonable defaults;
      they're not cast in concrete, and you can change them if you want to. If you have to left-pad
      strings of up to 500 bytes long, then it's perfectly OK to change both 255's in the
      declaration to 500 or more.</para>

      <para>A special case is when you usually operate on short strings (say less then 100 bytes)
      but occasionally have to call the function with a huge <database>(VAR)CHAR</database>
      argument. Declaring <database>CSTRING(32000)</database> makes sure that all the calls will be
      successful, but it will also cause 32000 bytes per parameter to be reserved, even in that
      majority of cases where the strings are under 100 bytes. In that situation you may consider
      declaring the function twice, with different names and different string lengths:</para>

      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpad</emphasis>
   <emphasis role="bold">CSTRING(100)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(100)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';

DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpadbig</emphasis>
   <emphasis role="bold">CSTRING(32000)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(32000)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';</programlisting>
      </blockquote>

      <para>Now you can call <function>lpad()</function> for all the small strings and
      <function>lpadbig()</function> for the occasional monster. Notice how the declared names in
      the first line differ (they determine how you call the functions from within your SQL), but
      the entry point (the function name in the library) is the same in both cases.</para>

      <!--The Firebird Book states that the low default is there for security reasons, to prevent
accidental or malicious overflow.-->
    </section>

    <section id="langrefupd21-notes-udf-null">
      <title>Passing <constant>NULL</constant> to UDFs in Firebird 2</title>

      <para>If a pre-2.0 Firebird engine must pass an SQL <constant>NULL</constant> argument to a
      user-defined function, it always converts it to a zero-equivalent, e.g. a numerical 0 or an
      empty string. The only exception to this rule are UDFs that make use of the
      <quote><database>BY DESCRIPTOR</database></quote> mechanism introduced in Firebird 1. The
      <systemitem class="library">fbudf</systemitem> library uses descriptors, but the vast majority
      of UDFs, including those in Firebird's standard <systemitem
      class="library">ib_udf</systemitem> library, still use the old style of parameter passing,
      inherited from InterBase.</para>

      <para>As a consequence, most UDFs can't tell the difference between <constant>NULL</constant>
      and zero input.</para>

      <para>Firebird 2 comes with a somewhat improved calling mechanism for these old-style UDFs.
      The engine will now pass <constant>NULL</constant> input as a null pointer to the function,
      <emphasis role="bold">if</emphasis> the function has been declared to the database with a
      <database>NULL</database> keyword after the argument(s) in question, e.g. like this:</para>

      <blockquote>
        <programlisting>declare external function ltrim
  cstring(255) <emphasis role="bold">null</emphasis>
  returns cstring(255) free_it
  entry_point 'IB_UDF_ltrim' module_name 'ib_udf';</programlisting>
      </blockquote>

      <para>This requirement ensures that existing databases and their applications can continue to
      function like before. Leave out the <database>NULL</database> keyword and the function will
      behave like it did under Firebird 1.5 and earlier.</para>

      <para>Please note that you can't just add <database>NULL</database> keywords to your
      declarations and then expect every function to handle <constant>NULL</constant> input
      correctly. Each function has to be (re)written in such a way that <constant>NULL</constant>s
      are dealt with correctly. Always look at the declarations provided by the function
      implementor. For the functions in the <systemitem class="library">ib_udf</systemitem> library,
      consult <filename>ib_udf2.sql</filename> in the Firebird <filename
      class="directory">UDF</filename> directory. Notice the <literal>2</literal> in the file name;
      the old-style declarations are in <filename>ib_udf.sql</filename>.</para>

      <para>These are the <systemitem class="library">ib_udf</systemitem> functions that have been
      updated to recognise <constant>NULL</constant> input and handle it properly:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><function>ascii_char</function></para>
        </listitem>

        <listitem>
          <para><function>lower</function></para>
        </listitem>

        <listitem>
          <para><function>lpad</function> and <function>rpad</function></para>
        </listitem>

        <listitem>
          <para><function>ltrim</function> and <function>rtrim</function></para>
        </listitem>

        <listitem>
          <para><function>substr</function> and <function>substrlen</function></para>
        </listitem>
      </itemizedlist>

      <para>Most <systemitem class="library">ib_udf</systemitem> functions remain as they were; in
      any case, passing <constant>NULL</constant> to an old-style UDF is never possible if the
      argument isn't of a referenced type.</para>

      <para>On a side note: don't use <function>lower</function>, <function>.trim</function> and
      <function>substr*</function> in new code; use the internal functions
      <database>LOWER</database>, <database>TRIM</database> and <database>SUBSTRING</database>
      instead.</para>

      <section id="langrefupd21-notes-udf-null-upgrade">
        <title><quote>Upgrading</quote> <systemitem class="library">ib_udf</systemitem> functions in
        an existing database</title>

        <para>If you are using an existing database with one or more of the functions listed above
        under Firebird 2, and you want to benefit from the improved <constant>NULL</constant>
        handling, run the script <filename>ib_udf_upgrade.sql</filename> against your database. It
        is located in the Firebird <filename class="directory">misc\upgrade\ib_udf</filename>
        directory.</para>
      </section>
    </section>

    <section id="langrefupd21-notes-maxindices">
      <title>Maximum number of indices in different Firebird versions</title>

      <para>Between Firebird 1.0 and 2.0 there have been quite a few changes to the maximum number
      of indices per database table. The table below sums them all up.</para>

      <table id="langrefupd21-tbl-maxindices-varversions">
        <title>Max. indices per table in Firebird 1.0 – 2.0</title>

        <tgroup cols="13">
          <colspec align="left" colname="colPageSize" />

          <colspec align="center" colname="colFb10_1" />

          <colspec align="center" colname="colFb10_2" />

          <colspec align="center" colname="colFb10_3" />

          <colspec align="center" colname="colFb103_1" />

          <colspec align="center" colname="colFb103_2" />

          <colspec align="center" colname="colFb103_3" />

          <colspec align="center" colname="colFb15_1" />

          <colspec align="center" colname="colFb15_2" />

          <colspec align="center" colname="colFb15_3" />

          <colspec align="center" colname="colFb20_1" />

          <colspec align="center" colname="colFb20_2" />

          <colspec align="center" colname="colFb20_3" />

          <spanspec align="center" nameend="colFb10_3" namest="colFb10_1" spanname="spanFb10" />

          <spanspec align="center" nameend="colFb103_3" namest="colFb103_1" spanname="spanFb103" />

          <spanspec align="center" nameend="colFb15_3" namest="colFb15_1" spanname="spanFb15" />

          <spanspec align="center" nameend="colFb20_3" namest="colFb20_1" spanname="spanFb20" />

          <spanspec align="center" nameend="colFb20_3" namest="colFb10_1" spanname="spanAllVersions" />

          <thead>
            <row valign="top">
              <entry align="left" morerows="2">Page size</entry>

              <entry spanname="spanAllVersions">Firebird version(s)</entry>
            </row>

            <row>
              <entry spanname="spanFb10">1.0, 1.0.2</entry>

              <entry spanname="spanFb103">1.0.3</entry>

              <entry spanname="spanFb15">1.5.x</entry>

              <entry spanname="spanFb20">2.0.x</entry>
            </row>

            <row>
              <entry>1 col</entry>

              <entry>2 cols</entry>

              <entry>3 cols</entry>

              <entry>1 col</entry>

              <entry>2 cols</entry>

              <entry>3 cols</entry>

              <entry>1 col</entry>

              <entry>2 cols</entry>

              <entry>3 cols</entry>

              <entry>1 col</entry>

              <entry>2 cols</entry>

              <entry>3 cols</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>1024</entry>

              <entry>62</entry>

              <entry>50</entry>

              <entry>41</entry>

              <entry>62</entry>

              <entry>50</entry>

              <entry>41</entry>

              <entry>62</entry>

              <entry>50</entry>

              <entry>41</entry>

              <entry>50</entry>

              <entry>35</entry>

              <entry>27</entry>
            </row>

            <row>
              <entry>2048</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>126</entry>

              <entry>101</entry>

              <entry>84</entry>

              <entry>126</entry>

              <entry>101</entry>

              <entry>84</entry>

              <entry>101</entry>

              <entry>72</entry>

              <entry>56</entry>
            </row>

            <row>
              <entry>4096</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>254</entry>

              <entry>203</entry>

              <entry>169</entry>

              <entry>254</entry>

              <entry>203</entry>

              <entry>169</entry>

              <entry>203</entry>

              <entry>145</entry>

              <entry>113</entry>
            </row>

            <row>
              <entry>8192</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>510</entry>

              <entry>408</entry>

              <entry>340</entry>

              <entry>257</entry>

              <entry>257</entry>

              <entry>257</entry>

              <entry>408</entry>

              <entry>291</entry>

              <entry>227</entry>
            </row>

            <row>
              <entry>16384</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>65</entry>

              <entry>1022</entry>

              <entry>818</entry>

              <entry>681</entry>

              <entry>257</entry>

              <entry>257</entry>

              <entry>257</entry>

              <entry>818</entry>

              <entry>584</entry>

              <entry>454</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </appendix>

  <appendix id="langrefupd21-dochist">
    <title>Document History</title>

    <para>The exact file history is recorded in the <filename class="directory">manual</filename>
    module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.9</revnumber>

          <date>24 Sep 2008</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>First publication, based on the <citetitle>Firebird 1.5 Language Reference
            Update</citetitle> with all the changes for 2.0 added (roughly doubling the
            size).</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="langrefupd21-license">
    <title>License notice</title>

    <para>The contents of this Documentation are subject to the Public Documentation License Version
    1.0 (the <quote>License</quote>); you may only use this Documentation if you comply with the
    terms of this License. Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>The Original Documentation is titled <citetitle>Firebird 2.1 Language Reference
    Update</citetitle>.</para>

    <para>The Initial Writers of the Original Documentation are: Paul Vinkenoog et al.</para>

    <para>Copyright (C) 2008-2009. All Rights Reserved. Initial Writers contact: paul at vinkenoog
    dot nl.</para>

    <para>Writers and Editors of included PDL-licensed material (the <quote>et al.</quote>) are: J.
    Beesley, Helen Borrie, Arno Brinkman, Alex Peshkov, Nickolay Samofatov, Dmitry Yemanov.</para>

    <para>Included portions are Copyright (C) 2001-2008 by their respective authors. All Rights
    Reserved.</para>
  </appendix>
</book>