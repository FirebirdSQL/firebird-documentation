<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../tools/docbook-dtd/docbookx.dtd">
<book id="langrefupd15">
  <bookinfo>
    <title>Firebird 1.5 Language Reference Update</title>
    <subtitle>Everything new in Firebird SQL since InterBase 6</subtitle>
    <titleabbrev>Firebird 1.5 Language Ref. Update</titleabbrev>
    <author>
      <firstname>Paul</firstname>
      <surname>Vinkenoog et al.</surname>
    </author>
    <edition>?? Xxx 20??, document version 1.2 — covers Firebird 1.0–1.5.6</edition>
  </bookinfo>
  <chapter id="langrefupd15-intro">
    <title>Introduction</title>
    <para>This guide documents the <emphasis role="bold">changes</emphasis> made in Firebird 1.0 and
    1.5 SQL since the fork from the open-sourced InterBase 6.0 codebase. It covers the following
    areas:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>Reserved words</para>
      </listitem>
      <listitem>
        <para>Data types and subtypes</para>
      </listitem>
      <listitem>
        <para>DDL statements (Data Definition Language)</para>
      </listitem>
      <listitem>
        <para>DML statements (Data Manipulation Language)</para>
      </listitem>
      <listitem>
        <para>PSQL statements (Procedural SQL, used in stored procedures and triggers)</para>
      </listitem>
      <listitem>
        <para>Context variables</para>
      </listitem>
      <listitem>
        <para>Internal functions</para>
      </listitem>
      <listitem>
        <para>UDFs (User Defined Functions, also known as external functions)</para>
      </listitem>
    </itemizedlist>
    <para>To have a complete Firebird 1.0 and 1.5 SQL reference, you need:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>The InterBase 6.0 beta SQL Reference (<filename>LangRef.pdf</filename> and/or
        <filename>SQLRef.html</filename>)</para>
      </listitem>
      <listitem>
        <para>This document</para>
      </listitem>
    </itemizedlist>
    <para>Topics <emphasis role="bold">not</emphasis> discussed in this document include:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>ODS versions</para>
      </listitem>
      <listitem>
        <para>Bug listings</para>
      </listitem>
      <listitem>
        <para>Installation and configuration</para>
      </listitem>
      <listitem>
        <para>Upgrade, migration and compatibility</para>
      </listitem>
      <listitem>
        <para>Server architectures</para>
      </listitem>
      <listitem>
        <para>API functions</para>
      </listitem>
      <listitem>
        <para>Connection protocols</para>
      </listitem>
      <listitem>
        <para>Tools and utilities</para>
      </listitem>
    </itemizedlist>
    <para>Consult the Release Notes for information on these subjects. You can find the Release
    Notes and other documentation via the Firebird Documentation Index at <ulink
    url="http://www.firebirdsql.org/index.php?op=doc">http://www.firebirdsql.org/index.php?op=doc</ulink>.</para>
    <section id="langrefupd15-intro-versions">
      <title>Versions covered</title>
      <para>This document covers all Firebird versions up to and including 1.5.6.</para>
    </section>
    <section id="langrefupd15-intro-authors">
      <title>Authorship</title>
      <para>Most of this document was written by the main author. The remainder (10–14%) was lifted
      from various Firebird Release Notes editions, which in turn contain material from preceding
      sources like the Whatsnew documents. Authors and editors of the included material are:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>J. Beesley</para>
        </listitem>
        <listitem>
          <para>Helen Borrie</para>
        </listitem>
        <listitem>
          <para>Arno Brinkman</para>
        </listitem>
        <listitem>
          <para>Frank Ingermann</para>
        </listitem>
        <listitem>
          <para>Alex Peshkov</para>
        </listitem>
        <listitem>
          <para>Nickolay Samofatov</para>
        </listitem>
        <listitem>
          <para>Dmitry Yemanov</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>
  <chapter id="langrefupd15-reswords">
    <title>Reserved words</title>
    <para>Reserved words are part of the Firebird SQL language. They cannot be used as identifiers,
    except when enclosed in double quotes. However, you should avoid this unless you really have no
    other option.</para>
    <section id="langrefupd15-reswords-10-not-15">
      <title>Added in 1.0 but removed in 1.5</title>
      <para>The following reserved words were added in Firebird 1.0 but removed again in 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>BREAK</database></member>
          <member><database>DESCRIPTOR</database></member>
          <member><database>FIRST</database></member>
          <member><database>SKIP</database></member>
          <member><database>SUBSTRING</database></member>
        </simplelist>
      </blockquote>
      <para>The following non-reserved words were earmarked in Firebird 1.0 as <quote>to be avoided
      because of future reservation</quote>, but no longer so in 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>COALESCE</database></member>
          <member><database>IIF</database></member>
          <member><database>NULLIF</database></member>
        </simplelist>
      </blockquote>
      <para>(of these three, <database>COALESCE</database> and <database>NULLIF</database> are
      non-reserved keywords in 1.5)</para>
    </section>
    <section id="langrefupd15-reswords-10-or-15">
      <title>Added in 1.0 and 1.5</title>
      <para>The following reserved words were added in Firebird 1.0 and are still reserved in
      1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>CURRENT_ROLE</database></member>
          <member><database>CURRENT_USER</database></member>
          <member><database>RECREATE</database></member>
        </simplelist>
      </blockquote>
      <para>The following reserved words were added in Firebird 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>BIGINT</database></member>
          <member><database>CASE</database></member>
          <member><database>CURRENT_CONNECTION</database></member>
          <member><database>CURRENT_TRANSACTION</database></member>
          <member><database>RELEASE</database></member>
          <member><database>ROW_COUNT</database></member>
          <member><database>SAVEPOINT</database></member>
        </simplelist>
      </blockquote>
      <para>The following words are not reserved, but recognized as keywords by Firebird 1.5 if used
      in the proper context:</para>
      <blockquote>
        <simplelist>
          <member><database>COALESCE</database></member>
          <member><database>DELETING</database></member>
          <member><database>INSERTING</database></member>
          <member><database>LAST</database></member>
          <member><database>LEAVE</database></member>
          <member><database>LOCK</database></member>
          <member><database>NULLIF</database></member>
          <member><database>NULLS</database></member>
          <member><database>STATEMENT</database></member>
          <member><database>UPDATING</database></member>
          <member><database>USING</database></member>
        </simplelist>
      </blockquote>
    </section>
    <section id="langrefupd15-reswords-future">
      <title>To be added in future versions</title>
      <para>The following words are not reserved in Firebird 1.0 or 1.5, but should be avoided as
      identifiers because they will likely be reserved in future versions:</para>
      <blockquote>
        <simplelist>
          <member><database>ABS</database></member>
          <member><database>BOOLEAN</database></member>
          <member><database>BOTH</database></member>
          <member><database>CHAR_LENGTH</database></member>
          <member><database>CHARACTER_LENGTH</database></member>
          <member><database>FALSE</database></member>
          <member><database>LEADING</database></member>
          <member><database>OCTET_LENGTH</database></member>
          <member><database>TRAILING</database></member>
          <member><database>TRIM</database></member>
          <member><database>TRUE</database></member>
          <member><database>UNKNOWN</database></member>
        </simplelist>
      </blockquote>
    </section>
  </chapter>
  <chapter id="langrefupd15-misc">
    <title>Miscellaneous language elements</title>
    <section id="langrefupd15-linecomment">
      <title>-- (single-line comment)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A line starting with <quote><literal>--</literal></quote> (two dashes) is a comment
        and will be ignored. This also makes it easy to quickly comment out a line of SQL.</para>
      </formalpara>
      <para>In Firebird 1.5 and up, the <quote><literal>--</literal></quote> can be placed anywhere
      on the line, e.g. after an SQL statement. Everything from the double dash to the end of the
      line will be ignored.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>-- a table to store our valued customers in:
create table Customers (
  name varchar(32),
  added_by varchar(24),
  custno varchar(8),
  purchases integer      -- number of purchases
)</programlisting>
            <para>Notice that the second comment is only allowed in Firebird 1.5 and up.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-concat">
      <title><database>||</database> (string concatenator)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd15-concat-overflow">
        <title>Overflow checking</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If the sum of the <emphasis>declared</emphasis> string lengths in a concatenation
          exceeded 32767 bytes, InterBase would raise an error without trying to do the actual
          concatenation – even though the result might very well be within that limit. In Firebird
          1.0 and 1.5, the <quote>early error</quote> threshold is raised to 65536. Consequently,
          concatenations of at most two (<database>VAR</database>)<database>CHAR</database>s can no
          longer result in these premature errors. An error will only be raised if the
          <emphasis>actual</emphasis> outcome exceeds 32767 bytes, or if the sum of the declared
          lengths exceeds 65535 bytes. The latter is only possible if three or more strings take
          part in the concatenation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The following statement will raise an error in InterBase, but not in
              Firebird:</para>
              <programlisting>select cast('abc' as varchar(30000))
    || cast('def' as varchar(30000))
from rdb$database</programlisting>
              <para>The following statement will raise an (unnecessary) error in both InterBase and
              Firebird:</para>
              <programlisting>select cast('abc' as varchar(30000))
    || cast('def' as varchar(30000))
    || cast('ghi' as varchar(30000))
from rdb$database</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>Firebird 2.0 does away with these premature errors altogether.</para>
        </note>
      </section>
    </section>
    <section id="langrefupd15-shorthandcast">
      <title>Shorthand casts</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Sure about shorthand casts in ESQL?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>When converting a string literal to a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database>, Firebird allows the use of a
        shorthand <quote>C-style</quote> cast. This feature already existed in InterBase 6, but was
        never properly documented.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting><replaceable>datatype</replaceable> '<replaceable>date/timestring</replaceable>'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; <emphasis role="bold">date '1-Jan-1943'</emphasis></programlisting>
            <programlisting>insert into Appointments
  (Employee_Id, Client_Id, App_date, App_time)
values
  (973, 8804, <emphasis role="bold">date 'today'</emphasis> + 2, <emphasis role="bold">time '16:00'</emphasis>)</programlisting>
            <programlisting>new.lastmod = <emphasis role="bold">timestamp 'now'</emphasis>;</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-case">
      <title><database>CASE</database> construct</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A <database>CASE</database> construct returns exactly one value from a number of
        possibilities. There are two syntactic variants:<itemizedlist spacing="compact">
            <listitem>
              <para>The simple <database>CASE</database>, comparable to a Pascal <code>case</code>
              or a C <code>switch</code>.</para>
            </listitem>
            <listitem>
              <para>The searched <database>CASE</database>, which works like a series of
              <quote><code>if ... else if ... else if</code></quote> clauses.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <section id="langrefupd15-case-simple">
        <title>Simple <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE <replaceable>&lt;expression&gt;</replaceable>
   WHEN <replaceable>&lt;exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>When this variant is used, <replaceable>&lt;expression&gt;</replaceable> is compared
        to <replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> etc.,
        until a match is found, upon which the corresponding result is returned. If there is no
        match and there is an <database>ELSE</database> clause,
        <replaceable>defaultresult</replaceable> is returned. If there is no match and no
        <database>ELSE</database> clause, <constant>NULL</constant> is returned.</para>
        <para>The match is determined with the <quote>=</quote> operator, so if
        <replaceable>&lt;expression&gt;</replaceable> is <constant>NULL</constant>, it won't match
        any of the <replaceable>&lt;expN&gt;</replaceable>s, not even those that are
        <constant>NULL</constant>.</para>
        <para>The results don't have to be literal values: they may also be field or variable names,
        compound expressions, or <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select name,
       age,
       case upper(sex)
         when 'M' then 'Male'
         when 'F' then 'Female'
         else 'Unknown'
       end,
       religion
from people</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-case-searched">
        <title>Searched <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE
   WHEN <replaceable>&lt;bool_exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;bool_exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Here, the <replaceable>&lt;bool_expN&gt;</replaceable>s are tests that give a ternary
        boolean result: <constant>true</constant>, <constant>false</constant>, or
        <constant>NULL</constant>. The first expression evaluating to <constant>TRUE</constant>
        determines the result. If no expression is <constant>TRUE</constant> and there is an
        <database>ELSE</database> clause, <replaceable>defaultresult</replaceable> is returned. If
        no expression is <constant>TRUE</constant> and there is no <database>ELSE</database> clause,
        <constant>NULL</constant> is returned.</para>
        <para>As with the simple <database>CASE</database>, the results don't have to be literal
        values: they may also be field or variable names, compound expressions, or
        <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>CanVote = case
            when Age &gt;= 18 then 'Yes'
            when Age &lt;  18 then 'No'
            else 'Unsure'
          end;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd15-datatypes">
    <title>Data types and subtypes</title>
    <section id="langrefupd15-bigint">
      <title><database>BIGINT</database> data type</title>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BIGINT</database> is the SQL99-compliant 64-bit signed integer type. It is
        available in Dialect 3 only.</para>
      </formalpara>
      <para><database>BIGINT</database> numbers range from -2<superscript>63</superscript> ..
      2<superscript>63</superscript>-1, or -9,223,372,036,854,775,808 ..
      9,223,372,036,854,775,807.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create table WholeLottaRecords (
  id bigint not null primary key,
  description varchar(32)
)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-charsets">
      <title>New character sets</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5</para>
      </formalpara>
      <para>The following table lists the character sets added in Firebird.</para>
      <table id="langrefupd15-tbl-charsets">
        <title>Character sets new in Firebird</title>
        <tgroup cols="4">
          <colspec colname="colName" colwidth="2*" />
          <colspec colname="colBytes" colwidth="*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Name</entry>
              <entry align="center">Bytes/char.</entry>
              <entry align="center">Languages</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>DOS737</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS775</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS858</entry>
              <entry>1</entry>
              <entry>= DOS850 plus € sign</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS862</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS864</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS866</entry>
              <entry>1</entry>
              <entry>Russian</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS869</entry>
              <entry>1</entry>
              <entry>Modern Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_2</entry>
              <entry>1</entry>
              <entry>Latin-2, Central European</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO8859_3</entry>
              <entry>1</entry>
              <entry>Latin-3, Southern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_4</entry>
              <entry>1</entry>
              <entry>Latin-4, Northern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_5</entry>
              <entry>1</entry>
              <entry>Cyrillic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_6</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_7</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_8</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_9</entry>
              <entry>1</entry>
              <entry>Latin-5, Turkish</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>1</entry>
              <entry>Latin-7, Baltic Rim</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1255</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1256</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1257</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd15-charset-none">
      <title>Character set <database>NONE</database> handling changed</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
        moved to and from fields or variables with another character set, resulting in fewer
        transliteration errors. For more details, see the <link
        linkend="langrefupd15-notes-charset-none">Note</link> at the end of the book.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-collations">
      <title>New collations</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5, 1.5.1</para>
      </formalpara>
      <para>The following table lists the collations added in Firebird.</para>
      <table id="langrefupd15-tbl-collations">
        <title>Collations new in Firebird</title>
        <tgroup cols="4">
          <colspec colname="colCharset" colwidth="2*" />
          <colspec colname="colCollation" colwidth="2*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Character set</entry>
              <entry align="center">Collation</entry>
              <entry align="center">Language</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row valign="top">
              <entry morerows="1">ISO8859_2</entry>
              <entry>CS_CZ</entry>
              <entry>Czech</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO_HUN</entry>
              <entry>Hungarian</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>LT_LT</entry>
              <entry>Lithuanian</entry>
              <entry>1.5.1</entry>
            </row>
            <row>
              <entry>WIN1250</entry>
              <entry>PXW_HUN</entry>
              <entry>Hungarian</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>WIN1251</entry>
              <entry>WIN1251_UA</entry>
              <entry>Ukrainian and Russian</entry>
              <entry>1.5</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
  <chapter id="langrefupd15-ddl">
    <title>DDL statements</title>
    <!--ALTER INDEX

Fb1 RlsNotes say:

Allow FK indexes to be disabled
It is now possible to set FOREIGN KEY indexes inactive using ALTER INDEX. This should resolve
some performance issues related to maintaining indexes with low selectivity.

In practice, this doesn't work and has never been implemented (confirmed by Dmitry).
It should have been removed from the Rlsnotes.-->
    <section id="langrefupd15-alter-domain">
      <title><database>ALTER DOMAIN</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-alter-domain-to">
        <title>Rename domain</title>
        <formalpara>
          <title>Added in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Renaming of a domain is possible with the <database>TO</database> clause. This
          feature was introduced in InterBase 6, but left out of the <citetitle>Language
          Reference</citetitle>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter domain posint to plusint</programlisting>
              <itemizedlist>
                <listitem>
                  <para>The <database>TO</database> clause can be combined with other clauses and
                  need not come first in that case.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-alter-domain-default">
        <title><database>SET DEFAULT</database> to any context variable</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the domain's datatype can be
          used as a default. This was already the case in InterBase 6, but the <citetitle>Language
          Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter domain DDate
  set default current_date</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-alter-table">
      <title><database>ALTER TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-at-contextvars">
        <title><database>ADD</database> column: Context variables as defaults</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the new column's datatype can
          be used as a default. This was already the case in InterBase 6, but the
          <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table MyData
  add MyDay date default current_date</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-at-position">
        <title><database>ALTER COLUMN</database>: <database>POSITION</database> now 1-based</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>When changing a column's position, the engine now interprets the new position as
          1-based. This is in accordance with the SQL standard and the InterBase documentation, but
          in practice InterBase interpreted the position as 0-based.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> POSITION <replaceable>&lt;newpos&gt;</replaceable>

<replaceable>&lt;newpos&gt;</replaceable>  ::=  an integer between 1 and the number of columns</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table Stock alter Quantity position 3</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>Don't confuse this with the <database>POSITION</database> in <database>CREATE/ALTER
          TRIGGER</database>. Trigger positions are and will remain 0-based.</para>
        </note>
      </section>
      <section id="langrefupd15-at-fk-notargetcol">
        <title><database>FOREIGN KEY</database> without target column references
        <database>PK</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you create a foreign key without specifying a target column, it will reference
          the <emphasis role="bold">primary key</emphasis> of the target table. This was already the
          case in InterBase 6, but the IB Language Reference wrongly states that in such cases, the
          engine scans the target table for a column with the same name as the referencing
          column.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table eik (
  a int not null primary key,
  b int not null unique
);

create table beuk (
  b int
);

alter table beuk
  add constraint fk_beuk
  foreign key (b) references eik;

-- beuk.b now references eik.a, not eik.b !</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-at-unique-keys">
        <title><database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple –
          are now allowed in columns with a <database>UNIQUE</database> constraint. For a full
          discussion, see <link linkend="langrefupd15-ct-unique-keys"><citetitle><database>CREATE
          TABLE</database> :: <database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-at-using-index">
        <title><database>USING INDEX</database> subclause</title>
        <!--Seems unavailable in ESQL-->
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>USING INDEX</database> subclause can be placed at the end of a primary,
          unique or foreign key definition. Its purpose is to<itemizedlist spacing="compact">
              <listitem>
                <para>provide a user-defined name for the automatically created index that enforces
                the constraint, and</para>
              </listitem>
              <listitem>
                <para>optionally define the index to be ascending or descending (the default being
                ascending).</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>[ADD] [CONSTRAINT <replaceable>constraint-name</replaceable>]
<replaceable>   &lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>For a full discussion and examples, see <link
        linkend="langrefupd15-ct-using-index"><citetitle><database>CREATE TABLE</database> ::
        <database>USING INDEX</database> subclause</citetitle></link>.</para>
      </section>
    </section>
    <section id="langrefupd15-alter-trigger">
      <title><database>ALTER TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-alter-trigger-multiaction">
        <title>Multi-action triggers</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ALTER TRIGGER</database> syntax has been extended to support
          multi-action triggers. For a full discussion of this feature, see <link
          linkend="langrefupd15-create-trigger-multiaction"><citetitle><database>CREATE
          TRIGGER</database> :: Multi-action triggers</citetitle></link>.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TRIGGER <replaceable>trigger-name</replaceable>
   [ACTIVE | INACTIVE]
   {BEFORE | AFTER} <replaceable>&lt;actions&gt;</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
<replaceable>   &lt;trigger_body&gt;</replaceable>

<replaceable>&lt;actions&gt;</replaceable>       ::= <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable>]]
<replaceable>&lt;single_action&gt;</replaceable> ::= INSERT | UPDATE | DELETE</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-alter-trigger-changecount">
        <title><database>ALTER TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Each time you use <database>CREATE</database>, <database>ALTER</database> or
          <database>DROP TRIGGER</database>, InterBase increments the metadata change counter of the
          associated table. Once that counter reaches 255, no more metadata changes are possible on
          the table (you can still work with the data though). A backup-restore cycle is needed to
          reset the counter and perform metadata operations again.</para>
        </formalpara>
        <para>While this obligatory cleanup after many metadata changes is in itself a useful
        feature, it also means that users who regularly use <database>ALTER TRIGGER</database> to
        deactivate triggers during e.g. bulk import operations are forced to backup and restore much
        more often then needed.</para>
        <para>Since changes to triggers don't imply structural changes to the table itself, Firebird
        no longer increments the table change counter when <database>CREATE</database>,
        <database>ALTER</database> or <database>DROP TRIGGER</database> is used. One thing has
        remained though: once the counter is at 255, you can no longer create, alter or drop
        triggers for that table.</para>
      </section>
      <section id="langrefupd15-alter-trigger-plan">
        <title><database>PLAN</database> allowed in trigger code</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
          would be rejected by the compiler. Now a valid plan can be included and will be
          used.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-database">
      <title><database>CREATE DATABASE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-cr-db-pagesize16k">
        <title>16 Kb page size supported</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum database page size has been raised from 8192 to 16384 bytes.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE {DATABASE | SCHEMA}
   ...
   [PAGE_SIZE [=] <replaceable>&lt;size&gt;</replaceable>]
   ...

<replaceable>&lt;size&gt;</replaceable>  ::=  1024 | 2048 | 4096 | 8192 | 16384</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-domain">
      <title><database>CREATE DOMAIN</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-create-domain-contextvars">
        <title>Context variables as defaults</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the new domain's datatype can
          be used as a default. This was already the case in InterBase 6, but the
          <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create domain DDate as
  date
  default current_date
  not null</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-generator">
      <title><database>CREATE GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-creatgen-limitraised">
        <title>Maximum number of generators significantly raised</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>InterBase reserved only one database page for generators, limiting the total number
          to 123 (on 1K pages) – 1019 (on 8K pages). Firebird has done away with that limit; you can
          now create more than 32,000 generators per database.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-index">
      <title><database>CREATE INDEX</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-creatind-unique-nulls">
        <title><database>UNIQUE</database> indices now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple –
          are now allowed in columns that have a <database>UNIQUE</database> index defined on them.
          For a full discussion, see <link
          linkend="langrefupd15-ct-unique-keys"><citetitle><database>CREATE TABLE</database> ::
          <database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</citetitle></link>. As far as <constant>NULL</constant>s are
          concerned, the rules for unique indices are exactly the same as those for unique
          keys.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-creatind-maxnumber">
        <title>Maximum number of indices per table increased</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0.3 and 1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum number of 64 indices per table has been removed in Firebird 1.0.3, and
          reintroduced at the higher level of 256 in Firebird 1.5.</para>
        </formalpara>
        <note>
          <para>Probably due to an off-by-one error in the code, the effective ceiling is 65 indices
          in Firebird 1.0 and 1.0.2, and 257 indices in Firebird 1.5.</para>
        </note>
        <para>The number of indices attainable in practice is further limited by the database page
        size and the number of columns per index, as shown in the table below.</para>
        <table id="langrefupd15-tbl-maxindices">
          <title>Maximum indices per table</title>
          <tgroup cols="10">
            <colspec align="left" colname="colPageSize" />
            <colspec align="center" colname="colFb10_1" />
            <colspec align="center" colname="colFb10_2" />
            <colspec align="center" colname="colFb10_3" />
            <colspec align="center" colname="colFb103_1" />
            <colspec align="center" colname="colFb103_2" />
            <colspec align="center" colname="colFb103_3" />
            <colspec align="center" colname="colFb15_1" />
            <colspec align="center" colname="colFb15_2" />
            <colspec align="center" colname="colFb15_3" />
            <spanspec align="center" nameend="colFb10_3" namest="colFb10_1" spanname="spanFb10" />
            <spanspec align="center" nameend="colFb103_3" namest="colFb103_1" spanname="spanFb103" />
            <spanspec align="center" nameend="colFb15_3" namest="colFb15_1" spanname="spanFb15" />
            <spanspec align="center" nameend="colFb15_3" namest="colFb10_1"
                      spanname="spanAllVersions" />
            <thead>
              <row valign="top">
                <entry align="left" morerows="2">Page size</entry>
                <entry spanname="spanAllVersions">Firebird version(s)</entry>
              </row>
              <row>
                <entry spanname="spanFb10">1.0, 1.0.2</entry>
                <entry spanname="spanFb103">1.0.3</entry>
                <entry spanname="spanFb15">1.5.x</entry>
              </row>
              <row>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1024</entry>
                <entry>62</entry>
                <entry>50</entry>
                <entry>41</entry>
                <entry>62</entry>
                <entry>50</entry>
                <entry>41</entry>
                <entry>62</entry>
                <entry>50</entry>
                <entry>41</entry>
              </row>
              <row>
                <entry>2048</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>126</entry>
                <entry>101</entry>
                <entry>84</entry>
                <entry>126</entry>
                <entry>101</entry>
                <entry>84</entry>
              </row>
              <row>
                <entry>4096</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>254</entry>
                <entry>203</entry>
                <entry>169</entry>
                <entry>254</entry>
                <entry>203</entry>
                <entry>169</entry>
              </row>
              <row>
                <entry>8192</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>510</entry>
                <entry>408</entry>
                <entry>340</entry>
                <entry>257</entry>
                <entry>257</entry>
                <entry>257</entry>
              </row>
              <row>
                <entry>16384</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>1022</entry>
                <entry>818</entry>
                <entry>681</entry>
                <entry>257</entry>
                <entry>257</entry>
                <entry>257</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Please be aware that under normal circumstances, even 64 indices is way too many and
        will drastically reduce mutation speeds. The maximum was raised to accommodate
        data-warehousing applications and the like, that do lots of bulk operations during which
        indices are temporarily switched off.</para>
      </section>
    </section>
    <section id="langrefupd15-create-table">
      <title><database>CREATE TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-ct-contextvars">
        <title>Context variables as column defaults</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the column datatype can be
          used as a default. This was already the case in InterBase 6, but the <citetitle>Language
          Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table MyData (
  id int not null primary key,
  record_created timestamp default current_timestamp,
  ...
)</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-ct-fk-notargetcol">
        <title><database>FOREIGN KEY</database> without target column references
        <database>PK</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you create a foreign key without specifying a target column, it will reference
          the <emphasis role="bold">primary key</emphasis> of the target table. This was already the
          case in InterBase 6, but the IB Language Reference wrongly states that in such cases, the
          engine scans the target table for a column with the same name as the referencing
          column.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table eik (
  a int not null primary key,
  b int not null unique
);

create table beuk (
  b int references eik
);

-- beuk.b references eik.a, not eik.b !</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-ct-unique-keys">
        <title><database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple –
          are now allowed in columns with a <database>UNIQUE</database> constraint. It is therefore
          possible to define a <database>UNIQUE</database> key on a column that has no <database>NOT
          NULL</database> constraint.</para>
        </formalpara>
        <para>For <database>UNIQUE</database> keys that span multiple columns, the logic is a little
        complicated:</para>
        <itemizedlist>
          <listitem>
            <para>Multiple rows having <emphasis>all</emphasis> the <database>UK</database> columns
            <constant>NULL</constant> are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having a <emphasis>different subset</emphasis> of
            <database>UK</database> colums <constant>NULL</constant> are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having the <emphasis>same subset</emphasis> of
            <database>UK</database> columns <constant>NULL</constant> and the rest filled with
            regular values and those regular values <emphasis>differ</emphasis> in at least one
            column, are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having the <emphasis>same subset</emphasis> of
            <database>UK</database> columns <constant>NULL</constant> and the rest filled with
            regular values and those regular values are the <emphasis>same</emphasis> in every
            column, are forbidden.</para>
          </listitem>
        </itemizedlist>
        <para>One way of summarizing this is as follows: In principle, all
        <constant>NULL</constant>s are considered distinct. But if two rows have exactly the same
        subset of <database>UK</database> columns filled with non-<constant>NULL</constant> values,
        the <constant>NULL</constant> columns are ignored and the non-<constant>NULL</constant>
        columns are decisive, just as if they constituted the entire unique key.</para>
        <!--Give example tables to show what is and isn't allowed?-->
      </section>
      <section id="langrefupd15-ct-using-index">
        <title><database>USING INDEX</database> subclause</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>USING INDEX</database> subclause can be placed at the end of a primary,
          unique or foreign key definition. Its purpose is to<itemizedlist spacing="compact">
              <listitem>
                <para>provide a user-defined name for the automatically created index that enforces
                the constraint, and</para>
              </listitem>
              <listitem>
                <para>optionally define the index to be ascending or descending (the default being
                ascending).</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <para>Without <database>USING INDEX</database>, indices enforcing named constraints are
        named after the constraint (this is new behaviour in Firebird 1.5) and indices for unnamed
        constraints get names like <database>RDB$FOREIGN13</database> or something equally
        romantic.</para>
        <note>
          <para>You must always provide a <emphasis>new</emphasis> name for the index. It is not
          possible to use pre-existing indices to enforce constraints.</para>
        </note>
        <para><database>USING INDEX</database> can be applied at field level, at table level, and
        (in <database>ALTER TABLE</database>) with <database>ADD CONSTRAINT</database>. It works
        with named as well as unnamed key constraints. It does <emphasis>not</emphasis> work with
        <database>CHECK</database> constraints, as these don't have their own enforcing
        index.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>[CONSTRAINT <replaceable>constraint-name</replaceable>]
   <replaceable>&lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The first example creates a primary key constraint <database>PK_CUST</database>
              using an index named <database>IX_CUSTNO</database>:</para>
              <programlisting>create table customers (
  custno int not null constraint pk_cust primary key using index ix_custno,
  ...</programlisting>
              <para>This, however:</para>
              <programlisting>create table customers (
  custno int not null primary key using index ix_custno,
  ...</programlisting>
              <para>...will give you a PK constraint called <database>INTEG_7</database> or
              something similar, and an index <database>IX_CUSTNO</database>.</para>
              <para>Some more examples:</para>
              <programlisting>create table people (
  id int not null,
  nickname varchar(12) not null,
  country char(4),
  ..
  ..
  constraint pk_people primary key (id),
  constraint uk_nickname unique (nickname) using index ix_nick
)</programlisting>
              <programlisting>alter table people
  add constraint fk_people_country
  foreign key (country) references countries(code)
  using desc index ix_people_country</programlisting>
            </blockquote></para>
        </formalpara>
        <important>
          <para>If you define a descending constraint-enforcing index on a primary or unique key, be
          sure to make any foreign keys referencing it descending as well.<!--Or else?--></para>
        </important>
      </section>
    </section>
    <section id="langrefupd15-create-trigger">
      <title><database>CREATE TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-create-trigger-multiaction">
        <title>Multi-action triggers</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Triggers can now be defined to fire upon multiple operations
          (<database>INSERT</database> and/or <database>UPDATE</database> and/or
          <database>DELETE</database>). Three new boolean context variables
          (<varname>INSERTING</varname>, <varname>UPDATING</varname> and
          <varname>DELETING</varname>) have been added so you can execute code conditionally within
          the trigger body depending on the type of operation.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE TRIGGER <replaceable>trigger-name</replaceable> for <replaceable>table-name</replaceable>
   [ACTIVE | INACTIVE]
   {BEFORE | AFTER} <replaceable>&lt;actions&gt;</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
<replaceable>   &lt;trigger_body&gt;</replaceable>

<replaceable>&lt;actions&gt;</replaceable>       ::= <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable>]]
<replaceable>&lt;single_action&gt;</replaceable> ::= INSERT | UPDATE | DELETE</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create trigger biu_parts for parts
  before insert or update
as
begin
  /* conditional code when inserting: */
  if (inserting and new.id is null)
    then new.id = gen_id(gen_partrec_id, 1);
  
  /* common code: */
  new.partname_upper = upper(new.partname);
end</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>In multi-action triggers, both context variables <database>OLD</database> and
          <database>NEW</database> are always available. If you use them in the wrong situation
          (i.e. <database>OLD</database> while inserting or <database>NEW</database> while
          deleting), the following happens:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>If you try to read their field values, <constant>NULL</constant> is
              returned.</para>
            </listitem>
            <listitem>
              <para>If you try to assign values to them, a runtime exception is thrown.</para>
            </listitem>
          </itemizedlist>
        </note>
      </section>
      <section id="langrefupd15-create-trigger-changecount">
        <title><database>CREATE TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In contrast to InterBase, Firebird does not increment the metadata change counter of
          the associated table when <database>CREATE</database>, <database>ALTER</database> or
          <database>DROP TRIGGER</database> is used. For a full discussion, see <link
          linkend="langrefupd15-alter-trigger-changecount"><citetitle><database>ALTER
          TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-create-trigger-plan">
        <title><database>PLAN</database> allowed in trigger code</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
          would be rejected by the compiler. Now a valid plan can be included and will be
          used.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-view">
      <title><database>CREATE VIEW</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-creatview-noplan">
        <title><database>PLAN</database> subclause disallowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>You can no longer use a <database>PLAN</database> subclause in a view
          definition.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-or-alter-proc">
      <title><database>CREATE OR ALTER PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the procedure does not yet exist, it is created just as if <database>CREATE
        PROCEDURE</database> were used. If it already exists, it is altered and recompiled. Existing
        permissions and dependencies are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE PROCEDURE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-create-or-alter-trigger">
      <title><database>CREATE OR ALTER TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the trigger does not yet exist, it is created just as if <database>CREATE
        TRIGGER</database> were used. If it already exists, it is altered and recompiled. Existing
        permissions and dependencies are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE TRIGGER</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-declareext">
      <title><database>DECLARE EXTERNAL FUNCTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>This statement makes an external function (UDF) known to the database.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION <replaceable>localname</replaceable>
   [<replaceable>&lt;type_decl&gt;</replaceable> [, <replaceable>&lt;type_decl&gt;</replaceable> ...]]
   RETURNS {<replaceable>&lt;return_type_decl&gt;</replaceable> | PARAMETER <replaceable>1-based_pos</replaceable>} [FREE_IT]
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;type_decl&gt;</replaceable>         ::=  <replaceable>sqltype</replaceable> [BY DESCRIPTOR] | CSTRING(<replaceable>length</replaceable>)
<replaceable>&lt;return_type_decl&gt;</replaceable>  ::=  <replaceable>sqltype</replaceable> [BY {DESCRIPTOR|VALUE}] | CSTRING(<replaceable>length</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>You may choose <replaceable>localname</replaceable> freely; this is the name by which
      the function will be known to your database. You may also vary the
      <replaceable>length</replaceable> argument of <database>CSTRING</database> parameters (more
      about <database>CSTRING</database>s in the <link
      linkend="langrefupd15-notes-cstring">note</link> near the end of the book).</para>
      <section id="langrefupd15-declareext-bydescriptor">
        <title><database>BY DESCRIPTOR</database> parameter passing</title>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird introduces the possibility to pass parameters <database>BY
          DESCRIPTOR</database>; this mechanism facilitates the processing of
          <constant>NULL</constant>s in a meaningful way. Notice that this only works if the person
          who wrote the function has implemented it. Simply adding <quote><database>BY
          DESCRIPTOR</database></quote> to an existing declaration does not make it work – on the
          contrary! Always use the declaration block provided by the function designer.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-declareext-retparamn">
        <title><database>RETURNS PARAMETER</database> <replaceable>n</replaceable></title>
        <formalpara>
          <title>Added in</title>
          <para>IB 6</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In order to return a <database>BLOB</database>, an extra input parameter must be
          declared and a <quote><database>RETURNS PARAMETER</database>
          <replaceable>n</replaceable></quote> subclause added – <replaceable>n</replaceable> being
          the position of said parameter. This subclause dates back to InterBase 6 beta, but somehow
          didn't make it into the <citetitle>Language Reference</citetitle> (it is documented in the
          <citetitle>Developer's Guide</citetitle> though).</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-drop-generator">
      <title><database>DROP GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Removes a generator. Its (very small) storage space will be freed for re-use after a
        backup-restore cycle.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DROP GENERATOR <replaceable>generator-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-drop-trigger">
      <title><database>DROP TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-drop-trigger-changecount">
        <title><database>DROP TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In contrast to InterBase, Firebird does not increment the metadata change counter of
          the associated table when <database>CREATE</database>, <database>ALTER</database> or
          <database>DROP TRIGGER</database> is used. For a full discussion, see <link
          linkend="langrefupd15-alter-trigger-changecount"><citetitle><database>ALTER
          TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-recreate-procedure">
      <title><database>RECREATE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a stored procedure. If a procedure with the same name already
        exists, <database>RECREATE PROCEDURE</database> will try to drop it and create a new
        procedure. <database>RECREATE PROCEDURE</database> will fail if the existing
        <database>SP</database> is in use.<!--Make sure this last statement is true!--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE PROCEDURE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-recreate-table">
      <title><database>RECREATE TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a table. If a table with the same name already exists,
        <database>RECREATE TABLE</database> will try to drop it (destroying all its data in the
        process!) and create a new table. <database>RECREATE TABLE</database> will fail if the
        existing table is in use.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE TABLE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-recreate-view">
      <title><database>RECREATE VIEW</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a view. If a view with the same name already exists,
        <database>RECREATE VIEW</database> will try to drop it and create a new view.
        <database>RECREATE VIEW</database> will fail if the existing view is in use.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE VIEW</database>.</para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-dml">
    <title>DML statements</title>
    <!--Rlsnotes 1.0:
  New PLANONLY option for statements
  Support for PLANONLY setting, allows for a statement/query to be submitted to the engine and
  the plan retrieved, without executing the statement/query.

As it turns out, this refers to SET PLANONLY in isql. You can NOT just add PLANONLY
to SQL statements!-->
    <section id="langrefupd15-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a stored procedure. In Firebird 1.0.x as well as in InterBase, any input
        parameters for the SP must be supplied as literals, host language variables (in ESQL) or
        local variables (in PSQL). In Firebird 1.5 and above, input parameters may also be
        (compound) expressions, except in static ESQL.</para>
      </formalpara>
      <!--Calling SP's with SELECT already allowed compound expressions as parameters in IB and Fb1.-->
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [TRANSACTION <replaceable>transaction</replaceable>]
   [<replaceable>&lt;in_item&gt;</replaceable> [,  <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>  ::=  <replaceable>&lt;param&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable> ::=  <replaceable>&lt;outvar&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;param&gt;</replaceable>    ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>   ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>  ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>
            <note>
              <title>Notes</title>
              <itemizedlist>
                <listitem>
                  <para><database>TRANSACTION</database> clauses are not supported in PSQL.</para>
                </listitem>
                <listitem>
                  <para>Expression parameters are not supported in static ESQL, and not in Firebird
                  versions below 1.5.</para>
                </listitem>
                <listitem>
                  <para><constant>NULL</constant> indicators are only valid in ESQL code. They must
                  be host language variables of type integer.</para>
                </listitem>
                <listitem>
                  <para>In ESQL, variable names used as parameters or outvars must be preceded by a
                  colon (<quote>:</quote>). In PSQL the colon is generally optional, but forbidden
                  for the trigger context variables <database>OLD</database> and
                  <database>NEW</database>.</para>
                  <!--When called with SELECT, the colon must always be present if the parameter is a variable (except OLD/NEW).
(Does this go for inparms as well as INTO outparms?)-->
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>In PSQL (with optional colons):</para>
            <programlisting>execute procedure MakeFullName
  :FirstName, :MiddleName, :LastName
  returning_values :FullName;</programlisting>
            <para>The same call in ESQL (with obligatory colons):</para>
            <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :MiddleName, :LastName
    returning_values :FullName;</programlisting>
            <para>...and in Firebird's command-line utility <application>isql (with literal
            parameters)</application>:</para>
            <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>
            <para><emphasis role="bold">Note:</emphasis> In isql, don't use
            <database>RETURNING_VALUES</database>. Any output values are shown automatically.</para>
            <para>Finally, a PSQL example with expression parameters, only possible in Firebird 1.5
            and up:</para>
            <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, MiddleName, upper(LastName)
  returning_values FullName;</programlisting>
          </blockquote></para>
      </formalpara>
      <!--1.5 Release Notes say:

  Dmitry Yemanov
  Calls to EXECUTE PROCEDURE ProcName(<Argument-list>) and SELECT <Output-list> FROM
  ProcName(<Argument-list>) can now accept local variables (in PSQL) and expressions
  (in DSQL and PSQL) as arguments.

However:
- Local variables were already usable as arguments in InterBase.
- With SELECT, even expressions were already allowed as arguments in InterBase.
So the only novelty in Firebird 1.5 is:
- Using expressions as arguments when calling an SP with EXECUTE PROCEDURE.-->
    </section>
    <section id="langrefupd15-select">
      <title><database>SELECT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd15-aggregates">
        <title>Aggregate functions: Extended functionality</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Several types of mixing and nesting aggragate functions are supported since Firebird
          1.5. They will be discussed in the following subsections. To get the complete picture,
          also look at the <database>SELECT</database> :: <database>GROUP BY</database>
          sections.</para>
        </formalpara>
        <section id="langrefupd15-aggregates-mix">
          <title>Mixing aggregate functions from different contexts</title>
          <para>Firebird 1.5 and up allow the use of aggregate functions from different contexts
          inside a single expression.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
          <para>This admittedly rather contrived query shows, in the second column, the maximum
          index selectivity of any index defined on a table, followed by the table's field count
          between parentheses. Of course you would normally display the field count in a separate
          column, or in the column with the table name, but the purpose here is to demonstrate that
          you can combine aggregates from different contexts in a single expression.</para>
          <warning>
            <para>Firebird 1.0 also executes this type of query, but gives the wrong results!</para>
          </warning>
        </section>
        <section id="langrefupd15-aggregates-in-subqueries">
          <title>Aggregate functions and <database>GROUP BY</database> items inside
          subqueries</title>
          <para>Since Firebird 1.5 it is possible to use aggregate functions and/or expressions
          contained in the <database>GROUP BY</database> clause inside a subquery.</para>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>This query returns each table's ID and field count. The subquery refers to
                <literal><systemitem>flds.rdb$relation_name</systemitem></literal>, which is also a
                <database>GROUP BY</database> item:</para>
                <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>
                <para>The next query shows the last field from each table and and its 1-based
                position. It uses the aggregate function <database>MAX</database> in a
                subquery.</para>
                <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>
                <para>The subquery also contains the <database>GROUP BY</database> item
                <systemitem>flds.rdb$relation_name</systemitem>, but that's not immediately obvious
                because in this case the <database>GROUP BY</database> clause uses the column
                number.</para>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd15-subqueries-in-aggregates">
          <title>Subqueries inside aggregate functions</title>
          <para>Using a singleton subselect inside (or as) an aggregate function argument is
          supported in Firebird 1.5 and up.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>
                <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd15-aggregates-nesting">
          <title>Nesting aggregate function calls</title>
          <para>Firebird 1.5 allows the indirect nesting of aggregate functions, provided that the
          inner function is from a lower SQL context. Direct nesting of aggregate function calls, as
          in <quote><database>COUNT</database>( <database>MAX</database>( price ) )</quote>, is
          still forbidden and punishable by exception.</para>
          <formalpara>
            <title>Example</title>
            <para>See under <link
            linkend="langrefupd15-subqueries-in-aggregates"><citetitle>Subqueries inside aggregate
            functions</citetitle></link>, where <database>COUNT()</database> is used inside a
            <database>SUM()</database>.</para>
          </formalpara>
          <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
        </section>
        <section id="langrefupd15-aggregates-having-orderby">
          <title>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></title>
          <para>Firebird 1.5 and above are stricter than previous versions about what can be
          included in the <database>HAVING</database> and <database>ORDER BY</database> clauses. If,
          in the context of an aggregate statement, an operand in a <database>HAVING</database> or
          <database>ORDER BY</database> item contains a column name,<!--This should probably be: ...contains a column name from the query context (i.e. from the table or join in the FROM clause).-->
          it is only accepted if one of the following is true:</para>
          <itemizedlist>
            <listitem>
              <para>The column name appears in an aggregate function call (e.g. <quote><code>HAVING
              MAX(SALARY) &gt; 10000</code></quote>).</para>
            </listitem>
            <listitem>
              <para>The operand equals or is based upon a non-aggregate column that appears in the
              <database>GROUP BY</database> list (by name or position).</para>
            </listitem>
            <!--This listitem commented out for now, needs research:
  o  The operand equals or is based upon a subquery, whether or not it is also a GROUP BY item.-->
            <!--See also under GROUP BY. Check if it is possible to include a non-aggregated subquery in the HAVING / ORDER BY
if that subquery contains columns not present in the GROUP BY.
And if this is possible, also look what happens if that subquery returns different values within a group.-->
          </itemizedlist>
          <para><quote>Is based upon</quote> means that the operand need not be exactly the same as
          the column name. Suppose there's a non-aggregate column
          <quote><database>STR</database></quote> in the select list. Then it's OK to use
          expressions like <quote><database>UPPER(STR)</database></quote>, <quote><database>STR ||
          '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4 FOR 2)</database></quote>
          in the <database>HAVING</database> clause – even if these expressions don't appear as such
          in the <database>SELECT</database> or <database>GROUP BY</database> list.</para>
        </section>
      </section>
      <!--If and when the subquery thing gets mentioned again, the above para must also be changed: ("...as the column name or subquery." etc.)-->
      <!--1.5 Rlsnotes say:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used in the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->
      <!--*******

Maybe the entire GROUP BY thing should become something like this:

Every column that is present - in non-aggregrated form - on the highest (outermost?) level in the context of an aggregated query
(i.e., is a column of the relation(s) in the FROM clause)
*must* be included in the GROUP BY clause.

Question: If such a column is present in a subquery, but with the table alias as defined in the outermost query context,
must it go in the GROUP BY? I think yes, but test!
Question 2: As above, but this time with its own alias, belonging to the subselect?
I think it doesn't have to go in the GROUP BY then, but test.
Question 3: If a relation does not have an alias in the uppermost FROM, and it is used in a subselect
also without an alias, does that mean they have the same context? I hope not...-->
      <section id="langrefupd15-amb-join">
        <title>Ambiguous <database>JOIN</database> statements rejected</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>InterBase 6 accepts and executes statements like the one below, which refers to an
          unqualified column name even though that name exists in both tables participating in the
          <database>JOIN</database>:</para>
        </formalpara>
        <blockquote>
          <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
        </blockquote>
        <para>The results of such a query are unpredictable. Firebird Dialect 3 returns an error if
        there are ambiguous field names in <database>JOIN</database> statements. Dialect 1 gives a
        warning but will execute the query anyway.</para>
      </section>
      <section id="langrefupd15-first-skip">
        <title><database>FIRST</database> and <database>SKIP</database></title>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>FIRST</database> limits the output of a query to the first so-many rows.
          <database>SKIP</database> will suppress the given number of rows before starting to return
          output.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>
              <note>
                <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an integer literal or a
                query parameter, the <quote><literal>()</literal></quote> may be omitted. Subselects
                on the other hand require an extra pair of parentheses.</para>
              </note>
            </blockquote></para>
        </formalpara>
        <para><database>FIRST</database> and <database>SKIP</database> are both optional. When used
        together as in <quote><database>FIRST</database> <replaceable>m</replaceable>
        <database>SKIP</database> <replaceable>n</replaceable></quote>, the
        <replaceable>n</replaceable> topmost rows of the output set are discarded and the first
        <replaceable>m</replaceable> rows of the remainder are returned.</para>
        <para><database>SKIP</database> 0 is allowed, but of course rather pointless.
        <database>FIRST</database> 0 is allowed in version 1.5 and up, where it returns an empty
        set. In 1.0.x, <database>FIRST</database> 0 causes an error. Negative
        <database>SKIP</database> and/or <database>FIRST</database> values always result in an
        error.</para>
        <para>If a <database>SKIP</database> lands past the end of the dataset, an empty set is
        returned. If the number of rows in the dataset (or the remainder after a
        <database>SKIP</database>) is less than the value given after <database>FIRST</database>,
        that smaller number of rows is returned. These are valid results, not error
        situations.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The following query will return the first 10 names from the People table:</para>
              <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
              <para>The following query will return everything <emphasis>but</emphasis> the first 10
              names:</para>
              <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
              <para>And this one returns the last 10 rows. Notice the double parentheses:</para>
              <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
              <para>This query returns rows 81–100 of the People table:</para>
              <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
            </blockquote></para>
        </formalpara>
        <caution>
          <title>Two Gotchas with <database>FIRST</database> in subselects</title>
          <itemizedlist>
            <listitem>
              <para>This:</para>
              <blockquote>
                <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
              </blockquote>
              <para>will delete all of the rows in the table. Ouch! The sub-select is evaluating
              each 10 candidate rows for deletion, deleting them, slipping forward 10 more... ad
              infinitum, until there are no rows left. Beware!</para>
            </listitem>
            <listitem>
              <para>Queries like:</para>
              <blockquote>
                <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
              </blockquote>
              <para>won't work as expected, because the optimization performed by the engine
              transforms the <database>IN</database> predicate to the correlated
              <database>EXISTS</database> predicate shown below. It's obvious that in this case
              <database>FIRST</database> <replaceable>N</replaceable> doesn't make any sense:</para>
              <blockquote>
                <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
              </blockquote>
            </listitem>
          </itemizedlist>
        </caution>
      </section>
      <section id="langrefupd15-group-by-udf">
        <title><database>GROUP BY</database>
        <database><replaceable>UDF</replaceable></database></title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird, you can use the output of a user-defined function as a <database>GROUP
          BY</database> item.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>      ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>] | <replaceable>&lt;udf-call&gt;</replaceable>
<replaceable>&lt;udf-call&gt;</replaceable>  ::=  <replaceable>udf-name</replaceable>(<replaceable>arg1</replaceable> [, <replaceable>argN</replaceable> ...])</programlisting>
            </blockquote></para>
        </formalpara>
        <para><database>UDF</database> calls may be nested, but – as follows from the syntax – you
        cannot mix <database>UDF</database> calls and <database>COLLATE</database> in a single
        <database>GROUP BY</database> item.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select strlen(lastname), count(*)
  from people
  group by strlen(lastname)
  order by 2 desc</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para><database>DSQL</database> currently lacks a mechanism to check if <database>GROUP BY
          <replaceable>UDF</replaceable></database> subclauses are formulated correctly. Always make
          sure that your <database>GROUP BY</database> item list correctly represents the
          <emphasis>scalar</emphasis> (i.e. non-aggregate) expression(s) in your
          <database>SELECT</database> list.</para>
        </warning>
      </section>
      <section id="langrefupd15-group-by-extensions">
        <title><database>GROUP BY</database> internal function, column position, and
        <database>CASE</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 1.5 adds the following to the list of valid <database>GROUP BY</database>
          items:<itemizedlist spacing="compact">
              <listitem>
                <para>1-based column position numbers (like in <database>ORDER
                BY</database>);</para>
              </listitem>
              <listitem>
                <para>The internal functions <database>COALESCE</database>,
                <database>EXTRACT</database>, <database>NULLIF</database>,
                <database>SUBSTRING</database> and <database>UPPER</database>;</para>
              </listitem>
              <listitem>
                <para><database>CASE</database> constructs.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>           ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
                      | <replaceable>column-position</replaceable>
                      | <replaceable>&lt;function-call&gt;</replaceable>
                      | <replaceable>CASE-construct</replaceable>

<replaceable>&lt;function-call&gt;</replaceable>  ::=  COALESCE(<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable> [, <replaceable>argN</replaceable> ...])
                      | EXTRACT(<replaceable>part</replaceable> FROM <replaceable>date/time</replaceable>)
                      | NULLIF(<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable>)
                      | SUBSTRING(<replaceable>str</replaceable> FROM <replaceable>pos</replaceable> [FOR <replaceable>count</replaceable>])
                      | UPPER(<replaceable>str</replaceable>)
                      | <replaceable>udf-name</replaceable>(<replaceable>arg1</replaceable> [, <replaceable>argN</replaceable> ...])</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Function calls may be nested. As in previous versions, <database>COLLATE</database>
        can only be used with column names.</para>
        <para>If you group by a column position, the expression at that position is copied
        internally from the select list. If it concerns a subquery, that subquery will be executed
        at least twice.</para>
        <important>
          <itemizedlist>
            <listitem>
              <para>A <database>GROUP BY</database> item cannot be a reference to an aggregate
              function (including those that are buried inside an expression) from the same
              context.</para>
            </listitem>
            <listitem>
              <para>As before, every non-aggregate column <emphasis role="bold">must</emphasis>
              appear in the <database>GROUP BY</database> list, whether explicitly or by
              position.</para>
            </listitem>
            <listitem>
              <para>An exception to the previous rule are non-aggregate subquery columns; you may
              leave these out of the <database>GROUP BY</database> clause. Be very careful though:
              if the subquery uses columns that are not in the <database>GROUP BY</database> list,
              it may return different results within the same group and you're in trouble. To avoid
              this, add those columns – or the entire subquery column – to the <database>GROUP
              BY</database>.</para>
              <!--This is probably not entirely correct - try to improve!-->
            </listitem>
          </itemizedlist>
        </important>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>select
  case when price is null then 0 else price end,
  sum(number_sold)
from sales_per_article
group by
  case when price is null then 0 else price end</programlisting>
              <para>Of course this example is only to demonstrate the use of a
              <database>CASE</database> construct in the <database>GROUP BY</database> clause. In
              this particular case you should first of all use <database>COALESCE</database>:</para>
              <programlisting>select
  coalesce (price, 0),
  sum(number_sold)
from sales_per_article
group by
  coalesce (price, 0)</programlisting>
              <para>and then you could save yourself some typing time by using the column
              number:</para>
              <programlisting>select
  coalesce (price, 0),
  sum(number_sold)
from sales_per_article
group by 1</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-having-stricter">
        <title><database>HAVING</database>: Stricter rules</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>See <link linkend="langrefupd15-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-orderby">
        <title><database>ORDER BY</database>: Expressions and <constant>NULL</constant>s
        placement</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In addition to column names and positions, the <database>ORDER BY</database> clause
          can now also contain expressions to sort the output by. Furthermore, per-column
          <database>NULLS FIRST</database> and <database>NULLS LAST</database> subclauses can be
          used to specify where <constant>NULL</constant>s appear in the sorted column.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>column-name</replaceable> | <replaceable>column-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Expressions consisting of a single non-negative number will be interpreted as 1-based
        column numbers and will cause an exception if they're not in the range from 1 to the number
        of columns.</para>
        <para>By default, <constant>NULL</constant>s will be placed at the end of the sort,
        regardless whether the order is ascending or descending. This is the same behaviour as in
        previous Firebird versions. No index will be used on columns for which the non-default
        <database>NULLS FIRST</database> placement is chosen.</para>
        <para>The number of function or procedure invocations resulting from a sort based on a UDF
        or stored procedure is unpredictable, regardless whether the ordering is specified by the
        expression itself or by the column position number.</para>
        <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->
        <!--Rlsnotes 1.5 say:

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice?-->
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>
              <programlisting>select first 10 * from document
  order by strlen(description) desc</programlisting>
              <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-orderby-stricter">
        <title><database>ORDER BY</database>: Stricter rules with aggregate statements</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>See <link linkend="langrefupd15-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-with-lock">
        <title><database>WITH LOCK</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description:</title>
          <para><database>WITH LOCK</database> provides a limited explicit pessimistic locking
          capability for cautious use in conditions where the affected row set is:<orderedlist
              numeration="loweralpha" spacing="compact">
              <listitem>
                <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
              </listitem>
              <listitem>
                <para>precisely controlled by the application code.</para>
              </listitem>
            </orderedlist></para>
        </formalpara>
        <caution>
          <title>This is for experts only!</title>
          <para>The need for a pessimistic lock in Firebird is very rare indeed and should be well
          understood before use of this extension is considered.</para>
          <para>It is essential to understand the effects of transaction isolation and other
          transaction attributes before attempting to implement explicit locking in your
          application.</para>
        </caution>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>
        <para><database>WITH LOCK</database> can only be used with a top-level, single-table
        <database>SELECT</database> statement. It is <emphasis>not</emphasis> available:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>in a subquery specification;</para>
          </listitem>
          <listitem>
            <para>for joined sets;</para>
          </listitem>
          <listitem>
            <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
            clause or any other aggregating operation;</para>
          </listitem>
          <listitem>
            <para>with a view;</para>
          </listitem>
          <listitem>
            <para>with the output of a selectable stored procedure;</para>
          </listitem>
          <listitem>
            <para>with an external table.</para>
          </listitem>
        </itemizedlist>
        <para>A lengthier, more in-depth discussion of <quote><database>SELECT ... WITH
        LOCK</database></quote> is included in the <link
        linkend="langrefupd15-notes-withlock">Notes</link>. It is a must-read for everybody who
        considers using this feature.</para>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd15-transcontrol">
    <title>Transaction control statements</title>
    <section id="langrefupd15-release-savepoint">
      <title><database>RELEASE SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Deletes a named savepoint, freeing up all the resources it binds.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Unless <database>ONLY</database> is added, all the savepoints created after the named
      savepoint are released as well.</para>
      <para>For a full discussion of savepoints, see <link
      linkend="langrefupd15-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>
    <section id="langrefupd15-rollback-to-savepoint">
      <title><database>ROLLBACK TO SAVEPOINT</database></title>
      <!--Should become a subsection of ROLLBACK ... later?-->
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Undoes everything that happened in a transaction since the creation of the
        savepoint.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
      <!--Keep this itemizedlist synchronized with the one under SAVEPOINT !-->
      <itemizedlist>
        <listitem>
          <para>All the mutations performed within the transaction since the savepoint was created
          are undone.</para>
        </listitem>
        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are
          preserved, as is the savepoint itself. This means that you can rollback to the same
          savepoint several times.</para>
        </listitem>
        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released.
          Other transactions that have requested access to rows locked after the savepoint must
          continue to wait until the transaction is committed or rolled back. Other transactions
          that have not already requested the rows can request and access the unlocked rows
          immediately.</para>
        </listitem>
      </itemizedlist>
      <para>For a full discussion of savepoints, see <link
      linkend="langrefupd15-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>
    <section id="langrefupd15-savepoint">
      <title><database>SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates an SQL-99 compliant savepoint, to which you can later rollback your work
        without rolling back the entire transaction. Savepoint mechanisms are also known as
        <quote>nested transactions</quote>.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SAVEPOINT <replaceable>&lt;name&gt;</replaceable>

<replaceable>&lt;name&gt;</replaceable>  ::=  a user-chosen identifier, unique within the transaction</programlisting>
          </blockquote></para>
      </formalpara>
      <para>If the supplied name exists already within the same transaction, the existing savepoint
      is deleted and a new one is created with the same name.</para>
      <para>If you later want to rollback your work to the point where the savepoint was created,
      use:</para>
      <blockquote>
        <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
      </blockquote>
      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
      <!--Keep this itemizedlist synchronized with the one under ROLLBACK TO SAVEPOINT !-->
      <itemizedlist>
        <listitem>
          <para>All the mutations performed within the transaction since the savepoint was created
          are undone.</para>
        </listitem>
        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are
          preserved, as is the savepoint itself. This means that you can rollback to the same
          savepoint several times.</para>
        </listitem>
        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released.
          Other transactions that have requested access to rows locked after the savepoint must
          continue to wait until the transaction is committed or rolled back. Other transactions
          that have not already requested the rows can request and access the unlocked rows
          immediately.</para>
        </listitem>
      </itemizedlist>
      <para>The internal savepoint bookkeeping can consume huge amounts of memory, especially if you
      update the same records multiple times in one transaction. If you don't need a savepoint
      anymore but you're not yet ready to end the transaction, you can delete the savepoint and free
      the resources it uses with:</para>
      <blockquote>
        <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
      </blockquote>
      <para>With <database>ONLY</database>, the named savepoint is the only one that gets released.
      Without it, all savepoints created after it are released as well.</para>
      <formalpara>
        <title>Example DSQL session using a savepoint</title>
        <para><blockquote>
            <programlisting>create table test (id integer);
commit;
insert into test values (1);
commit;
insert into test values (2);
savepoint y;
delete from test;
select * from test;   -- returns no rows
rollback to y;
select * from test;   -- returns two rows
rollback;
select * from test;   -- returns one row</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd15-savepoint-internal">
        <title>Internal savepoints</title>
        <!--Does this belong here? Is it SQL? The TPB is an API thing, right?-->
        <para>By default, the engine uses an automatic transaction-level system savepoint to perform
        transaction rollback. When you issue a <database>ROLLBACK</database> statement, all changes
        performed in this transaction are backed out via a transaction-level savepoint and the
        transaction is then committed. This logic reduces the amount of garbage collection caused by
        rolled back transactions.</para>
        <para>When the volume of changes performed under a transaction-level savepoint is getting
        large (10<superscript>4</superscript>–10<superscript>6</superscript> records affected), the
        engine releases the transaction-level savepoint and uses the TIP mechanism to roll back the
        transaction if needed.</para>
        <tip>
          <para>If you expect the volume of changes in your transaction to be large, you can use the
          TPB flag <function>isc_tpb_no_auto_undo</function> to avoid the transaction-level
          savepoint being created.</para>
        </tip>
      </section>
      <section id="langrefupd15-savepoint-psql">
        <title>Savepoints and PSQL</title>
        <!--Here again the question whether it belongs here.-->
        <para>Transaction control statements are not allowed in PSQL, as that would break the
        atomicity of the statement that calls the procedure. But Firebird does support the raising
        and handling of exceptions in PSQL, so that actions performed in stored procedures and
        triggers can be selectively undone without the entire procedure failing. Internally,
        automatic savepoints are used to:</para>
        <itemizedlist>
          <listitem>
            <para>undo all actions in a <database>BEGIN...END</database> block where an uncaught
            exception occurs;</para>
          </listitem>
          <listitem>
            <para>undo all actions performed by the SP/trigger (or, in the case of a selectable SP,
            all actions performed since the last <database>SUSPEND</database>) when it terminates
            prematurely due to an uncaught error or exception.</para>
          </listitem>
        </itemizedlist>
        <para>Each PSQL exception handling block is also bounded by automatic system
        savepoints.</para>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd15-psql">
    <title>PSQL statements</title>
    <para>PSQL – Procedural SQL – is the Firebird stored procedure and trigger language.</para>
    <section id="langrefupd15-psql-begin-end">
      <title><database>BEGIN ... END</database> blocks may be empty</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
        allowing you to write stub code without having to resort to dummy statements.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-break">
      <title><database>BREAK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link linkend="langrefupd15-psql-leave"><database>LEAVE</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BREAK</database> immediately terminates a <database>WHILE</database> or
        <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure selphrase(num int)
returns (phrase varchar(40))
as
begin
  for select Phr from Phrases into phrase do
  begin
    if (num &lt; 1) then <emphasis role="bold">break;</emphasis>
    suspend;
    num = num - 1;
  end
  phrase = '***  Ready!  ***';
  suspend;
end</programlisting>
            <para>This selectable SP returns at most <replaceable>num</replaceable> rows from the
            table Phrases. The variable <replaceable>num</replaceable> is decremented in each
            iteration; once it is smaller than 1, the loop is terminated with
            <database>BREAK</database>. The program then continues at the line
            <quote><literal>phrase = '*** Ready! ***';</literal></quote>.</para>
          </blockquote></para>
      </formalpara>
      <important>
        <para>Since Firebird 1.5, use of the SQL-99 compliant synonym <link
        linkend="langrefupd15-psql-leave"><database>LEAVE</database></link> is preferred.</para>
      </important>
      <!--TESTED:
Contrary to what Fb 1.5 rlsnotes suggest, BREAK works in SPs *and* triggers as from 1.0.
In IB6 it doesn't exist.-->
    </section>
    <section id="langrefupd15-psql-declare">
      <title><database>DECLARE [VARIABLE]</database> with initialization</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and above, a PSQL local variable can be initialized upon declaration.
        The <database>VARIABLE</database> keyword has become optional.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>];</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure proccie (a int)
returns (b int)
as
  declare p int;
  declare q int = 8;
  declare r int default 9;
  declare variable s int;
  declare variable t int = 10;
  declare variable u int default 11;
begin
  <replaceable>&lt;intelligent code here&gt;</replaceable>
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-exception">
      <title><database>EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>EXCEPTION</database> syntax has been extended so that the user
        can<orderedlist numeration="loweralpha" spacing="compact">
            <listitem>
              <para>Rethrow a caught exception or error.</para>
            </listitem>
            <listitem>
              <para>Provide a custom message when throwing a user-defined exception.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXCEPTION [<replaceable>&lt;exception-name&gt;</replaceable> [<replaceable>custom-message</replaceable>]]

<replaceable>&lt;exception-name&gt;</replaceable>  ::=  A previously defined exception name</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd15-psql-exception-rethrow">
        <title>Rethrowing a caught exception</title>
        <para>Within the exception handling block only, you can rethrow the caught exception or
        error by giving the <database>EXCEPTION</database> command without any arguments. Outside
        such blocks, this <quote>bare</quote> command has no effect.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>when any do
begin
  insert into error_log (...) values (sqlcode, ...);
  exception;
end</programlisting>
              <para>This example first logs some information about the exception or error, and then
              rethrows it.</para>
              <!--So it also works with SQL en GDS errors? Answered by Dmitry: YES.-->
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-psql-exception-custom-msg">
        <title>Providing a custom error message</title>
        <para>Firebird 1.5 and up allow you to override an exception's default error message by
        supplying an alternative one when throwing the exception.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>exception ex_data_error 'You just lost some valuable data';</programlisting>
              <programlisting>exception ex_bad_type 'Wrong type for record with id ' || new.id;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-psql-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and above, (compound) expressions are allowed as input parameters for
        stored procedures called with <database>EXECUTE PROCEDURE</database>. See <link
        linkend="langrefupd15-execproc"><citetitle>DML statements :: <database>EXECUTE
        PROCEDURE</database></citetitle></link> for full info and examples.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-execstat">
      <title><database>EXECUTE STATEMENT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>EXECUTE STATEMENT</database> takes a single string argument and executes it
        as if it had been submitted as a DSQL statement. The exact syntax depends on the number of
        data rows that the supplied statement may return.</para>
      </formalpara>
      <section id="langrefupd15-psql-execstat-nooutput">
        <title>No data returned</title>
        <para>This form is used with <database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database> and <database>EXECUTE PROCEDURE</database> statements that
        return no data.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;statement&gt;</replaceable>

<replaceable>&lt;statement&gt;</replaceable>  ::=  An SQL statement returning no data.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleOne (ProcName varchar(100))
as
declare variable stmt varchar(1024);
declare variable param int;
begin
   select min(SomeField) from SomeTable into param;
   stmt = 'execute procedure ' 
          || ProcName 
          || '(' 
          || cast(param as varchar(20)) 
          || ')';
   execute statement stmt;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>Although this form of <database>EXECUTE STATEMENT</database> can also be used with
          all kinds of DDL strings (except <database>CREATE/DROP DATABASE</database>), it is
          generally very, very unwise to use this trick in order to circumvent the no-DDL rule in
          PSQL.</para>
        </warning>
      </section>
      <section id="langrefupd15-psql-execstat-singleton">
        <title>One row of data returned</title>
        <para>This form is used with singleton <database>SELECT</database> statements.</para>
        <!--EXECUTE PROCEDURE with RETURNING_VALUES is NOT possible in EXECUTE STATEMENT
(Token unknown - line 1, char 25 returning_values). Why?-->
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  An SQL statement returning at most one row of data.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleTwo (TableName varchar(100))
as
declare variable param int;
begin
  execute statement
    'select max(CheckField) from ' || TableName into :param;
  if (param &gt; 100) then
    exception Ex_Overflow 'Overflow in ' || TableName;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-psql-execstat-multirow">
        <title>Any number of data rows returned</title>
        <para>This form – analogous to <quote><database>FOR SELECT ... DO</database></quote> – is
        used with <database>SELECT</database> statements that may return a multi-row dataset.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>FOR EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   DO <replaceable>&lt;compound-statement&gt;</replaceable>

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  Any SELECT statement.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleThree 
  ( TextField varchar(100),
    TableName varchar(100) )
returns 
  ( LongLine varchar(32000) )
as
declare variable Chunk varchar(100);
begin
  Chunk = '';
  for execute statement
    'select ' || TextField || ' from ' || TableName into :Chunk
  do
    if (Chunk is not null) then
      LongLine = LongLine || Chunk || ' ';
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-psql-execstat-caveats">
        <title>Caveats with <database>EXECUTE STATEMENT</database></title>
        <orderedlist>
          <listitem>
            <para>There is no way to validate the syntax of the enclosed statement.</para>
          </listitem>
          <listitem>
            <para>There are no dependency checks to discover whether tables or columns have been
            dropped.</para>
          </listitem>
          <listitem>
            <para>Operations will be slow because the embedded statement has to be prepared every
            time it is executed.</para>
          </listitem>
          <listitem>
            <para>The argument string cannot contain any parameters. All variable substitution into
            the static part of the DSQL statement should be performed before <database>EXECUTE
            STATEMENT</database> is called.</para>
          </listitem>
          <listitem>
            <para>Return values are strictly checked for data type in order to avoid unpredictable
            type-casting exceptions. For example, the string <literal>'1234'</literal> would convert
            to an integer, 1234, but <literal>'abc'</literal> would give a conversion error.</para>
          </listitem>
          <listitem>
            <para>The submitted DSQL statement is always executed with the privileges of the current
            <emphasis role="bold">user</emphasis>. Privileges granted to the trigger or SP that
            contains the <database>EXECUTE STATEMENT</database> statement are not in effect while
            the DSQL statement runs.</para>
          </listitem>
        </orderedlist>
        <para>All in all, this feature is intended only for very cautious use and you should always
        take the above factors into account. Bottom line: use <database>EXECUTE STATEMENT</database>
        only when other methods are impossible, or perform even worse than <database>EXECUTE
        STATEMENT</database>.</para>
      </section>
    </section>
    <section id="langrefupd15-psql-exit">
      <title><database>EXIT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <database>EXIT</database> can be used in all PSQL. In earlier
        versions it is only supported in stored procedures, not in triggers.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-forexecstatdo">
      <title><database>FOR EXECUTE STATEMENT ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>See <link linkend="langrefupd15-psql-execstat-multirow"><citetitle><database>EXECUTE
        STATEMENT</database> :: Any number of data rows returned</citetitle></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-forselect">
      <title><database>FOR SELECT ... INTO ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a <database>SELECT</database> statement and retrieves the result set. In each
        iteration of the loop, the field values of the current row are copied into local variables.
        Adding an <database>AS CURSOR</database> clause enables positioned deletes and updates.
        <database>FOR SELECT</database> statements may be nested.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>FOR <replaceable>&lt;select-stmt&gt;</replaceable>
   INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   [AS CURSOR <replaceable>name</replaceable>]
DO
   <replaceable>&lt;psql-stmt&gt;</replaceable>

<replaceable>&lt;select-stmt&gt;</replaceable>  ::=  A valid <database>SELECT</database> statement.
<replaceable>&lt;var&gt;</replaceable>          ::=  A PSQL variable name, optionally preceded by <quote><literal>:</literal></quote>
<replaceable>&lt;psql-stmt&gt;</replaceable>    ::=  A single statement or a block of PSQL code.</programlisting>
            <itemizedlist>
              <listitem>
                <para>The <database>SELECT</database> statement may contain named SQL parameters,
                like in <quote><code>select name || :sfx from names where number =
                :num</code></quote>. Each parameter must be a PSQL variable that has been declared
                previously (this includes any in/out params of the PSQL module).</para>
              </listitem>
              <listitem>
                <para>Caution! If the value of a PSQL variable that is used in the
                <database>SELECT</database> statement changes during execution of the loop, the
                statement <emphasis>may</emphasis> (but will not always) be re-evaluated for the
                remaining rows. In general, this situation should be avoided. If you really need
                this behaviour, test your code thoroughly and make sure you know how variable
                changes affect the outcome. Also be advised that the behaviour may depend on the
                query plan, in particular the use of indices. As it is currently not strictly
                defined, it may change in some future version of Firebird.</para>
                <!--I have noticed that the statement is NOT re-avaluated if an index is used, and IS re-evaluated if no index is used.
Adding PLAN (T NATURAL) to a certain query forced re-evaluation and thus altered the outcome.
But I don't know if this is always the case, and if the use of an index is the only factor.-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>create procedure shownums
  returns (aa int, bb int, sm int, df int)
as
begin
  for select distinct a, b from numbers order by a, b
    into :aa, :bb
  do
  begin
    sm = aa + bb;
    df = aa - bb;
    suspend;
  end
end</programlisting>
            <programlisting>create procedure relfields
  returns (relation char(32), pos int, field char(32))
as
begin
  for select rdb$relation_name from rdb$relations
      into :relation
  do
  begin
    for select rdb$field_position + 1, rdb$field_name
        from rdb$relation_fields
        where rdb$relation_name = :relation
        order by rdb$field_position
        into :pos, :field
    do
    begin
      if (pos = 2) then relation = '  "';   -- for nicer output
      suspend;
    end
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd15-psql-forselect-ascursor">
        <title><database>AS CURSOR</database> clause</title>
        <formalpara>
          <title>Available in</title>
          <para>PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The optional <database>AS CURSOR</database> clause creates a named cursor that can
          be referenced (after <database>WHERE CURRENT OF</database>) within the <database>FOR
          SELECT</database> loop in order to update or delete the current row. This feature was
          already added in InterBase, but not mentioned in the <citetitle>Language
          Reference</citetitle>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure deltown (towntodelete varchar(24))
  returns (town varchar(24), pop int)
as
begin
  for select town, pop from towns into :town, :pop as cursor tcur do
  begin
    if (town = towntodelete)
      then delete from towns where current of tcur;
      else suspend;
  end
end</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>A <quote><database>FOR UPDATE</database></quote> clause is allowed in the
                <database>SELECT</database> statement., but not required for a positioned update or
                delete to succeed.</para>
              </listitem>
              <listitem>
                <para><database>AS CURSOR</database> is not supported in <database>FOR EXECUTE
                STATEMENT</database> loops, even if the statement to execute is a suitable
                <database>SELECT</database> query.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-psql-leave">
      <title><database>LEAVE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>LEAVE</database> immediately terminates a <database>WHILE</database> or
        <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>while (b &lt; 10) do
begin
  insert into Numbers(B) values (:b);
  b = b + 1;
  when any do
  begin
    execute procedure log_error (current_timestamp, 'Error in B loop');
    <emphasis role="bold">leave;</emphasis>
  end
end
c = 0;
while (c &lt; 10) do
begin
  ...
  ...
end</programlisting>
            <para>If an error occurs during the insert, the event is logged and the loop terminated.
            The program continues at the line of code reading <quote><literal>c =
            0;</literal></quote></para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-plan">
      <title><database>PLAN</database> allowed in trigger code</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would
        be rejected by the compiler. Now a valid plan can be included and will be used.</para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-variables">
    <title>Context variables</title>
    <section id="langrefupd15-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_CONNECTION</varname> returns a unique identifier for the current
        connection.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page
      and reset upon restore. Since the engine itself is not interested in this value, it is only
      incremented if the client reads it during a session. Hence it is only useful as a unique
      identifier, not as an indicator of the number of connections since the creation or latest
      restoration of the database. Please note that this will change in Firebird 2.1.</para>
    </section>
    <section id="langrefupd15-current_role">
      <title><varname>CURRENT_ROLE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the
        currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is
        <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><varname>CURRENT_ROLE</varname> always represents a valid role or
      <database>NONE</database>. If a user connects with a non-existing role, the engine silently
      resets it to <database>NONE</database> without returning an error.</para>
    </section>
    <section id="langrefupd15-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TRANSACTION</varname> contains the unique identifier of the current
        transaction.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header
      page and reset upon restore. Unlike <varname>CURRENT_CONNECTION</varname>, it is incremented
      with every new transaction, whether the client reads the value or not.</para>
    </section>
    <section id="langrefupd15-current_user">
      <title><varname>CURRENT_USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <database>USER</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-deleting">
      <title><varname>DELETING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired
        because of a <database>DELETE</database> operation. Intended for use in <link
        linkend="langrefupd15-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-gdscode">
      <title><varname>GDSCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <database>WHEN GDSCODE</database> handling block, the <varname>GDSCODE</varname>
        context variable contains a numerical representation of the current Firebird error code. It
        is 0 in <database>WHEN SQLCODE</database>, <database>WHEN EXCEPTION</database> and
        <database>WHEN ANY</database> handlers, as well as everywhere else in PSQL.</para>
        <!--In 2.0, GDSCODE is also non-zero in WHEN ANY (provided a GDS error occurred)-->
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when gdscode grant_obj_notfound, gdscode grant_fld_notfound,
     gdscode grant_nopriv, gdscode grant_nopriv_on_base
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Please notice: After <database>WHEN GDSCODE</database>, you must use symbolic names like
      <errorcode>grant_obj_notfound</errorcode> etc. But the <varname>GDSCODE</varname> context
      variable is an <database>INTEGER</database>. If you want to compare it against a certain
      error, you have to use the numeric value, e.g. 335544551 for
      <errorcode>grant_obj_notfound</errorcode>.</para>
    </section>
    <section id="langrefupd15-inserting">
      <title><varname>INSERTING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger
        fired because of an <database>INSERT</database> operation. Intended for use in <link
        linkend="langrefupd15-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-row_count">
      <title><varname>ROW_COUNT</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <varname>ROW_COUNT</varname> context variable contains the number of rows affected
        by the most recent DML statement (<database>INSERT</database>, <database>UPDATE</database>
        or <database>DELETE</database>) in the current trigger or stored procedure.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>For <database>SELECT</database> statements, <varname>ROW_COUNT</varname> currently
            returns 0.</para>
          </listitem>
          <listitem>
            <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows
            affected by an <database>EXECUTE STATEMENT</database> or <database>EXECUTE
            PROCEDURE</database> command.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-sqlcode">
      <title><varname>SQLCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <database>WHEN SQLCODE</database> handling block, the <varname>SQLCODE</varname>
        context variable contains the current SQL error code. In a <database>WHEN ANY</database>
        block it contains the SQL error code if indeed an SQL error occurred; otherwise it contains
        0. <varname>SQLCODE</varname> is also 0 in <database>WHEN GDSCODE</database> and
        <database>WHEN EXCEPTION</database> handlers, as well as everywhere else in PSQL.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-updating">
      <title><varname>UPDATING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired
        because of an <database>UPDATE</database> operation. Intended for use in <link
        linkend="langrefupd15-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-functions">
    <title>Internal functions</title>
    <section id="langrefupd15-coalesce">
      <title><database>COALESCE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>COALESCE</database> function takes two or more arguments and returns the
        value of the first non-<constant>NULL</constant> argument. If all the arguments evaluate to
        <constant>NULL</constant>, the result is <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select 
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
  as FullName
from Persons</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This example picks the Nickname from the Persons table. If it happens to be
      <constant>NULL</constant>, it goes on to FirstName. If that too is <constant>NULL</constant>,
      <quote>Mr./Mrs.</quote> is used. Finally, it adds the family name. All in all, it tries to use
      the available data to compose a full name that is as informal as possible. Notice that this
      scheme only works if absent nicknames and first names are really <constant>NULL</constant>: if
      one of them is an empty string instead, <database>COALESCE</database> will happily return that
      to the caller.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>COALESCE</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd15-udf-nvl"><function>*nvl</function></link> external functions.</para>
      </note>
    </section>
    <section id="langrefupd15-extract">
      <title><database>EXTRACT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB 6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Extracts and returns an element from a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database> expression. It was already added
        in InterBase 6, but not documented in the <citetitle>Language Reference</citetitle> at the
        time.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>SMALLINT</database> or <database>DECIMAL(6,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | DAY | WEEKDAY | YEARDAY
                   | HOUR | MINUTE | SECOND
<replaceable>&lt;datetime&gt;</replaceable>  ::=  An expression of type DATE, TIME or TIMESTAMP</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The returned datatype is <database>DECIMAL(6,4)</database> for the
      <database>SECOND</database> part and <database>SMALLINT</database> for all others. The ranges
      are shown in the table below.</para>
      <para>If you try to extract a part that isn't present in the date/time argument (e.g.
      <database>SECOND</database> from a <database>DATE</database> or <database>YEAR</database> from
      a <database>TIME</database>), an error occurs.</para>
      <table id="langrefupd15-tbl-extractranges">
        <title>Ranges for <database>EXTRACT</database> results</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Part</entry>
              <entry>Range</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><database>YEAR</database></entry>
              <entry>1–9999</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MONTH</database></entry>
              <entry>1–12</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>DAY</database></entry>
              <entry>1–31</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>WEEKDAY</database></entry>
              <entry>0–6</entry>
              <entry>0 = Sunday</entry>
            </row>
            <row>
              <entry><database>YEARDAY</database></entry>
              <entry>0–365</entry>
              <entry>0 = January 1</entry>
            </row>
            <row>
              <entry><database>HOUR</database></entry>
              <entry>0–23</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MINUTE</database></entry>
              <entry>0–59</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>SECOND</database></entry>
              <entry>0.0000–59.999</entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!--Tested: year in a DATE (when casting from dd.mm.yyyy string) can be 0-9999 in Fb1.5;
0 and 10000 give errors.
IB 6.5 doc specifies 0-5400 here
Oddly enough, DatDef sez DATE and TIMESTAMP can range from 1 Jan 100 a.d. to 29 Feb 32768 a.d.-->
    </section>
    <section id="langrefupd15-nullif">
      <title><database>NULLIF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>NULLIF</database> returns the value of the first argument, unless it is
        equal to the second. In that case, <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This will return the average weight of the persons listed in FatPeople, excluding those
      having a weight of -1, since <database>AVG</database> skips <constant>NULL</constant> data.
      Presumably, -1 indicates <quote>weight unknown</quote> in this table. A plain
      <database>AVG</database>(Weight) would include the -1 weights, thus skewing the result.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>NULLIF</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd15-udf-nullif"><function>*nullif</function></link> external
        functions.</para>
      </note>
    </section>
    <section id="langrefupd15-substring">
      <title><database>SUBSTRING()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring starting at the given position, either to the end of the
        string or with a given length.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SUBSTRING(<replaceable>&lt;str&gt;</replaceable> FROM <replaceable>startpos</replaceable> [FOR <replaceable>length</replaceable>])

&lt;str&gt; := any expression evaluating to a string
<replaceable>startpos</replaceable> and <replaceable>length</replaceable> must be integer literals</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>SUBSTRING</database> returns the stream of bytes starting at byte position
      <replaceable>startpos</replaceable> (the first byte position being 1). Without the
      <database>FOR</database> argument, it returns all the remaining bytes in the string. With
      <database>FOR</database>, it returns <replaceable>length</replaceable> bytes or the remainder
      of the string, whichever is shorter.</para>
      <para><database>SUBSTRING</database> can be used with:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>Any string or (var)char argument, regardless of its character set;</para>
        </listitem>
        <listitem>
          <para>Subtype 0 (binary) <database>BLOB</database>s;</para>
        </listitem>
        <listitem>
          <para>Subtype 1 (text) <database>BLOB</database>s, if the character set has 1 byte per
          character.</para>
        </listitem>
      </itemizedlist>
      <para><database>SUBSTRING</database> can <emphasis>not</emphasis> be used with text
      <database>BLOB</database>s that have an underlying multi-byte character set.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-udf">
    <title>External functions (UDFs)</title>
    <para>External functions must be <quote>declared</quote> (made known) to the database before
    they can be used. Firebird ships with two external function libraries:</para>
    <itemizedlist>
      <listitem>
        <para><systemitem class="library">ib_udf</systemitem> – inherited from InterBase;</para>
      </listitem>
      <listitem>
        <para><systemitem class="library">fbudf</systemitem> – a new library using <link
        linkend="langrefupd15-declareext-bydescriptor">descriptors</link>, present as from Firebird
        1.0 (Windows) and 1.5 (Linux).</para>
      </listitem>
    </itemizedlist>
    <para>Users can also create their own UDF libraries or acquire them from third parties.</para>
    <!--Wherever appropriate I used 32767 as a max string length, not 32765 (max. VARCHAR-length).
This is about what the function itself and the Firebird engine can handle when you call it
from your SQL, *not* about whether the result subsequently fits in a VARCHAR.-->
    <section id="langrefupd15-udf-addday">
      <title><function>addDay</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> days added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addday (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addDay
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addDay' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addhour">
      <title><function>addHour</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> hours added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addhour (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addHour
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addHour' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addmillisecond">
      <title><function>addMilliSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> milliseconds added.
        Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmillisecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMilliSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addminute">
      <title><function>addMinute</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> minutes added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addminute (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMinute
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addmonth">
      <title><function>addMonth</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> months added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmonth (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMonth
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addsecond">
      <title><function>addSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> seconds added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addsecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addweek">
      <title><function>addWeek</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> weeks added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addweek (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addWeek
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addyear">
      <title><function>addYear</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> years added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addyear (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addYear
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addYear' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-ascii_char">
      <title><function>ascii_char</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII character corresponding to the integer value passed in.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(1)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ascii_char (<parameter>intval</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration (changed)</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ascii_char
   INTEGER
   RETURNS CSTRING(1) FREE_IT
   ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf'</programlisting>
            <para>The declaration has been changed to reflect the fact that the UDF as such returns
            a 1-character C string, not an SQL <database>CHAR(1)</database> as stated in the
            InterBase declaration. The engine will pass it on to the caller as a
            <database>CHAR(1)</database> though.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-dow">
      <title><function>dow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the day of the week from a timestamp argument. The returned name may be
        localized.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>VARCHAR(15)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dow
   TIMESTAMP,
   VARCHAR(15) RETURNS PARAMETER 2
   ENTRY_POINT 'DOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd15-udf-sdow"><function>sdow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-dpower">
      <title><function>dpower</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th
        power.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dpower (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dPower
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR,
   DOUBLE PRECISION BY DESCRIPTOR
   RETURNS PARAMETER 3
   ENTRY_POINT 'power' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-getexacttimestamp">
      <title><function>getExactTimestamp</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the system time with milliseconds precision. This function was added because
        <varname>CURRENT_TIMESTAMP</varname> – at least in pre-2.0 versions of Firebird – has
        <literal>.0000</literal> in the fractional part of the second.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>getexacttimestamp()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION getExactTimestamp
   TIMESTAMP RETURNS PARAMETER 1
   ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-i64round">
      <title><function>i64round</function></title>
      <para>See <link linkend="langrefupd15-udf-round"><function>round</function></link>.</para>
    </section>
    <section id="langrefupd15-udf-i64truncate">
      <title><function>i64truncate</function></title>
      <para>See <link
      linkend="langrefupd15-udf-truncate"><function>truncate</function></link>.</para>
    </section>
    <section id="langrefupd15-udf-log">
      <title><function>log</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <function>log(x,y)</function> returns the the
        base-<parameter>x</parameter> logarithm of <parameter>y</parameter>. In Firebird 1.0.x and
        InterBase, it erroneously returns the base-<parameter>y</parameter> logarithm of
        <parameter>x</parameter>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>log (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration (unchanged)</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION log
   DOUBLE PRECISION, DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>If any of your pre-1.5 databases use <function>log</function>, check your PSQL and
        application code. It may contain workarounds to return the right results. Under Firebird 1.5
        and up, any such workarounds should be removed or you'll get the wrong results.</para>
      </warning>
    </section>
    <section id="langrefupd15-udf-lpad">
      <title><function>lpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string left-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>lpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses
            <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link
            linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this
            function can accept and return strings of up to 32767 characters.</para>
          </listitem>
          <listitem>
            <para>When calling this function, make sure <parameter>endlength</parameter> does not
            exceed the declared result length.</para>
          </listitem>
        </itemizedlist>
      </note>
      <!--OBSERVATION (with 1.5.3):
If endlength < strlen(input), the input string is truncated to endlength by cutting off
characters on the right side (end of the string)-->
    </section>
    <section id="langrefupd15-udf-ltrim">
      <title><function>ltrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any leading space characters removed. In Firebird 1.0.x,
        this function returns <constant>NULL</constant> if the input string is empty or
        <constant>NULL</constant>. In 1.5 and above it returns <literal>''</literal> (an empty
        string) in these cases.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ltrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ltrim
   CSTRING(255)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses
            <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link
            linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this
            function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-udf-nullif">
      <title><function>*nullif</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd15-nullif"><database>NULLIF()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>*nullif</function> functions – for integers, bigints, doubles and
        strings, respectively – each return the first argument if it is not equal to the second. If
        the arguments are equal, the functions return <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>inullif   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nullif (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnullif   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snullif   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5, use of the new internal function <link
      linkend="langrefupd15-nullif"><database>NULLIF</database></link> is preferred.</para>
      <warning>
        <title>Warnings</title>
        <itemizedlist>
          <listitem>
            <para>These functions return <constant>NULL</constant> when the second argument is
            <constant>NULL</constant>, even if the first argument is a proper value. This is a wrong
            result. The <database>NULLIF</database> internal function doesn't have this bug.</para>
          </listitem>
          <listitem>
            <para><function>i64nullif</function> and <function>dnullif</function> will return wrong
            and/or bizarre results if it is not 100% clear to the engine that each argument is of
            the intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE
            PRECISION</database>). If in doubt, cast them both explicitly to the declared type (see
            declarations below).</para>
          </listitem>
        </itemizedlist>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION inullif
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nullif
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS NUMERIC(18,4) BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <programlisting>DECLARE EXTERNAL FUNCTION dnullif
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snullif
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-nvl">
      <title><function>*nvl</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd15-coalesce"><database>COALESCE()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>nvl</function> functions – for integers, bigints, doubles and
        strings, respectively – are <constant>NULL</constant> replacers. They each return the first
        argument's value if it is not <constant>NULL</constant>. If the first argument is
        <constant>NULL</constant>, the value of the second argument is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>invl   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nvl (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnvl   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snvl   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5, use of the new internal function <link
      linkend="langrefupd15-coalesce"><database>COALESCE</database></link> is preferred.</para>
      <warning>
        <para><function>i64nvl</function> and <function>dnvl</function> will return wrong and/or
        bizarre results if it is not absolutely clear to the engine that each argument is of the
        intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE PRECISION</database>).
        If in doubt, cast both arguments explicitly to the declared type (see declarations
        below).</para>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION invl
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nvl
   NUMERIC(18,0) BY DESCRIPTOR, NUMERIC(18,0) BY DESCRIPTOR
   RETURNS NUMERIC(18,0) BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION dnvl
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snvl
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-right">
      <title><function>right</function></title>
      <para>See <link linkend="langrefupd15-udf-sright"><function>sright</function></link>.</para>
    </section>
    <section id="langrefupd15-udf-round">
      <title><function>round</function>, <function>i64round</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole number that is nearest to their (scaled
        numeric/decimal) argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>round    (<parameter>number</parameter>)
i64round (<parameter>bignumber</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Halves are always rounded upward, i.e. away from zero for positive numbers and toward
        zero for negative numbers. For instance, <literal>3.5</literal> is rounded to
        <literal>4</literal>, but <literal>-3.5</literal> is rounded to
        <literal>-3</literal>.</para>
      </caution>
      <warning>
        <title>Bug alert</title>
        <para>In versions 1.0 through 1.5.5, these functions are <emphasis>broken</emphasis> for
        negative numbers:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>Anything between 0 and -0.6 (that's right: -0.6, not -0.5) is rounded to 0.</para>
          </listitem>
          <listitem>
            <para>Anything between -0.6 and -1 is rounded to +1 (<emphasis>plus</emphasis>
            1).</para>
          </listitem>
          <listitem>
            <para>Anything between -1 and -1.6 is rounded to -1.</para>
          </listitem>
          <listitem>
            <para>Anything between -1.6 and -2 is rounded to -2.</para>
          </listitem>
          <listitem>
            <para>Etcetera.</para>
          </listitem>
        </itemizedlist>
        <para>Fixed in 1.5.6 (backport from 2.5).</para>
        <!--http://tracker.firebirdsql.org/browse/CORE-2281
Fixed in Jan 2009 in 1.5, 2.0, 2.1, 2.5 and main branches.
Fix will be effective in 1.5.6, 2.0.6, 2.1.3 and 2.5-->
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>round</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbround</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under truncate:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-rpad">
      <title><function>rpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string right-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>rpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses
            <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link
            linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this
            function can accept and return strings of up to 32767 characters.</para>
          </listitem>
          <listitem>
            <para>When calling this function, make sure <parameter>endlength</parameter> does not
            exceed the declared result length.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-udf-rtrim">
      <title><function>rtrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any trailing space characters removed. In Firebird
        1.0.x, this function returns <constant>NULL</constant> if the input string is empty or
        <constant>NULL</constant>. In 1.5 and above it returns <literal>''</literal> (an empty
        string) in these cases.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>rtrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rtrim
   CSTRING(255)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses
            <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link
            linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this
            function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-udf-sdow">
      <title><function>sdow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the abbreviated day of the week from a timestamp argument. The returned
        abbreviation may be localized.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>VARCHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sdow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sdow
   TIMESTAMP,
   VARCHAR(5) RETURNS PARAMETER 2
   ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd15-udf-dow"><function>dow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-sright">
      <title><function>sright</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the rightmost <replaceable>numchars</replaceable> characters of the input
        string. Only works with 1-byte character sets.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>VARCHAR(100)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sright (<parameter>str</parameter>, <parameter>numchars</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sright
   VARCHAR(100) BY DESCRIPTOR, SMALLINT,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'right' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-string2blob">
      <title><function>string2blob</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string as a <database>BLOB</database>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>string2blob (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION string2blob
   VARCHAR(300) BY DESCRIPTOR,
   BLOB RETURNS PARAMETER 2
   ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-substr">
      <title><function>substr</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0, 1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring from <parameter>startpos</parameter> to
        <parameter>endpos</parameter>, inclusively. Positions are 1-based. If
        <parameter>endpos</parameter> is past the end of the string, Firebird's
        <function>substr</function> returns all the characters from <parameter>startpos</parameter>
        to the end of the string. InterBase's <function>substr</function> returned
        <constant>NULL</constant> in this case.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>substr (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>endpos</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substr
   CSTRING(255), SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses
            <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link
            linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this
            function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
      <tip>
        <para>Although the function arguments are slightly different, consider using the internal
        SQL function <link linkend="langrefupd15-substring"><database>SUBSTRING</database></link>
        instead, for better compatibility.</para>
      </tip>
    </section>
    <section id="langrefupd15-udf-substrlen">
      <title><function>substrlen</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd15-substring"><database>SUBSTRING()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the substring starting at <parameter>startpos</parameter> and having
        <parameter>length</parameter> characters (or less, if the end of the string is reached
        first). Positions are 1-based. If either <parameter>startpos</parameter> or
        <parameter>length</parameter> is smaller than 1, an empty string is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>substrlen (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>length</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substrlen
   CSTRING(255), SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses
            <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link
            linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this
            function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
      <tip>
        <para>Firebird 1.0 has also implemented the internal SQL function <link
        linkend="langrefupd15-substring"><database>SUBSTRING</database></link>, effectively
        rendering <function>substrlen</function> obsolete in the same version in which it was
        introduced. In new code, use <database>SUBSTRING</database>.</para>
      </tip>
    </section>
    <section id="langrefupd15-udf-truncate">
      <title><function>truncate</function>, <function>i64truncate</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole-number portion of their (scaled numeric/decimal)
        argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>truncate    (<parameter>number</parameter>)
i64truncate (<parameter>bignumber</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Both functions round to the nearest whole number that is lower than or equal to the
        argument. This means that negative numbers are also <quote>truncated</quote> downward. For
        instance, <function>truncate(<parameter>-2.37</parameter>)</function> returns
        <literal>-3</literal>.</para>
      </caution>
      <warning>
        <title>Bug alert</title>
        <para>Contrary to what's mentioned above, in versions 1.0 through 1.5.5 anything between -1
        and 0 is truncated to 0. This anomaly has been corrected in Firebird 1.5.6 and above (as a
        backport from 2.5).</para>
        <!--http://tracker.firebirdsql.org/browse/CORE-2282
Fixed in Jan 2009 in 1.5, 2.0, 2.1, 2.5 and main branches.
Fix will be effective in 1.5.6, 2.0.6, 2.1.3 and 2.5-->
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>truncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbtruncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under round:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names.</para>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <appendix id="langrefupd15-notes">
    <title>Notes</title>
    <section id="langrefupd15-notes-charset-none">
      <title>Character set <database>NONE</database> data accepted <quote>as is</quote></title>
      <subtitle>In Firebird 1.5.1 and up</subtitle>
      <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
      moved to and from fields or variables with another character set, resulting in fewer
      transliteration errors.</para>
      <para>In Firebird 1.5.0, from a client connected with character set <database>NONE</database>,
      you could read data in two incompatible character sets – such as <database>SJIS</database>
      (Japanese) and <database>WIN1251</database> (Russian) – even though you could not read one of
      those character sets while connected from a client with the other character set. Data would be
      received <quote>as is</quote> and be stored without raising an exception.</para>
      <para>However, from this character set <database>NONE</database> client connection, an attempt
      to update any Russian or Japanese data columns using either parameterized queries or literal
      strings without introducer syntax would fail with transliteration errors; and subsequent
      queries on the stored <quote><database>NONE</database></quote> data would similarly
      fail.</para>
      <para>In Firebird 1.5.1, both problems have been circumvented. Data received from the client
      in character set <database>NONE</database> are still stored <quote>as is</quote> but what is
      stored is an exact, binary copy of the received string. In the reverse case, when stored data
      are read into this client from columns with specific character sets, there will be no
      transliteration error. When the connection character set is <database>NONE</database>, no
      attempt is made in either case to resolve the string to well-formed characters, so neither the
      write nor the read will throw a transliteration error.</para>
      <para>This opens the possibility for working with data from multiple character sets in a
      single database, as long as the connection character set is <database>NONE</database>. The
      client has full responsibility for submitting strings in the appropriate character set and
      converting strings returned by the engine, as needed.</para>
      <para>Abstraction layers that have to manage this can read the low byte of the
      <structfield>sqlsubtype</structfield> field in the <structname>XSQLVAR</structname> structure,
      which contains the character set identifier.</para>
      <para>While character set <database>NONE</database> literals are accepted and implicitly
      stored in the character set of their context, the use of introducer syntax to coerce the
      character sets of literals is highly recommended when the application is handling literals in
      a mixture of character sets. This should avoid the string's being misinterpreted when the
      application shifts the context for literal usage to a different character set.</para>
      <note>
        <para>Coercion of the character set, using the introducer syntax or casting, is still
        required when handling heterogeneous character sets from a client context that is anything
        other than <database>NONE</database>. Both methods are shown below, using character set
        <database>ISO8859_1</database> as an example target. Notice the
        <quote><literal>_</literal></quote> prefix in the introducer syntax.</para>
        <variablelist>
          <varlistentry>
            <term>Introducer syntax:</term>
            <listitem>
              <para><code>_ISO8859_1 <replaceable>mystring</replaceable></code></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Casting:</term>
            <listitem>
              <para><code>CAST (<replaceable>mystring</replaceable> AS
              VARCHAR(<replaceable>n</replaceable>) CHARACTER SET ISO8859_1)</code></para>
            </listitem>
          </varlistentry>
        </variablelist>
      </note>
    </section>
    <section id="langrefupd15-notes-withlock">
      <title>Understanding the <database>WITH LOCK</database> clause</title>
      <para>This note looks a little deeper into explicit locking and its ramifications. The
      <database>WITH LOCK</database> feature, added in Firebird 1.5, provides a limited explicit
      pessimistic locking capability for cautious use in conditions where the affected row set
      is:<orderedlist numeration="loweralpha" spacing="compact">
          <listitem>
            <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
          </listitem>
          <listitem>
            <para>precisely controlled by the application code.</para>
          </listitem>
        </orderedlist></para>
      <para>Pessimistic locks are rarely needed in Firebird. This is an expert feature, intended for
      use by those who thoroughly understand its consequences. Knowledge of the various levels of
      transaction isolation is essential. <database>WITH LOCK</database> is available in DSQL and
      PSQL, and only for top-level, single-table <database>SELECT</database>s. As stated in the
      reference part of this guide, <database>WITH LOCK</database> is <emphasis>not</emphasis>
      available:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification;</para>
        </listitem>
        <listitem>
          <para>for joined sets;</para>
        </listitem>
        <listitem>
          <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
          clause or any other aggregating operation;</para>
        </listitem>
        <listitem>
          <para>with a view;</para>
        </listitem>
        <listitem>
          <para>with the output of a selectable stored procedure;</para>
        </listitem>
        <listitem>
          <para>with an external table.</para>
        </listitem>
      </itemizedlist>
      <section id="langrefupd15-appx-withlock-syntax">
        <title>Syntax and behaviour</title>
        <blockquote>
          <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
        </blockquote>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>
        <para>As the engine considers, in turn, each record falling under an explicit lock
        statement, it returns either the record version that is the most currently committed,
        regardless of database state when the statement was submitted, or an exception.</para>
        <para>Wait behaviour and conflict reporting depend on the transaction parameters specified
        in the TPB block:</para>
        <table id="langrefupd15-tbl-tpb-effects">
          <title>How TPB settings affect explicit locking</title>
          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />
            <colspec align="left" colname="behaviour" colwidth="3*" />
            <thead>
              <row>
                <entry align="center">TPB mode</entry>
                <entry align="center">Behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row valign="top">
                <entry><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explicit locks are overridden by implicit or explicit
                table-level locks and are ignored.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If a record is modified by any transaction that was
                committed since the transaction attempting to get explicit lock started, or an
                active transaction has performed a modification of this record, an update conflict
                exception is raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If the record is modified by any transaction that has
                committed since the transaction attempting to get explicit lock started, an update
                conflict exception is raised immediately.</para><para>If an active transaction is
                holding ownership on this record (via explicit locking or by a normal optimistic
                write-lock) the transaction attempting the explicit lock waits for the outcome of
                the blocking transaction and, when it finishes, attempts to get the lock on the
                record again. This means that, if the blocking transaction committed a modified
                version of this record, an update conflict exception will be raised.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or normal update), an update conflict exception is
                raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or by a normal optimistic write-lock), the
                transaction attempting the explicit lock waits for the outcome of blocking
                transation and when it finishes, attempts to get the lock on the record
                again.</para><para>Update conflict exceptions can never be raised by an explicit
                lock statement in this TPB mode.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="langrefupd15-appx-withlock-engine">
        <title>How the engine deals with <database>WITH LOCK</database></title>
        <para>When an <database>UPDATE</database> statement tries to access a record that is locked
        by another transaction, it either raises an update conflict exception or waits for the
        locking transaction to finish, depending on TPB mode. Engine behaviour here is the same as
        if this record had already been modified by the locking transaction.</para>
        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>
        <para>The engine guarantees that all records returned by an explicit lock statement are
        actually locked and <emphasis>do</emphasis> meet the search conditions specified in
        <database>WHERE</database> clause, as long as the search conditions do not depend on any
        other tables, via joins, subqueries, etc. It also guarantees that rows not meeting the
        search conditions will not be locked by the statement. It can <emphasis>not</emphasis>
        guarantee that there are no rows which, though meeting the search conditions, are not
        locked.</para>
        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during
          the course of the locking statement's execution.</para>
        </note>
        <para>The engine locks rows at fetch time. This has important consequences if you lock
        several rows at once. Many access methods for Firebird databases default to fetching output
        in packets of a few hundred rows (<quote>buffered fetches</quote>). Most data access
        components cannot bring you the rows contained in the last-fetched packet, where an error
        occurred.</para>
      </section>
      <section id="langrefupd15-appx-withlock-of">
        <title>The optional <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> sub-clause</title>
        <para>The <database>FOR UPDATE</database> clause provides a technique to prevent usage of
        buffered fetches, optionally with the <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> subclause to enable positioned
        updates.</para>
        <tip>
          <para>Alternatively, it may be possible in your access components to set the size of the
          fetch buffer to 1. This would enable you to process the currently-locked row before the
          next is fetched and locked, or to handle errors without rolling back your
          transaction.</para>
        </tip>
      </section>
      <section id="langrefupd15-appx-withlock-caveats">
        <title>Caveats using <database>WITH LOCK</database></title>
        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were
            taken under that savepoint, but it doesn't notify waiting transactions. Applications
            should not depend on this behaviour as it may get changed in the future.</para>
          </listitem>
          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict
            errors, the volume of deadlock errors will grow unless you design your locking strategy
            carefully and control it rigorously.</para>
          </listitem>
          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit
            locks are (1) to prevent expensive handling of update conflict errors in heavily loaded
            applications and (2) to maintain integrity of objects mapped to a relational database in
            a clustered environment. If your use of explicit locking doesn't fall in one of these
            two categories, then it's the wrong way to do the task in Firebird.</para>
          </listitem>
          <listitem>
            <para>Explicit locking is an advanced feature; do not misuse it! While solutions for
            these kinds of problems may be very important for web sites handling thousands of
            concurrent writers, or for ERP/CRM systems operating in large corporations, most
            application programs do not need to work in such conditions.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="langrefupd15-appx-withlock-examples">
        <title>Examples using explicit locking</title>
        <orderedlist numeration="lowerroman">
          <listitem>
            <para>Simple:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK</programlisting>
          </listitem>
          <listitem>
            <para>Multiple rows, one-by-one processing with DSQL cursor:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK</programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section id="langrefupd15-notes-cstring">
      <title>A note on <database>CSTRING</database> parameters</title>
      <para>External functions involving strings often use the type
      <database>CSTRING(<replaceable>n</replaceable>)</database> in their declarations. This type
      represents a zero-terminated string of maximum length <replaceable>n</replaceable>. Most of
      the functions handling <database>CSTRING</database>s are programmed in such a way that they
      can accept and return zero-terminated strings of any length. So why the
      <replaceable>n</replaceable>? Because the Firebird engine has to set up space to process the
      input an output parameters, and convert them to and from SQL data types. Most strings used in
      databases are only dozens to hundreds of bytes long; it would be a waste to reserve 32 KB of
      memory each time such a string is processed. Therefore, the <emphasis>standard</emphasis>
      declarations of most <database>CSTRING</database> functions – as found in the file
      <filename>ib_udf.sql</filename> – specify a length of 255 bytes. (In Firebird 1.5.1 and below,
      this default length is 80 bytes.) As an example, here's the SQL declaration of
      <function>lpad</function>:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
      </blockquote>
      <para>Once you've declared a <database>CSTRING</database> parameter with a certain length, you
      cannot call the function with a longer input string, or cause it to return a string longer
      than the declared output length. But the standard declarations are just reasonable defaults;
      they're not cast in concrete, and you can change them if you want to. If you have to left-pad
      strings of up to 500 bytes long, then it's perfectly OK to change both 255's in the
      declaration to 500 or more.</para>
      <para>A special case is when you usually operate on short strings (say less then 100 bytes)
      but occasionally have to call the function with a huge <database>(VAR)CHAR</database>
      argument. Declaring <database>CSTRING(32000)</database> makes sure that all the calls will be
      successful, but it will also cause 32000 bytes per parameter to be reserved, even in that
      majority of cases where the strings are under 100 bytes. In that situation you may consider
      declaring the function twice, with different names and different string lengths:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpad</emphasis>
   <emphasis role="bold">CSTRING(100)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(100)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';

DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpadbig</emphasis>
   <emphasis role="bold">CSTRING(32000)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(32000)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';</programlisting>
      </blockquote>
      <para>Now you can call <function>lpad()</function> for all the small strings and
      <function>lpadbig()</function> for the occasional monster. Notice how the declared names in
      the first line differ (they determine how you call the functions from within your SQL), but
      the entry point (the function name in the library) is the same in both cases.</para>
      <!--The Firebird Book states that the low default is there for security reasons, to prevent accidental or malicious overflow.-->
    </section>
  </appendix>
  <appendix id="langrefupd15-dochist">
    <title>Document History</title>
    <para>The exact file history is recorded in the <filename class="directory">manual</filename>
    module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>
    <para><revhistory>
        <revision>
          <revnumber>1.0</revnumber>
          <date>4 Jul 2008</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>First publication, using 15–20% material from the Firebird Release Notes.</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.1</revnumber>
          <date>8 Dec 2010</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>GLOBAL: Renamed all <quote>Deprecated in</quote> section headers to <quote>Better
            alternative</quote>. This also required editing the text immediately following the
            header and in some cases additional text in the section (if the
            <quote>deprecation</quote> was discussed in the section body).</para>
            <para><citetitle>Bookinfo</citetitle>: Added 1.5.6 to covered versions.</para>
            <para><citetitle>Introduction :: Versions covered</citetitle>: Added 1.5.6.</para>
            <para><citetitle>Introduction :: Authorship</citetitle>: Edited first paragraph. Added
            Frank Ingermann to contributor list.</para>
            <para><citetitle>Reserved words :: Added in 1.0 and 1.5</citetitle>: Put 2nd list in
            alphabetical order.</para>
            <para><citetitle>Reserved words :: To be added in future versions</citetitle>: Put list
            in alphabetical order.</para>
            <para><citetitle>Miscellaneous language elements :: -- (single-line
            comment)</citetitle>: Brought last para within blockquote.</para>
            <para><citetitle>Miscellaneous language elements</citetitle>: Added sections
            <citetitle><database>||</database> (string concatenator)</citetitle> and
            <citetitle>Shorthand casts</citetitle>.</para>
            <para><citetitle>DDL statements</citetitle>: Added section <citetitle><database>ALTER
            DOMAIN</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>ALTER TABLE</database></citetitle>: Added
            section <citetitle><database>ADD</database> column: Context variables as
            defaults</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>ALTER TABLE</database></citetitle>: Added
            section <citetitle><database>FOREIGN KEY</database> without target column references
            <database>PK</database></citetitle>.</para>
            <para><citetitle>DDL statements</citetitle>: Added section <citetitle><database>CREATE
            DOMAIN</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>CREATE TABLE</database></citetitle>: Added
            section <citetitle>Context variables as column defaults</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>CREATE TABLE</database></citetitle>: Added
            section <citetitle><database>FOREIGN KEY</database> without target column references
            <database>PK</database></citetitle>.</para>
            <para><citetitle>DML statements</citetitle>: Moved sections <citetitle><database>RELEASE
            SAVEPOINT</database></citetitle>, <citetitle><database>ROLLBACK TO
            SAVEPOINT</database></citetitle> and
            <citetitle><database>SAVEPOINT</database></citetitle> into new chapter
            <citetitle>Transaction control statements</citetitle>.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> :: Aggregate functions:
            Extended functionality :: Aggregate statements: Stricter <database>HAVING</database> and
            <database>ORDER BY</database></citetitle>: Edited second listitem. Commented out third
            listitem as it needs research. Edited last paragraph.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> ::
            <database>FIRST</database> and <database>SKIP</database></citetitle>: Edited
            Description.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> :: <database>GROUP
            BY</database> internal function, column position, and
            <database>CASE</database></citetitle>: Added 3rd listitem to Important box. Edited the
            paras between the examples.</para>
            <para><citetitle>Transaction control statements</citetitle>: new chapter.</para>
            <para><citetitle>PSQL statements :: <database>DECLARE [VARIABLE]</database> with
            initialization</citetitle>: Indented var declarations in Example.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database> :: Caveats
            with <database>EXECUTE STATEMENT</database></citetitle>: Changed SQL -&gt; DSQL in item
            4. Rewrote item 6.</para>
            <para><citetitle>PSQL statements</citetitle>: Added section <citetitle><database>FOR
            SELECT ... INTO ... DO</database></citetitle>.</para>
            <para><citetitle>Context variables :: <varname>CURRENT_CONNECTION</varname></citetitle>:
            Improved Description. Added note about upcoming change in 2.1 to last paragraph.</para>
            <para><citetitle>Context variables ::
            <varname>CURRENT_TRANSACTION</varname></citetitle>: Improved Description.</para>
            <para><citetitle>Context variables :: <varname>ROW_COUNT</varname></citetitle>: Edited
            Description. Edited second Note.</para>
            <para><citetitle>External functions ::
            <function>getExactTimestamp</function></citetitle>: Edited Description.</para>
            <para><citetitle>External functions :: <function>log</function></citetitle>: Changed
            <function>log</function> -&gt; <function>log(x,y)</function> in Description.</para>
            <para><citetitle>External functions :: <function>right</function></citetitle>: moved to
            <citetitle><function>sright</function></citetitle> and left a symlink in place.</para>
            <para><citetitle>External functions :: <function>round</function>,
            <function>i64round</function></citetitle>: Added 1.5.6 to Changed in. Added Caution box.
            Edited and extended Bug warning box.</para>
            <para><citetitle>External functions :: <function>substrlen</function></citetitle>: Added
            <quote>Better alternative</quote> formalpara.</para>
            <para><citetitle>External functions :: <function>truncate</function>,
            <function>i64truncate</function></citetitle>: Added 1.5.6 to Changed in. Added Caution
            box. Edited Warning box.</para>
            <para><citetitle>Notes :: Understanding the <database>WITH LOCK</database> clause ::
            Syntax and behaviour</citetitle>: In table, aligned 1st column left, all rows top, and
            added periods to sentences in first two rows.</para>
            <para><citetitle>License notice</citetitle>: Added Frank Ingermann as contributor.
            Copyright end year now 2010.</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.2</revnumber>
          <date>? Xxx 201?</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para><citetitle>Context variables :: <varname>GDSCODE</varname></citetitle>: Corrected
            Example: after <database>WHEN GDSCODE</database> a symbolic name must follow, not a
            number. Added notice after Example to explain same.</para>
            <para><citetitle>License notice</citetitle>: Copyright end year now 2011.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>
  <appendix id="langrefupd15-license">
    <title>License notice</title>
    <para>The contents of this Documentation are subject to the Public Documentation License Version
    1.0 (the <quote>License</quote>); you may only use this Documentation if you comply with the
    terms of this License. Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>
    <para>The Original Documentation is titled <citetitle>Firebird 1.5 Language Reference
    Update</citetitle>.</para>
    <para>The Initial Writers of the Original Documentation are: Paul Vinkenoog et al.</para>
    <para>Copyright (C) 2008–2011. All Rights Reserved. Initial Writers contact: paul at vinkenoog
    dot nl.</para>
    <para>Writers and Editors of included PDL-licensed material (the <quote>al.</quote>) are: J.
    Beesley, Helen Borrie, Arno Brinkman, Frank Ingermann, Alex Peshkov, Nickolay Samofatov, Dmitry
    Yemanov.</para>
    <para>Included portions are Copyright (C) 2001-2007 by their respective authors. All Rights
    Reserved.</para>
  </appendix>
</book>
