<?xml version="1.0" encoding="UTF-8"?>
<!--
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-->
<book id="langrefupd15">
  <bookinfo>
    <title>Firebird 1.5 Language Reference Update</title>
    <subtitle>Everything new in Firebird SQL since InterBase 6</subtitle>
    <titleabbrev>Firebird 1.5 Language Update</titleabbrev>
    <author>
      <firstname>Paul</firstname>
      <surname>Vinkenoog et al.</surname>
    </author>
    <edition>3 July 2008, document version 0.1 — covers Firebird 1.0–1.5.5</edition>
  </bookinfo>
  <chapter id="langrefupd15-intro">
    <title>Introduction</title>
    <para>This guide documents the <emphasis role="bold">changes</emphasis> made in Firebird 1.0 and 1.5 SQL since the fork from the open-sourced InterBase 6.0 codebase. It covers the following areas:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>Reserved words</para>
      </listitem>
      <listitem>
        <para>Data types and subtypes</para>
      </listitem>
      <listitem>
        <para>DDL statements (Data Definition Language)</para>
      </listitem>
      <listitem>
        <para>DML statements (Data Manipulation Language)</para>
      </listitem>
      <listitem>
        <para>PSQL statements (Procedural SQL, used in stored procedures and triggers)</para>
      </listitem>
      <listitem>
        <para>Context variables</para>
      </listitem>
      <listitem>
        <para>Internal functions</para>
      </listitem>
      <listitem>
        <para>UDFs (User Defined Functions, also known as external functions)</para>
      </listitem>
    </itemizedlist>
    <para>To have a complete Firebird 1.0 and 1.5 SQL reference, you need:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>The InterBase 6.0 beta SQL Reference (<filename>LangRef.pdf</filename> and/or <filename>SQLRef.html</filename>)</para>
      </listitem>
      <listitem>
        <para>This document</para>
      </listitem>
    </itemizedlist>
    <para>Topics <emphasis role="bold">not</emphasis> discussed in this document include:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>ODS versions</para>
      </listitem>
      <listitem>
        <para>Bug listings</para>
      </listitem>
      <listitem>
        <para>Installation and configuration</para>
      </listitem>
      <listitem>
        <para>Upgrade, migration and compatibility</para>
      </listitem>
      <listitem>
        <para>Server architectures</para>
      </listitem>
      <listitem>
        <para>API functions</para>
      </listitem>
      <listitem>
        <para>Connection protocols</para>
      </listitem>
      <listitem>
        <para>Tools and utilities</para>
      </listitem>
    </itemizedlist>
    <para>Consult the Release Notes for information on these subjects. You can find the Release Notes and other documentation via the Firebird Documentation Index at <ulink url="http://www.firebirdsql.org/index.php?op=doc">http://www.firebirdsql.org/index.php?op=doc</ulink>.</para>
    <section id="langrefupd15-intro-versions">
      <title>Versions covered</title>
      <para>This document covers all Firebird versions up to and including 1.5.5.</para>
    </section>
    <section id="langrefupd15-intro-authors">
      <title>Authorship</title>
      <para>Roughly 80–85% of the text in this document is new. The remainder was lifted from various Firebird Release Notes editions, which in turn contain material from preceding sources like the Whatsnew documents. Authors and editors of the included material are:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>J. Beesley</para>
        </listitem>
        <listitem>
          <para>Helen Borrie</para>
        </listitem>
        <listitem>
          <para>Arno Brinkman</para>
        </listitem>
        <listitem>
          <para>Alex Peshkov</para>
        </listitem>
        <listitem>
          <para>Nickolay Samofatov</para>
        </listitem>
        <listitem>
          <para>Dmitry Yemanov</para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>
  <chapter id="langrefupd15-reswords">
    <title>Reserved words</title>
    <para>Reserved words are part of the Firebird SQL language. They cannot be used as identifiers, except when enclosed in double quotes. However, you should avoid this unless you really have no other option.</para>
    <section id="langrefupd15-reswords-10-not-15">
      <title>Added in 1.0 but removed in 1.5</title>
      <para>The following reserved words were added in Firebird 1.0 but removed again in 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>BREAK</database></member>
          <member><database>DESCRIPTOR</database></member>
          <member><database>FIRST</database></member>
          <member><database>SKIP</database></member>
          <member><database>SUBSTRING</database></member>
        </simplelist>
      </blockquote>
      <para>The following non-reserved words were earmarked in Firebird 1.0 as <quote>to be avoided because of future reservation</quote>, but no longer so in 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>COALESCE</database></member>
          <member><database>IIF</database></member>
          <member><database>NULLIF</database></member>
        </simplelist>
      </blockquote>
      <para>(of these three, <database>COALESCE</database> and <database>NULLIF</database> are non-reserved keywords in 1.5)</para>
    </section>
    <section id="langrefupd15-reswords-10-or-15">
      <title>Added in 1.0 and 1.5</title>
      <para>The following reserved words were added in Firebird 1.0 and are still reserved in 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>CURRENT_ROLE</database></member>
          <member><database>CURRENT_USER</database></member>
          <member><database>RECREATE</database></member>
        </simplelist>
      </blockquote>
      <para>The following reserved words were added in Firebird 1.5:</para>
      <blockquote>
        <simplelist>
          <member><database>BIGINT</database></member>
          <member><database>CASE</database></member>
          <member><database>RELEASE</database></member>
          <member><database>SAVEPOINT</database></member>
          <member><database>CURRENT_CONNECTION</database></member>
          <member><database>CURRENT_TRANSACTION</database></member>
          <member><database>ROW_COUNT</database></member>
        </simplelist>
      </blockquote>
      <para>The following words are not reserved, but recognized as keywords by Firebird 1.5 if used in the proper context:</para>
      <blockquote>
        <simplelist>
          <member><database>COALESCE</database></member>
          <member><database>DELETING</database></member>
          <member><database>INSERTING</database></member>
          <member><database>LAST</database></member>
          <member><database>LEAVE</database></member>
          <member><database>LOCK</database></member>
          <member><database>NULLIF</database></member>
          <member><database>NULLS</database></member>
          <member><database>STATEMENT</database></member>
          <member><database>UPDATING</database></member>
          <member><database>USING</database></member>
        </simplelist>
      </blockquote>
    </section>
    <section id="langrefupd15-reswords-future">
      <title>To be added in future versions</title>
      <para>The following words are not reserved in Firebird 1.0 or 1.5, but should be avoided as identifiers because they will likely be reserved in future versions:</para>
      <blockquote>
        <simplelist>
          <member><database>ABS</database></member>
          <member><database>BOOLEAN</database></member>
          <member><database>BOTH</database></member>
          <member><database>CHAR_LENGTH</database></member>
          <member><database>CHARACTER_LENGTH</database></member>
          <member><database>FALSE</database></member>
          <member><database>LEADING</database></member>
          <member><database>OCTET_LENGTH</database></member>
          <member><database>TRIM</database></member>
          <member><database>TRAILING</database></member>
          <member><database>TRUE</database></member>
          <member><database>UNKNOWN</database></member>
        </simplelist>
      </blockquote>
    </section>
  </chapter>
  <chapter id="langrefupd15-misc">
    <title>Miscellaneous language elements</title>
    <section id="langrefupd15-linecomment">
      <title>-- (single-line comment)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A line starting with <quote><literal>--</literal></quote> (two dashes) is a comment and will be ignored. This also makes it easy to quickly comment out a line of SQL.</para>
      </formalpara>
      <para>In Firebird 1.5 and up, the <quote><literal>--</literal></quote> can be placed anywhere on the line, e.g. after an SQL statement. Everything from the double dash to the end of the line will be ignored.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>-- a table to store our valued customers in:
create table Customers (
  name varchar(32),
  added_by varchar(24),
  custno varchar(8),
  purchases integer      -- number of purchases
)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Notice that the second comment is only allowed in Firebird 1.5 and up.</para>
    </section>
    <section id="langrefupd15-case">
      <title><database>CASE</database> construct</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A <database>CASE</database> construct returns exactly one value from a number of possibilities. There are two syntactic variants:<itemizedlist spacing="compact">
            <listitem>
              <para>The simple <database>CASE</database>, comparable to a Pascal <code>case</code> or a C <code>switch</code>.</para>
            </listitem>
            <listitem>
              <para>The searched <database>CASE</database>, which works like a series of <quote><code>if ... else if ... else if</code></quote> clauses.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <section id="langrefupd15-case-simple">
        <title>Simple <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE <replaceable>&lt;expression&gt;</replaceable>
   WHEN <replaceable>&lt;exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>When this variant is used, <replaceable>&lt;expression&gt;</replaceable> is compared to <replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> etc., until a match is found, upon which the corresponding result is returned. If there is no match and there is an <database>ELSE</database> clause, <replaceable>defaultresult</replaceable> is returned. If there is no match and no <database>ELSE</database> clause, <constant>NULL</constant> is returned.</para>
        <para>The match is determined with the <quote>=</quote> operator, so if <replaceable>&lt;expression&gt;</replaceable> is <constant>NULL</constant>, it won't match any of the <replaceable>&lt;expN&gt;</replaceable>s, not even those that are <constant>NULL</constant>.</para>
        <para>The results don't have to be literal values: they may also be field or variable names, compound expressions, or <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select name,
       age,
       case upper(sex)
         when 'M' then 'Male'
         when 'F' then 'Female'
         else 'Unknown'
       end,
       religion
from people</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-case-searched">
        <title>Searched <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE
   WHEN <replaceable>&lt;bool_exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;bool_exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Here, the <replaceable>&lt;bool_expN&gt;</replaceable>s are tests that give a ternary boolean result: <constant>true</constant>, <constant>false</constant>, or <constant>NULL</constant>. The first expression evaluating to <constant>TRUE</constant> determines the result. If no expression is <constant>TRUE</constant> and there is an <database>ELSE</database> clause, <replaceable>defaultresult</replaceable> is returned. If no expression is <constant>TRUE</constant> and there is no <database>ELSE</database> clause, <constant>NULL</constant> is returned.</para>
        <para>As with the simple <database>CASE</database>, the results don't have to be literal values: they may also be field or variable names, compound expressions, or <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>CanVote = case
            when Age &gt;= 18 then 'Yes'
            when Age &lt;  18 then 'No'
            else 'Unsure'
          end;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd15-datatypes">
    <title>Data types and subtypes</title>
    <section id="langrefupd15-bigint">
      <title><database>BIGINT</database> data type</title>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BIGINT</database> is the SQL99-compliant 64-bit signed integer type. It is available in Dialect 3 only.</para>
      </formalpara>
      <para><database>BIGINT</database> numbers range from -2<superscript>63</superscript> .. 2<superscript>63</superscript>-1, or -9,223,372,036,854,775,808 .. 9,223,372,036,854,775,807.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create table WholeLottaRecords (
  id bigint not null primary key,
  description varchar(32)
)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-charsets">
      <title>New character sets</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5</para>
      </formalpara>
      <para>The following table lists the character sets added in Firebird.</para>
      <table id="langrefupd15-tbl-charsets">
        <title>Character sets new in Firebird</title>
        <tgroup cols="4">
          <colspec colname="colName" colwidth="2*" />
          <colspec colname="colBytes" colwidth="*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Name</entry>
              <entry align="center">Bytes/char.</entry>
              <entry align="center">Languages</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>DOS737</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS775</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS858</entry>
              <entry>1</entry>
              <entry>= DOS850 plus € sign</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS862</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS864</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS866</entry>
              <entry>1</entry>
              <entry>Russian</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS869</entry>
              <entry>1</entry>
              <entry>Modern Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_2</entry>
              <entry>1</entry>
              <entry>Latin-2, Central European</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO8859_3</entry>
              <entry>1</entry>
              <entry>Latin-3, Southern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_4</entry>
              <entry>1</entry>
              <entry>Latin-4, Northern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_5</entry>
              <entry>1</entry>
              <entry>Cyrillic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_6</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_7</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_8</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_9</entry>
              <entry>1</entry>
              <entry>Latin-5, Turkish</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>1</entry>
              <entry>Latin-7, Baltic Rim</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1255</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1256</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1257</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd15-charset-none">
      <title>Character set <database>NONE</database> handling changed</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are moved to and from fields or variables with another character set, resulting in fewer transliteration errors. For more details, see the <link linkend="langrefupd15-notes-charset-none">Note</link> at the end of the book.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-collations">
      <title>New collations</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5, 1.5.1</para>
      </formalpara>
      <para>The following table lists the collations added in Firebird.</para>
      <table id="langrefupd15-tbl-collations">
        <title>Collations new in Firebird</title>
        <tgroup cols="4">
          <colspec colname="colCharset" colwidth="2*" />
          <colspec colname="colCollation" colwidth="2*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Character set</entry>
              <entry align="center">Collation</entry>
              <entry align="center">Language</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">ISO8859_2</entry>
              <entry>CS_CZ</entry>
              <entry>Czech</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO_HUN</entry>
              <entry>Hungarian</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>LT_LT</entry>
              <entry>Lithuanian</entry>
              <entry>1.5.1</entry>
            </row>
            <row>
              <entry>WIN1250</entry>
              <entry>PXW_HUN</entry>
              <entry>Hungarian</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>WIN1251</entry>
              <entry>WIN1251_UA</entry>
              <entry>Ukrainian and Russian</entry>
              <entry>1.5</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </chapter>
  <chapter id="langrefupd15-ddl">
    <title>DDL statements</title>
    <!--ALTER INDEX

Fb1 RlsNotes say:

Allow FK indexes to be disabled
It is now possible to set FOREIGN KEY indexes inactive using ALTER INDEX. This should resolve
some performance issues related to maintaining indexes with low selectivity.

In practice, this doesn't work and has never been implemented (confirmed by Dmitry).
It should have been removed from the Rlsnotes.-->
    <section id="langrefupd15-alter-table">
      <title><database>ALTER TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-at-position">
        <title><database>ALTER COLUMN</database>: <database>POSITION</database> now 1-based</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>When changing a column's position, the engine now interprets the new position as 1-based. This is in accordance with the SQL standard and the InterBase documentation, but in practice InterBase interpreted the position as 0-based.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> POSITION <replaceable>&lt;newpos&gt;</replaceable>

<replaceable>&lt;newpos&gt;</replaceable>  ::=  an integer between 1 and the number of columns</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table Stock alter Quantity position 3</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>Don't confuse this with the <database>POSITION</database> in <database>CREATE/ALTER TRIGGER</database>. Trigger positions are and will remain 0-based.</para>
        </note>
      </section>
      <section id="langrefupd15-at-unique-keys">
        <title><database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple – are now allowed in columns with a <database>UNIQUE</database> constraint. For a full discussion, see <link linkend="langrefupd15-ct-unique-keys"><citetitle><database>CREATE TABLE</database> :: <database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-at-using-index">
        <title><database>USING INDEX</database> subclause</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>USING INDEX</database> subclause can be placed at the end of a primary, unique or foreign key definition. Its purpose is to<itemizedlist spacing="compact">
              <listitem>
                <para>provide a user-defined name for the automatically created index that enforces the constraint, and</para>
              </listitem>
              <listitem>
                <para>optionally define the index to be ascending or descending (the default being ascending).</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>[ADD] [CONSTRAINT <replaceable>constraint-name</replaceable>]
<replaceable>   &lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>For a full discussion and examples, see <link linkend="langrefupd15-ct-using-index"><citetitle><database>CREATE TABLE</database> :: <database>USING INDEX</database> subclause</citetitle></link>.</para>
      </section>
    </section>
    <section id="langrefupd15-alter-trigger">
      <title><database>ALTER TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-alter-trigger-multiaction">
        <title>Multi-action triggers</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ALTER TRIGGER</database> syntax has been extended to support multi-action triggers. For a full discussion of this feature, see <link linkend="langrefupd15-create-trigger-multiaction"><citetitle><database>CREATE TRIGGER</database> :: Multi-action triggers</citetitle></link>.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TRIGGER <replaceable>trigger-name</replaceable>
   [ACTIVE | INACTIVE]
   {BEFORE | AFTER} <replaceable>&lt;actions&gt;</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
<replaceable>   &lt;trigger_body&gt;</replaceable>

<replaceable>&lt;actions&gt;</replaceable>       ::= <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable>]]
<replaceable>&lt;single_action&gt;</replaceable> ::= INSERT | UPDATE | DELETE</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-alter-trigger-changecount">
        <title><database>ALTER TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Each time you use <database>CREATE</database>, <database>ALTER</database> or <database>DROP TRIGGER</database>, InterBase increments the metadata change counter of the associated table. Once that counter reaches 255, no more metadata changes are possible on the table (you can still work with the data though). A backup-restore cycle is needed to reset the counter and perform metadata operations again.</para>
        </formalpara>
        <para>While this obligatory cleanup after many metadata changes is in itself a useful feature, it also means that users who regularly use <database>ALTER TRIGGER</database> to deactivate triggers during e.g. bulk import operations are forced to backup and restore much more often then needed.</para>
        <para>Since changes to triggers don't imply structural changes to the table itself, Firebird no longer increments the table change counter when <database>CREATE</database>, <database>ALTER</database> or <database>DROP TRIGGER</database> is used. One thing has remained though: once the counter is at 255, you can no longer create, alter or drop triggers for that table.</para>
      </section>
      <section id="langrefupd15-alter-trigger-plan">
        <title><database>PLAN</database> allowed in trigger code</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would be rejected by the compiler. Now a valid plan can be included and will be used.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-database">
      <title><database>CREATE DATABASE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-cr-db-pagesize16k">
        <title>16 Kb page size supported</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum database page size has been raised from 8192 to 16384 bytes.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE {DATABASE | SCHEMA}
   ...
   [PAGE_SIZE [=] <replaceable>&lt;size&gt;</replaceable>]
   ...

<replaceable>&lt;size&gt;</replaceable>  ::=  1024 | 2048 | 4096 | 8192 | 16384</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-generator">
      <title><database>CREATE GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-creatgen-limitraised">
        <title>Maximum number of generators significantly raised</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>InterBase reserved only one database page for generators, limiting the total number to 123 (on 1K pages) – 1019 (on 8K pages). Firebird has done away with that limit; you can now create more than 32,000 generators per database.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-index">
      <title><database>CREATE INDEX</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-creatind-unique-nulls">
        <title><database>UNIQUE</database> indices now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple – are now allowed in columns that have a <database>UNIQUE</database> index defined on them. For a full discussion, see <link linkend="langrefupd15-ct-unique-keys"><citetitle><database>CREATE TABLE</database> :: <database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</citetitle></link>. As far as <constant>NULL</constant>s are concerned, the rules for unique indices are exactly the same as those for unique keys.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-creatind-maxnumber">
        <title>Maximum number of indices per table increased</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0.3 and 1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum number of 64 indices per table has been removed in Firebird 1.0.3, and reintroduced at the higher level of 256 in Firebird 1.5.</para>
        </formalpara>
        <note>
          <para>Probably due to an off-by-one error in the code, the effective ceiling is 65 indices in Firebird 1.0 and 1.0.2, and 257 indices in Firebird 1.5.</para>
        </note>
        <para>The number of indices attainable in practice is further limited by the database page size and the number of columns per index, as shown in the table below.</para>
        <table id="langrefupd15-tbl-maxindices">
          <title>Maximum indices per table</title>
          <tgroup cols="10">
            <colspec align="left" colname="colPageSize" />
            <colspec align="center" colname="colFb10_1" />
            <colspec align="center" colname="colFb10_2" />
            <colspec align="center" colname="colFb10_3" />
            <colspec align="center" colname="colFb103_1" />
            <colspec align="center" colname="colFb103_2" />
            <colspec align="center" colname="colFb103_3" />
            <colspec align="center" colname="colFb15_1" />
            <colspec align="center" colname="colFb15_2" />
            <colspec align="center" colname="colFb15_3" />
            <spanspec align="center" nameend="colFb10_3" namest="colFb10_1" spanname="spanFb10" />
            <spanspec align="center" nameend="colFb103_3" namest="colFb103_1" spanname="spanFb103" />
            <spanspec align="center" nameend="colFb15_3" namest="colFb15_1" spanname="spanFb15" />
            <spanspec align="center" nameend="colFb15_3" namest="colFb10_1" spanname="spanAllVersions" />
            <thead>
              <row valign="top">
                <entry align="left" morerows="2">Page size</entry>
                <entry spanname="spanAllVersions">Firebird version(s)</entry>
              </row>
              <row>
                <entry spanname="spanFb10">1.0, 1.0.2</entry>
                <entry spanname="spanFb103">1.0.3</entry>
                <entry spanname="spanFb15">1.5.x</entry>
              </row>
              <row>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1024</entry>
                <entry>62</entry>
                <entry>50</entry>
                <entry>41</entry>
                <entry>62</entry>
                <entry>50</entry>
                <entry>41</entry>
                <entry>62</entry>
                <entry>50</entry>
                <entry>41</entry>
              </row>
              <row>
                <entry>2048</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>126</entry>
                <entry>101</entry>
                <entry>84</entry>
                <entry>126</entry>
                <entry>101</entry>
                <entry>84</entry>
              </row>
              <row>
                <entry>4096</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>254</entry>
                <entry>203</entry>
                <entry>169</entry>
                <entry>254</entry>
                <entry>203</entry>
                <entry>169</entry>
              </row>
              <row>
                <entry>8192</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>510</entry>
                <entry>408</entry>
                <entry>340</entry>
                <entry>257</entry>
                <entry>257</entry>
                <entry>257</entry>
              </row>
              <row>
                <entry>16384</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>65</entry>
                <entry>1022</entry>
                <entry>818</entry>
                <entry>681</entry>
                <entry>257</entry>
                <entry>257</entry>
                <entry>257</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Please be aware that under normal circumstances, even 64 indices is way too many and will drastically reduce mutation speeds. The maximum was raised to accommodate data-warehousing applications and the like, that do lots of bulk operations during which indices are temporarily switched off.</para>
      </section>
    </section>
    <section id="langrefupd15-create-table">
      <title><database>CREATE TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-ct-unique-keys">
        <title><database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple – are now allowed in columns with a <database>UNIQUE</database> constraint. It is therefore possible to define a <database>UNIQUE</database> key on a column that has no <database>NOT NULL</database> constraint.</para>
        </formalpara>
        <para>For <database>UNIQUE</database> keys that span multiple columns, the logic is a little complicated:</para>
        <itemizedlist>
          <listitem>
            <para>Multiple rows having <emphasis>all</emphasis> the <database>UK</database> columns <constant>NULL</constant> are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having a <emphasis>different subset</emphasis> of <database>UK</database> colums <constant>NULL</constant> are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having the <emphasis>same subset</emphasis> of <database>UK</database> columns <constant>NULL</constant> and the rest filled with regular values and those regular values <emphasis>differ</emphasis> in at least one column, are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having the <emphasis>same subset</emphasis> of <database>UK</database> columns <constant>NULL</constant> and the rest filled with regular values and those regular values are the <emphasis>same</emphasis> in every column, are forbidden.</para>
          </listitem>
        </itemizedlist>
        <para>One way of summarizing this is as follows: In principle, all <constant>NULL</constant>s are considered distinct. But if two rows have exactly the same subset of <database>UK</database> columns filled with non-<constant>NULL</constant> values, the <constant>NULL</constant> columns are ignored and the non-<constant>NULL</constant> columns are decisive, just as if they constituted the entire unique key.</para>
        <!--Give example tables to show what is and isn't allowed?-->
      </section>
      <section id="langrefupd15-ct-using-index">
        <title><database>USING INDEX</database> subclause</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>USING INDEX</database> subclause can be placed at the end of a primary, unique or foreign key definition. Its purpose is to<itemizedlist spacing="compact">
              <listitem>
                <para>provide a user-defined name for the automatically created index that enforces the constraint, and</para>
              </listitem>
              <listitem>
                <para>optionally define the index to be ascending or descending (the default being ascending).</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <para>Without <database>USING INDEX</database>, indices enforcing named constraints are named after the constraint (this is new behaviour in Firebird 1.5) and indices for unnamed constraints get names like <database>RDB$FOREIGN13</database> or something equally romantic.</para>
        <note>
          <para>You must always provide a <emphasis>new</emphasis> name for the index. It is not possible to use pre-existing indices to enforce constraints.</para>
        </note>
        <para><database>USING INDEX</database> can be applied at field level, at table level, and (in <database>ALTER TABLE</database>) with <database>ADD CONSTRAINT</database>. It works with named as well as unnamed key constraints. It does <emphasis>not</emphasis> work with <database>CHECK</database> constraints, as these don't have their own enforcing index.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>[CONSTRAINT <replaceable>constraint-name</replaceable>]
   <replaceable>&lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The first example creates a primary key constraint <database>PK_CUST</database> using an index named <database>IX_CUSTNO</database>:</para>
              <programlisting>create table customers (
  custno int not null constraint pk_cust primary key using index ix_custno,
  ...</programlisting>
              <para>This, however:</para>
              <programlisting>create table customers (
  custno int not null primary key using index ix_custno,
  ...</programlisting>
              <para>...will give you a PK constraint called <database>INTEG_7</database> or something similar, and an index <database>IX_CUSTNO</database>.</para>
              <para>Some more examples:</para>
              <programlisting>create table people (
  id int not null,
  nickname varchar(12) not null,
  country char(4),
  ..
  ..
  constraint pk_people primary key (id),
  constraint uk_nickname unique (nickname) using index ix_nick
)</programlisting>
              <programlisting>alter table people
  add constraint fk_people_country
  foreign key (country) references countries(code)
  using desc index ix_people_country</programlisting>
            </blockquote></para>
        </formalpara>
        <important>
          <para>If you define a descending constraint-enforcing index on a primary or unique key, be sure to make any foreign keys referencing it descending as well.<!--Or else?--></para>
        </important>
      </section>
    </section>
    <section id="langrefupd15-create-trigger">
      <title><database>CREATE TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-create-trigger-multiaction">
        <title>Multi-action triggers</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Triggers can now be defined to fire upon multiple operations (<database>INSERT</database> and/or <database>UPDATE</database> and/or <database>DELETE</database>). Three new boolean context variables (<varname>INSERTING</varname>, <varname>UPDATING</varname> and <varname>DELETING</varname>) have been added so you can execute code conditionally within the trigger body depending on the type of operation.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE TRIGGER <replaceable>trigger-name</replaceable> for <replaceable>table-name</replaceable>
   [ACTIVE | INACTIVE]
   {BEFORE | AFTER} <replaceable>&lt;actions&gt;</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
<replaceable>   &lt;trigger_body&gt;</replaceable>

<replaceable>&lt;actions&gt;</replaceable>       ::= <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable> [OR <replaceable>&lt;single_action&gt;</replaceable>]]
<replaceable>&lt;single_action&gt;</replaceable> ::= INSERT | UPDATE | DELETE</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create trigger biu_parts for parts
  before insert or update
as
begin
  /* conditional code when inserting: */
  if (inserting and new.id is null)
    then new.id = gen_id(gen_partrec_id, 1);
  
  /* common code: */
  new.partname_upper = upper(new.partname);
end</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>In multi-action triggers, both context variables <database>OLD</database> and <database>NEW</database> are always available. If you use them in the wrong situation (i.e. <database>OLD</database> while inserting or <database>NEW</database> while deleting), the following happens:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>If you try to read their field values, <constant>NULL</constant> is returned.</para>
            </listitem>
            <listitem>
              <para>If you try to assign values to them, a runtime exception is thrown.</para>
            </listitem>
          </itemizedlist>
        </note>
      </section>
      <section id="langrefupd15-create-trigger-changecount">
        <title><database>CREATE TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In contrast to InterBase, Firebird does not increment the metadata change counter of the associated table when <database>CREATE</database>, <database>ALTER</database> or <database>DROP TRIGGER</database> is used. For a full discussion, see <link linkend="langrefupd15-alter-trigger-changecount"><citetitle><database>ALTER TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-create-trigger-plan">
        <title><database>PLAN</database> allowed in trigger code</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would be rejected by the compiler. Now a valid plan can be included and will be used.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-view">
      <title><database>CREATE VIEW</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-creatview-noplan">
        <title><database>PLAN</database> subclause disallowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>You can no longer use a <database>PLAN</database> subclause in a view definition.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-create-or-alter-proc">
      <title><database>CREATE OR ALTER PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the procedure does not yet exist, it is created just as if <database>CREATE PROCEDURE</database> were used. If it already exists, it is altered and recompiled. Existing permissions and dependencies are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE PROCEDURE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-create-or-alter-trigger">
      <title><database>CREATE OR ALTER TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the trigger does not yet exist, it is created just as if <database>CREATE TRIGGER</database> were used. If it already exists, it is altered and recompiled. Existing permissions and dependencies are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE TRIGGER</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-declareext">
      <title><database>DECLARE EXTERNAL FUNCTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>This statement makes an external function (UDF) known to the database.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION <replaceable>localname</replaceable>
   [<replaceable>&lt;type_decl&gt;</replaceable> [, <replaceable>&lt;type_decl&gt;</replaceable> ...]]
   RETURNS {<replaceable>&lt;return_type_decl&gt;</replaceable> | PARAMETER <replaceable>1-based_pos</replaceable>} [FREE_IT]
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;type_decl&gt;</replaceable>         ::=  <replaceable>sqltype</replaceable> [BY DESCRIPTOR] | CSTRING(<replaceable>length</replaceable>)
<replaceable>&lt;return_type_decl&gt;</replaceable>  ::=  <replaceable>sqltype</replaceable> [BY {DESCRIPTOR|VALUE}] | CSTRING(<replaceable>length</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>You may choose <replaceable>localname</replaceable> freely; this is the name by which the function will be known to your database. You may also vary the <replaceable>length</replaceable> argument of <database>CSTRING</database> parameters (more about <database>CSTRING</database>s in the <link linkend="langrefupd15-notes-cstring">note</link> near the end of the book).</para>
      <section id="langrefupd15-declareext-bydescriptor">
        <title><database>BY DESCRIPTOR</database> parameter passing</title>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird introduces the possibility to pass parameters <database>BY DESCRIPTOR</database>; this mechanism facilitates the processing of <constant>NULL</constant>s in a meaningful way. Notice that this only works if the person who wrote the function has implemented it. Simply adding <quote><database>BY DESCRIPTOR</database></quote> to an existing declaration does not make it work – on the contrary! Always use the declaration block provided by the function designer.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-declareext-retparamn">
        <title><database>RETURNS PARAMETER</database> <replaceable>n</replaceable></title>
        <formalpara>
          <title>Added in</title>
          <para>IB 6</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In order to return a <database>BLOB</database>, an extra input parameter must be declared and a <quote><database>RETURNS PARAMETER</database> <replaceable>n</replaceable></quote> subclause added – <replaceable>n</replaceable> being the position of said parameter. This subclause dates back to InterBase 6 beta, but somehow didn't make it into the <citetitle>Language Reference</citetitle> (it is documented in the <citetitle>Developer's Guide</citetitle> though).</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-drop-generator">
      <title><database>DROP GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Removes a generator. Its (very small) storage space will be freed for re-use after a backup-restore cycle.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DROP GENERATOR <replaceable>generator-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-drop-trigger">
      <title><database>DROP TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd15-drop-trigger-changecount">
        <title><database>DROP TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In contrast to InterBase, Firebird does not increment the metadata change counter of the associated table when <database>CREATE</database>, <database>ALTER</database> or <database>DROP TRIGGER</database> is used. For a full discussion, see <link linkend="langrefupd15-alter-trigger-changecount"><citetitle><database>ALTER TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-recreate-procedure">
      <title><database>RECREATE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a stored procedure. If a procedure with the same name already exists, <database>RECREATE PROCEDURE</database> will try to drop it and create a new procedure. <database>RECREATE PROCEDURE</database> will fail if the existing <database>SP</database> is in use.<!--Make sure this last statement is true!--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE PROCEDURE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-recreate-table">
      <title><database>RECREATE TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a table. If a table with the same name already exists, <database>RECREATE TABLE</database> will try to drop it (destroying all its data in the process!) and create a new table. <database>RECREATE TABLE</database> will fail if the existing table is in use.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE TABLE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-recreate-view">
      <title><database>RECREATE VIEW</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a view. If a view with the same name already exists, <database>RECREATE VIEW</database> will try to drop it and create a new view. <database>RECREATE VIEW</database> will fail if the existing view is in use.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE VIEW</database>.</para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-dml">
    <title>DML statements</title>
    <!--Rlsnotes 1.0:
  New PLANONLY option for statements
  Support for PLANONLY setting, allows for a statement/query to be submitted to the engine and
  the plan retrieved, without executing the statement/query.

As it turns out, this refers to SET PLANONLY in isql. You can NOT just add PLANONLY
to SQL statements!-->
    <section id="langrefupd15-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a stored procedure. In Firebird 1.0.x as well as in InterBase, any input parameters for the SP must be supplied as literals, host language variables (in ESQL) or local variables (in PSQL). In Firebird 1.5 and above, input parameters may also be (compound) expressions, except in static ESQL.</para>
      </formalpara>
      <!--Calling SP's with SELECT already allowed compound expressions as parameters in IB and Fb1.-->
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [TRANSACTION <replaceable>transaction</replaceable>]
   [<replaceable>&lt;in_item&gt;</replaceable> [,  <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>  ::=  <replaceable>&lt;param&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable> ::=  <replaceable>&lt;outvar&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;param&gt;</replaceable>    ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>   ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>  ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>
            <note>
              <title>Notes</title>
              <itemizedlist>
                <listitem>
                  <para><database>TRANSACTION</database> clauses are not supported in PSQL.</para>
                </listitem>
                <listitem>
                  <para>Expression parameters are not supported in static ESQL, and not in Firebird versions below 1.5.</para>
                </listitem>
                <listitem>
                  <para><constant>NULL</constant> indicators are only valid in ESQL code. They must be host language variables of type integer.</para>
                </listitem>
                <listitem>
                  <para>In ESQL, variable names used as parameters or outvars must be preceded by a colon (<quote>:</quote>). In PSQL the colon is generally optional, but forbidden for the trigger context variables <database>OLD</database> and <database>NEW</database>.</para>
                  <!--When called with SELECT, the colon must always be present
if the parameter is a variable (except OLD/NEW).-->
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>In PSQL (with optional colons):</para>
            <programlisting>execute procedure MakeFullName
  :FirstName, :Middlename, :LastName
  returning_values :FullName;</programlisting>
            <para>The same call in ESQL (with obligatory colons):</para>
            <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :Middlename, :LastName
    returning_values :FullName;</programlisting>
            <para>...and in Firebird's command-line utility <application>isql (with literal parameters)</application>:</para>
            <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>
            <para><emphasis role="bold">Note:</emphasis> In isql, don't use <database>RETURNING_VALUES</database>. Any output values are shown automatically.</para>
            <para>Finally, a PSQL example with expression parameters, only possible in Firebird 1.5 and up:</para>
            <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, Middlename, upper(LastName)
  returning_values FullName;</programlisting>
          </blockquote></para>
      </formalpara>
      <!--1.5 Release Notes say:

  Dmitry Yemanov
  Calls to EXECUTE PROCEDURE ProcName(<Argument-list>) and SELECT <Output-list> FROM
  ProcName(<Argument-list>) can now accept local variables (in PSQL) and expressions
  (in DSQL and PSQL) as arguments.

However:
- Local variables were already usable as arguments in InterBase.
- With SELECT, even expressions were already allowed as arguments in InterBase.
So the only novelty in Firebird 1.5 is:
- Using expressions as arguments when calling an SP with EXECUTE PROCEDURE.-->
    </section>
    <section id="langrefupd15-release-savepoint">
      <title><database>RELEASE SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Deletes a named savepoint, freeing up all the resources it binds.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Unless <database>ONLY</database> is added, all the savepoints created after the named savepoint are released as well.</para>
      <para>For a full discussion of savepoints, see <link linkend="langrefupd15-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>
    <section id="langrefupd15-rollback-to-savepoint">
      <title><database>ROLLBACK TO SAVEPOINT</database></title>
      <!--Should become a subsection of ROLLBACK ... later?-->
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Undoes everything that happened in a transaction since the creation of the savepoint.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
      <!--Keep this itemizedlist synchronized with the one under SAVEPOINT !-->
      <itemizedlist>
        <listitem>
          <para>All the mutations performed within the transaction since the savepoint was created are undone.</para>
        </listitem>
        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are preserved, as is the savepoint itself. This means that you can rollback to the same savepoint several times.</para>
        </listitem>
        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released. Other transactions that have requested access to rows locked after the savepoint must continue to wait until the transaction is committed or rolled back. Other transactions that have not already requested the rows can request and access the unlocked rows immediately.</para>
        </listitem>
      </itemizedlist>
      <para>For a full discussion of savepoints, see <link linkend="langrefupd15-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>
    <section id="langrefupd15-savepoint">
      <title><database>SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates an SQL-99 compliant savepoint, to which you can later rollback your work without rolling back the entire transaction. Savepoint mechanisms are also known as <quote>nested transactions</quote>.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SAVEPOINT <replaceable>&lt;name&gt;</replaceable>

<replaceable>&lt;name&gt;</replaceable>  ::=  a user-chosen identifier, unique within the transaction</programlisting>
          </blockquote></para>
      </formalpara>
      <para>If the supplied name exists already within the same transaction, the existing savepoint is deleted and a new one is created with the same name.</para>
      <para>If you later want to rollback your work to the point where the savepoint was created, use:</para>
      <blockquote>
        <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
      </blockquote>
      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
      <!--Keep this itemizedlist synchronized with the one under ROLLBACK TO SAVEPOINT !-->
      <itemizedlist>
        <listitem>
          <para>All the mutations performed within the transaction since the savepoint was created are undone.</para>
        </listitem>
        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are preserved, as is the savepoint itself. This means that you can rollback to the same savepoint several times.</para>
        </listitem>
        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released. Other transactions that have requested access to rows locked after the savepoint must continue to wait until the transaction is committed or rolled back. Other transactions that have not already requested the rows can request and access the unlocked rows immediately.</para>
        </listitem>
      </itemizedlist>
      <para>The internal savepoint bookkeeping can consume huge amounts of memory, especially if you update the same records multiple times in one transaction. If you don't need a savepoint anymore but you're not yet ready to end the transaction, you can delete the savepoint and free the resources it uses with:</para>
      <blockquote>
        <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
      </blockquote>
      <para>With <database>ONLY</database>, the named savepoint is the only one that gets released. Without it, all savepoints created after it are released as well.</para>
      <formalpara>
        <title>Example DSQL session using a savepoint</title>
        <para><blockquote>
            <programlisting>create table test (id integer);
commit;
insert into test values (1);
commit;
insert into test values (2);
savepoint y;
delete from test;
select * from test;   -- returns no rows
rollback to y;
select * from test;   -- returns two rows
rollback;
select * from test;   -- returns one row</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd15-savepoint-internal">
        <title>Internal savepoints</title>
        <!--Does this belong here? Is it SQL? The TPB is an API thing, right?-->
        <para>By default, the engine uses an automatic transaction-level system savepoint to perform transaction rollback. When you issue a <database>ROLLBACK</database> statement, all changes performed in this transaction are backed out via a transaction-level savepoint and the transaction is then committed. This logic reduces the amount of garbage collection caused by rolled back transactions.</para>
        <para>When the volume of changes performed under a transaction-level savepoint is getting large (10<superscript>4</superscript>–10<superscript>6</superscript> records affected), the engine releases the transaction-level savepoint and uses the TIP mechanism to roll back the transaction if needed.</para>
        <tip>
          <para>If you expect the volume of changes in your transaction to be large, you can use the TPB flag <function>isc_tpb_no_auto_undo</function> to avoid the transaction-level savepoint being created.</para>
        </tip>
      </section>
      <section id="langrefupd15-savepoint-psql">
        <title>Savepoints and PSQL</title>
        <!--Here again the question whether it belongs here.-->
        <para>Transaction control statements are not allowed in PSQL, as that would break the atomicity of the statement that calls the procedure. But Firebird does support the raising and handling of exceptions in PSQL, so that actions performed in stored procedures and triggers can be selectively undone without the entire procedure failing. Internally, automatic savepoints are used to:</para>
        <itemizedlist>
          <listitem>
            <para>undo all actions in a <database>BEGIN...END</database> block where an uncaught exception occurs;</para>
          </listitem>
          <listitem>
            <para>undo all actions performed by the SP/trigger (or, in the case of a selectable SP, all actions performed since the last <database>SUSPEND</database>) when it terminates prematurely due to an uncaught error or exception.</para>
          </listitem>
        </itemizedlist>
        <para>Each PSQL exception handling block is also bounded by automatic system savepoints.</para>
      </section>
    </section>
    <section id="langrefupd15-select">
      <title><database>SELECT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd15-aggregates">
        <title>Aggregate functions: Extended functionality</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Several types of mixing and nesting aggragate functions are supported since Firebird 1.5. They will be discussed in the following subsections. To get the complete picture, also look at the <database>SELECT</database> :: <database>GROUP BY</database> sections.</para>
        </formalpara>
        <section id="langrefupd15-aggregates-mix">
          <title>Mixing aggregate functions from different contexts</title>
          <para>Firebird 1.5 and up allow the use of aggregate functions from different contexts inside a single expression.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
          <para>This admittedly rather contrived query shows, in the second column, the maximum index selectivity of any index defined on a table, followed by the table's field count between parentheses. Of course you would normally display the field count in a separate column, or in the column with the table name, but the purpose here is to demonstrate that you can combine aggregates from different contexts in a single expression.</para>
          <warning>
            <para>Firebird 1.0 also executes this type of query, but gives the wrong results!</para>
          </warning>
        </section>
        <section id="langrefupd15-aggregates-in-subqueries">
          <title>Aggregate functions and <database>GROUP BY</database> items inside subqueries</title>
          <para>Since Firebird 1.5 it is possible to use aggregate functions and/or expressions contained in the <database>GROUP BY</database> clause inside a subquery.</para>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>This query returns each table's ID and field count. The subquery refers to <literal><systemitem>flds.rdb$relation_name</systemitem></literal>, which is also a <database>GROUP BY</database> item:</para>
                <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>
                <para>The next query shows the last field from each table and and its 1-based position. It uses the aggregate function <database>MAX</database> in a subquery.</para>
                <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>
                <para>The subquery also contains the <database>GROUP BY</database> item <systemitem>flds.rdb$relation_name</systemitem>, but that's not immediately obvious because in this case the <database>GROUP BY</database> clause uses the column number.</para>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd15-subqueries-in-aggregates">
          <title>Subqueries inside aggregate functions</title>
          <para>Using a singleton subselect inside (or as) an aggregate function argument is supported in Firebird 1.5 and up.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>
                <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd15-aggregates-nesting">
          <title>Nesting aggregate function calls</title>
          <para>Firebird 1.5 allows the indirect nesting of aggregate functions, provided that the inner function is from a lower SQL context. Direct nesting of aggregate function calls, as in <quote><database>COUNT</database>( <database>MAX</database>( price ) )</quote>, is still forbidden and punishable by exception.</para>
          <formalpara>
            <title>Example</title>
            <para>See under <link linkend="langrefupd15-subqueries-in-aggregates"><citetitle>Subqueries inside aggregate functions</citetitle></link>, where <database>COUNT()</database> is used inside a <database>SUM()</database>.</para>
          </formalpara>
          <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
        </section>
        <section id="langrefupd15-aggregates-having-orderby">
          <title>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER BY</database></title>
          <para>Firebird 1.5 and above are stricter than previous versions about what can be included in the <database>HAVING</database> and <database>ORDER BY</database> clauses. If, in the context of an aggregate statement, an operand in a <database>HAVING</database> or <database>ORDER BY</database> item contains a column name, it is only accepted if one of the following is true:</para>
          <itemizedlist>
            <listitem>
              <para>The column name appears in an aggregate function call (e.g. <quote><code>HAVING MAX(SALARY) &gt; 10000</code></quote>).</para>
            </listitem>
            <listitem>
              <para>The operand equals or is built around a non-aggregate column that appears in the <database>GROUP BY</database> list (by name or position).</para>
            </listitem>
            <listitem>
              <para>The operand equals or is built around a subquery, whether or not it is also a <database>GROUP BY</database> item.</para>
              <!--Probably an error, just like the fact that non-aggregate subqueries need not be included
in the GROUP BY list. Asked Arno, also about "invalid expressions" that were prev. allowed.
Waiting for answer.-->
            </listitem>
          </itemizedlist>
          <para><quote>Is built around</quote> means that the operand need not be exactly the same as the column or subquery. Suppose there's a non-aggregate column <quote><database>STR</database></quote> in the select list. Then it's OK to use expressions like <quote><database>UPPER(STR)</database></quote>, <quote><database>STR || '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4 FOR 2)</database></quote> in the <database>HAVING</database> clause – even if these expressions don't appear in the <database>SELECT</database> or <database>GROUP BY</database> list.</para>
        </section>
      </section>
      <!--Mr. Laurel also says:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->
      <section id="langrefupd15-amb-join">
        <title>Ambiguous <database>JOIN</database> statements rejected</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>InterBase 6 accepts and executes statements like the one below, which refers to an unqualified column name even though that name exists in both tables participating in the <database>JOIN</database>:</para>
        </formalpara>
        <blockquote>
          <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
        </blockquote>
        <para>The results of such a query are unpredictable. Firebird Dialect 3 returns an error if there are ambiguous field names in <database>JOIN</database> statements. Dialect 1 gives a warning but will execute the query anyway.</para>
      </section>
      <section id="langrefupd15-first-skip">
        <title><database>FIRST</database> and <database>SKIP</database></title>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>FIRST</database> enables the user to limit the output of a query to the first so-many rows. <database>SKIP</database> will suppress the given number of rows before starting to return output.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>
              <note>
                <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an integer literal or a query parameter, the <quote><literal>()</literal></quote> may be omitted. Subselects on the other hand require an extra pair of parentheses.</para>
              </note>
            </blockquote></para>
        </formalpara>
        <para><database>FIRST</database> and <database>SKIP</database> are both optional. When used together as in <quote><database>FIRST</database> <replaceable>m</replaceable> <database>SKIP</database> <replaceable>n</replaceable></quote>, the <replaceable>n</replaceable> topmost rows of the output set are discarded and the first <replaceable>m</replaceable> rows of the remainder are returned.</para>
        <para><database>SKIP</database> 0 is allowed, but of course rather pointless. <database>FIRST</database> 0 is allowed in version 1.5 and up, where it returns an empty set. In 1.0.x, <database>FIRST</database> 0 causes an error. Negative <database>SKIP</database> and/or <database>FIRST</database> values always result in an error.</para>
        <para>If a <database>SKIP</database> lands past the end of the dataset, an empty set is returned. If the number of rows in the dataset (or the remainder after a <database>SKIP</database>) is less than the value given after <database>FIRST</database>, that smaller number of rows is returned. These are valid results, not error situations.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The following query will return the first 10 names from the People table:</para>
              <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
              <para>The following query will return everything <emphasis>but</emphasis> the first 10 names:</para>
              <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
              <para>And this one returns the last 10 rows. Notice the double parentheses:</para>
              <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
              <para>This query returns rows 81–100 of the People table:</para>
              <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
            </blockquote></para>
        </formalpara>
        <caution>
          <title>Two Gotchas with <database>FIRST</database> in subselects</title>
          <itemizedlist>
            <listitem>
              <para>This:</para>
              <blockquote>
                <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
              </blockquote>
              <para>will delete all of the rows in the table. Ouch! The sub-select is evaluating each 10 candidate rows for deletion, deleting them, slipping forward 10 more... ad infinitum, until there are no rows left. Beware!</para>
            </listitem>
            <listitem>
              <para>Queries like:</para>
              <blockquote>
                <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
              </blockquote>
              <para>won't work as expected, because the optimization performed by the engine transforms the <database>IN</database> predicate to the correlated <database>EXISTS</database> predicate shown below. It's obvious that in this case <database>FIRST</database> <replaceable>N</replaceable> doesn't make any sense:</para>
              <blockquote>
                <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
              </blockquote>
            </listitem>
          </itemizedlist>
        </caution>
      </section>
      <section id="langrefupd15-group-by-udf">
        <title><database>GROUP BY</database> <database><replaceable>UDF</replaceable></database></title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird, you can use the output of a user-defined function as a <database>GROUP BY</database> item.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>      ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>] | <replaceable>&lt;udf-call&gt;</replaceable>
<replaceable>&lt;udf-call&gt;</replaceable>  ::=  <replaceable>udf-name</replaceable>(<replaceable>arg1</replaceable> [, <replaceable>argN</replaceable> ...])</programlisting>
            </blockquote></para>
        </formalpara>
        <para><database>UDF</database> calls may be nested, but – as follows from the syntax – you cannot mix <database>UDF</database> calls and <database>COLLATE</database> in a single <database>GROUP BY</database> item.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select strlen(lastname), count(*)
  from people
  group by strlen(lastname)
  order by 2 desc</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para><database>DSQL</database> currently lacks a mechanism to check if <database>GROUP BY <replaceable>UDF</replaceable></database> subclauses are formulated correctly. Always make sure that your <database>GROUP BY</database> item list correctly represents the <emphasis>scalar</emphasis> (i.e. non-aggregate) expression(s) in your <database>SELECT</database> list.</para>
        </warning>
      </section>
      <section id="langrefupd15-group-by-extensions">
        <title><database>GROUP BY</database> internal function, column position, and <database>CASE</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 1.5 adds the following to the list of valid <database>GROUP BY</database> items:<itemizedlist spacing="compact">
              <listitem>
                <para>1-based column position numbers (like in <database>ORDER BY</database>);</para>
              </listitem>
              <listitem>
                <para>The internal functions <database>COALESCE</database>, <database>EXTRACT</database>, <database>NULLIF</database>, <database>SUBSTRING</database> and <database>UPPER</database>;</para>
              </listitem>
              <listitem>
                <para><database>CASE</database> constructs.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>           ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
                      | <replaceable>column-position</replaceable>
                      | <replaceable>&lt;function-call&gt;</replaceable>
                      | <replaceable>CASE-construct</replaceable>

<replaceable>&lt;function-call&gt;</replaceable>  ::=  COALESCE(<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable> [, <replaceable>argN</replaceable> ...])
                      | EXTRACT(<replaceable>part</replaceable> FROM <replaceable>date/time</replaceable>)
                      | NULLIF(<replaceable>arg1</replaceable>, <replaceable>arg2</replaceable>)
                      | SUBSTRING(<replaceable>str</replaceable> FROM <replaceable>pos</replaceable> [FOR <replaceable>count</replaceable>])
                      | UPPER(<replaceable>str</replaceable>)
                      | <replaceable>udf-name</replaceable>(<replaceable>arg1</replaceable> [, <replaceable>argN</replaceable> ...])</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Function calls may be nested. As in previous versions, <database>COLLATE</database> can only be used with column names.</para>
        <para>If you group by a column position, the expression at that position is copied internally from the select list. If it concerns a subquery, that subquery will be executed at least twice.</para>
        <important>
          <itemizedlist>
            <listitem>
              <para>A <database>GROUP BY</database> item cannot be a reference to an aggregate function (including those that are buried inside an expression) from the same context.</para>
            </listitem>
            <listitem>
              <para>As before, every non-aggregate column <emphasis role="bold">must</emphasis> appear in the <database>GROUP BY</database> list, whether explicitly or by position.</para>
              <!--Except subqueries, but that's probably an error.-->
            </listitem>
          </itemizedlist>
        </important>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>select
  case when price is null then 0 else price end,
  sum(number_sold)
from sales_per_article
group by
  case when price is null then 0 else price end</programlisting>
              <para>Of course this example is only to demonstrate the use of a <database>CASE</database> construct in the <database>GROUP BY</database> clause. In this particular case you should first use <database>COALESCE</database>:</para>
              <programlisting>select
  coalesce (price, 0),
  sum(number_sold)
from sales_per_article
group by
  coalesce (price, 0)</programlisting>
              <para>and second, you could save yourself some typing by using the column number:</para>
              <programlisting>select
  coalesce (price, 0),
  sum(number_sold)
from sales_per_article
group by 1</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-having-stricter">
        <title><database>HAVING</database>: Stricter rules</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>See <link linkend="langrefupd15-aggregates-having-orderby"><citetitle>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-orderby">
        <title><database>ORDER BY</database>: Expressions and <constant>NULL</constant>s placement</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In addition to column names and positions, the <database>ORDER BY</database> clause can now also contain expressions to sort the output by. Furthermore, per-column <database>NULLS FIRST</database> and <database>NULLS LAST</database> subclauses can be used to specify where <constant>NULL</constant>s appear in the sorted column.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>column-name</replaceable> | <replaceable>column-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Expressions consisting of a single non-negative number will be interpreted as 1-based column numbers and will cause an exception if they're not in the range from 1 to the number of columns.</para>
        <para>By default, <constant>NULL</constant>s will be placed at the end of the sort, regardless whether the order is ascending or descending. This is the same behaviour as in previous Firebird versions. No index will be used on columns for which the non-default <database>NULLS FIRST</database> placement is chosen.</para>
        <para>The number of function or procedure invocations resulting from a sort based on a UDF or stored procedure is unpredictable, regardless whether the ordering is specified by the expression itself or by the column position number.</para>
        <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->
        <!--Rlsnotes 1.5 say:

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice?-->
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>
              <programlisting>select first 10 * from document
  order by strlen(description) desc      </programlisting>
              <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-orderby-stricter">
        <title><database>ORDER BY</database>: Stricter rules with aggregate statements</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>See <link linkend="langrefupd15-aggregates-having-orderby"><citetitle>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd15-with-lock">
        <title><database>WITH LOCK</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description:</title>
          <para><database>WITH LOCK</database> provides a limited explicit pessimistic locking capability for cautious use in conditions where the affected row set is:<orderedlist numeration="loweralpha" spacing="compact">
              <listitem>
                <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
              </listitem>
              <listitem>
                <para>precisely controlled by the application code.</para>
              </listitem>
            </orderedlist></para>
        </formalpara>
        <caution>
          <title>This is for experts only!</title>
          <para>The need for a pessimistic lock in Firebird is very rare indeed and should be well understood before use of this extension is considered.</para>
          <para>It is essential to understand the effects of transaction isolation and other transaction attributes before attempting to implement explicit locking in your application.</para>
        </caution>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the selected rows and prevent any other transaction from obtaining write access to any of those rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to each row, one by one, as it is fetched into the server-side row cache. It becomes possible, then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by another transaction.</para>
        <para><database>WITH LOCK</database> can only be used with a top-level, single-table <database>SELECT</database> statement. It is <emphasis>not</emphasis> available:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>in a subquery specification;</para>
          </listitem>
          <listitem>
            <para>for joined sets;</para>
          </listitem>
          <listitem>
            <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database> clause or any other aggregating operation;</para>
          </listitem>
          <listitem>
            <para>with a view;</para>
          </listitem>
          <listitem>
            <para>with the output of a selectable stored procedure;</para>
          </listitem>
          <listitem>
            <para>with an external table.</para>
          </listitem>
        </itemizedlist>
        <para>A lengthier, more in-depth discussion of <quote><database>SELECT ... WITH LOCK</database></quote> is included in the <link linkend="langrefupd15-notes-withlock">Notes</link>. It is a must-read for everybody who considers using this feature.</para>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd15-psql">
    <title>PSQL statements</title>
    <para>PSQL – Procedural SQL – is the Firebird stored procedure and trigger language.</para>
    <section id="langrefupd15-psql-begin-end">
      <title><database>BEGIN ... END</database> blocks may be empty</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up, allowing you to write stub code without having to resort to dummy statements.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-break">
      <title><database>BREAK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Deprecated in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BREAK</database> immediately terminates a <database>WHILE</database> or <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure selphrase(num int)
returns (phrase varchar(40))
as
begin
  for select Phr from Phrases into phrase do
  begin
    if (num &lt; 1) then <emphasis role="bold">break;</emphasis>
    suspend;
    num = num - 1;
  end
  phrase = '***  Ready!  ***';
  suspend;
end</programlisting>
            <para>This selectable SP returns at most <replaceable>num</replaceable> rows from the table Phrases. The variable <replaceable>num</replaceable> is decremented in each iteration; once it is smaller than 1, the loop is terminated with <database>BREAK</database>. The program then continues at the line <quote><literal>phrase = '*** Ready! ***';</literal></quote>.</para>
          </blockquote></para>
      </formalpara>
      <important>
        <para>Since Firebird 1.5, <database>BREAK</database> is deprecated in favor of its SQL-99 compliant synonym <link linkend="langrefupd15-psql-leave"><citetitle><database>LEAVE</database></citetitle></link>.</para>
      </important>
      <!--TESTED:
Contrary to what Fb 1.5 rlsnotes suggest, BREAK works in SPs *and* triggers as from 1.0.
In IB6 it doesn't exist.-->
    </section>
    <section id="langrefupd15-psql-declare">
      <title><database>DECLARE [VARIABLE]</database> with initialization</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and above, a PSQL local variable can be initialized upon declaration. The <database>VARIABLE</database> keyword has become optional.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>];</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure proccie (a int)
returns (b int)
as
declare p int;
declare q int = 8;
declare r int default 9;
declare variable s int;
declare variable t int = 10;
declare variable u int default 11;
begin
  <replaceable>&lt;intelligent code here&gt;</replaceable>
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-exception">
      <title><database>EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>EXCEPTION</database> syntax has been extended so that the user can<orderedlist numeration="loweralpha" spacing="compact">
            <listitem>
              <para>Rethrow a caught exception or error.</para>
            </listitem>
            <listitem>
              <para>Provide a custom message when throwing a user-defined exception.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXCEPTION [<replaceable>&lt;exception-name&gt;</replaceable> [<replaceable>custom-message</replaceable>]]

<replaceable>&lt;exception-name&gt;</replaceable>  ::=  A previously defined exception name</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd15-psql-exception-rethrow">
        <title>Rethrowing a caught exception</title>
        <para>Within the exception handling block only, you can rethrow the caught exception or error by giving the <database>EXCEPTION</database> command without any arguments. Outside such blocks, this <quote>bare</quote> command has no effect.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>when any do
begin
  insert into error_log (...) values (sqlcode, ...);
  exception;
end</programlisting>
              <para>This example first logs some information about the exception or error, and then rethrows it.</para>
              <!--So it also works with SQL en GDS errors? Answered by Dmitry: YES.-->
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-psql-exception-custom-msg">
        <title>Providing a custom error message</title>
        <para>Firebird 1.5 and up allow you to override an exception's default error message by supplying an alternative one when throwing the exception.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>exception ex_data_error 'You just lost some valuable data';</programlisting>
              <programlisting>exception ex_bad_type 'Wrong type for record with id ' || new.id;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd15-psql-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and above, (compound) expressions are allowed as input parameters for stored procedures called with <database>EXECUTE PROCEDURE</database>. See <link linkend="langrefupd15-execproc"><citetitle>DML statements :: <database>EXECUTE PROCEDURE</database></citetitle></link> for full info and examples.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-execstat">
      <title><database>EXECUTE STATEMENT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>EXECUTE STATEMENT</database> takes a single string argument and executes it as if it had been submitted as a DSQL statement. The exact syntax depends on the number of data rows that the supplied statement may return.</para>
      </formalpara>
      <section id="langrefupd15-psql-execstat-nooutput">
        <title>No data returned</title>
        <para>This form is used with <database>INSERT</database>, <database>UPDATE</database>, <database>DELETE</database> and <database>EXECUTE PROCEDURE</database> statements that return no data.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;statement&gt;</replaceable>

<replaceable>&lt;statement&gt;</replaceable>  ::=  An SQL statement returning no data.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleOne (ProcName varchar(100))
as
declare variable stmt varchar(1024);
declare variable param int;
begin
   select min(SomeField) from SomeTable into param;
   stmt = 'execute procedure ' 
          || ProcName 
          || '(' 
          || cast(param as varchar(20)) 
          || ')';
   execute statement stmt;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>Although this form of <database>EXECUTE STATEMENT</database> can also be used with all kinds of DDL strings (except <database>CREATE/DROP DATABASE</database>), it is generally very, very unwise to use this trick in order to circumvent the no-DDL rule in PSQL.</para>
        </warning>
      </section>
      <section id="langrefupd15-psql-execstat-singleton">
        <title>One row of data returned</title>
        <para>This form is used with singleton <database>SELECT</database> statements.</para>
        <!--EXECUTE PROCEDURE with RETURNING_VALUES is NOT possible in EXECUTE STATEMENT
(Token unknown - line 1, char 25 returning_values). Why?-->
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  An SQL statement returning at most one row of data.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleTwo (TableName varchar(100))
as
declare variable param int;
begin
  execute statement
    'select max(CheckField) from ' || TableName into :param;
  if (param &gt; 100) then
    exception Ex_Overflow 'Overflow in ' || TableName;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-psql-execstat-multirow">
        <title>Any number of data rows returned</title>
        <para>This form – analogous to <quote><database>FOR SELECT ... DO</database></quote> – is used with <database>SELECT</database> statements that may return a multi-row dataset.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>FOR EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   DO <replaceable>&lt;compound-statement&gt;</replaceable>

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  Any SELECT statement.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleThree 
  ( TextField varchar(100),
    TableName varchar(100) )
returns 
  ( LongLine varchar(32000) )
as
declare variable Chunk varchar(100);
begin
  Chunk = '';
  for execute statement
    'select ' || TextField || ' from ' || TableName into :Chunk
  do
    if (Chunk is not null) then
      LongLine = LongLine || Chunk || ' ';
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd15-psql-execstat-caveats">
        <title>Caveats with <database>EXECUTE STATEMENT</database></title>
        <orderedlist>
          <listitem>
            <para>There is no way to validate the syntax of the enclosed statement.</para>
          </listitem>
          <listitem>
            <para>There are no dependency checks to discover whether tables or columns have been dropped.</para>
          </listitem>
          <listitem>
            <para>Operations will be slow because the embedded statement has to be prepared every time it is executed.</para>
          </listitem>
          <listitem>
            <para>The argument string cannot contain any parameters. All variable substitution into the static part of the SQL statement should be performed before <database>EXECUTE STATEMENT</database> is called.</para>
          </listitem>
          <listitem>
            <para>Return values are strictly checked for data type in order to avoid unpredictable type-casting exceptions. For example, the string <literal>'1234'</literal> would convert to an integer, 1234, but <literal>'abc'</literal> would give a conversion error.</para>
          </listitem>
          <listitem>
            <para>If the stored procedure has special privileges on some objects, the dynamic statement submitted in the <database>EXECUTE STATEMENT</database> string does not inherit them. Privileges are restricted to those granted to the user who is executing the procedure.</para>
          </listitem>
        </orderedlist>
        <para>All in all, this feature is intended only for very cautious use and you should always take the above factors into account. Bottom line: use <database>EXECUTE STATEMENT</database> only when other methods are impossible, or perform even worse than <database>EXECUTE STATEMENT</database>.</para>
      </section>
    </section>
    <section id="langrefupd15-psql-exit">
      <title><database>EXIT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <database>EXIT</database> can be used in all PSQL. In earlier versions it is only supported in stored procedures, not in triggers.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-forexecstatdo">
      <title><database>FOR EXECUTE STATEMENT ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>See <link linkend="langrefupd15-psql-execstat-multirow"><citetitle><database>EXECUTE STATEMENT</database> :: Any number of data rows returned</citetitle></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-leave">
      <title><database>LEAVE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>LEAVE</database> immediately terminates a <database>WHILE</database> or <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>while (b &lt; 10) do
begin
  insert into Numbers(B) values (:b);
  b = b + 1;
  when any do
  begin
    execute procedure log_error (current_timestamp, 'Error in B loop');
    <emphasis role="bold">leave;</emphasis>
  end
end
c = 0;
while (c &lt; 10) do
begin
  ...
  ...
end</programlisting>
            <para>If an error occurs during the insert, the event is logged and the loop terminated. The program continues at the line of code reading <quote><literal>c = 0;</literal></quote></para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-psql-plan">
      <title><database>PLAN</database> allowed in trigger code</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would be rejected by the compiler. Now a valid plan can be included and will be used.</para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-variables">
    <title>Context variables</title>
    <section id="langrefupd15-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_CONNECTION</varname> contains the system identifier of the active connection context.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page and reset upon restore. Since the engine itself is not interested in this value, it is only incremented if the client reads it during a session. Hence it is only useful as a unique identifier, not as an indicator of the number of connections since the creation or last restoration of the database.</para>
      <!--Starting with Fb 2.1, the value is incremented with every connection.-->
    </section>
    <section id="langrefupd15-current_role">
      <title><varname>CURRENT_ROLE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><varname>CURRENT_ROLE</varname> always represents a valid role or <database>NONE</database>. If a user connects with a non-existing role, the engine silently resets it to <database>NONE</database> without returning an error.</para>
    </section>
    <section id="langrefupd15-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TRANSACTION</varname> contains the system identifier of the current transaction context.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header page and reset upon restore. Unlike <varname>CURRENT_CONNECTION</varname>, it is incremented with every new transaction, whether the client reads the value or not.</para>
    </section>
    <section id="langrefupd15-current_user">
      <title><varname>CURRENT_USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the currently connected user. It is fully equivalent to <database>USER</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-deleting">
      <title><varname>DELETING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired because of a <database>DELETE</database> operation. Intended for use in <link linkend="langrefupd15-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-gdscode">
      <title><varname>GDSCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <database>WHEN GDSCODE</database> handling block, the <varname>GDSCODE</varname> context variable contains a numerical representation of the current Firebird error code. It is 0 in <database>WHEN SQLCODE</database>, <database>WHEN EXCEPTION</database> and <database>WHEN ANY</database> handlers, as well as everywhere else in PSQL.</para>
        <!--In 2.0, GDSCODE is also non-zero in WHEN ANY (provided a GDS error occurred)-->
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when gdscode 335544551, gdscode 335544552,
     gdscode 335544553, gdscode 335544707
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-inserting">
      <title><varname>INSERTING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger fired because of an <database>INSERT</database> operation. Intended for use in <link linkend="langrefupd15-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-row_count">
      <title><varname>ROW_COUNT</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>ROW_COUNT</varname> is a context variable containing the number of rows affected by the last DML statement.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>For <database>SELECT</database> statements, <varname>ROW_COUNT</varname> currently returns 0.</para>
          </listitem>
          <listitem>
            <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows affected by an <database>EXECUTE STATEMENT</database> command.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-sqlcode">
      <title><varname>SQLCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <database>WHEN SQLCODE</database> handling block, the <varname>SQLCODE</varname> context variable contains the current SQL error code. In a <database>WHEN ANY</database> block it contains the SQL error code if indeed an SQL error occurred; otherwise it contains 0. <varname>SQLCODE</varname> is also 0 in <database>WHEN GDSCODE</database> and <database>WHEN EXCEPTION</database> handlers, as well as everywhere else in PSQL.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-updating">
      <title><varname>UPDATING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired because of an <database>UPDATE</database> operation. Intended for use in <link linkend="langrefupd15-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-functions">
    <title>Internal functions</title>
    <!--Aren't internal functions always available? If so, drop the "Available in" blockies or fill in
"everywhere".-->
    <section id="langrefupd15-coalesce">
      <title><database>COALESCE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>COALESCE</database> function takes two or more arguments and returns the value of the first non-<constant>NULL</constant> argument. If all the arguments evaluate to <constant>NULL</constant>, <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select 
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
  as FullName
from Persons</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This example picks the Nickname from the Persons table. If it happens to be <constant>NULL</constant>, it goes on to FirstName. If that too is <constant>NULL</constant>, <quote>Mr./Mrs.</quote> is used. Finally, it adds the family name. All in all, it tries to use the available data to compose a full name that is as informal as possible. Notice that this scheme only works if absent nicknames and first names are really <constant>NULL</constant>: if one of them is an empty string instead, <database>COALESCE</database> will happily return that to the caller.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>COALESCE</database> is not available, you can accomplish the same with the <link linkend="langrefupd15-udf-nvl"><function>*nvl</function></link> external functions.</para>
      </note>
    </section>
    <section id="langrefupd15-extract">
      <title><database>EXTRACT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB 6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Extracts and returns an element from a <database>DATE</database>, <database>TIME</database> or <database>TIMESTAMP</database> expression. It was already added in InterBase 6, but not documented in the <citetitle>Language Reference</citetitle> at the time.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>SMALLINT</database> or <database>DECIMAL(6,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | DAY | WEEKDAY | YEARDAY
                   | HOUR | MINUTE | SECOND
<replaceable>&lt;datetime&gt;</replaceable>  ::=  An expression of type DATE, TIME or TIMESTAMP</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The returned datatype is <database>DECIMAL(6,4)</database> for the <database>SECOND</database> part and <database>SMALLINT</database> for all others. The ranges are shown in the table below.</para>
      <para>If you try to extract a part that isn't present in the date/time argument (e.g. <database>SECOND</database> from a <database>DATE</database> or <database>YEAR</database> from a <database>TIME</database>), an error occurs.</para>
      <table id="langrefupd15-tbl-extractranges">
        <title>Ranges for <database>EXTRACT</database> results</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Part</entry>
              <entry>Range</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><database>YEAR</database></entry>
              <entry>1–9999</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MONTH</database></entry>
              <entry>1–12</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>DAY</database></entry>
              <entry>1–31</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>WEEKDAY</database></entry>
              <entry>0–6</entry>
              <entry>0 = Sunday</entry>
            </row>
            <row>
              <entry><database>YEARDAY</database></entry>
              <entry>0–365</entry>
              <entry>0 = January 1</entry>
            </row>
            <row>
              <entry><database>HOUR</database></entry>
              <entry>0–23</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MINUTE</database></entry>
              <entry>0–59</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>SECOND</database></entry>
              <entry>0.0000–59.999</entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!--Tested: year in a DATE (when casting from dd.mm.yyyy string) can be 0-9999 in Fb1.5;
0 and 10000 give errors.
IB 6.5 doc specifies 0-5400 here
Oddly enough, DatDef sez DATE and TIMESTAMP can range from 1 Jan 100 a.d. to 29 Feb 32768 a.d.-->
    </section>
    <section id="langrefupd15-nullif">
      <title><database>NULLIF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>NULLIF</database> returns the value of the first argument, unless it is equal to the second. In that case, <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This will return the average weight of the persons listed in FatPeople, excluding those having a weight of -1, since <database>AVG</database> skips <constant>NULL</constant> data. Presumably, -1 indicates <quote>weight unknown</quote> in this table. A plain <database>AVG</database>(Weight) would include the -1 weights, thus skewing the result.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>NULLIF</database> is not available, you can accomplish the same with the <link linkend="langrefupd15-udf-nullif"><function>*nullif</function></link> external functions.</para>
      </note>
    </section>
    <section id="langrefupd15-substring">
      <title><database>SUBSTRING()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring starting at the given position, either to the end of the string or with a given length.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SUBSTRING(<replaceable>&lt;str&gt;</replaceable> FROM <replaceable>startpos</replaceable> [FOR <replaceable>length</replaceable>])

&lt;str&gt; := any expression evaluating to a string
<replaceable>startpos</replaceable> and <replaceable>length</replaceable> must be integer literals</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>SUBSTRING</database> returns the stream of bytes starting at byte position <replaceable>startpos</replaceable> (the first byte position being 1). Without the <database>FOR</database> argument, it returns all the remaining bytes in the string. With <database>FOR</database>, it returns <replaceable>length</replaceable> bytes or the remainder of the string, whichever is shorter.</para>
      <para><database>SUBSTRING</database> can be used with:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>Any string or (var)char argument, regardless of its character set;</para>
        </listitem>
        <listitem>
          <para>Subtype 0 (binary) <database>BLOB</database>s;</para>
        </listitem>
        <listitem>
          <para>Subtype 1 (text) <database>BLOB</database>s, if the character set has 1 byte per character.</para>
        </listitem>
      </itemizedlist>
      <para><database>SUBSTRING</database> can <emphasis>not</emphasis> be used with text <database>BLOB</database>s that have an underlying multi-byte character set.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd15-udf">
    <title>External functions (UDFs)</title>
    <para>External functions must be <quote>declared</quote> (made known) to the database before they can be used. Firebird ships with two external function libraries:</para>
    <itemizedlist>
      <listitem>
        <para><systemitem class="library">ib_udf</systemitem> – inherited from InterBase;</para>
      </listitem>
      <listitem>
        <para><systemitem class="library">fbudf</systemitem> – a new library using <link linkend="langrefupd15-declareext-bydescriptor">descriptors</link>, present as from Firebird 1.0 (Windows) and 1.5 (Linux).</para>
      </listitem>
    </itemizedlist>
    <para>Users can also create their own UDF libraries or acquire them from third parties.</para>
    <!--Wherever appropriate I used 32767 as a max string length, not 32765 (max. VARCHAR-length).
This is about what the function itself and the Firebird engine can handle when you call it
from your SQL, *not* about whether the result subsequently fits in a VARCHAR.-->
    <section id="langrefupd15-udf-addday">
      <title><function>addDay</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> days added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addday (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addDay
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addDay' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addhour">
      <title><function>addHour</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> hours added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addhour (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addHour
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addHour' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addmillisecond">
      <title><function>addMilliSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> milliseconds added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmillisecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMilliSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addminute">
      <title><function>addMinute</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> minutes added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addminute (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMinute
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addmonth">
      <title><function>addMonth</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> months added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmonth (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMonth
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addsecond">
      <title><function>addSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> seconds added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addsecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addweek">
      <title><function>addWeek</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> weeks added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addweek (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addWeek
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-addyear">
      <title><function>addYear</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> years added. Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addyear (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addYear
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addYear' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-ascii_char">
      <title><function>ascii_char</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII character corresponding to the integer value passed in.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(1)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ascii_char (<parameter>intval</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration (changed)</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ascii_char
   INTEGER
   RETURNS CSTRING(1) FREE_IT
   ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf'</programlisting>
            <para>The declaration has been changed to reflect the fact that the UDF as such returns a 1-character C string, not an SQL <database>CHAR(1)</database> as stated in the InterBase declaration. The engine will pass it on to the caller as a <database>CHAR(1)</database> though.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-dow">
      <title><function>dow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the day of the week from a timestamp argument. The returned name may be localized.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>VARCHAR(15)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dow
   TIMESTAMP,
   VARCHAR(15) RETURNS PARAMETER 2
   ENTRY_POINT 'DOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd15-udf-sdow"><function>sdow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-dpower">
      <title><function>dpower</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th power.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dpower (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dPower
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR,
   DOUBLE PRECISION BY DESCRIPTOR
   RETURNS PARAMETER 3
   ENTRY_POINT 'power' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-getexacttimestamp">
      <title><function>getExactTimestamp</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the system time with milliseconds precision. This function was added because <database>CURRENT_TIMESTAMP</database> always has <literal>.0000</literal> in the fractional part of the second.</para>
        <!--This changes in 2.0 or afterwards-->
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>getexacttimestamp()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION getExactTimestamp
   TIMESTAMP RETURNS PARAMETER 1
   ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-i64round">
      <title><function>i64round</function></title>
      <para>See <link linkend="langrefupd15-udf-round"><function>round</function></link>.</para>
    </section>
    <section id="langrefupd15-udf-i64truncate">
      <title><function>i64truncate</function></title>
      <para>See <link linkend="langrefupd15-udf-truncate"><function>truncate</function></link>.</para>
    </section>
    <section id="langrefupd15-udf-log">
      <title><function>log</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <function>log</function> returns the the base-<parameter>x</parameter> logarithm of <parameter>y</parameter>. In Firebird 1.0.x and InterBase, it erroneously returns the base-<parameter>y</parameter> logarithm of <parameter>x</parameter>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>log (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration (unchanged)</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION log
   DOUBLE PRECISION, DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>If any of your pre-1.5 databases uses <function>log</function>, check your PSQL and application code. It may contain workarounds to return the right results. Under Firebird 1.5 and up, any such workarounds should be removed or you'll get the wrong results.</para>
      </warning>
    </section>
    <section id="langrefupd15-udf-lpad">
      <title><function>lpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string left-padded with <parameter>padchar</parameter>s until <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>lpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this function can accept and return strings of up to 32767 characters.</para>
          </listitem>
          <listitem>
            <para>When calling this function, make sure <parameter>endlength</parameter> does not exceed the declared result length.</para>
          </listitem>
        </itemizedlist>
      </note>
      <!--OBSERVATION (with 1.5.3):
If endlength < strlen(input), the input string is truncated to endlength by cutting off
characters on the right side (end of the string)-->
    </section>
    <section id="langrefupd15-udf-ltrim">
      <title><function>ltrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any leading space characters removed. In Firebird 1.0.x, this function returns <constant>NULL</constant> if the input string is empty or <constant>NULL</constant>. In 1.5 and above it returns <literal>''</literal> (an empty string) in these cases.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ltrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ltrim
   CSTRING(255)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-udf-nullif">
      <title><function>*nullif</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Deprecated in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>*nullif</function> functions – for integers, bigints, doubles and strings, respectively – each return the first argument if it is not equal to the second. If the arguments are equal, the functions return <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>inullif   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nullif (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnullif   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snullif   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5 these functions are all deprecated. Use the new internal function <link linkend="langrefupd15-nullif"><database>NULLIF</database></link> instead.</para>
      <warning>
        <title>Warnings</title>
        <itemizedlist>
          <listitem>
            <para>These functions return <constant>NULL</constant> when the second argument is <constant>NULL</constant>, even if the first argument is a proper value. This is a wrong result. The <database>NULLIF</database> internal function doesn't have this bug.</para>
          </listitem>
          <listitem>
            <para><function>i64nullif</function> and <function>dnullif</function> will return wrong and/or bizarre results if it is not 100% clear to the engine that each argument is of the intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE PRECISION</database>). If in doubt, cast them both explicitly to the declared type (see declarations below).</para>
          </listitem>
        </itemizedlist>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION inullif
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nullif
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS NUMERIC(18,4) BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <programlisting>DECLARE EXTERNAL FUNCTION dnullif
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snullif
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-nvl">
      <title><function>*nvl</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Deprecated in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>nvl</function> functions – for integers, bigints, doubles and strings, respectively – are <constant>NULL</constant> replacers. They each return the first argument's value if it is not <constant>NULL</constant>. If the first argument is <constant>NULL</constant>, the value of the second argument is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>invl   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nvl (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnvl   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snvl   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5 these functions are all deprecated. Use the new internal function <link linkend="langrefupd15-coalesce"><database>COALESCE</database></link> instead.</para>
      <warning>
        <para><function>i64nvl</function> and <function>dnvl</function> will return wrong and/or bizarre results if it is not absolutely clear to the engine that each argument is of the intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE PRECISION</database>). If in doubt, cast both arguments explicitly to the declared type (see declarations below).</para>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION invl
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nvl
   NUMERIC(18,0) BY DESCRIPTOR, NUMERIC(18,0) BY DESCRIPTOR
   RETURNS NUMERIC(18,0) BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION dnvl
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snvl
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-right">
      <title><function>right</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the rightmost <replaceable>numchars</replaceable> characters of the input string.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>VARCHAR(100)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>right (<parameter>str</parameter>, <parameter>numchars</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION right
   VARCHAR(100) BY DESCRIPTOR, SMALLINT,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'right' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-round">
      <title><function>round</function>, <function>i64round</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole number that is nearest to their (scaled numeric/decimal) argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>round    (<parameter>number</parameter>)
i64round (<parameter>big</parameter>number)</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <title>Bug warning</title>
        <para>These functions are <emphasis>broken</emphasis> for negative numbers:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>Anything between 0 and -0.6 (that's right: -0.6, not -0.5) is rounded to 0.</para>
          </listitem>
          <listitem>
            <para>Anything between -0.6 and -1 is rounded to +1 (<emphasis>plus</emphasis> 1).</para>
          </listitem>
          <listitem>
            <para>Anything between -1 and -1.6 is rounded to -1.</para>
          </listitem>
          <listitem>
            <para>Anything between -1.6 and -2 is rounded to -2.</para>
          </listitem>
          <listitem>
            <para>Etcetera.</para>
          </listitem>
        </itemizedlist>
        <!--Tested in 1.0 and 1.5 -> same shit.-->
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is <function>round</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <para>In Firebird 1.5, the entry point has been renamed to <function>fbround</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under truncate:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any existing <function>*round</function> and <function>*truncate</function> declarations and declare them anew, using the updated entry point names.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-rpad">
      <title><function>rpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string right-padded with <parameter>padchar</parameter>s until <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>rpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this function can accept and return strings of up to 32767 characters.</para>
          </listitem>
          <listitem>
            <para>When calling this function, make sure <parameter>endlength</parameter> does not exceed the declared result length.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-udf-rtrim">
      <title><function>rtrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any trailing space characters removed. In Firebird 1.0.x, this function returns <constant>NULL</constant> if the input string is empty or <constant>NULL</constant>. In 1.5 and above it returns <literal>''</literal> (an empty string) in these cases.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>rtrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rtrim
   CSTRING(255)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd15-udf-sdow">
      <title><function>sdow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the abbreviated day of the week from a timestamp argument. The returned abbreviation may be localized.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>VARCHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sdow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sdow
   TIMESTAMP,
   VARCHAR(5) RETURNS PARAMETER 2
   ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd15-udf-dow"><function>dow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-string2blob">
      <title><function>string2blob</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string as a <database>BLOB</database>.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>string2blob (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION string2blob
   VARCHAR(300) BY DESCRIPTOR,
   BLOB RETURNS PARAMETER 2
   ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd15-udf-substr">
      <title><function>substr</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0, 1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring from <parameter>startpos</parameter> to <parameter>endpos</parameter>, inclusively. Positions are 1-based. If <parameter>endpos</parameter> is past the end of the string, Firebird's <function>substr</function> returns all the characters from <parameter>startpos</parameter> to the end of the string. InterBase's <function>substr</function> returned <constant>NULL</constant> in this case.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>substr (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>endpos</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substr
   CSTRING(255), SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
      <tip>
        <para>Although the function arguments are slightly different, consider using the internal SQL function <database><link linkend="langrefupd15-substring">SUBSTRING</link></database> instead, for better compatibility.</para>
      </tip>
    </section>
    <section id="langrefupd15-udf-substrlen">
      <title><function>substrlen</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the substring starting at <parameter>startpos</parameter> and having <parameter>length</parameter> characters (or less, if the end of the string is reached first). Positions are 1-based. If either <parameter>startpos</parameter> or <parameter>length</parameter> is smaller than 1, an empty string is returned.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>CHAR(<replaceable>n</replaceable>)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>substrlen (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>length</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substrlen
   CSTRING(255), SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In Firebird 1.5.1 and below, the default declaration uses <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
          </listitem>
          <listitem>
            <para>Depending on how you declare it (see <link linkend="langrefupd15-notes-cstring"><database>CSTRING</database> note</link>), this function can accept and return strings of up to 32767 characters.</para>
          </listitem>
        </itemizedlist>
      </note>
      <tip>
        <para>Firebird 1.0 has also implemented the internal SQL function <database><link linkend="langrefupd15-substring">SUBSTRING</link></database>, rendering <function>substrlen</function> obsolete in the same version in which it was introduced. In new code, use <database>SUBSTRING</database>.</para>
      </tip>
    </section>
    <section id="langrefupd15-udf-truncate">
      <title><function>truncate</function>, <function>i64truncate</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole-number portion of their (scaled numeric/decimal) argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Return type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>truncate    (<parameter>number</parameter>)
i64truncate (<parameter>big</parameter>number)</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>Both functions round to the nearest whole number that is lower than or equal to the argument. This means that negative numbers are <quote>truncated</quote> downward. For instance, <function>truncate(<parameter>-2.37</parameter>)</function> returns <literal>-3</literal>. A rather peculiar exception is formed by the numbers between -1 and 0, which are all truncated to 0. The only number that truncates to -1 is -1 itself.</para>
        <!--Tested in 1.0 and 1.5 -> same shit. This is floor, not truncate. Except on <-1,0]-->
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is <function>truncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <para>In Firebird 1.5, the entry point has been renamed to <function>fbtruncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under round:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any existing <function>*round</function> and <function>*truncate</function> declarations and declare them anew, using the updated entry point names.</para>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <appendix id="langrefupd15-notes">
    <title>Notes</title>
    <section id="langrefupd15-notes-charset-none">
      <title>Character set <database>NONE</database> data accepted <quote>as is</quote></title>
      <subtitle>In Firebird 1.5.1 and up</subtitle>
      <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are moved to and from fields or variables with another character set, resulting in fewer transliteration errors.</para>
      <para>In Firebird 1.5.0, from a client connected with character set <database>NONE</database>, you could read data in two incompatible character sets – such as <database>SJIS</database> (Japanese) and <database>WIN1251</database> (Russian) – even though you could not read one of those character sets while connected from a client with the other character set. Data would be received <quote>as is</quote> and be stored without raising an exception.</para>
      <para>However, from this character set <database>NONE</database> client connection, an attempt to update any Russian or Japanese data columns using either parameterized queries or literal strings without introducer syntax would fail with transliteration errors; and subsequent queries on the stored <quote><database>NONE</database></quote> data would similarly fail.</para>
      <para>In Firebird 1.5.1, both problems have been circumvented. Data received from the client in character set <database>NONE</database> are still stored <quote>as is</quote> but what is stored is an exact, binary copy of the received string. In the reverse case, when stored data are read into this client from columns with specific character sets, there will be no transliteration error. When the connection character set is <database>NONE</database>, no attempt is made in either case to resolve the string to well-formed characters, so neither the write nor the read will throw a transliteration error.</para>
      <para>This opens the possibility for working with data from multiple character sets in a single database, as long as the connection character set is <database>NONE</database>. The client has full responsibility for submitting strings in the appropriate character set and converting strings returned by the engine, as needed.</para>
      <para>Abstraction layers that have to manage this can read the low byte of the <structfield>sqlsubtype</structfield> field in the <structname>XSQLVAR</structname> structure, which contains the character set identifier.</para>
      <para>While character set <database>NONE</database> literals are accepted and implicitly stored in the character set of their context, the use of introducer syntax to coerce the character sets of literals is highly recommended when the application is handling literals in a mixture of character sets. This should avoid the string's being misinterpreted when the application shifts the context for literal usage to a different character set.</para>
      <note>
        <para>Coercion of the character set, using the introducer syntax or casting, is still required when handling heterogeneous character sets from a client context that is anything other than <database>NONE</database>. Both methods are shown below, using character set <database>ISO8859_1</database> as an example target. Notice the <quote><literal>_</literal></quote> prefix in the introducer syntax.</para>
        <variablelist>
          <varlistentry>
            <term>Introducer syntax:</term>
            <listitem>
              <para><code>_ISO8859_1 <replaceable>mystring</replaceable></code></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Casting:</term>
            <listitem>
              <para><code>CAST (<replaceable>mystring</replaceable> AS VARCHAR(<replaceable>n</replaceable>) CHARACTER SET ISO8859_1)</code></para>
            </listitem>
          </varlistentry>
        </variablelist>
      </note>
    </section>
    <section id="langrefupd15-notes-withlock">
      <title>Understanding the <database>WITH LOCK</database> clause</title>
      <para>This note looks a little deeper into explicit locking and its ramifications. The <database>WITH LOCK</database> feature, added in Firebird 1.5, provides a limited explicit pessimistic locking capability for cautious use in conditions where the affected row set is:<orderedlist numeration="loweralpha" spacing="compact">
          <listitem>
            <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
          </listitem>
          <listitem>
            <para>precisely controlled by the application code.</para>
          </listitem>
        </orderedlist></para>
      <para>Pessimistic locks are rarely needed in Firebird. This is an expert feature, intended for use by those who thoroughly understand its consequences. Knowledge of the various levels of transaction isolation is essential. <database>WITH LOCK</database> is available in DSQL and PSQL, and only for top-level, single-table <database>SELECT</database>s. As stated in the reference part of this guide, <database>WITH LOCK</database> is <emphasis>not</emphasis> available:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification;</para>
        </listitem>
        <listitem>
          <para>for joined sets;</para>
        </listitem>
        <listitem>
          <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database> clause or any other aggregating operation;</para>
        </listitem>
        <listitem>
          <para>with a view;</para>
        </listitem>
        <listitem>
          <para>with the output of a selectable stored procedure;</para>
        </listitem>
        <listitem>
          <para>with an external table.</para>
        </listitem>
      </itemizedlist>
      <section id="langrefupd15-appx-withlock-syntax">
        <title>Syntax and behaviour</title>
        <blockquote>
          <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
        </blockquote>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the selected rows and prevent any other transaction from obtaining write access to any of those rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to each row, one by one, as it is fetched into the server-side row cache. It becomes possible, then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by another transaction.</para>
        <para>As the engine considers, in turn, each record falling under an explicit lock statement, it returns either the record version that is the most currently committed, regardless of database state when the statement was submitted, or an exception.</para>
        <para>Wait behaviour and conflict reporting depend on the transaction parameters specified in the TPB block:</para>
        <table id="langrefupd15-tbl-tpb-effects">
          <title>How TPB settings affect explicit locking</title>
          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />
            <colspec align="left" colname="behaviour" colwidth="3*" />
            <thead>
              <row>
                <entry align="center">TPB mode</entry>
                <entry align="center">Behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry align="center"><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explicit locks are overridden by implicit or explicit table-level locks and are ignored</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_concurrency</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If a record is modified by any transaction that was committed since the transaction attempting to get explicit lock started, or an active transaction has performed a modification of this record, an update conflict exception is raised immediately</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_concurrency</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If the record is modified by any transaction that has committed since the transaction attempting to get explicit lock started, an update conflict exception is raised immediately.</para><para>If an active transaction is holding ownership on this record (via explicit locking or by a normal optimistic write-lock) the transaction attempting the explicit lock waits for the outcome of the blocking transaction and, when it finishes, attempts to get the lock on the record again. This means that, if the blocking transaction committed a modified version of this record, an update conflict exception will be raised.</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_read_committed</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on this record (via explicit locking or normal update), an update conflict exception is raised immediately.</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_read_committed</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on this record (via explicit locking or by a normal optimistic write-lock), the transaction attempting the explicit lock waits for the outcome of blocking transation and when it finishes, attempts to get the lock on the record again.</para><para>Update conflict exceptions can never be raised by an explicit lock statement in this TPB mode.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="langrefupd15-appx-withlock-engine">
        <title>How the engine deals with <database>WITH LOCK</database></title>
        <para>When an <database>UPDATE</database> statement tries to access a record that is locked by another transaction, it either raises an update conflict exception or waits for the locking transaction to finish, depending on TPB mode. Engine behaviour here is the same as if this record had already been modified by the locking transaction.</para>
        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>
        <para>The engine guarantees that all records returned by an explicit lock statement are actually locked and <emphasis>do</emphasis> meet the search conditions specified in <database>WHERE</database> clause, as long as the search conditions do not depend on any other tables, via joins, subqueries, etc. It also guarantees that rows not meeting the search conditions will not be locked by the statement. It can <emphasis>not</emphasis> guarantee that there are no rows which, though meeting the search conditions, are not locked.</para>
        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during the course of the locking statement's execution.</para>
        </note>
        <para>The engine locks rows at fetch time. This has important consequences if you lock several rows at once. Many access methods for Firebird databases default to fetching output in packets of a few hundred rows (<quote>buffered fetches</quote>). Most data access components cannot bring you the rows contained in the last-fetched packet, where an error occurred.</para>
      </section>
      <section id="langrefupd15-appx-withlock-of">
        <title>The optional <quote><database>OF</database> <replaceable>&lt;column-names&gt;</replaceable></quote> sub-clause</title>
        <para>The <database>FOR UPDATE</database> clause provides a technique to prevent usage of buffered fetches, optionally with the <quote><database>OF</database> <replaceable>&lt;column-names&gt;</replaceable></quote> subclause to enable positioned updates.</para>
        <tip>
          <para>Alternatively, it may be possible in your access components to set the size of the fetch buffer to 1. This would enable you to process the currently-locked row before the next is fetched and locked, or to handle errors without rolling back your transaction.</para>
        </tip>
      </section>
      <section id="langrefupd15-appx-withlock-caveats">
        <title>Caveats using <database>WITH LOCK</database></title>
        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were taken under that savepoint, but it doesn't notify waiting transactions. Applications should not depend on this behaviour as it may get changed in the future.</para>
          </listitem>
          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict errors, the volume of deadlock errors will grow unless you design your locking strategy carefully and control it rigorously.</para>
          </listitem>
          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit locks are (1) to prevent expensive handling of update conflict errors in heavily loaded applications and (2) to maintain integrity of objects mapped to a relational database in a clustered environment. If your use of explicit locking doesn't fall in one of these two categories, then it's the wrong way to do the task in Firebird.</para>
          </listitem>
          <listitem>
            <para>Explicit locking is an advanced feature; do not misuse it! While solutions for these kinds of problems may be very important for web sites handling thousands of concurrent writers, or for ERP/CRM systems operating in large corporations, most application programs do not need to work in such conditions.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="langrefupd15-appx-withlock-examples">
        <title>Examples using explicit locking</title>
        <orderedlist numeration="lowerroman">
          <listitem>
            <para>Simple:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK        </programlisting>
          </listitem>
          <listitem>
            <para>Multiple rows, one-by-one processing with DSQL cursor:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK        </programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section id="langrefupd15-notes-cstring">
      <title>A note on <database>CSTRING</database> parameters</title>
      <para>External functions involving strings often use the type <database>CSTRING(<replaceable>n</replaceable>)</database> in their declarations. This type represents a zero-terminated string of maximum length <replaceable>n</replaceable>. Most of the functions handling <database>CSTRING</database>s are programmed in such a way that they can accept and return zero-terminated strings of any length. So why the <replaceable>n</replaceable>? Because the Firebird engine has to set up space to process the input an output parameters, and convert them to and from SQL data types. Most strings used in databases are only dozens to hundreds of bytes long; it would be a waste to reserve 32 KB of memory each time such a string is processed. Therefore, the <emphasis>standard</emphasis> declarations of most <database>CSTRING</database> functions – as found in the file <filename>ib_udf.sql</filename> – specifiy a length of 255 bytes. (In Firebird 1.5.1 and below, this default length is 80 bytes.) As an example, here's the SQL declaration of <function>lpad</function>:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
      </blockquote>
      <para>Once you've declared a <database>CSTRING</database> parameter with a certain length, you cannot call the function with a longer input string, or cause it to return a string longer than the declared output length. But the standard declarations are just reasonable defaults; they're not cast in concrete, and you can change them if you want to. If you have to left-pad strings of up to 500 bytes long, then it's perfectly OK to change both 255's in the declaration to 500 or more.</para>
      <para>A special case is when you usually operate on short strings (say less then 100 bytes) but occasionally have to call the function with a huge <database>(VAR)CHAR</database> argument. Declaring <database>CSTRING(32000)</database> makes sure that all the calls will be successful, but it will also cause 32000 bytes per parameter to be reserved, even in that majority of cases where the strings are under 100 bytes. In that situation you may consider declaring the function twice, with different names and different string lengths:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpad</emphasis>
   <emphasis role="bold">CSTRING(100)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(100)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';

DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpadbig</emphasis>
   <emphasis role="bold">CSTRING(32000)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(32000)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';</programlisting>
      </blockquote>
      <para>Now you can call <function>lpad()</function> for all the small strings and <function>lpadbig()</function> for the occasional monster. Notice how the declared names in the first line differ (they determine how you call the functions from within your SQL), but the entry point (the function name in the library) is the same in both cases.</para>
      <!--The Firebird Book states that the low default is there for security reasons, to prevent
accidental or malicious overflow.-->
    </section>
  </appendix>
  <appendix id="langrefupd15-dochist">
    <title>Document History</title>
    <para>The exact file history is recorded in the <filename class="directory">manual</filename> module in our CVS tree; see <ulink url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>
    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>
          <date>3 Jul 2008</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>First publication, using 15–20% material from the Firebird Release Notes.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>
  <appendix id="langrefupd15-license">
    <title>License notice</title>
    <para>The contents of this Documentation are subject to the Public Documentation License Version 1.0 (the <quote>License</quote>); you may only use this Documentation if you comply with the terms of this License. Copies of the License are available at <ulink url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink> (PDF) and <ulink url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink> (HTML).</para>
    <para>The Original Documentation is titled <citetitle>Firebird 1.5 Language Reference Update</citetitle>.</para>
    <para>The Initial Writers of the Original Documentation are: Paul Vinkenoog et al.</para>
    <para>Copyright (C) 2008. All Rights Reserved. Initial Writers contact: paul at vinkenoog dot nl.</para>
    <para>Writers and Editors of included PDL-licensed material (the <quote>et al.</quote>) are: J. Beesley, Helen Borrie, Arno Brinkman, Alex Peshkov, Nickolay Samofatov, Dmitry Yemanov.</para>
    <para>Included portions are Copyright (C) 2001-2007 by their respective authors. All Rights Reserved.</para>
  </appendix>
</book>