<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../../tools/docbook-dtd/docbookx.dtd">
<book id="langrefupd25">
  <bookinfo>
    <title>Firebird 2.5 Language Reference Update</title>
    <subtitle>Everything new in Firebird SQL since InterBase 6</subtitle>
    <titleabbrev>Firebird 2.5 Language Ref. Update</titleabbrev>
    <author>
      <firstname>Paul</firstname>
      <surname>Vinkenoog et al.</surname>
    </author>
    <edition>8 Oct 2011, document version 1.1 — covers Firebird 2.5 and 2.5.1</edition>
  </bookinfo>
  <chapter id="langrefupd25-intro">
    <title>Introduction</title>
    <section id="langrefupd25-intro-subject">
      <title>Subject matter</title>
      <subtitle>What's this book about?</subtitle>
      <para>This guide documents the <emphasis role="bold">changes</emphasis> made in the Firebird
      SQL language between InterBase 6 and Firebird 2.5.1. It covers the following areas:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>Reserved words</para>
        </listitem>
        <listitem>
          <para>Data types and subtypes</para>
        </listitem>
        <listitem>
          <para>DDL statements (Data Definition Language)</para>
        </listitem>
        <listitem>
          <para>DML statements (Data Manipulation Language)</para>
        </listitem>
        <listitem>
          <para>Transaction control statements</para>
        </listitem>
        <listitem>
          <para>PSQL statements (Procedural SQL, used in stored procedures and triggers)</para>
        </listitem>
        <listitem>
          <para>Security and access control statements</para>
        </listitem>
        <listitem>
          <para>Context variables</para>
        </listitem>
        <listitem>
          <para>Operators and predicates</para>
        </listitem>
        <listitem>
          <para>Aggregate functions</para>
        </listitem>
        <listitem>
          <para>Internal functions</para>
        </listitem>
        <listitem>
          <para>UDFs (User Defined Functions, also known as external functions)</para>
        </listitem>
      </itemizedlist>
      <para>To have a complete Firebird 2.5 SQL reference, you need:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>The InterBase 6.0 beta SQL Reference (<filename>LangRef.pdf</filename> and/or
          <filename>SQLRef.html</filename>)</para>
        </listitem>
        <listitem>
          <para>This document</para>
        </listitem>
      </itemizedlist>
      <para>Non-SQL topics are <emphasis role="bold">not</emphasis> discussed in this document.
      These include:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>ODS versions</para>
        </listitem>
        <listitem>
          <para>Bug listings</para>
        </listitem>
        <listitem>
          <para>Installation and configuration</para>
        </listitem>
        <listitem>
          <para>Upgrade, migration and compatibility</para>
        </listitem>
        <listitem>
          <para>Server architectures</para>
        </listitem>
        <listitem>
          <para>API functions</para>
        </listitem>
        <listitem>
          <para>Connection protocols</para>
        </listitem>
        <listitem>
          <para>Tools and utilities</para>
        </listitem>
      </itemizedlist>
      <para>Consult the Release Notes for information on these subjects. You can find the Release
      Notes and other documentation via the Firebird Documentation Index at <ulink
      url="http://www.firebirdsql.org/en/documentation/">http://www.firebirdsql.org/en/documentation/</ulink>.</para>
    </section>
    <section id="langrefupd25-intro-versions">
      <title>Versions covered</title>
      <para>This document covers all Firebird versions up to and including 2.5.1.</para>
    </section>
    <section id="langrefupd25-intro-authors">
      <title>Authorship</title>
      <para>Most of this document was written by the main author. The remainder (2–3%) was lifted
      from various Firebird Release Notes editions, which in turn contain material from preceding
      sources like the Whatsnew documents. Authors and editors of the included material are:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>J. Beesley</para>
        </listitem>
        <listitem>
          <para>Helen Borrie</para>
        </listitem>
        <listitem>
          <para>Arno Brinkman</para>
        </listitem>
        <listitem>
          <para>Frank Ingermann</para>
        </listitem>
        <listitem>
          <para>Vlad Khorsun</para>
        </listitem>
        <listitem>
          <para>Alex Peshkov</para>
        </listitem>
        <listitem>
          <para>Nickolay Samofatov</para>
        </listitem>
        <listitem>
          <para>Adriano dos Santos Fernandes</para>
        </listitem>
        <listitem>
          <para>Dmitry Yemanov</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-intro-acks">
      <title>Acknowledgments</title>
      <para>Vlad Khorsun, Adriano dos Santos Fernandes and Dmitry Yemanov have been very helpful and
      patient whenever I had questions about the details of various new Firebird features. The email
      conversations I had with them have made this a better work of reference. Thank you,
      guys!</para>
    </section>
  </chapter>
  <chapter id="langrefupd25-new-in-25">
    <title>New in Firebird 2.5</title>
    <para>For users upgrading from Firebird 2.1, this chapter lists the SQL additions and changes in
    Firebird 2.5 and 2.5.1, with links to the corresponding sections. If you come from an earlier
    version or are new to Firebird, you may want to <link linkend="langrefupd25-reskeywords">skip
    this chapter</link>.</para>
    <section id="langrefupd25-new-in-25-reswords">
      <title>Reserved words and keywords</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist>
        <listitem>
          <para><link linkend="langrefupd25-reswords-added">Newly reserved words</link>:
          <database>SIMILAR</database>, <database>SQLSTATE</database> (2.5.1).</para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-keywords-added">New non-reserved keywords</link>:
          <database>AUTONOMOUS</database>, <database>BIN_NOT</database>,
          <database>CALLER</database>, <database>CHAR_TO_UUID</database>,
          <database>COMMON</database>, <database>DATA</database>, <database>FIRSTNAME</database>,
          <database>GRANTED</database>, <database>LASTNAME</database>, <database>MAPPING</database>,
          <database>MIDDLENAME</database>, <database>OS_NAME</database>,
          <database>SOURCE</database>, <database>TWO_PHASE</database> and
          <database>UUID_TO_CHAR</database>.</para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-reswords-dropped">No longer reserved, but still
          keywords</link>: <database>ACTIVE</database>, <database>AFTER</database>,
          <database>ASC</database>, <database>ASCENDING</database>, <database>AUTO</database>,
          <database>BEFORE</database>, <database>COLLATION</database>,
          <database>COMMITTED</database>, <database>COMPUTED</database>,
          <database>CONDITIONAL</database>, <database>CONTAINING</database>,
          <database>CSTRING</database>, <database>DATABASE</database>, <database>DESC</database>,
          <database>DESCENDING</database>, <database>DESCRIPTOR</database>, <database>DO</database>,
          <database>DOMAIN</database>, <database>ENTRY_POINT</database>,
          <database>EXCEPTION</database>, <database>EXIT</database>, <database>FILE</database>,
          <database>GEN_ID</database>, <database>GENERATOR</database>, <database>IF</database>,
          <database>INACTIVE</database>, <database>INPUT_TYPE</database>,
          <database>ISOLATION</database>, <database>KEY</database>, <database>LENGTH</database>,
          <database>LEVEL</database>, <database>MANUAL</database>, <database>MODULE_NAME</database>,
          <database>NAMES</database>, <database>OPTION</database>, <database>OUTPUT_TYPE</database>,
          <database>OVERFLOW</database>, <database>PAGE</database>, <database>PAGE_SIZE</database>,
          <database>PAGES</database>, <database>PASSWORD</database>,
          <database>PRIVILEGES</database>, <database>PROTECTED</database>,
          <database>READ</database>, <database>RESERV</database>, <database>RESERVING</database>,
          <database>RETAIN</database>, <database>SCHEMA</database>, <database>SEGMENT</database>,
          <database>SHADOW</database>, <database>SHARED</database>, <database>SINGULAR</database>,
          <database>SIZE</database>, <database>SNAPSHOT</database>, <database>SORT</database>,
          <database>STABILITY</database>, <database>STARTING</database>,
          <database>STARTS</database>, <database>STATEMENT</database>,
          <database>STATISTICS</database>, <database>SUB_TYPE</database>,
          <database>SUSPEND</database>, <database>TRANSACTION</database>,
          <database>UNCOMMITTED</database>, <database>WAIT</database>, <database>WORK</database> and
          <database>WRITE</database>.</para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-keywords-dropped">No longer reserved and not
          keywords</link>: <database>AUTODDL</database>, <database>BASE_NAME</database>,
          <database>BASED</database>, <database>BLOBEDIT</database>, <database>BUFFER</database>,
          <database>CHECK_POINT_LENGTH</database>, <database>COMPILETIME</database>,
          <database>CONTINUE</database>, <database>DB_KEY</database>, <database>DEBUG</database>,
          <database>DESCRIBE</database>, <database>DISPLAY</database>, <database>ECHO</database>,
          <database>EDIT</database>, <database>EVENT</database>, <database>EXTERN</database>,
          <database>FOUND</database>, <database>GOTO</database>, <database>GROUP_COMMIT_</database>,
          <database>HELP</database>, <database>IMMEDIATE</database>, <database>INDICATOR</database>,
          <database>INIT</database>, <database>INPUT</database>, <database>ISQL</database>,
          <database>LC_MESSAGES</database>, <database>LC_TYPE</database>, <database>LEV</database>,
          <database>LOG_BUFFER_SIZE</database>, <database>MAX_SEGMENT</database>,
          <database>MAXIMUM</database>, <database>MESSAGE</database>, <database>MINIMUM</database>,
          <database>NOAUTO</database>, <database>NUM_LOG_BUFFERS</database>,
          <database>OUTPUT</database>, <database>PAGELENGTH</database>,
          <database>PREPARE</database>, <database>PUBLIC</database>, <database>QUIT</database>,
          <database>RETURN</database>, <database>RUNTIME</database>, <database>SHELL</database>,
          <database>SHOW</database>, <database>SQLERROR</database>, <database>SQLWARNING</database>,
          <database>STATIC</database>, <database>TERMINATOR</database>,
          <database>TRANSLATE</database>, <database>TRANSLATION</database>,
          <database>VERSION</database>, <database>WAIT_TIME</database> and
          <database>WHENEVER</database>.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-misc">
      <title>Miscellany</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-hexnumerals">Hexadecimal notation for
          numerals</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-hexbinstrings">Hexadecimal notation for
          <quote>binary</quote> strings</link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-types">
      <title>Data types and subtypes</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-sqlnull"><database>SQL_NULL</database> data
          type</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-charsets"><database>GB18030</database> character set,
          <database>WIN_1258</database> alias</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-collations"><database>UNICODE_CI_AI</database> collation
          for <database>UTF8</database>, <database>GB18030</database> collation for
          <database>GB18030</database></link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-ddl">
      <title>Data Definition Language (DDL)</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-ddl-charset-alter"><database>ALTER CHARACTER
          SET</database> (set default collation for charset)</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-tbl-speccollattrs"><database>NUMERIC-SORT</database>
          attribute for Unicode collations</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-cr-db-default-collation">Default collation for the
          database</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-alter-proc-classic-visibility">Classic Server: Altered
          procedure immediately visible to other clients</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-at-ac-generated"><database>ALTER COLUMN</database> also
          for generated (computed) columns</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-at-ac-change-type"><database>ALTER COLUMN ...
          TYPE</database> no longer fails if column is used in trigger or SP</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-creatview-from-sp">Views can select from stored
          procedures</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-creatview-infer-colnames">Views can infer column names
          from derived tables or <database>GROUP BY</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-creatview-fullselect-union">Column list for
          <database>UNION</database>-based views no longer mandatory</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-alter-view"><database>ALTER
          VIEW</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-create-or-alter-view"><database>CREATE OR ALTER
          VIEW</database></link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-dml">
      <title>Data Manipulation Language (DML)</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-update-setchanged"><database>UPDATE</database>
          statement: changed <database>SET</database> semantics</link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-psql">
      <title>PSQL statements</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-psql-declare-typeofcolumn"><database>TYPE OF
          COLUMN</database> in variable and parameter declarations</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-psql-execstat"><database>EXECUTE
          STATEMENT</database></link>:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para><link linkend="langrefupd25-psql-execstat-improved-perf">Improved
              performance</link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-psql-execstat-with-trans"><database>WITH</database>
              {<database>AUTONOMOUS</database>|<database>COMMON</database>}
              <database>TRANSACTION</database></link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-psql-execstat-with-caller-privs"><database>WITH
              CALLER PRIVILEGES</database></link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-psql-execstat-on-external"><database>ON
              EXTERNAL</database> [<database>DATA SOURCE</database>]</link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-psql-execstat-asuser-etc"><database>AS
              USER</database>, <database>PASSWORD</database> and
              <database>ROLE</database></link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-psql-execstat-with-params">Parameterized
              statements</link></para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-psql-autonomous-trans"><database>IN AUTONOMOUS
          TRANSACTION</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-psql-subquery-as-expr">Subqueries as PSQL
          expressions</link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-security">
      <title>Security and access control</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-security-alter-role"><database>ALTER
          ROLE</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-security-grantedby"><database>GRANTED BY</database>
          clause</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-security-revoke-all-on-all"><database>REVOKE ALL ON
          ALL</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-security-rdbadmin">The <database>RDB$ADMIN</database>
          role</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-security-auto-admin-mapping"><database>AUTO ADMIN
          MAPPING</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-security-sql-user-mgmt">SQL user management
          commands</link>:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para><link linkend="langrefupd25-security-create-user"><database>CREATE
              USER</database></link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-security-alter-user"><database>ALTER
              USER</database></link></para>
            </listitem>
            <listitem>
              <para><link linkend="langrefupd25-security-drop-user"><database>DROP
              USER</database></link></para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-contextvars">
      <title>Context variables</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-sqlcode"><varname>SQLCODE</varname> deprecated
          (2.5.1)</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-sqlstate"><varname>SQLSTATE</varname> context variable
          (2.5.1)</link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-operators">
      <title>Operators and predicates</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-similar-to"><database>SIMLAR TO</database>: Regular
          expressions</link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-aggrfunc">
      <title>Aggregate functions</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-aggrfunc-list"><database>LIST()</database> separator may
          be any string expression</link></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="langrefupd25-new-in-25-intfunc">
      <title>Internal functions</title>
      <para>Changed since Firebird 2.1:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><link linkend="langrefupd25-intfunc-cast"><database>CAST()</database> as
          <database>TYPE OF COLUMN</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database>: New unit
          <database>WEEK</database>. Sub-<database>DAY</database> units allowed with
          <database>DATE</database>s.</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-intfunc-datediff"><database>DATEDIFF</database>: New
          unit <database>WEEK</database>. Sub-<database>DAY</database> units allowed with
          <database>DATE</database>s.</link></para>
        </listitem>
        <listitem>
          <para><link
          linkend="langrefupd25-intfunc-char_to_uuid"><database>CHAR_TO_UUID()</database></link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-intfunc-log"><database>LOG()</database> behaviour
          improved</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-intfunc-log10"><database>LOG10()</database> behaviour
          improved</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-intfunc-lpad"><database>LPAD()</database> now returns
          <database>VARCHAR</database> of exact end length</link></para>
        </listitem>
        <listitem>
          <para><link linkend="langrefupd25-intfunc-rpad"><database>RPAD()</database> now returns
          <database>VARCHAR</database> of exact end length</link></para>
        </listitem>
        <listitem>
          <para><link
          linkend="langrefupd25-intfunc-uuid_to_char"><database>UUID_TO_CHAR()</database></link></para>
        </listitem>
      </itemizedlist>
    </section>
  </chapter>
  <chapter id="langrefupd25-reskeywords">
    <title>Reserved words and keywords</title>
    <para>Reserved words are part of the Firebird SQL language. They cannot be used as identifiers
    (e.g. as table or procedure names), except when enclosed in double quotes in Dialect 3. However,
    you should avoid this unless you have a compelling reason.</para>
    <para>Keywords are also part of the language. They have a special meaning when used in the
    proper context, but they are not reserved for Firebird's own and exclusive use. You can use them
    as identifiers without double-quoting.</para>
    <para>The following sections present the changes since InterBase 6. Full listings of Firebird
    2.5 reserved words and keywords can be found in the <link
    linkend="langrefupd25-reskeywords-full">Appendix</link>.</para>
    <section id="langrefupd25-reskeywords-added">
      <title>Added since InterBase 6</title>
      <section id="langrefupd25-reswords-added">
        <title>Newly reserved words</title>
        <para>The following reserved words have been added to Firebird:</para>
        <blockquote>
          <simplelist>
            <member><database>BIGINT<!--1.5--></database></member>
            <member><database>BIT_LENGTH<!--2.0--></database></member>
            <member><database>BOTH<!--2.0--></database></member>
            <member><database>CASE<!--1.5--></database></member>
            <!--CHAR_LENGTH (2.0) removed - already in IB6 reserved words list!-->
            <!--CHARACTER_LENGTH (2.0) removed - already in IB6 reserved words list!-->
            <member><database>CLOSE<!--2.0--></database></member>
            <member><database>CONNECT<!--2.1--></database></member>
            <member><database>CROSS<!--2.0--></database></member>
            <member><database>CURRENT_CONNECTION<!--1.5--></database></member>
            <member><database>CURRENT_ROLE<!--1.0--></database></member>
            <member><database>CURRENT_TRANSACTION<!--1.5--></database></member>
            <member><database>CURRENT_USER<!--1.0--></database></member>
            <member><database>DISCONNECT<!--2.1--></database></member>
            <member><database>FETCH<!--2.0--></database></member>
            <member><database>GLOBAL<!--2.1--></database></member>
            <member><database>INSENSITIVE<!--2.1--></database></member>
            <member><database>LEADING<!--2.0--></database></member>
            <member><database>LOWER<!--2.0--></database></member>
            <!--OCTET_LENGTH (2.0) removed - already in IB6 reserved words list!-->
            <member><database>OPEN<!--2.0--></database></member>
            <member><database>RECREATE<!--1.0--></database></member>
            <member><database>RECURSIVE<!--2.1 - first mentioned in 2.1.2 rlsnotes--></database></member>
            <!--RELEASE (1.5) removed - already in IB6 reserved words list!-->
            <member><database>ROW_COUNT<!--1.5--></database></member>
            <member><database>ROWS<!--2.0--></database></member>
            <member><database>SAVEPOINT<!--1.5--></database></member>
            <member><database>SENSITIVE<!--2.1 - first mentioned in 2.1.2 rlsnotes--></database></member>
            <member><database>SIMILAR<!--2.5--></database></member>
            <member><database>SQLSTATE</database> (2.5.1)</member>
            <member><database>START<!--2.1--></database></member>
            <member><database>TRAILING<!--2.0--></database></member>
            <member><database>TRIM<!--2.0--></database></member>
            <!--USING (according to RlsNotes KW in 1.5, RES in 2.0) removed - already in IB6 reserved words list!-->
          </simplelist>
        </blockquote>
        <!--None of these have been dropped or moved to keyword in Fb 2.5-->
      </section>
      <section id="langrefupd25-keywords-added">
        <title>New non-reserved keywords</title>
        <para>The following words have been added to Firebird as non-reserved keywords. More than
        half of them are names of internal functions added between 2.0 and 2.1.</para>
        <blockquote>
          <simplelist>
            <member><database>ABS<!--2.1--></database></member>
            <member><database>ACCENT<!--2.1--></database></member>
            <member><database>ACOS<!--2.1--></database></member>
            <member><database>ALWAYS<!--2.1--></database></member>
            <member><database>ASCII_CHAR<!--2.1--></database></member>
            <member><database>ASCII_VAL<!--2.1--></database></member>
            <member><database>ASIN<!--2.1--></database></member>
            <member><database>ATAN<!--2.1--></database></member>
            <member><database>ATAN2<!--2.1--></database></member>
            <member><database>AUTONOMOUS<!--2.5--></database></member>
            <member><database>BACKUP<!--2.0--></database></member>
            <member><database>BIN_AND<!--2.1--></database></member>
            <member><database>BIN_OR<!--2.1--></database></member>
            <member><database>BIN_NOT<!--2.5--></database></member>
            <member><database>BIN_SHL<!--2.1--></database></member>
            <member><database>BIN_SHR<!--2.1--></database></member>
            <member><database>BIN_XOR<!--2.1--></database></member>
            <member><database>BLOCK<!--2.0--></database></member>
            <member><database>BREAK<!--RES in 1.0 - KW in 1.5--></database></member>
            <member><database>CALLER<!--2.5--></database></member>
            <member><database>CEIL<!--2.1--></database></member>
            <member><database>CEILING<!--2.1 - first mentioned in 2.1.2 rlsnotes--></database></member>
            <member><database>CHAR_TO_UUID<!--2.5--></database></member>
            <member><database>COALESCE<!--1.5--></database></member>
            <member><database>COLLATION<!--2.0--></database></member>
            <member><database>COMMENT<!--2.0--></database></member>
            <member><database>COMMON<!--2.5--></database></member>
            <member><database>COS<!--2.1--></database></member>
            <member><database>COSH<!--2.1--></database></member>
            <member><database>COT<!--2.1--></database></member>
            <member><database>DATA<!--2.5--></database></member>
            <member><database>DATEADD<!--2.1--></database></member>
            <member><database>DATEDIFF<!--2.1--></database></member>
            <member><database>DECODE<!--2.1--></database></member>
            <member><database>DELETING<!--1.5--></database></member>
            <!--DESCRIPTOR (RES in 1.0, KW in 1.5) moved to "No longer reserved, still KW" - already in IB6 reserved words list!-->
            <member><database>DIFFERENCE<!--2.0--></database></member>
            <member><database>EXP<!--2.1--></database></member>
            <member><database>FIRST<!--RES in 1.0 - KW in 1.5--></database></member>
            <member><database>FIRSTNAME<!--2.5--></database></member>
            <member><database>FLOOR<!--2.1--></database></member>
            <member><database>GEN_UUID<!--2.1--></database></member>
            <member><database>GENERATED<!--2.1--></database></member>
            <member><database>GRANTED<!--2.5--></database></member>
            <member><database>HASH<!--2.1--></database></member>
            <member><database>IIF<!--RES in 1.0 - dropped in 1.5 (but check keywords.cpp if time permits) - KW in 2.0 (intfunc IIF added in 2.0)--></database></member>
            <member><database>INSERTING<!--1.5--></database></member>
            <member><database>LAST<!--1.5--></database></member>
            <member><database>LASTNAME<!--2.5--></database></member>
            <member><database>LEAVE<!--1.5--></database></member>
            <member><database>LIST<!--2.1--></database></member>
            <member><database>LN<!--2.1--></database></member>
            <member><database>LOCK<!--1.5--></database></member>
            <member><database>LOG<!--2.1--></database></member>
            <member><database>LOG10<!--2.1--></database></member>
            <member><database>LPAD<!--2.1--></database></member>
            <member><database>MAPPING<!--2.5--></database></member>
            <member><database>MATCHED<!--2.1--></database></member>
            <member><database>MATCHING<!--2.1--></database></member>
            <member><database>MAXVALUE<!--2.1--></database></member>
            <member><database>MIDDLENAME<!--2.5--></database></member>
            <member><database>MILLISECOND<!--2.1--></database></member>
            <member><database>MINVALUE<!--2.1--></database></member>
            <member><database>MOD<!--2.1--></database></member>
            <member><database>NEXT<!--2.0--></database></member>
            <member><database>NULLIF<!--1.5--></database></member>
            <member><database>NULLS<!--1.5--></database></member>
            <member><database>OS_NAME<!--2.5--></database></member>
            <member><database>OVERLAY<!--2.1--></database></member>
            <member><database>PAD<!--2.1--></database></member>
            <member><database>PI<!--2.1--></database></member>
            <member><database>PLACING<!--2.1--></database></member>
            <member><database>POWER<!--2.1--></database></member>
            <member><database>PRESERVE<!--2.1--></database></member>
            <member><database>RAND<!--2.1--></database></member>
            <member><database>REPLACE<!--2.1--></database></member>
            <member><database>RESTART<!--2.0--></database></member>
            <member><database>RETURNING<!--2.0--></database></member>
            <member><database>REVERSE<!--2.1--></database></member>
            <member><database>ROUND<!--2.1--></database></member>
            <member><database>RPAD<!--2.1--></database></member>
            <member><database>SCALAR_ARRAY<!--2.0--></database></member>
            <member><database>SEQUENCE<!--2.0--></database></member>
            <member><database>SIGN<!--2.1--></database></member>
            <member><database>SIN<!--2.1--></database></member>
            <member><database>SINH<!--2.1--></database></member>
            <member><database>SKIP<!--RES in 1.0 - KW in 1.5--></database></member>
            <member><database>SOURCE<!--2.5--></database></member>
            <member><database>SPACE<!--2.1--></database></member>
            <member><database>SQRT<!--2.1--></database></member>
            <!--STATEMENT moved to "No longer reserved, still KW" - already in IB6 reserved words list! - probably also RES in 1.0-->
            <member><database>SUBSTRING<!--RES in 1.0 - KW in 1.5--></database></member>
            <member><database>TAN<!--2.1--></database></member>
            <member><database>TANH<!--2.1--></database></member>
            <member><database>TEMPORARY<!--2.1--></database></member>
            <member><database>TRUNC<!--2.1--></database></member>
            <member><database>TWO_PHASE<!--2.5--></database></member>
            <member><database>WEEK<!--2.1 -> 2.5 RlsNotes mention WEEK as RESERVED, but this is incorrect ("create table week" succeeds)--></database></member>
            <member><database>UPDATING<!--1.5--></database></member>
            <member><database>UUID_TO_CHAR<!--2.5--></database></member>
          </simplelist>
        </blockquote>
      </section>
    </section>
    <section id="langrefupd25-reskeywords-dropped">
      <title>Dropped since InterBase 6</title>
      <section id="langrefupd25-reswords-dropped">
        <title>No longer reserved, still keywords</title>
        <para>The following words are no longer reserved in Firebird 2.5, but are still recognized
        as keywords:</para>
        <!--All were de-reserved in 2.5, except
ACTION CASCADE FREE_IT RESTRICT ROLE TYPE WEEKDAY YEARDAY,
which were de-reserved in 2.0
and
DESCRIPTOR STATEMENT
which were de-reserved in 1.5-->
        <blockquote>
          <simplelist>
            <member><database>ACTION<!--2.0--></database></member>
            <member><database>ACTIVE</database></member>
            <member><database>AFTER</database></member>
            <member><database>ASC</database></member>
            <member><database>ASCENDING</database></member>
            <member><database>AUTO</database></member>
            <member><database>BEFORE</database></member>
            <member><database>CASCADE<!--2.0--></database></member>
            <member><database>COLLATION</database></member>
            <member><database>COMMITTED</database></member>
            <member><database>COMPUTED</database></member>
            <member><database>CONDITIONAL</database></member>
            <member><database>CONTAINING</database></member>
            <member><database>CSTRING</database></member>
            <member><database>DATABASE</database></member>
            <member><database>DESC</database></member>
            <member><database>DESCENDING</database></member>
            <member><database>DESCRIPTOR<!--RES in 1.0 AND ALSO IN IB6 LIST - KW in 1.5--></database></member>
            <member><database>DO</database></member>
            <member><database>DOMAIN</database></member>
            <member><database>ENTRY_POINT</database></member>
            <member><database>EXCEPTION</database></member>
            <member><database>EXIT</database></member>
            <member><database>FILE</database></member>
            <member><database>FREE_IT<!--2.0--></database></member>
            <member><database>GEN_ID</database></member>
            <member><database>GENERATOR</database></member>
            <member><database>IF</database></member>
            <member><database>INACTIVE</database></member>
            <member><database>INPUT_TYPE</database></member>
            <member><database>ISOLATION</database></member>
            <member><database>KEY</database></member>
            <member><database>LENGTH</database></member>
            <member><database>LEVEL</database></member>
            <member><database>MANUAL</database></member>
            <member><database>MODULE_NAME</database></member>
            <member><database>NAMES</database></member>
            <member><database>OPTION</database></member>
            <member><database>OUTPUT_TYPE</database></member>
            <member><database>OVERFLOW</database></member>
            <member><database>PAGE</database></member>
            <member><database>PAGE_SIZE</database></member>
            <member><database>PAGES</database></member>
            <member><database>PASSWORD</database></member>
            <member><database>PRIVILEGES</database></member>
            <member><database>PROTECTED</database></member>
            <member><database>READ</database></member>
            <member><database>RESERV</database></member>
            <member><database>RESERVING</database></member>
            <member><database>RESTRICT<!--2.0--></database></member>
            <member><database>RETAIN</database></member>
            <member><database>ROLE<!--2.0--></database></member>
            <member><database>SCHEMA</database></member>
            <member><database>SEGMENT</database></member>
            <member><database>SHADOW</database></member>
            <member><database>SHARED</database></member>
            <member><database>SINGULAR</database></member>
            <member><database>SIZE</database></member>
            <member><database>SNAPSHOT</database></member>
            <member><database>SORT</database></member>
            <member><database>STABILITY</database></member>
            <member><database>STARTING</database></member>
            <member><database>STARTS</database></member>
            <member><database>STATEMENT<!--RESERVED in IB6 (hence probably also in 1.0), KW in 1.5--></database></member>
            <member><database>STATISTICS</database></member>
            <member><database>SUB_TYPE</database></member>
            <member><database>SUSPEND</database></member>
            <member><database>TRANSACTION</database></member>
            <member><database>TYPE<!--2.0--></database></member>
            <member><database>UNCOMMITTED</database></member>
            <member><database>WAIT</database></member>
            <member><database>WEEKDAY<!--2.0--></database></member>
            <member><database>WORK</database></member>
            <member><database>WRITE</database></member>
            <member><database>YEARDAY<!--2.0--></database></member>
          </simplelist>
        </blockquote>
      </section>
      <section id="langrefupd25-keywords-dropped">
        <title>No longer reserved, not keywords</title>
        <para>The following words are no longer reserved in Firebird 2.5, and not keywords
        either:</para>
        <!--All were de-reserved and in 2.5, except
BASENAME CACHE CHECK_POINT_LEN GROUP_COMMIT_WAIT LOG_BUF_SIZE LOGFILE NUM_LOG_BUFS RAW_PARTITIONS,
which were de-reserved in 2.0-->
        <blockquote>
          <simplelist>
            <member><database>AUTODDL</database></member>
            <member><database>BASE_NAME</database></member>
            <member><database>BASED</database></member>
            <member><database>BASENAME<!--2.0--></database></member>
            <member><database>BLOBEDIT</database></member>
            <member><database>BUFFER</database></member>
            <member><database>CACHE<!--2.0--></database></member>
            <member><database>CHECK_POINT_LEN<!--2.0--></database></member>
            <member><database>CHECK_POINT_LENGTH</database></member>
            <member><database>COMPILETIME</database></member>
            <member><database>CONTINUE</database></member>
            <member><database>DB_KEY</database></member>
            <member><database>DEBUG</database></member>
            <member><database>DESCRIBE</database></member>
            <member><database>DISPLAY</database></member>
            <member><database>ECHO</database></member>
            <member><database>EDIT</database></member>
            <member><database>EVENT</database></member>
            <member><database>EXTERN</database></member>
            <member><database>FOUND</database></member>
            <member><database>GOTO</database></member>
            <member><database>GROUP_COMMIT_</database></member>
            <member><database>GROUP_COMMIT_WAIT<!--2.0--></database></member>
            <member><database>HELP</database></member>
            <member><database>IMMEDIATE</database></member>
            <member><database>INDICATOR</database></member>
            <member><database>INIT</database></member>
            <member><database>INPUT</database></member>
            <member><database>ISQL</database></member>
            <member><database>LC_MESSAGES</database></member>
            <member><database>LC_TYPE</database></member>
            <member><database>LEV</database></member>
            <member><database>LOG_BUF_SIZE<!--2.0--></database></member>
            <member><database>LOG_BUFFER_SIZE</database></member>
            <member><database>LOGFILE<!--2.0--></database></member>
            <member><database>MAX_SEGMENT</database></member>
            <member><database>MAXIMUM</database></member>
            <member><database>MESSAGE</database></member>
            <member><database>MINIMUM</database></member>
            <member><database>NOAUTO</database></member>
            <member><database>NUM_LOG_BUFFERS</database></member>
            <member><database>NUM_LOG_BUFS<!--2.0--></database></member>
            <member><database>OUTPUT</database></member>
            <member><database>PAGELENGTH</database></member>
            <member><database>PREPARE</database></member>
            <member><database>PUBLIC</database></member>
            <member><database>QUIT</database></member>
            <member><database>RAW_PARTITIONS<!--2.0--></database></member>
            <member><database>RETURN</database></member>
            <member><database>RUNTIME</database></member>
            <member><database>SHELL</database></member>
            <member><database>SHOW</database></member>
            <member><database>SQLERROR</database></member>
            <member><database>SQLWARNING</database></member>
            <member><database>STATIC</database></member>
            <member><database>TERMINATOR</database></member>
            <member><database>TRANSLATE</database></member>
            <member><database>TRANSLATION</database></member>
            <member><database>VERSION</database></member>
            <member><database>WAIT_TIME</database></member>
            <member><database>WHENEVER</database></member>
          </simplelist>
        </blockquote>
        <para>Some of these words still have a special meaning in ESQL and/or ISQL.</para>
      </section>
    </section>
    <section id="langrefupd25-reswords-future">
      <title>Possibly reserved in future versions</title>
      <para>The following words are not reserved in Firebird 2.5, but are better avoided as
      identifiers because they will likely be reserved – or added as keywords – in future
      versions:</para>
      <blockquote>
        <simplelist>
          <member><database>BOOLEAN</database></member>
          <member><database>FALSE</database></member>
          <member><database>TRUE</database></member>
          <member><database>UNKNOWN</database></member>
        </simplelist>
      </blockquote>
    </section>
  </chapter>
  <chapter id="langrefupd25-misc">
    <title>Miscellaneous language elements</title>
    <section id="langrefupd25-linecomment">
      <title>-- (single-line comment)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A line starting with <quote><literal>--</literal></quote> (two dashes) is a comment
        and will be ignored. This also makes it easy to quickly comment out a line of SQL.</para>
      </formalpara>
      <para>In Firebird 1.5 and up, the <quote><literal>--</literal></quote> can be placed anywhere
      on the line, e.g. after an SQL statement. Everything from the double dash to the end of the
      line will be ignored.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>-- a table to store our valued customers in:
create table Customers (
  name varchar(32),
  added_by varchar(24),
  custno varchar(8),
  purchases integer      -- number of purchases
)</programlisting>
            <para>Notice that the second comment is only allowed in Firebird 1.5 and up.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-hexnumerals">
      <title>Hexadecimal notation for numerals</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 2.5 and up, integer values can be entered in hexadecimal notation. Numbers
        with 1–8 hex digits will be interpreted as <database>INTEGER</database>s; numbers with 9–16
        hex digits as <database>BIGINT</database>s.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>0{x|X}<replaceable>&lt;hexdigits&gt;</replaceable>

<replaceable>&lt;hexdigits&gt;</replaceable>  ::=  1–16 of <replaceable>&lt;hexdigit&gt;</replaceable>
<replaceable>&lt;hexdigit&gt;</replaceable>   ::=  one of 0..9, A..F, a..f</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select 0x6FAA0D3 from rdb$database           -- returns 117088467
select 0x4F9 from rdb$database               -- returns 1273
select 0x6E44F9A8 from rdb$database          -- returns 1850014120
select 0x9E44F9A8 from rdb$database          -- returns -1639646808 (an <database>INTEGER</database>)
select 0x09E44F9A8 from rdb$database         -- returns 2655320488 (a <database>BIGINT</database>)
select 0x28ED678A4C987 from rdb$database     -- returns 720001751632263
select 0xFFFFFFFFFFFFFFFF from rdb$database  -- returns -1</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara id="langrefupd25-hexnumerals-valueranges">
        <title>Value ranges</title>
        <para><itemizedlist>
            <listitem>
              <para>Hex numbers in the range <literal>0</literal> .. <literal>7FFF</literal>
              <literal>FFFF</literal> are positive <database>INTEGER</database>s with values between
              0 .. 2147483647 decimal. You can force them to <database>BIGINT</database> by
              prepending enough zeroes to bring the total number of hex digits to nine or above, but
              that only changes their type, not their value.</para>
            </listitem>
            <listitem>
              <para>Hex numbers between <literal>8000</literal> <literal>0000</literal> ..
              <literal>FFFF</literal> <literal>FFFF</literal> require some attention:</para>
              <itemizedlist>
                <listitem>
                  <para>When written with eight hex digits, as in <literal>0x9E44F9A8</literal>,
                  they are interpreted as 32-bit <database>INTEGER</database> values. Since their
                  leftmost bit (sign bit) is set, they map to the negative range -2147483648 .. -1
                  decimal.</para>
                </listitem>
                <listitem>
                  <para>With one or more zeroes prepended, as in <literal>0x09E44F9A8</literal>,
                  they are interpreted as 64-bit <database>BIGINT</database>s in the range
                  <literal>0000</literal> <literal>0000</literal> <literal>8000</literal>
                  <literal>0000</literal> .. <literal>0000</literal> <literal>0000</literal>
                  <literal>FFFF</literal> <literal>FFFF</literal>. The sign bit isn't set now, so
                  they map to the positive range 2147483648 .. 4294967295 decimal.</para>
                </listitem>
              </itemizedlist>
              <para>Thus, in this range – and in this range only – prepending a mathematically
              insignificant 0 results in a totally different value. This is something to be aware
              of.</para>
            </listitem>
            <listitem>
              <para>Hex numbers between <literal>1</literal> <literal>0000</literal>
              <literal>0000</literal> .. <literal>7FFF</literal> <literal>FFFF</literal>
              <literal>FFFF</literal> <literal>FFFF</literal> are all positive
              <database>BIGINT</database>s.</para>
            </listitem>
            <listitem>
              <para>Hex numbers between <literal>8000</literal> <literal>0000</literal>
              <literal>0000</literal> <literal>0000</literal> .. <literal>FFFF</literal>
              <literal>FFFF</literal> <literal>FFFF</literal> <literal>FFFF</literal> are all
              negative <database>BIGINT</database>s.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-hexbinstrings">
      <title>Hexadecimal notation for <quote>binary</quote> strings</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 2.5 and up, string literals can be entered in hexadecimal notation. Each
        pair of hex digits defines a byte in the string. Strings entered this way will have
        character set <database>OCTETS</database> by default, but you can force the engine to
        interpret them otherwise with the introducer syntax.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>{x|X}'<replaceable>&lt;hexstring&gt;</replaceable>'

<replaceable>&lt;hexstring&gt;</replaceable>  ::=  an even number of <replaceable>&lt;hexdigit&gt;</replaceable>
<replaceable>&lt;hexdigit&gt;</replaceable>   ::=  one of 0..9, A..F, a..f</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select x'4E657276656E' from rdb$database
  -- returns 4E657276656E, a 6-byte 'binary' string

select _ascii x'4E657276656E' from rdb$database
  -- returns 'Nerven' (same string, now interpreted as ASCII text)

select _iso8859_1 x'53E46765' from rdb$database
  -- returns 'Säge' (4 chars, 4 bytes)

select _utf8 x'53C3A46765' from rdb$database
  -- returns 'Säge' (4 chars, 5 bytes)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>It is up to the client interface how binary strings are displayed to the user.
              Isql, for one, uses uppercase letters A-F. FlameRobin uses lowercase letters. Other
              client programs may have other ideas, e.g. like this, with spaces between the bytes:
              '4E 65 72 76 65 6E'.</para>
            </listitem>
            <listitem>
              <para>The hexadecimal notation allows you to insert any byte value (including 00) at
              any place in the string. However, if you want to coerce it to anything other than
              <database>OCTETS</database>, it is your responsibilty that the byte sequence is valid
              for the target character set.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-shorthandcast">
      <title>Shorthand datetime casts</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Sure about shorthand casts in ESQL?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>When converting a string literal to a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database>, Firebird allows the use of a
        shorthand <quote>C-style</quote> cast. This feature already existed in InterBase 6, but was
        never properly documented.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting><replaceable>datatype</replaceable> '<replaceable>date/timestring</replaceable>'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; <emphasis role="bold">date '1-Jan-1943'</emphasis></programlisting>
            <programlisting>insert into Appointments
  (Employee_Id, Client_Id, App_date, App_time)
values
  (973, 8804, <emphasis role="bold">date 'today'</emphasis> + 2, <emphasis role="bold">time '16:00'</emphasis>)</programlisting>
            <programlisting>new.lastmod = <emphasis role="bold">timestamp 'now'</emphasis>;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Note</title>
        <para>Please be advised that these shorthand expressions are evaluated immediately at parse
        time and stay the same as long as the statement remains prepared. Thus, even if a query is
        executed multiple times, the value for e.g. <quote>timestamp 'now'</quote> won't change, no
        matter how much time passes. If you need the value to progress (i.e. be evaluated upon every
        call), use a full cast.</para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-cast"><database>CAST</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-case">
      <title><database>CASE</database> construct</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--KW_CASE is defined in ESQL to recognize Pascal case constructs. No support for SQL CASE found.-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A <database>CASE</database> construct returns exactly one value from a number of
        possibilities. There are two syntactic variants:<itemizedlist spacing="compact">
            <listitem>
              <para>The simple <database>CASE</database>, comparable to a Pascal <code>case</code>
              or a C <code>switch</code>.</para>
            </listitem>
            <listitem>
              <para>The searched <database>CASE</database>, which works like a series of
              <quote><code>if ... else if ... else if</code></quote> clauses.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <section id="langrefupd25-case-simple">
        <title>Simple <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE <replaceable>&lt;test-expr&gt;</replaceable>
   WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>result</replaceable>
   [WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>result</replaceable> ...]
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>When this variant is used, <replaceable>&lt;test-expr&gt;</replaceable> is compared to
        <replaceable>&lt;expr&gt;</replaceable> 1, <replaceable>&lt;expr&gt;</replaceable> 2 etc.,
        until a match is found, upon which the corresponding result is returned. If there is no
        match and there is an <database>ELSE</database> clause,
        <replaceable>defaultresult</replaceable> is returned. If there is no match and no
        <database>ELSE</database> clause, <constant>NULL</constant> is returned.</para>
        <para>The match is determined with the <quote>=</quote> operator, so if
        <replaceable>&lt;test-expr&gt;</replaceable> is <constant>NULL</constant>, it won't match
        any of the <replaceable>&lt;expr&gt;</replaceable>s, not even those that are
        <constant>NULL</constant>.</para>
        <para>The results don't have to be literal values: they may also be field or variable names,
        compound expressions, or <constant>NULL</constant> literals.</para>
        <para>A shorthand form of the simple <database>CASE</database> construct is the <link
        linkend="langrefupd25-intfunc-decode"><database>DECODE()</database></link> function,
        available since Firebird 2.1.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select name,
       age,
       case upper(sex)
         when 'M' then 'Male'
         when 'F' then 'Female'
         else 'Unknown'
       end,
       religion
from people</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-case-searched">
        <title>Searched <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE
   WHEN <replaceable>&lt;bool_expr&gt;</replaceable> THEN <replaceable>result</replaceable>
   [WHEN <replaceable>&lt;bool_expr&gt;</replaceable> THEN <replaceable>result</replaceable> ...]
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Here, the <replaceable>&lt;bool_expr&gt;</replaceable>s are tests that give a ternary
        boolean result: <constant>TRUE</constant>, <constant>FALSE</constant>, or
        <constant>NULL</constant>. The first expression evaluating to <constant>TRUE</constant>
        determines the result. If no expression is <constant>TRUE</constant> and there is an
        <database>ELSE</database> clause, <replaceable>defaultresult</replaceable> is returned. If
        no expression is <constant>TRUE</constant> and there is no <database>ELSE</database> clause,
        <constant>NULL</constant> is returned.</para>
        <para>As with the simple <database>CASE</database>, the results don't have to be literal
        values: they may also be field or variable names, compound expressions, or
        <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>CanVote = case
            when Age &gt;= 18 then 'Yes'
            when Age &lt;  18 then 'No'
            else 'Unsure'
          end;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd25-datatypes">
    <title>Data types and subtypes</title>
    <section id="langrefupd25-bigint">
      <title><database>BIGINT</database> data type</title>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BIGINT</database> is the SQL99-compliant 64-bit signed integer type. It is
        available in Dialect 3 only.</para>
      </formalpara>
      <para><database>BIGINT</database> numbers range from -2<superscript>63</superscript> ..
      2<superscript>63</superscript>-1, or -9,223,372,036,854,775,808 ..
      9,223,372,036,854,775,807.</para>
      <para>Since Firebird 2.5, <database>BIGINT</database> numbers may be entered in hexadecimal
      form, with 9–16 hex digits. Shorter hex numerals are interpreted as
      <database>INTEGER</database>s.</para>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>create table WholeLottaRecords (
  id bigint not null primary key,
  description varchar(32)
)</programlisting>
            <programlisting>insert into MyBigints values (
  -236453287458723,
  328832607832,
  22,
  -56786237632476,
  0x6F55A09D42,                   -- 478177959234
  0X7FFFFFFFFFFFFFFF,             -- 9223372036854775807
  0xffffffffffffffff,             -- -1
  0x80000000,                     -- -2147483648, an <database>INTEGER</database>
  0x080000000,                    -- 2147483648, a <database>BIGINT</database>
  0XFFFFFFFF,                     -- -1, an <database>INTEGER</database>
  0X0FFFFFFFF                     -- 4294967295, a <database>BIGINT</database>
)</programlisting>
            <para>The hexadecimal <database>INTEGER</database>s in the second example will be
            automatically cast to <database>BIGINT</database> before insertion into the table.
            However, this happens <emphasis>after</emphasis> the numerical value has been
            established, so <literal>0x80000000</literal> (8 digits) and
            <literal>0x080000000</literal> (9 digits) will be stored as different values. For more
            information on this difference, see <link
            linkend="langrefupd25-hexnumerals"><citetitle>Hexadecimal notation for
            numerals</citetitle></link>, in particular the paragraph <link
            linkend="langrefupd25-hexnumerals-valueranges"><citetitle>Value
            ranges</citetitle></link>.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-blob">
      <title><database>BLOB</database> data type</title>
      <section id="langrefupd25-blob-func-op-support">
        <title>Text <database>BLOB</database> support in functions and operators</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.1, 2.1.5, 2.5.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Text <database>BLOB</database>s of any length and character set (including
          multi-byte sets) are now supported by practically every internal text function and
          operator. In a few cases there are limitations or bugs.</para>
        </formalpara>
        <formalpara>
          <title>Level of support</title>
          <para><itemizedlist>
              <listitem>
                <para>Full support for:</para>
                <itemizedlist spacing="compact">
                  <listitem>
                    <para><literal>=</literal> (assignment);</para>
                  </listitem>
                  <listitem>
                    <para><literal>=</literal>, <literal>&lt;&gt;</literal>,
                    <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal>,
                    <literal>&gt;=</literal> and synonyms (comparison);</para>
                  </listitem>
                  <listitem>
                    <para><literal>||</literal> (concatenation);</para>
                  </listitem>
                  <listitem>
                    <para><database>BETWEEN</database>, <database>IS [NOT] DISTINCT FROM</database>,
                    <database>IN</database>, <database>ANY</database>|<database>SOME</database> and
                    <database>ALL</database>.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>Support for <database>STARTING [WITH]</database>, <database>LIKE</database>
                and <database>CONTAINING</database>:</para>
                <itemizedlist spacing="compact">
                  <listitem>
                    <para>In versions 2.1–2.1.4 and 2.5, an error is raised if the second operand is
                    32 KB or longer, or if the first operand is a <database>BLOB</database> with
                    character set <database>NONE</database> and the second operand is a
                    <database>BLOB</database> of any length and character set.</para>
                    <!--CORE-3233, and yes, it's 32K *bytes*, not *characters*
Fixed by Dmitry 17/18 Feb 2011, for 2.1.5, 2.5.1, 3.0 a1-->
                  </listitem>
                  <listitem>
                    <para>In versions 2.5.1 and up (as well as 2.1.5 and up in the 2.1 branch), each
                    operand can be a <database>BLOB</database> of any length and character
                    set.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para><database>SELECT DISTINCT</database>, <database>ORDER BY</database> and
                <database>GROUP BY</database> work on the <database>BLOB</database> ID, not the
                contents. This makes them as good as useless, except that <database>SELECT
                DISTINCT</database> weeds out multiple <constant>NULL</constant>s, if present.
                <database>GROUP BY</database> behaves oddly in that it groups together equal rows if
                they are adjacent, but not if they are apart.<!--CORE-3252
Explanation: For GROUP BY, BLOBs are first ordered on *ID*. Then, the *actual* BLOB content is compared.
As a result, it groups on equal content only if the rows are contiguous (ID-wise).--></para>
              </listitem>
              <listitem>
                <para>Any issues with <database>BLOB</database>s in <link
                linkend="langrefupd25-intfunc">internal functions</link> and <link
                linkend="langrefupd25-aggrfunc">aggregate functions</link> are discussed in their
                respective sections.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-blob-various">
        <title>Various enhancements</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0, several enhancements have been implemented for text
          <database>BLOB</database>s:<itemizedlist>
              <listitem>
                <para>DML <database>COLLATE</database> clauses are now supported.</para>
              </listitem>
              <listitem>
                <para>Equality comparisons can be performed on the full <database>BLOB</database>
                contents.</para>
              </listitem>
              <listitem>
                <para>Character set conversions are possible when assigning a
                <database>BLOB</database> to a <database>BLOB</database> or a string to a
                <database>BLOB</database>.</para>
              </listitem>
            </itemizedlist>When defining binary <database>BLOB</database>s, the mnemonic
          <constant>binary</constant> can now be used instead of the integer 0.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
              <programlisting>create table MyPictures (
  id int not null primary key,
  title varchar(40),
  description varchar(200),
  picture blob sub_type binary
)</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-sqlnull">
      <title><database>SQL_NULL</database> data type</title>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
        <!--CORE-2298-->
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>SQL_NULL</database> data type is of little or no interest to end users.
        It can hold no data, only a state: <database>NULL</database> or <database>NOT
        NULL</database>. It is also not possible to declare columns, variables or PSQL parameters of
        type <database>SQL_NULL</database>. At present, its only purpose is to support the <quote>?
        <database>IS</database> <database>NULL</database></quote> syntax in SQL statements with
        positional parameters. Application developers can make use of this when constructing queries
        that contain one or more optional filter terms.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>If a statement containing the following predicate is prepared:<blockquote>
            <programlisting>? <replaceable>&lt;op&gt;</replaceable> NULL</programlisting>
            <!--ATTN: In PDF output, no vertical space appears here!-->
          </blockquote>Firebird will describe the parameter ('?') as being of type
        <database>SQL_NULL</database>. <replaceable>&lt;op&gt;</replaceable> can be any comparison
        operator, but the only one that makes sense in practice is
        <quote><database>IS</database></quote> (and possibly, in some rare cases,
        <quote><database>NOT IS</database></quote>).</para>
      </formalpara>
      <section id="langrefupd25-sqlnull-rationale">
        <title>Rationale</title>
        <para>In itself, having a query with a <quote><database>WHERE ? IS NULL</database></quote>
        clause doesn't make a lot of sense. You could use such a parameter as an on/off switch, but
        that hardly warrants inventing a whole new datataype. After all, such switches can also be
        constructed with a <database>CHAR</database>, <database>SMALLINT</database> or other
        parameter type. The reason for adding the <database>SQL_NULL</database> type is that
        developers of applications, connectivity toolsets, drivers etc. want to be able to support
        queries with optional filters like these:</para>
        <blockquote>
          <para><programlisting>select make, model, weight, price, in_stock from automobiles
  where (make = :make or :make is null)
    and (model = :model or :model is null)
    and (price &lt;= :maxprice or :maxprice is null)</programlisting></para>
        </blockquote>
        <para>The idea is that the end user can optionally enter choices for the parameters
        <parameter>:make</parameter>, <parameter>:model</parameter> and
        <parameter>:maxprice</parameter>. Wherever a choice is entered, the corresponding filter
        should be applied. Wherever a parameter is left unset (<constant>NULL</constant>), there
        should be no filtering on that attribute. If all are unset, the entire table
        <database>AUTOMOBILES</database> should be shown.</para>
        <para>Unfortunately, named parameters like <parameter>:make</parameter> and
        <parameter>:model</parameter> only exist on the application level. Before the query is
        passed to Firebird for preparation, it must be converted to this form:</para>
        <blockquote>
          <para><programlisting>select make, model, weight, price, in_stock from automobiles
  where (make = ? or ? is null)
    and (model = ? or ? is null)
    and (price &lt;= ? or ? is null)</programlisting></para>
        </blockquote>
        <para>Instead of three named parameters, each occurring twice, we now have six positional
        parameters. There is <emphasis>no way</emphasis> that Firebird can tell whether some of them
        actually refer to the same application-level variable. (The fact that, in this example, they
        happen to be within the same pair of parentheses doesn't mean anything.) This in turn means
        that Firebird also cannot determine the <emphasis>data type</emphasis> of the <quote>? is
        null</quote> parameters. This last problem could be solved by casting:</para>
        <blockquote>
          <para><programlisting>select make, model, weight, price, in_stock from automobiles
  where (make = ? or cast(? as type of column automobiles.make) is null)
    and (model = ? or cast(? as type of column automobiles.model) is null)
    and (price &lt;= ? or cast(? as type of column automobiles.price) is null)</programlisting></para>
        </blockquote>
        <para>...but this is rather cumbersome. And there is another issue: wherever a filter term
        is <emphasis>not</emphasis> <constant>NULL</constant>, its value will be passed twice to the
        server: once in the parameter that is compared against the table column, and once in the
        parameter that is tested for <constant>NULL</constant>. This is a bit of a waste. But the
        only alternative is to set up no less then <emphasis>eight</emphasis> separate queries (2 to
        the power of the number of optional filters), which is even more of a headache. Hence the
        decision to implement a dedicated <database>SQL_NULL</database> datatype.</para>
      </section>
      <section id="langrefupd25-sqlnull-use">
        <title>Use in practice</title>
        <para><emphasis>Notice: The following discussion assumes familiarity with the Firebird API
        and the passing of parameters via <type>XSQLVAR</type> structures. Readers without this
        knowledge won't have to deal with the <database>SQL_NULL</database> datatype anyway and can
        skip this section.</emphasis></para>
        <para>As usual, the application passes the parameterized query in <literal>?</literal>-form
        to the server. It is not possible to merge pairs of <quote>identical</quote> parameters into
        one. So, for e.g. two optional filters, four positional parameters are needed:</para>
        <blockquote>
          <para><programlisting>select size, colour, price from shirts
  where (size = ? or ? is null)
  and (colour = ? or ? is null)</programlisting></para>
        </blockquote>
        <para>After the call to <function>isc_dsql_describe_bind()</function>, the
        <varname>sqltype</varname> of the 2nd and 4th parameter will be set to
        <database>SQL_NULL</database>. As said, Firebird has no knowledge of their special relation
        with the 1st and 3d parameter – this is entirely the responsibility of the programmer. Once
        the values for size and colour have been set (or left unset) by the user and the query is
        about to be executed, each pair of <varname>XSQLVAR</varname>s must be filled as
        follows:</para>
        <variablelist>
          <varlistentry>
            <term>User has filled in a value</term>
            <listitem>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>First parameter (value compare): set <varname>*sqldata</varname> to the
                  supplied value and <varname>*sqlind</varname> to 0 (for <database>NOT
                  NULL</database>);</para>
                </listitem>
                <listitem>
                  <para>Second parameter (<database>NULL</database> test): set
                  <varname>sqldata</varname> to null (null pointer, not SQL
                  <database>NULL</database>) and <varname>*sqlind</varname> to 0 (for <database>NOT
                  NULL</database>).</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>User has left the field blank</term>
            <listitem>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>Both parameters: set <varname>sqldata</varname> to null (null pointer, not
                  SQL <database>NULL</database>) and <varname>*sqlind</varname> to -1 (indicating
                  <database>NULL</database>).</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>In other words: The value compare parameter is always set as usual. The
        <database>SQL_NULL</database> parameter is set the same, except that
        <varname>sqldata</varname> remains null at all times.</para>
      </section>
    </section>
    <section id="langrefupd25-charsets">
      <title>New character sets</title>
      <!--2.1: All charsets/collations in fbintl.conf are also predeclared in RDB$CHARACTER_SETS/COLLATIONS,
with the exception of the _UNICODE collations.
Format of an fbintl.conf entry:
  <charset      NAME>
    intl_module fbintl
    collation   NAME [REAL-NAME]
  </charset>
Only one collation has REAL-NAME set:
  <charset CP943C>
    intl_module fbintl
    collation CP943C ibm-943_P15A-2003
    collation CP943C_UNICODE
  </charset>
In rdb$collations, this collation is registered as CP943C-->
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5, 2.0, 2.1, 2.5</para>
      </formalpara>
      <para>The following table lists the character sets added in Firebird.</para>
      <table id="langrefupd25-tbl-charsets">
        <title>Character sets new in Firebird</title>
        <tgroup cols="4">
          <colspec colname="colName" colwidth="2*" />
          <colspec colname="colBytes" colwidth="*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Name</entry>
              <entry align="center">Max bytes/ch.</entry>
              <entry align="center">Languages</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>CP943C</entry>
              <entry>2</entry>
              <entry>Japanese</entry>
              <entry>2.1</entry>
            </row>
            <row>
              <entry>DOS737</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS775</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS858</entry>
              <entry>1</entry>
              <entry>= DOS850 plus € sign</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS862</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS864</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS866</entry>
              <entry>1</entry>
              <entry>Russian</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS869</entry>
              <entry>1</entry>
              <entry>Modern Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>GB18030</entry>
              <entry>4</entry>
              <entry>Chinese</entry>
              <entry>2.5</entry>
            </row>
            <row>
              <entry>GBK</entry>
              <entry>2</entry>
              <entry>Chinese</entry>
              <entry>2.1</entry>
            </row>
            <row>
              <entry>ISO8859_2</entry>
              <entry>1</entry>
              <entry>Latin-2, Central European</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO8859_3</entry>
              <entry>1</entry>
              <entry>Latin-3, Southern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_4</entry>
              <entry>1</entry>
              <entry>Latin-4, Northern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_5</entry>
              <entry>1</entry>
              <entry>Cyrillic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_6</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_7</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_8</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_9</entry>
              <entry>1</entry>
              <entry>Latin-5, Turkish</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>1</entry>
              <entry>Latin-7, Baltic Rim</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>KOI8R</entry>
              <entry>1</entry>
              <entry>Russian</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>KOI8U</entry>
              <entry>1</entry>
              <entry>Ukrainian</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>TIS620</entry>
              <entry>1</entry>
              <entry>Thai</entry>
              <entry>2.1</entry>
            </row>
            <row>
              <entry>UTF8 <footnote label="(*)">
                  <para>In Firebird 1.5, <database>UTF8</database> is an alias for
                  <database>UNICODE_FSS</database>. This character set has some inherent problems.
                  In Firebird 2, <database>UTF8</database> is a character set in its own right,
                  without the drawbacks of <database>UNICODE_FSS</database>.</para>
                </footnote></entry>
              <entry>4</entry>
              <entry>All</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1255</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1256</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1257</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1258</entry>
              <entry>1</entry>
              <entry>Vietnamese</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN_1258 (alias for WIN1258)</entry>
              <entry>1</entry>
              <entry>Vietnamese</entry>
              <entry>2.5</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd25-charset-none">
      <title>Character set <database>NONE</database> handling changed</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
        moved to and from fields or variables with another character set, resulting in fewer
        transliteration errors. For more details, see the <link
        linkend="langrefupd25-notes-charset-none">Note</link> at the end of the book.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-collations">
      <title>New collations</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5, 1.5.1, 2.0, 2.1, 2.5</para>
      </formalpara>
      <para>The following table lists the collations added in Firebird. The <quote>Details</quote>
      column is based on what has been reported in the Release Notes and other documents. The
      information in this column is probably incomplete; some collations with an empty Details field
      may still be case insensitive (ci), accent insensitive (ai) or dictionary-sorted (dic).</para>
      <para>Please note that the default – binary – collations for new character sets are not listed
      here, as doing so would add no meaningful information.</para>
      <table id="langrefupd25-tbl-collations">
        <title>Collations new in Firebird</title>
        <tgroup cols="5">
          <colspec colname="colCharset" colwidth="2*" />
          <colspec colname="colCollation" colwidth="2*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colDetails" colwidth="*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Character set</entry>
              <entry align="center">Collation</entry>
              <entry align="center">Language</entry>
              <entry align="center">Details</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>CP943C</entry>
              <entry>CP943C_UNICODE</entry>
              <entry>Japanese</entry>
              <entry></entry>
              <entry>2.1</entry>
            </row>
            <row>
              <entry>GB18030</entry>
              <entry>GB18030_UNICODE</entry>
              <entry>Chinese</entry>
              <entry></entry>
              <entry>2.5</entry>
            </row>
            <row>
              <entry>GBK</entry>
              <entry>GBK_UNICODE</entry>
              <entry>Chinese</entry>
              <entry></entry>
              <entry>2.1</entry>
            </row>
            <row valign="top">
              <entry morerows="2">ISO8859_1</entry>
              <entry>ES_ES_CI_AI</entry>
              <entry>Spanish</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>FR_FR_CI_AI</entry>
              <entry>French</entry>
              <entry>ci, ai</entry>
              <entry>2.1</entry>
            </row>
            <row>
              <entry>PT_BR</entry>
              <entry>Brazilian Portuguese</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row valign="top">
              <entry morerows="2">ISO8859_2</entry>
              <entry>CS_CZ</entry>
              <entry>Czech</entry>
              <entry></entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO_HUN</entry>
              <entry>Hungarian</entry>
              <entry></entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO_PLK</entry>
              <entry>Polish</entry>
              <entry></entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>LT_LT</entry>
              <entry>Lithuanian</entry>
              <entry></entry>
              <entry>1.5.1</entry>
            </row>
            <row valign="top">
              <entry morerows="3">UTF8</entry>
              <entry>UCS_BASIC</entry>
              <entry>All</entry>
              <entry></entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>UNICODE</entry>
              <entry>All</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>UNICODE_CI</entry>
              <entry>All</entry>
              <entry>ci</entry>
              <entry>2.1</entry>
            </row>
            <row>
              <entry>UNICODE_CI_AI</entry>
              <entry>All</entry>
              <entry>ci, ai</entry>
              <entry>2.5</entry>
            </row>
            <row valign="top">
              <entry morerows="3">WIN1250</entry>
              <entry>BS_BA</entry>
              <entry>Bosnian</entry>
              <entry></entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>PXW_HUN</entry>
              <entry>Hungarian</entry>
              <entry>ci</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>WIN_CZ</entry>
              <entry>Czech</entry>
              <entry>ci</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN_CZ_CI_AI</entry>
              <entry>Czech</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1251</entry>
              <entry>WIN1251_UA</entry>
              <entry>Ukrainian and Russian</entry>
              <entry></entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1252</entry>
              <entry>WIN_PTBR</entry>
              <entry>Brazilian Portuguese</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row valign="top">
              <entry morerows="2">WIN1257</entry>
              <entry>WIN1257_EE</entry>
              <entry>Estonian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1257_LT</entry>
              <entry>Lithuanian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1257_LV</entry>
              <entry>Latvian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>KOI8R</entry>
              <entry>KOI8R_RU</entry>
              <entry>Russian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>KOI8U</entry>
              <entry>KOI8U_UA</entry>
              <entry>Ukrainian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>TIS620</entry>
              <entry>TIS620_UNICODE</entry>
              <entry>Thai</entry>
              <entry></entry>
              <entry>2.1</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note>
        <title>A note on the UTF8 collations</title>
        <para>The <database>UCS_BASIC</database> collation sorts in Unicode code-point order: A, B,
        a, b, á... This is exactly the same as <database>UTF8</database> with no collation
        specified. <database>UCS_BASIC</database> was added to comply with the SQL standard.</para>
        <para>The <database>UNICODE</database> collation sorts using UCA (Unicode Collation
        Algorithm): a, A, á, b, B...</para>
        <para><database>UNICODE_CI</database> is truly case-insensitive. In a search for e.g.
        'Apple', it will also find 'apple', 'APPLE' and 'aPPLe'.</para>
        <para><database>UNICODE_CI_AI</database> is accent-insensitive as well. According to this
        collation, 'APPEL' equals 'Appèl'.</para>
      </note>
      <!--RlsNotes:
  Collation Changes in V.2.1
  Spanish
  ES_ES (as well as the new ES_ES_CI_AI) collation automatically uses attributes
  DISABLE-COMPRESSIONS=1;SPECIALS-FIRST=1.
  Note: The attributes are stored at database creation time, so the changes do not
  apply to databases with ODS < 11.1.
  The ES_ES_CI_AI collation was standardised to current usage.

So:
- was ES_ES changed or not?
- was ES_ES_CI_AI (BTW, *not* new in 2.1) changed in 2.1 or not?-->
      <section id="langrefupd25-collations-unicode">
        <title>Unicode collations for all character sets</title>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <para>Firebird now comes with <database>UNICODE</database> collations for all the standard
        character sets. However, except for the ones listed in the <link
        linkend="langrefupd25-tbl-collations">new collations table</link> in the previous section,
        these collations are not automatically available in your databases. Instead, they must be
        added with the <database>CREATE COLLATION</database> statement, like this:</para>
        <blockquote>
          <programlisting>create collation ISO8859_1_UNICODE for ISO8859_1</programlisting>
        </blockquote>
        <para>The new Unicode collations all have the name of their character set with
        <database>_UNICODE</database> added. (The built-in Unicode collations for
        <database>UTF8</database> are the exception to the rule.) They are defined, along with the
        other collations, in the manifest file <filename>fbintl.conf</filename> in Firebird's
        <filename class="directory">intl</filename> subdirectory.</para>
        <para>Collations may also be registered under a user-chosen name, e.g.:</para>
        <blockquote>
          <programlisting>create collation <emphasis role="bold">LAT_UNI</emphasis> for ISO8859_1 from external ('ISO8859_1_UNICODE')</programlisting>
        </blockquote>
        <para>See <link linkend="langrefupd25-ddl-collation-create"><database>CREATE
        COLLATION</database></link> for the full syntax.</para>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd25-ddl">
    <title>DDL statements</title>
    <para>The statements in this chapter are grouped by the type of database object they operate on.
    For instance, <database>ALTER DATABASE</database>, <database>CREATE DATABASE</database> and
    <database>DROP DATABASE</database> are all found under
    <citetitle><database>DATABASE</database></citetitle>; <database>DECLARE EXTERNAL
    FUNCTION</database> and <database>ALTER EXTERNAL FUNCTION</database> are under
    <citetitle><database>EXTERNAL FUNCTION</database></citetitle>; etc.</para>
    <section id="langrefupd25-ddl-charset">
      <title><database>CHARACTER SET</database></title>
      <section id="langrefupd25-ddl-charset-alter">
        <title><database>ALTER CHARACTER SET</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--and ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>With <database>ALTER CHARACTER SET</database>, the default collation of a character
          set can be changed. This will affect all future usage of the character set, except where
          overridden by an explicit <database>COLLATE</database> clause. The collation of existing
          domains, columns and PSQL variables will not be changed.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER CHARACTER SET <replaceable>charset</replaceable> SET DEFAULT COLLATION <replaceable>collation</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter character set utf8 set default collation unicode_ci_ai</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>If you use <database>SET DEFAULT COLLATION</database> on the default character
                set of the database, you have effectively set (or overridden) the default collation
                for the database.</para>
              </listitem>
              <listitem>
                <para>If you use <database>SET DEFAULT COLLATION</database> on the connection
                character set, string constants will be interpreted according to the new default
                collation (unless character set and/or collation are overridden). In most
                situations, this will make no difference, but comparisons may have another outcome
                if the collation changes.</para>
                <!--Maybe add an example.-->
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-ddl-collation">
      <title><database>COLLATION</database></title>
      <section id="langrefupd25-ddl-collation-create">
        <title><database>CREATE COLLATION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--and ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Adds a collation to the database. The collation must already be present on your
          system (typically in a library file) and must be properly registered in a <filename
          class="extension">.conf</filename> file in the <filename class="directory">intl</filename>
          subdirectory of your Firebird installation. You may also base the collation on one that is
          already present in the database.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE COLLATION <replaceable>collname</replaceable>
   FOR <replaceable>charset</replaceable>
   [FROM <replaceable>basecoll</replaceable> | FROM EXTERNAL ('<replaceable>extname</replaceable>')]
   [NO PAD | PAD SPACE]
   [CASE [IN]SENSITIVE]
   [ACCENT [IN]SENSITIVE]
   ['<replaceable>&lt;specific-attributes&gt;</replaceable>']

<replaceable>collname</replaceable>               ::=  the name to use for the new collation
<replaceable>charset</replaceable>                ::=  a character set present in the database
<replaceable>basecoll</replaceable>               ::=  a collation already present in the database
<replaceable>extname</replaceable>                ::=  the collation name used in the .conf file
<replaceable>&lt;specific-attributes&gt;</replaceable>  ::=  <replaceable>&lt;attribute&gt;</replaceable> [; <replaceable>&lt;attribute&gt;</replaceable> ...]
<replaceable>&lt;attribute&gt;</replaceable>            ::=  <replaceable>attrname</replaceable>=<replaceable>attrvalue</replaceable></programlisting>
              <itemizedlist>
                <listitem>
                  <para>If no <database>FROM</database> clause is present, Firebird will scan the
                  <filename class="extension">.conf</filename> file(s) in your <filename
                  class="directory">intl</filename> subdirectory for a collation with the name
                  specified after <database>CREATE COLLATION</database>. That is, omitting the
                  <database>FROM</database> clause is the same as specifying <quote><database>FROM
                  EXTERNAL</database> ('<replaceable>collname</replaceable>')</quote>.</para>
                </listitem>
                <listitem>
                  <para>The single-quoted <replaceable>extname</replaceable> is case-sensitive and
                  must be exactly equal to the collation name in the <filename
                  class="extension">.conf</filename> file. The <replaceable>collname</replaceable>,
                  <replaceable>charset</replaceable> and <replaceable>basecoll</replaceable>
                  parameters are case-insensitive, unless surrounded by double-quotes.</para>
                </listitem>
              </itemizedlist>
            </blockquote><!--In RDB$COLLATION_ATTRIBUTES:
no pad 0
pad space 1
case sensitive 0
case insensitive 2
accent sensitive 0
accent insensitive:
  create collation lat_uni_ai for iso8859_1 
    from external ('ISO8859_1_UNICODE') accent insensitive
  Message: isc_dsql_execute2 failed

  SQL Message : -607
  This operation is not defined for system tables.

  Engine Code    : 335544351
  Engine Message :
  unsuccessful metadata update
  Invalid collation attributes

But this works:
create collation spa_ai for iso8859_1
    from external ('ES_ES') accent insensitive
RDB$COLLATION_ATTRIBUTES = 4--></para>
        </formalpara>
        <formalpara>
          <title>Specific attributes</title>
          <para>The table below lists the available specific attributes. Not all specific attributes
          apply to every collation, even if specifying them doesn't cause an error. Please note that
          specific attributes are case sensitive. In the table below, <quote><emphasis>1
          bpc</emphasis></quote> indicates that an attribute is valid for collations of character
          sets using 1 byte per character (so-called <firstterm>narrow character sets</firstterm>).
          <quote><emphasis>UNI</emphasis></quote> stands for <quote>UNICODE
          collations</quote>.</para>
          <!--Email 11-6-2011: Adriano dos Santos Fernandes confirms that this means UNICODE collations in general:
with or without _CI, _AI, and for all character sets, not just UTF8.-->
        </formalpara>
        <table id="langrefupd25-tbl-speccollattrs">
          <title>Specific collation attributes</title>
          <tgroup cols="4">
            <colspec colname="colName" colwidth="2*" />
            <colspec colname="colValues" colwidth="1*" />
            <colspec colname="colValidFor" colwidth="1*" />
            <colspec colname="colComment" colwidth="4*" />
            <thead>
              <row>
                <entry align="center">Name</entry>
                <entry align="center">Values</entry>
                <entry align="center">Valid for</entry>
                <entry align="center">Comment</entry>
              </row>
            </thead>
            <tbody valign="top">
              <row>
                <entry>DISABLE-COMPRESSIONS</entry>
                <entry>0, 1</entry>
                <entry>1 bpc</entry>
                <entry>Disables compressions (aka contractions). Compressions cause certain
                character sequences to be sorted as atomic units, e.g. Spanish
                <literal>c</literal>+<literal>h</literal> as a single character
                <literal>ch</literal>.</entry>
              </row>
              <row>
                <entry>DISABLE-EXPANSIONS</entry>
                <entry>0, 1</entry>
                <entry>1 bpc</entry>
                <entry>Disables expansions. Expansions cause certain characters (e.g. ligatures or
                umlauted vowels) to be treated as character sequences and sorted
                accordingly.</entry>
              </row>
              <row>
                <entry>ICU-VERSION</entry>
                <entry><literal>default</literal> or
                <replaceable>M</replaceable>.<replaceable>m</replaceable></entry>
                <entry>UNI</entry>
                <entry>Specifies the ICU library version to use. Valid values are the ones defined
                in the applicable <sgmltag class="starttag">intl_module</sgmltag> element in
                <filename>intl/fbintl.conf</filename>. Format: either the string literal
                <quote><literal>default</literal></quote> or a major+minor version number like
                <quote>3.0</quote> (both unquoted).</entry>
              </row>
              <row>
                <entry>LOCALE</entry>
                <entry><replaceable>xx</replaceable>_<replaceable>YY</replaceable></entry>
                <entry>UNI</entry>
                <entry>Specifies the collation locale. Requires complete version of ICU libraries.
                Format: a locale string like <quote><literal>du_NL</literal></quote>
                (unquoted).</entry>
              </row>
              <row>
                <entry>MULTI-LEVEL</entry>
                <entry>0, 1</entry>
                <entry>1 bpc</entry>
                <entry>Uses more than one ordering level.</entry>
              </row>
              <row>
                <entry>NUMERIC-SORT</entry>
                <entry>0, 1</entry>
                <entry>UNI</entry>
                <entry>Treats contiguous groups of decimal digits in the string as atomic units and
                sorts them numerically. (This is also known as <firstterm>natural
                sorting</firstterm>.)</entry>
              </row>
              <row>
                <entry>SPECIALS-FIRST</entry>
                <entry>0, 1</entry>
                <entry>1 bpc</entry>
                <entry>Orders special characters (spaces, symbols etc.) before alphanumeric
                characters.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para><emphasis>Note:</emphasis> The <database>NUMERIC-SORT</database> specific attribute
        was added in Firebird 2.5.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Simplest form, using the name as found in the <filename
              class="extension">.conf</filename> file (case-insensitive):</para>
              <programlisting>create collation iso8859_1_unicode for iso8859_1</programlisting>
              <para>Using a custom name. Notice how the <quote>external</quote> name must now
              <emphasis>exactly</emphasis> match the name in the <filename
              class="extension">.conf</filename> file:</para>
              <programlisting>create collation lat_uni
  for iso8859_1
  from external ('ISO8859_1_UNICODE')</programlisting>
              <para>Based on a collation already present in the database:</para>
              <programlisting>create collation es_es_nopad_ci
  for iso8859_1
  from es_es
  no pad
  case insensitive</programlisting>
              <para>With a special attribute (case-sensitive!):</para>
              <programlisting>create collation es_es_ci_compr
  for iso8859_1
  from es_es
  case insensitive
  'DISABLE-COMPRESSIONS=0'</programlisting>
            </blockquote></para>
        </formalpara>
        <tip>
          <para>If you want to add a new character set with its default collation in your database,
          declare and run the stored procedure <function>sp_register_character_set(name,
          max_bytes_per_character)</function>, found in <filename>misc/intl.sql</filename> under
          your Firebird installation directory. Please note: in order for this to work, the
          character set must be present on your system and registered in a <filename
          class="extension">.conf</filename> file in the <filename class="directory">intl</filename>
          subdirectory.</para>
        </tip>
      </section>
      <section id="langrefupd25-ddl-collation-drop">
        <title><database>DROP COLLATION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--and ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Removes a collation from the database. Only user-added collations can be removed in
          this way.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DROP COLLATION <replaceable>name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <tip>
          <para>If you want to remove an entire character set with all its collations from your
          database, declare and run the stored procedure
          <function>sp_unregister_character_set(name)</function>, found in
          <filename>misc/intl.sql</filename> under your Firebird installation directory.</para>
          <!--This procedure, when executed on a system charset, succeeds, but a subsequent
COMMIT fails:

  SQL Message : -204
  Undefined name

  Engine Code    : 335544568
  Engine Message :
  Implementation of text subtype 66 not located.

66 being the charset ID here.

Maybe this too only works with user-added sets?-->
        </tip>
      </section>
    </section>
    <section id="langrefupd25-ddl-comment">
      <title><database>COMMENT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Allows you to enter comments for metadata objects. The comments will be stored in the
        various <database>RDB$DESCRIPTION</database> text <database>BLOB</database> fields in the
        system tables, from where client applications can pick them up.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COMMENT ON <replaceable>&lt;object&gt;</replaceable> IS {'<replaceable>sometext</replaceable>' | NULL}

<replaceable>&lt;object&gt;</replaceable>      ::=  DATABASE
                   | <replaceable>&lt;basic-type&gt;</replaceable> <replaceable>objectname</replaceable>
                   | COLUMN <replaceable>relationname</replaceable>.<replaceable>fieldname</replaceable>
                   | PARAMETER <replaceable>procname</replaceable>.<replaceable>paramname</replaceable>

<replaceable>&lt;basic-type&gt;</replaceable>  ::=  CHARACTER SET | COLLATION | DOMAIN | EXCEPTION
                   | EXTERNAL FUNCTION | FILTER | GENERATOR | INDEX
                   | PROCEDURE | ROLE | SEQUENCE | TABLE | TRIGGER | VIEW</programlisting>
            <note>
              <para>If you enter an empty comment (<literal>''</literal>), it will end up as
              <constant>NULL</constant> in the database.</para>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>comment on database is 'Here''s where we keep all our customer records.'</programlisting>
            <programlisting>comment on table Metals is 'Also for alloys'</programlisting>
            <programlisting>comment on column Metals.IsAlloy is '0 = pure metal, 1 = alloy'</programlisting>
            <programlisting>comment on index ix_sales is 'Set inactive during bulk inserts!'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-ddl-database">
      <title><database>DATABASE</database></title>
      <section id="langrefupd25-create-database">
        <title><database>CREATE DATABASE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>CREATE {DATABASE | SCHEMA}
   ...
   [PAGE_SIZE [=] <replaceable>size</replaceable>]
   ...
   [DEFAULT CHARACTER SET <replaceable>charset</replaceable> [COLLATION <replaceable>collation</replaceable>]]
   ...
   [DIFFERENCE FILE '<replaceable>filepath</replaceable>']

<replaceable>size</replaceable>  ::=  4096 | 8192 | 16384</programlisting>
              <itemizedlist>
                <listitem>
                  <para>If the user supplies a size smaller than 4096, it will be silently converted
                  to 4096. Other numbers not equal to any of the supported sizes will be silently
                  converted to the next lower supported size.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-cr-db-pagesize16k">
          <title>16 Kb page size supported, 1 and 2 Kb deprecated</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0, 2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 1.0 has raised the maximum database page size from 8192 to 16384 bytes.
            In Firebird 2.1 and up, page sizes 1024 and 2048 are deprecated as inefficient. Firebird
            will no longer create databases with these page sizes, but it will connect to existing
            small-page databases without any problem.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-cr-db-default-collation">
          <title>Default collation for the database</title>
          <formalpara>
            <title>Added in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.5 and up, you can specify a collation with the default character
            set, as shown in the Syntax block above. If present, this collation will become the
            default collation for the default character set (and hence for the entire database,
            except where another character set is used).</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create database "colltest.fdb" default character set iso8859_1 collation du_nl</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Please notice</title>
            <para>The keyword to use here is <database>COLLATION</database>, not the usual
            <database>COLLATE</database>.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-cr-db-difffile">
          <title><database>DIFFERENCE FILE</database> parameter</title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>The <database>DIFFERENCE FILE</database> parameter was added in Firebird 2.0, but
            not documented at the time. For a full description, see <link
            linkend="langrefupd25-alter-db-add-diff"><citetitle><database>ALTER DATABASE</database>
            :: <database>ADD DIFFERENCE FILE</database></citetitle></link>.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-alter-db">
        <title><database>ALTER DATABASE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Alters a database's file organisation or toggles its <quote>safe-to-copy</quote>
          state.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER {DATABASE | SCHEMA}
   [<replaceable>&lt;add_sec_clause&gt;</replaceable> [<replaceable>&lt;add_sec_clause&gt;</replaceable> ...]]
   [ADD DIFFERENCE FILE '<replaceable>filepath</replaceable>' | DROP DIFFERENCE FILE]
   [{BEGIN | END} BACKUP]

<replaceable>&lt;add_sec_clause&gt;</replaceable>  ::=  ADD <replaceable>&lt;sec_file&gt;</replaceable> [<replaceable>&lt;sec_file&gt;</replaceable> ...]

<replaceable>&lt;sec_file&gt;</replaceable>        ::=  FILE '<replaceable>filepath</replaceable>'
                          [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]
                          [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]</programlisting>
              <para>The <database>DIFFERENCE FILE</database> and <database>BACKUP</database>
              clauses, added in Firebird 2.0, are not available in ESQL.</para>
            </blockquote></para>
        </formalpara>
        <!--Strange: in gpre/sql.cpp, under ALTER DATABASE, there is support for things not found in the
docs, like DROP LOG/CASCADE/CACHE, ADD FILE, ADD LOGFILE, an OVERFLOW keyword, BASE_NAME...
And a number of SET clauses:
  CHECK_POINT_LENGTH, NUM_LOG_BUFFERS, LOG_BUFFER_SIZE, GROUP_COMMIT_WAIT_TIME-->
        <section id="langrefupd25-alter-db-begin-backup">
          <title><database>BEGIN BACKUP</database></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Freezes the main database file so that it can be backed up safely by filesystem
            means, even while users are connected and perform operations on the data. Any mutations
            to the database will be written to a separate file, the <firstterm>delta
            file</firstterm>. Contrary to what the syntax suggests, this statement does
            <emphasis>not</emphasis> initiate the backup itself; it merely creates the
            conditions.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter database begin backup</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-db-end-backup">
          <title><database>END BACKUP</database></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Merges the delta file back into the main database file and restores the normal
            state of operation, thus closing the time window during which safe backups could be made
            via the filesystem. (Safe backups with <application>gbak</application> are still
            possible.)</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter database end backup</programlisting>
              </blockquote></para>
          </formalpara>
          <tip>
            <para>Instead of <database>BEGIN</database> and <database>END BACKUP</database>,
            consider using Firebird's <application>nbackup</application> tool: it can freeze and
            unfreeze the main database file as well as make full and incremental backups. A manual
            for nbackup is available via the <ulink
            url="http://www.firebirdsql.org/en/documentation/">Firebird Documentation
            Index</ulink>.</para>
          </tip>
        </section>
        <section id="langrefupd25-alter-db-add-diff">
          <title><database>ADD DIFFERENCE FILE</database></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Presets path and name of the delta file to which mutations are written when the
            database goes into <quote>copy-safe</quote> mode after an <database>ALTER DATABASE BEGIN
            BACKUP</database> command.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter database add difference file 'C:\Firebird\Databases\Fruitbase.delta'</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>This statement doesn't really add any file. It just overrides the default
                  path and name for the delta file that will be created if and when the database
                  enters copy-safe mode.</para>
                </listitem>
                <listitem>
                  <para>If you provide a relative path or a bare filename here, it will be appended
                  to the current directory as seen from the server. On Windows, this is often the
                  system directory.</para>
                </listitem>
                <listitem>
                  <para>If you want to change an existing setting, <link
                  linkend="langrefupd25-alter-db-drop-diff"><database>DROP</database></link> the old
                  one first and then <database>ADD</database> the new one.</para>
                </listitem>
                <listitem>
                  <para>When not overridden, the delta file gets the same path and filename as the
                  database itself, but with the extension <filename
                  class="extension">.delta</filename></para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-db-drop-diff">
          <title><database>DROP DIFFERENCE FILE</database></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Removes the delta file path and name that were previously set with <database>ALTER
            DATABASE ADD DIFFERENCE FILE</database>. This statement doesn't really drop a file. It
            only erases the preset path and/or filename that would otherwise have been used the next
            time the database went into copy-safe mode, and reverts to the default behaviour.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter database drop difference file</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
    </section>
    <section id="langrefupd25-ddl-domain">
      <title><database>DOMAIN</database></title>
      <section id="langrefupd25-create-domain">
        <title><database>CREATE DOMAIN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <section id="langrefupd25-create-domain-contextvars">
          <title>Context variables as defaults</title>
          <formalpara>
            <title>Changed in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Any context variable that is assignment-compatible to the new domain's datatype
            can be used as a default. This was already the case in InterBase 6, but the
            <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create domain DDate as
  date
  default current_date
  not null</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-alter-domain">
        <title><database>ALTER DOMAIN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <!--(for when we construct the formal syntax:)
In IB6 and Fb (tested 2.0) you cannot provide a default after ALTER DOMAIN ... TYPE-->
        <warning>
          <para>If a domain's definition is changed, existing PSQL code using that domain may become
          invalid. For information on how to detect this, please read the note <link
          linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
          <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
          document.</para>
        </warning>
        <section id="langrefupd25-alter-domain-to">
          <title>Rename domain</title>
          <formalpara>
            <title>Added in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Renaming of a domain is possible with the <database>TO</database> clause. This
            feature was introduced in InterBase 6, but left out of the <citetitle>Language
            Reference</citetitle>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter domain posint to plusint</programlisting>
                <itemizedlist>
                  <listitem>
                    <para>The <database>TO</database> clause can be combined with other clauses and
                    need not come first in that case.</para>
                  </listitem>
                </itemizedlist>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-domain-default">
          <title><database>SET DEFAULT</database> to any context variable</title>
          <formalpara>
            <title>Changed in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Any context variable that is assignment-compatible to the domain's datatype can be
            used as a default. This was already the case in InterBase 6, but the <citetitle>Language
            Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter domain DDate
  set default current_date</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
    </section>
    <section id="langrefupd25-ddl-exception">
      <title><database>EXCEPTION</database></title>
      <section id="langrefupd25-create-exception">
        <title><database>CREATE EXCEPTION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <section id="langrefupd25-create-exception-msglength">
          <title>Message length increased</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 and higher, the maximum length of the exception message has been
            raised from 78 to 1021.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create exception Ex_TooManyManagers
  'Too many managers: An attempt was made to create more managers than the
   maximum defined in the Limits table. If you really need to create more
   managers than you have now, raise the limit first. However, please consult
   your department''s manager before doing so. Otherwise, your decision may
   be overturned later and the additional manager(s) removed.'</programlisting>
              </blockquote></para>
          </formalpara>
          <note>
            <para>The maximum exception message length depends on a certain system table field.
            Therefore, pre-2.0 databases need to be backed up and restored under Firebird
            2.<replaceable>x</replaceable> before they can store exception messages of up to 1021
            bytes.</para>
          </note>
        </section>
      </section>
      <section id="langrefupd25-create-or-alter-exception">
        <title><database>CREATE OR ALTER EXCEPTION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If the exception does not yet exist, it is created just as if <database>CREATE
          EXCEPTION</database> were used. If it already exists, it is altered. Existing dependencies
          are preserved.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as for <database>CREATE EXCEPTION</database>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-recreate-exception">
        <title><database>RECREATE EXCEPTION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates or recreates an exception. If an exception with the same name already
          exists, <database>RECREATE EXCEPTION</database> will try to drop it and create a new
          exception. This wlll fail if there are existing dependencies on the exception.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <database>CREATE EXCEPTION</database>.</para>
        </formalpara>
        <note>
          <para>If you use <database>RECREATE EXCEPTION</database> on an exception that has
          dependent objects, you may not get an error message until you try to commit your
          transaction.</para>
          <!--I wonder why that is? It's not very practical. (Asked Dmitry.)
Answer (31-10-2008):
  The major part of the every DDL work is actually executed at commit. 
  Some DDL operations offer early (execute time) checks in order to be a 
  bit more friendly to the user. It seems this one is missing such a 
  check. Worth entering into the tracker.-->
        </note>
        <!--LangRef says that an exception can be dropped or altered by:
- its creator
- SYSDBA
- OS superuser
But where is the creator/owner of an exception kept? Not in rdb$exceptions...

OK, just created a new user without any privileges on whatever and he can just connect
and drop any exception (as long as there are no dependencies on it).
He can also ALTER existing exceptions that have dependencies.
Now find out how this is in Fb 1.5, 1.0 and IB6 - and DOCUMENT it.

(Asked Dmitry about this.)
Answer (31-10-2008):
  Yes, v3.0 is expected to implement ACLs for all metadata objects. The 
  same issue exists with generators and UDFs, BTW.-->
      </section>
    </section>
    <section id="langrefupd25-ddl-extfunc">
      <title><database>EXTERNAL FUNCTION</database></title>
      <section id="langrefupd25-ddl-extfunc-declare">
        <title><database>DECLARE EXTERNAL FUNCTION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>This statement makes an external function (UDF) available in the database.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <!--See src/jrd/fun.e(pp)
and fb-support thread <<UDF argument "by descriptor FREE_IT">> (22 Jan 2009).
It seems that the combination of descriptors and free_it was only supported
since 2.0 (code change by Claudio).
Maybe the *syntax* was already accepted in 1.x but nothing was freed?
Find out and update 1.5, 2.0 and 2.1 LangRefUpds.-->
              <programlisting>DECLARE EXTERNAL FUNCTION <replaceable>localname</replaceable>
   [<replaceable>&lt;arg_type_decl&gt;</replaceable> [, <replaceable>&lt;arg_type_decl&gt;</replaceable> ...]]
   RETURNS {<replaceable>&lt;return_type_decl&gt;</replaceable> | PARAMETER <replaceable>1-based_pos</replaceable>} [FREE_IT]
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;arg_type_decl&gt;</replaceable>     ::=  <replaceable>sqltype</replaceable> [BY DESCRIPTOR] | CSTRING(<replaceable>length</replaceable>)
<replaceable>&lt;return_type_decl&gt;</replaceable>  ::=  <replaceable>sqltype</replaceable> [BY {DESCRIPTOR|VALUE}] | CSTRING(<replaceable>length</replaceable>)</programlisting>
              <note>
                <title>Restrictions</title>
                <itemizedlist spacing="compact">
                  <listitem>
                    <para>The <database>BY DESCRIPTOR</database> passing method is not supported in
                    ESQL.</para>
                  </listitem>
                </itemizedlist>
              </note>
            </blockquote></para>
        </formalpara>
        <para>You may choose <replaceable>localname</replaceable> freely; this is the name by which
        the function will be known to your database. You may also vary the
        <replaceable>length</replaceable> argument of <database>CSTRING</database> parameters (more
        about <database>CSTRING</database>s in the <link
        linkend="langrefupd25-notes-cstring">note</link> near the end of the book).</para>
        <section id="langrefupd25-declareext-bydescriptor">
          <title><database>BY DESCRIPTOR</database> parameter passing</title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird introduces the possibility to pass parameters <database>BY
            DESCRIPTOR</database>; this mechanism facilitates the processing of
            <constant>NULL</constant>s in a meaningful way. Notice that this only works if the
            person who wrote the function has implemented it. Simply adding <quote><database>BY
            DESCRIPTOR</database></quote> to an existing declaration does not make it work – on the
            contrary! Always use the declaration block provided by the function designer.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-declareext-retparamn">
          <title><database>RETURNS PARAMETER</database> <replaceable>n</replaceable></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL, ESQL</para>
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>IB 6</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In order to return a <database>BLOB</database>, an extra input parameter must be
            declared and a <quote><database>RETURNS PARAMETER</database>
            <replaceable>n</replaceable></quote> clause added – <replaceable>n</replaceable> being
            the position of said parameter. This clause dates back to InterBase 6 beta, but somehow
            didn't make it into the <citetitle>Language Reference</citetitle> (it is documented in
            the <citetitle>Developer's Guide</citetitle> though).</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-ddl-extfunc-alter">
        <title><database>ALTER EXTERNAL FUNCTION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Alters an external function's module name and/or entry point. Existing dependencies
          are preserved.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER EXTERNAL FUNCTION <replaceable>funcname</replaceable>
   <replaceable>&lt;modification&gt;</replaceable> [<replaceable>&lt;modification&gt;</replaceable>]

<replaceable>&lt;modification&gt;</replaceable>  ::=  ENTRY_POINT '<replaceable>new-entry-point</replaceable>'
                     | MODULE_NAME '<replaceable>new-module-name</replaceable>'</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter external function Phi module_name 'NewUdfLib'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-ddl-filter">
      <title><database>FILTER</database></title>
      <section id="langrefupd25-declare-filter">
        <title><database>DECLARE FILTER</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Makes a <database>BLOB</database> filter available to the database.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DECLARE FILTER <replaceable>filtername</replaceable>
   INPUT_TYPE <replaceable>&lt;sub_type&gt;</replaceable> OUTPUT_TYPE <replaceable>&lt;sub_type&gt;</replaceable>
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;sub_type&gt;</replaceable>  ::=  <replaceable>number</replaceable> | <replaceable>&lt;mnemonic&gt;</replaceable>
<replaceable>&lt;mnemonic&gt;</replaceable>  ::=  binary | text | blr | acl | ranges | summary | format
                 | transaction_description | external_file_description
                 | <replaceable>user_defined</replaceable></programlisting>
              <itemizedlist>
                <listitem>
                  <para>In Firebird 2 and up, no two <database>BLOB</database> filters in a database
                  may have the same combination of input and output type. Declaring a filter with an
                  already existing input-output type combination will fail. Restoring pre-2.0
                  databases that contain such <quote>duplicate</quote> filters will also
                  fail.</para>
                </listitem>
                <listitem>
                  <para>The possibility to indicate the <database>BLOB</database> types with their
                  mnemonics instead of numbers was added in Firebird 2. The
                  <constant>binary</constant> mnemonic for subtype 0 was also added in Firebird 2.
                  The predefined mnemonics are case-insensitive.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>declare filter Funnel
  input_type blr output_type text
  entry_point 'blr2asc' module_name 'myfilterlib'</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>User-defined mnemonics</title>
          <para>If you want to define mnemonics for your own <database>BLOB</database> subtypes, you
          can add them to <database>the RDB$TYPES</database> system table as shown below. Once
          committed, the mnemonics can be used in subsequent filter declarations.<blockquote>
              <programlisting>insert into rdb$types (rdb$field_name, rdb$type, rdb$type_name)
  values ('RDB$FIELD_SUB_TYPE', -33, 'MIDI')</programlisting>
              <!--ATTN: In PDF output, no vertical space appears here!-->
            </blockquote>The value for <literal>rdb$field_name</literal> must always be
          <database>'RDB$FIELD_SUB_TYPE'</database>. If you define your mnemonics in all-uppercase,
          you can use them case-insensitively and unquoted in your filter declarations.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-ddl-index">
      <title><database>INDEX</database></title>
      <section id="langrefupd25-create-index">
        <title><database>CREATE INDEX</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates an index on a table for faster searching, sorting and/or grouping.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE [UNIQUE] [ASC[ENDING] | [DESC[ENDING]] INDEX <replaceable>indexname</replaceable>
   ON <replaceable>tablename</replaceable>
   { (<replaceable>&lt;col&gt;</replaceable> [, <replaceable>&lt;col&gt;</replaceable> ...]) | COMPUTED BY (<replaceable>expression</replaceable>) }

<replaceable>&lt;col&gt;</replaceable>  ::=  a column not of type ARRAY, BLOB or COMPUTED BY</programlisting>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-creatind-unique-nulls">
          <title><database>UNIQUE</database> indices now allow <constant>NULL</constant>s</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple
            – are now allowed in columns that have a <database>UNIQUE</database> index defined on
            them. For a full discussion, see <link
            linkend="langrefupd25-ct-unique-keys"><citetitle><database>CREATE TABLE</database> ::
            <database>UNIQUE</database> constraints now allow
            <constant>NULL</constant>s</citetitle></link>. As far as <constant>NULL</constant>s are
            concerned, the rules for unique indices are exactly the same as those for unique
            keys.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatind-on-expr">
          <title>Indexing on expressions</title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Instead of one or more columns, you can now also specify a single
            <database>COMPUTED BY</database> expression in an index definition.<!--GENERATED ALWAYS AS is not (yet) supported here. Feature request created (CORE-2732).-->
            Expression indices will be used in appropriate queries, provided that the expression in
            the <database>WHERE</database>, <database>ORDER BY</database> or <database>GROUP
            BY</database> clause exactly matches the expression in the index definition.
            Multi-segment expression indices are not supported, but the expression itself may
            involve multiple columns.</para>
            <!--Must the entire WHERE or ORDER BY be equal to the index, or does it work per item? Found out:

- With ORDER BY/GROUP BY, the entire clause must be the same, i.e. there can only be one order/group item.
  The same goes for column indices, btw: a 1-column index is never used in a multicolumn order/group by.
  A multicolumn index can be used for a multicolumn order/group by, provided they are fully equal.

- In the case of WHERE, the index can be used even if the expression doesn't constitute the entire search
  but is linked with AND (not OR!) to other predicates.

- HAVING seems not to use available expression indices. Column indices *are* used when appropriate.
  Asked Dmitry:
  > Another thing: I noticed that expression indices are used for ORDER BY, GROUP BY and WHERE clauses,
  > but not for HAVING clauses (unlike column indices). Is there a special reason for this?
  Answer (31-10-2008):
  No. Could you provide a test case?-->
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <programlisting>create index ix_upname on persons computed by (upper(name));
commit;

-- the following queries will use ix_upname:
select * from persons order by upper(name);
select * from persons where upper(name) starting with 'VAN';
delete from persons where upper(name) = 'BROWN';
delete from persons where upper(name) = 'BROWN' and age &gt; 65;</programlisting>
                <programlisting>create descending index ix_events_yt
  on MyEvents
  computed by (extract(year from StartDate) || Town);
commit;

-- the following query will use ix_events_yt:
select * from MyEvents
  order by extract(year from StartDate) || Town desc;</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatind-keylength">
          <title>Maximum index key length increased</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>The maximum length of index keys, which used to be fixed at 252 bytes, is now
            equal to 1/4 of the page size, i.e. varying from 256 to 4096. The maximum indexable
            string length in bytes is 9 less than the key length. The table below shows the
            indexable string lengths in characters for the various page sizes and character
            sets.</para>
          </formalpara>
          <!--Table still valid for 2.1, 2.5 ?-->
          <table id="langrefupd25-tbl-max-indexable-strlen">
            <title>Maximum indexable <database>(VAR)CHAR</database> length</title>
            <tgroup cols="5">
              <colspec align="left" colname="colPageSize" />
              <colspec align="center" colname="col1bpc" />
              <colspec align="center" colname="col2bpc" />
              <colspec align="center" colname="col3bpc" />
              <colspec align="center" colname="col4bpc" />
              <spanspec align="center" nameend="col4bpc" namest="col1bpc" spanname="spanAllCharsets" />
              <thead>
                <row valign="top">
                  <entry align="left" morerows="1">Page size</entry>
                  <entry spanname="spanAllCharsets">Maximum indexable string length per charset
                  type</entry>
                </row>
                <row>
                  <entry>1 byte/char</entry>
                  <entry>2 bytes/char</entry>
                  <entry>3 bytes/char</entry>
                  <entry>4 bytes/char</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>1024</entry>
                  <entry>247</entry>
                  <entry>123</entry>
                  <entry>82</entry>
                  <entry>61</entry>
                </row>
                <row>
                  <entry>2048</entry>
                  <entry>503</entry>
                  <entry>251</entry>
                  <entry>167</entry>
                  <entry>125</entry>
                </row>
                <row>
                  <entry>4096</entry>
                  <entry>1015</entry>
                  <entry>507</entry>
                  <entry>338</entry>
                  <entry>253</entry>
                </row>
                <row>
                  <entry>8192</entry>
                  <entry>2039</entry>
                  <entry>1019</entry>
                  <entry>679</entry>
                  <entry>509</entry>
                </row>
                <row>
                  <entry>16384</entry>
                  <entry>4087</entry>
                  <entry>2043</entry>
                  <entry>1362</entry>
                  <entry>1021</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
        <section id="langrefupd25-creatind-maxnumber">
          <title>Maximum number of indices per table increased</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0.3, 1.5, 2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>The maximum number of 65 indices per table has been removed in Firebird 1.0.3,
            reintroduced at the higher level of 257 in Firebird 1.5, and removed once again in
            Firebird 2.0.</para>
          </formalpara>
          <para>Although there is no longer a <quote>hard</quote> ceiling, the number of indices
          creatable in practice is still limited by the database page size and the number of columns
          per index, as shown in the table below.</para>
          <!--Why has the max. number of indices gone down again in 2.0?
According to Arno Brinkman, this *might* be due to extensions to the index root page,
probably the added segment selectivity.-->
          <!--Check if table below still valid for 2.1. If so, change 2.0 -> 2.0/2.1 in title!-->
          <table id="langrefupd25-tbl-maxindices">
            <title>Max. indices per table, Firebird 2.0</title>
            <tgroup cols="4">
              <colspec align="left" colname="colPageSize" />
              <colspec align="center" colname="colFb20_1" />
              <colspec align="center" colname="colFb20_2" />
              <colspec align="center" colname="colFb20_3" />
              <spanspec align="center" nameend="colFb20_3" namest="colFb20_1"
                        spanname="spanColCounts" />
              <thead>
                <row valign="top">
                  <entry align="left" morerows="1">Page size</entry>
                  <entry spanname="spanColCounts">Number of indices depending on column
                  count</entry>
                </row>
                <row>
                  <entry>1 col</entry>
                  <entry>2 cols</entry>
                  <entry>3 cols</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>1024</entry>
                  <entry>50</entry>
                  <entry>35</entry>
                  <entry>27</entry>
                </row>
                <row>
                  <entry>2048</entry>
                  <entry>101</entry>
                  <entry>72</entry>
                  <entry>56</entry>
                </row>
                <row>
                  <entry>4096</entry>
                  <entry>203</entry>
                  <entry>145</entry>
                  <entry>113</entry>
                </row>
                <row>
                  <entry>8192</entry>
                  <entry>408</entry>
                  <entry>291</entry>
                  <entry>227</entry>
                </row>
                <row>
                  <entry>16384</entry>
                  <entry>818</entry>
                  <entry>584</entry>
                  <entry>454</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>Please be aware that under normal circumstances, even 50 indices is way too many and
          will drastically reduce mutation speeds. The maximum was removed to accommodate
          data-warehousing applications and the like, which perform lots of bulk operations with the
          indices temporarily inactivated.</para>
          <para>For a full table also including Firebird versions 1.0–1.5, see the <link
          linkend="langrefupd25-notes-maxindices">Notes</link> at the end of the book.</para>
        </section>
      </section>
      <!--ALTER INDEX

Fb1 RlsNotes say:

Allow FK indexes to be disabled
It is now possible to set FOREIGN KEY indexes inactive using ALTER INDEX. This should resolve
some performance issues related to maintaining indexes with low selectivity.

In practice, this doesn't work and has never been implemented (confirmed by Dmitry).
It should have been removed from the Rlsnotes.-->
    </section>
    <section id="langrefupd25-ddl-procedure">
      <title><database>PROCEDURE</database></title>
      <para>A stored procedure (SP) is a code module that can be called by the client, by another
      stored procedure, an executable block or a trigger. Stored procedures, executable blocks and
      triggers are written in Procedural SQL (PSQL). Most SQL statements are also available in PSQL,
      sometimes with restrictions or extensions. Notable exceptions are DDL and transaction control
      statements.</para>
      <para>Stored procedures can accept and return multiple parameters.</para>
      <section id="langrefupd25-create-proc">
        <title><database>CREATE PROCEDURE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates a stored procedure.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE PROCEDURE <replaceable>procname</replaceable>
   [(<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])]
   [RETURNS (<replaceable>&lt;outparam&gt;</replaceable> [, <replaceable>&lt;outparam&gt;</replaceable> ...])]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparam&gt;</replaceable>       ::=  <replaceable>&lt;param_decl&gt;</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>]
<replaceable>&lt;outparam&gt;</replaceable>      ::=  <replaceable>&lt;param_decl&gt;</replaceable>
<replaceable>&lt;param_decl&gt;</replaceable>    ::=  <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
<replaceable>&lt;type&gt;</replaceable>          ::=  <replaceable>sql_datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>
<replaceable>&lt;declarations&gt;</replaceable>  ::=  See <link linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax

/* If <replaceable>sql_datatype</replaceable> is a string type, it may include a character set */</programlisting>
              <!--Notice that if a charset and a collation and not null are specified, not null comes in the middle.
This is the only accepted order!
The same goes for domain definitions: charset -> not null -> collation
Except that in domain definitions, default must come after charset: charset -> default -> not null -> collate
whereas with procedure parameters, default comes at the very end: charset -> not null -> collate -> default

It *looks like*, if TYPE OF <domain> is used and COLLATE is added, the COLLATE clause is accepted but ignored
if <domain> already includes a collation - and maybe even if it doesn't? Yes, seems so! Find out more.-->
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-create-proc-typeofcolumn">
          <title><database>TYPE OF COLUMN</database> in parameter and variable declarations</title>
          <formalpara>
            <title>Added in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Analogous to the <quote><database>TYPE OF</database>
            <replaceable>domain</replaceable></quote> syntax supported since version 2.1, it is now
            also possible to declare variables and parameters as having the type of an existing
            table or view column. Only the type itself is used; in the case of string types, this
            includes the character set and the collation. Constraints and default values are never
            copied from the source column.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>/* Assuming DDL autocommit and connection charset UTF8 */

create domain dphrase as
  varchar(200) character set utf8 collate unicode_ci_ai;

create table phrases (phrase dphrase);

set term #;
create procedure equalphrases (a <emphasis role="bold">type of column</emphasis> phrases.phrase,
                               b <emphasis role="bold">type of column</emphasis> phrases.phrase)
  returns (res varchar(30))
as
begin
  if (a = b) then res = 'Yes'; else res = 'No';
  suspend;
end#
set term ;#

select res from equalphrases('Appel', 'appèl');

-- result is 'Yes'</programlisting>
              </blockquote></para>
          </formalpara>
          <warning>
            <title>Warnings</title>
            <itemizedlist>
              <listitem>
                <para>For text types, character set and collation are included by <database>TYPE OF
                COLUMN</database> – just as when <database>[TYPE OF]</database>
                <replaceable>&lt;domain&gt;</replaceable> is used. However, due to a bug, the
                collation is not always taken into consideration when comparisons (e.g. equality
                tests) are made. In cases where the collation is of importance, test your code
                thoroughly before deploying! This bug is fixed for Firebird 3.</para>
                <!--More specific: If the column has a direct type, comparisons igmore the collation even though in/output column
descriptions do include the collation. If the column has a domain type, comparisons function correctly.-->
              </listitem>
              <listitem>
                <para>If the column's type is changed at a later time, PSQL code using that column
                may become invalid. For information on how to detect this, please read the note
                <link linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
                <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
                document.</para>
              </listitem>
            </itemizedlist>
          </warning>
        </section>
        <section id="langrefupd25-create-proc-domains">
          <title>Domains supported in parameter and variable declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up support the use of domains instead of SQL datatypes when
            declaring input/output parameters and local variables. With the <quote><database>TYPE
            OF</database></quote> modifier, only the domain's type is used – not its <database>NOT
            NULL</database> setting, <database>CHECK</database> constraint and/or default value. If
            the domain is of a text type, its character set and collation are always
            preserved.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create domain <emphasis role="bold">bool3</emphasis>
  smallint
  check (value is null or value in (0,1));

create domain <emphasis role="bold">bigposnum</emphasis>
  bigint
  check (value &gt;= 0);

/* Determines if A is a multiple of B: */
set term #;
create procedure ismultiple (a <emphasis role="bold">bigposnum</emphasis>, b <emphasis role="bold">bigposnum</emphasis>)
  returns (res <emphasis role="bold">bool3</emphasis>)
as
  declare ratio <emphasis role="bold">type of bigposnum</emphasis>;      -- ratio is a bigint
  declare remainder <emphasis role="bold">type of bigposnum</emphasis>;  -- so is remainder
begin
  if (a is null or b is null) then res = null;
  else if (b = 0) then
  begin
    if (a = 0) then res = 1; else res = 0;
  end
  else
  begin
    ratio = a / b;                      -- integer division!
    remainder = a - b*ratio;
    if (remainder = 0) then res = 1; else res = 0;
  end
end#
set term ;#</programlisting>
              </blockquote></para>
          </formalpara>
          <warning>
            <para>If a domain's definition is changed, existing PSQL code using that domain may
            become invalid. For information on how to detect this, please read the note <link
            linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
            <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
            document.</para>
          </warning>
        </section>
        <section id="langrefupd25-create-proc-collate">
          <title><database>COLLATE</database> in variable and parameter declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>COLLATE</database> clauses in declarations of
            input/output parameters and local variables.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create procedure SpanishToDutch
  (es_1 varchar(20) character set iso8859_1 collate es_es,
   es_2 my_char_domain collate es_es)
returns
  (nl_1 varchar(20) character set iso8859_1 collate du_nl,
   nl_2 my_char_domain collate du_nl)
as
declare s_temp varchar(100) character set utf8 collate unicode;
begin
  ...
  ...
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-proc-notnull">
          <title><database>NOT NULL</database> in variable and parameter declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>NOT NULL</database> constraints in
            declarations of input/output parameters and local variables.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create procedure RegisterOrder
  (order_no int not null, description varchar(200) not null)
returns
  (ticket_no int not null)
as
declare temp int not null;
begin
  ...
  ...
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-proc-defaults">
          <title>Default argument values</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>It is now possible to provide default values for stored procedure arguments,
            allowing the caller to omit one or more items (possibly even all) from the end of the
            argument list.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>CREATE PROCEDURE <replaceable>procname</replaceable> (<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])
   ...

<replaceable>&lt;inparam&gt;</replaceable>  ::=  <replaceable>paramname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>]</programlisting>
                <para><emphasis role="bold">Important:</emphasis> If you provide a default value for
                a parameter, you must do the same for any and all parameters following it.</para>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-proc-empty">
          <title><database>BEGIN ... END</database> blocks may be empty</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
            allowing you to write stub code without having to resort to dummy statements.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create procedure grab_ints (a integer, b integer)
as
begin
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-alter-proc">
        <title><database>ALTER PROCEDURE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <section id="langrefupd25-alter-proc-argdefaults">
          <title>Default argument values</title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>You can now provide default values for stored procedure arguments, allowing the
            caller to omit one or more items from the end of the argument list. See <link
            linkend="langrefupd25-create-proc"><citetitle><database>CREATE
            PROCEDURE</database></citetitle></link> for syntax and details.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter procedure TestProc
  (a int, b int default 1007, s varchar(12) = '-')
  ...</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-proc-classic-visibility">
          <title>Classic Server: Altered procedure immediately visible to other clients</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Traditionally, when a client used <database>ALTER PROCEDURE</database> on a
            Classic server, other clients would keep seeing (and possibly executing) the old version
            for the duration of their connection. This has been fixed in 2.5. Now, all clients see
            the new version as soon as the changes have been committed.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-proc-collate">
          <title><database>COLLATE</database> in variable and parameter declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>COLLATE</database> clauses in declarations of
            input/output parameters and local variables. See <link
            linkend="langrefupd25-create-proc"><citetitle><database>CREATE
            PROCEDURE</database></citetitle></link> for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-proc-domains">
          <title>Domains supported in parameter and variable declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up support the use of domains instead of SQL datatypes when
            declaring input/output parameters and local variables. See <link
            linkend="langrefupd25-create-proc"><citetitle><database>CREATE
            PROCEDURE</database></citetitle></link> for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-proc-notnull">
          <title><database>NOT NULL</database> in variable and parameter declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>NOT NULL</database> constraints in
            declarations of input/output parameters and local variables. See <link
            linkend="langrefupd25-create-proc"><citetitle><database>CREATE
            PROCEDURE</database></citetitle></link> for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-proc-restr">
          <title>Restriction on altering used procedures</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.0.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-proc-typeofcolumn">
          <title><database>TYPE OF COLUMN</database> in parameter and variable declarations</title>
          <formalpara>
            <title>Added in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Analogous to the <quote><database>TYPE OF</database>
            <replaceable>domain</replaceable></quote> syntax supported since version 2.1, it is now
            also possible to declare variables and parameters as having the type of an existing
            table or view column. See <link
            linkend="langrefupd25-create-proc"><citetitle><database>CREATE
            PROCEDURE</database></citetitle></link> for syntax and details.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-create-or-alter-proc">
        <title><database>CREATE OR ALTER PROCEDURE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If the procedure does not yet exist, it is created just as if <database>CREATE
          PROCEDURE</database> were used. If it already exists, it is altered and recompiled.
          Existing permissions and dependencies are preserved.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as for <database>CREATE PROCEDURE</database>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-drop-proc">
        <title><database>DROP PROCEDURE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <section id="langrefupd25-drop-proc-restr">
          <title>Restriction on dropping used procedures</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.0.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-recreate-proc">
        <title><database>RECREATE PROCEDURE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates or recreates a stored procedure. If a procedure with the same name already
          exists, <database>RECREATE PROCEDURE</database> will try to drop it and create a new
          procedure. <database>RECREATE PROCEDURE</database> will fail if the existing
          <database>SP</database> is in use.<!--Make sure this last statement is true!--></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <link linkend="langrefupd25-create-proc"><database>CREATE
          PROCEDURE</database></link>.</para>
        </formalpara>
        <section id="langrefupd25-recreate-proc-restr">
          <title>Restriction on recreating used procedures</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.0.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>
    </section>
    <section id="langrefupd25-ddl-sequence">
      <title><database>SEQUENCE</database> or <database>GENERATOR</database></title>
      <section id="langrefupd25-create-seq">
        <title><database>CREATE SEQUENCE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates a new sequence or generator. <database>SEQUENCE</database> is the
          SQL-compliant term for what InterBase and Firebird have always called a generator.
          <database>CREATE SEQUENCE</database> is fully equivalent to <database>CREATE
          GENERATOR</database> and is the recommended syntax from Firebird 2.0 onward.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE SEQUENCE <replaceable>sequence-name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create sequence seqtest</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Because internally sequences and generators are the same thing, you can freely mix the
        generator and sequence syntaxes, even when operating on the same object. This is not
        recommended however.</para>
        <para>Sequences (or generators) are always stored as 64-bit integer values, regardless of
        the database dialect. However:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If the <emphasis>client</emphasis> dialect is set to 1, the server passes
            generator values as truncated 32-bit values to the client.</para>
          </listitem>
          <listitem>
            <para>If generator values are fed into a 32-bit field or variable, all goes well until
            the actual value exceeds the 32-bit range. At that point, a dialect 3 database will
            raise an error whereas a dialect 1 database will silently truncate the value (which
            could also lead to an error, e.g. if the receiving field has a unique key defined on
            it).</para>
          </listitem>
        </itemizedlist>
        <formalpara>
          <title>See also</title>
          <para><link linkend="langrefupd25-alter-seq"><database>ALTER SEQUENCE</database></link>,
          <link linkend="langrefupd25-nextvaluefor"><database>NEXT VALUE FOR</database></link>,
          <link linkend="langrefupd25-drop-seq"><database>DROP SEQUENCE</database></link></para>
        </formalpara>
      </section>
      <section id="langrefupd25-create-gen">
        <title><database>CREATE GENERATOR</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Better alternative</title>
          <para><link linkend="langrefupd25-create-seq"><database>CREATE
          SEQUENCE</database></link></para>
        </formalpara>
        <section id="langrefupd25-creatgen-creatseq">
          <title><database>CREATE SEQUENCE</database> preferred</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>From Firebird 2.0 onward, the SQL-compliant <link
            linkend="langrefupd25-create-seq"><database>CREATE SEQUENCE</database></link> syntax is
            preferred.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatgen-limitraised">
          <title>Maximum number of generators significantly raised</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>InterBase reserved only one database page for generators, limiting the total
            number to 123 (on 1K pages) – 1019 (on 8K pages). Firebird has done away with that
            limit; you can now create more than 32,000 generators per database.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-alter-seq">
        <title><database>ALTER SEQUENCE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>(Re)initializes a sequence or generator to the given value.
          <database>SEQUENCE</database> is the SQL-compliant term for what InterBase and Firebird
          have always called a generator. <quote><database>ALTER SEQUENCE ... RESTART
          WITH</database></quote> is fully equivalent to <quote><database>SET GENERATOR ...
          TO</database></quote> and is the recommended syntax from Firebird 2.0 onward.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER SEQUENCE <replaceable>sequence-name</replaceable> RESTART WITH <replaceable>&lt;newval&gt;</replaceable>

<replaceable>&lt;newval&gt;</replaceable>  ::=  A signed 64-bit integer value.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter sequence seqtest restart with 0</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>Careless use of <database>ALTER SEQUENCE</database> is a mighty fine way of screwing
          up your database! Under normal circumstances you should only use it right after
          <database>CREATE SEQUENCE</database>, to set the initial value.</para>
        </warning>
        <formalpara>
          <title>See also</title>
          <para><link linkend="langrefupd25-create-seq"><database>CREATE
          SEQUENCE</database></link></para>
        </formalpara>
      </section>
      <section id="langrefupd25-set-generator">
        <title><database>SET GENERATOR</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Better alternative</title>
          <para><link linkend="langrefupd25-alter-seq"><database>ALTER
          SEQUENCE</database></link></para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>(Re)initializes a generator or sequence to the given value. From Firebird 2 onward,
          the SQL-compliant <link linkend="langrefupd25-alter-seq"><database>ALTER
          SEQUENCE</database></link> syntax is preferred.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SET GENERATOR <replaceable>generator-name</replaceable> TO <replaceable>&lt;new-value&gt;</replaceable>

<replaceable>&lt;new-value&gt;</replaceable>  ::=  A 64-bit integer.</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>Once a generator or sequence is up and running, you should not tamper with its value
          (other than retrieving next values with <database>GEN_ID</database> or <database>NEXT
          VALUE FOR</database>) unless you know exactly what you are doing.</para>
        </warning>
      </section>
      <section id="langrefupd25-drop-seq">
        <title><database>DROP SEQUENCE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Removes a sequence or generator from the database. Its (very small) storage space
          will be freed for re-use after a backup-restore cycle. <database>SEQUENCE</database> is
          the SQL-compliant term for what InterBase and Firebird have always called a generator.
          <database>DROP SEQUENCE</database> is fully equivalent to <database>DROP
          GENERATOR</database> and is the recommended syntax from Firebird 2.0 onward.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DROP SEQUENCE <replaceable>sequence-name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>drop sequence seqtest</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>See also</title>
          <para><link linkend="langrefupd25-create-seq"><database>CREATE
          SEQUENCE</database></link></para>
        </formalpara>
      </section>
      <section id="langrefupd25-drop-generator">
        <title><database>DROP GENERATOR</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in source-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Better alternative</title>
          <para><link linkend="langrefupd25-drop-seq"><database>DROP
          SEQUENCE</database></link></para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Removes a generator or sequence from the database. Its (very small) storage space
          will be freed for re-use after a backup-restore cycle.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DROP GENERATOR <replaceable>generator-name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <para>From Firebird 2.0 onward, the SQL-compliant <link
        linkend="langrefupd25-drop-seq"><database>DROP SEQUENCE</database></link> syntax is
        preferred.</para>
      </section>
    </section>
    <section id="langrefupd25-ddl-table">
      <title><database>TABLE</database></title>
      <section id="langrefupd25-create-table">
        <title><database>CREATE TABLE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <section id="langrefupd25-ct-gtts">
          <title>Global Temporary Tables (GTTs)</title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Global temporary tables have persistent metadata, but their contents are
            transaction-bound (the default) or connection-bound. Every transaction or connection has
            its own private instance of a GTT, isolated from all the others. Instances are only
            created if and when the GTT is referenced, and destroyed upon transaction end or
            disconnection. To modify or remove a GTT's metadata, <database>ALTER TABLE</database>
            and <database>DROP TABLE</database> can be used.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>CREATE GLOBAL TEMPORARY TABLE <replaceable>name</replaceable>
   (<replaceable>column_def</replaceable> [, <replaceable>column_def</replaceable> | <replaceable>table_constraint</replaceable> ...])
   [ON COMMIT {DELETE | PRESERVE} ROWS]</programlisting>
                <itemizedlist>
                  <listitem>
                    <para><database>ON COMMIT DELETE ROWS</database> creates a transaction-level GTT
                    (the default), <database>ON COMMIT PRESERVE ROWS</database> a connection-level
                    GTT.</para>
                  </listitem>
                  <listitem>
                    <para>An <database>EXTERNAL [FILE]</database> clause is not allowed on a global
                    temporary table.</para>
                  </listitem>
                </itemizedlist>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Restrictions</title>
            <para>GTTs can be <quote>dressed up</quote> with all the features and paraphernalia of
            ordinary tables (keys, references, indices, triggers...) but there are a few
            restrictions:<itemizedlist>
                <listitem>
                  <para>GTTs and regular tables cannot reference one another.</para>
                </listitem>
                <listitem>
                  <para>A connection-bound (<quote><database>PRESERVE ROWS</database></quote>) GTT
                  cannot reference a transaction-bound (<quote><database>DELETE
                  ROWS</database></quote>) GTT.</para>
                </listitem>
                <listitem>
                  <para>Domain constraints cannot reference any GTT.</para>
                  <!--Ummm... I didn't know that a domain constraint could reference a table at all.
Check with Dmitry!-->
                </listitem>
                <listitem>
                  <para>The destruction of a GTT instance at the end of its life cycle does
                  <emphasis>not</emphasis> cause any before/after delete triggers to fire.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create global temporary table MyConnGTT (
  id int not null primary key,
  txt varchar(32),
  ts timestamp default current_timestamp
)
on commit preserve rows;

commit;

create global temporary table MyTxGTT (
  id int not null primary key,
  parent_id int not null references MyConnGTT(id),
  txt varchar(32),
  ts timestamp default current_timestamp
);

commit;</programlisting>
              </blockquote></para>
          </formalpara>
          <tip>
            <para>In an existing database, it's not always easy to tell a regular table from a GTT,
            or a transaction-level GTT from a connection-level GTT. Use this query to find out a
            table's type:</para>
            <blockquote>
              <programlisting>select t.rdb$type_name
  from rdb$relations r
  join rdb$types t on r.rdb$relation_type = t.rdb$type
  where t.rdb$field_name = 'RDB$RELATION_TYPE'
  and r.rdb$relation_name = '<replaceable>TABLENAME</replaceable>'</programlisting>
            </blockquote>
            <para>Or, for an overview of all your relations:</para>
            <blockquote>
              <programlisting>select r.rdb$relation_name, t.rdb$type_name
  from rdb$relations r
  join rdb$types t on r.rdb$relation_type = t.rdb$type
  where t.rdb$field_name = 'RDB$RELATION_TYPE'
  and coalesce (r.rdb$system_flag, 0) = 0</programlisting>
            </blockquote>
          </tip>
          <!--From the 2.1.1 RlsNotes:

  The data and index pages of all GTT instances are placed in separate temporary files.
  Each connection has its own temporary file created the first time the connection
  references some GTT.

This is probably incorrect. With 2 or 3 connections referencing the same connection-level GTT,
I saw ONE file appear in Windows\Temp. It disappeared after the last disconnect.-->
        </section>
        <section id="langrefupd25-ct-gen-always-as">
          <title><database>GENERATED ALWAYS AS</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Instead of <database>COMPUTED [BY]</database>, you may also use the
            SQL-2003-compliant equivalent <database>GENERATED ALWAYS AS</database> for computed
            fields.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting><replaceable>colname</replaceable> [<replaceable>coltype</replaceable>] GENERATED ALWAYS AS (<replaceable>expression</replaceable>)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create table Persons (
  id int primary key,
  firstname varchar(24) not null,
  middlename varchar(24),
  lastname varchar(24) not null,
  fullname varchar(74) generated always as
    (firstname || coalesce(' ' || middlename, '') || ' ' || lastname),
  street varchar(32),
  ...
  ...
)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Note</title>
            <para><database>GENERATED ALWAYS AS</database> is not currently supported in index
            definitions.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-ct-check">
          <title><database>CHECK</database> accepts <constant>NULL</constant> outcome</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>If a <database>CHECK</database> constraint resolves to <constant>NULL</constant>,
            Firebird versions before 2.0 reject the input. Following the SQL standard to the letter,
            Firebird 2.0 and above let <constant>NULL</constant>s pass and only consider the check
            failed if the outcome is <constant>false</constant>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <para>Checks like these:</para>
                <programlisting>check (value &gt; 10000)</programlisting>
                <programlisting>check (Town like 'Amst%')</programlisting>
                <programlisting>check (upper(value) in ( 'A', 'B', 'X' ))</programlisting>
                <programlisting>check (Minimum &lt;= Maximum)</programlisting>
                <para>all <emphasis>fail</emphasis> in pre-2.0 Firebird versions if the value to be
                checked is <constant>NULL</constant>. In 2.0 and above they
                <emphasis>succeed</emphasis>.</para>
              </blockquote></para>
          </formalpara>
          <warning>
            <para>This change may cause existing databases to behave differently when migrated to
            Firebird 2.0+. Carefully examine your <database>CREATE/ALTER TABLE</database> statements
            and add <quote><code>and XXX is not null</code></quote> predicates to your
            <database>CHECK</database>s if they should continue to reject <constant>NULL</constant>
            input.</para>
          </warning>
        </section>
        <section id="langrefupd25-ct-contextvars">
          <title>Context variables as column defaults</title>
          <formalpara>
            <title>Changed in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Any context variable that is assignment-compatible to the column datatype can be
            used as a default. This was already the case in InterBase 6, but the <citetitle>Language
            Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create table MyData (
  id int not null primary key,
  record_created timestamp default current_timestamp,
  ...
)</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-ct-fk-notargetcol">
          <title><database>FOREIGN KEY</database> without target column references
          <database>PK</database></title>
          <formalpara>
            <title>Changed in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>If you create a foreign key without specifying a target column, it will reference
            the <emphasis role="bold">primary key</emphasis> of the target table. This was already
            the case in InterBase 6, but the IB Language Reference wrongly states that in such
            cases, the engine scans the target table for a column with the same name as the
            referencing column.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create table eik (
  a int not null primary key,
  b int not null unique
);

create table beuk (
  b int references eik
);

-- beuk.b references eik.a, not eik.b !</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-ct-fk-noexclusive">
          <title><database>FOREIGN KEY</database> creation no longer requires exclusive
          access</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 and above, creating a foreign key constraint no longer requires
            exclusive access to the database.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-ct-unique-keys">
          <title><database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple
            – are now allowed in columns with a <database>UNIQUE</database> constraint. It is
            therefore possible to define a <database>UNIQUE</database> key on a column that has no
            <database>NOT NULL</database> constraint.</para>
          </formalpara>
          <para>For <database>UNIQUE</database> keys that span multiple columns, the logic is a
          little complicated:</para>
          <itemizedlist>
            <listitem>
              <para>Multiple rows having <emphasis>all</emphasis> the <database>UK</database>
              columns <constant>NULL</constant> are allowed.</para>
            </listitem>
            <listitem>
              <para>Multiple rows having a <emphasis>different subset</emphasis> of
              <database>UK</database> colums <constant>NULL</constant> are allowed.</para>
            </listitem>
            <listitem>
              <para>Multiple rows having the <emphasis>same subset</emphasis> of
              <database>UK</database> columns <constant>NULL</constant> and the rest filled with
              regular values and those regular values <emphasis>differ</emphasis> in at least one
              column, are allowed.</para>
            </listitem>
            <listitem>
              <para>Multiple rows having the <emphasis>same subset</emphasis> of
              <database>UK</database> columns <constant>NULL</constant> and the rest filled with
              regular values and those regular values are the <emphasis>same</emphasis> in every
              column, are forbidden.</para>
            </listitem>
          </itemizedlist>
          <para>One way of summarizing this is as follows: In principle, all
          <constant>NULL</constant>s are considered distinct. But if two rows have exactly the same
          subset of <database>UK</database> columns filled with non-<constant>NULL</constant>
          values, the <constant>NULL</constant> columns are ignored and the
          non-<constant>NULL</constant> columns are decisive, just as if they constituted the entire
          unique key.</para>
          <!--Give example tables to show what is and isn't allowed?-->
        </section>
        <section id="langrefupd25-ct-using-index">
          <title><database>USING INDEX</database> subclause</title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
            <!--ESQL: no support found in source-->
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>A <database>USING INDEX</database> subclause can be placed at the end of a
            primary, unique or foreign key definition. Its purpose is to<itemizedlist
                spacing="compact">
                <listitem>
                  <para>provide a user-defined name for the automatically created index that
                  enforces the constraint, and</para>
                </listitem>
                <listitem>
                  <para>optionally define the index to be ascending or descending (the default being
                  ascending).</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
          <para>Without <database>USING INDEX</database>, indices enforcing named constraints are
          named after the constraint (this is new behaviour in Firebird 1.5) and indices for unnamed
          constraints get names like <database>RDB$FOREIGN13</database> or something equally
          romantic.</para>
          <note>
            <para>You must always provide a <emphasis>new</emphasis> name for the index. It is not
            possible to use pre-existing indices to enforce constraints.</para>
          </note>
          <para><database>USING INDEX</database> can be applied at field level, at table level, and
          (in <database>ALTER TABLE</database>) with <database>ADD CONSTRAINT</database>. It works
          with named as well as unnamed key constraints. It does <emphasis>not</emphasis> work with
          <database>CHECK</database> constraints, as these don't have their own enforcing
          index.</para>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>[CONSTRAINT <replaceable>constraint-name</replaceable>]
   <replaceable>&lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>The first example creates a primary key constraint
                <database>PK_CUST</database> using an index named
                <database>IX_CUSTNO</database>:</para>
                <programlisting>create table customers (
  custno int not null constraint pk_cust primary key using index ix_custno,
  ...</programlisting>
                <para>This, however:</para>
                <programlisting>create table customers (
  custno int not null primary key using index ix_custno,
  ...</programlisting>
                <para>...will give you a PK constraint called <database>INTEG_7</database> or
                something similar, and an index <database>IX_CUSTNO</database>.</para>
                <para>Some more examples:</para>
                <programlisting>create table people (
  id int not null,
  nickname varchar(12) not null,
  country char(4),
  ..
  ..
  constraint pk_people primary key (id),
  constraint uk_nickname unique (nickname) using index ix_nick
)</programlisting>
                <programlisting>alter table people
  add constraint fk_people_country
  foreign key (country) references countries(code)
  using desc index ix_people_country</programlisting>
              </blockquote></para>
          </formalpara>
          <important>
            <para>If you define a descending constraint-enforcing index on a primary or unique key,
            be sure to make any foreign keys referencing it descending as well.<!--Or else?--></para>
          </important>
        </section>
      </section>
      <section id="langrefupd25-alter-table">
        <title><database>ALTER TABLE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <!--(for when we construct the formal syntax:)
- In IB6 and Fb (tested 2.0) you cannot provide a default after ALTER [COLUMN] ... TYPE
- In IB6 thru Fb 2.1, a COLLATE clause is not supported with ALTER [COLUMN] ... TYPE
- ALTER COLUMN ADD/DROP/ DEFAULT are not supported in ESQL-->
        <section id="langrefupd25-at-contextvars">
          <title><database>ADD</database> column: Context variables as defaults</title>
          <formalpara>
            <title>Changed in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Any context variable that is assignment-compatible to the new column's datatype
            can be used as a default. This was already the case in InterBase 6, but the
            <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter table MyData
  add MyDay date default current_date</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-at-ac-generated">
          <title><database>ALTER COLUMN</database> also for generated (computed) columns</title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
            <!--ESQL ?-->
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.5 supports the altering of generated (computed) columns, something that
            was previously impossible. Only the data type and the generation expression can be
            changed; you cannot change a base column into a generated column or vice versa.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>gencolname</replaceable>
   [TYPE <replaceable>datatype</replaceable>]
   {GENERATED ALWAYS AS | COMPUTED BY} (<replaceable>expression</replaceable>)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create table nums (a int, b generated always as (3*a));
commit;

alter table nums alter b generated always as (4*a + 7);
commit;</programlisting>
              </blockquote></para>
          </formalpara>
          <para>Notice that you can use <database>GENERATED ALWAYS AS</database> when altering
          columns defined with <database>COMPUTED BY</database> and vice versa.</para>
        </section>
        <section id="langrefupd25-at-ac-change-type">
          <title><database>ALTER COLUMN ... TYPE</database> no longer fails if column is used in
          trigger or SP</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Previously, if a table column was referenced in a stored procedure or trigger, the
            column's type could not be changed, even if the change would not break the PSQL code.
            Now such changes are permitted – even if they <emphasis>do</emphasis> break the
            code.</para>
          </formalpara>
          <warning>
            <para>This means that, in the current situation, you can commit changes that break SP's
            or triggers without getting as much as a warning! For information on how to track down
            invalidated PSQL modules after a column type change, please read the note <link
            linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
            <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
            document.</para>
          </warning>
        </section>
        <section id="langrefupd25-at-ac-dropdefault">
          <title><database>ALTER COLUMN</database>: <database>DROP DEFAULT</database></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
            <!--ESQL: no-->
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2 adds the possibility to drop a column-level default. Once the default
            is dropped, there will either be no default in place or – if the column's type is a
            <database>DOMAIN</database> with a default – the domain default will resurface.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> DROP DEFAULT</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter table Trees alter Girth drop default</programlisting>
              </blockquote></para>
          </formalpara>
          <para>An error is raised if you use <database>DROP DEFAULT</database> on a column that
          doesn't have a default or whose effective default is domain-based.</para>
        </section>
        <section id="langrefupd25-at-ac-setdefault">
          <title><database>ALTER COLUMN</database>: <database>SET DEFAULT</database></title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
            <!--ESQL: no-->
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2 adds the possibility to set/alter defaults on existing columns. If the
            column already had a default, the new default will replace it. Column-level defaults
            always override domain-level defaults.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> SET DEFAULT <replaceable>&lt;default&gt;</replaceable>

<replaceable>&lt;default&gt;</replaceable>  ::=  <replaceable>literal-value</replaceable> | <replaceable>context-variable</replaceable> | NULL</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter table Customers alter EnteredBy set default current_user</programlisting>
              </blockquote></para>
          </formalpara>
          <tip>
            <para>If you want to switch off a domain-based default on a column, set the column
            default to <constant>NULL</constant>.</para>
          </tip>
        </section>
        <section id="langrefupd25-at-position">
          <title><database>ALTER COLUMN</database>: <database>POSITION</database> now
          1-based</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>When changing a column's position, the engine now interprets the new position as
            1-based. This is in accordance with the SQL standard and the InterBase documentation,
            but in practice InterBase interpreted the position as 0-based.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> POSITION <replaceable>&lt;newpos&gt;</replaceable>

<replaceable>&lt;newpos&gt;</replaceable>  ::=  an integer between 1 and the number of columns</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter table Stock alter Quantity position 3</programlisting>
              </blockquote></para>
          </formalpara>
          <note>
            <para>Don't confuse this with the <database>POSITION</database> in
            <database>CREATE/ALTER TRIGGER</database>. Trigger positions are and will remain
            0-based.</para>
          </note>
        </section>
        <section id="langrefupd25-at-check">
          <title><database>CHECK</database> accepts <constant>NULL</constant> outcome</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>If a <database>CHECK</database> constraint resolves to <constant>NULL</constant>,
            Firebird versions before 2.0 reject the input. Following the SQL standard to the letter,
            Firebird 2.0 and above let <constant>NULL</constant>s pass and only consider the check
            failed if the outcome is <constant>false</constant>. For more information see under
            <link linkend="langrefupd25-ct-check"><citetitle><database>CREATE
            TABLE</database></citetitle></link>.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-at-fk-notargetcol">
          <title><database>FOREIGN KEY</database> without target column references
          <database>PK</database></title>
          <formalpara>
            <title>Changed in</title>
            <para>IB</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>If you create a foreign key without specifying a target column, it will reference
            the <emphasis role="bold">primary key</emphasis> of the target table. This was already
            the case in InterBase 6, but the IB Language Reference wrongly states that in such
            cases, the engine scans the target table for a column with the same name as the
            referencing column.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create table eik (
  a int not null primary key,
  b int not null unique
);

create table beuk (
  b int
);

alter table beuk
  add constraint fk_beuk
  foreign key (b) references eik;

-- beuk.b now references eik.a, not eik.b !</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-at-fk-noexclusive">
          <title><database>FOREIGN KEY</database> creation no longer requires exclusive
          access</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 and above, adding a foreign key constraint no longer requires
            exclusive access to the database.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-at-gen-always-as">
          <title><database>GENERATED ALWAYS AS</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Instead of <database>COMPUTED [BY]</database>, you may also use the
            SQL-2003-compliant equivalent <database>GENERATED ALWAYS AS</database> for computed
            fields.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting><replaceable>colname</replaceable> [<replaceable>coltype</replaceable>] GENERATED ALWAYS AS (<replaceable>expression</replaceable>)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>alter table Friends
  add fullname varchar(74)
  generated always as
    (firstname || coalesce(' ' || middlename, '') || ' ' || lastname)</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-at-unique-keys">
          <title><database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple
            – are now allowed in columns with a <database>UNIQUE</database> constraint. For a full
            discussion, see <link linkend="langrefupd25-ct-unique-keys"><citetitle><database>CREATE
            TABLE</database> :: <database>UNIQUE</database> constraints now allow
            <constant>NULL</constant>s</citetitle></link>.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-at-using-index">
          <title><database>USING INDEX</database> subclause</title>
          <formalpara>
            <title>Available in</title>
            <para>DSQL</para>
            <!--ESQL: no support found in source-->
          </formalpara>
          <formalpara>
            <title>Added in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>A <database>USING INDEX</database> subclause can be placed at the end of a
            primary, unique or foreign key definition. Its purpose is to<itemizedlist
                spacing="compact">
                <listitem>
                  <para>provide a user-defined name for the automatically created index that
                  enforces the constraint, and</para>
                </listitem>
                <listitem>
                  <para>optionally define the index to be ascending or descending (the default being
                  ascending).</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>[ADD] [CONSTRAINT <replaceable>constraint-name</replaceable>]
<replaceable>   &lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
              </blockquote></para>
          </formalpara>
          <para>For a full discussion and examples, see <link
          linkend="langrefupd25-ct-using-index"><citetitle><database>CREATE TABLE</database> ::
          <database>USING INDEX</database> subclause</citetitle></link>.</para>
        </section>
      </section>
      <section id="langrefupd25-recreate-table">
        <title><database>RECREATE TABLE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates or recreates a table. If a table with the same name already exists,
          <database>RECREATE TABLE</database> will try to drop it (destroying all its data in the
          process!) and create a new table. <database>RECREATE TABLE</database> will fail if the
          existing table is in use.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <link
          linkend="langrefupd25-create-table"><citetitle><database>CREATE
          TABLE</database></citetitle></link>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-ddl-trigger">
      <title><database>TRIGGER</database></title>
      <section id="langrefupd25-create-trigger">
        <title><database>CREATE TRIGGER</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates a trigger, a block of PSQL code that is executed automatically upon certain
          database events or mutations to a table or view.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <!--DATABASE TRIGGERS SUPPORTED IN ESQL ???-->
              <programlisting>CREATE TRIGGER <replaceable>name</replaceable>
   {<replaceable>&lt;relation_trigger_legacy&gt;</replaceable>
      | <replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>
      | <replaceable>&lt;database_trigger&gt;</replaceable>        }
   AS
      [<replaceable>&lt;declarations&gt;</replaceable>]
   BEGIN
      [<replaceable>&lt;statements&gt;</replaceable>]
   END

<replaceable>&lt;relation_trigger_legacy&gt;</replaceable>   ::=  FOR {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
                                 [ACTIVE | INACTIVE]
                                 {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
                                 [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;relation_trigger_sql2003&gt;</replaceable>  ::=  [ACTIVE | INACTIVE]
                                 {BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable>
                                 [POSITION <replaceable>number</replaceable>]
                                 ON {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}

<replaceable>&lt;database_trigger&gt;</replaceable>          ::=  [ACTIVE | INACTIVE]
                                 ON <replaceable>db_event</replaceable>
                                 [POSITION <replaceable>number</replaceable>]

<replaceable>&lt;mutation_list&gt;</replaceable>             ::=  <replaceable>mutation</replaceable> [OR <replaceable>mutation</replaceable> [OR <replaceable>mutation</replaceable>]]
<replaceable>mutation</replaceable>                    ::=  INSERT | UPDATE | DELETE

<replaceable>db_event</replaceable>                    ::=  CONNECT | DISCONNECT | TRANSACTION START
                                   | TRANSACTION COMMIT | TRANSACTION ROLLBACK

<replaceable>number</replaceable>                      ::=  0..32767 (default is 0)

<replaceable>&lt;declarations&gt;</replaceable>              ::=  See <link
                  linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax</programlisting>
              <itemizedlist>
                <listitem>
                  <para><quote>Legacy</quote> and <quote>sql2003</quote> relation triggers are
                  exactly the same. The only thing that differs is the creation syntax.</para>
                </listitem>
                <listitem>
                  <para>Triggers with lower position numbers fire first. Position numbers need not
                  be unique, but if two or more triggers have the same position, the firing order
                  between them is undefined.</para>
                </listitem>
                <listitem>
                  <para>When defining relation triggers, each mutation type
                  (<database>INSERT</database>, <database>UPDATE</database> or
                  <database>DELETE</database>) may occur at most once in the mutation list.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-create-trigger-on-syntax">
          <title>SQL-2003-compliant syntax for relation triggers</title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Since Firebird 2.1, an alternative, SQL-2003-compliant syntax can be used for
            triggers on tables and views. Instead of specifying <quote><database>FOR</database>
            <replaceable>relationname</replaceable></quote> before the event type and the optional
            directives surrounding it, you can now put <quote><database>ON</database>
            <replaceable>relationname</replaceable></quote> after it, as shown in the syntax earlier
            in this chapter.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create trigger biu_books
  active before insert or update position 3
  on books
as
begin
  if (new.id is null)
    then new.id = next value for gen_bookids;
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-dbtriggers">
          <title>Database triggers</title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Since Firebird 2.1, triggers can be defined to fire upon the database events
            <database>CONNECT</database>, <database>DISCONNECT</database>, <database>TRANSACTION
            START</database>, <database>TRANSACTION COMMIT</database> and <database>TRANSACTION
            ROLLBACK</database>. Only the database owner and <database>SYSDBA</database> can create,
            alter and drop these triggers.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>CREATE TRIGGER <replaceable>name</replaceable>
   [ACTIVE | INACTIVE]
   ON <replaceable>db_event</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
      [<replaceable>&lt;declarations&gt;</replaceable>]
   BEGIN
      [<replaceable>&lt;statements&gt;</replaceable>]
   END

<replaceable>db_event</replaceable>                    ::=  CONNECT | DISCONNECT | TRANSACTION START
                                   | TRANSACTION COMMIT | TRANSACTION ROLLBACK

<replaceable>number</replaceable>                      ::=  0..32767 (default is 0)

<replaceable>&lt;declarations&gt;</replaceable>              ::=  See <link
                    linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create trigger tr_connect
  on connect
as
begin
  insert into dblog (wie, wanneer, wat)
    values (current_user, current_timestamp, 'verbind');
end</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Execution of database triggers and handling of exceptions</title>
            <para><itemizedlist>
                <listitem>
                  <para><database>CONNECT</database> and <database>DISCONNECT</database> triggers
                  are executed in a transaction created specifically for this purpose. If all goes
                  well, the transaction is committed. Uncaught exceptions roll back the transaction,
                  and:</para>
                  <itemizedlist spacing="compact">
                    <listitem>
                      <para>In the case of a <database>CONNECT</database> trigger, the connection is
                      then broken and the exception returned to the client.</para>
                    </listitem>
                    <listitem>
                      <para>With a <database>DISCONNECT</database> trigger, exceptions are not
                      reported and the connection is broken as foreseen.</para>
                    </listitem>
                  </itemizedlist>
                  <!--Tried out the above and indeed: if a CONNECT trigger causes an exception,
you can NOT access the database, except with isql -nodbtriggers!-->
                  <!--Do TRANSACTION triggers fire in this specific transaction?-->
                </listitem>
                <listitem>
                  <para><database>TRANSACTION</database> triggers are executed within the
                  transaction whose opening, committing or rolling-back evokes them. The actions
                  taken after an uncaught exception depend on the type:</para>
                  <itemizedlist spacing="compact">
                    <listitem>
                      <para>In a <database>START</database> trigger, the exception is reported to
                      the client and the transaction is rolled back.</para>
                    </listitem>
                    <listitem>
                      <para>In a <database>COMMIT</database> trigger, the exception is reported, the
                      trigger's actions so far are undone and the commit is canceled.</para>
                    </listitem>
                    <listitem>
                      <para>In a <database>ROLLBACK</database> trigger, the exception is not
                      reported and the transaction is rolled back as foreseen.</para>
                    </listitem>
                  </itemizedlist>
                  <!--Find out: if the 3rd TRANSACTION COMMIT trigger excepts, is the work of the previous two also undone?-->
                </listitem>
                <listitem>
                  <para>It follows from the above that there is no direct way of knowing if a
                  <database>DISCONNECT</database> or <database>TRANSACTION ROLLBACK</database>
                  trigger caused an exception.</para>
                </listitem>
                <listitem>
                  <para>It also follows that you can't connect to a database if a
                  <database>CONNECT</database> trigger causes an exception, and that you can't start
                  a transaction if a <database>TRANSACTION START</database> trigger does so. Both
                  phenomena effectively lock you out of your database while you need to get in there
                  to fix the problem. See the note below for a way around this Catch-22
                  situation.</para>
                </listitem>
                <listitem>
                  <para>In the case of a two-phase commit, <database>TRANSACTION COMMIT</database>
                  triggers fire in the prepare, not the commit phase.</para>
                  <!--And how about START and ROLLBACK triggers?-->
                </listitem>
              </itemizedlist></para>
          </formalpara>
          <note>
            <para>Some Firebird command-line tools have been supplied with new switches to suppress
            the automatic firing of database triggers:</para>
            <blockquote>
              <programlisting>gbak -nodbtriggers
isql -nodbtriggers
nbackup -T</programlisting>
            </blockquote>
            <para>These switches can only be used by the database owner and
            <database>SYSDBA</database>.</para>
            <!--Find out: is there an API equivalent for this? Otherwise you can't access databases with an exception-raising CONNECT trigger other than with isql!-->
            <!--What with gbak -c used to change the ownership? Can you not use nodbtriggers then?-->
          </note>
        </section>
        <section id="langrefupd25-create-trigger-typeofcolumn">
          <title><database>TYPE OF COLUMN</database> in variable declarations</title>
          <formalpara>
            <title>Added in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Analogous to the <quote><database>TYPE OF</database>
            <replaceable>domain</replaceable></quote> syntax supported since version 2.1, it is now
            also possible to declare variables as having the type of an existing table or view
            column. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-domains">
          <title>Domains instead of datatypes</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow the use of domains instead of SQL datatypes when
            declaring local trigger variables. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for the exact syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-collate">
          <title><database>COLLATE</database> in variable declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>COLLATE</database> clauses in local variable
            declarations. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-notnull">
          <title><database>NOT NULL</database> in variable declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>NOT NULL</database> constraints in local
            variable declarations. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-multiaction">
          <title>Multi-action triggers</title>
          <formalpara>
            <title>Added in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Relation triggers can be defined to fire upon multiple operations
            (<database>INSERT</database> and/or <database>UPDATE</database> and/or
            <database>DELETE</database>). Three new boolean context variables
            (<varname>INSERTING</varname>, <varname>UPDATING</varname> and
            <varname>DELETING</varname>) have been added so you can execute code conditionally
            within the trigger body depending on the type of operation.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create trigger biu_parts for parts
  before insert or update
as
begin
  /* conditional code when inserting: */
  if (inserting and new.id is null)
    then new.id = gen_id(gen_partrec_id, 1);
  
  /* common code: */
  new.partname_upper = upper(new.partname);
end</programlisting>
              </blockquote></para>
          </formalpara>
          <note>
            <para>In multi-action triggers, both context variables <database>OLD</database> and
            <database>NEW</database> are always available. If you use them in the wrong situation
            (i.e. <database>OLD</database> while inserting or <database>NEW</database> while
            deleting), the following happens:</para>
            <itemizedlist spacing="compact">
              <listitem>
                <para>If you try to read their field values, <constant>NULL</constant> is
                returned.</para>
              </listitem>
              <listitem>
                <para>If you try to assign values to them, a runtime exception is thrown.</para>
              </listitem>
            </itemizedlist>
          </note>
        </section>
        <section id="langrefupd25-create-trigger-empty">
          <title><database>BEGIN ... END</database> blocks may be empty</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
            allowing you to write stub code without having to resort to dummy statements.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-changecount">
          <title><database>CREATE TRIGGER</database> no longer increments table change count</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In contrast to InterBase, Firebird does not increment the metadata change counter
            of the associated table when <database>CREATE</database>, <database>ALTER</database> or
            <database>DROP TRIGGER</database> is used. For a full discussion, see <link
            linkend="langrefupd25-alter-trigger-changecount"><citetitle><database>ALTER
            TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-create-trigger-plan">
          <title><database>PLAN</database> allowed in trigger code</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
            would be rejected by the compiler. Now a valid plan can be included and will be
            used.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-alter-trigger">
        <title><database>ALTER TRIGGER</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Alters an existing trigger. Relation triggers cannot be changed into database
          triggers or vice versa. The associated table or view of a relation trigger cannot be
          changed.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <!--DATABASE TRIGGERS SUPPORTED IN ESQL ???-->
              <programlisting>ALTER TRIGGER <replaceable>name</replaceable>
   [ACTIVE | INACTIVE]
   [{BEFORE | AFTER} <replaceable>&lt;mutation_list&gt;</replaceable> | ON <replaceable>db_event</replaceable>]
   [POSITION <replaceable>number</replaceable>]
   [AS
       [<replaceable>&lt;declarations&gt;</replaceable>]
    BEGIN
       [<replaceable>&lt;statements&gt;</replaceable>]
    END                ]</programlisting>
              <itemizedlist>
                <listitem>
                  <para>See <link linkend="langrefupd25-create-trigger"><citetitle><database>CREATE
                  TRIGGER</database></citetitle></link> for the meaning of
                  <replaceable>&lt;mutation_list&gt;</replaceable> etc.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-alter-trigger-dbtriggers">
          <title>Database triggers</title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>The <database>ALTER TRIGGER</database> syntax (see above) has been extended to
            support database triggers. For a full discussion of this feature, see <link
            linkend="langrefupd25-create-trigger-dbtriggers"><citetitle><database>CREATE
            TRIGGER</database> :: Database triggers</citetitle></link>.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-typeofcolumn">
          <title><database>TYPE OF COLUMN</database> in variable declarations</title>
          <formalpara>
            <title>Added in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Analogous to the <quote><database>TYPE OF</database>
            <replaceable>domain</replaceable></quote> syntax supported since version 2.1, it is now
            also possible to declare variables as having the type of an existing table or view
            column. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-domains">
          <title>Domains instead of datatypes</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow the use of domains instead of SQL datatypes when
            declaring local trigger variables. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for the exact syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-collate">
          <title><database>COLLATE</database> in variable declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>COLLATE</database> clauses in local variable
            declarations. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-notnull">
          <title><database>NOT NULL</database> in variable declarations</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow <database>NOT NULL</database> constraints in local
            variable declarations. See <link
            linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link>
            for syntax and details.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-multiaction">
          <title>Multi-action triggers</title>
          <formalpara>
            <title>Added in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>The <database>ALTER TRIGGER</database> syntax (see above) has been extended to
            support multi-action triggers. For a full discussion of this feature, see <link
            linkend="langrefupd25-create-trigger-multiaction"><citetitle><database>CREATE
            TRIGGER</database> :: Multi-action triggers</citetitle></link>.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-restr">
          <title>Restriction on altering used triggers</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.0.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-plan">
          <title><database>PLAN</database> allowed in trigger code</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
            would be rejected by the compiler. Now a valid plan can be included and will be
            used.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-alter-trigger-changecount">
          <title><database>ALTER TRIGGER</database> no longer increments table change count</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Each time you use <database>CREATE</database>, <database>ALTER</database> or
            <database>DROP TRIGGER</database>, InterBase increments the metadata change counter of
            the associated table. Once that counter reaches 255, no more metadata changes are
            possible on the table (you can still work with the data though). A backup-restore cycle
            is needed to reset the counter and perform metadata operations again.</para>
          </formalpara>
          <para>While this obligatory cleanup after many metadata changes is in itself a useful
          feature, it also means that users who regularly use <database>ALTER TRIGGER</database> to
          deactivate triggers during e.g. bulk import operations are forced to backup and restore
          much more often then needed.</para>
          <para>Since changes to triggers don't imply structural changes to the table itself,
          Firebird no longer increments the table change counter when <database>CREATE</database>,
          <database>ALTER</database> or <database>DROP TRIGGER</database> is used. One thing has
          remained though: once the counter is at 255, you can no longer create, alter or drop
          triggers for that table.</para>
        </section>
      </section>
      <section id="langrefupd25-create-or-alter-trigger">
        <title><database>CREATE OR ALTER TRIGGER</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If the trigger does not yet exist, it is created just as if <database>CREATE
          TRIGGER</database> were used. If it already exists, it is altered and recompiled. Existing
          permissions and dependencies are preserved.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as for <database>CREATE TRIGGER</database>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-drop-trigger">
        <title><database>DROP TRIGGER</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <section id="langrefupd25-drop-trigger-restr">
          <title>Restriction on dropping used triggers</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.0.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-drop-trigger-changecount">
          <title><database>DROP TRIGGER</database> no longer increments table change count</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In contrast to InterBase, Firebird does not increment the metadata change counter
            of the associated table when <database>CREATE</database>, <database>ALTER</database> or
            <database>DROP TRIGGER</database> is used. For a full discussion, see <link
            linkend="langrefupd25-alter-trigger-changecount"><citetitle><database>ALTER
            TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-recreate-trigger">
        <title><database>RECREATE TRIGGER</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates or recreates a trigger. If a trigger with the same name already exists,
          <database>RECREATE TRIGGER</database> will try to drop it and create a new trigger.
          <database>RECREATE TRIGGER</database> will fail if the existing trigger is in use.<!--Make sure this last statement is true!--></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <link linkend="langrefupd25-create-trigger"><database>CREATE
          TRIGGER</database></link>.</para>
        </formalpara>
        <section id="langrefupd25-recreate-trigger-restr">
          <title>Restriction on recreating used triggers</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.0.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from
            dropping, altering or recreating a trigger or stored procedure if it has been used since
            the database was opened. This restriction has been removed again in version 2.0.1.
            Still, performing these operations on a live database is potentially risky and should
            only be done with the utmost care.</para>
          </formalpara>
        </section>
      </section>
    </section>
    <section id="langrefupd25-ddl-view">
      <title><database>VIEW</database></title>
      <section id="langrefupd25-create-view">
        <title><database>CREATE VIEW</database></title>
        <!--In the 2.0 Rlsnotes:
  Changed Logic for View Updates
  Apply NOT NULL constraints to base tables only, ignoring the ones inherited by view columns
  from domain definitions.

This looked weird: view columns can't specify a datatype or domain, so how in the world
can they inherit a NOT NULL constraint from a domain, *other than through the base table* ?!

Reaction Dmitry (31-10-2008):
 "IIRC, this change allows to pass NULLs to views that are made updateable
  via triggers (as they can override that value with something valid)."

Some testing revealed that 1.5 had a problem, not with not-null fields that participated in the
view (as long as a trigger converted the nulls before submitting the data to the table), but with
not-null fields that were left out of the view - even if a trigger supplied a valid value for
them. For those columns you would get a validation error. This has been fixed in 2.0-->
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE VIEW <replaceable>viewname</replaceable> [<replaceable>&lt;full_column_list&gt;</replaceable>]
   AS
   <replaceable>&lt;select_statement&gt;</replaceable>
   [WITH CHECK OPTION]

<replaceable>&lt;full_column_list&gt;</replaceable>  ::=  (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])</programlisting>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-creatview-from-sp">
          <title>Views can select from stored procedures</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.5 and up, views can select from selectable stored procedures.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>create view low_bones as
  select id, name, description from them_bones('human')
  where name in ('leg_bone', 'foot_bone', 'toe_bone')</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatview-infer-colnames">
          <title>Views can infer column names from derived tables or <database>GROUP
          BY</database></title>
          <formalpara>
            <title>Changed in</title>
            <para>2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2.5 and up, views can infer the names of columns from a derived table
            or involved in a GROUP BY clause. Previously it was necessary to specify explicit
            aliases for these columns (either per column or in a full list).</para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <programlisting>create view tickle as
  select t from (select t from tackle)</programlisting>
                <programlisting>create view vstocks as
  select kind, sum(stock) s from stocks
  group by kind</programlisting>
                <para>In the second example, notice that it is still necessary to alias the
                <database>SUM</database> column. Previous Firebird versions also required an
                explicit alias for the <database>KIND</database> column.</para>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatview-colaliases">
          <title>Per-column aliases supported in view definition</title>
          <!--Since the full SELECT syntax was already supported for views in 2.0, check in 2.0:
- whether column aliases are supported in the SELECT, and if so:
- whether they are indeed used as view column names, and if so:
- whether they can render the full column name list superfluous.-->
          <formalpara>
            <title>Changed in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.1 and up allow the use of column aliases in the
            <database>SELECT</database> statement. You can alias none, some or all of the columns;
            each alias used becomes the name of the corresponding view column.</para>
          </formalpara>
          <formalpara>
            <title>Syntax (partial)</title>
            <para><blockquote>
                <programlisting>CREATE VIEW viewname [<replaceable>&lt;full_column_list&gt;</replaceable>]
   AS
   SELECT <replaceable>&lt;column_def&gt;</replaceable> [, <replaceable>&lt;column_def&gt;</replaceable> ...]
   ...

<replaceable>&lt;full_column_list&gt;</replaceable>  ::=  (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])

<replaceable>&lt;column_def&gt;</replaceable>        ::=  {<replaceable>source_col</replaceable> | <replaceable>expr</replaceable>} [[AS] <replaceable>colalias</replaceable>]</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>If the full column list is also present, specifying column aliases is futile
                  as they will be overridden by the names in the column list.</para>
                </listitem>
                <listitem>
                  <para>The full column list used to be mandatory for views whose
                  <database>SELECT</database> statement contains expression-based columns or
                  identical column names. Now you can omit the full column list, provided that you
                  alias such columns in the <database>SELECT</database> clause.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatview-fullselect">
          <title>Full <database>SELECT</database> syntax supported</title>
          <!--IB6 LangRef p.88: UNIONs in views supported in ESQL, but not in DSQL.-->
          <formalpara>
            <title>Changed in</title>
            <para>2.0, 2.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>From Firebird 2.0 onward view definitions are considered full-fledged
            <database>SELECT</database> statements. Consequently, the following elements are
            (re)allowed in view definitions: <database>FIRST</database>, <database>SKIP</database>,
            <database>ROWS</database>, <database>ORDER BY</database>, <database>PLAN</database> and
            <database>UNION</database>.</para>
          </formalpara>
          <note id="langrefupd25-creatview-fullselect-union">
            <para>In Firebird 2.5 and up, it is no longer necessary to supply a view column list if
            the view is based on a <database>UNION</database>:</para>
            <programlisting>create view vplanes as
  select make, model from jets
    union
  select make, model from props
    union
  select make, model from gliders</programlisting>
            <para>The column names will be taken from the union. Of course you can still override
            them with a view column list.</para>
          </note>
        </section>
        <section id="langrefupd25-creatview-noplan">
          <title><database>PLAN</database> subclause disallowed in 1.5, reallowed in 2.0</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5, 2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird versions 1.5.x forbid the use of a <database>PLAN</database> subclause in
            a view definition. From 2.0 onward a <database>PLAN</database> is allowed again.</para>
          </formalpara>
        </section>
        <section id="langrefupd25-creatview-triggers">
          <title>Triggers on updatable views block auto-writethrough</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In versions prior to 2.0, Firebird often did not block the automatic writethrough
            to the underlying table if one or more triggers were defined on a naturally updatable
            view. This could cause mutations to be performed twice unintentionally, sometimes
            leading to data corruption and other mishaps. Starting at Firebird 2.0, this
            misbehaviour has been corrected: now if you define a trigger on a naturally updatable
            view, no mutations to the view will be automatically passed on to the table; either your
            trigger takes care of that, or nothing will. This is in accordance with the description
            in the InterBase 6 <citetitle>Data Definition Guide</citetitle> under
            <citetitle>Updating views with triggers</citetitle>.</para>
          </formalpara>
          <warning>
            <para>Some people have developed code that counts on or takes advantage of the prior
            behaviour. Such code should be corrected for Firebird 2.0 and higher, or mutations may
            not reach the table at all.</para>
          </warning>
        </section>
        <section id="langrefupd25-creatview-insertable">
          <title>View with non-participating <database>NOT NULL</database> columns in base table can
          be made insertable</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Any view whose base table contains one or more non-participating <database>NOT
            NULL</database> columns is read-only by nature. It can be made updatable by the use of
            triggers, but even with those, all <database>INSERT</database> attempts into such views
            used to fail because the <database>NOT NULL</database> constraint on the base table was
            checked before the view trigger got a chance to put things right. In Firebird 2.0 and up
            this is no longer the case: provided the right trigger is in place, such views are now
            insertable.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <para>The view below would give validation errors for any insert attempts in
                Firebird 1.5 and earlier. In Firebird 2.0 and up it is insertable:</para>
                <programlisting>create table base (x int not null, y int not null);

create view vbase as select x from base;

set term #;
create trigger bi_base for vbase before insert
as
begin
  if (new.x is null) then new.x = 33;
  insert into base values (new.x, 0);
end#
set term ;#</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>Please notice that the problem described above only occurred for
                  <database>NOT NULL</database> columns that were left <emphasis>outside</emphasis>
                  the view.</para>
                </listitem>
                <listitem>
                  <para>Oddly enough, the problem would be gone if the base table itself had a
                  trigger converting <constant>NULL</constant> input to something valid.<!--Is this also true if adding the trigger does NOT make the view updatable according to Firebird?
Test with e.g. a join.--> But then there was a risk that the insert would take place twice, due to
                  the <link linkend="langrefupd25-creatview-triggers">auto-writethrough bug</link>
                  that has also been fixed in Firebird 2.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-alter-view">
        <title><database>ALTER VIEW</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2.5 and up support <database>ALTER VIEW</database>, allowing you to change
          a view's definition without having to drop it first. Existing dependencies are
          preserved.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <link linkend="langrefupd25-create-view"><database>CREATE
          VIEW</database></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-create-or-alter-view">
        <title><database>CREATE OR ALTER VIEW</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>CREATE OR ALTER VIEW</database> will create the view if it doesn't exist.
          Otherwise, it will alter the existing view, preserving existing dependencies.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <link linkend="langrefupd25-create-view"><database>CREATE
          VIEW</database></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-recreate-view">
        <title><database>RECREATE VIEW</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Creates or recreates a view. If a view with the same name already exists,
          <database>RECREATE VIEW</database> will try to drop it and create a new view.
          <database>RECREATE VIEW</database> will fail if the existing view is in use.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para>Exactly the same as <link linkend="langrefupd25-create-view"><database>CREATE
          VIEW</database></link>.</para>
        </formalpara>
      </section>
    </section>
    <!--None of the "CREATE OR ALTER" statements seems available in ESQL:-->
    <!--RECREATE seems totally absent from ESQL-->
  </chapter>
  <chapter id="langrefupd25-dml">
    <title>DML statements</title>
    <!--Rlsnotes 1.0:
  New PLANONLY option for statements
  Support for PLANONLY setting, allows for a statement/query to be submitted to the engine and
  the plan retrieved, without executing the statement/query.

As it turns out, this refers to SET PLANONLY in isql. You can NOT just add PLANONLY
to SQL statements!-->
    <section id="langrefupd25-delete">
      <title><database>DELETE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Deletes rows from a database table (or from one or more tables underlying a view),
        depending on the <database>WHERE</database> and <database>ROWS</database> clauses.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <!--Both IB6 LangRef and IBP RefGuide forget to mention views.-->
            <!--DELETE and UPDATE allow a table/view alias, also in 1.5.3.
Find out since when (this is not mentioned in IB LangRef) and document it with DELETE and UPDATE, possibly also in LangRefUpd-1.5-->
            <programlisting>DELETE
   [TRANSACTION <replaceable>name</replaceable>]
   FROM {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>
                <listitem>
                  <para>In a pure DSQL session, <database>WHERE CURRENT OF</database> isn't of much
                  use, since there exists no DSQL statement to create a cursor.</para>
                </listitem>
                <listitem>
                  <para>The <database>PLAN</database>, <database>ORDER BY</database> and
                  <database>ROWS</database> clauses are not available in ESQL.</para>
                </listitem>
                <listitem>
                  <para>The <database>RETURNING</database> clause is not available in ESQL.<!--Sure about that ?--></para>
                </listitem>
                <listitem>
                  <para>The <quote><database>INTO</database>
                  <replaceable>&lt;variables&gt;</replaceable></quote> subclause is only available
                  in PSQL.</para>
                </listitem>
                <listitem>
                  <para>When returning values into the context variable <database>NEW</database>,
                  this name must not be preceded by a colon
                  (<quote><literal>:</literal></quote>).</para>
                </listitem>
              </itemizedlist>
            </note>
            <!--Are only 'loose' plan_items allowed, or also JOIN, SORT, MERGE ?-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-delete-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>delete from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-delete-orderby">
        <title><database>ORDER BY</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>DELETE</database> now allows an <database>ORDER BY</database> clause. This
          only makes sense in combination with <database>ROWS</database>, but is also valid without
          it.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-delete-plan">
        <title><database>PLAN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>DELETE</database> now allows a <database>PLAN</database> clause, so users
          can optimize the operation manually.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-delete-alias-use">
        <title>Relation alias makes real name unavailable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you give a table or view an alias in a Firebird 2.0 or above statement, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that relation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Correct usage:</para>
              <programlisting>delete from Cities where name starting 'Alex'</programlisting>
              <programlisting>delete from Cities where Cities.name starting 'Alex'</programlisting>
              <programlisting>delete from Cities C where name starting 'Alex'</programlisting>
              <programlisting>delete from Cities C where C.name starting 'Alex'</programlisting>
              <para>No longer possible:</para>
              <programlisting>delete from Cities C where Cities.name starting 'Alex'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-delete-returning">
        <title><database>RETURNING</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>DELETE</database> statement removing <emphasis>at most one
          row</emphasis> may optionally include a <database>RETURNING</database> clause in order to
          return values from the deleted row. The clause, if present, need not contain all of the
          relation's columns and may also contain other columns or expressions.</para>
          <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>delete from Scholars
  where firstname = 'Henry' and lastname = 'Higgins'
  returning lastname, fullname, id</programlisting>
              <programlisting>delete from Dumbbells
  order by iq desc
  rows 1
  returning lastname, iq into :lname, :iq;</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>In DSQL, a statement with a <database>RETURNING</database> clause <emphasis
                role="">always</emphasis> returns exactly one row. If no record was actually
                deleted, the fields in this row are all <constant>NULL</constant>. This behaviour
                may change in a later version of Firebird. In PSQL, if no row was deleted, nothing
                is returned, and the receiving variables keep their existing values.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-delete-rows">
        <title><database>ROWS</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Limits the amount of rows deleted to a specified number or range.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            </blockquote></para>
        </formalpara>
        <para>With a single argument <replaceable>m</replaceable>, the deletion is limited to the
        first <replaceable>m</replaceable> rows of the dataset defined by the table or view and the
        optional <database>WHERE</database> and <database>ORDER BY</database> clauses.</para>
        <para>Points to note:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> = 0, no rows are deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>
        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, the
        deletion is limited to rows <replaceable>m</replaceable> to <replaceable>n</replaceable>
        inclusively. Row numbers are 1-based.</para>
        <para>Points to note when using two arguments:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, no
            rows are deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, no rows are
            deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>
        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd25-select-rows"><database>SELECT</database></link> and <link
        linkend="langrefupd25-update-rows"><database>UPDATE</database></link> statements.</para>
      </section>
    </section>
    <section id="langrefupd25-execblock">
      <title><database>EXECUTE BLOCK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1, 2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a block of PSQL code as if it were a stored procedure, optionally with input
        and output parameters and variable declarations. This allows the user to perform
        <quote>on-the-fly</quote> PSQL within a DSQL context.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparams&gt;</replaceable>      ::=  <replaceable>&lt;param_decl&gt;</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable> ]
<replaceable>&lt;outparams&gt;</replaceable>     ::=  <replaceable>&lt;param_decl&gt;</replaceable>     [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;param_decl&gt;</replaceable>    ::=  <replaceable>paramname</replaceable> <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [COLLATE <replaceable>collation</replaceable>]
<replaceable>&lt;type&gt;</replaceable>          ::=  <replaceable>sql_datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>
<replaceable>&lt;declarations&gt;</replaceable>  ::=  See <link linkend="langrefupd25-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>This example injects the numbers 0 through 127 and their corresponding ASCII
            characters into the table <database>ASCIITABLE</database>:</para>
            <programlisting>execute block
as
declare i int = 0;
begin
  while (i &lt; 128) do
  begin
    insert into AsciiTable values (:i, ascii_char(:i));
    i = i + 1;
  end
end</programlisting>
          </blockquote><blockquote>
            <para>The next example calculates the geometric mean of two numbers and returns it to
            the user:</para>
            <programlisting>execute block (x double precision = ?, y double precision = ?)
returns (gmean double precision)
as
begin
  gmean = sqrt(x*y);
  suspend;
end</programlisting>
            <para>Because this block has input parameters, it has to be prepared first. Then the
            parameters can be set and the block executed. It depends on the client software how this
            must be done and even if it is possible at all – see the notes below.</para>
            <para>Our last example takes two integer values, <varname>smallest</varname> and
            <varname>largest</varname>. For all the numbers in the range <varname>smallest</varname>
            .. <varname>largest</varname>, the block outputs the number itself, its square, its cube
            and its fourth power.</para>
            <programlisting>execute block (smallest int = ?, largest int = ?)
returns (number int, square bigint, cube bigint, fourth bigint)
as
begin
  number = smallest;
  while (number &lt;= largest) do
  begin
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    suspend;
    number = number + 1;
  end
end</programlisting>
            <para>Again, it depends on the client software if and how you can set the parameter
            values.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Some clients, especially those allowing the user to submit several statements at
              once, may require you to surround the <database>EXECUTE BLOCK</database> statement
              with <database>SET TERM</database> lines, like this:</para>
              <programlisting>set term #;
execute block (...)
as
begin
  statement1;
  statement2;
end
#
set term ;#</programlisting>
              <para>In Firebird's <application>isql</application> client you must set the terminator
              to something other than <quote><literal>;</literal></quote> before you type in the
              <database>EXECUTE BLOCK</database> statement. Otherwise
              <application>isql</application>, being line-oriented, will try to execute the part you
              have entered as soon as it encounters the first semicolon.</para>
            </listitem>
            <listitem>
              <para>Executing a block without input parameters should be possible with every
              Firebird client that allows the user to enter his or her own DSQL statements. If there
              are input parameters, things get trickier: these parameters must get their values
              after the statement is prepared but before it is executed. This requires special
              provisions, which not every client application offers. (Firebird's own
              <application>isql</application>, for one, doesn't.)</para>
            </listitem>
            <listitem>
              <para>The server only accepts question marks (<quote><literal>?</literal></quote>) as
              placeholders for the input values, not <quote><literal>:a</literal></quote>,
              <quote><literal>:MyParam</literal></quote> etc., or literal values. Client software
              may support the <quote><literal>:xxx</literal></quote> form though, which it will
              preprocess before sending it to the server.</para>
            </listitem>
            <listitem>
              <para>If the block has output parameters, you <emphasis>must</emphasis> use
              <database>SUSPEND</database> or nothing will be returned.</para>
            </listitem>
            <listitem>
              <para>Output is always returned in the form of a result set, just as with a
              <database>SELECT</database> statement. You can't use
              <database>RETURNING_VALUES</database> or execute the block <database>INTO</database>
              some variables, even if there's only one result row.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <section id="langrefupd25-execblock-collate">
        <title><database>COLLATE</database> in variable and parameter declarations</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2.1 and up allow <database>COLLATE</database> clauses in declarations of
          input/output parameters and local variables.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>execute block
  (es_1 varchar(20) character set iso8859_1 collate es_es = ?)
returns
  (nl_1 varchar(20) character set iso8859_1 collate du_nl)
as
  declare s_temp varchar(100) character set utf8 collate unicode;
begin
  ...
  ...
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-execblock-notnull">
        <title><database>NOT NULL</database> in variable and parameter declarations</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2.1 and up allow <database>NOT NULL</database> constraints in declarations
          of input/output parameters and local variables.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>execute block (a int not null = ?, b int not null = ?)
returns (product bigint not null, message varchar(20) not null)
as
  declare useless_dummy timestamp not null;
begin
  product = a*b;
  if (product &lt; 0) then message = 'This is below zero.';
  else if (product &gt; 0) then message = 'This is above zero.';
  else message = 'This must be zero.';
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-execblock-domains">
        <title>Domains instead of datatypes</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2.1 and up allow the use of domains instead of SQL datatypes when declaring
          input/output parameters and local variables. With the <quote><database>TYPE
          OF</database></quote> modifier only the domain's type is used, not its <database>NOT
          NULL</database> setting, <database>CHECK</database> constraint and/or default value. If
          the domain is of a text type, its character set and collation are always included.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>execute block (a my_domain = ?, b type of my_other_domain = ?)
returns (p my_third_domain)
as
  declare s_temp type of my_third_domain;
begin
  ...
  ...
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>For input parameters, the collation that comes with the domain is not taken into
          consideration when comparisons (e.g. equality tests) are made. This is caused by a bug
          that has been fixed for Firebird 3.</para>
        </warning>
      </section>
      <section id="langrefupd25-execblock-typeofcolumn">
        <title><database>TYPE OF COLUMN</database> in parameter and variable declarations</title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Analogous to the <quote><database>TYPE OF</database>
          <replaceable>domain</replaceable></quote> syntax supported since version 2.1, it is now
          also possible to declare variables and parameters as having the type of an existing table
          or view column. Only the type itself is used; in the case of string types, this includes
          the character set and the collation. Constraints and default values are never copied from
          the source column.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table numbers (
  bignum   numeric(18),
  smallnum numeric(9)
)

execute block (dividend <emphasis role="bold"> type of column</emphasis> numbers.bignum = ?,
               divisor <emphasis role="bold">  type of column</emphasis> numbers.smallnum = ?)
      returns (quotient <emphasis role="bold"> type of column</emphasis> numbers.bignum,
               remainder <emphasis role="bold">type of column</emphasis> numbers.smallnum)
as
begin
  quotient  = dividend / divisor;
  remainder = mod (dividend, divisor);
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>For input parameters, the collation that comes with the column's type is not taken
          into consideration when comparisons (e.g. equality tests) are made. For local variables,
          the behaviour varies. This is caused by a bug that has been fixed for Firebird 3.</para>
          <!--For locvars, the collation is OK if the column's type is a *domain* with a collation. When defined directly, it fails.-->
        </warning>
      </section>
    </section>
    <section id="langrefupd25-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a stored procedure. In Firebird 1.0.x as well as in InterBase, any input
        parameters for the SP must be supplied as literals, host language variables (in ESQL) or
        local variables (in PSQL). In Firebird 1.5 and above, input parameters may also be
        (compound) expressions, except in static ESQL.</para>
      </formalpara>
      <!--Calling SP's with SELECT already allowed compound expressions as parameters in IB and Fb1.-->
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [TRANSACTION <replaceable>transaction</replaceable>]
   [<replaceable>&lt;in_item&gt;</replaceable> [, <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>   ::=  <replaceable>&lt;inparam&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable>  ::=  <replaceable>&lt;outvar&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;inparam&gt;</replaceable>   ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>    ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>   ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>
            <note>
              <title>Notes</title>
              <itemizedlist>
                <listitem>
                  <para><database>TRANSACTION</database> clauses are not supported in PSQL.</para>
                  <!--And in DSQL they are? That would surprise me. Find out!-->
                </listitem>
                <listitem>
                  <para>Expression parameters are not supported in static ESQL, and not in Firebird
                  versions below 1.5.</para>
                </listitem>
                <listitem>
                  <para><constant>NULL</constant> indicators are only valid in ESQL code. They must
                  be host language variables of type integer.</para>
                </listitem>
                <listitem>
                  <para>In ESQL, variable names used as parameters or outvars must be preceded by a
                  colon (<quote>:</quote>). In PSQL the colon is generally optional, but forbidden
                  for the trigger context variables <database>OLD</database> and
                  <database>NEW</database>.</para>
                  <!--When called with SELECT, the colon must always be present if the parameter is a variable (except OLD/NEW).
(Does this go for inparms as well as INTO outparms?)-->
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>In PSQL (with optional colons):</para>
            <programlisting>execute procedure MakeFullName
  :FirstName, :MiddleName, :LastName
  returning_values :FullName;</programlisting>
            <para>The same call in ESQL (with obligatory colons):</para>
            <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :MiddleName, :LastName
    returning_values :FullName;</programlisting>
            <para>...and in Firebird's command-line utility <application>isql (with literal
            parameters)</application>:</para>
            <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>
            <para><emphasis role="bold">Note:</emphasis> In isql, don't use
            <database>RETURNING_VALUES</database>. Any output values are shown automatically.</para>
            <para>Finally, a PSQL example with expression parameters, only possible in Firebird 1.5
            and up:</para>
            <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, MiddleName, upper(LastName)
  returning_values FullName;</programlisting>
          </blockquote></para>
      </formalpara>
      <!--1.5 Release Notes say:

  Dmitry Yemanov
  Calls to EXECUTE PROCEDURE ProcName(<Argument-list>) and SELECT <Output-list> FROM
  ProcName(<Argument-list>) can now accept local variables (in PSQL) and expressions
  (in DSQL and PSQL) as arguments.

However:
- Local variables were already usable as arguments in InterBase.
- With SELECT, even expressions were already allowed as arguments in InterBase.
So the only novelty in Firebird 1.5 is:
- Using expressions as arguments when calling an SP with EXECUTE PROCEDURE.-->
    </section>
    <section id="langrefupd25-insert">
      <title><database>INSERT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Adds rows to a database table, or to one or more tables underlying a view. Field
        values can be given in the <database>VALUES</database> clause, they can be totally absent
        (in both cases, exactly one row is inserted), or they can come from a
        <database>SELECT</database> statement (0 to many rows inserted).</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>INSERT [TRANSACTION <replaceable>name</replaceable>]
   INTO {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>}
   {DEFAULT VALUES | [(<replaceable>&lt;column_list&gt;</replaceable>)] <replaceable>&lt;value_source&gt;</replaceable>}
   [RETURNING <replaceable>&lt;value_list&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;column_list&gt;</replaceable>   ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;value_source&gt;</replaceable>  ::=  VALUES (<replaceable>&lt;value_list&gt;</replaceable>) | <replaceable>&lt;select_stmt&gt;</replaceable>
<replaceable>&lt;value_list&gt;</replaceable>    ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>     ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
<replaceable>&lt;select_stmt&gt;</replaceable>   ::=  a <database>SELECT</database> whose result set fits the target columns</programlisting>
            <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <!--I suppose DEFAULT VALUES not available in ESQL. Check.-->
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>
                <listitem>
                  <para>The <database>RETURNING</database> clause is not available in ESQL.<!--still not in 2.1 ?--></para>
                </listitem>
                <listitem>
                  <para>The <quote><database>INTO</database>
                  <replaceable>&lt;variables&gt;</replaceable></quote> subclause is only available
                  in PSQL.</para>
                </listitem>
                <listitem>
                  <para>When returning values into the context variable <database>NEW</database>,
                  this name must not be preceded by a colon
                  (<quote><literal>:</literal></quote>).</para>
                </listitem>
                <listitem>
                  <para>Since v. 2.0, no column may appear more than once in the insert list.</para>
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-insert-defaults">
        <title><database>INSERT</database> ... <database>DEFAULT VALUES</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL<!--Sure about PSQL? Also check ESQL--></para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>DEFAULT VALUES</database> clause allows insertion of a record without
          providing any values at all, neither directly nor from a <database>SELECT</database>
          statement. This is only possible if every <database>NOT NULL</database> or
          <database>CHECK</database>ed column in the table either has a valid default declared or
          gets such a value from a <database>BEFORE INSERT</database> trigger. Furthermore, triggers
          providing required field values must not depend on the presence of input values.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>insert into journal default values
  returning entry_id</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-insert-returning">
        <title><database>RETURNING</database> clause</title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>An <database>INSERT</database> statement adding <emphasis>at most one row</emphasis>
          may optionally include a <database>RETURNING</database> clause in order to return values
          from the inserted row. The clause, if present, need not contain all of the insert columns
          and may also contain other columns or expressions. The returned values reflect any changes
          that may have been made in <database>BEFORE</database> tiggers, but not those in
          <database>AFTER</database> triggers.</para>
          <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>insert into Scholars (firstname, lastname, address, phone, email)
  values ('Henry', 'Higgins', '27A Wimpole Street', '3231212', null)
  returning lastname, fullname, id</programlisting>
              <programlisting>insert into Dumbbells (firstname, lastname, iq)
  select fname, lname, iq from Friends order by iq rows 1
  returning id, firstname, iq into :id, :fname, :iq;</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para><database>RETURNING</database> is only supported for
                <database>VALUES</database> inserts and – since version 2.1 – singleton
                <database>SELECT</database> inserts.</para>
              </listitem>
              <listitem>
                <para>In DSQL, a statement with a <database>RETURNING</database> clause <emphasis
                role="">always</emphasis> returns exactly one row. If no record was actually
                inserted, the fields in this row are all <constant>NULL</constant>. This behaviour
                may change in a later version of Firebird. In PSQL, if no row was inserted, nothing
                is returned, and the receiving variables keep their existing values.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-insert-from-union">
        <title><database>UNION</database> allowed in feeding <database>SELECT</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>SELECT</database> query used in an <database>INSERT</database> statement
          may now be a <database>UNION</database>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>insert into Members (number, name)
  select number, name from NewMembers where Accepted = 1
    union
  select number, name from SuspendedMembers where Vindicated = 1</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-merge">
      <title><database>MERGE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL... guess not--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Merges data into a table or view. The source may a table, view or <link
        linkend="langrefupd25-derived-tables">derived table</link> (i.e. a parenthesized
        <database>SELECT</database> statement or <link
        linkend="langrefupd25-select-cte"><database>CTE</database></link>). Each source record will
        be used to update one or more target records, insert a new record in the target table, or
        neither. The action taken depends on the provided condition and the
        <database>WHEN</database> clause(s). The condition will typically contain a comparison of
        fields in the source and target relations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>MERGE INTO {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   USING {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
   ON <replaceable>condition</replaceable>
   WHEN MATCHED THEN UPDATE SET <replaceable>colname</replaceable> = <replaceable>value</replaceable> [, <replaceable>colname</replaceable> = <replaceable>value</replaceable> ...]
   WHEN NOT MATCHED THEN INSERT [(<replaceable>&lt;columns&gt;</replaceable>)] VALUES (<replaceable>&lt;values&gt;</replaceable>)

<replaceable>&lt;columns&gt;</replaceable>  ::=  <replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...]
<replaceable>&lt;values&gt;</replaceable>   ::=  <replaceable>value</replaceable>   [, <replaceable>value</replaceable>   ...]

<emphasis role="bold">Note:</emphasis> It is allowed to provide only one of the WHEN clauses</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>merge into books b
  using purchases p
  on p.title = b.title and p.type = 'bk'
  when matched then
    update set b.desc = b.desc || '; ' || p.desc
  when not matched then
    insert (title, desc, bought) values (p.title, p.desc, p.bought)</programlisting>
            <programlisting>merge into customers c
  using (select * from customers_delta where id &gt; 10) cd
  on (c.id = cd.id)
  when matched then update set name = cd.name
  when not matched then insert (id, name) values (cd.id, cd.name)</programlisting>
            <!--Second example provided by Adriano!-->
          </blockquote></para>
      </formalpara>
      <note>
        <para><database>WHEN NOT MATCHED</database> should be interpreted from the point of view of
        the <emphasis>source</emphasis> (the relation in the <database>USING</database> clause).
        That is: if a source record doesn't have a match in the target table, the
        <database>INSERT</database> clause is executed. Conversely, records in the target table
        without a matching source record don't trigger any action.</para>
      </note>
      <warning>
        <para>If the <database>WHEN MATCHED</database> clause is present and multiple source records
        match the same record in the target table, the <database>UPDATE</database> clause is
        executed for all the matching source records, each update overwriting the previous one. This
        is non-standard behaviour: SQL-2003 specifies that in such a case an exception must be
        raised.<!--http://tracker.firebirdsql.org/browse/CORE-2274--></para>
      </warning>
    </section>
    <section id="langrefupd25-select">
      <title><database>SELECT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd25-aggregates">
        <title>Aggregate functions: Extended functionality</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Several types of mixing and nesting aggragate functions are supported since Firebird
          1.5. They will be discussed in the following subsections. To get the complete picture,
          also look at the <database>SELECT</database> :: <database>GROUP BY</database>
          sections.</para>
        </formalpara>
        <section id="langrefupd25-aggregates-mix">
          <title>Mixing aggregate functions from different contexts</title>
          <para>Firebird 1.5 and up allow the use of aggregate functions from different contexts
          inside a single expression.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
          <para>This admittedly rather contrived query shows, in the second column, the maximum
          index selectivity of any index defined on a table, followed by the table's field count
          between parentheses. Of course you would normally display the field count in a separate
          column, or in the column with the table name, but the purpose here is to demonstrate that
          you can combine aggregates from different contexts in a single expression.</para>
          <warning>
            <para>Firebird 1.0 also executes this type of query, but gives the wrong results!</para>
          </warning>
        </section>
        <section id="langrefupd25-aggregates-in-subqueries">
          <title>Aggregate functions and <database>GROUP BY</database> items inside
          subqueries</title>
          <para>Since Firebird 1.5 it is possible to use aggregate functions and/or expressions
          contained in the <database>GROUP BY</database> clause inside a subquery.</para>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>This query returns each table's ID and field count. The subquery refers to
                <literal><systemitem>flds.rdb$relation_name</systemitem></literal>, which is also a
                <database>GROUP BY</database> item:</para>
                <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>
                <para>The next query shows the last field from each table and and its 1-based
                position. It uses the aggregate function <database>MAX</database> in a
                subquery.</para>
                <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>
                <para>The subquery also contains the <database>GROUP BY</database> item
                <systemitem>flds.rdb$relation_name</systemitem>, but that's not immediately obvious
                because in this case the <database>GROUP BY</database> clause uses the column
                number.</para>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-subqueries-in-aggregates">
          <title>Subqueries inside aggregate functions</title>
          <para>Using a singleton subselect inside (or as) an aggregate function argument is
          supported in Firebird 1.5 and up.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>
                <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-aggregates-nesting">
          <title>Nesting aggregate function calls</title>
          <para>Firebird 1.5 allows the indirect nesting of aggregate functions, provided that the
          inner function is from a lower SQL context. Direct nesting of aggregate function calls, as
          in <quote><database>COUNT</database>( <database>MAX</database>( price ) )</quote>, is
          still forbidden and punishable by exception.</para>
          <formalpara>
            <title>Example</title>
            <para>See under <link
            linkend="langrefupd25-subqueries-in-aggregates"><citetitle>Subqueries inside aggregate
            functions</citetitle></link>, where <database>COUNT()</database> is used inside a
            <database>SUM()</database>.</para>
          </formalpara>
          <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
        </section>
        <section id="langrefupd25-aggregates-having-orderby">
          <title>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></title>
          <para>Firebird 1.5 and above are stricter than previous versions about what can be
          included in the <database>HAVING</database> and <database>ORDER BY</database> clauses. If,
          in the context of an aggregate statement, an operand in a <database>HAVING</database> or
          <database>ORDER BY</database> item contains a column name,<!--This should probably be: ...contains a column name from the query context (i.e. from the table or join in the FROM clause).-->
          it is only accepted if one of the following is true:</para>
          <itemizedlist>
            <listitem>
              <para>The column name appears in an aggregate function call (e.g. <quote><code>HAVING
              MAX(SALARY) &gt; 10000</code></quote>).</para>
            </listitem>
            <listitem>
              <para>The operand equals or is based upon a non-aggregate column that appears in the
              <database>GROUP BY</database> list (by name or position).</para>
            </listitem>
            <!--This listitem commented out for now, needs research:
  o  The operand equals or is based upon a subquery, whether or not it is also a GROUP BY item.-->
            <!--See also under GROUP BY. Check if it is possible to include a non-aggregated subquery in the HAVING / ORDER BY
if that subquery contains columns not present in the GROUP BY.
And if this is possible, also look what happens if that subquery returns different values within a group.-->
          </itemizedlist>
          <para><quote>Is based upon</quote> means that the operand need not be exactly the same as
          the column name. Suppose there's a non-aggregate column
          <quote><database>STR</database></quote> in the select list. Then it's OK to use
          expressions like <quote><database>UPPER(STR)</database></quote>, <quote><database>STR ||
          '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4 FOR 2)</database></quote>
          in the <database>HAVING</database> clause – even if these expressions don't appear as such
          in the <database>SELECT</database> or <database>GROUP BY</database> list.</para>
          <!--If and when the subquery thing gets mentioned again, the above para must also be changed: ("...as the column name or subquery." etc.)-->
        </section>
      </section>
      <!--1.5 Rlsnotes say:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used in the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->
      <!--*******

Maybe the entire GROUP BY thing should become something like this:

Every column that is present - in non-aggregrated form - on the highest (outermost?) level in the context of an aggregated query
(i.e., is a column of the relation(s) in the FROM clause)
*must* be included in the GROUP BY clause.

Question: If such a column is present in a subquery, but with the table alias as defined in the outermost query context,
must it go in the GROUP BY? I think yes, but test!
Question 2: As above, but this time with its own alias, belonging to the subselect?
I think it doesn't have to go in the GROUP BY then, but test.
Question 3: If a relation does not have an alias in the uppermost FROM, and it is used in a subselect
also without an alias, does that mean they have the same context? I hope not...-->
      <section id="langrefupd25-select-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-select-cte">
        <title>Common Table Expressions (<quote><database>WITH ... AS ...
        SELECT</database></quote>)</title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL? Suppose not, but do find out / ask-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A common table expression or <database>CTE</database> can be described as a virtual
          table or view, defined in a preamble to a main query, and going out of scope after the
          main query's execution. The main query can reference any <database>CTE</database>s defined
          in the preamble as if they were regular tables or views. <database>CTE</database>s can be
          recursive, i.e. self-referencing, but they cannot be nested.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting><replaceable>&lt;cte-construct&gt;</replaceable>  ::=  <replaceable>&lt;cte-defs&gt;</replaceable>
                      <replaceable>&lt;main-query&gt;</replaceable>

<replaceable>&lt;cte-defs&gt;</replaceable>       ::=  WITH [RECURSIVE] <replaceable>&lt;cte&gt;</replaceable> [, <replaceable>&lt;cte&gt;</replaceable> ...]

<replaceable>&lt;cte&gt;</replaceable>            ::=  <replaceable>name</replaceable> [(<replaceable>&lt;column-list&gt;</replaceable>)] AS (<replaceable>&lt;cte-stmt&gt;</replaceable>)

<replaceable>&lt;column-list&gt;</replaceable>    ::=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]

<replaceable>&lt;cte-stmt&gt;</replaceable>       ::=  any <database>SELECT</database> statement or <database>UNION</database>

<replaceable>&lt;main-query&gt;</replaceable>     ::=  the main <database>SELECT</database> statement, which can refer to the
                      <database>CTE</database>s defined in the preamble</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting><emphasis role="bold">with dept_year_budget as (
  select fiscal_year,
         dept_no,
         sum(projected_budget) as budget
  from proj_dept_budget
  group by fiscal_year, dept_no
)</emphasis>
select d.dept_no,
       d.department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from department d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009
where exists (
  select * from proj_dept_budget b
  where d.dept_no = b.dept_no
)</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>A <database>CTE</database> definition can contain any legal
                <database>SELECT</database> statement, as long as it doesn't have a
                <quote><database>WITH...</database></quote> preamble of its own (no nesting).</para>
              </listitem>
              <listitem>
                <para><database>CTE</database>s defined for the same main query can reference each
                other, but care should be taken to avoid loops.</para>
                <!--Can a CTE also refer to another one that comes *after* it in the WITH clause?-->
              </listitem>
              <listitem>
                <para><database>CTE</database>s can be referenced from anywhere in the main
                query.</para>
              </listitem>
              <listitem>
                <para>Each <database>CTE</database> can be referenced multiple times in the main
                query, possibly with different aliases.</para>
              </listitem>
              <listitem>
                <para>When enclosed in parentheses, <database>CTE</database> constructs can be used
                as subqueries in <database>SELECT</database> statements, but also in
                <database>UPDATE</database>s, <database>MERGE</database>s etc.</para>
              </listitem>
              <listitem>
                <para>In PSQL, <database>CTE</database>s are also supported in
                <database>FOR</database> loop headers:</para>
                <programlisting>for <emphasis role="bold">with my_rivers as (select * from rivers where owner = 'me')</emphasis>
    select name, length from my_rivers into :rname, :rlen
do
begin
  ..
end</programlisting>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <section id="langrefupd25-select-cte-recursive">
          <title>Recursive <database>CTE</database>s</title>
          <para>A recursive (self-referencing) <database>CTE</database> is a
          <database>UNION</database> which must have at least one non-recursive member, called the
          <firstterm>anchor</firstterm>. The non-recursive member(s) must be placed before the
          recursive member(s). Recursive members are linked to each other and to their non-recursive
          neighbour by <database>UNION ALL</database> operators. The unions between non-recursive
          members may be of any type.</para>
          <para>Recursive <database>CTE</database>s require the <database>RECURSIVE</database>
          keyword to be present right after <database>WITH</database>. Each recursive union member
          may reference itself only once, and it must do so in a <database>FROM</database>
          clause.</para>
          <para>A great benefit of recursive <database>CTE</database>s is that they use far less
          memory and CPU cycles than an equivalent recursive stored procedure.</para>
          <!--Find out:
- May the recursive reference occur in any FROM clause in the recursive union member, or only
  in the member's main (outermost) FROM clause?
- Can the RECURSIVE keyword be repeated before each (recursive) CTE?-->
          <para>The execution pattern of a recursive <database>CTE</database> is as follows:</para>
          <itemizedlist>
            <listitem>
              <para>The engine begins execution from a non-recursive member.</para>
            </listitem>
            <listitem>
              <para>For each row evaluated, it starts executing each recursive member one-by-one,
              using the current values from the outer row as parameters.</para>
            </listitem>
            <listitem>
              <para>If the currently executing instance of a recursive member produces no rows,
              execution loops back one level and gets the next row from the outer result set.</para>
            </listitem>
          </itemizedlist>
          <!--I wonder if this is entirely correct. Don't all the recursive union members each present a next lower level in the execution pattern?
Also, to whom should I give credit for this text (if I use it): Vlad or Paul?-->
          <formalpara>
            <title>Example with a recursive <database>CTE</database></title>
            <para><blockquote>
                <programlisting><emphasis role="bold">with recursive
  dept_year_budget as (
    select fiscal_year,
           dept_no,
           sum(projected_budget) as budget
    from proj_dept_budget
    group by fiscal_year, dept_no
  ),
  dept_tree as (
    select dept_no,
           head_dept,
           department,
           cast('' as varchar(255)) as indent
    from department
    where head_dept is null
    union all
    select d.dept_no,
           d.head_dept,
           d.department,
           h.indent || '  '
    from department d
         join dept_tree h on d.head_dept = h.dept_no
  )</emphasis>
select d.dept_no,
       d.indent || d.department as department,
       dyb_2008.budget as budget_08,
       dyb_2009.budget as budget_09
from <emphasis role="bold">dept_tree</emphasis> d
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2008
       on d.dept_no = dyb_2008.dept_no
       and dyb_2008.fiscal_year = 2008
     left join <emphasis role="bold">dept_year_budget</emphasis> dyb_2009
       on d.dept_no = dyb_2009.dept_no
       and dyb_2009.fiscal_year = 2009</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Notes on recursive <database>CTE</database>s</title>
            <para><itemizedlist>
                <listitem>
                  <para>Aggregates (<database>DISTINCT</database>, <database>GROUP BY</database>,
                  <database>HAVING</database>) and aggregate functions (<database>SUM</database>,
                  <database>COUNT</database>, <database>MAX</database> etc) are not allowed in
                  recursive union members.</para>
                </listitem>
                <listitem>
                  <para>A recursive reference cannot participate in an outer join.</para>
                </listitem>
                <listitem>
                  <para>The maximum recursion depth is 1024.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-derived-tables">
        <title>Derived tables (<quote><database>SELECT FROM SELECT</database></quote>)</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A derived table is the result set of a <database>SELECT</database> query, used in an
          outer <database>SELECT</database> as if it were an ordinary table. Put otherwise, it is a
          subquery in the <database>FROM</database> clause.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>(<replaceable>select-query</replaceable>)
   [[AS] <replaceable>derived-table-alias</replaceable>]
   [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

<replaceable>&lt;derived-column-aliases&gt;</replaceable>  :=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The derived table in the query below (shown in boldface) contains all the
              relation names in the database followed by their field count. The outer
              <database>SELECT</database> produces, for each existing field count, the number of
              relations having that field count.</para>
              <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>
              <para>A trivial example demonstrating the use of a derived table alias and column
              aliases list (both are optional):</para>
              <programlisting>select dbinfo.descr,
       dbinfo.def_charset
from   <emphasis role="bold">(select * from rdb$database) dbinfo
         (descr, rel_id, sec_class, def_charset)</emphasis></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>Derived tables can be nested.</para>
              </listitem>
              <listitem>
                <para>Derived tables can be unions and can be used in unions. They can contain
                aggregate functions, subselects and joins, and can themselves be used in aggregate
                functions, subselects and joins. They can also be or contain queries on selectable
                stored procedures. They can have <database>WHERE</database>, <database>ORDER
                BY</database> and <database>GROUP BY</database> clauses, <database>FIRST</database>,
                <database>SKIP</database> or <database>ROWS</database> directives, etc. etc.</para>
              </listitem>
              <listitem>
                <para>Every column in a derived table <emphasis>must</emphasis> have a name. If it
                doesn't have one by nature (e.g. because it's a constant) it must either be given an
                alias in the usual way, or a column aliases list must be added to the derived table
                specification.</para>
              </listitem>
              <listitem>
                <para>The column aliases list is optional, but if it is used it must be complete.
                That is: it must contain an alias for every column in the derived table.</para>
              </listitem>
              <listitem>
                <para>The optimizer can handle a derived table very efficiently. However, if the
                derived table is involved in an inner join and contains a subquery, then no join
                order can be made.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-first-skip">
        <title><database>FIRST</database> and <database>SKIP</database></title>
        <!--Seem unavailable in ESQL. But Dmitry writes to me: "Available since v1.0, I believe."
Checked again in gpre source (using SKIP search), and it really really really isn't there. So:-->
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Better alternative</title>
          <para><link linkend="langrefupd25-select-rows"><database>ROWS</database></link></para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>FIRST</database> limits the output of a query to the first so-many rows.
          <database>SKIP</database> will suppress the given number of rows before starting to return
          output.<tip>
              <para>In Firebird 2.0 and up, use the SQL-compliant <link
              linkend="langrefupd25-select-rows"><database>ROWS</database></link> syntax
              instead.</para>
            </tip></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>
              <note>
                <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an integer literal or a
                query parameter, the <quote><literal>()</literal></quote> may be omitted. Subselects
                on the other hand require an extra pair of parentheses.</para>
              </note>
            </blockquote></para>
        </formalpara>
        <para><database>FIRST</database> and <database>SKIP</database> are both optional. When used
        together as in <quote><database>FIRST</database> <replaceable>m</replaceable>
        <database>SKIP</database> <replaceable>n</replaceable></quote>, the
        <replaceable>n</replaceable> topmost rows of the output set are discarded and the first
        <replaceable>m</replaceable> rows of the remainder are returned.</para>
        <para><database>SKIP</database> 0 is allowed, but of course rather pointless.
        <database>FIRST</database> 0 is allowed in version 1.5 and up, where it returns an empty
        set. In 1.0.x, <database>FIRST</database> 0 causes an error. Negative
        <database>SKIP</database> and/or <database>FIRST</database> values always result in an
        error.</para>
        <para>If a <database>SKIP</database> lands past the end of the dataset, an empty set is
        returned. If the number of rows in the dataset (or the remainder after a
        <database>SKIP</database>) is less than the value given after <database>FIRST</database>,
        that smaller number of rows is returned. These are valid results, not error
        situations.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The following query will return the first 10 names from the People table:</para>
              <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
              <para>The following query will return everything <emphasis>but</emphasis> the first 10
              names:</para>
              <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
              <para>And this one returns the last 10 rows. Notice the double parentheses:</para>
              <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
              <para>This query returns rows 81–100 of the People table:</para>
              <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
            </blockquote></para>
        </formalpara>
        <caution>
          <title>Two Gotchas with <database>FIRST</database> in subselects</title>
          <itemizedlist>
            <listitem>
              <para>This:</para>
              <blockquote>
                <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
              </blockquote>
              <para>will delete all of the rows in the table. Ouch! The sub-select is evaluating
              each 10 candidate rows for deletion, deleting them, slipping forward 10 more... ad
              infinitum, until there are no rows left. Beware! Or better: use the
              <database>ROWS</database> syntax, available since Firebird 2.0.</para>
            </listitem>
            <listitem>
              <para>Queries like:</para>
              <blockquote>
                <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
              </blockquote>
              <para>won't work as expected, because the optimization performed by the engine
              transforms the <database>IN</database> predicate to the correlated
              <database>EXISTS</database> predicate shown below. It's obvious that in this case
              <database>FIRST</database> <replaceable>N</replaceable> doesn't make any sense:</para>
              <blockquote>
                <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
              </blockquote>
              <!--This still so with ROWS? BTW, I think this is a grave error in the optimizer!-->
            </listitem>
          </itemizedlist>
        </caution>
      </section>
      <section id="langrefupd25-groupby">
        <title><database>GROUP BY</database></title>
        <formalpara>
          <title>Description</title>
          <para><database>GROUP BY</database> merges rows that have the same combination of values
          and/or <constant>NULL</constant>s in the item list into a single row. Any aggregate
          functions in the select list are applied to each group individually instead of to the
          dataset as a whole.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>  ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
               | <replaceable>column-alias</replaceable>
               | <replaceable>column-position</replaceable>
               | <replaceable>expression</replaceable></programlisting>
              <itemizedlist>
                <listitem>
                  <para>Only non-negative integer <emphasis>literals</emphasis> will be interpreted
                  as column positions. If they are outside the range from 1 to the number of
                  columns, an error is raised. Integer values resulting from expressions or
                  parameter substitutions are simply invariables and will be used as such in the
                  grouping. They will have no effect though, as their value is the same for each
                  row.</para>
                </listitem>
                <listitem>
                  <para>A <database>GROUP BY</database> item cannot be a reference to an aggregate
                  function (including one that is buried inside an expression) from the same
                  context.</para>
                </listitem>
                <listitem>
                  <para>The select list may not contain expressions that can have different values
                  within a group. To avoid this, the rule of thumb is to include each non-aggregate
                  item from the select list in the <database>GROUP BY</database> list (whether by
                  copying, alias or position).</para>
                  <!--Some exceptions and variations are possible, but they could be discussed
later in notes. For instance, a GROUP BY item may be 'narrower' than the
corresponding select item (SELECT upper(ColA) GROUP BY ColA is fine, but
the reverse isn't). Also think of certain subselects, and items that don't
refer to the current context.-->
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Note</title>
          <para>If you group by a column position, the expression at that position is copied
          internally from the select list. If it concerns a subquery, that subquery will be executed
          at least twice.<!--I suppose the same goes for grouping by aliases?--></para>
        </formalpara>
        <section id="langrefupd25-groupby-extensions">
          <title>Grouping by alias, position and expressions</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0, 1.5, 2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In addition to column names, Firebird 2 allows column aliases, column positions
            and arbitrary valid expressions as <database>GROUP BY</database> items.</para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>These three queries all achieve the same result:</para>
                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by len_name</programlisting>
                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by 1</programlisting>
                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by strlen(lastname)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>History</title>
            <para>Grouping by UDF results was added in Firebird 1. Grouping by column positions,
            <database>CASE</database> outcomes and a limited number of internal functions in
            Firebird 1.5. Firebird 2 added column aliases and expressions in general as valid
            <database>GROUP BY</database> items (<quote>expressions in general</quote> absorbing the
            UDF, <database>CASE</database> and internal functions lot).</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-having-stricter">
        <title><database>HAVING</database>: Stricter rules</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>See <link linkend="langrefupd25-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-join">
        <title><database>JOIN</database></title>
        <section id="langrefupd25-join-amb-fields">
          <title>Ambiguous field names rejected</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>InterBase 6 accepts and executes statements like the one below, which refers to an
            unqualified column name even though that name exists in both tables participating in the
            <database>JOIN</database>:</para>
          </formalpara>
          <blockquote>
            <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
          </blockquote>
          <para>The results of such a query are unpredictable. Firebird Dialect 3 returns an error
          if there are ambiguous field names in <database>JOIN</database> statements. Dialect 1
          gives a warning but will execute the query anyway.</para>
        </section>
        <section id="langrefupd25-join-crossjoin">
          <title><database>CROSS JOIN</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.0 and up support <database>CROSS JOIN</database>, which performs a full
            set multiplication on the tables involved. Previously you had to achieve this by joining
            on a tautology (a condition that is always true) or by using the comma syntax, now
            deprecated.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> CROSS JOIN <replaceable>&lt;relation&gt;</replaceable>
   ...

<replaceable>&lt;relation&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
</programlisting>
                <para><emphasis role="bold">Note:</emphasis> If you use <database>CROSS
                JOIN</database>, you can't use <database>ON</database>.</para>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select * from Men cross join Women
order by Men.age, Women.age

-- old syntax:
--   select * from Men join Women on 1 = 1
--   order by Men.age, Women.age

-- comma syntax:
--   select * from Men, Women
--   order by Men.age, Women.age</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-join-namedcolsjoin">
          <title>Named colums <database>JOIN</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>A named colums join is an equi-join on the columns named in the
            <database>USING</database> clause. These columns must exist in both relations.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> [<replaceable>&lt;join_type&gt;</replaceable>] JOIN <replaceable>&lt;relation&gt;</replaceable>
   USING (<replaceable>colname</replaceable> [, <replaceable>colname</replaceable> ...])
   ...

<replaceable>&lt;relation&gt;</replaceable>   ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
<replaceable>&lt;join_type&gt;</replaceable>  ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select *
  from books join shelves
  using (shelf, bookcase)</programlisting>
                <para>The equivalent in traditional syntax:</para>
                <programlisting>select *
  from books b join shelves s
  on b.shelf = s.shelf and b.bookcase = s.bookcase</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>The columns in the USING clause can be selected without qualifier. Be aware,
                  however, that doing so in outer joins doesn't always give the same result as
                  selecting <replaceable>left</replaceable>.<replaceable>colname</replaceable> or
                  <replaceable>right</replaceable>.<replaceable>colname</replaceable>. One of the
                  latter may be <constant>NULL</constant> while the other isn't; plain
                  <replaceable>colname</replaceable> always returns the
                  non-<constant>NULL</constant> alternative in such cases.</para>
                </listitem>
                <listitem>
                  <para><database>SELECT</database> * from a named columns join returns each
                  <database>USING</database> column only once. In outer joins, such a column always
                  contains the non-<constant>NULL</constant> alternative except for rows where the
                  field is <constant>NULL</constant> in both tables.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
        <section id="langrefupd25-join-natural">
          <title>Natural <database>JOIN</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.1</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>A natural join is an automatic equi-join on all the columns that exist in both
            relations. If there are no common column names, a <link
            linkend="langrefupd25-join-crossjoin"><database>CROSS JOIN</database></link> is
            produced.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>&lt;relation&gt;</replaceable> NATURAL [<replaceable>&lt;join_type&gt;</replaceable>] JOIN <replaceable>&lt;relation&gt;</replaceable>
   ...

<replaceable>&lt;relation&gt;</replaceable>   ::=  {<replaceable>table</replaceable> | <replaceable>view</replaceable> | <replaceable>cte</replaceable> | (<replaceable>select_stmt</replaceable>)} [[AS] <replaceable>alias</replaceable>]
<replaceable>&lt;join_type&gt;</replaceable>  ::=  INNER | {LEFT | RIGHT | FULL} [OUTER]</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select * from Pupils natural left join Tutors</programlisting>
                <para>Assuming that the Pupils and Tutors tables have two field names in common:
                <database>TUTOR</database> and <database>CLASS</database>, the equivalent
                traditional syntax is:</para>
                <programlisting>select * from Pupils p left join Tutors t
  on p.tutor = t.tutor and p.class = t.class</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>Common columns can be selected from a natural join without qualifier.
                  Beware, however, that doing so in outer joins doesn't always gives the same result
                  as selecting <replaceable>left</replaceable>.<replaceable>colname</replaceable> or
                  <replaceable>right</replaceable>.<replaceable>colname</replaceable>. One of the
                  latter may be <constant>NULL</constant> while the other isn't; plain
                  <replaceable>colname</replaceable> always returns the
                  non-<constant>NULL</constant> alternative in such cases.</para>
                </listitem>
                <listitem>
                  <para><database>SELECT</database> * from a natural join returns each common column
                  only once. In outer joins, such a column always contains the
                  non-<constant>NULL</constant> alternative except for rows where the field is
                  <constant>NULL</constant> in both tables.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-orderby">
        <title><database>ORDER BY</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-orderby-alias">
          <title>Order by column alias</title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.0 and above support ordering by column alias.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select rdb$character_set_id as charset_id,
       rdb$collation_id as coll_id,
       rdb$collation_name as name
from rdb$collations
order by charset_id, coll_id</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-order-star-by-colpos">
          <title>Ordering by column position causes * expansion</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>If you order by column position in a <quote><database>SELECT</database> *</quote>
            query, the engine will now expand the * to determine the sort column(s).</para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>The following wasn't possible in pre-2.0 versions:</para>
                <programlisting>select * from rdb$collations
order by 3, 2</programlisting>
                <para>The following would sort the output set on <literal>Films.Director</literal>
                in previous versions. In Firebird 2 and up, it will sort on the second column of
                <literal>Books</literal>:</para>
                <programlisting>select Books.*, Films.Director from Books, Films
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-orderby-expr">
          <title>Ordering by expressions</title>
          <formalpara>
            <title>Added in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 1.5 introduced the possibility to use expressions as ordering items.
            Please note that expressions consisting of a single non-negative whole number will be
            interpreted as column positions and cause an exception if they're not in the range from
            1 to the number of columns.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select x, y, note from Pairs
order by x+y desc</programlisting>
              </blockquote></para>
          </formalpara>
          <note>
            <para>The number of function or procedure invocations resulting from a sort based on a
            UDF or stored procedure is unpredictable, regardless whether the ordering is specified
            by the expression itself or by the column position number.</para>
          </note>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>The number of function or procedure invocations resulting from a sort based
                  on a UDF or stored procedure is unpredictable, regardless whether the ordering is
                  specified by the expression itself or by the column position number.</para>
                </listitem>
                <listitem>
                  <para>Only non-negative whole number <emphasis>literals</emphasis> are interpreted
                  as column positions. A whole number resulting from an expression evaluation or
                  parameter substitution is seen as an integer invariable and will lead to a dummy
                  sort, since its value is the same for each row.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
          <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->
          <!--Rlsnotes 1.5 say (by Nickolay):

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice? Maybe with ARRAYs?-->
        </section>
        <section id="langrefupd25-orderby-nulls">
          <title><constant>NULL</constant>s placement</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5, 2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 1.5 has introduced the per-column <database>NULLS FIRST</database> and
            <database>NULLS LAST</database> directives to specify where <constant>NULL</constant>s
            appear in the sorted column. Firebird 2.0 has changed the default placement of
            <constant>NULL</constant>s.</para>
          </formalpara>
          <para>Unless overridden by <database>NULLS FIRST</database> or <database>NULLS
          LAST</database>, <constant>NULL</constant>s in ordered columns are placed as
          follows:</para>
          <itemizedlist>
            <listitem>
              <para>In Firebird 1.0 and 1.5: at the end of the sort, regardless whether the order is
              ascending or descending.</para>
            </listitem>
            <listitem>
              <para>In Firebird 2.0 and up: at the <emphasis>start</emphasis> of ascending orderings
              and at the <emphasis>end</emphasis> of descending orderings.</para>
            </listitem>
          </itemizedlist>
          <para>See also the table below for an overview of the different versions.</para>
          <table id="langrefupd25-tbl-null-placement">
            <title><constant>NULL</constant>s placement in ordered columns</title>
            <tgroup cols="4">
              <colspec colname="colStatement" colwidth="2*" />
              <colspec colname="colPlac10" colwidth="1*" />
              <colspec colname="colPlac15" colwidth="1*" />
              <colspec colname="colPlac2" colwidth="1*" />
              <thead>
                <row valign="top">
                  <entry morerows="1">Ordering</entry>
                  <entry align="center" nameend="colPlac2"
                  namest="colPlac10"><constant>NULL</constant>s placement</entry>
                </row>
                <row valign="top">
                  <entry align="center">Firebird 1</entry>
                  <entry align="center">Firebird 1.5</entry>
                  <entry align="center">Firebird 2</entry>
                </row>
              </thead>
              <tbody>
                <row valign="top">
                  <entry>order by Field [asc]</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                  <entry>top</entry>
                </row>
                <row valign="top">
                  <entry>order by Field desc</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                </row>
                <row valign="top">
                  <entry>order by Field [asc | desc] nulls first</entry>
                  <entry>—</entry>
                  <entry>top</entry>
                  <entry>top</entry>
                </row>
                <row valign="top">
                  <entry>order by Field [asc | desc] nulls last</entry>
                  <entry>—</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <note>
            <title>Notes</title>
            <itemizedlist>
              <listitem>
                <para>Pre-existing databases may need a backup-restore cycle before they show the
                correct <constant>NULL</constant> ordering behaviour under Firebird 2.0 and
                up.</para>
                <!--CHECK! Is this always true, or only when the column is indexed?-->
              </listitem>
              <listitem>
                <para>No index will be used on columns for which a non-default
                <constant>NULLS</constant> placement is chosen. In Firebird 1.5, that is the case
                with <database>NULLS FIRST</database>. In 2.0 and higher, with <database>NULLS
                LAST</database> on ascending and <database>NULLS FIRST</database> on descending
                sorts.</para>
              </listitem>
            </itemizedlist>
          </note>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>
                <programlisting>select * from document
  order by strlen(description) desc
  rows 10</programlisting>
                <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-orderby-stricter">
          <title>Stricter ordering rules with aggregate statements</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>See <link linkend="langrefupd25-aggregates-having-orderby"><citetitle>Aggregate
            statements: Stricter <database>HAVING</database> and <database>ORDER
            BY</database></citetitle></link>.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-select-plan">
        <title><database>PLAN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Specifies a user plan for the data retrieval, overriding the plan that the optimizer
          would have generated automatically.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <para><!--This is (a modified view of) the syntax as given in the IB6 LangRef, with the
Fb 2.0 extension of optionally providing an INDEX list after ORDER:--><programlisting>PLAN <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;plan_expr&gt;</replaceable>   ::=  [JOIN | [SORT] [MERGE]] (<replaceable>&lt;plan_item&gt;</replaceable> [, <replaceable>&lt;plan_item&gt;</replaceable> ...])

<replaceable>&lt;plan_item&gt;</replaceable>   ::=  <replaceable>&lt;basic_item&gt;</replaceable> | <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;basic_item&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>alias</replaceable>}
                   {NATURAL
                    | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>))
                    | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;indexlist&gt;</replaceable>   ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]</programlisting><!--The syntax given in the 2.0 Rlsnotes differs considerably, but contains at
least some errors. However, the same is probably true for the above.
Points to investigate wrt syntax in Rlsnotes 2.0:
- Must MERGE always take place on *exactly* 2 streams?
- Must MERGE always take place on explicitly SORTed streams?

Points to improve in the syntax above (either in the syntax itself, or
in notes):
- With JOIN and MERGE, the number of plan_items must be at least 2.--></para>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd25-select-plan-improved">
          <title>Handling of user <database>PLAN</database>s improved</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firbird 2 has implemented the following improvements in the handling of
            user-specified <database>PLAN</database>s:<itemizedlist>
                <listitem>
                  <para>Plan fragments are propagated to nested levels of joins, enabling manual
                  optimization of complex outer joins.</para>
                </listitem>
                <listitem>
                  <para>User-supplied plans will be checked for correctness in outer joins.</para>
                </listitem>
                <listitem>
                  <para>Short-circuit optimization for user-supplied plans has been added.</para>
                </listitem>
                <listitem>
                  <para>A user-specified access path can be supplied for any
                  <database>SELECT</database>-based statement or clause.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
        <section id="langrefupd25-select-plan-order-index">
          <title><database>ORDER</database> with <database>INDEX</database></title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>A single plan item can now contain both an <database>ORDER</database> and an
            <database>INDEX</database> directive (in that order).</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>plan (MyTable order ix_myfield index (ix_this, ix_that))</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-select-plan-alltables">
          <title><database>PLAN</database> must include all tables</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2 and up, a <database>PLAN</database> clause must handle all the
            tables in the query. Previous versions sometimes accepted incomplete plans, but this is
            no longer the case.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-select-alias-use">
        <title>Relation alias makes real name unavailable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you give a table or view an alias in a Firebird 2.0 or above statement, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that relation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Correct usage:</para>
              <programlisting>select pears from Fruit</programlisting>
              <programlisting>select Fruit.pears from Fruit</programlisting>
              <programlisting>select pears from Fruit F</programlisting>
              <programlisting>select F.pears from Fruit F</programlisting>
              <para>No longer possible:</para>
              <programlisting>select Fruit.pears from Fruit F</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-select-rows">
        <title><database>ROWS</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Limits the amount of rows returned by the <database>SELECT</database> statement to a
          specified number or range.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <para>With a single <database>SELECT</database>:</para>
              <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;columns&gt;</replaceable>  ::=  The usual output column specifications.
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>   ::=  Any expression evaluating to an integer.</programlisting>
              <para>With a <database>UNION</database>:</para>
              <programlisting>SELECT [FIRST <replaceable>p</replaceable>] [SKIP <replaceable>q</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]

UNION [ALL | DISTINCT]

SELECT [FIRST <replaceable>r</replaceable>] [SKIP <replaceable>s</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]

ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>With a single argument <replaceable>m</replaceable>, the first
        <replaceable>m</replaceable> rows of the dataset are returned.</para>
        <para>Points to note:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> = 0, an empty set is returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>
        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, rows
        <replaceable>m</replaceable> to <replaceable>n</replaceable> of the dataset are returned,
        inclusively. Row numbers are 1-based.</para>
        <para>Points to note when using two arguments:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, an
            empty set is returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, an empty set is
            returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>
        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
        <para>The SQL-compliant <database>ROWS</database> syntax obviates the need for <link
        linkend="langrefupd25-first-skip"><database>FIRST</database> and
        <database>SKIP</database></link>, except in one case: a <database>SKIP</database> without
        <database>FIRST</database>, which returns the entire remainder of the set after skipping a
        given number of rows. (You can often <quote>fake it</quote> though, by supplying a second
        argument that you know to be bigger than the number of rows in the set.)</para>
        <para>You cannot use <database>ROWS</database> together with <database>FIRST</database>
        and/or <database>SKIP</database> in a single <database>SELECT</database> statement, but is
        it valid to use one form in the top-level statement and the other in subselects, or to use
        the two syntaxes in different subselects.</para>
        <para>When used with a <database>UNION</database>, the <database>ROWS</database> subclause
        applies to the UNION as a whole and must be placed after the last
        <database>SELECT</database>. If you want to limit the output of one or more individual
        <database>SELECT</database>s within the <database>UNION</database>, you have two options:
        either use <database>FIRST</database>/<database>SKIP</database> on those
        <database>SELECT</database> statements, or convert them to <link
        linkend="langrefupd25-derived-tables">derived tables</link> with <database>ROWS</database>
        clauses.</para>
        <!--Dmitry's SELECT syntax in the 2.0 Rlsnotes is incorrect here, as it states that you can use ROWS on every SELECT in a UNION. Let him know!-->
        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd25-update-rows"><database>UPDATE</database></link> and <link
        linkend="langrefupd25-delete-rows"><database>DELETE</database></link> statements.</para>
        <!--SKIP and FIRST can be used - and could already in 1.5 - with UNIONs and in subqueries, even though the 2.0 RlsNotes seem to suggest otherwise.-->
      </section>
      <section id="langrefupd25-union">
        <title><database>UNION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL, PSQL</para>
        </formalpara>
        <section id="langrefupd25-union-in-subqueries">
          <title><database>UNION</database>s in subqueries</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para><database>UNION</database>s are now allowed in subqueries. This applies not only
            to column-level subqueries in a <database>SELECT</database> list, but also to subqueries
            in <database>ANY</database>|<database>SOME</database>, <database>ALL</database> and
            <database>IN</database> predicates, as well as the optional <database>SELECT</database>
            expression that feeds an <database>INSERT</database>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd25-union-distinct">
          <title><database>UNION DISTINCT</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>You can now use the optional <database>DISTINCT</database> keyword when defining a
            <database>UNION</database>. This will show duplicate rows only once instead of every
            time they occur in one of the tables. Since <database>DISTINCT</database>, being the
            opposite of <database>ALL</database>, is the default mode anyway, this doesn't add any
            new functionality.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>SELECT (...) FROM (...)
UNION [DISTINCT | ALL]
SELECT (...) FROM (...)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select name, phone from translators
  union distinct
select name, phone from proofreaders</programlisting>
                <para>Translators who also work as proofreaders (a not uncommon combination) will
                show up only once in the result set, provided their phone number is the same in both
                tables. The same result would have been obtained without
                <database>DISTINCT</database>. With <database>ALL</database>, they would appear
                twice.</para>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd25-with-lock">
        <title><database>WITH LOCK</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description:</title>
          <para><database>WITH LOCK</database> provides a limited explicit pessimistic locking
          capability for cautious use in conditions where the affected row set is:<orderedlist
              numeration="loweralpha" spacing="compact">
              <listitem>
                <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
              </listitem>
              <listitem>
                <para>precisely controlled by the application code.</para>
              </listitem>
            </orderedlist></para>
        </formalpara>
        <caution>
          <title>This is for experts only!</title>
          <para>The need for a pessimistic lock in Firebird is very rare indeed and should be well
          understood before use of this extension is considered.</para>
          <para>It is essential to understand the effects of transaction isolation and other
          transaction attributes before attempting to implement explicit locking in your
          application.</para>
        </caution>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
            </blockquote></para>
        </formalpara>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>
        <para><database>WITH LOCK</database> can only be used with a top-level, single-table
        <database>SELECT</database> statement. It is <emphasis>not</emphasis> available:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>in a subquery specification;</para>
          </listitem>
          <listitem>
            <para>for joined sets;</para>
          </listitem>
          <listitem>
            <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
            clause or any other aggregating operation;</para>
          </listitem>
          <listitem>
            <para>with a view;</para>
          </listitem>
          <listitem>
            <para>with the output of a selectable stored procedure;</para>
          </listitem>
          <listitem>
            <para>with an external table.</para>
          </listitem>
        </itemizedlist>
        <para>A lengthier, more in-depth discussion of <quote><database>SELECT ... WITH
        LOCK</database></quote> is included in the <link
        linkend="langrefupd25-notes-withlock">Notes</link>. It is a must-read for everybody who
        considers using this feature.</para>
      </section>
    </section>
    <section id="langrefupd25-update">
      <title><database>UPDATE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Changes values in a table (or in one or more tables underlying a view). The columns
        affected are specified in the <database>SET</database> clause; the rows affected may be
        limited by the <database>WHERE</database> and <database>ROWS</database> clauses.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>UPDATE [TRANSACTION <replaceable>name</replaceable>] {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>     ::=  Any expression evaluating to an integer.
<replaceable>&lt;values&gt;</replaceable>     ::=  <replaceable>value_expression</replaceable> [, <replaceable>value_expression</replaceable> ...]
<replaceable>&lt;variables&gt;</replaceable>  ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>
                <listitem>
                  <para>In a pure DSQL session, <database>WHERE CURRENT OF</database> isn't of much
                  use, since there exists no DSQL statement to create a cursor.</para>
                </listitem>
                <listitem>
                  <para>The <database>PLAN</database>, <database>ORDER BY</database> and
                  <database>ROWS</database> clauses are not available in ESQL.</para>
                </listitem>
                <listitem>
                  <para>Since v. 2.0, no column may be <database>SET</database> more than once in
                  the same <database>UPDATE</database> statement.</para>
                </listitem>
                <listitem>
                  <para>The <database>RETURNING</database> clause is not available in ESQL.<!--Sure about that ?--></para>
                </listitem>
                <listitem>
                  <para>The <quote><database>INTO</database>
                  <replaceable>&lt;variables&gt;</replaceable></quote> subclause is only available
                  in PSQL.</para>
                </listitem>
                <listitem>
                  <para>When returning values into the context variable <database>NEW</database>,
                  this name must not be preceded by a colon
                  (<quote><literal>:</literal></quote>).</para>
                </listitem>
              </itemizedlist>
            </note>
            <!--Are only loose plan_items allowed, or also JOIN, SORT, MERGE ?-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-update-setchanged">
        <title>Changed <database>SET</database> semantics</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In previous Firebird versions, if multiple assignments were done in the
          <database>SET</database> clause, the new column values would become immediately available
          to subsequent assigments in the same clause. That is, in a clause like <quote>set a=3,
          b=a</quote>, <replaceable>b</replaceable> would be set to 3, not to
          <replaceable>a</replaceable>'s old value. This non-standard behaviour has now been
          corrected. In Firebird 2.5 and up, any assignments in the <database>SET</database> clause
          will use the old column values.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <para>Given table <database>TSET</database>:</para>
              <programlisting>A  B
----
1  0
2  0</programlisting>
              <para>the following statement:</para>
              <programlisting>update tset set a=5, b=a</programlisting>
              <para>will change its state to</para>
              <programlisting>A  B
----
5  1
5  2</programlisting>
              <para>In versions prior to Firebird 2.5, this would have been:</para>
              <programlisting>A  B
----
5  5
5  5</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Retaining the old behaviour</title>
          <para>For a limited time, you can keep the old, non-standard behaviour by setting the
          <parameter>OldSetClauseSemantics</parameter> parameter in
          <filename>firebird.conf</filename> to 1. This parameter will be deprecated and removed in
          the future. If set, it will be used for all database connections made through the
          server.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-update-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>update MyTable
  set NameBlobSp = 'Juan'
  where NameBlobBr collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-update-orderby">
        <title><database>ORDER BY</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>UPDATE</database> now allows an <database>ORDER BY</database> clause. This
          only makes sense in combination with <database>ROWS</database>, but is also valid without
          it.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-update-plan">
        <title><database>PLAN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>UPDATE</database> now allows a <database>PLAN</database> clause, so users
          can optimize the operation manually.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-update-alias-use">
        <title>Relation alias makes real name unavailable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you give a table or view an alias in a Firebird 2.0 or above statement, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that relation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Correct usage:</para>
              <programlisting>update Fruit set soort = 'pisang' where ...</programlisting>
              <programlisting>update Fruit set Fruit.soort = 'pisang' where ...</programlisting>
              <programlisting>update Fruit F set soort = 'pisang' where ...</programlisting>
              <programlisting>update Fruit F set F.soort = 'pisang' where ...</programlisting>
              <para>No longer possible:</para>
              <programlisting>update Fruit F set Fruit.soort = 'pisang' where ...</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-update-returning">
        <title><database>RETURNING</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>An <database>UPDATE</database> statement modifying <emphasis>at most one
          row</emphasis> may optionally include a <database>RETURNING</database> clause in order to
          return values from the updated row. The clause, if present, need not contain all the
          modified columns and may also contain other columns or expressions. The returned values
          reflect any changes that may have been made in <database>BEFORE</database> tiggers, but
          not those in <database>AFTER</database> triggers.
          <database>OLD</database>.<replaceable>fieldname</replaceable> and
          <database>NEW</database>.<replaceable>fieldname</replaceable> may both be used in the list
          of columns to return; for field names not preceded by either of these, the new value is
          returned.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>update Scholars
  set firstname = 'Hugh', lastname = 'Pickering'
  where firstname = 'Henry' and lastname = 'Higgins'
  returning id, old.lastname, new.lastname</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>In DSQL, a statement with a <database>RETURNING</database> clause <emphasis
                role="">always</emphasis> returns exactly one row. If no record was actually
                updated, the fields in this row are all <constant>NULL</constant>. This behaviour
                may change in a later version of Firebird. In PSQL, if no row was updated, nothing
                is returned, and the receiving variables keep their existing values.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-update-rows">
        <title><database>ROWS</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Limits the amount of rows updated to a specified number or range.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            </blockquote></para>
        </formalpara>
        <para>With a single argument <replaceable>m</replaceable>, the update is limited to the
        first <replaceable>m</replaceable> rows of the dataset defined by the table or view and the
        optional <database>WHERE</database> and <database>ORDER BY</database> clauses.</para>
        <para>Points to note:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> = 0, no rows are updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>
        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, the
        update is limited to rows <replaceable>m</replaceable> to <replaceable>n</replaceable>
        inclusively. Row numbers are 1-based.</para>
        <para>Points to note when using two arguments:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, no
            rows are updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, no rows are
            updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>
        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd25-select-rows"><database>SELECT</database></link> and <link
        linkend="langrefupd25-delete-rows"><database>DELETE</database></link> statements.</para>
      </section>
    </section>
    <section id="langrefupd25-update-or-insert">
      <title><database>UPDATE OR INSERT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ? Guess not, readme says: Scope: DSQL, PSQL-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>UPDATE OR INSERT</database> checks if any existing records already contain
        the new values supplied for the <database>MATCHING</database> columns. If so, those records
        are updated. If not, a new record is inserted. In the absence of a
        <database>MATCHING</database> clause, matching is done against the primary key. If a
        <database>RETURNING</database> clause is present and more than one matching record is found,
        an error is raised.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>UPDATE OR INSERT INTO
   {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [(<replaceable>&lt;columns&gt;</replaceable>)]
   VALUES (<replaceable>&lt;values&gt;</replaceable>)
   [MATCHING (<replaceable>&lt;columns&gt;</replaceable>)]
   [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]

<replaceable>&lt;columns&gt;</replaceable>      ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;values&gt;</replaceable>       ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>    ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]</programlisting>
            <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>No column may appear more than once in the update/insert column list.</para>
                </listitem>
                <listitem>
                  <para>If the table has no PK, the <database>MATCHING</database> clause becomes
                  mandatory.</para>
                </listitem>
                <listitem>
                  <para>The <quote><database>INTO</database>
                  <replaceable>&lt;variables&gt;</replaceable></quote> subclause is only available
                  in PSQL.</para>
                </listitem>
                <listitem>
                  <para>When values are returned into the context variable <database>NEW</database>,
                  this name must not be preceded by a colon
                  (<quote><literal>:</literal></quote>).</para>
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update or insert into Cows (Name, Number, Location)
  values ('Suzy Creamcheese', 3278823, 'Green Pastures')
  matching (Number)
  returning rec_id into :id;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Matches are determined with <link linkend="langrefupd25-distinct"><database>IS
              NOT DISTINCT</database></link>, not with the <quote>=</quote> operator. This means
              that one <constant>NULL</constant> matches another.</para>
            </listitem>
            <listitem>
              <para>The optional <database>RETURNING</database> clause:</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>...may contain any or all columns of the target table, regardless if they
                  were mentioned earlier in the statement, but also other expressions.</para>
                </listitem>
                <listitem>
                  <para>...may contain <database>OLD</database> and <database>NEW</database>
                  qualifiers for field names; by default, the new field value is returned.</para>
                </listitem>
                <!-- But... if you return into New.A, is field A really updated then, after the BEFORE triggers?-->
                <listitem>
                  <para>...returns field values as they are after the <database>BEFORE</database>
                  triggers have run, but before any <database>AFTER</database> triggers.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd25-transcontrol">
    <title>Transaction control statements</title>
    <section id="langrefupd25-release-savepoint">
      <title><database>RELEASE SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Deletes a named savepoint, freeing up all the resources it binds.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Unless <database>ONLY</database> is added, all the savepoints created after the named
      savepoint are released as well.</para>
      <para>For a full discussion of savepoints, see <link
      linkend="langrefupd25-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>
    <section id="langrefupd25-rollback">
      <title><database>ROLLBACK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ROLLBACK [WORK]
   [TRANSACTION <replaceable>tr_name</replaceable>]
   [RETAIN [SNAPSHOT] | TO [SAVEPOINT] <replaceable>sp_name</replaceable> | RELEASE]</programlisting>
            <itemizedlist>
              <listitem>
                <para>The <database>TRANSACTION</database> clause is only available in ESQL.</para>
              </listitem>
              <listitem>
                <para>The <database>RELEASE</database> clause is only available in ESQL, and is
                discouraged.</para>
              </listitem>
              <listitem>
                <para><database>RETAIN</database> and <database>TO</database> are only available in
                DSQL.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-rollback-retain">
        <title><database>ROLLBACK RETAIN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Undoes all the database changes carried out in the transaction without closing it.
          User variables set with <link
          linkend="langrefupd25-intfunc-set_context"><database>RDB$SET_CONTEXT()</database></link>
          remain unchanged.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROLLBACK [WORK] RETAIN [SNAPSHOT]</programlisting>
              <!--IB6 LangRef says for COMMIT RETAIN [SNAPSHOT]:
  "Make the transaction’s changes visible to subsequent SNAPSHOT transactions or
   READ COMMITTED transactions."
But since ROLLBACK doesn't apply any changes, I wonder what SNAPSHOT would
do here... still, the syntax IS supported.-->
            </blockquote></para>
        </formalpara>
        <note>
          <para>The functionality provided by <database>ROLLBACK RETAIN</database> has been present
          since InterBase 6, but the only way to access it was through the API call
          <function>isc_rollback_retaining()</function>.</para>
        </note>
      </section>
      <section id="langrefupd25-rollback-to-savepoint">
        <title><database>ROLLBACK TO SAVEPOINT</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Undoes everything that happened in a transaction since the creation of the
          savepoint.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
        <!--Keep this itemizedlist synchronized with the one under SAVEPOINT !-->
        <itemizedlist>
          <listitem>
            <para>All the database mutations performed within the transaction since the savepoint
            was created are undone. User variables set with <link
            linkend="langrefupd25-intfunc-set_context"><database>RDB$SET_CONTEXT()</database></link>
            remain unchanged.</para>
          </listitem>
          <listitem>
            <para>All savepoints created after the one named are destroyed. All earlier savepoints
            are preserved, as is the savepoint itself. This means that you can rollback to the same
            savepoint several times.</para>
          </listitem>
          <listitem>
            <para>All implicit and explicit record locks acquired since the savepoint are released.
            Other transactions that have requested access to rows locked after the savepoint must
            continue to wait until the transaction is committed or rolled back. Other transactions
            that have not already requested the rows can request and access the unlocked rows
            immediately.</para>
          </listitem>
        </itemizedlist>
        <para>For a full discussion of savepoints, see <link
        linkend="langrefupd25-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
      </section>
    </section>
    <section id="langrefupd25-savepoint">
      <title><database>SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <!--ESQL: no-->
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates an SQL-99 compliant savepoint, to which you can later rollback your work
        without rolling back the entire transaction. Savepoint mechanisms are also known as
        <quote>nested transactions</quote>.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SAVEPOINT <replaceable>&lt;name&gt;</replaceable>

<replaceable>&lt;name&gt;</replaceable>  ::=  a user-chosen identifier, unique within the transaction</programlisting>
          </blockquote></para>
      </formalpara>
      <para>If the supplied name exists already within the same transaction, the existing savepoint
      is deleted and a new one is created with the same name.</para>
      <para>If you later want to rollback your work to the point where the savepoint was created,
      use:</para>
      <blockquote>
        <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
      </blockquote>
      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
      <!--Keep this itemizedlist synchronized with the one under ROLLBACK TO SAVEPOINT !-->
      <itemizedlist>
        <listitem>
          <para>All the database mutations performed within the transaction since the savepoint was
          created are undone. User variables set with <link
          linkend="langrefupd25-intfunc-set_context"><database>RDB$SET_CONTEXT()</database></link>
          remain unchanged.</para>
        </listitem>
        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are
          preserved, as is the savepoint itself. This means that you can rollback to the same
          savepoint several times.</para>
        </listitem>
        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released.
          Other transactions that have requested access to rows locked after the savepoint must
          continue to wait until the transaction is committed or rolled back. Other transactions
          that have not already requested the rows can request and access the unlocked rows
          immediately.</para>
        </listitem>
      </itemizedlist>
      <para>The internal savepoint bookkeeping can consume huge amounts of memory, especially if you
      update the same records multiple times in one transaction. If you don't need a savepoint
      anymore but you're not yet ready to end the transaction, you can delete the savepoint and free
      the resources it uses with:</para>
      <blockquote>
        <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
      </blockquote>
      <para>With <database>ONLY</database>, the named savepoint is the only one that gets released.
      Without it, all savepoints created after it are released as well.</para>
      <formalpara>
        <title>Example DSQL session using a savepoint</title>
        <para><blockquote>
            <programlisting>create table test (id integer);
commit;
insert into test values (1);
commit;
insert into test values (2);
savepoint y;
delete from test;
select * from test;   -- returns no rows
rollback to y;
select * from test;   -- returns two rows
rollback;
select * from test;   -- returns one row</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-savepoint-internal">
        <title>Internal savepoints</title>
        <!--Does this belong here? Is it SQL? The TPB is an API thing, right?-->
        <para>By default, the engine uses an automatic transaction-level system savepoint to perform
        transaction rollback. When you issue a <database>ROLLBACK</database> statement, all changes
        performed in this transaction are backed out via a transaction-level savepoint and the
        transaction is then committed. This logic reduces the amount of garbage collection caused by
        rolled back transactions.</para>
        <para>When the volume of changes performed under a transaction-level savepoint is getting
        large (10<superscript>4</superscript>–10<superscript>6</superscript> records affected), the
        engine releases the transaction-level savepoint and uses the TIP mechanism to roll back the
        transaction if needed.</para>
        <tip>
          <para>If you expect the volume of changes in your transaction to be large, you can specify
          the <database>NO AUTO UNDO</database> option in your <database>SET TRANSACTION</database>
          statement, or – if you use the API – set the TPB flag <systemitem
          class="constant">isc_tpb_no_auto_undo</systemitem>. Both prevent the creation of the
          transaction-level savepoint.</para>
        </tip>
      </section>
      <section id="langrefupd25-savepoint-psql">
        <title>Savepoints and PSQL</title>
        <!--Here again the question whether it belongs here.-->
        <para>Transaction control statements are not allowed in PSQL, as that would break the
        atomicity of the statement that calls the procedure. But Firebird does support the raising
        and handling of exceptions in PSQL, so that actions performed in stored procedures and
        triggers can be selectively undone without the entire procedure failing. Internally,
        automatic savepoints are used to:</para>
        <itemizedlist>
          <listitem>
            <para>undo all actions in a <database>BEGIN...END</database> block where an exception
            occurs;<!--Even if the exception is caught by a WHEN at the end of the block? Test!
Also, it turns out that non-SQL actions are not undone (at least not all of them).
See thread [firebird-support] FOR SELECT Commands to skip to the next record... of 21 Nov 2010.
The fact that savepoints are used may explain why non-SQL actions are not reversed. --></para>
          </listitem>
          <listitem>
            <para>undo all actions performed by the SP/trigger (or, in the case of a selectable SP,
            all actions performed since the last <database>SUSPEND</database>) when it terminates
            prematurely due to an uncaught error or exception.</para>
          </listitem>
        </itemizedlist>
        <para>Each PSQL exception handling block is also bounded by automatic system
        savepoints.</para>
      </section>
    </section>
    <section id="langrefupd25-set-trans">
      <title><database>SET TRANSACTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Starts and optionally configures a transaction.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SET TRANSACTION
   [NAME <replaceable>hostvar</replaceable>]
   [READ WRITE | READ ONLY]
   [ [ISOLATION LEVEL] { SNAPSHOT [TABLE STABILITY]
                         | READ COMMITTED [[NO] RECORD_VERSION] } ]
   [WAIT | NO WAIT]
   [LOCK TIMEOUT <replaceable>seconds</replaceable>]
   [NO AUTO UNDO]
   [IGNORE LIMBO]
   [RESERVING <replaceable>&lt;tables&gt;</replaceable> | USING <replaceable>&lt;dbhandles&gt;</replaceable>]

<replaceable>&lt;tables&gt;</replaceable>      ::=  <replaceable>&lt;table_spec&gt;</replaceable> [, <replaceable>&lt;table_spec&gt;</replaceable> ...]

<replaceable>&lt;table_spec&gt;</replaceable>  ::=  <replaceable>tablename</replaceable> [, <replaceable>tablename</replaceable> ...]
                      [FOR [SHARED | PROTECTED] {READ | WRITE}]

<replaceable>&lt;dbhandles&gt;</replaceable>   ::=  <replaceable>dbhandle</replaceable> [, <replaceable>dbhandle</replaceable> ...]</programlisting>
            <!--In Fb 1.0 gpre I find "NO_AUTO_UNDO" (with underscores).
In DSQL, the underscored version is rejected.
Dmitry says: "I suspect it was inherited from InterBase 6.0 and nobody
cared to document it there."
- It's still not documented in IB 6.5 LangRef and EmbedSQL-->
            <itemizedlist>
              <listitem>
                <para>The <database>NAME</database> option is only available in ESQL. It must be
                followed by a previously declared and initialized host-language variable. Without
                <database>NAME</database>, <database>SET TRANSACTION</database> applies to the
                default transaction.</para>
              </listitem>
              <listitem>
                <para>The <database>USING</database> option is also ESQL-only. It limits the
                databases that the transaction can access to the ones mentioned here.</para>
              </listitem>
              <listitem>
                <para><database>IGNORE LIMBO</database> and <database>LOCK TIMEOUT</database> are
                not supported in ESQL.</para>
              </listitem>
              <listitem>
                <para><database>LOCK TIMEOUT</database> and <database>NO WAIT</database> are
                mutually exclusive.</para>
              </listitem>
              <listitem>
                <para>Default option settings are: <database>READ WRITE</database> +
                <database>WAIT</database> + <database>SNAPSHOT</database>.</para>
              </listitem>
            </itemizedlist>
            <!--Ask Claudio or Dmitry:
- Is LOCK TIMEOUT 0 the same as no timeout, or as NO WAIT?-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-set-trans-ignore-limbo">
        <title><database>IGNORE LIMBO</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>With this option, records created by limbo transactions are ignored. Transactions
          are in limbo if the second stage of a two-phase commit fails.</para>
        </formalpara>
        <note>
          <para><database>IGNORE LIMBO</database> surfaces the <systemitem
          class="constant">isc_tpb_ignore_limbo</systemitem> TPB parameter, available in the API
          since <application>InterBase</application> times and mainly used by
          <application>gfix</application>.</para>
        </note>
      </section>
      <section id="langrefupd25-set-trans-lock-timeout">
        <title><database>LOCK TIMEOUT</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>This option is only available for <database>WAIT</database> transactions. It takes a
          non-negative integer as argument, prescribing the maximum number of seconds that the
          transaction should wait when a lock conflict occurs. If the the waiting time has passed
          and the lock has still not been released, an error is generated.</para>
        </formalpara>
        <note>
          <para>This is a brand new feature in Firebird 2. Its API equivalent is the new <systemitem
          class="constant">isc_tpb_lock_timeout</systemitem> TPB parameter.</para>
        </note>
      </section>
      <section id="langrefupd25-set-trans-no-auto-undo">
        <title><database>NO AUTO UNDO</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
          <!--In ESQL probably as NO_AUTO_UNDO, i.e. with underscores! See comment under Syntax, above.-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>With <database>NO AUTO UNDO</database>, the transaction refrains from keeping the
          log that is normally used to undo changes in the event of a rollback. Should the
          transaction be rolled back after all, other transactions will pick up the garbage
          (eventually).<!--Is that correct? Under SAVEPOINT, it says that the TIP mechanism is used. What is that?-->
          This option can be useful for massive insertions that don't need to be rolled back. For
          transactions that don't perform any mutations, <database>NO AUTO UNDO</database> makes no
          difference at all.</para>
        </formalpara>
        <note>
          <para><database>NO AUTO UNDO</database> is the SQL equivalent of the <systemitem
          class="constant">isc_tpb_no_auto_undo</systemitem> TPB parameter, available in the API
          since <application>InterBase</application> times.</para>
        </note>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd25-psql">
    <title>PSQL statements</title>
    <para>PSQL – Procedural SQL – is the Firebird programming language used in stored procedures,
    triggers and executable blocks.</para>
    <section id="langrefupd25-psql-begin-end">
      <title><database>BEGIN ... END</database> blocks may be empty</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
        allowing you to write stub code without having to resort to dummy statements.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-break">
      <title><database>BREAK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link linkend="langrefupd25-psql-leave"><database>LEAVE</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BREAK</database> immediately terminates a <database>WHILE</database> or
        <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure selphrase(num int)
returns (phrase varchar(40))
as
begin
  for select Phr from Phrases into phrase do
  begin
    if (num &lt; 1) then <emphasis role="bold">break;</emphasis>
    suspend;
    num = num - 1;
  end
  phrase = '***  Ready!  ***';
  suspend;
end</programlisting>
            <para>This selectable SP returns at most <replaceable>num</replaceable> rows from the
            table Phrases. The variable <replaceable>num</replaceable> is decremented in each
            iteration; once it is smaller than 1, the loop is terminated with
            <database>BREAK</database>. The program then continues at the line
            <quote><literal>phrase = '*** Ready! ***';</literal></quote>.</para>
          </blockquote></para>
      </formalpara>
      <important>
        <para>Since Firebird 1.5, use of the SQL-99 compliant alternative <link
        linkend="langrefupd25-psql-leave"><database>LEAVE</database></link> is preferred.</para>
        <!--Not synonyms anymore, for in 2.0 LEAVE supports a label whereas BREAK doesn't.-->
      </important>
      <!--TESTED:
Contrary to what Fb 1.5 rlsnotes suggest, BREAK works in SPs *and* triggers as from 1.0.
In IB6 it doesn't exist.-->
    </section>
    <section id="langrefupd25-psql-close-cursor">
      <title><database>CLOSE</database> cursor</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Closes an open cursor. Any cursors still open when the trigger, stored procedure or
        <database>EXECUTE BLOCK</database> statement they belong to is exited, will be closed
        automatically.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CLOSE <replaceable>cursorname</replaceable>;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para>See <link linkend="langrefupd25-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-declare">
      <title><database>DECLARE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Declares a PSQL local variable.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>&lt;var_spec&gt;</replaceable>;

<replaceable>&lt;var_spec&gt;</replaceable>  ::=  <replaceable>&lt;type&gt;</replaceable> [NOT NULL] [<replaceable>&lt;coll&gt;</replaceable>] [<replaceable>&lt;default&gt;</replaceable>]
                   | CURSOR FOR (<replaceable>select-statement</replaceable>)
<replaceable>&lt;type&gt;</replaceable>      ::=  <replaceable>sql_datatype</replaceable> | [TYPE OF] <replaceable>domain</replaceable> | TYPE OF COLUMN <replaceable>rel</replaceable>.<replaceable>col</replaceable>
<replaceable>&lt;coll&gt;</replaceable>      ::=  COLLATE <replaceable>collation</replaceable>
<replaceable>&lt;default&gt;</replaceable>   ::=  {= | DEFAULT} <replaceable>value</replaceable></programlisting>
            <itemizedlist spacing="compact">
              <listitem>
                <para>If <replaceable>sql_datatype</replaceable> is a text type, it may include a
                character set.</para>
              </listitem>
              <listitem>
                <para>Obviously, a <database>COLLATE</database> clause is only allowed with text
                types.</para>
              </listitem>
            </itemizedlist>
            <!--According to IB6 Langref, the var's type
  "can be any InterBase datatype except Blob and arrays"
But 2.5 happily accepts BLOBs as variables. And so does 2.0.
If time available, ind out since when BLOBs are accepted as in/out params and local vars.

Hmm: this one returns 'klaar' in 2.5, but fails in 2.0 ('invalid BLOB ID'):
  execute block returns (s blob sub_type text)
  as
  declare b blob sub_type binary;
  begin
    s = 'klaar';
    suspend;
  end
The error is not with the locvar b, but with outparm s
If you don't assign a value to s, there is no error and null is returned.
-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-psql-declare-cursor">
        <title><database>DECLARE</database> ... <database>CURSOR</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <!--ATTENTION: DECLARE ... CURSOR was already available in ESQL. Difference: according to LangRef, the SELECT need not go between () in ESQL.

Then there is a DSQL form:
  DECLARE cursor CURSOR FOR <statement_id>
Here, <statement_id> is the id of an already prepared stmt. How do you do that in DSQL?
PREPARE seems only supported in ESQL. Should you prepare via the API, and is the handle the ID?
Incidentally,  "declare cursor billie cursor for..." already breaks on "billie".
This suggests that this use is not supported after all, at least not in the form given in the LangRef.
Indeed, in IBPhoenix's FirebirdReference, in the head of the DECLARE CURSOR section, DSQL has been stricken out.

And is the optional [VARIABLE] supported in DSQL and ESQL?-->
          <para>Declares a named cursor and binds it to its own <database>SELECT</database>
          statement. The cursor can later be opened, used to walk the result set, and closed again.
          Positioned updates and deletes (using <link
          linkend="langrefupd25-psql-wherecurrentof"><database>WHERE CURRENT OF</database></link>)
          are also supported. PSQL cursors are available in triggers, stored procedures and <link
          linkend="langrefupd25-execblock"><database>EXECUTE BLOCK</database></link>
          statements.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>execute block
returns (relation char(31), sysflag int)
as
declare cur cursor for 
  (select rdb$relation_name, rdb$system_flag from rdb$relations);
begin
  open cur;
  while (1=1) do
  begin
    fetch cur into relation, sysflag;
    if (row_count = 0) then leave;
    suspend;
  end
  close cur;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>A <quote><database>FOR UPDATE</database></quote> clause is allowed in the
                <database>SELECT</database> statement, but not required for a positioned update or
                delete to succeed.</para>
              </listitem>
              <listitem>
                <para>Make sure that declared cursor names do not clash with any names defined later
                on in <link linkend="langrefupd25-psql-forselect-ascursor"><database>AS
                CURSOR</database></link> clauses.</para>
              </listitem>
              <listitem>
                <para>If you need a cursor to loop through an output set, it is almost always easier
                – and less error-prone – to use a <database>FOR SELECT</database> statement with an
                <database>AS CURSOR</database> clause. Declared cursors must be explicitly opened,
                fetched from, and closed. Furthermore, you need to check
                <varname>row_count</varname> after every fetch and break out of the loop if it is
                zero. <database>AS CURSOR</database> takes care of all of that automagically.
                However, declared cursors give you more control over the sequence of events, and
                allow you to operate several cursors in parallel.</para>
              </listitem>
              <listitem>
                <para>The <database>SELECT</database> statement may contain named SQL parameters,
                like in <quote><code>select name || :sfx from names where number =
                :num</code></quote>. Each parameter must be a PSQL variable that has been declared
                previously (this includes any in/out params of the PSQL module). When the cursor is
                opened, the parameter is assigned the current value of the variable.</para>
              </listitem>
              <listitem>
                <para>Caution! If the value of a PSQL variable that is used in the
                <database>SELECT</database> statement changes during execution of the loop, the
                statement <emphasis>may</emphasis> (but will not always) be re-evaluated for the
                remaining rows. In general, this situation should be avoided. If you really need
                this behaviour, test your code thoroughly and make sure you know how variable
                changes affect the outcome. Also be advised that the behaviour may depend on the
                query plan, in particular the use of indices. As it is currently not strictly
                defined, it may change in some future version of Firebird.</para>
                <!--I have noticed that the statement is NOT re-avaluated if an index is used, and IS re-evaluated if no index is used.
Adding PLAN (T NATURAL) to a certain query forced re-evaluation and thus altered the outcome.
But I don't know if this is always the case, and if the use of an index is the only factor.-->
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>See also</title>
          <para><link linkend="langrefupd25-psql-open-cursor"><database>OPEN</database>
          cursor</link>, <link linkend="langrefupd25-psql-fetch-cursor"><database>FETCH</database>
          cursor</link>, <link linkend="langrefupd25-psql-close-cursor"><database>CLOSE</database>
          cursor</link></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-declare-init">
        <title><database>DECLARE [VARIABLE]</database> with initialization</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 1.5 and above, a PSQL local variable can be initialized upon
          declaration. The <database>VARIABLE</database> keyword has become optional.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure proccie (a int)
returns (b int)
as
  declare p int;
  declare q int = 8;
  declare r int default 9;
  declare variable s int;
  declare variable t int = 10;
  declare variable u int default 11;
begin
  <replaceable>&lt;intelligent code here&gt;</replaceable>
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-declare-domain">
        <title><database>DECLARE</database> with <database>DOMAIN</database> instead of
        datatype</title>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.1 and above, PSQL local variables and input/output parameters can be
          declared with a domain instead of a datatype. The <database>TYPE OF</database> modifier
          allows using only the domain's datatype and not its <database>NOT NULL</database> setting,
          <database>CHECK</database> constraint and/or default value. If the domain is of a text
          type, its character set and collation are always included.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure MyProc (a int, f <emphasis role="bold">ternbool</emphasis>)
  returns (b int, x <emphasis role="bold">type of</emphasis> <emphasis role="bold">bigfloat</emphasis>)
as
  declare p int;
  declare q int = 8;
  declare y <emphasis role="bold">stocknum</emphasis> default -1;
begin
  <replaceable>&lt;very intelligent code here&gt;</replaceable>
end</programlisting>
              <para>(This example presupposes that <database>TERNBOOL</database>,
              <database>BIGFLOAT</database> and <database>STOCKNUM</database> are domains already
              defined in the database.)</para>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>If you change a domain's definition, existing PSQL code using that domain may become
          invalid. For information on how to detect this, please read the note <link
          linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
          <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
          document.</para>
        </warning>
      </section>
      <section id="langrefupd25-psql-declare-typeofcolumn">
        <title><database>TYPE OF COLUMN</database> in variable declaration</title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Analogous to the <quote><database>TYPE OF</database>
          <replaceable>domain</replaceable></quote> syntax supported since version 2.1, it is now
          also possible to declare variables and parameters as having the type of an existing table
          or view column. Only the type itself is used; in the case of string types, this includes
          the character set and the collation. Constraints and default values are never copied from
          the source column.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table cars (
  make varchar(20),
  model varchar(20),
  weight numeric(4),
  topspeed numeric(3),
  constraint uk_make_model unique (make, model)
)

create procedure max_kinetic_energy
                   (make <emphasis role="bold">type of column</emphasis> cars.make,
                    model <emphasis role="bold">type of column</emphasis> cars.model)
           returns (max_e_kin double precision)
as
  declare mass <emphasis role="bold">type of column</emphasis> cars.weight;
  declare velocity <emphasis role="bold">type of column</emphasis> cars.topspeed;
begin
  select weight, topspeed from cars
    where make = :make and model = :model
    into mass, velocity;
  max_e_kin = 0.5 * mass * velocity * velocity;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <title>Warnings</title>
          <itemizedlist>
            <listitem>
              <para>The collation of the source column is not always taken into consideration when
              comparisons (e.g. equality tests) are made, even though it should. This is due to a
              bug that has been fixed for Firebird 3.</para>
              <!--More precisely: If the source column has a domain type with a collation, all goes well. If type and collation
were defined directly on the column, it goes wrong.-->
            </listitem>
            <listitem>
              <para>PSQL code using <database>TYPE OF COLUMN</database> may become invalid if the
              column's type is changed at a later time. For information on how to detect this,
              please read the note <link linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
              <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
              document.</para>
            </listitem>
          </itemizedlist>
        </warning>
      </section>
      <section id="langrefupd25-psql-declare-collate">
        <title><database>COLLATE</database> in variable declaration</title>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.1 and above, a <database>COLLATE</database> clause is allowed in the
          declaration of text-type PSQL local variables and input/output parameters.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure GimmeText
  returns (txt char(32) character set utf8 collate unicode)
as
  declare simounao mytextdomain collate pt_br default 'não';
begin
  <replaceable>&lt;stunningly intelligent code here&gt;</replaceable>
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-declare-notnull">
        <title><database>NOT NULL</database> in variable declaration</title>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.1 and above, a <database>NOT NULL</database> constraint is allowed in
          the declaration of PSQL local variables and input/output parameters.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure Compute(a int not null, b int not null)
  returns (outcome bigint not null)
as
  declare temp bigint not null;
begin
  <replaceable>&lt;slightly disappointing code here&gt;</replaceable>
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-psql-exception">
      <title><database>EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>EXCEPTION</database> syntax has been extended so that the user
        can<orderedlist numeration="loweralpha" spacing="compact">
            <listitem>
              <para>Rethrow a caught exception or error.</para>
            </listitem>
            <listitem>
              <para>Provide a custom message when throwing a user-defined exception.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXCEPTION [<replaceable>&lt;exception-name&gt;</replaceable> [<replaceable>custom-message</replaceable>]]

<replaceable>&lt;exception-name&gt;</replaceable>  ::=  A previously defined exception name</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-psql-exception-rethrow">
        <title>Rethrowing a caught exception</title>
        <para>Within the exception handling block only, you can rethrow the caught exception or
        error by giving the <database>EXCEPTION</database> command without any arguments. Outside
        such blocks, this <quote>bare</quote> command has no effect.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>when any do
begin
  insert into error_log (...) values (sqlcode, ...);
  exception;
end</programlisting>
              <para>This example first logs some information about the exception or error, and then
              rethrows it.</para>
              <!--So it also works with SQL en GDS errors? Answered by Dmitry: YES.-->
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-exception-custom-msg">
        <title>Providing a custom error message</title>
        <para>Firebird 1.5 and up allow you to override an exception's default error message by
        supplying an alternative one when throwing the exception.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>exception ex_data_error 'You just lost some valuable data';</programlisting>
              <programlisting>exception ex_bad_type 'Wrong type for record with id ' || new.id;</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>Starting at version 2.0, the maximum message length is 1021 instead of 78
          characters.</para>
        </note>
      </section>
    </section>
    <section id="langrefupd25-psql-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and above, (compound) expressions are allowed as input parameters for
        stored procedures called with <database>EXECUTE PROCEDURE</database>. See <link
        linkend="langrefupd25-execproc"><citetitle>DML statements :: <database>EXECUTE
        PROCEDURE</database></citetitle></link> for full info and examples.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-execstat">
      <title><database>EXECUTE STATEMENT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>EXECUTE STATEMENT</database> takes a string argument and executes it as if
        it had been submitted as a DSQL statement. If the statement returns data, the
        <database>INTO</database> clause assigns these to local variables. If the statement may
        return more than one row of data, the <quote><database>FOR ... DO</database></quote> form
        must be used to create a loop.</para>
      </formalpara>
      <formalpara>
        <title>Syntax (full)</title>
        <para><blockquote>
            <programlisting><replaceable>&lt;execute-statement&gt;</replaceable>  ::=  EXECUTE STATEMENT <replaceable>&lt;argument&gt;</replaceable>
                            [<replaceable>&lt;option&gt;</replaceable> ...]
                            [INTO <replaceable>&lt;variables&gt;</replaceable>]

<database><replaceable>&lt;looped-version&gt;</replaceable></database>     ::=  FOR <replaceable>&lt;execute-statement&gt;</replaceable> DO <replaceable>&lt;psql-statement&gt;</replaceable>

<replaceable>&lt;argument&gt;</replaceable>           ::=  <replaceable>paramless-stmt</replaceable>
                          | (<replaceable>paramless-stmt</replaceable>)
                          | (<replaceable>&lt;stmt-with-params&gt;</replaceable>) (<replaceable>&lt;param-values&gt;</replaceable>)

<replaceable>&lt;stmt-with-params&gt;</replaceable>   ::=  A statement containing one or more parameters,
                          in one of these forms:
                            - named: ':' + paramname, e.g. :a, :b, :size
                            - positional: each param is designated by '?'
                          Named and positional parameters may not be mixed.

<replaceable>&lt;param-values&gt;</replaceable>       ::=  <replaceable>&lt;named-values&gt;</replaceable> | <replaceable>&lt;positional-values&gt;</replaceable>
<replaceable>&lt;named-values&gt;</replaceable>       ::=  <replaceable>paramname</replaceable> := <replaceable>value-expr</replaceable> [, <replaceable>paramname</replaceable> := <replaceable>value-expr</replaceable> ...]
<replaceable>&lt;positional-values&gt;</replaceable>  ::=  <replaceable>value-expr</replaceable> [, <replaceable>value-expr</replaceable> ...]

<replaceable>&lt;option&gt;</replaceable>             ::=  WITH {AUTONOMOUS|COMMON} TRANSACTION
                          | WITH CALLER PRIVILEGES
                          | AS USER <replaceable>user</replaceable>
                          | PASSWORD <replaceable>password</replaceable>
                          | ROLE <replaceable>role</replaceable>
                          | ON EXTERNAL [DATA SOURCE] <replaceable>&lt;connect-string&gt;</replaceable>

<replaceable>&lt;connect-string&gt;</replaceable>     ::=  [<replaceable>&lt;hostspec&gt;</replaceable>]<replaceable>path-or-alias</replaceable>
<replaceable>&lt;hostspec&gt;</replaceable>           ::=  <replaceable>&lt;tcpip-hostspec&gt;</replaceable> | <replaceable>&lt;netbeui-hostspec&gt;</replaceable>
<replaceable>&lt;tcpip-hostspec&gt;</replaceable>     ::=  <replaceable>hostname</replaceable>:
<replaceable>&lt;netbeui-hostspec&gt;</replaceable>   ::=  \\<replaceable>hostname</replaceable>\

<replaceable>&lt;variables&gt;</replaceable>          ::=  [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...]

<replaceable>&lt;psql-statement&gt;</replaceable>     ::=  A simple or compound PSQL statement.


NOTICE:
<replaceable>paramless-stmt</replaceable>, <replaceable>&lt;stmt-with-params&gt;</replaceable>, <replaceable>user</replaceable>, <replaceable>password</replaceable>, <replaceable>role</replaceable> and <replaceable>&lt;connect-string&gt;</replaceable>
are string expressions. When given directly, i.e. as literal strings, they must
be enclosed in single-quote characters.</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The following paragraphs first explain the basic usage of <database>EXECUTE
      STATEMENT</database> as it has been since Firebird 1.5. After that, the new features in 2.5
      are introduced.</para>
      <section id="langrefupd25-psql-execstat-nooutput">
        <title>No data returned</title>
        <para>This form is used with <database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database> and <database>EXECUTE PROCEDURE</database> statements that
        return no data.</para>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;statement&gt;</replaceable>

<replaceable>&lt;statement&gt;</replaceable>  ::=  An SQL statement returning no data.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleOne (ProcName varchar(100))
as
declare variable stmt varchar(1024);
declare variable param int;
begin
   select min(SomeField) from SomeTable into param;
   stmt = 'execute procedure ' 
          || ProcName 
          || '(' 
          || cast(param as varchar(20)) 
          || ')';
   execute statement stmt;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>Although this form of <database>EXECUTE STATEMENT</database> can also be used with
          all kinds of DDL strings (except <database>CREATE/DROP DATABASE</database>), it is
          generally very, very unwise to use this trick in order to circumvent the no-DDL rule in
          PSQL.</para>
        </warning>
      </section>
      <section id="langrefupd25-psql-execstat-singleton">
        <title>One row of data returned</title>
        <para>This form is used with singleton <database>SELECT</database> statements.</para>
        <!--FIND OUT: What about statements with a RETURNING clause?-->
        <!--EXECUTE PROCEDURE with RETURNING_VALUES is NOT possible in EXECUTE STATEMENT
(Token unknown - line 1, char 25 returning_values). Why?-->
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  An SQL statement returning at most one row of data.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleTwo (TableName varchar(100))
as
declare variable param int;
begin
  execute statement
    'select max(CheckField) from ' || TableName into :param;
  if (param &gt; 100) then
    exception Ex_Overflow 'Overflow in ' || TableName;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-multirow">
        <title>Any number of data rows returned</title>
        <para>This form – analogous to <quote><database>FOR SELECT ... DO</database></quote> – is
        used with <database>SELECT</database> statements that may return a multi-row dataset.</para>
        <!--FIND OUT: What about statements with a RETURNING clause?-->
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>FOR EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   DO <replaceable>&lt;psql-statement&gt;</replaceable>

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  Any SELECT statement.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote>
<replaceable>&lt;psql-statement&gt;</replaceable>    ::=  A simple or compound PSQL statement.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleThree 
  (TextField varchar(100),
   TableName varchar(100))
returns 
  (LongLine varchar(32000))
as
declare variable Chunk varchar(100);
begin
  Chunk = '';
  for execute statement
    'select ' || TextField || ' from ' || TableName into :Chunk
  do
    if (Chunk is not null) then
      LongLine = LongLine || Chunk || ' ';
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-improved-perf">
        <title>Improved performance</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In previous versions, if <database>EXECUTE STATEMENT</database> occurred in a loop,
          the SQL statement would be prepared, executed and released upon every iteration. In
          Firebird 2.5 and above, such a statement is only prepared once, giving a huge performance
          benefit.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-with-trans">
        <title><database>WITH</database>
        {<database>AUTONOMOUS</database>|<database>COMMON</database>}
        <database>TRANSACTION</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Traditionally, the executed SQL statement always ran within the current transaction,
          and this is still the default. <database>WITH AUTONOMOUS TRANSACTION</database> causes a
          separate transaction to be started, with the same parameters as the current transaction.
          It will be committed if the statement runs to completion without errors and rolled back
          otherwise. <database>WITH COMMON TRANSACTION</database> uses the current transaction if
          possible. If the statement must run in a separate connection, an already started
          transaction within that connection is used, if available. Otherwise, a new transaction is
          started with the same parameters as the current transaction. Any new transactions started
          under the <quote><database>COMMON</database></quote> regime are committed or rolled back
          with the current transaction.</para>
          <!--Is that last statement still true if the COMMON is implicit?-->
        </formalpara>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>[FOR]
   EXECUTE STATEMENT <replaceable>sql-statement</replaceable>
   WITH {AUTONOMOUS|COMMON} TRANSACTION
   [...other options...]
   [INTO <replaceable>&lt;variables&gt;</replaceable>]
[DO <replaceable>psql-statement</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-with-caller-privs">
        <title><database>WITH CALLER PRIVILEGES</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>By default, the SQL statement is executed with the privileges of the current user.
          Specifying <database>WITH CALLER PRIVILEGES</database> adds to this the privileges of the
          calling SP or trigger, just as if the statement were executed directly by the routine.
          <database>WITH CALLER PRIVILEGES</database> has no effect if the <database>ON
          EXTERNAL</database> clause is also present.</para>
          <!--Find out: is WCP effective if the _internal_ provider creates an extra connection?-->
        </formalpara>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>[FOR]
   EXECUTE STATEMENT <replaceable>sql-statement</replaceable>
   WITH CALLER PRIVILEGES
   [...other options...]
   [INTO <replaceable>&lt;variables&gt;</replaceable>]
[DO <replaceable>psql-statement</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-on-external">
        <title><database>ON EXTERNAL</database> [<database>DATA SOURCE</database>]</title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>With <database>ON EXTERNAL DATA SOURCE</database>, the SQL statement is executed in
          a separate connection to the same or another database, possibly even on another server. If
          the connect string is <constant>NULL</constant> or <literal>''</literal> (empty string),
          the entire <database>ON EXTERNAL</database> clause is considered absent and the statement
          is executed against the current database.</para>
        </formalpara>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>[FOR]
   EXECUTE STATEMENT <replaceable>sql-statement</replaceable>
   ON EXTERNAL [DATA SOURCE] <replaceable>&lt;connect-string&gt;</replaceable>
   [AS USER <replaceable>user</replaceable>]
   [PASSWORD <replaceable>password</replaceable>]
   [ROLE <replaceable>role</replaceable>]
   [...other options...]
   [INTO <replaceable>&lt;variables&gt;</replaceable>]
[DO <replaceable>psql-statement</replaceable>]

<replaceable>&lt;connect-string&gt;</replaceable>     ::=  [<replaceable>&lt;hostspec&gt;</replaceable>]<replaceable>path-or-alias</replaceable>
<replaceable>&lt;hostspec&gt;</replaceable>           ::=  <replaceable>&lt;tcpip-hostspec&gt;</replaceable> | <replaceable>&lt;netbeui-hostspec&gt;</replaceable>
<replaceable>&lt;tcpip-hostspec&gt;</replaceable>     ::=  <replaceable>hostname</replaceable>:
<replaceable>&lt;netbeui-hostspec&gt;</replaceable>   ::=  \\<replaceable>hostname</replaceable>\

NOTICE:
<replaceable>sql-statement</replaceable>, <replaceable>user</replaceable>, <replaceable>password</replaceable>, <replaceable>role</replaceable> and <replaceable>&lt;connect-string&gt;</replaceable> are string
expressions. When given directly, i.e. as literal strings, they must
be enclosed in single-quote characters.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Connection pooling</title>
          <para><itemizedlist>
              <listitem>
                <para>External connections made by statements <database>WITH COMMON
                TRANSACTION</database> (the default) will remain open until the current transaction
                ends. They can be reused by subsequent calls to <database>EXECUTE
                STATEMENT</database>, but only if the connect string is <emphasis>exactly</emphasis>
                the same, including case.</para>
                <!--"including case" also if a case-insensitive collation is active? Yep, connection charset/collation don't seem to make a difference here.-->
              </listitem>
              <listitem>
                <para>External connections made by statements <database>WITH AUTONOMOUS
                TRANSACTION</database> are closed as soon as the statement has been executed.</para>
              </listitem>
              <listitem>
                <para>Notice that statements <database>WITH AUTONOMOUS TRANSACTION</database> can
                and will reuse connections that were opened earlier by statements <database>WITH
                COMMON TRANSACTION</database>. If this happens, the reused connection will be left
                open after the statement has been executed. (It must be, because it has at least one
                uncommitted transaction!)</para>
                <!--Actually, I see no reason why 'autonomous' connections shouldn't be left open for reuse as well. Ask Vlad!-->
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Transaction pooling</title>
          <para><itemizedlist>
              <listitem>
                <para>If <database>WITH COMMON TRANSACTION</database> is in effect, transactions
                will be reused as much as possible. They will be committed or rolled back together
                with the current transaction.</para>
              </listitem>
              <listitem>
                <para>If <database>WITH AUTONOMOUS TRANSACTION</database> is specified, a fresh
                transaction will always be started for the statement. This transaction will be
                committed or rolled back immediately after the statement's execution.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Exception handling</title>
          <para>When <database>ON EXTERNAL</database> is used, the extra connection is always made
          via a so-called external provider, even if the connection is to the current database. One
          of the consequences is that you can't catch exceptions the way you are used to. Every
          exception caused by the statement is wrapped in either an
          <errorname>eds_connection</errorname> or an <errorname>eds_statement</errorname> error. In
          order to catch them in your PSQL code, you have to use <database>WHEN GDSCODE</database>
          <errorname>eds_connection</errorname>, <database>WHEN GDSCODE</database>
          <errorname>eds_statement</errorname> or <database>WHEN ANY</database>. (Without
          <database>ON EXTERNAL</database>, exceptions are caught in the usual way, even if an extra
          connection is made to the current database.)</para>
        </formalpara>
        <formalpara>
          <title>Miscellaneous notes</title>
          <para><itemizedlist>
              <listitem>
                <para>The character set used for the external connection is the same as that for the
                current connection.</para>
              </listitem>
              <listitem>
                <para>Two-phase commits are not supported.</para>
              </listitem>
              <listitem>
                <para>For authentication details, please look under <link
                linkend="langrefupd25-psql-execstat-asuser-etc-auth"><citetitle><database>AS
                USER</database>, <database>PASSWORD</database> and <database>ROLE</database> ::
                Authentication</citetitle></link>, below.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-asuser-etc">
        <title><database>AS USER</database>, <database>PASSWORD</database> and
        <database>ROLE</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Optionally, a user name, password and/or role can be specified under which the
          statement must be executed.</para>
        </formalpara>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>[FOR]
   EXECUTE STATEMENT <replaceable>sql-statement</replaceable>
   AS USER <replaceable>user</replaceable>
   PASSWORD <replaceable>password</replaceable>
   ROLE <replaceable>role</replaceable>
   [...other options...]
   [INTO <replaceable>&lt;variables&gt;</replaceable>]
[DO <replaceable>psql-statement</replaceable>]

NOTICE:
<replaceable>sql-statement</replaceable>, <replaceable>user</replaceable>, <replaceable>password</replaceable> and <replaceable>role</replaceable> are string expressions.
When given directly, i.e. as literal strings, they must be
enclosed in single-quote characters.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara id="langrefupd25-psql-execstat-asuser-etc-auth">
          <title>Authentication</title>
          <para>How a user is authenticated and whether a separate connection is opened depends on
          the presence and values of the parameters <database>ON EXTERNAL [DATA SOURCE]</database>,
          <database>AS USER</database>, <database>PASSWORD</database> and
          <database>ROLE</database>.<itemizedlist>
              <listitem>
                <para>If <database>ON EXTERNAL</database> is present, a new connection is always
                opened, and:</para>
                <itemizedlist>
                  <listitem>
                    <para>If at least one of <database>AS USER</database>,
                    <database>PASSWORD</database> and <database>ROLE</database> is present, native
                    authentication is attempted with the given parameter values (locally or
                    remotely, depending on the connect string). No defaults are used for missing
                    parameters.</para>
                  </listitem>
                  <listitem>
                    <para>If all three are absent and the connect string contains no hostname, then
                    the new connection is established on the local host with the same user and role
                    as the current connection. The term 'local' means 'on the same machine as the
                    <emphasis>server</emphasis>' here. This is not necessarily the location of the
                    client.</para>
                  </listitem>
                  <listitem>
                    <para>If all three are absent and the connect string contains a hostname, then
                    trusted authentication is attempted on the remote host (again, remote from the
                    POV of the server). If this succeeds, the remote OS will provide the user name
                    (usually the OS account under which the Firebird process runs).</para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <listitem>
                <para>If <database>ON EXTERNAL</database> is absent:</para>
                <itemizedlist>
                  <listitem>
                    <para>If at least one of <database>AS USER</database>,
                    <database>PASSWORD</database> and <database>ROLE</database> is present, a new
                    connection to the current database is opened with the given parameter values. No
                    defaults are used for missing parameters.</para>
                  </listitem>
                  <listitem>
                    <para>If all three are absent, the statement is executed within the current
                    connection.</para>
                  </listitem>
                </itemizedlist>
              </listitem>
              <!--No vertical space here in PDF output!-->
            </itemizedlist><emphasis>Notice:</emphasis> If a parameter value is
          <constant>NULL</constant> or <literal>''</literal> (empty string), the entire parameter is
          considered absent. Additionally, <database>AS USER</database> is considered absent if its
          value is equal to <varname>CURRENT_USER</varname>, and <database>ROLE</database> if it's
          equal to <varname>CURRENT_ROLE</varname>. The comparison is made case-sensitively; in most
          cases this means that only user and role names given in all-caps can be equal tot
          <varname>CURRENT_USER</varname> or <varname>CURRENT_ROLE</varname>.</para>
          <!--Is this also true if a case-insensitive collation is in effect?-->
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-with-params">
        <title>Parameterized statements</title>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Since Firebird 2.5, the SQL statement to be executed may contain parameters. When
          <database>[FOR] EXECUTE STATEMENT</database> is called, a value must be provided for each
          parameter.</para>
        </formalpara>
        <formalpara>
          <title>Syntax (partial)</title>
          <para><blockquote>
              <programlisting>[FOR]
   EXECUTE STATEMENT (<replaceable>&lt;parameterized-statement&gt;</replaceable>) (<replaceable>&lt;param-assignments&gt;</replaceable>)
   [...options...]
   [INTO <replaceable>&lt;variables&gt;</replaceable>]
[DO <replaceable>psql-statement</replaceable>]

<replaceable>&lt;parameterized-statement&gt;</replaceable>  ::=  An SQL statement containing
                                  <replaceable>&lt;named-param&gt;</replaceable>s or <replaceable>&lt;positional-param&gt;</replaceable>s

<replaceable>&lt;named-param&gt;</replaceable>              ::=  :<replaceable>paramname</replaceable>
<replaceable>&lt;positional-param&gt;</replaceable>         ::=  ?

<replaceable>&lt;param-assignments&gt;</replaceable>        ::=  <replaceable>&lt;named-assignments&gt;</replaceable> | <replaceable>&lt;positional-assignments&gt;</replaceable>
<replaceable>&lt;named-assignments&gt;</replaceable>        ::=  <replaceable>paramname</replaceable> := <replaceable>value</replaceable> [, <replaceable>paramname</replaceable> := <replaceable>value</replaceable> ...]
<replaceable>&lt;positional-assignments&gt;</replaceable>   ::=  <replaceable>value</replaceable> [, <replaceable>value</replaceable> ...]

NOTICE:
<replaceable>&lt;parameterized-statement&gt;</replaceable> is a string expression. When given directly,
i.e. as a literal string, it must be enclosed in single-quote characters.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>With named parameters:</para>
              <programlisting>...
declare license_num varchar(15);
declare connect_string varchar(100);
<emphasis role="bold">declare stmt varchar(100) =
  'select license from cars where driver = :driver and location = :loc';</emphasis>
begin
  ...
  select connstr from databases where cust_id = :id into connect_string;
  ...
  for select id from drivers into current_driver do
  begin  
    for select location from driver_locations
      where driver_id = :current_driver
      into current_location do
    begin
      ...
      <emphasis role="bold">execute statement (stmt) (driver := current_driver,
                                   loc := current_location)
        on external connect_string
        into license_num;</emphasis>
      ...</programlisting>
              <para>The same code with positional parameters:</para>
              <programlisting>...
declare license_num varchar(15);
declare connect_string varchar(100);
<emphasis role="bold">declare stmt varchar(100) =
  'select license from cars where driver = ? and location = ?';</emphasis>
begin
  ...
  select connstr from databases where cust_id = :id into connect_string;
  ...
  for select id from drivers into current_driver do
  begin  
    for select location from driver_locations
      where driver_id = :current_driver
      into current_location do
    begin
      ...
      <emphasis role="bold">execute statement (stmt) (current_driver, current_location)
        on external connect_string
        into license_num;</emphasis>
      ...</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para>Some things to be aware of:<itemizedlist>
              <listitem>
                <para>When a statement has parameters, it must be placed in parentheses when
                <database>EXECUTE STATEMENT</database> is called, regardless whether it is given
                directly as a string, as a variable name, or by another expression.</para>
              </listitem>
              <listitem>
                <para>Named parameters must be preceded by a colon (<quote>:</quote>) in the
                statement itself, but not in the parameter assignments.</para>
              </listitem>
              <listitem>
                <para>Each named parameter may occur several times in the statement, but only once
                in the assignments.</para>
              </listitem>
              <listitem>
                <para>Each named parameter must be assigned a value when <database>EXECUTE
                STATEMENT</database> is called; the assignments can be placed in any order.</para>
              </listitem>
              <listitem>
                <para>The assignment operator for named parameters is
                <quote><literal>:=</literal></quote>, not <quote><literal>=</literal></quote> like
                in SQL.</para>
              </listitem>
              <listitem>
                <para>With positional parameters, the number of values supplied must exactly equal
                the number of parameters (question marks) in the statement.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-psql-execstat-caveats">
        <title>Caveats with <database>EXECUTE STATEMENT</database></title>
        <orderedlist>
          <listitem>
            <para>There is no way to validate the syntax of the enclosed statement.</para>
          </listitem>
          <listitem>
            <para>There are no dependency checks to discover whether tables or columns have been
            dropped.</para>
          </listitem>
          <listitem>
            <para>Even though the performance in loops has been significantly improved in Firebird
            2.5, execution is still considerably slower than that of statements given
            directly.</para>
          </listitem>
          <listitem>
            <para>Return values are strictly checked for data type in order to avoid unpredictable
            type-casting exceptions. For example, the string <literal>'1234'</literal> would convert
            to an integer, 1234, but <literal>'abc'</literal> would give a conversion error.</para>
          </listitem>
        </orderedlist>
        <para>All in all, this feature is meant to be used very cautiously and you should always
        take the above factors into account. If you can achieve the same result with PSQL and/or
        DSQL, then this is nearly always preferable.</para>
      </section>
    </section>
    <section id="langrefupd25-psql-exit">
      <title><database>EXIT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <database>EXIT</database> can be used in all PSQL. In earlier
        versions it is only supported in stored procedures, not in triggers.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-fetch-cursor">
      <title><database>FETCH</database> cursor</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Fetches the next data row from a cursor's result set and stores the column values in
        PSQL variables.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>FETCH <replaceable>cursorname</replaceable> INTO [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...];</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The <link linkend="langrefupd25-row_count"><varname>ROW_COUNT</varname></link>
              context variable will be 1 if the fetch returned a data row and 0 if the end of the
              set has been reached.</para>
            </listitem>
            <listitem>
              <para>You can do a positioned <link
              linkend="langrefupd25-update"><database>UPDATE</database></link> or <link
              linkend="langrefupd25-delete"><database>DELETE</database></link> on the fetched row
              with the <database>WHERE CURRENT OF</database> clause.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para>See <link linkend="langrefupd25-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-forexecstatdo">
      <title><database>FOR EXECUTE STATEMENT ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>See <link linkend="langrefupd25-psql-execstat-multirow"><citetitle><database>EXECUTE
        STATEMENT</database> :: Any number of data rows returned</citetitle></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-forselect">
      <title><database>FOR SELECT ... INTO ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a <database>SELECT</database> statement and retrieves the result set. In each
        iteration of the loop, the field values of the current row are copied into local variables.
        Adding an <database>AS CURSOR</database> clause enables positioned deletes and updates.
        <database>FOR SELECT</database> statements may be nested.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>FOR <replaceable>&lt;select-stmt&gt;</replaceable>
   INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   [AS CURSOR <replaceable>name</replaceable>]
DO
   <replaceable>&lt;psql-stmt&gt;</replaceable>

<replaceable>&lt;select-stmt&gt;</replaceable>  ::=  A valid <database>SELECT</database> statement.
<replaceable>&lt;var&gt;</replaceable>          ::=  A PSQL variable name, optionally preceded by <quote><literal>:</literal></quote>
<replaceable>&lt;psql-stmt&gt;</replaceable>    ::=  A single statement or a block of PSQL code.</programlisting>
            <itemizedlist>
              <listitem>
                <para>The <database>SELECT</database> statement may contain named SQL parameters,
                like in <quote><code>select name || :sfx from names where number =
                :num</code></quote>. Each parameter must be a PSQL variable that has been declared
                previously (this includes any in/out params of the PSQL module).</para>
              </listitem>
              <listitem>
                <para>Caution! If the value of a PSQL variable that is used in the
                <database>SELECT</database> statement changes during execution of the loop, the
                statement <emphasis>may</emphasis> (but will not always) be re-evaluated for the
                remaining rows. In general, this situation should be avoided. If you really need
                this behaviour, test your code thoroughly and make sure you know how variable
                changes affect the outcome. Also be advised that the behaviour may depend on the
                query plan, in particular the use of indices. And as it is currently not strictly
                defined, it may also change in some future version of Firebird.</para>
                <!--I have noticed that the statement is NOT re-avaluated if an index is used, and IS re-evaluated if no index is used.
Adding PLAN (T NATURAL) to a certain query forced re-evaluation and thus altered the outcome.
But I don't know if this is always the case, and if the use of an index is the only factor.-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>create procedure shownums
  returns (aa int, bb int, sm int, df int)
as
begin
  for select distinct a, b from numbers order by a, b
    into :aa, :bb
  do
  begin
    sm = aa + bb;
    df = aa - bb;
    suspend;
  end
end</programlisting>
            <programlisting>create procedure relfields
  returns (relation char(32), pos int, field char(32))
as
begin
  for select rdb$relation_name from rdb$relations
      into :relation
  do
  begin
    for select rdb$field_position + 1, rdb$field_name
        from rdb$relation_fields
        where rdb$relation_name = :relation
        order by rdb$field_position
        into :pos, :field
    do
    begin
      if (pos = 2) then relation = '  "';   -- for nicer output
      suspend;
    end
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd25-psql-forselect-ascursor">
        <title><database>AS CURSOR</database> clause</title>
        <formalpara>
          <title>Available in</title>
          <para>PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The optional <database>AS CURSOR</database> clause creates a named cursor that can
          be referenced (after <link linkend="langrefupd25-psql-wherecurrentof"><database>WHERE
          CURRENT OF</database></link>) within the <database>FOR SELECT</database> loop in order to
          update or delete the current row. This feature was already added in InterBase, but not
          mentioned in the <citetitle>Language Reference</citetitle>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure deltown (towntodelete varchar(24))
  returns (town varchar(24), pop int)
as
begin
  for select town, pop from towns into :town, :pop as cursor tcur do
  begin
    if (town = towntodelete)
      then delete from towns where current of tcur;
      else suspend;
  end
end</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>A <quote><database>FOR UPDATE</database></quote> clause is allowed in the
                <database>SELECT</database> statement., but not required for a positioned update or
                delete to succeed.</para>
              </listitem>
              <listitem>
                <para>Make sure that cursor names defined here do not clash with any names created
                earlier on in <link linkend="langrefupd25-psql-declare-cursor"><database>DECLARE
                CURSOR</database></link> statements.</para>
              </listitem>
              <listitem>
                <para><database>AS CURSOR</database> is not supported in <database>FOR EXECUTE
                STATEMENT</database> loops, even if the statement to execute is a suitable
                <database>SELECT</database> query.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-psql-autonomous-trans">
      <title><database>IN AUTONOMOUS TRANSACTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Code running in an autonomous transaction will be committed immediately upon
        successful completion, regardless of how the parent transaction finishes. This is useful if
        you want to make sure that certain actions will not be rolled back, even if an error is
        raised later.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>IN AUTONOMOUS TRANSACTION DO <replaceable>&lt;psql-statement&gt;</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger tr_connect on connect
as
begin
  -- make sure log message is always preserved:
  in autonomous transaction do
    insert into log (msg) values ('User ' || current_user || ' connects.');
  if (current_user in (select username from blocked_users)) then
  begin
    -- again, log message must be preserved and event posted, so:
    in autonomous transaction do
    begin
      insert into log (msg) values ('User ' || current_user || ' refused.');
      post_event 'Connection attempt by blocked user.';
    end
    -- now we can safely except:
    exception ex_baduser;
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Autonomous transactions have the same isolation level as their parent
              transaction.</para>
            </listitem>
            <listitem>
              <para>Because the autonomous transaction is completely independent of its parent, care
              must be taken to avoid deadlocks.</para>
            </listitem>
            <listitem>
              <para>If an exception occurs <emphasis>within</emphasis> the autonomous transaction,
              the work will be rolled back.</para>
              <!--An exception, or an UNCAUGHT exception?-->
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-leave">
      <title><database>LEAVE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>LEAVE</database> immediately terminates the innermost
        <database>WHILE</database> or <database>FOR</database> loop. With the optional
        <replaceable>label</replaceable> argument introduced in Firebird 2.0,
        <database>LEAVE</database> can break out of surrounding loops as well. Execution continues
        with the first statement after the outermost terminated loop.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>[<replaceable>label</replaceable>:]
{FOR | WHILE} ... DO
   ...
   (possibly nested loops, with or without labels)
   ...
   LEAVE [<replaceable>label</replaceable>];</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <para>If an error occurs during the insert in the example below, the event is logged and
            the loop terminated. The program continues at the line of code reading <quote><literal>c
            = 0;</literal></quote></para>
            <programlisting>while (b &lt; 10) do
begin
  insert into Numbers(B) values (:b);
  b = b + 1;
  when any do
  begin
    execute procedure log_error (current_timestamp, 'Error in B loop');
    <emphasis role="bold">leave;</emphasis>
  end
end
c = 0;</programlisting>
            <para>The next example uses labels. <quote><code>Leave LoopA</code></quote> terminates
            the outer loop, <quote><code>leave LoopB</code></quote> the inner loop. Notice that a
            plain <quote><code>leave</code></quote> would also suffice to terminate the inner
            loop.</para>
            <programlisting>stmt1 = 'select Name from Farms';
<emphasis role="bold">LoopA:</emphasis>
for execute statement :stmt1 into :farm do
begin
  stmt2 = 'select Name from Animals where Farm = ''';
  <emphasis role="bold">LoopB:</emphasis>
  for execute statement :stmt2 || :farm || '''' into :animal do
  begin
    if  (animal = 'Fluffy') then <emphasis role="bold">leave LoopB</emphasis>;
    else if (animal = farm) then <emphasis role="bold">leave LoopA</emphasis>;
    else suspend;
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-open-cursor">
      <title><database>OPEN</database> cursor</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Opens a previously declared cursor, executing its <database>SELECT</database>
        statement and enabling it to fetch records from the result set.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>OPEN <replaceable>cursorname</replaceable>;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para>See <link linkend="langrefupd25-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-plan">
      <title><database>PLAN</database> allowed in trigger code</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would
        be rejected by the compiler. Now a valid plan can be included and will be used.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-subquery-as-expr">
      <title>Subqueries as PSQL expressions</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Previously, subqueries could not be used as value expressions in PSQL, even if they
        returned a single value. This made it necessary to use <database>SELECT ... INTO</database>,
        often assigning the result to a variable that wouldn't have been necessary otherwise.
        Firebird 2.5 and up support the direct use of scalar subqueries as if they were simple value
        expressions.</para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>Constructions like the following are now valid PSQL:</para>
            <programlisting>var = (select ... from ...);

if ((select ... from ...) = 1) then ...

if (1 = any (select ... from ...)) then ...

if (1 in (select ... from ...)) then ...</programlisting>
            <para>Of course, in the first two examples you have to be sure that the
            <database>SELECT</database> doesn't return multiple rows!</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-psql-udf-as-proc">
      <title>UDFs callable as void functions</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 2.0 and above, PSQL code may call UDFs without assigning the result value,
        i.e. like a Pascal procedure or C void function. In most cases this is senseless, because
        the main purpose of almost every UDF is to produce the result value. Some functions however
        perform a specific task, and if you're not interested in the result value you can now spare
        yourself the trouble of assigning it to a dummy variable.<!--Also possible in DSQL? No. And ESQL? Asked Dmitry, but he forgot to answer that one.--></para>
      </formalpara>
      <note>
        <para><link
        linkend="langrefupd25-intfunc-get_context"><function>RDB$GET_CONTEXT</function></link> and
        <link
        linkend="langrefupd25-intfunc-set_context"><function>RDB$SET_CONTEXT</function></link>,
        though classified in this guide under internal functions, are actually a kind of
        auto-declared UDFs. You may therefore call them without catching the result. Of course this
        only makes sense for <function>RDB$SET_CONTEXT</function>.</para>
      </note>
    </section>
    <section id="langrefupd25-psql-wherecurrentof">
      <title><database>WHERE CURRENT OF</database> valid again for view cursors</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0, 2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Because of possible reliability issues, Firebird 2.0 disallowed <database>WHERE
        CURRENT OF</database> for view cursors. In Firebird 2.1, with its improved view validation
        logic, this restriction has been lifted.</para>
        <!--Find out if this also goes for DSQL and/or ESQL !

Also ask Dmitry whether WCO is unreliable in 1.x for view cursors. If yes, add warning to 1.5 version.-->
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd25-security">
    <title>Security and access control</title>
    <section id="langrefupd25-security-alter-role">
      <title><database>ALTER ROLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Currently, <database>ALTER ROLE</database>'s only purpose is to control the automatic
        mapping of the <database>RDB$ADMIN</database> role to Windows administrators. For a full
        discussion, see <link
        linkend="langrefupd25-security-rdbadmin"><database>RDB$ADMIN</database></link> and <link
        linkend="langrefupd25-security-auto-admin-mapping"><database>AUTO ADMIN
        MAPPING</database></link>.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ALTER ROLE RDB$ADMIN {SET|DROP} AUTO ADMIN MAPPING</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-security-grant-revoke">
      <title><database>GRANT</database> and <database>REVOKE</database></title>
      <section id="langrefupd25-security-grantedby">
        <title><database>GRANTED BY</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>When a privilege is granted, it is normally stored in the database with the current
          user as the grantor. With the <database>GRANTED BY</database> clause, the user who grants
          the privilege can have someone else registered as the grantor. When <database>GRANTED
          BY</database> is used with <database>REVOKE</database>, the privilege (registered as)
          granted by the named user will be removed. To make migration from certain other RDBMSes
          easier, the non-standard <database>AS</database> is supported as a synonym of
          <database>GRANTED BY</database>.</para>
        </formalpara>
        <formalpara>
          <title>Access</title>
          <para>Use of the <database>GRANTED BY</database> clause is reserved to:<itemizedlist
              spacing="compact">
              <listitem>
                <para>The database owner;</para>
              </listitem>
              <listitem>
                <para><database>SYSDBA</database>;</para>
              </listitem>
              <listitem>
                <para>anybody who has the <link
                linkend="langrefupd25-security-rdbadmin"><database>RDB$ADMIN</database></link> role
                in the database and specified it while connecting;</para>
              </listitem>
              <listitem>
                <para>if <link linkend="langrefupd25-security-auto-admin-mapping"><database>AUTO
                ADMIN MAPPING</database></link> is on for the database: any Windows administrator
                who connected to the database using trusted authentication without specifying a
                role.</para>
              </listitem>
            </itemizedlist>Even the owner of the role can't use <database>GRANTED BY</database> if
          he isn't in the above list.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>GRANT
   {<replaceable>&lt;privileges&gt;</replaceable> ON <replaceable>&lt;object&gt;</replaceable> | <replaceable>role</replaceable>}
   TO <replaceable>&lt;grantees&gt;</replaceable>
   [WITH {GRANT|ADMIN} OPTION]
   [{GRANTED BY | AS} [USER] <replaceable>grantor</replaceable>]</programlisting>
              <programlisting>REVOKE
   [{GRANT|ADMIN} OPTION FOR]
   {<replaceable>&lt;privileges&gt;</replaceable> ON <replaceable>&lt;object&gt;</replaceable> | <replaceable>role</replaceable>}
   FROM <replaceable>&lt;grantees&gt;</replaceable>
   [{GRANTED BY | AS} [USER] <replaceable>grantor</replaceable>]</programlisting>
              <para>(These are not the complete <database>GRANT</database> and
              <database>REVOKE</database> syntaxes, but they are complete as far as
              <database>GRANTED BY</database> is concerned.)</para>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>-- connected as database owner BOB:

create role digger;
grant digger to francis;
grant digger to fred;
grant digger to frank with admin option granted by fritz;
commit;

revoke digger from fred;
-- OK
revoke admin option for digger from frank;
-- error: "BOB is not grantor of Role on DIGGER to FRANK."
revoke admin option for digger from frank granted by fritz;
-- OK
revoke digger from frank
-- error: "BOB is not grantor of Role on DIGGER to FRANK."
commit;

-- exit BOB, enter FRITZ:

revoke digger from frank;
-- OK
revoke digger from francis;
-- error: "FRITZ is not grantor of Role on DIGGER to FRANCIS."
revoke digger from francis granted by bob;
-- error: "Only SYSDBA or database owner can use GRANTED BY clause"
commit;</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Note</title>
          <para>Please notice that a <database>GRANT</database> or <database>ADMIN</database> option
          is just a flag in the privilege record; it does not have a separate grantor. So this
          line:<blockquote>
              <para><programlisting>grant digger to frank with admin option granted by fritz</programlisting><!--No vertical whitespace here in PDF! Fix XSLT!--></para>
            </blockquote>does not mean <quote>Grant digger to Frank, and grant the admin option in
          Fritz's name</quote>, but <quote>Grant digger to Frank with admin option – all in Fritz's
          name</quote>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-security-revoke-all-on-all">
        <title><database>REVOKE ALL ON ALL</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL?-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Revokes all privileges (including role memberships) on all objects from one or more
          users and/or roles. This is a quick way to <quote>clean up</quote> when a user has left
          the system or must be locked out of the database.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>REVOKE ALL ON ALL FROM <replaceable>&lt;grantee&gt;</replaceable> [, <replaceable>&lt;grantee&gt;</replaceable> ...]

<replaceable>&lt;grantee&gt;</replaceable>  ::=  [USER] <replaceable>username</replaceable> | [ROLE] <replaceable>rolename</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>revoke all on all from buddy, peggy, sue</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>When invoked by a privileged user (the database owner,
                <database>SYSDBA</database> or anyone whose <database>CURRENT_ROLE</database> is
                <database>RDB$ADMIN</database>), all privileges are removed regardless of the
                grantor. Otherwise, only those privileges granted by the current user are
                removed.</para>
              </listitem>
              <listitem>
                <para>The <database>GRANTED BY</database> clause is not supported.</para>
              </listitem>
              <listitem>
                <para>This statement cannot be used to revoke privileges from stored procedure,
                trigger or view grantees. (Privileges ON such objects are removed, of
                course.)</para>
              </listitem>
              <!--Username may be PUBLIC.
However, this will deny him SELECT access to RDB$FORMATS, RDB$PAGES and RDB$ROLES. Is that bad?-->
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd25-security-revoke-admin-option">
        <title><database>REVOKE ADMIN OPTION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: No support found in sources. Even the older WITH ADMIN OPTION is not supported.-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Revokes a previously granted admin option (the right to pass on a granted role to
          others) from the grantee, without revoking the role itself. Multiple roles and/or multiple
          grantees can be handled in one statement.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>REVOKE ADMIN OPTION FOR <replaceable>&lt;role-list&gt;</replaceable> FROM <replaceable>&lt;grantee-list&gt;</replaceable>

<replaceable>&lt;role-list&gt;</replaceable>     ::=  <replaceable>role</replaceable> [, <replaceable>role</replaceable> ...]
<replaceable>&lt;grantee-list&gt;</replaceable>  ::=  [USER] <replaceable>&lt;grantee&gt;</replaceable> [, [USER] <replaceable>&lt;grantee&gt;</replaceable> ...]
<replaceable>&lt;grantee&gt;</replaceable>       ::=  <replaceable>username</replaceable> | PUBLIC</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>revoke admin option for manager from john, paul, george, ringo</programlisting>
            </blockquote></para>
        </formalpara>
        <para>If a user has received the admin option from several grantors, each of those grantors
        must revoke it or the user will still be able to grant the role(s) in question to
        others.</para>
      </section>
    </section>
    <section id="langrefupd25-security-rdbadmin">
      <title>The <database>RDB$ADMIN</database> role</title>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Firebird 2.5 introduces the <database>RDB$ADMIN</database> system role, which is
        predefined in every database. Granting someone the <database>RDB$ADMIN</database> role in a
        database gives him or her <database>SYSDBA</database> rights <emphasis>in that database
        only</emphasis>. In a normal database, this means full control over all objects. In the
        security database, it means the ability to create, alter and drop user accounts. In both
        cases, the grantee can always pass the role on to others. In other words,
        <quote><database>WITH ADMIN OPTION</database></quote> is built in and need not be
        specified.</para>
      </formalpara>
      <section id="langrefupd25-security-rdbadmin-normaldb">
        <title>In normal databases</title>
        <section id="langrefupd25-security-rdbadmin-normaldb-granting">
          <title>Granting the <database>RDB$ADMIN</database> role in a normal database</title>
          <para>In a regular database, the <database>RDB$ADMIN</database> role can be granted and
          revoked with the usual syntax:</para>
          <blockquote>
            <programlisting>GRANT RDB$ADMIN TO <replaceable>username</replaceable>
REVOKE RDB$ADMIN FROM <replaceable>username</replaceable></programlisting>
          </blockquote>
          <para>Grantors can be:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>The database owner;</para>
            </listitem>
            <listitem>
              <para><database>SYSDBA</database>;</para>
            </listitem>
            <listitem>
              <para>anybody who has the <database>RDB$ADMIN</database> role in the database and
              specified it while connecting;</para>
            </listitem>
            <listitem>
              <para>if <link linkend="langrefupd25-security-auto-admin-mapping"><database>AUTO ADMIN
              MAPPING</database></link> is on for the database: any Windows administrator who
              connected to the database using trusted authentication without specifying a
              role.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="langrefupd25-security-rdbadmin-normaldb-using">
          <title>Using the <database>RDB$ADMIN</database> role in a normal database</title>
          <para>To make use of his <database>RDB$ADMIN</database> privileges, the grantee simply
          specifies the role when connecting to the database.</para>
          <!--Oddly enough, Windows administrators who have been granted this role also get it as current role if they
don't specify it (even if AUTO ADMIN MAPPING is off). See fb-devel 24-12-2010. Enter into tracker!-->
        </section>
      </section>
      <section id="langrefupd25-security-rdbadmin-secdb">
        <title>In the security database</title>
        <section id="langrefupd25-security-rdbadmin-secdb-granting">
          <title>Granting the <database>RDB$ADMIN</database> role in the security database</title>
          <para>Since nobody can connect to the security database, the <database>GRANT</database>
          and <database>REVOKE</database> statements cannot be used here. Instead, the
          <database>RDB$ADMIN</database> role is granted and revoked with the new <link
          linkend="langrefupd25-security-sql-user-mgmt">SQL user management commands</link>:</para>
          <blockquote>
            <programlisting>CREATE USER <replaceable>newuser</replaceable> PASSWORD '<replaceable>password</replaceable>' GRANT ADMIN ROLE
ALTER USER <replaceable>existinguser</replaceable> GRANT ADMIN ROLE
ALTER USER <replaceable>existinguser</replaceable> REVOKE ADMIN ROLE</programlisting>
          </blockquote>
          <para>Please notice that <database>GRANT ADMIN ROLE</database> and <database>REVOKE ADMIN
          ROLE</database> are not <database>GRANT</database> and <database>REVOKE</database>
          statements. They are three-word parameters to <database>CREATE</database> and
          <database>ALTER</database> <database>USER</database>.</para>
          <para>Alternatively, <application>gsec</application> can be used with the
          <parameter>-admin</parameter> parameter:</para>
          <blockquote>
            <programlisting>gsec -add <replaceable>newuser</replaceable> -pw <replaceable>password</replaceable> -admin yes
gsec -mo <replaceable>existinguser</replaceable> -admin yes
gsec -mo <replaceable>existinguser</replaceable> -admin no</programlisting>
          </blockquote>
          <para>Depending on the situation, more parameters may be needed when invoking gsec, e.g.
          <parameter>-user</parameter> and <parameter>-pass</parameter>, or
          <parameter>-trusted</parameter>.</para>
          <para>Grantors can be:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para><database>SYSDBA</database>;</para>
            </listitem>
            <listitem>
              <para>anybody who has the <database>RDB$ADMIN</database> role in the security database
              and specified it while connecting (or while invoking
              <application>gsec</application>);</para>
            </listitem>
            <listitem>
              <para>if <link linkend="langrefupd25-security-auto-admin-mapping"><database>AUTO ADMIN
              MAPPING</database></link> is on for the security database: any Windows administrator
              who connected (or invoked <application>gsec</application>) using trusted
              authentication without specifying a role.</para>
            </listitem>
          </itemizedlist>
          <!--Is it correct that windows accounts can not individually be granted the RDB$ADMIN role in the security database,
and shouldn't we make this possible?-->
        </section>
        <section id="langrefupd25-security-rdbadmin-secdb-using">
          <title>Using the <database>RDB$ADMIN</database> role in the security database</title>
          <para>To manage user accounts through SQL, the grantee must specify the
          <database>RDB$ADMIN</database> role when connecting. But this poses a problem, because
          nobody can connect to the security database. The solution is that the user connects to
          another – regular – database where he also has <database>RDB$ADMIN</database> rights. He
          specifies the role when connecting to the regular database, and can then give any SQL user
          management command. It's not the most elegant of solutions, but it is the only way. If
          there isn't a regular database where the grantee has the <database>RDB$ADMIN</database>
          role, the SQL route is blocked.</para>
          <para>To perform user management with <application>gsec</application>, the grantee must
          provide the extra parameter <parameter>-role</parameter>
          <parameter>rdb$admin</parameter>.</para>
        </section>
      </section>
    </section>
    <section id="langrefupd25-security-auto-admin-mapping">
      <title><database>AUTO ADMIN MAPPING</database></title>
      <formalpara>
        <title>Platform</title>
        <para>Windows only</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 2.1, Windows administrators would automatically receive
        <database>SYSDBA</database> privileges if they used trusted authentication to connect to the
        server. In Firebird 2.5, this is no longer the case. Whether administrators have automatic
        <database>SYSDBA</database> rights now depends on the setting of <database>AUTO ADMIN
        MAPPING</database>. This is a per-database switch which is off by default. If <database>AUTO
        ADMIN MAPPING</database> is on, it will take effect whenever a Windows administrator: a)
        connects using trusted authentication, and b) does <emphasis>not</emphasis> specify any role
        when connecting. After a successful <quote>auto admin</quote> connect, the current role is
        set to <link
        linkend="langrefupd25-security-rdbadmin"><database>RDB$ADMIN</database></link>.</para>
      </formalpara>
      <section id="langrefupd25-security-auto-admin-mapping-normaldb">
        <title>In normal databases</title>
        <para>To turn the automatic mapping on and off in a regular database:</para>
        <blockquote>
          <programlisting>ALTER ROLE RDB$ADMIN SET AUTO ADMIN MAPPING
ALTER ROLE RDB$ADMIN DROP AUTO ADMIN MAPPING</programlisting>
        </blockquote>
        <para>These statements must be issued by a user with sufficient rights, that is:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>The database owner;</para>
          </listitem>
          <listitem>
            <para><database>SYSDBA</database>;</para>
          </listitem>
          <listitem>
            <para>anybody who has the <database>RDB$ADMIN</database> role in the database and
            specified it while connecting;</para>
          </listitem>
          <listitem>
            <para>if <database>AUTO ADMIN MAPPING</database> is on for the database: any Windows
            administrator who connected to the database using trusted authentication without
            specifying a role.</para>
          </listitem>
        </itemizedlist>
        <para>In normal databases, the status of <database>AUTO ADMIN MAPPING</database> is checked
        at connect time only. If an administrator has the <database>RDB$ADMIN</database> role
        because the mapping was on when he connected, he will keep that role for the duration of the
        connection, even if he or someone else turns off the mapping in the meantime. Likewise,
        setting <database>AUTO ADMIN MAPPING</database> on will not change the current role to
        <database>RDB$ADMIN</database> for administrators who were already connected.</para>
      </section>
      <section id="langrefupd25-security-auto-admin-mapping-secdb">
        <title>In the security database</title>
        <para>There are no SQL statements to turn the automatic mapping on and off in the security
        database. Instead, <application>gsec</application> must be used:</para>
        <blockquote>
          <programlisting>gsec -mapping set
gsec -mapping drop</programlisting>
        </blockquote>
        <para>Depending on the situation, more parameters may be needed when invoking gsec, e.g.
        <parameter>-user</parameter> and <parameter>-pass</parameter>, or
        <parameter>-trusted</parameter>.</para>
        <para>These commands can be given by:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><database>SYSDBA</database>;</para>
          </listitem>
          <listitem>
            <para>if <database>AUTO ADMIN MAPPING</database> is on for the security database: any
            Windows administrator who invokes <application>gsec</application> using trusted
            authentication without specifying a role.</para>
          </listitem>
        </itemizedlist>
        <para>Unlike the case with regular databases, users connecting with the
        <database>RDB$ADMIN</database> role cannot turn <database>AUTO ADMIN MAPPING</database> on
        or off in the security database. Also notice that the Windows administrator in the second
        listitem can only turn the mapping <emphasis>off</emphasis>. In doing so, he shuts off the
        very mechanism that gave him access in the first place, so he won't be able to turn it back
        on again. (Even in an interactive <application>gsec</application> session, the new setting
        takes effect immediately.)</para>
        <!--The fact that RDB$ADMIN'ers can not do this: is it on purpose and if so: why?-->
      </section>
    </section>
    <section id="langrefupd25-security-sql-user-mgmt">
      <title>SQL user management commands</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Firebird 2.5 and up provide SQL statements for user account management. Except in one
        case, they are only available to the following privileged users:<itemizedlist
            spacing="compact">
            <listitem>
              <para><database>SYSDBA</database>;</para>
            </listitem>
            <listitem>
              <para>Any user who has been granted the <link
              linkend="langrefupd25-security-rdbadmin"><database>RDB$ADMIN</database></link> role in
              the security database and at least one other database. The user must specify the role
              when connecting to the database.</para>
            </listitem>
            <listitem>
              <para>If <link linkend="langrefupd25-security-auto-admin-mapping"><database>AUTO ADMIN
              MAPPING</database></link> is on for the security database: any Windows administrator
              connected to any database using trusted authentication without specifying a role.
              Whether <database>AUTO ADMIN MAPPING is on in the connection database is
              unimportant.</database><!--This is not entirely true: if the admin is also an explicit grantee of the RDB$ADMIN role in the connection database,
and he specifies that role when connecting, he can use the statements.

BTW, I think that a role in the connection database should not block secbase privileges at all!--></para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <para>Non-privileged users can only use <database>ALTER USER</database>, to change their own
      account details.</para>
      <section id="langrefupd25-security-create-user">
        <title><database>CREATE USER</database></title>
        <formalpara>
          <title>Description</title>
          <para>Creates a Firebird user account.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CREATE USER <replaceable>username</replaceable> PASSWORD '<replaceable>password</replaceable>'
   [FIRSTNAME '<replaceable>firstname</replaceable>']
   [MIDDLENAME '<replaceable>middlename</replaceable>']
   [LASTNAME '<replaceable>lastname</replaceable>']
   [GRANT ADMIN ROLE]</programlisting>
              <para><database>GRANT ADMIN ROLE</database> gives the new user the
              <database>RDB$ADMIN</database> role in the security database. This allows him to
              manage user accounts, but doesn't give him any special privileges in regular
              databases. For more infomation, see <link
              linkend="langrefupd25-security-rdbadmin"><citetitle>The <database>RDB$ADMIN</database>
              role</citetitle></link>.</para>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>create user bigshot password 'buckshot'
create user john password 'fYe_3Ksw' firstname 'John' lastname 'Doe'
create user mary password 'lamb_chop' firstname 'Mary' grant admin role</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-security-alter-user">
        <title><database>ALTER USER</database></title>
        <formalpara>
          <title>Description</title>
          <para>Alters details of a Firebird user account. This is the only account management
          statement that can also be used by non-privileged users, in order to change their own
          account details.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER USER <replaceable>username</replaceable>
   [PASSWORD '<replaceable>password</replaceable>']
   [FIRSTNAME '<replaceable>firstname</replaceable>']
   [MIDDLENAME '<replaceable>middlename</replaceable>']
   [LASTNAME '<replaceable>lastname</replaceable>']
   [{GRANT|REVOKE} ADMIN ROLE]

-- At least one of the optional parameters must be present.
-- GRANT/REVOKE ADMIN ROLE is reserved to privileged users.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>alter user bobby password '67-UiT_G8' grant admin role
alter user dan firstname 'No_Jack' lastname 'Kennedy'
alter user dumbbell revoke admin role</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd25-security-drop-user">
        <title><database>DROP USER</database></title>
        <formalpara>
          <title>Description</title>
          <para>Removes a Firebird user account.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DROP USER <replaceable>username</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>drop user timmy</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd25-variables">
    <title>Context variables</title>
    <section id="langrefupd25-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_CONNECTION</varname> contains the unique identifier of the current
        connection.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page
      and reset to 0 upon restore. Since version 2.1, it is incremented upon every new connection.
      (In previous versions, it was only incremented if the client read it during a session.) As a
      result, <varname>CURRENT_CONNECTION</varname> now indicates the number of connections since
      the creation – or most recent restoration – of the database.</para>
    </section>
    <section id="langrefupd25-current_role">
      <title><varname>CURRENT_ROLE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the
        currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is
        <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><varname>CURRENT_ROLE</varname> always represents a valid role or
      <database>NONE</database>. If a user connects with a non-existing role, the engine silently
      resets it to <database>NONE</database> without returning an error.</para>
    </section>
    <section id="langrefupd25-current_time">
      <title><varname>CURRENT_TIME</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIME</varname> returns the current server time. In versions prior to
        2.0, the fractional part used to be always <quote><literal>.0000</literal></quote>, giving
        an effective precision of 0 decimals. From Firebird 2.0 onward you can specify a precision
        when polling this variable. The default is still 0 decimals, i.e. seconds precision.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIME</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIME [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_time from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select current_time(2) from rdb$database
-- returns e.g. 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Unlike <varname>CURRENT_TIME</varname>, the default precision of
              <varname>CURRENT_TIMESTAMP</varname> has changed to 3 decimals. As a result,
              <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum of
              <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIME</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL – e.g.
              to measure time intervals – use <link
              linkend="langrefupd25-now"><literal>'NOW'</literal></link> with a full cast (not
              shorthand syntax).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-current_timestamp">
      <title><varname>CURRENT_TIMESTAMP</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIMESTAMP</varname> returns the current server date and time. In
        versions prior to 2.0, the fractional part used to be always
        <quote><literal>.0000</literal></quote>, giving an effective precision of 0 decimals. From
        Firebird 2.0 onward you can specify a precision when polling this variable. The default is 3
        decimals, i.e. milliseconds precision.<!--This new functionality also available in ESQL? Dimtry says about the new ms precision:
"I believe it should be supported automagically." About the precision arg: "Not supported."--></para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIMESTAMP [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_timestamp from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <programlisting>select current_timestamp(2) from rdb$database
-- returns e.g. 2008-08-13 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The default precision of <varname>CURRENT_TIME</varname> is still 0 decimals, so
              in Firebird 2.0 and up <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum
              of <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIMESTAMP</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL – e.g.
              to measure time intervals – use <link
              linkend="langrefupd25-now"><literal>'NOW'</literal></link> with a full cast (not
              shorthand syntax).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TRANSACTION</varname> contains the unique identifier of the current
        transaction.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header
      page and reset to 0 upon restore. It is incremented with every new transaction.</para>
    </section>
    <section id="langrefupd25-current_user">
      <title><varname>CURRENT_USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1 -> CHECK!--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <database>USER</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-deleting">
      <title><varname>DELETING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired
        because of a <database>DELETE</database> operation. Intended for use in <link
        linkend="langrefupd25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-gdscode">
      <title><varname>GDSCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>GDSCODE</varname> context variable contains the numerical representation of the
        current Firebird error code. Prior to Firebird 2.0, <varname>GDSCODE</varname> was only set
        in <database>WHEN GDSCODE</database> handlers. Now it may also be non-zero in <database>WHEN
        ANY</database>, <database>WHEN SQLCODE</database> and <database>WHEN EXCEPTION</database>
        blocks, provided that the condition raising the error corresponds with a Firebird error
        code. Outside error handlers, <varname>GDSCODE</varname> is always 0. Outside PSQL it
        doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when gdscode grant_obj_notfound, gdscode grant_fld_notfound,
     gdscode grant_nopriv, gdscode grant_nopriv_on_base
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Please notice: After <database>WHEN GDSCODE</database>, you must use symbolic names like
      <errorcode>grant_obj_notfound</errorcode> etc. But the <varname>GDSCODE</varname> context
      variable is an <database>INTEGER</database>. If you want to compare it against a certain
      error, you have to use the numeric value, e.g. 335544551 for
      <errorcode>grant_obj_notfound</errorcode>.</para>
    </section>
    <section id="langrefupd25-inserting">
      <title><varname>INSERTING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger
        fired because of an <database>INSERT</database> operation. Intended for use in <link
        linkend="langrefupd25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-new">
      <title><varname>NEW</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>NEW</varname> contains the new version of a database record that has just
        been inserted or updated. Starting with Firebird 2.0 it is read-only in
        <database>AFTER</database> triggers.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>NEW</varname> is
        always available. But if the trigger is fired by a <database>DELETE</database>, there will
        be no new version of the record. In that situation, reading from <varname>NEW</varname> will
        always return <constant>NULL</constant>; writing to it will cause a runtime
        exception.</para>
      </note>
    </section>
    <section id="langrefupd25-now">
      <title><literal>'NOW'</literal></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><literal>'NOW'</literal> is not a variable but a string literal. It is, however,
        special in the sense that when you <database>CAST()</database> it to a date/time type, you
        will get the current date and/or time. The fractional part of the time used to be always
        <quote><literal>.0000</literal></quote>, giving an effective seconds precision. Since
        Firebird 2.0 the precision is 3 decimals, i.e. milliseconds. <literal>'NOW'</literal> is
        case-insensitive, and the engine ignores leading or trailing spaces when casting.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(3)</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select 'Now' from rdb$database
-- returns 'Now'</programlisting>
            <programlisting>select cast('Now' as date) from rdb$database
-- returns e.g. 2008-08-13</programlisting>
            <programlisting>select cast('now' as time) from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select cast('NOW' as timestamp) from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <para><link linkend="langrefupd25-shorthandcast">Shorthand syntax</link> for the last
            three statements:</para>
            <programlisting>select date 'Now' from rdb$database
select time 'now' from rdb$database
select timestamp 'NOW' from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>When used with <database>CAST()</database>, <literal>'NOW'</literal> always
              returns the actual date/time, even in PSQL modules, where
              <varname>CURRENT_DATE</varname>, <link
              linkend="langrefupd25-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langrefupd25-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              return the same value throughout the duration of the outermost routine. This makes
              <literal>'NOW'</literal> useful for measuring time intervals in triggers, procedures
              and executable blocks.</para>
            </listitem>
            <listitem>
              <para>When used with the shorthand syntax, <literal>'NOW'</literal> is evaluated at
              parse time and the value is frozen for as long as the statement stays prepared – even
              across multiple executions of the prepared statement! This is something to be aware
              of.</para>
            </listitem>
            <listitem>
              <para>Unless you really need progressing values in PSQL, or frozen values during
              multiple executions, reading <varname>CURRENT_DATE</varname>,
              <varname>CURRENT_TIME</varname> and <varname>CURRENT_TIMESTAMP</varname> is generally
              preferable to using <literal>'NOW'</literal>. Be aware though that
              <varname>CURRENT_TIME</varname> defaults to seconds precision; to get milliseconds
              precision, use <varname>CURRENT_TIME</varname>(<parameter>3</parameter>).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-old">
      <title><varname>OLD</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>OLD</varname> contains the existing version of a database record just before
        a deletion or update. Starting with Firebird 2.0 it is read-only.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>OLD</varname> is
        always available. But if the trigger is fired by an <database>INSERT</database>, there is
        obviously no pre-existing version of the record. In that situation, reading from
        <varname>OLD</varname> will always return <constant>NULL</constant>; writing to it will
        cause a runtime exception.</para>
      </note>
    </section>
    <section id="langrefupd25-row_count">
      <title><varname>ROW_COUNT</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <varname>ROW_COUNT</varname> context variable contains the number of rows affected
        by the most recent DML statement (<database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database>, <database>SELECT</database> or <database>FETCH</database>) in
        the current trigger, stored procedure or executable block.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Behaviour with <database>SELECT</database> and <database>FETCH<!--Better make this a table!--></database></title>
        <para><itemizedlist>
            <listitem>
              <para>After a singleton <database>SELECT</database>, <varname>ROW_COUNT</varname> is 1
              if a data row was retrieved and 0 otherwise.</para>
            </listitem>
            <listitem>
              <para>In a <database>FOR SELECT</database> loop, <varname>ROW_COUNT</varname> is
              incremented with every iteration (starting at 0 before the first).</para>
            </listitem>
            <listitem>
              <para>After a <database>FETCH</database> from a cursor, <varname>ROW_COUNT</varname>
              is 1 if a data row was retrieved and 0 otherwise. Fetching more records from the same
              cursor does <emphasis>not</emphasis> increment <varname>ROW_COUNT</varname> beyond
              1.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.<replaceable>x</replaceable>, <varname>ROW_COUNT</varname> is 0
              after any type of <database>SELECT</database> statement.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <note>
        <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows affected
        by an <database>EXECUTE STATEMENT</database> or <database>EXECUTE PROCEDURE
        </database>command.</para>
      </note>
    </section>
    <section id="langrefupd25-sqlcode">
      <title><varname>SQLCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Deprecated in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>SQLCODE</varname> context variable contains the current SQL error code. Prior to
        Firebird 2.0, <varname>SQLCODE</varname> was only set in <database>WHEN SQLCODE</database>
        and <database>WHEN ANY</database> handlers. Now it may also be non-zero in <database>WHEN
        GDSCODE</database> and <database>WHEN EXCEPTION</database> blocks, provided that the
        condition raising the error corresponds with an SQL error code. Outside error handlers,
        <varname>SQLCODE</varname> is always 0. Outside PSQL it doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Important notice</title>
        <para><varname>SQLCODE</varname> is now deprecated in favour of the SQL-2003-compliant <link
        linkend="langrefupd25-sqlstate"><citetitle><varname>SQLSTATE</varname></citetitle></link>
        status code. Support for <varname>SQLCODE</varname> and <database>WHEN SQLCODE</database>
        will be discontinued in some future version of Firebird.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-sqlstate">
      <title><varname>SQLSTATE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handler, the
        <varname>SQLSTATE</varname> context variable contains the 5-character, SQL-2003-compliant
        status code resulting from the statement that raised the error. Outside error handlers,
        <varname>SQLSTATE</varname> is always '00000'. Outside PSQL it is not available at
        all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  Msg = case sqlstate
          when '22003' then 'Numeric value out of range.'
          when '22012' then 'Division by zero.'
          when '23000' then 'Integrity constraint violation.'
          else 'Something bad happened! SQLSTATE = ' || sqlstate
        end;  
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><database>SQLSTATE</database> is destined to replace
              <database>SQLCODE</database>. The latter is now deprecated in Firebird and will
              disappear in some future version.</para>
            </listitem>
            <listitem>
              <para>Firebird does not (yet) support the syntax <quote><database>WHEN SQLSTATE ...
              DO</database></quote>. You have to use <database>WHEN ANY</database> and test the
              <varname>SQLSTATE</varname> variable within the handler.</para>
              <!--Request for improvement CORE-3526-->
            </listitem>
            <listitem>
              <para>Each <database>SQLSTATE</database> code is the concatenation of a 2-character
              class and a 3-character subclass. Classes 00 (successful completion), 01 (warning) and
              02 (no data) represent <firstterm>completion conditions</firstterm>. Every status code
              outside these classes is an <firstterm>exception</firstterm>. Because classes 00, 01
              and 02 don't raise an error, they won't ever show up in the
              <varname>SQLSTATE</varname> variable.</para>
            </listitem>
            <listitem>
              <para>For a complete listing of <database>SQLSTATE</database> codes, consult the
              <ulink
              url="http://www.firebirdsql.org/rlsnotesh/rlsnotes25.html#rnfb25-appx-sqlstates"><citetitle>Appendix
              to the Firebird 2.5 Release Notes</citetitle></ulink>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-updating">
      <title><varname>UPDATING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired
        because of an <database>UPDATE</database> operation. Intended for use in <link
        linkend="langrefupd25-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd25-operators">
    <title>Operators and predicates</title>
    <section id="langrefupd25-operators-null">
      <title><constant>NULL</constant> literals allowed as operands</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Before Firebird 2.0, most operators and predicates did not allow
        <constant>NULL</constant> literals as operands. Tests or operations like <quote><code>A
        &lt;&gt; NULL</code></quote>, <quote><code>B + NULL</code></quote> or <quote><code>NULL &lt;
        ANY(...)</code></quote> would be rejected by the parser. Now they are allowed almost
        everywhere, but please be aware of the following:<blockquote>
            <para><emphasis>The vast majority of these newly allowed expressions return
            <constant>NULL</constant> regardless of the state or value of the other operand, and are
            therefore worthless for any practicle purpose whatsoever.</emphasis></para>
          </blockquote></para>
      </formalpara>
      <!--Made this a separate para because otherwise there is no space between it and the blockquote
above in the PDF version:-->
      <para>In particular, don't try to determine (non-)nullness of a field or variable by testing
      with <quote><code>= NULL</code></quote> or <quote><code>&lt;&gt; NULL</code></quote>. Always
      use <quote><code>IS [NOT] NULL</code></quote>.</para>
      <formalpara>
        <title>Predicates</title>
        <para>The <database>IN</database>, <database>ANY</database>/<database>SOME</database> and
        <database>ALL</database> predicates now also allow <constant>NULL</constant> literals where
        they were previously taboo. Here too, there is no practical benefit to enjoy, but the
        situation is a little more complicated in that predicates with <constant>NULL</constant>s do
        not always return a <constant>NULL</constant> result. For details, see the
        <citetitle>Firebird Null Guide</citetitle>, section <ulink
        url="http://www.firebirdsql.org/manual/nullguide-predicates.html"><citetitle>Predicates</citetitle></ulink>.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-concat">
      <title><database>||</database> (string concatenator)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd25-concat-blobs">
        <title>Text <database>BLOB</database> concatenation</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Since Firebird 2.1 the concatenation operator supports <database>BLOB</database>s of
          any length and any character set. If a mixture of <database>BLOB</database>s and
          non-<database>BLOB</database>s is involved, the result is a <database>BLOB</database>. If
          both text and binary <database>BLOB</database>s are involved, the result is a binary
          <database>BLOB</database>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-concat-resulttype">
        <title>Result type <database>VARCHAR</database> or <database>BLOB</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 2.0, the result type of string concatenations used to be
          <database>CHAR</database>(<replaceable>n</replaceable>). In Firebird 2.0 this was changed
          to <database>VARCHAR</database>(<replaceable>n</replaceable>). As a result, the maximum
          length of a concatenation outcome became 32765 instead of 32767. In Firebird 2.1 and up,
          if at least one of the operands is a <database>BLOB</database>, the result is also a
          <database>BLOB</database> and the maximum doesn't apply. For non-<database>BLOB</database>
          concatenations the result is still
          <database>VARCHAR</database>(<replaceable>n</replaceable>) with a maximum of 32765
          bytes.</para>
          <!--Bug report CORE-3195: max should be 32767.-->
        </formalpara>
      </section>
      <section id="langrefupd25-concat-overflow">
        <title>Overflow checking</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0, 2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird versions 1.x, an error would be raised if the sum of the
          <emphasis>declared</emphasis> string lengths in a concatenation exceeded 65535 bytes, even
          if the <emphasis>actual</emphasis> result lay within the maximum string length of 32767
          bytes. In Firebird 2.0 and up, the declared string lengths will never cause an error. Only
          if the actual outcome exceeds 32765 bytes (the new limit for concatenation results) will
          an error be raised.</para>
          <!--Bug report CORE-3195: max should be 32767.-->
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-all">
      <title><database>ALL</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd25-all-null">
        <title><constant>NULL</constant> literals allowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ALL</database> predicate now allows a <constant>NULL</constant> as the
          test value. Notice that this brings no practical benefits. In particular, a
          <constant>NULL</constant> test value will not be considered equal to
          <constant>NULL</constant>s in the subquery result set. Even if the entire set is filled
          with <constant>NULL</constant>s and the operator chosen is <quote>=</quote>, the predicate
          will not return <constant>true</constant>, but <constant>NULL</constant>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-all-union">
        <title><database>UNION</database> as subselect</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The subselect in an <database>ALL</database> predicate may now also be a
          <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-any">
      <title><database>ANY</database> / <database>SOME</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd25-any-null">
        <title><constant>NULL</constant> literals allowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ANY</database> (or <database>SOME</database>) predicate now allows a
          <constant>NULL</constant> as the test value. Notice that this brings no practical
          benefits. In particular, a <constant>NULL</constant> test value will not be considered
          equal to a <constant>NULL</constant> in the subquery result set.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-any-union">
        <title><database>UNION</database> as subselect</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The subselect in an <database>ANY</database> (or <database>SOME</database>)
          predicate may now also be a <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-in">
      <title><database>IN</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd25-in-null">
        <title><constant>NULL</constant> literals allowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>IN</database> predicate now allows <constant>NULL</constant> literals,
          both as the test value and in the list. Notice that this brings no practical benefits. In
          particular, <quote><constant>NULL</constant> <database>IN</database> (...,
          <constant>NULL</constant>, ..., ...)</quote> will not return <constant>true</constant> and
          <quote><constant>NULL</constant> <database><database>NOT</database></database>
          <database>IN</database> (..., <constant>NULL</constant>, ..., ...)</quote> will not return
          <constant>false</constant>.</para>
        </formalpara>
      </section>
      <section id="langrefupd25-in-union">
        <title><database>UNION</database> as subselect</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A subselect in an <database>IN</database> predicate may now also be a
          <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd25-distinct">
      <title><database>IS [NOT] DISTINCT FROM</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Two operands are considered <database>DISTINCT</database> if they have a different
        value or if one of them is <constant>NULL</constant> and the other isn't. They are
        <database>NOT DISTINCT</database> if they have the same value or if both of them are
        <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Boolean</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting><replaceable>op1</replaceable> IS [NOT] DISTINCT FROM <replaceable>op2</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select id, name, teacher from courses
  where start_day is not distinct from end_day</programlisting>
            <programlisting>if (New.Job is distinct from Old.Job)
  then post_event 'job_changed';</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>IS [NOT] DISTINCT FROM</database> always returns <constant>true</constant> or
      <constant>false</constant>, never <constant>NULL</constant> (unknown). The
      <quote><literal>=</literal></quote> and <quote><literal>&lt;&gt;</literal></quote> operators,
      by contrast, return <constant>NULL</constant> if one or both operands are
      <constant>NULL</constant>. See also the table below.</para>
      <table id="langrefupd25-tbl-distinct">
        <title>Comparison of <database>[NOT] DISTINCT</database> to
        <quote><literal>=</literal></quote> and <quote><literal>&lt;&gt;</literal></quote></title>
        <tgroup cols="5">
          <colspec colname="colOperands" />
          <colspec align="center" colname="colResult1" />
          <colspec align="center" colname="colResult2" />
          <colspec align="center" colname="colResult3" />
          <colspec align="center" colname="colResult4" />
          <spanspec nameend="colResult4" namest="colResult1" spanname="spanResults" />
          <thead>
            <row>
              <entry align="center" morerows="1">Operand characteristics</entry>
              <entry align="center" spanname="spanResults">Results with the different
              operators</entry>
            </row>
            <row>
              <entry align="center">=</entry>
              <entry align="center">NOT DISTINCT</entry>
              <entry align="center">&lt;&gt;</entry>
              <entry align="center">DISTINCT</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Same value</entry>
              <entry><constant>true</constant></entry>
              <entry><constant>true</constant></entry>
              <entry><constant>false</constant></entry>
              <entry><constant>false</constant></entry>
            </row>
            <row>
              <entry>Different values</entry>
              <entry><constant>false</constant></entry>
              <entry><constant>false</constant></entry>
              <entry><constant>true</constant></entry>
              <entry><constant>true</constant></entry>
            </row>
            <row>
              <entry>Both <constant>NULL</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>true</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>false</constant></entry>
            </row>
            <row>
              <entry>One <constant>NULL</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>false</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>true</constant></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd25-nextvaluefor">
      <title><database>NEXT VALUE FOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: no--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the next value in a sequence. <database>SEQUENCE</database> is the
        SQL-compliant term for what InterBase and Firebird have always called a generator.
        <database>NEXT VALUE FOR</database> is fully equivalent to <database>GEN_ID(...,
        1)</database> and is the recommended syntax from Firebird 2.0 onward.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>NEXT VALUE FOR <replaceable>sequence-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>new.cust_id = next value for custseq;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>NEXT VALUE FOR</database> doesn't support increment values other than 1. If
      you absolutely need other step values, use the legacy GEN_ID function.</para>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-create-seq"><database>CREATE SEQUENCE</database></link>,
        <link linkend="langrefupd25-intfunc-gen_id"><database>GEN_ID()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-similar-to">
      <title><database>SIMILAR TO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL?--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>SIMILAR TO</database> matches a string against an SQL regular expression
        pattern. Unlike in some other languages, the pattern must match the entire string in order
        to succeed – matching a substring is not enough. If any operand is
        <constant>NULL</constant>, the result is <constant>NULL</constant>. Otherwise, the result is
        <constant>TRUE</constant> or <constant>FALSE</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Boolean</para>
      </formalpara>
      <formalpara>
        <title>Syntax: <database>SIMILAR TO</database></title>
        <para><blockquote>
            <programlisting><replaceable>string-expression</replaceable> [NOT] SIMILAR TO <replaceable>&lt;pattern&gt;</replaceable> [ESCAPE <replaceable>&lt;escape-char&gt;</replaceable>]

<replaceable>&lt;pattern&gt;</replaceable>      ::=  an SQL regular expression
<replaceable>&lt;escape-char&gt;</replaceable>  ::=  a single character</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Syntax: SQL regular expressions</title>
        <para>The following syntax defines the SQL regular expression format. It is a complete and
        correct top-down definition. It is also highly formal, rather long and probably perfectly
        fit to discourage everybody who hasn't already some experience with regular expessions (or
        with highly formal, rather long top-down definitions). Feel free to skip it and read the
        next section, <link linkend="langrefupd25-similar-to-building-regexps"><citetitle>Building
        regular expressions</citetitle></link>, which uses a bottom-up approach, aimed at the rest
        of us.<blockquote>
            <programlisting><replaceable>&lt;regular expression&gt;</replaceable>     ::=  <replaceable>&lt;regular term&gt;</replaceable> ['|' <replaceable>&lt;regular term&gt;</replaceable> ...]

<replaceable>&lt;regular term&gt;</replaceable>           ::=  <replaceable>&lt;regular factor&gt;</replaceable> ...

<replaceable>&lt;regular factor&gt;</replaceable>         ::=  <replaceable>&lt;regular primary&gt;</replaceable> [<replaceable>&lt;quantifier&gt;</replaceable>]

<replaceable>&lt;quantifier&gt;</replaceable>             ::=  ?
                              | *
                              | +
                              | '{' <replaceable>&lt;m&gt;</replaceable> [,[<replaceable>&lt;n&gt;</replaceable>]] '}'

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>                 ::=  unsigned int, with <replaceable>&lt;m&gt;</replaceable> &lt;= <replaceable>&lt;n&gt;</replaceable> if both present

<replaceable>&lt;regular primary&gt;</replaceable>        ::=  <replaceable>&lt;character&gt;</replaceable>
                              | <replaceable>&lt;character class&gt;</replaceable>
                              | %
                              | (<replaceable>&lt;regular expression&gt;</replaceable>)

<replaceable>&lt;character&gt;</replaceable>              ::=  <replaceable>&lt;escaped character&gt;</replaceable>
                              | <replaceable>&lt;non-escaped character&gt;</replaceable>

<replaceable>&lt;escaped character&gt;</replaceable>      ::=  <replaceable>&lt;escape-char&gt;</replaceable> <replaceable>&lt;special character&gt;</replaceable>
                              | <replaceable>&lt;escape-char&gt;</replaceable> <replaceable>&lt;escape-char&gt;</replaceable>

<replaceable>&lt;special character&gt;</replaceable>      ::=  any of the characters []()|^-+*%_?{

<replaceable>&lt;non-escaped character&gt;</replaceable>  ::=  any character that is not a <replaceable>&lt;special character&gt;</replaceable>
                              and not equal to <replaceable>&lt;escape-char&gt;</replaceable> (if defined)

<replaceable>&lt;character class&gt;</replaceable>        ::=  '_'
                              | '[' <replaceable>&lt;member&gt;</replaceable> ... ']'
                              | '[^' <replaceable>&lt;non-member&gt;</replaceable> ... ']'
                              | '[' <replaceable>&lt;member&gt;</replaceable> ... '^' <replaceable>&lt;non-member&gt;</replaceable> ... ']'

<replaceable>&lt;member&gt;</replaceable>, <replaceable>&lt;non-member&gt;</replaceable>   ::=  <replaceable>&lt;character&gt;</replaceable>
                              | <replaceable>&lt;range&gt;</replaceable>
                              | <replaceable>&lt;predefined class&gt;</replaceable>

<replaceable>&lt;range&gt;</replaceable>                  ::=  <replaceable>&lt;character&gt;</replaceable>-<replaceable>&lt;character&gt;</replaceable>

<replaceable>&lt;predefined class&gt;</replaceable>       ::=  '[:' <replaceable>&lt;predefined class name&gt;</replaceable> ':]'

<replaceable>&lt;predefined class name&gt;</replaceable>  ::=  ALPHA | UPPER | LOWER | DIGIT
                              | ALNUM | SPACE | WHITESPACE</programlisting>
          </blockquote><!--After %, Fb does not allow *, + or {}, although it should according to the standard.
? is allowed.

CORE-3522--></para>
      </formalpara>
      <section id="langrefupd25-similar-to-building-regexps">
        <title>Building regular expressions</title>
        <section id="langrefupd25-similar-to-building-regexps-characters">
          <title>Characters</title>
          <para>Within regular expressions, most characters represent themselves. The only
          exceptions are the special characters below:</para>
          <blockquote>
            <programlisting>[ ] ( ) | ^ - + * % _ ? {</programlisting>
          </blockquote>
          <para>...and the escape character, if it is defined.</para>
          <para>A regular expression that doesn't contain any special or escape characters only
          matches strings that are identical to itself (subject to the collation in use). That is,
          it functions just like the <quote><literal>=</literal></quote> operator:</para>
          <blockquote>
            <programlisting>'Apple' similar to 'Apple'              -- true
'Apples' similar to 'Apple'             -- false
'Apple' similar to 'Apples'             -- false
'APPLE' similar to 'Apple'              -- depends on collation</programlisting>
          </blockquote>
        </section>
        <section id="langrefupd25-similar-to-building-regexps-wildcards">
          <title>Wildcards</title>
          <para>The known SQL wildchards <literal>_</literal> and <literal>%</literal> match any
          single character and a string of any length, respectively:</para>
          <blockquote>
            <programlisting>'Birne' similar to 'B_rne'              -- true
'Birne' similar to 'B_ne'               -- false
'Birne' similar to 'B%ne'               -- true
'Birne' similar to 'Bir%ne%'            -- true
'Birne' similar to 'Birr%ne'            -- false</programlisting>
          </blockquote>
          <para>Notice how <literal>%</literal> also matches the empty string.</para>
        </section>
        <section id="langrefupd25-similar-to-building-regexps-classes">
          <title>Character classes</title>
          <para>A bunch of characters enclosed in brackets define a character class. A character in
          the string matches a class in the pattern if the character is a member of the
          class:</para>
          <blockquote>
            <programlisting>'Citroen' similar to 'Cit[arju]oen'     -- true
'Citroen' similar to 'Ci[tr]oen'        -- false
'Citroen' similar to 'Ci[tr][tr]oen'    -- true</programlisting>
          </blockquote>
          <para>As can be seen from the second line, the class only matches a single character, not
          a sequence.</para>
          <para>Within a class definition, two characters connected by a hyphen define a range. A
          range comprises the two endpoints and all the characters that lie between them in the
          active collation. Ranges can be placed anywhere in the class definition without special
          delimiters to keep them apart from the other elements.</para>
          <blockquote>
            <programlisting>'Datte' similar to 'Dat[q-u]e'          -- true
'Datte' similar to 'Dat[abq-uy]e'       -- true
'Datte' similar to 'Dat[bcg-km-pwz]e'   -- false</programlisting>
          </blockquote>
          <!--ERROR: If the first character defining the range is higher than the second, Firebird not only accepts this
(which is illegal) but also treats it as a "_" wildcard: it matches any single character!

CORE-3523 - Fixed by Adriano for 2.5.1-->
          <para>The following predefined character classes can also be used in a class
          definition:</para>
          <variablelist>
            <varlistentry>
              <term>[:ALPHA:]</term>
              <listitem>
                <para>Latin letters <literal>a</literal>..<literal>z</literal> and
                <literal>A</literal>..<literal>Z</literal>. With an accent-insensitive collation,
                this class also matches accented forms of these characters.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>[:DIGIT:]</term>
              <listitem>
                <para>Decimal digits <literal>0</literal>..<literal>9</literal>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>[:ALNUM:]</term>
              <listitem>
                <para>Union of [:ALPHA:] and [:DIGIT:].</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>[:UPPER:]</term>
              <listitem>
                <para>Uppercase Latin letters <literal>A</literal>..<literal>Z</literal>. Also
                matches lowercase with case-insensitive collation and accented forms with
                accent-insensitive collation.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>[:LOWER:]</term>
              <listitem>
                <para>Lowercase Latin letters <literal>a</literal>..<literal>z</literal>. Also
                matches uppercase with case-insensitive collation and accented forms with
                accent-insensitive collation.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>[:SPACE:]</term>
              <listitem>
                <para>Matches the space character (ASCII 32).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>[:WHITESPACE:]</term>
              <listitem>
                <para>Matches vertical tab (ASCII 9), linefeed (ASCII 10), horizontal tab (ASCII
                11), formfeed (ASCII 12), carriage return (ASCII 13) and space (ASCII 32).</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <!--SQL standard:

3.1.6.42 white space: Characters used to separate tokens in SQL text; white space may be required (for example,
to separate <nondelimiter token>s from one another) and may be used between any two tokens for
which there are no rules prohibiting such use.
White space is any character in the Unicode General Category classes “Zs”, “Zl”, and “Zp”, or any of the fol-
lowing characters:
— U+0009, Horizontal Tabulation
— U+000A, Line Feed
— U+000B, Vertical Tabulation
— U+000C, Form Feed
— U+000D, Carriage Return
— U+0085, Next Line
NOTE 6 — The normative provisions of this International Standard impose no requirement that any character set have equivalents for
any of these characters except U+0020 (<space>); however, by reference to this definition of white space, they do impose the requirement
that every equivalent for one of these shall be recognized as a white space character.
NOTE 7 — The Unicode General Category classes “Zs”, “Zl”, and “Zp” are assigned to Unicode characters that are, respectively, space
separators, line separators, and paragraph separators.
The only character that is a member of the Unicode General Category class “Zl” is U+2028, Line Separator. The only character that is
a member of the Unicode General Category class “Zp” is U+2029, Paragraph Separator. The characters that are members of the Unicode
General Category class “Zs” are: U+0020, Space, U+00A0, No-Break Space, U+1680, Ogham Space Mark, U+2000, En Quad, U+2001,
Em Quad, U+2002, En Space, U+2003, Em Space, U+2004, Three-Per-Em Space, U+2005, Four-Per-Em Space, U+2006, Six-Per-Em
Space, U+2007, Figure Space, U+2008, Punctuation Space, U+2009, Thin Space, U+200A, Hair Space, U+202F, Narrow No-Break
Space, and U+3000, Ideographic Space.-->
          <para>Including a predefined class has the same effect as including all its members.
          Predefined classes are only allowed <emphasis>within</emphasis> class definitions. If you
          need to match against a predefined class and nothing more, place an extra pair of brackets
          around it.</para>
          <blockquote>
            <programlisting>'Erdbeere' similar to 'Erd[[:ALNUM:]]eere'     -- true
'Erdbeere' similar to 'Erd[[:DIGIT:]]eere'     -- false
'Erdbeere' similar to 'Erd[a[:SPACE:]b]eere'   -- true
'Erdbeere' similar to [[:ALPHA:]]              -- false
'E'        similar to [[:ALPHA:]]              -- true</programlisting>
          </blockquote>
          <para>If a class definition starts with a caret, everything that follows is excluded from
          the class. All other characters match:</para>
          <blockquote>
            <programlisting>'Framboise' similar to 'Fra[^ck-p]boise'       -- false
'Framboise' similar to 'Fr[^a][^a]boise'       -- false
'Framboise' similar to 'Fra[^[:DIGIT:]]boise'  -- true</programlisting>
          </blockquote>
          <para>If the caret is not placed at the start of the sequence, the class contains
          everything <emphasis>before</emphasis> the caret, except for the elements that also occur
          <emphasis>after</emphasis> the caret:</para>
          <blockquote>
            <programlisting>'Grapefruit' similar to 'Grap[a-m^f-i]fruit'   -- true
'Grapefruit' similar to 'Grap[abc^xyz]fruit'   -- false
'Grapefruit' similar to 'Grap[abc^de]fruit'    -- false
'Grapefruit' similar to 'Grap[abe^de]fruit'    -- false</programlisting>
            <programlisting>'3' similar to '[[:DIGIT:]^4-8]'               -- true
'6' similar to '[[:DIGIT:]^4-8]'               -- false</programlisting>
          </blockquote>
          <para>Lastly, the already mentioned wildcard <quote><literal>_</literal></quote> is a
          character class of its own, matching any single character.</para>
          <!--I notice that within a class definition, _ loses its special meaning and only represents itself.
Is this according to the standard? NO! It should be escaped within a class definition.
Firebird accepts it if escaped, but also if not escaped.
Also | is accepted in a class def and represents itself. It is also accepted escaped.
The escape character is NOT accepted on its own in a class def.-->
        </section>
        <section id="langrefupd25-similar-to-building-regexps-quantifiers">
          <title>Quantifiers</title>
          <para>A question mark immediately following a character or class indicates that the
          preceding item may occur 0 or 1 times in order to match:</para>
          <blockquote>
            <programlisting>'Hallon' similar to 'Hal?on'                   -- false
'Hallon' similar to 'Hal?lon'                  -- true
'Hallon' similar to 'Halll?on'                 -- true
'Hallon' similar to 'Hallll?on'                -- false
'Hallon' similar to 'Halx?lon'                 -- true
'Hallon' similar to 'H[a-c]?llon[x-z]?'        -- true</programlisting>
          </blockquote>
          <para>An asterisk immediately following a character or class indicates that the preceding
          item may occur 0 or more times in order to match:</para>
          <blockquote>
            <programlisting>'Icaque' similar to 'Ica*que'                  -- true
'Icaque' similar to 'Icar*que'                 -- true
'Icaque' similar to 'I[a-c]*que'               -- true
'Icaque' similar to '_*'                       -- true
'Icaque' similar to '[[:ALPHA:]]*'             -- true
'Icaque' similar to 'Ica[xyz]*e'               -- false</programlisting>
          </blockquote>
          <para>A plus sign immediately following a character or class indicates that the preceding
          item must occur 1 or more times in order to match:</para>
          <blockquote>
            <programlisting>'Jujube' similar to 'Ju_+'                     -- true
'Jujube' similar to 'Ju+jube'                  -- true
'Jujube' similar to 'Jujuber+'                 -- false
'Jujube' similar to 'J[jux]+be'                -- true
'Jujube' sililar to 'J[[:DIGIT:]]+ujube'       -- false</programlisting>
          </blockquote>
          <para>If a character or class is followed by a number enclosed in braces, it must be
          repeated <emphasis>exactly</emphasis> that number of times in order to match:</para>
          <blockquote>
            <programlisting>'Kiwi' similar to 'Ki{2}wi'                    -- false
'Kiwi' similar to 'K[ipw]{2}i'                 -- true
'Kiwi' similar to 'K[ipw]{2}'                  -- false
'Kiwi' similar to 'K[ipw]{3}'                  -- true</programlisting>
          </blockquote>
          <para>If the number is followed by a comma, the item must be repeated <emphasis>at
          least</emphasis> that number of times in order to match:</para>
          <blockquote>
            <programlisting>'Limone' similar to 'Li{2,}mone'               -- false
'Limone' similar to 'Li{1,}mone'               -- true
'Limone' similar to 'Li[nezom]{2,}'            -- true</programlisting>
          </blockquote>
          <para>If the braces contain two numbers seperated by a comma, the second number not
          smaller than the first, then the item must be repeated <emphasis>at least</emphasis> the
          first number and <emphasis>at most</emphasis> the second number of times in order to
          match:</para>
          <blockquote>
            <programlisting>'Mandarijn' similar to 'M[a-p]{2,5}rijn'       -- true
'Mandarijn' similar to 'M[a-p]{2,3}rijn'       -- false
'Mandarijn' similar to 'M[a-p]{2,3}arijn'      -- true</programlisting>
          </blockquote>
          <para>The quantifiers <literal>?</literal>, <literal>*</literal> and <literal>+</literal>
          are shorthand for <literal>{0,1}</literal>, <literal>{0,}</literal> and
          <literal>{1,}</literal>, respectively.</para>
        </section>
        <section id="langrefupd25-similar-to-building-regexps-oring">
          <title>OR-ing terms</title>
          <para>Regular expression terms can be OR'ed with the <literal>|</literal> operator. A
          match is made when the argument string matches at least one of the terms:</para>
          <blockquote>
            <programlisting>'Nektarin' similar to 'Nek|tarin'              -- false
'Nektarin' similar to 'Nektarin|Persika'       -- true
'Nektarin' similar to 'M_+|N_+|P_+'            -- true</programlisting>
          </blockquote>
        </section>
        <section id="langrefupd25-similar-to-building-regexps-subexpr">
          <title>Subexpressions</title>
          <para>One or more parts of the regular expression can be grouped into subexpressions (also
          called subpatterns) by placing them between parentheses. A subexpression is a regular
          expression in its own right. It can contain all the elements allowed in a regular
          expression, and can also have quantifiers added to it.</para>
          <blockquote>
            <programlisting>'Orange' similar to 'O(ra|ri|ro)nge'           -- true
'Orange' similar to 'O(r[a-e])+nge'            -- true
'Orange' similar to 'O(ra){2,4}nge'            -- false
'Orange' similar to 'O(r(an|in)g|rong)?e'      -- true</programlisting>
          </blockquote>
        </section>
        <section id="langrefupd25-similar-to-building-regexps-escaping">
          <title>Escaping special characters</title>
          <para>In order to match against a character that is special in regular expressions, that
          character has to be escaped. There is no default escape character; rather, the user
          specifies one when needed:</para>
          <blockquote>
            <programlisting>'Peer (Poire)' similar to 'P[^ ]+ \(P[^ ]+\)' escape '\'    -- true
'Pera [Pear]'  similar to 'P[^ ]+ #[P[^ ]+#]' escape '#'    -- true
'Päron-Äppledryck' similar to 'P%$-Ä%' escape '$'           -- true
'Pärondryck' similar to 'P%--Ä%' escape '-'                 -- false</programlisting>
          </blockquote>
          <para>The last line demonstrates that the escape character can also escape itself, if
          needed.</para>
          <!--Firebird allows escaping }. This is not conformant!-->
        </section>
      </section>
    </section>
    <section id="langrefupd25-some">
      <title><database>SOME</database></title>
      <para>See <link linkend="langrefupd25-any"><database>ANY</database></link></para>
    </section>
  </chapter>
  <chapter id="langrefupd25-aggrfunc">
    <title>Aggregate functions</title>
    <para>Aggregate functions operate on groups of records, rather than on individual records or
    variables. They are often used in combination with a <database>GROUP BY</database>
    clause.</para>
    <section id="langrefupd25-aggrfunc-list">
      <title><database>LIST()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL?  -> Oleg Loa, Dmitry Yemanov-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>LIST</database> returns a string consisting of the
        non-<constant>NULL</constant> argument values in the group, separated either by a comma or
        by a user-supplied delimiter. If there are no non-<constant>NULL</constant> values (this
        includes the case where the group is empty), <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database><database>BLOB</database></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LIST ([ALL | DISTINCT] <replaceable>expression</replaceable> [, <replaceable>separator</replaceable>])</programlisting>
            <itemizedlist>
              <listitem>
                <para><database>ALL</database> (the default) results in all
                non-<constant>NULL</constant> values to be listed. With
                <database>DISTINCT</database>, duplicates are removed, except if
                <replaceable>expression</replaceable> is a <database>BLOB</database>.<!--CORE-3253--></para>
              </listitem>
              <listitem>
                <para>In Firebird 2.5 and up, the optional <replaceable>separator</replaceable>
                argument may be any string expression. This makes it possible to specify e.g.
                <parameter><literal>ascii_char(13)</literal></parameter> as a separator. (This
                improvement has also been backported to 2.1.4.)</para>
              </listitem>
              <listitem>
                <para>The <replaceable>expression</replaceable> and
                <replaceable>separator</replaceable> arguments support <database>BLOB</database>s of
                any size and character set.</para>
              </listitem>
              <listitem>
                <para>Date/time and numerical arguments are implicitly converted to strings before
                concatenation.</para>
              </listitem>
              <listitem>
                <para>The result is a text <database>BLOB</database>, except when
                <replaceable>expression</replaceable> is a <database>BLOB</database> of another
                subtype.</para>
              </listitem>
              <listitem>
                <para>The ordering of the list values is undefined.</para>
                <!--Rlsnotes say: implementation-defined. What does this mean: that they can differ between, say, Fb/Win and Fb/Linux?
-> No, this seems to have been blindly copied from the SQL-2003 standard documents-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-aggrfunc-max">
      <title><database>MAX()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1<!--Check with 2.0 to make sure!--></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>MAX</database> returns the maximum argument value in the group. If the
        argument is a string, this is the value that comes last when the active collation is
        applied.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>MAX (<replaceable>expression</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>If the group is empty or contains only <database>NULL</database>s, the result
                is <database>NULL</database>.</para>
              </listitem>
              <listitem>
                <para>Since Firebird 2.1, this function fully supports text
                <database>BLOB</database>s of any size and character set.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-aggrfunc-min">
      <title><database>MIN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1<!--Check with 2.0 to make sure!--></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>MIN</database> returns the minimum argument value in the group. If the
        argument is a string, this is the value that comes first when the active collation is
        applied.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>MIN (<replaceable>expression</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>If the group is empty or contains only <database>NULL</database>s, the result
                is <database>NULL</database>.</para>
              </listitem>
              <listitem>
                <para>Since Firebird 2.1, this function fully supports text
                <database>BLOB</database>s of any size and character set.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd25-intfunc">
    <title>Internal functions</title>
    <section id="langrefupd25-intfunc-abs">
      <title><database>ABS()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the absolute value of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Numerical</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ABS (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-abs">external function
        <function>ABS</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-acos">
      <title><database>ACOS()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the arc cosine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ACOS (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>The result is an angle in the range [0, π].</para>
              </listitem>
              <listitem>
                <para>If the argument is outside the range [-1, 1], NaN is returned.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-acos">external function
        <function>ACOS</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-ascii_char">
      <title><database>ASCII_CHAR()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII character corresponding to the number passed in the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>[VAR]CHAR(1) CHARACTER SET NONE</database><!--VARCHAR when arg is NULL--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ASCII_CHAR (<replaceable>&lt;code&gt;</replaceable>)

<replaceable>&lt;code&gt;</replaceable>  ::=  an integer in the range [0..255]</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <itemizedlist>
          <listitem>
            <para>If the <link linkend="langrefupd25-udf-ascii_char">external function
            <function>ASCII_CHAR</function></link> is declared in your database, it will override
            the internal function. To make the internal function available, <link
            linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
            linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
            function (UDF).</para>
          </listitem>
          <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
          <listitem>
            <para>If you are used to the behaviour of the <function>ASCII_CHAR</function> UDF, which
            returns an empty string if the argument is 0, please notice that the internal function
            correctly returns a character with ASCII code 0 here.</para>
          </listitem>
        </itemizedlist>
      </important>
    </section>
    <section id="langrefupd25-intfunc-ascii_val">
      <title><database>ASCII_VAL()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII code of the character passed in.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>SMALLINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ASCII_VAL (<replaceable>ch</replaceable>)

<replaceable>ch</replaceable>  ::=  a [<database>VAR</database>]<database>CHAR</database> or text <database>BLOB</database> of max. 32767 bytes</programlisting>
            <itemizedlist>
              <listitem>
                <para>If the argument is a string with more than one character, the ASCII code of
                the first character is returned.</para>
              </listitem>
              <listitem>
                <para>If the argument is an empty string, 0 is returned.</para>
              </listitem>
              <listitem>
                <para>If the argument is <constant>NULL</constant>, <constant>NULL</constant> is
                returned.</para>
                <!--Should that be mentioned? It is the expected behaviour.-->
              </listitem>
              <listitem>
                <para>If the first character of the argument string is multi-byte, an error is
                raised. (A bug in Firebird 2.1–2.1.3 and 2.5 causes an error to be raised if
                <emphasis>any</emphasis> character in the string is multi-byte. This is fixed in
                versions 2.1.4 and 2.5.1.)</para>
                <!--RlsNotes say: Error if *first* char is multibyte. Entered bug CORE-3227. Fixed for 2.1.4, 2.5.1, 3.0-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-ascii_val">external function
        <function>ASCII_VAL</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-asin">
      <title><database>ASIN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the arc sine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ASIN (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>The result is an angle in the range [-π/2, π/2].</para>
              </listitem>
              <listitem>
                <para>If the argument is outside the range [-1, 1], NaN is returned.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-asin">external function
        <function>ASIN</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-atan">
      <title><database>ATAN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the arc tangent of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ATAN (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>The result is an angle in the range &lt;-π/2, π/2&gt;.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-atan">external function
        <function>ATAN</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-atan2">
      <title><database>ATAN2()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the angle whose sine-to-cosine <emphasis>ratio</emphasis> is given by the two
        arguments, and whose sine and cosine <emphasis>signs</emphasis> correspond to the signs of
        the arguments. This allows results across the entire circle, including the angles -π/2 and
        π/2.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <!--Note for maintainers/editors: the argument names y and x (in that order!) are chosen on purpose, for geometrical reasons.-->
            <programlisting>ATAN2 (<replaceable>y</replaceable>, <replaceable>x</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>The result is an angle in the range [-π, π].</para>
              </listitem>
              <listitem>
                <para>If <replaceable>x</replaceable> is negative, the result is π if
                <replaceable>y</replaceable> is 0, and -π if <replaceable>y</replaceable> is
                -0.</para>
              </listitem>
              <listitem>
                <para>If both <replaceable>y</replaceable> and <replaceable>x</replaceable> are 0,
                the result is meaningless. Starting with Firebird 3, an error will be raised if both
                arguments are 0.</para>
                <!--Bug report CORE-3201: an exception should be raised here or NaN returned.
02 Feb 2011 Fixed by Adriano for 3.0 alpha. 2.1.5 and 2.5.1 not (yet?)-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-atan2">external function
        <function>ATAN2</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>A fully equivalent description of this function is the following:
              <database>ATAN2</database>(<replaceable>y</replaceable>, <replaceable>x</replaceable>)
              is the angle between the positive X-axis and the line from the origin to the point
              (<replaceable>x</replaceable>, <replaceable>y</replaceable>). This also makes it
              obvious that <database>ATAN2</database>(0, 0) is undefined.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>x</replaceable> is greater than 0,
              <database>ATAN2</database>(<replaceable>y</replaceable>, <replaceable>x</replaceable>)
              is the same as
              <database>ATAN</database>(<replaceable>y</replaceable>/<replaceable>x</replaceable>).</para>
            </listitem>
            <listitem>
              <para>If both sine and cosine of the angle are already known,
              <database>ATAN2</database>(<replaceable>sin</replaceable>,
              <replaceable>cos</replaceable>) gives the angle.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-bin_and">
      <title><database>BIN_AND()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the result of the bitwise AND operation on the argument(s).</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> or <database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIN_AND (<replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-bin_and">external function
        <function>BIN_AND</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-bin_or">
      <title><database>BIN_OR()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the result of the bitwise OR operation on the argument(s).</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> or <database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIN_OR (<replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-bin_or">external function
        <function>BIN_OR</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-bin_shl">
      <title><database>BIN_SHL()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument bitwise left-shifted by the second argument, i.e.
        <replaceable>a</replaceable> &lt;&lt; <replaceable>b</replaceable> or
        <replaceable>a</replaceable>·2^<replaceable>b</replaceable>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIN_SHL (<replaceable>number</replaceable>, <replaceable>shift</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-bin_shr">
      <title><database>BIN_SHR()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument bitwise right-shifted by the second argument, i.e.
        <replaceable>a</replaceable> &gt;&gt; <replaceable>b</replaceable> or
        <replaceable>a</replaceable>/2^<replaceable>b</replaceable>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIN_SHR (<replaceable>number</replaceable>, <replaceable>shift</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>The operation performed is an arithmetic right shift (SAR), meaning that the
                sign of the first operand is always preserved.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-bin_xor">
      <title><database>BIN_XOR()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the result of the bitwise XOR operation on the argument(s).</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> or <database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIN_XOR (<replaceable>number</replaceable> [, <replaceable>number</replaceable> ...])</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-bin_xor">external function
        <function>BIN_XOR</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-bit_length">
      <title><database>BIT_LENGTH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Gives the length in bits of the input string. For multi-byte character sets, this may
        be less than the number of characters times 8 times the <quote>formal</quote> number of
        bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
      </formalpara>
      <note>
        <para>With arguments of type <database>CHAR</database>, this function takes the entire
        formal string length (e.g. the declared length of a field or variable) into account. If you
        want to obtain the <quote>logical</quote> bit length, not counting the trailing spaces,
        right-<link linkend="langrefupd25-intfunc-trim"><database>TRIM</database></link> the
        argument before passing it to <database>BIT_LENGTH</database>.</para>
      </note>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIT_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title><database>BLOB</database> support</title>
        <para>Since Firebird 2.1, this function fully supports text <database>BLOB</database>s of
        any length and character set.</para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select bit_length('Hello!') from rdb$database
  -- returns 48</programlisting>
            <programlisting>select bit_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 64: ü and ß take up one byte each in ISO8859_1</programlisting>
            <programlisting>select bit_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 80: ü and ß take up two bytes each in UTF8</programlisting>
            <programlisting>select bit_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 208: all 24 <database>CHAR</database> positions count, and two of them are 16-bit</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-octet_length"><database>OCTET_LENGTH()</database></link>,
        <link
        linkend="langrefupd25-intfunc-char_length"><database>CHARACTER_LENGTH()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-cast">
      <title><database>CAST()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0, 2.1, 2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>CAST</database> converts an expression to the desired datatype or domain. If
        the conversion is not possible, an error is raised.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>User-chosen.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CAST (<replaceable>expression</replaceable> AS <replaceable>&lt;target_type&gt;</replaceable>)

<replaceable>&lt;target_type&gt;</replaceable>  ::=  <replaceable>sql_datatype</replaceable>
                    | [TYPE OF] <replaceable>domain</replaceable>
                    | TYPE OF COLUMN <replaceable>relname</replaceable>.<replaceable>colname</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Shorthand syntax</title>
        <para><blockquote>
            <para>Alternative syntax, supported only when casting a string literal to a
            <database>DATE</database>, <database>TIME</database> or
            <database>TIMESTAMP</database>:</para>
            <programlisting><replaceable>datatype</replaceable> <replaceable>'date/timestring'</replaceable></programlisting>
            <para>This syntax was already available in InterBase, but was never properly documented.
            <emphasis>Please notice:</emphasis> The shorthand syntax is evaluated immediately at
            parse time, causing the value to stay the same until the statement is unprepared. For
            datetime literals like <literal>'12-Oct-2012'</literal> this doesn't make any
            difference. But for the pseudo-variables <literal>'NOW'</literal>,
            <literal>'YESTERDAY'</literal>, <literal>'TODAY'</literal> and
            <literal>'TOMORROW'</literal> this may not be what you want. If you need the value to be
            evaluated at every call, use <database>CAST()</database>.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>A full-syntax cast:</para>
            <programlisting>select cast ('12' || '-June-' || '1959' as date) from rdb$database</programlisting>
            <para>A shorthand string-to-date cast:</para>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; date '1-Jan-1943'</programlisting>
            <para>Notice that you can drop even the shorthand cast from the example above, as the
            engine will understand from the context (comparison to a <database>DATE</database>
            field) how to interpret the string:</para>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; '1-Jan-1943'</programlisting>
            <para>But this is not always possible. The cast below cannot be dropped, otherwise the
            engine would find itself with an integer to be subtracted from a string:</para>
            <programlisting>select date 'today' - 7 from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The following table shows the type conversions possible with
      <database>CAST</database>.</para>
      <table id="langrefupd25-tbl-cast">
        <title>Possible <database>CAST</database>s</title>
        <tgroup cols="2">
          <colspec colname="colFromType" />
          <colspec colname="colToType" />
          <thead>
            <row valign="top">
              <entry>From</entry>
              <entry>To</entry>
            </row>
          </thead>
          <tbody>
            <row valign="top">
              <entry><simplelist>
                  <member>Numeric types</member>
                </simplelist></entry>
              <entry><simplelist>
                  <member>Numeric types</member>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>BLOB</database></member>
                </simplelist></entry>
            </row>
            <row valign="top">
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>BLOB</database></member>
                </simplelist></entry>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>BLOB</database></member>
                  <member>Numeric types</member>
                  <member><database>DATE</database></member>
                  <member><database>TIME</database></member>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
            </row>
            <row valign="top">
              <entry><simplelist>
                  <member><database>DATE</database></member>
                  <member><database>TIME</database></member>
                </simplelist></entry>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>BLOB</database></member>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
            </row>
            <row valign="top">
              <entry><simplelist>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>BLOB</database></member>
                  <member><database>DATE</database></member>
                  <member><database>TIME</database></member>
                </simplelist></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Keep in mind that sometimes information is lost, for instance when you cast a
      <database>TIMESTAMP</database> to a <database>DATE</database>. Also, the fact that types are
      <database>CAST</database>-compatible is in itself no guarantee that a conversion will succeed.
      <quote><database>CAST</database>(123456789 as <database>SMALLINT</database>)</quote> will
      definitely result in an error, as will <quote><database>CAST</database>('Judgement Day' as
      <database>DATE</database>)</quote>.</para>
      <formalpara>
        <title>Casting input fields</title>
        <para>Since Firebird 2.0, you can cast statement parameters to a datatype:</para>
      </formalpara>
      <blockquote>
        <programlisting>cast (? as integer)</programlisting>
      </blockquote>
      <para>This gives you control over the type of input field set up by the engine. Please notice
      that with statement parameters, you always need a full-syntax cast – shorthand casts are not
      supported.</para>
      <formalpara>
        <title>Casting to a domain or its type</title>
        <para>Firebird 2.1 and above support casting to a domain or its base type. When casting to a
        domain, any constraints (<database>NOT NULL</database> and/or <database>CHECK</database>)
        declared for the domain must be satisfied or the cast will fail. Please be aware that a
        <database>CHECK</database> passes if it evaluates to <constant>TRUE</constant>
        <emphasis>or</emphasis> <constant>NULL</constant>! So, given the following
        statements:</para>
      </formalpara>
      <blockquote>
        <programlisting>create domain quint as int check (value &gt;= 5000)
select cast (2000 as quint) from rdb$database     -- (1)
select cast (8000 as quint) from rdb$database     -- (2)
select cast (null as quint) from rdb$database     -- (3)</programlisting>
      </blockquote>
      <para>only cast number (1) will result in an error.</para>
      <para>When the <database>TYPE OF</database> modifier is used, the expression is cast to the
      base type of the domain, ignoring any constraints. With domain <type>quint</type> defined as
      above, the following two casts are equivalent and will both succeed:</para>
      <blockquote>
        <programlisting>select cast (2000 as type of quint) from rdb$database
select cast (2000 as int) from rdb$database</programlisting>
      </blockquote>
      <para>If <database>TYPE OF</database> is used with a
      (<database>VAR</database>)<database>CHAR</database> type, its character set and collation are
      retained:</para>
      <blockquote>
        <programlisting>create domain iso20 varchar(20) character set iso8859_1;
create domain dunl20 varchar(20) character set iso8859_1 collate du_nl;
create table zinnen (zin varchar(20));
commit;
insert into zinnen values ('Deze');
insert into zinnen values ('Die');
insert into zinnen values ('die');
insert into zinnen values ('deze');

select cast(zin as type of iso20) from zinnen order by 1;
  -- returns Deze -&gt; Die -&gt; deze -&gt; die

select cast(zin as type of dunl20) from zinnen order by 1;
  -- returns deze -&gt; Deze -&gt; die -&gt; Die</programlisting>
      </blockquote>
      <warning>
        <para>If a domain's definition is changed, existing <database>CAST</database>s to that
        domain or its type may become invalid. If these <database>CAST</database>s occur in PSQL
        modules, their invalidation may be detected. See the note <link
        linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The <database>RDB$VALID_BLR</database>
        field</citetitle></link>, near the end of this document.</para>
      </warning>
      <formalpara>
        <title>Casting to a column's type</title>
        <para>In Firebird 2.5 and above, it is possible to cast expressions to the type of an
        existing table or view column. Only the type itself is used; in the case of string types,
        this includes the character set but not the collation. Constraints and default values of the
        source column are not applied.</para>
      </formalpara>
      <blockquote>
        <programlisting>create table ttt (
  s varchar(40) character set utf8 collate unicode_ci_ai
);
commit;

select cast ('Jag har många vänner' as type of column ttt.s) from rdb$database;</programlisting>
      </blockquote>
      <warning>
        <title>Warnings</title>
        <itemizedlist>
          <listitem>
            <para>For text types, character set and collation are preserved by the cast – just as
            when casting to a domain. However, due to a bug, the collation is not always taken into
            consideration when comparisons (e.g. equality tests) are made. In cases where the
            collation is of importance, test your code thoroughly before deploying! This bug is
            fixed for Firebird 3.</para>
            <!--More specific: If the column has a direct type, comparisons igmore the collation even though output column
descriptions do include the collation. If the column has a domain type, comparisons function correctly.-->
          </listitem>
          <listitem>
            <para>If a column's definition is altered, existing <database>CAST</database>s to that
            column's type may become invalid. If these <database>CAST</database>s occur in PSQL
            modules, their invalidation may be detected. See the note <link
            linkend="langrefupd25-notes-rdbvalid_blr"><citetitle>The
            <database>RDB$VALID_BLR</database> field</citetitle></link>, near the end of this
            document.</para>
          </listitem>
        </itemizedlist>
      </warning>
      <formalpara>
        <title>Casting <database>BLOB</database>s</title>
        <para>Successful casting to and from <database>BLOB</database>s is possible since Firebird
        2.1.</para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-ceil">
      <title><database>CEIL()</database>, <database>CEILING()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the smallest whole number greater than or equal to the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database> or <database>DOUBLE PRECISION</database><!--DOUBLE PRECISION if arg is an SQL parameter--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CEIL[ING] (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-ceiling">external function
        <function>CEILING</function></link> is declared in your database, it will override the
        internal function <database>CEILING</database> (but not <database>CEIL</database>). To make
        the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-floor"><database>FLOOR()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-char_length">
      <title><database>CHAR_LENGTH()</database>, <database>CHARACTER_LENGTH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Gives the length in characters of the input string.</para>
      </formalpara>
      <note>
        <para>With arguments of type <database>CHAR</database>, this function returns the formal
        string length (i.e. the declared length of a field or variable). If you want to obtain the
        <quote>logical</quote> length, not counting the trailing spaces, right-<link
        linkend="langrefupd25-intfunc-trim"><database>TRIM</database></link> the argument before
        passing it to <database>CHAR[ACTER]_LENGTH</database>.</para>
        <!--This is the case when
- CASTing to CHAR(n)
- Reading a CHAR(n) variable or table field

But e.g. a SUBSTRING result, although formally of the same length as the first
argument, has a CHAR_LENGTH (and strlen) equal to the 'FOR' argument or the
length to the end of the string, e.g:
SUBSTRING('Hello' from 3 for 2) is a CHAR(5) with CHAR_LENGTH 2
SUBSTRING('Hello' from 2) is a CHAR(5) with CHAR_LENGTH 4
SUBSTRING('Hello' from 2 for 8) is a CHAR(5) with CHAR_LENGTH 4

However, as soon as you CAST such substrings to a CHAR(n) or store them
in a CHAR(n) field or variable, the CHAR_LENGTH becomes n.

Another example: if you have a char(12) column with the string 'AB', it has
a CHAR_LENGTH of 12 and concatenation with '.' shows the 10 spaces. Now if
you select SUBSTRING(field from 2 for 2), you get a CHAR(12) with CHAR_LENGTH 2.
You see only an A, but concatenation with '.' shows there's a space behind it.

The conclusion must be (I think) that SUBSTRING puts a zero character after the
result, or maybe fills the entire formal length with zero chars.-->
      </note>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CHAR_LENGTH (<replaceable>str</replaceable>)
CHARACTER_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title><database>BLOB</database> support</title>
        <para>Since Firebird 2.1, this function fully supports text <database>BLOB</database>s of
        any length and character set.</para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select char_length('Hello!') from rdb$database
  -- returns 6</programlisting>
            <programlisting>select char_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 8</programlisting>
            <programlisting>select char_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 8; the fact that ü and ß take up two bytes each is irrelevant</programlisting>
            <programlisting>select char_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 24: all 24 <database>CHAR</database> positions count</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-bit_length"><database>BIT_LENGTH()</database></link>, <link
        linkend="langrefupd25-intfunc-octet_length"><database>OCTET_LENGTH()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-char_to_uuid">
      <title><database>CHAR_TO_UUID()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Converts a human-readable 36-char UUID string to the corresponding 16-byte
        UUID.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>CHAR(16) CHARACTER SET OCTETS</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CHAR_TO_UUID (<replaceable>ascii_uuid</replaceable>)

<replaceable>ascii_uuid</replaceable>  ::=  a string of length 36 with:
                   * '-' (hyphen) at positions 9, 14, 19 and 24;
                   * valid hex digits at every other position.</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select char_to_uuid('A0bF4E45-3029-2a44-D493-4998c9b439A3') from rdb$database
-- returns A0BF4E4530292A44D4934998C9B439A3 (16-byte string)

select char_to_uuid('A0bF4E45-3029-2A44-X493-4998c9b439A3') from rdb$database
-- error: -Human readable UUID argument for CHAR_TO_UUID must
--         have hex digit at position 20 instead of "X (ASCII 88)"</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-uuid_to_char"><database>UUID_TO_CHAR()</database></link>,
        <link linkend="langrefupd25-intfunc-gen_uuid"><database>GEN_UUID()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-coalesce">
      <title><database>COALESCE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>COALESCE</database> function takes two or more arguments and returns the
        value of the first non-<constant>NULL</constant> argument. If all the arguments evaluate to
        <constant>NULL</constant>, the result is <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select 
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
  as FullName
from Persons</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This example picks the Nickname from the Persons table. If it happens to be
      <constant>NULL</constant>, it goes on to FirstName. If that too is <constant>NULL</constant>,
      <quote>Mr./Mrs.</quote> is used. Finally, it adds the family name. All in all, it tries to use
      the available data to compose a full name that is as informal as possible. Notice that this
      scheme only works if absent nicknames and first names are really <constant>NULL</constant>: if
      one of them is an empty string instead, <database>COALESCE</database> will happily return that
      to the caller.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>COALESCE</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd25-udf-nvl"><function>*nvl</function></link> external functions.</para>
      </note>
    </section>
    <section id="langrefupd25-intfunc-cos">
      <title><database>COS()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's cosine. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COS (<replaceable>angle</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>Any non-<constant>NULL</constant> result is – obviously – in the range [-1,
                1].</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-cos">external function
        <function>COS</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-cosh">
      <title><database>COSH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the hyperbolic cosine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COSH (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>Any non-<constant>NULL</constant> result is in the range [1, INF].</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-cosh">external function
        <function>COSH</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-cot">
      <title><database>COT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's cotangent. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COT (<replaceable>angle</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-cot">external function
        <function>COT</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-dateadd">
      <title><database>DATEADD()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Adds the specified number of years, months, weeks, days, hours, minutes, seconds or
        milliseconds to a date/time value. (The <database>WEEK</database> unit is new in
        2.5.)</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DATE</database>, <database>TIME</database> or
        <database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DATEADD (<replaceable>&lt;args&gt;</replaceable>)

<replaceable>&lt;args&gt;</replaceable>      ::=  <replaceable>&lt;amount&gt;</replaceable> <replaceable>&lt;unit&gt;</replaceable> TO <replaceable>&lt;datetime&gt;</replaceable>
                 | <replaceable>&lt;unit&gt;</replaceable>, <replaceable>&lt;amount&gt;</replaceable>, <replaceable>&lt;datetime&gt;</replaceable>

<replaceable>&lt;amount&gt;</replaceable>    ::=  an integer expression (negative to subtract)
<replaceable>&lt;unit&gt;</replaceable>      ::=  YEAR | MONTH | WEEK | DAY
                   | HOUR | MINUTE | SECOND | MILLISECOND
<replaceable>&lt;datetime&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
            <itemizedlist>
              <listitem>
                <para>The result type is determined by the third argument.</para>
              </listitem>
              <listitem>
                <para>With <database>TIMESTAMP</database> and <database>DATE</database> arguments,
                all units can be used. (Prior to Firebird 2.5, units smaller than
                <database>DAY</database> were disallowed for <database>DATE</database>s.)</para>
              </listitem>
              <listitem>
                <para>With <database>TIME</database> arguments, only <database>HOUR</database>,
                <database>MINUTE</database>, <database>SECOND</database> and
                <database>MILLISECOND</database> can be used.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>dateadd (28 day to current_date)
dateadd (-6 hour to current_time)
dateadd (month, 9, DateOfConception)
dateadd (-38 week to DateOfBirth)
dateadd (minute, 90, time 'now')
dateadd (? year to date '11-Sep-1973')</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-datediff">
      <title><database>DATEDIFF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the number of years, months, weeks, days, hours, minutes, seconds or
        milliseconds elapsed between two date/time values. (The <database>WEEK</database> unit is
        new in 2.5.)</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DATEDIFF (<replaceable>&lt;args&gt;</replaceable>)

<replaceable>&lt;args&gt;</replaceable>     ::=  <replaceable>&lt;unit&gt;</replaceable> FROM <replaceable>&lt;moment1&gt;</replaceable> TO <replaceable>&lt;moment2&gt;</replaceable>
                | <replaceable>&lt;unit&gt;</replaceable>, <replaceable>&lt;moment1&gt;</replaceable>, <replaceable>&lt;moment2&gt;</replaceable>

<replaceable>&lt;unit&gt;</replaceable>     ::=  YEAR | MONTH | WEEK | DAY
                  | HOUR | MINUTE | SECOND | MILLISECOND
<replaceable>&lt;momentN&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
            <itemizedlist>
              <listitem>
                <para><database>DATE</database> and <database>TIMESTAMP</database> arguments can be
                combined. No other mixes are allowed.</para>
              </listitem>
              <listitem>
                <para>With <database>TIMESTAMP</database> and <database>DATE</database> arguments,
                all units can be used. (Prior to Firebird 2.5, units smaller than
                <database>DAY</database> were disallowed for <database>DATE</database>s.)</para>
              </listitem>
              <listitem>
                <para>With <database>TIME</database> arguments, only <database>HOUR</database>,
                <database>MINUTE</database>, <database>SECOND</database> and
                <database>MILLISECOND</database> can be used.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Computation</title>
        <para><itemizedlist>
            <listitem>
              <para><database>DATEDIFF</database> doesn't look at any smaller units than the one
              specified in the first argument. As a result,</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para><quote><code>datediff (year, date '1-Jan-2009', date
                  '31-Dec-2009')</code></quote> returns 0, but</para>
                </listitem>
                <listitem>
                  <para><quote><code>datediff (year, date '31-Dec-2009', date
                  '1-Jan-2010')</code></quote> returns 1</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>It does, however, look at all the <emphasis>bigger</emphasis> units. So:</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para><quote><code>datediff (day, date '26-Jun-1908', date
                  '11-Sep-1973')</code></quote> returns 23818</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>A negative result value indicates that <replaceable>moment2</replaceable> lies
              before <replaceable>moment1</replaceable>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>datediff (hour from current_timestamp to timestamp '12-Jun-2059 06:00')
datediff (minute from time '0:00' to current_time)
datediff (month, current_date, date '1-1-1900')
datediff (day from current_date to cast(? as date))</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-decode">
      <title><database>DECODE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>DECODE</database> is a shortcut for the so-called <link
        linkend="langrefupd25-case-simple"><quote>simple <database>CASE</database></quote>
        construct</link>, in which a given expression is compared to a number of other expressions
        until a match is found. The result is determined by the value listed after the matching
        expression. If no match is found, the default result is returned, if present. Otherwise,
        <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECODE ( <replaceable>&lt;test-expr&gt;</replaceable>,
         <replaceable>&lt;expr&gt;</replaceable>, <replaceable>result</replaceable>
         [, <replaceable>&lt;expr&gt;</replaceable>, <replaceable>result</replaceable> ...]
         [, <replaceable>defaultresult</replaceable>] )</programlisting>
            <para>The equivalent CASE construct:</para>
            <programlisting>CASE <replaceable>&lt;test-expr&gt;</replaceable>
   WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>result</replaceable>
   [WHEN <replaceable>&lt;expr&gt;</replaceable> THEN <replaceable>result</replaceable> ...]
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            <!--Both for DECODE and CASE:
Determine whether and when to use <> with the replaceables, and BE CONSISTENT!-->
            <caution>
              <para>Matching is done with the <quote><literal>=</literal></quote> operator, so if
              <replaceable>&lt;test-expr&gt;</replaceable> is <constant>NULL</constant>, it won't
              match any of the <replaceable>&lt;expr&gt;</replaceable>s, not even those that are
              <constant>NULL</constant>.</para>
            </caution>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select name,
       age,
       decode( upper(sex),
               'M', 'Male',
               'F', 'Female',
               'Unknown' ),
       religion
from people</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-case"><database>CASE</database></link>, <link
        linkend="langrefupd25-case-simple">Simple <database>CASE</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-exp">
      <title><database>EXP()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the natural exponential,
        <emphasis>e</emphasis><superscript><replaceable>number</replaceable></superscript></para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXP (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-ln"><database>LN()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-extract">
      <title><database>EXTRACT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB 6</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Extracts and returns an element from a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database> expression. This function was
        already added in InterBase 6, but not documented in the <citetitle>Language
        Reference</citetitle> at the time.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>SMALLINT</database> or <database>NUMERIC</database><!--or DECIMAL?--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | WEEK
                   | DAY | WEEKDAY | YEARDAY
                   | HOUR | MINUTE | SECOND | MILLISECOND
<replaceable>&lt;datetime&gt;</replaceable>  ::=  a DATE, TIME or TIMESTAMP expression</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The returned datatypes and possible ranges are shown in the table below. If you try to
      extract a part that isn't present in the date/time argument (e.g. <database>SECOND</database>
      from a <database>DATE</database> or <database>YEAR</database> from a
      <database>TIME</database>), an error occurs.</para>
      <table id="langrefupd25-tbl-extractranges">
        <title>Types and ranges of <database>EXTRACT</database> results</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>Part</entry>
              <entry>Type</entry>
              <entry>Range</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><database>YEAR</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>1–9999</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MONTH</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>1–12</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>WEEK</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>1–53</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>DAY</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>1–31</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>WEEKDAY</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>0–6</entry>
              <entry>0 = Sunday</entry>
            </row>
            <row>
              <entry><database>YEARDAY</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>0–365</entry>
              <entry>0 = January 1</entry>
            </row>
            <row>
              <entry><database>HOUR</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>0–23</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MINUTE</database></entry>
              <entry><database>SMALLINT</database></entry>
              <entry>0–59</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>SECOND</database></entry>
              <entry><database>NUMERIC(9,4)</database></entry>
              <entry>0.0000–59.9999</entry>
              <entry>includes millisecond as fraction</entry>
            </row>
            <row>
              <entry><database>MILLISECOND</database></entry>
              <entry><database>NUMERIC(9,1)</database></entry>
              <entry>0.0–999.9</entry>
              <entry>broken in 2.1, 2.1.1</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <section id="langrefupd25-intfunc-extract-millisecond">
        <title><database>MILLISECOND</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.1 (with bug)<!--CORE-1962, fixed by Adriano--></para>
        </formalpara>
        <formalpara>
          <title>Fixed in</title>
          <para>2.1.2</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2.1 and up support extraction of the millisecond from a
          <database>TIME</database> or <database>TIMESTAMP</database>. The datatype returned is
          <database>NUMERIC(9,1)</database>.</para>
        </formalpara>
        <note>
          <para>If you extract the millisecond from <link
          linkend="langrefupd25-current_time"><database>CURRENT_TIME</database></link>, be aware
          that this variable defaults to seconds precision, so the result will always be 0. Extract
          from <database>CURRENT_TIME(3)</database> or <link
          linkend="langrefupd25-current_timestamp"><database>CURRENT_TIMESTAMP</database></link> to
          get milliseconds precision.</para>
        </note>
      </section>
      <section id="langrefupd25-intfunc-extract-week">
        <title><database>WEEK</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2.1 and up support extraction of the ISO-8601 week number from a
          <database>DATE</database> or <database>TIMESTAMP</database>. ISO-8601 weeks start on a
          Monday and always have the full seven days. Week 1 is the first week that has a majority
          (at least 4) of its days in the new year. The first 1–3 days of the year may belong to the
          last week (52 or 53) of the previous year. Likewise, a year's final 1–3 days may belong to
          week 1 of the following year.</para>
        </formalpara>
        <caution>
          <para>Be careful when combining <database>WEEK</database> and <database>YEAR</database>
          results. For instance, 30 December 2008 lies in week 1 of 2009, so <quote><code>extract
          (week from date '30 Dec 2008')</code></quote> returns 1. However, extracting
          <database>YEAR</database> always gives the calendar year, which is 2008. In this case,
          <database>WEEK</database> and <database>YEAR</database> are at odds with each other. The
          same happens when the first days of January belong to the last week of the previous
          year.</para>
          <para>Please also notice that <database>WEEKDAY</database> is <emphasis>not</emphasis>
          ISO-8601 compliant: it returns 0 for Sunday, whereas ISO-8601 specifies 7.</para>
        </caution>
      </section>
    </section>
    <section id="langrefupd25-intfunc-floor">
      <title><database>FLOOR()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the largest whole number smaller than or equal to the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database> or <database>DOUBLE PRECISION</database><!--DOUBLE PRECISION if arg is an SQL parameter--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>FLOOR (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-floor">external function
        <function>FLOOR</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-ceil"><database>CEIL()</database> /
        <database>CEILING()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-gen_id">
      <title><database>GEN_ID()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Increments a generator or sequence and returns its new value. From Firebird 2.0
        onward, the SQL-compliant <database>NEXT VALUE FOR</database> syntax is preferred, except
        when an increment other than 1 is needed.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>GEN_ID (<replaceable>generator-name</replaceable>, <replaceable>&lt;step&gt;</replaceable>)

<replaceable>&lt;step&gt;</replaceable>  ::=  An integer expression.</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>new.rec_id = gen_id(gen_recnum, 1);</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>Unless you know very well what you are doing, using <database>GEN_ID()</database> with
        step values lower than 1 may compromise your data's integrity.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-nextvaluefor"><database>NEXT VALUE FOR</database></link>,
        <link linkend="langrefupd25-create-gen"><database>CREATE GENERATOR</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-gen_uuid">
      <title><database>GEN_UUID()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a universally unique ID as a 16-byte character string.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>CHAR(16) CHARACTER SET OCTETS</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>GEN_UUID ()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select gen_uuid() from rdb$database
-- returns e.g. 017347BFE212B2479C00FA4323B36320 (16-byte string)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-uuid_to_char"><database>UUID_TO_CHAR()</database></link>,
        <link
        linkend="langrefupd25-intfunc-char_to_uuid"><database>CHAR_TO_UUID()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-hash">
      <title><database>HASH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a hash value for the input string. This function fully supports text
        <database>BLOB</database>s of any length and character set.</para>
        <!--This function seems rather crummy. It's only 64-bit, and for shorter strings it returns smaller numbers.
For single ASCII characters it simply returns the ASCII code.-->
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>HASH (<replaceable>string</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-iif">
      <title><database>IIF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>IIF</database> takes three arguments. If the first evaluates to
        <constant>true</constant>, the second argument is returned; otherwise the third is
        returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>IIF (<replaceable>&lt;condition&gt;</replaceable>, <replaceable>ResultT</replaceable>, <replaceable>ResultF</replaceable>)

<replaceable>&lt;condition&gt;</replaceable>  ::=  A boolean expression.</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select iif( sex = 'M', 'Sir', 'Madam' ) from Customers</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>IIF</database>(<parameter>Cond</parameter>, <parameter>Result1</parameter>,
      <parameter>Result2</parameter>) is a shortcut for <quote><database>CASE</database>
      <database>WHEN</database> <parameter>Cond</parameter> <database>THEN</database>
      <parameter>Result1</parameter> <database>ELSE</database> <parameter>Result2</parameter>
      <database>END</database></quote>. You can also compare <database>IIF</database> to the ternary
      <quote><literal>?</literal> <literal>:</literal></quote> operator in C-like languages.</para>
    </section>
    <section id="langrefupd25-intfunc-left">
      <title><database>LEFT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the leftmost part of the argument string. The number of characters is given in
        the second argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LEFT (<replaceable>string</replaceable>, <replaceable>length</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>This function fully supports text <database>BLOB</database>s of any length,
                including those with a multi-byte character set.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>string</replaceable> is a <database>BLOB</database>, the
                result is a <database>BLOB</database>. Otherwise, the result is a
                <database>VARCHAR(<replaceable>n</replaceable>)</database> with
                <replaceable>n</replaceable> the length of the input string.</para>
              </listitem>
              <listitem>
                <para>If the <replaceable>length</replaceable> argument exceeds the string length,
                the input string is returned unchanged.</para>
              </listitem>
              <listitem>
                <para>If the <replaceable>length</replaceable> argument is not a whole number,
                bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5
                becomes 2, 3.5 becomes 4, etc.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-right"><database>RIGHT()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-ln">
      <title><database>LN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the natural logarithm of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LN (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>An error is raised if the argument is negative or 0.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-ln">external function
        <function>LN</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-exp"><database>EXP()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-log">
      <title><database>LOG()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the <replaceable>x</replaceable>-based logarithm of
        <replaceable>y</replaceable>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LOG (<replaceable>x</replaceable>, <replaceable>y</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>If either argument is 0 or below, an error is raised. (Before 2.5, this would
                result in <constant>NaN</constant>, <constant>±INF</constant> or 0, depending on the
                exact values of the arguments.)</para>
              </listitem>
              <listitem>
                <para>If both arguments are 1, <constant>NaN</constant> is returned.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>x</replaceable> = 1 and <replaceable>y</replaceable> &lt; 1,
                -<constant>INF</constant> is returned.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>x</replaceable> = 1 and <replaceable>y</replaceable> &gt; 1,
                <constant>INF</constant> is returned.</para>
              </listitem>
            </itemizedlist>
            <!--See CORE-1936: In 2.1, this was a mess.-->
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-log">external function
        <function>LOG</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-log10">
      <title><database>LOG10()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the 10-based logarithm of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LOG10 (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>An error is raised if the argument is negative or 0. (In versions prior to
                2.5, such values would result in <constant>NaN</constant> and
                -<constant>INF</constant>, respectively.)</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-log10">external function
        <function>LOG10</function></link> is declared in your database, it will override the
        internal function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-lower">
      <title><database>LOWER()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the lower-case equivalent of the input string. The exact result depends on the
        character set. With <database>ASCII</database> or <database>NONE</database> for instance,
        only ASCII characters are lowercased; with <database>OCTETS</database>, the entire string is
        returned unchanged. Since Firebird 2.1 this function also fully supports text
        <database>BLOB</database>s of any length and character set.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>(VAR)CHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LOWER (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <para>Because <database>LOWER</database> is a reserved word, the internal function wil take
        precedence even if the <link linkend="langrefupd25-udf-lower">external function by that
        name</link> has also been declared. To call the (inferior!) external function, use
        double-quotes and the exact capitalisation, as in
        <function>"LOWER"</function>(<replaceable>str</replaceable>).</para>
      </note>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select Sheriff from Towns
  where lower(Name) = 'cooper''s valley'</programlisting>
            <!--Maybe add some examples that show the workings with accented characters in different character sets.
E.g. lower(_octets HÓPLÄ)  lower(_ascii 'HÓPLÄ') vs. lower(_iso8859_1 'HÓPLÄ').
Do likewise for UPPER().-->
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-upper"><database>UPPER</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-lpad">
      <title><database>LPAD()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5 (backported to 2.1.4)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Left-pads a string with spaces or with a user-supplied string until a given length is
        reached.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LPAD (<replaceable>str</replaceable>, <replaceable>endlen</replaceable> [, <replaceable>padstr</replaceable>])</programlisting>
            <itemizedlist>
              <listitem>
                <para>This function fully supports text <database>BLOB</database>s of any length and
                character set.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>str</replaceable> is a <database>BLOB</database>, the result
                is a <database>BLOB</database>. Otherwise, the result is a
                <database>VARCHAR</database>(<replaceable>endlen</replaceable>).</para>
              </listitem>
              <listitem>
                <para>If <replaceable>padstr</replaceable> is given and equals <literal>''</literal>
                (empty string), no padding takes place.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>endlen</replaceable> is less than the current string length,
                the string is truncated to <replaceable>endlen</replaceable>, even if
                <replaceable>padstr</replaceable> is the empty string.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-lpad">external function
        <function>LPAD</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <note>
        <para>In Firebird 2.1–2.1.3, all non-BLOB results were of type
        <database>VARCHAR</database>(32765), which made it advisable to cast them to a more modest
        size. This is no longer the case.</para>
        <!--CORE-1346, backported to 2.1.4
Actually, the length was 32765 for single-byte charsets, 8191 for UTF8, etc.-->
      </note>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para><programlisting>lpad ('Hello', 12)                 -- returns '       Hello'
lpad ('Hello', 12, '-')            -- returns '-------Hello'
lpad ('Hello', 12, '')             -- returns 'Hello'
lpad ('Hello', 12, 'abc')          -- returns 'abcabcaHello'
lpad ('Hello', 12, 'abcdefghij')   -- returns 'abcdefgHello'
lpad ('Hello', 2)                  -- returns 'He'
lpad ('Hello', 2, '-')             -- returns 'He'
lpad ('Hello', 2, '')              -- returns 'He'</programlisting></para>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. Although it does try to limit memory consumption, this may affect
        performance if huge <database>BLOB</database>s are involved.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-rpad"><database>RPAD()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-maxvalue">
      <title><database>MAXVALUE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the maximum value from a list of numerical, string, or date/time expressions.
        This function fully supports text <database>BLOB</database>s of any length and character
        set.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>MAXVALUE (<replaceable>expr</replaceable> [, <replaceable>expr</replaceable> ...])</programlisting>
            <itemizedlist>
              <listitem>
                <para>If one or more expressions resolve to <constant>NULL</constant>,
                <database>MAXVALUE</database> returns <constant>NULL</constant>. This behaviour
                differs from the aggregate function <database>MAX</database>.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-minvalue"><database>MINVALUE()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-minvalue">
      <title><database>MINVALUE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the minimum value from a list of numerical, string, or date/time expressions.
        This function fully supports text <database>BLOB</database>s of any length and character
        set.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>MINVALUE (<replaceable>expr</replaceable> [, <replaceable>expr</replaceable> ...])</programlisting>
            <itemizedlist>
              <listitem>
                <para>If one or more expressions resolve to <constant>NULL</constant>,
                <database>MINVALUE</database> returns <constant>NULL</constant>. This behaviour
                differs from the aggregate function <database>MIN</database>.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-maxvalue"><database>MAXVALUE()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-mod">
      <title><database>MOD()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the remainder of an integer division.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> or <database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>MOD (<replaceable>a</replaceable>, <replaceable>b</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>Non-integer arguments are rounded before the division takes place. So,
                <quote>7.5 mod 2.5</quote> gives 2 (8 mod 3), not 0.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-mod">external function
        <function>MOD</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-nullif">
      <title><database>NULLIF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>NULLIF</database> returns the value of the first argument, unless it is
        equal to the second. In that case, <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This will return the average weight of the persons listed in FatPeople, excluding those
      having a weight of -1, since <database>AVG</database> skips <constant>NULL</constant> data.
      Presumably, -1 indicates <quote>weight unknown</quote> in this table. A plain
      <database>AVG</database>(Weight) would include the -1 weights, thus skewing the result.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>NULLIF</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd25-udf-nullif"><function>*nullif</function></link> external
        functions.</para>
      </note>
    </section>
    <section id="langrefupd25-intfunc-octet_length">
      <title><database>OCTET_LENGTH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Gives the length in bytes (octets) of the input string. For multi-byte character sets,
        this may be less than the number of characters times the <quote>formal</quote> number of
        bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
      </formalpara>
      <note>
        <para>With arguments of type <database>CHAR</database>, this function takes the entire
        formal string length (e.g. the declared length of a field or variable) into account. If you
        want to obtain the <quote>logical</quote> byte length, not counting the trailing spaces,
        right-<link linkend="langrefupd25-intfunc-trim"><database>TRIM</database></link> the
        argument before passing it to <database>OCTET_LENGTH</database>.</para>
      </note>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>OCTET_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title><database>BLOB</database> support</title>
        <para>Since Firebird 2.1, this function fully supports text <database>BLOB</database>s of
        any length and character set.</para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select octet_length('Hello!') from rdb$database
  -- returns 6</programlisting>
            <programlisting>select octet_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 8: ü and ß take up one byte each in ISO8859_1</programlisting>
            <programlisting>select octet_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 10: ü and ß take up two bytes each in UTF8</programlisting>
            <programlisting>select octet_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 26: all 24 <database>CHAR</database> positions count, and two of them are 2-byte</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-bit_length"><database>BIT_LENGTH()</database></link>, <link
        linkend="langrefupd25-intfunc-char_length"><database>CHARACTER_LENGTH()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-overlay">
      <title><database>OVERLAY()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Overwrites part of a string with another string. By default, the number of characters
        removed from the host string equals the length of the replacement string. With the optional
        fourth argument, the user can specify a different number of characters to be removed.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>OVERLAY (<replaceable>string</replaceable> PLACING <replaceable>replacement</replaceable> FROM <replaceable>pos</replaceable> [FOR <replaceable>length</replaceable>])</programlisting>
            <itemizedlist>
              <listitem>
                <para>This function supports <database>BLOB</database>s of any length.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>string</replaceable> or <replaceable>replacement</replaceable>
                is a <database>BLOB</database>, the result is a <database>BLOB</database>.
                Otherwise, the result is a <database>VARCHAR(<replaceable>n</replaceable>) with
                <replaceable>n</replaceable> the sum of the lengths of
                <replaceable>string</replaceable> and
                <replaceable>replacement</replaceable>.</database></para>
              </listitem>
              <listitem>
                <para>As usual in SQL string functions, <replaceable>pos</replaceable> is
                1-based.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>pos</replaceable> is beyond the end of
                <replaceable>string</replaceable>, <replaceable>replacement</replaceable> is placed
                directly after <replaceable>string.</replaceable></para>
              </listitem>
              <listitem>
                <para>If the number of characters from <replaceable>pos</replaceable> to the end of
                <replaceable>string</replaceable> is smaller than the length of
                <replaceable>replacement</replaceable> (or than the
                <replaceable>length</replaceable> argument, if present),
                <replaceable>string</replaceable> is truncated at <replaceable>pos</replaceable> and
                <replaceable>replacement</replaceable> placed after it.</para>
              </listitem>
              <listitem>
                <para>The effect of a <quote><database>FOR</database> 0</quote> clause is that
                <replaceable>replacement</replaceable> is simply inserted into
                <replaceable>string</replaceable>.</para>
              </listitem>
              <listitem>
                <para>If any argument is <constant>NULL</constant>, the result is
                <constant>NULL</constant>.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>pos</replaceable> or <replaceable>length</replaceable> is not
                a whole number, bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0,
                1.5 becomes 2, 2.5 becomes 2, 3.5 becomes 4, etc.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>overlay ('Goodbye' placing 'Hello' from 2)    -- returns 'GHelloe'
overlay ('Goodbye' placing 'Hello' from 5)    -- returns 'GoodHello'
overlay ('Goodbye' placing 'Hello' from 8)    -- returns 'GoodbyeHello'
overlay ('Goodbye' placing 'Hello' from 20)   -- returns 'GoodbyeHello'

overlay ('Goodbye' placing 'Hello' from 2 for 0)   -- r. 'GHellooodbye'
overlay ('Goodbye' placing 'Hello' from 2 for 3)   -- r. 'GHellobye'
overlay ('Goodbye' placing 'Hello' from 2 for 6)   -- r. 'GHello'
overlay ('Goodbye' placing 'Hello' from 2 for 9)   -- r. 'GHello'

overlay ('Goodbye' placing '' from 4)         -- returns 'Goodbye'
overlay ('Goodbye' placing '' from 4 for 3)   -- returns 'Gooe'
overlay ('Goodbye' placing '' from 4 for 20)  -- returns 'Goo'

overlay ('' placing 'Hello' from 4)           -- returns 'Hello'
overlay ('' placing 'Hello' from 4 for 0)     -- returns 'Hello'
overlay ('' placing 'Hello' from 4 for 20)    -- returns 'Hello'</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. This may affect performance if huge <database>BLOB</database>s are
        involved.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-replace"><database>REPLACE()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-pi">
      <title><database>PI()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an approximation of the value of π.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>PI ()</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-pi">external function
        <function>PI</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-position">
      <title><database>POSITION()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the (1-based) position of the first occurrence of a substring in a host
        string. With the optional third argument, the search starts at a given offset, disregarding
        any matches that may occur earlier in the string. If no match is found, the result is
        0.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>POSITION (<replaceable>&lt;args&gt;</replaceable>)

<replaceable>&lt;args&gt;</replaceable>  ::=  <replaceable>substr</replaceable> IN <replaceable>string</replaceable>
             | <replaceable>substr</replaceable>, <replaceable>string</replaceable> [, <replaceable>startpos</replaceable>]</programlisting>
            <itemizedlist>
              <listitem>
                <para>The <database>optional third argument is only supported in the second syntax
                (comma syntax).</database></para>
              </listitem>
              <listitem>
                <para>The empty string is considered a substring of every string. Therefore, if
                <replaceable>substr</replaceable> is '' (empty string) and
                <replaceable>string</replaceable> is not <constant>NULL</constant>, the result
                is:</para>
                <itemizedlist spacing="compact">
                  <listitem>
                    <para>1 if <replaceable>startpos</replaceable> is not given;</para>
                  </listitem>
                  <listitem>
                    <para><replaceable>startpos</replaceable> if <replaceable>startpos</replaceable>
                    lies within <replaceable>string</replaceable>;</para>
                  </listitem>
                  <listitem>
                    <para>0 if <replaceable>startpos</replaceable> lies beyond the end of
                    <replaceable>string</replaceable>.</para>
                  </listitem>
                </itemizedlist>
                <para><emphasis role="bold">Notice:</emphasis> A bug in Firebird 2.1–2.1.3 and 2.5
                causes <database>POSITION</database> to <emphasis>always</emphasis> return 1 if
                <replaceable>substr</replaceable> is the empty string. This is fixed in 2.1.4 and
                2.5.1.</para>
                <!--If startpos present, result should be startpos if inside string, and 0 if past string. CORE-3244.
Fixed in 2.1.4, 2.5.1, 3.0-->
              </listitem>
              <listitem>
                <para>This function fully supports text <database>BLOB</database>s of any size and
                character set.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>position ('be' in 'To be or not to be')      -- returns 4
position ('be', 'To be or not to be')        -- returns 4
position ('be', 'To be or not to be', 4)     -- returns 4
position ('be', 'To be or not to be', 8)     -- returns 17
position ('be', 'To be or not to be', 18)    -- returns 0
position ('be' in 'Alas, poor Yorick!')      -- returns 0</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. This may affect performance if huge <database>BLOB</database>s are
        involved.</para>
      </warning>
    </section>
    <section id="langrefupd25-intfunc-power">
      <title><database>POWER()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th
        power.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>POWER (<replaceable>x</replaceable>, <replaceable>y</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>If <replaceable>x</replaceable> negative, an error is raised.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-dpower">external function
        <function>POWER</function></link> is declared in your database as <function>power</function>
        instead of the default <function>dPower</function>, it will override the internal function.
        To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-rand">
      <title><database>RAND()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a random number between 0 and 1.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RAND ()</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-rand">external function
        <function>RAND</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-get_context">
      <title><database>RDB$GET_CONTEXT()</database></title>
      <note>
        <para><database>RDB$GET_CONTEXT</database> and its counterpart
        <database>RDB$SET_CONTEXT</database> are actually predeclared UDFs. They are listed here as
        internal functions because they are always present – the user doesn't have to do anything to
        make them available.</para>
      </note>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Since it's a declared UDF, it should be availabe in ESQL-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Retrieves the value of a context variable from one of the namespaces
        <database>SYSTEM</database>, <database>USER_SESSION</database> and
        <database>USER_TRANSACTION</database>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(255)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RDB$GET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>')

<replaceable>&lt;namespace&gt;</replaceable>  ::=  SYSTEM | USER_SESSION | USER_TRANSACTION
<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title role="block">The namespaces</title>
        <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
        namespaces are initially empty. The user can create and set variables in them with
        <database>RDB$SET_CONTEXT()</database> and retrieve them with
        <database>RDB$GET_CONTEXT()</database>. The <database>SYSTEM</database> namespace is
        read-only. It contains a number of predefined variables, shown in the table below.<table
            border="topbot" id="langrefupd25-tbl-systemnamespace">
            <title>Context variables in the SYSTEM namespace</title>
            <tgroup cols="2">
              <colspec colname="colVarname" colwidth="1*" />
              <colspec colname="colVardescr" colwidth="3*" />
              <tbody>
                <row valign="top">
                  <entry><varname>DB_NAME</varname></entry>
                  <entry>Either the full path to the database or – if connecting via the path is
                  disallowed – its alias.</entry>
                </row>
                <row valign="top">
                  <entry><varname>NETWORK_PROTOCOL</varname></entry>
                  <entry>The protocol used for the connection: <literal>'TCPv4'</literal>,
                  <literal>'WNET'</literal>, <literal>'XNET'</literal> or
                  <constant>NULL</constant>.</entry>
                </row>
                <row valign="top">
                  <entry><varname>CLIENT_ADDRESS</varname></entry>
                  <entry>For TCPv4, this is the IP address. For XNET, the local process ID. For all
                  other protocols this variable is <constant>NULL</constant>.</entry>
                </row>
                <row valign="top">
                  <entry><varname>CURRENT_USER</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd25-current_user"><varname>CURRENT_USER</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>CURRENT_ROLE</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd25-current_role"><varname>CURRENT_ROLE</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>SESSION_ID</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd25-current_connection"><varname>CURRENT_CONNECTION</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>TRANSACTION_ID</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd25-current_transaction"><varname>CURRENT_TRANSACTION</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>ISOLATION_LEVEL</varname></entry>
                  <entry>The isolation level of the current transaction: <literal>'READ</literal>
                  <literal>COMMITTED'</literal>, <literal>'SNAPSHOT'</literal> or
                  <literal>'CONSISTENCY'</literal>.</entry>
                </row>
                <row valign="top">
                  <entry><varname>ENGINE_VERSION</varname></entry>
                  <entry>The Firebird engine (server) version. Added in 2.1.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </formalpara>
      <formalpara>
        <title>Return values and error behaviour</title>
        <para>If the polled variable exists in the given namespace, its value will be returned as a
        string of max. 255 characters. If the namespace doesn't exist or if you try to access a
        non-existing variable in the <database>SYSTEM</database> namespace, an error is raised. If
        you poll a non-existing variable in one of the other namespaces, <constant>NULL</constant>
        is returned. Both namespace and variable names must be given as single-quoted,
        case-sensitive, non-<constant>NULL</constant> strings.</para>
        <!--Funny enough, a variable's name may be the empty string.-->
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database</programlisting>
          </blockquote><blockquote>
            <programlisting>New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');</programlisting>
            <programlisting>insert into MyTable (TestField)
  values (rdb$get_context('USER_SESSION', 'MyVar'))</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-set_context"><database>RDB$SET_CONTEXT()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-set_context">
      <title><database>RDB$SET_CONTEXT()</database></title>
      <note>
        <para><database>RDB$SET_CONTEXT</database> and its counterpart
        <database>RDB$GET_CONTEXT</database> are actually predeclared UDFs. They are listed here as
        internal functions because they are always present – the user doesn't have to do anything to
        make them available.</para>
      </note>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Since it's a declared UDF, it should be availabe in ESQL-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates, sets or unsets a variable in one of the user-writable namespaces
        <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RDB$SET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>', <replaceable>&lt;value&gt;</replaceable> | <constant>NULL</constant>)

<replaceable>&lt;namespace&gt;</replaceable>  ::=  USER_SESSION | USER_TRANSACTION
<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters
<replaceable>&lt;value&gt;</replaceable>      ::=  A value of any type, as long as it's castable
                  to a VARCHAR(255)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title role="block">The namespaces</title>
        <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
        namespaces are initially empty. The user can create and set variables in them with
        <database>RDB$SET_CONTEXT()</database> and retrieve them with
        <database>RDB$GET_CONTEXT()</database>. The <database>USER_SESSION</database> context is
        bound to the current connection. Variables in <database>USER_TRANSACTION</database> only
        exist in the transaction in which they have been set. When the transaction ends, the context
        and all the variables defined in it are destroyed.</para>
      </formalpara>
      <formalpara>
        <title role="block">Return values and error behaviour</title>
        <para>The function returns 1 if the variable already existed before the call and 0 if it
        didn't. To remove a variable from a context, set it to <constant>NULL</constant>. If the
        given namespace doesn't exist, an error is raised. Both namespace and variable names must be
        entered as single-quoted, case-sensitive, non-<constant>NULL</constant> strings.</para>
        <!--Funny enough, a variable's name may be the empty string.-->
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database</programlisting>
          </blockquote><blockquote>
            <programlisting>rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);</programlisting>
            <programlisting>select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
  from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The maximum number of variables in any single context is 1000.</para>
            </listitem>
            <listitem>
              <para>All <database>USER_TRANSACTION</database> variables will survive a <link
              linkend="langrefupd25-rollback-retain"><database>ROLLBACK RETAIN</database></link> or
              <link linkend="langrefupd25-rollback-to-savepoint"><database>ROLLBACK TO
              SAVEPOINT</database></link> unaltered, no matter at which point during the transaction
              they were set.</para>
            </listitem>
            <listitem>
              <para>Due to its UDF-like nature, <database>RDB$SET_CONTEXT</database> can – in PSQL
              only – be called like a void function, without assigning the result, as in the second
              example above. Regular internal functions don't allow this type of use.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-get_context"><database>RDB$GET_CONTEXT()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-replace">
      <title><database>REPLACE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Replaces all occurrences of a substring in a string.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>REPLACE (<replaceable>str</replaceable>, <replaceable>find</replaceable>, <replaceable>repl</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>This function fully supports text <database>BLOB</database>s of any length and
                character set.</para>
              </listitem>
              <listitem>
                <para>If any argument is a <database>BLOB</database>, the result is a
                <database>BLOB</database>. Otherwise, the result is a
                <database>VARCHAR(<replaceable>n</replaceable>) with <replaceable>n</replaceable>
                calculated from the lengths of <replaceable>str</replaceable>,
                <replaceable>find</replaceable> and <replaceable>repl</replaceable> in such a way
                that even the maximum possible number of replacements won't overflow the
                field.</database></para>
              </listitem>
              <listitem>
                <para>If <replaceable>find</replaceable> is the empty string,
                <replaceable>str</replaceable> is returned unchanged.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>repl</replaceable> is the empty string, all occurrences of
                <replaceable>find</replaceable> are deleted from
                <replaceable>str</replaceable>.</para>
              </listitem>
              <listitem>
                <para>If any argument is <constant>NULL</constant>, the result is always
                <constant>NULL</constant>, even if nothing would have been replaced.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>replace ('Billy Wilder',  'il', 'oog')     -- returns 'Boogly Woogder'
replace ('Billy Wilder',  'il',    '')     -- returns 'Bly Wder'
replace ('Billy Wilder',  null, 'oog')     -- returns <constant>NULL</constant>
replace ('Billy Wilder',  'il',  null)     -- returns <constant>NULL</constant>
replace ('Billy Wilder', 'xyz',  null)     -- returns <constant>NULL</constant> (!)
replace ('Billy Wilder', 'xyz', 'abc')     -- returns 'Billy Wilder'
replace ('Billy Wilder',    '', 'abc')     -- returns 'Billy Wilder'</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. This may affect performance if huge <database>BLOB</database>s are
        involved.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-overlay"><database>OVERLAY()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-reverse">
      <title><database>REVERSE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string backwards.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>REVERSE (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>reverse ('spoonful')                 -- returns 'lufnoops'
reverse ('Was it a cat I saw?')      -- returns '?was I tac a ti saW'</programlisting>
          </blockquote></para>
      </formalpara>
      <tip>
        <para>This function comes in very handy if you want to group, search or order on string
        endings, e.g. when dealing with domain names or email addresses:</para>
        <programlisting>create index ix_people_email on people
  computed by (reverse(email));

select * from people
  where reverse(email) starting with reverse('.br');</programlisting>
      </tip>
    </section>
    <section id="langrefupd25-intfunc-right">
      <title><database>RIGHT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the rightmost part of the argument string. The number of characters is given
        in the second argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RIGHT (<replaceable>string</replaceable>, <replaceable>length</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>This function supports text <database>BLOB</database>s of any length, but has
                a bug in versions 2.1–2.1.3 and 2.5 that makes it fail with text
                <database>BLOB</database>s larger than 1024 bytes that have a multi-byte character
                set. This has been fixed in versions 2.1.4 and 2.5.1.<!--Reported as CORE-3228. Bug present in 2.1-2.1.3 and 2.5 - fixed for 2.1.4, 2.5.1, 3.0
Notice: the limit is 1024 BYTES, not characters.--></para>
              </listitem>
              <listitem>
                <para>If <replaceable>string</replaceable> is a <database>BLOB</database>, the
                result is a <database>BLOB</database>. Otherwise, the result is a
                <database>VARCHAR(<replaceable>n</replaceable>)</database> with
                <replaceable>n</replaceable> the length of the input string.</para>
              </listitem>
              <listitem>
                <para>If the <replaceable>length</replaceable> argument exceeds the string length,
                the input string is returned unchanged.</para>
              </listitem>
              <listitem>
                <para>If the <replaceable>length</replaceable> argument is not a whole number,
                bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5
                becomes 2, 3.5 becomes 4, etc.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. This may affect performance if huge <database>BLOB</database>s are
        involved.</para>
      </warning>
      <important>
        <para>If the <link linkend="langrefupd25-udf-sright">external function
        <function>RIGHT</function></link> is declared in your database as <function>right</function>
        instead of the default <function>sright</function>, it will override the internal function.
        To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-left"><database>LEFT()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-round">
      <title><database>ROUND()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Rounds a number to the nearest integer. If the fractional part is exactly
        <literal>0.5</literal>, rounding is upward for positive numbers and downward for negative
        numbers. With the optional <parameter>scale</parameter> argument, the number can be rounded
        to powers-of-ten multiples (tens, hundreds, tenths, hundredths, etc.) instead of just
        integers.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database>, (scaled) <database>BIGINT</database> or
        <database>DOUBLE</database></para>
        <!--DOUBLE if the first arg is a statement parameter-->
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ROUND (<replaceable>&lt;number&gt;</replaceable> [, <replaceable>&lt;scale&gt;</replaceable>])

<replaceable>&lt;number&gt;</replaceable>  ::=  a numerical expression
<replaceable>&lt;scale&gt;</replaceable>   ::=  an integer specifying the number of decimal places
               toward which should be rounded, e.g.:
                  2 for rounding to the nearest multiple of 0.01
                  1 for rounding to the nearest multiple of 0.1
                  0 for rounding to the nearest whole number
                 -1 for rounding to the nearest multiple of 10
                 -2 for rounding to the nearest multiple of 100</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>If the <parameter>scale</parameter> argument is present, the result usually has
              the same scale as the first argument, e.g.</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>ROUND(123.654, 1) returns 123.700 (not 123.7)</para>
                </listitem>
                <listitem>
                  <para>ROUND(8341.7, -3) returns 8000.0 (not 8000)</para>
                </listitem>
                <listitem>
                  <para>ROUND(45.1212, 0) returns 45.0000 (not 45)</para>
                </listitem>
              </itemizedlist>
              <para>Otherwise, the result scale is 0:</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>ROUND(45.1212) returns 45</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <important>
        <itemizedlist>
          <listitem>
            <para>If the <link linkend="langrefupd25-udf-round">external function
            <function>ROUND</function></link> is declared in your database, it will override the
            internal function. To make the internal function available, <link
            linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
            linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
            function (UDF).</para>
            <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
          </listitem>
          <listitem>
            <para>If you are used to the behaviour of the external function
            <function>ROUND</function>, please notice that the <emphasis>internal</emphasis>
            function always rounds halves away from zero, i.e. downward for negative numbers.</para>
          </listitem>
        </itemizedlist>
      </important>
    </section>
    <section id="langrefupd25-intfunc-rpad">
      <title><database>RPAD()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.5 (backported to 2.1.4)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Right-pads a string with spaces or with a user-supplied string until a given length is
        reached.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RPAD (<replaceable>str</replaceable>, <replaceable>endlen</replaceable> [, <replaceable>padstr</replaceable>])</programlisting>
            <itemizedlist>
              <listitem>
                <para>This function fully supports text <database>BLOB</database>s of any length and
                character set.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>str</replaceable> is a <database>BLOB</database>, the result
                is a <database>BLOB</database>. Otherwise, the result is a
                <database>VARCHAR</database>(<replaceable>endlen</replaceable>).</para>
              </listitem>
              <listitem>
                <para>If <replaceable>padstr</replaceable> is given and equals <literal>''</literal>
                (empty string), no padding takes place.</para>
              </listitem>
              <listitem>
                <para>If <replaceable>endlen</replaceable> is less than the current string length,
                the string is truncated to <replaceable>endlen</replaceable>, even if
                <replaceable>padstr</replaceable> is the empty string.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-rpad">external function
        <function>RPAD</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
      <note>
        <para>In Firebird 2.1–2.1.3, all non-BLOB results were of type
        <database>VARCHAR</database>(32765), which made it advisable to cast them to a more modest
        size. This is no longer the case.</para>
        <!--CORE-1346, backported to 2.1.4
Actually, the length was 32765 for single-byte charsets, 8191 for UTF8, etc.-->
      </note>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para><programlisting>rpad ('Hello', 12)                 -- returns 'Hello       '
rpad ('Hello', 12, '-')            -- returns 'Hello-------'
rpad ('Hello', 12, '')             -- returns 'Hello'
rpad ('Hello', 12, 'abc')          -- returns 'Helloabcabca'
rpad ('Hello', 12, 'abcdefghij')   -- returns 'Helloabcdefg'
rpad ('Hello', 2)                  -- returns 'He'
rpad ('Hello', 2, '-')             -- returns 'He'
rpad ('Hello', 2, '')              -- returns 'He'</programlisting></para>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. Although it does try to limit memory consumption, this may affect
        performance if huge <database>BLOB</database>s are involved.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-lpad"><database>LPAD()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-sign">
      <title><database>SIGN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the sign of the argument: -1, 0 or 1.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>SMALLINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SIGN (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-sign">external function
        <function>SIGN</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-sin">
      <title><database>SIN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's sine. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SIN (<replaceable>angle</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>Any non-<constant>NULL</constant> result is – obviously – in the range [-1,
                1].</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-sin">external function
        <function>SIN</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-sinh">
      <title><database>SINH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the hyperbolic sine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SINH (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-sinh">external function
        <function>SINH</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-sqrt">
      <title><database>SQRT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the square root of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SQRT (<replaceable>number</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-sqrt">external function
        <function>SQRT</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-substring">
      <title><database>SUBSTRING()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0, 2.1, 2.1.5, 2.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring starting at the given position, either to the end of the
        string or with a given length.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)</database> or
        <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SUBSTRING (<replaceable>str</replaceable> FROM <replaceable>startpos</replaceable> [FOR <replaceable>length</replaceable>])</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This function returns the substring starting at character position
      <replaceable>startpos</replaceable> (the first position being 1). Without the
      <database>FOR</database> argument, it returns all the remaining characters in the string. With
      <database>FOR</database>, it returns <replaceable>length</replaceable> characters or the
      remainder of the string, whichever is shorter.</para>
      <para>In Firebird 1.x, <replaceable>startpos</replaceable> and
      <replaceable>length</replaceable> must be integer literals. In 2.0 and above they can be any
      valid integer expression.</para>
      <para>Starting with Firebird 2.1, this function fully supports binary and text
      <database>BLOB</database>s of any length and character set. If <replaceable>str</replaceable>
      is a <database>BLOB</database>, the result is also a <database>BLOB</database>. For any other
      argument type, the result is a <database>VARCHAR</database>(<replaceable>n</replaceable>).
      Previously, the result type used to be <database>CHAR</database>(<replaceable>n</replaceable>)
      if the argument was a <database>CHAR</database>(<replaceable>n</replaceable>) or a string
      literal.</para>
      <para>For non-<database>BLOB</database> arguments, the width of the result field is always
      equal to the length of <replaceable>str</replaceable>, regardless of
      <replaceable>startpos</replaceable> and <replaceable>length</replaceable>. So,
      <code>substring('pinhead' from 4 for 2)</code> will return a <database>VARCHAR(7)</database>
      containing the string <literal>'he'</literal>.</para>
      <para>If any argument is <constant>NULL</constant>, the result is
      <constant>NULL</constant>.</para>
      <warning>
        <title>Bugs</title>
        <itemizedlist>
          <listitem>
            <para>If <replaceable>str</replaceable> is a <database>BLOB</database> and the
            <replaceable>length</replaceable> argument is not present, the output is limited to
            32767 characters. Workaround: with long <database>BLOB</database>s, always specify
            char_length(<replaceable>str</replaceable>) – or a sufficiently high integer – as the
            third argument, unless you are sure that the requested substring fits within 32767
            characters.</para>
            <para>This bug has been fixed in version 2.5.1; the fix was also backported to
            2.1.5.<!--CORE-3245
Indeed, it takes max 32767 CHARACTERS - the number of BYTES may be larger.
Fixed 2 Feb 2011 by Dmitry for 2.1.5, 2.5.1, 3.0 alpha 1--></para>
          </listitem>
          <listitem>
            <para>A bug in Firebird 2.0 which caused the function to return <quote>false
            emptystrings</quote> if <replaceable>startpos</replaceable> or
            <replaceable>length</replaceable> was <constant>NULL</constant>, has been fixed.<!--Also in later 2.0.x versions?--></para>
          </listitem>
        </itemizedlist>
      </warning>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. Although it does try to limit memory consumption, this may affect
        performance if huge <database>BLOB</database>s are involved.</para>
      </warning>
    </section>
    <section id="langrefupd25-intfunc-tan">
      <title><database>TAN()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's tangent. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>TAN (<replaceable>angle</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-tan">external function
        <function>TAN</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-tanh">
      <title><database>TANH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the hyperbolic tangent of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>TANH (<replaceable>number</replaceable>)</programlisting>
            <itemizedlist>
              <listitem>
                <para>Due to rounding, any non-<constant>NULL</constant> result is in the range [-1,
                1] (mathematically, it's &lt;-1, 1&gt;).</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <important>
        <para>If the <link linkend="langrefupd25-udf-tanh">external function
        <function>TANH</function></link> is declared in your database, it will override the internal
        function. To make the internal function available, <link
        linkend="langrefupd25-ddl-extfunc"><database>DROP</database></link> or <link
        linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER</database></link> the external
        function (UDF).</para>
        <!--DROP link points to EXTERNAL FUNCTION in general - no DROP section yet!-->
      </important>
    </section>
    <section id="langrefupd25-intfunc-trim">
      <title><database>TRIM()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Removes leading and/or trailing spaces (or optionally other strings) from the input
        string. Since Firebird 2.1 this function fully supports text <database>BLOB</database>s of
        any length and character set.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)</database> or
        <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>TRIM ([<replaceable>&lt;adjust&gt;</replaceable>] <replaceable>str</replaceable>)

<replaceable>&lt;adjust&gt;</replaceable>  ::=  {[<replaceable>where</replaceable>] [<replaceable>what</replaceable>]} FROM

<replaceable>where</replaceable>     ::=  BOTH | LEADING | TRAILING       /* default is BOTH */

<replaceable>what </replaceable>     ::=  The substring to be removed (repeatedly if necessary)
               from <replaceable>str</replaceable>'s head and/or tail. Default is ' ' (space).</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select trim ('  Waste no space   ') from rdb$database
  -- returns 'Waste no space'</programlisting>
            <programlisting>select trim (leading from '  Waste no space   ') from rdb$database
  -- returns 'Waste no space   '</programlisting>
            <programlisting>select trim (leading '.' from '  Waste no space   ') from rdb$database
  -- returns '  Waste no space   '</programlisting>
            <programlisting>select trim (trailing '!' from 'Help!!!!') from rdb$database
  -- returns 'Help'</programlisting>
            <programlisting>select trim ('la' from 'lalala I love you Ella') from rdb$database
  -- returns ' I love you El'</programlisting>
            <programlisting>select trim ('la' from 'Lalala I love you Ella') from rdb$database
  -- returns 'Lalala I love you El'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>If <replaceable>str</replaceable> is a <database>BLOB</database>, the result is
              a <database>BLOB</database>. Otherwise, it is a
              <database>VARCHAR</database>(<replaceable>n</replaceable>) with
              <replaceable>n</replaceable> the formal length of
              <replaceable>str</replaceable>.</para>
            </listitem>
            <listitem>
              <para>The substring to be removed, if specified, may not be bigger than 32767 bytes.
              However, if this substring is <emphasis>repeated</emphasis> at
              <replaceable>str</replaceable>'s head or tail, the total number of bytes removed may
              be far greater. (The restriction on the size of the substring will be lifted in
              Firebird 3.)<!--CORE-3234: Lifting of this restriction requested. Fixed by Adriano for 3.0 alpha 1.--></para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <warning>
        <para>When used on a <database>BLOB</database>, this function may need to load the entire
        object into memory. This may affect performance if huge <database>BLOB</database>s are
        involved.</para>
      </warning>
    </section>
    <section id="langrefupd25-intfunc-trunc">
      <title><database>TRUNC()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the integer part of a number. With the optional <parameter>scale</parameter>
        argument, the number can be truncated to powers-of-ten multiples (tens, hundreds, tenths,
        hundredths, etc.) instead of just integers.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database>, (scaled) <database>BIGINT</database> or
        <database>DOUBLE</database></para>
        <!--DOUBLE if the first arg is a statement parameter-->
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>TRUNC (<replaceable>&lt;number&gt;</replaceable> [, <replaceable>&lt;scale&gt;</replaceable>])

<replaceable>&lt;number&gt;</replaceable>  ::=  a numerical expression
<replaceable>&lt;scale&gt;</replaceable>   ::=  an integer specifying the number of decimal places
               toward which should be truncated, e.g.:
                  2 for truncating to a multiple of 0.01
                  1 for truncating to a multiple of 0.1
                  0 for truncating to a whole number
                 -1 for truncating to a multiple of 10
                 -2 for truncating to a multiple of 100</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>If the <parameter>scale</parameter> argument is present, the result usually has
              the same scale as the first argument, e.g.</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para><database>TRUNC</database>(789.2225, 2) returns 789.2200 (not 789.22)</para>
                </listitem>
                <listitem>
                  <para><database>TRUNC</database>(345.4, -2) returns 300.0 (not 300)</para>
                </listitem>
                <listitem>
                  <para><database>TRUNC</database>(-163.41, 0) returns -163.00 (not -163)</para>
                </listitem>
              </itemizedlist>
              <para>Otherwise, the result scale is 0:</para>
              <itemizedlist spacing="compact">
                <listitem>
                  <para><database>TRUNC</database>(-163.41) returns -163</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <important>
        <para>If you are used to the behaviour of the <link
        linkend="langrefupd25-udf-truncate">external function <function>TRUNCATE</function></link>,
        please notice that the <emphasis>internal</emphasis> function <database>TRUNC</database>
        always truncates toward zero, i.e. upward for negative numbers.</para>
      </important>
    </section>
    <section id="langrefupd25-intfunc-upper">
      <title><database>UPPER()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0, 2.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the upper-case equivalent of the input string. The exact result depends on the
        character set. With <database>ASCII</database> or <database>NONE</database> for instance,
        only ASCII characters are uppercased; with <database>OCTETS</database>, the entire string is
        returned unchanged. Since Firebird 2.1 this function also fully supports text
        <database>BLOB</database>s of any length and character set.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>(VAR)CHAR</database> or <database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>UPPER (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select upper(_iso8859_1 'Débâcle')
from rdb$database
  -- returns 'DÉBÂCLE' (before Firebird 2.0: 'DéBâCLE')</programlisting>
            <programlisting>select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
  -- returns 'DEBACLE', following French uppercasing rules</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-intfunc-lower"><database>LOWER</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-intfunc-uuid_to_char">
      <title><database>UUID_TO_CHAR()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL ?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Converts a 16-byte UUID to its 36-character, human-readable ASCII
        representation.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>CHAR(36)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>UUID_TO_CHAR (<replaceable>uuid</replaceable>)

<replaceable>uuid</replaceable>  ::=  a string consisting of 16 single-byte characters</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select uuid_to_char(x'876C45F4569B320DBCB4735AC3509E5F') from rdb$database
-- returns '876C45F4-569B-320D-BCB4-735AC3509E5F'

select uuid_to_char(gen_uuid()) from rdb$database
-- returns e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

select uuid_to_char('Firebird swings!') from rdb$database
-- returns '46697265-6269-7264-2073-77696E677321'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd25-intfunc-char_to_uuid"><database>CHAR_TO_UUID()</database></link>,
        <link linkend="langrefupd25-intfunc-gen_uuid"><database>GEN_UUID()</database></link></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd25-udf">
    <title>External functions (UDFs)</title>
    <para>External functions must be <quote>declared</quote> (made known) to the database before
    they can be used. Firebird ships with two external function libraries:</para>
    <itemizedlist>
      <listitem>
        <para><systemitem class="library">ib_udf</systemitem> – inherited from InterBase;</para>
      </listitem>
      <listitem>
        <para><systemitem class="library">fbudf</systemitem> – a new library using <link
        linkend="langrefupd25-declareext-bydescriptor">descriptors</link>, present as from Firebird
        1.0 (Windows) and 1.5 (Linux).</para>
      </listitem>
    </itemizedlist>
    <para>Users can also create their own UDF libraries or acquire them from third parties.</para>
    <!--Wherever appropriate I used 32767 as a max string length, not 32765 (max. VARCHAR-length).
This is about what the function itself and the Firebird engine can handle when you call it
from your SQL, *not* about whether the result subsequently fits in a VARCHAR.-->
    <section id="langrefupd25-udf-abs">
      <title><function>abs</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-abs"><database>ABS()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the absolute value of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>abs (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION abs
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_abs' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-acos">
      <title><function>acos</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-acos"><database>ACOS()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the arc cosine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>acos (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION acos
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_acos' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addday">
      <title><function>addDay</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> days added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addday (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addDay
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addDay' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addhour">
      <title><function>addHour</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> hours added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addhour (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addHour
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addHour' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addmillisecond">
      <title><function>addMilliSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> milliseconds added.
        Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmillisecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMilliSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addminute">
      <title><function>addMinute</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> minutes added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addminute (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMinute
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addmonth">
      <title><function>addMonth</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> months added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmonth (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMonth
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addsecond">
      <title><function>addSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> seconds added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addsecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addweek">
      <title><function>addWeek</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> weeks added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addweek (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addWeek
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-addyear">
      <title><function>addYear</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-dateadd"><database>DATEADD</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> years added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addyear (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addYear
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addYear' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-ascii_char">
      <title><function>ascii_char</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-ascii_char"><database>ASCII_CHAR()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII character corresponding to the integer value passed in.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(1)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ascii_char (<parameter>intval</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ascii_char
   INTEGER <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(1) FREE_IT
   ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf'</programlisting>
            <para>The declaration reflects the fact that the UDF as such returns a 1-character C
            string, not an SQL <database>CHAR(1)</database> as stated in the InterBase declaration.
            The engine will pass the result to the caller as a <database>VARCHAR(1)</database>
            though.</para>
            <para>The <emphasis role="bold">NULL</emphasis> after INTEGER is an optional addition
            that became available in Firebird 2. When declared with the <database>NULL</database>
            keyword, the engine will pass a <constant>NULL</constant> argument unchanged to the
            function. This causes a <constant>NULL</constant> result, which is correct. Without the
            <database>NULL</database> keyword (your only option in pre-2.0 versions),
            <constant>NULL</constant> is passed to the function as 0 and the result is an empty
            string.</para>
            <!--Actually, the UDF fills in a \0 here (NUL character), but since it's a
C string, this acts as a string terminator so the result is an empty string.-->
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><function>ascii_char(0)</function> returns an empty string in all versions, not
              a character with ASCII value 0.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was <database>CHAR(1)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-ascii_val">
      <title><function>ascii_val</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-ascii_val"><database>ASCII_VAL()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII code of the character passed in.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ascii_val (<parameter>ch</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ascii_val
   CHAR(1)
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_ascii_val' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Because <database>CHAR</database> fields are padded with spaces, an empty string
        argument will be seen as a space, and yield a result of 32. The internal function
        <database><link
        linkend="langrefupd25-intfunc-ascii_val"><database>ASCII_VAL</database></link></database>
        returns 0 in this case.</para>
      </caution>
    </section>
    <section id="langrefupd25-udf-asin">
      <title><function>asin</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-asin"><database>ASIN()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the arc sine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>asin (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION asin
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_asin' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-atan">
      <title><function>atan</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-atan"><database>ATAN()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the arc tangent of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>atan (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION atan
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_atan' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-atan2">
      <title><function>atan2</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-atan2"><database>ATAN2()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the angle whose sine-to-cosine <emphasis>ratio</emphasis> is given by the two
        arguments, and whose sine and cosine <emphasis>signs</emphasis> correspond to the signs of
        the arguments. This allows results across the entire circle, including the angles -π/2 and
        π/2.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>atan2 (<parameter>num1</parameter>, <parameter>num2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION atan2
   DOUBLE PRECISION, DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_atan2' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-bin_and">
      <title><function>bin_and</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-bin_and"><database>BIN_AND()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the bitwise AND result of the arguments.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>bin_and (<parameter>num1</parameter>, <parameter>num2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION bin_and
   INTEGER, INTEGER
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_bin_and' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-bin_or">
      <title><function>bin_or</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-bin_or"><database>BIN_OR()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the bitwise OR result of the arguments.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>bin_or (<parameter>num1</parameter>, <parameter>num2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION bin_or
   INTEGER, INTEGER
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_bin_or' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-bin_xor">
      <title><function>bin_xor</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-bin_xor"><database>BIN_XOR()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the bitwise XOR result of the arguments.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>bin_xor (<parameter>num1</parameter>, <parameter>num2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION bin_xor
   INTEGER, INTEGER
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_bin_xor' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-ceiling">
      <title><function>ceiling</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-ceil"><database>CEIL()</database> /
        <database>CEILING()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the smallest whole number that is greater than or equal to the
        argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ceiling (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ceiling
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_ceiling' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-cos">
      <title><function>cos</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-cos"><database>COS()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's cosine. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>cos (<parameter>angle</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION cos
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_cos' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-cosh">
      <title><function>cosh</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-cosh"><database>COSH()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the hyperbolic cosine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>cosh (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION cosh
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_cosh' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-cot">
      <title><function>cot</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-cot"><database>COT()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's cotangent. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>cot (<parameter>angle</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION cot
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_cot' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-dow">
      <title><function>dow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the day of the week from a timestamp argument. The returned name may be
        localized.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(15)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dow
   TIMESTAMP,
   VARCHAR(15) RETURNS PARAMETER 2
   ENTRY_POINT 'DOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-udf-sdow"><function>sdow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-dpower">
      <title><function>dpower</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-power"><database>POWER()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th
        power.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dpower (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dPower
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR,
   DOUBLE PRECISION BY DESCRIPTOR
   RETURNS PARAMETER 3
   ENTRY_POINT 'power' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-floor">
      <title><function>floor</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-floor"><database>FLOOR()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the largest whole number that is smaller than or equal to the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>floor (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION floor
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_floor' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-getexacttimestamp">
      <title><function>getExactTimestamp</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link
        linkend="langrefupd25-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link> or
        <link linkend="langrefupd25-now"><literal>'NOW'</literal></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the system time with milliseconds precision. This function was added because
        in pre-2.0 versions, <varname>CURRENT_TIMESTAMP</varname> always had
        <literal>.0000</literal> in the fractional part of the second. In Firebird 2.0 and up it is
        better to use <link
        linkend="langrefupd25-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>, which
        now also defaults to milliseconds precision. To measure time intervals in PSQL modules, use
        <link linkend="langrefupd25-now"><literal>'NOW'</literal></link>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>getexacttimestamp()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION getExactTimestamp
   TIMESTAMP RETURNS PARAMETER 1
   ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-i64round">
      <title><function>i64round</function></title>
      <para>See <link linkend="langrefupd25-udf-round"><function>round</function></link>.</para>
    </section>
    <section id="langrefupd25-udf-i64truncate">
      <title><function>i64truncate</function></title>
      <para>See <link
      linkend="langrefupd25-udf-truncate"><function>truncate</function></link>.</para>
    </section>
    <section id="langrefupd25-udf-ln">
      <title><function>ln</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-ln"><database>LN()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the natural logarithm of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ln (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ln
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_ln' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-log">
      <title><function>log</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-log"><database>LOG()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <function>log(x,y)</function> returns the the
        base-<parameter>x</parameter> logarithm of <parameter>y</parameter>. In Firebird 1.0.x and
        InterBase, it erroneously returns the base-<parameter>y</parameter> logarithm of
        <parameter>x</parameter>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>log (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration (unchanged)</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION log
   DOUBLE PRECISION, DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>If any of your pre-1.5 databases use <function>log</function>, check your PSQL and
        application code. It may contain workarounds to return the right results. Under Firebird 1.5
        and up, any such workarounds should be removed or you'll get wrong results.</para>
      </warning>
    </section>
    <section id="langrefupd25-udf-log10">
      <title><function>log10</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-log10"><database>LOG10()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the 10-based logarithm of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>log10 (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION log10
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_log10' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-lower">
      <title><function>lower</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-lower"><database>LOWER()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the lower-case version of the input string. Please notice that only ASCII
        characters are handled correctly. If possible, use the superior internal function <link
        linkend="langrefupd25-intfunc-lower"><database>LOWER</database></link> instead.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>"LOWER" (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION "LOWER"
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lower' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>.
            <function>"LOWER"</function> has been surrounded by double-quotes because
            <database>LOWER</database>, being a reserved word, cannot be used as an identifier
            except when quoted. When you call the function, you also have to add the quotes and use
            the exact capitalization, otherwise the internal function will take precedence. (Most
            other internal function names are not reserved words; in those cases, the external
            function prevails if it is declared.)</para>
            <para>The <emphasis role="bold">NULL</emphasis> after CSTRING(255) is an optional
            addition that became available in Firebird 2. When declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument unchanged to the function. This leads to a <constant>NULL</constant> result,
            which is correct. Without the <database>NULL</database> keyword (your only option in
            pre-2.0 versions), <constant>NULL</constant> is passed to the function as an empty
            string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-lpad">
      <title><function>lpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-lpad"><database>LPAD()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string left-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>lpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, INTEGER, CSTRING(1) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis>s after the CSTRING arguments are an optional
            addition that became available in Firebird 2. If an argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant>s are passed to the function as
            empty strings and the result is a string with <replaceable>endlengh</replaceable>
            padchars (if <replaceable>str</replaceable> is <constant>NULL</constant>) or a copy of
            <replaceable>str</replaceable> itself (if <replaceable>padchar</replaceable> is
            <constant>NULL</constant>).</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>When calling this function, make sure <replaceable>endlength</replaceable> does
              not exceed the declared result length.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>endlength</replaceable> is less than
              <replaceable>str</replaceable>'s length, <replaceable>str</replaceable> is truncated
              to <replaceable>endlength</replaceable>. If <replaceable>endlength</replaceable> is
              negative, the result is <constant>NULL</constant>.</para>
            </listitem>
            <listitem>
              <para>A <constant>NULL</constant> <replaceable>endlength</replaceable> is treated as
              if it were 0.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>padchar</replaceable> is empty, or if
              <replaceable>padchar</replaceable> is <constant>NULL</constant> and the function has
              been declared without the <database>NULL</database> keyword after the last argument,
              <replaceable>str</replaceable> is returned unchanged (or truncated to
              <replaceable>endlength</replaceable>).</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>A bug that caused an endless loop if <replaceable>padchar</replaceable> was
              empty or <constant>NULL</constant> has been fixed in 2.0.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-ltrim">
      <title><function>ltrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-trim"><database>TRIM()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any leading space characters removed. In new code, you
        are advised to use the internal function <link
        linkend="langrefupd25-intfunc-trim"><database>TRIM</database></link> instead, as it is both
        more powerful and more versatile.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ltrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ltrim
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.0.x, this function returned <constant>NULL</constant> if the input
              string was either empty or <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-mod">
      <title><function>mod</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-mod"><database>MOD()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the remainder of an integer division.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>mod (<parameter>a</parameter>, <parameter>b</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION mod
   INTEGER, INTEGER
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_mod' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-nullif">
      <title><function>*nullif</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-nullif"><database>NULLIF()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>*nullif</function> functions – for integers, bigints, doubles and
        strings, respectively – each return the first argument if it is not equal to the second. If
        the arguments are equal, the functions return <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>inullif   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nullif (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnullif   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snullif   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5, use of the internal function <link
      linkend="langrefupd25-intfunc-nullif"><database>NULLIF</database></link> is preferred.</para>
      <warning>
        <title>Warnings</title>
        <itemizedlist>
          <listitem>
            <para>These functions return <constant>NULL</constant> when the second argument is
            <constant>NULL</constant>, even if the first argument is a proper value. This is a wrong
            result. The <database>NULLIF</database> internal function doesn't have this bug.</para>
          </listitem>
          <listitem>
            <para><function>i64nullif</function> and <function>dnullif</function> will return wrong
            and/or bizarre results if it is not 100% clear to the engine that each argument is of
            the intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE
            PRECISION</database>). If in doubt, cast them both explicitly to the declared type (see
            declarations below).</para>
          </listitem>
        </itemizedlist>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION inullif
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nullif
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS NUMERIC(18,4) BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <programlisting>DECLARE EXTERNAL FUNCTION dnullif
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snullif
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-nvl">
      <title><function>*nvl</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-coalesce"><database>COALESCE()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>nvl</function> functions – for integers, bigints, doubles and
        strings, respectively – are <constant>NULL</constant> replacers. They each return the first
        argument's value if it is not <constant>NULL</constant>. If the first argument is
        <constant>NULL</constant>, the value of the second argument is returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>invl   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nvl (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnvl   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snvl   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5, use of the internal function <link
      linkend="langrefupd25-intfunc-coalesce"><database>COALESCE</database></link> is
      preferred.</para>
      <warning>
        <para><function>i64nvl</function> and <function>dnvl</function> will return wrong and/or
        bizarre results if it is not absolutely clear to the engine that each argument is of the
        intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE PRECISION</database>).
        If in doubt, cast both arguments explicitly to the declared type (see declarations
        below).</para>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION invl
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nvl
   NUMERIC(18,0) BY DESCRIPTOR, NUMERIC(18,0) BY DESCRIPTOR
   RETURNS NUMERIC(18,0) BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION dnvl
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snvl
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-pi">
      <title><function>pi</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-pi"><database>PI()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an approximation of the value of π.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>pi ()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION pi
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_pi' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-rand">
      <title><function>rand</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-rand"><database>RAND()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a pseudo-random number. Before Firebird 2.0, this function would first seed
        the random number generator with the current time in seconds. Multiple
        <function>rand()</function> calls within the same second would therefore return the same
        value. If you want that old behaviour in Firebird 2 and up, use <link
        linkend="langrefupd25-udf-srand"><function>srand()</function></link>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>rand ()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rand
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_rand' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-right">
      <title><function>right</function></title>
      <para>See <link linkend="langrefupd25-udf-sright"><function>sright</function></link>.</para>
    </section>
    <section id="langrefupd25-udf-round">
      <title><function>round</function>, <function>i64round</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.1.3</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-round"><database>ROUND()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole number that is nearest to their (scaled
        numeric/decimal) argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>round    (<parameter>number</parameter>)
i64round (<parameter>bignumber</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Halves are always rounded upward, i.e. away from zero for positive numbers and toward
        zero for negative numbers. For instance, <literal>3.5</literal> is rounded to
        <literal>4</literal>, but <literal>-3.5</literal> is rounded to <literal>-3</literal>. The
        internal function <link
        linkend="langrefupd25-intfunc-round"><database>ROUND</database></link>, available since
        Firebird 2.1, rounds all halves away from zero.</para>
      </caution>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>round</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbround</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under truncate:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names. From Firebird 2.0 onward you can
            also perform this update with <link
            linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER EXTERNAL
            FUNCTION</database></link>.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-rpad">
      <title><function>rpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-rpad"><database>RPAD()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string right-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>rpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rpad
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, INTEGER, CSTRING(1) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis>s after the CSTRING arguments are an optional
            addition that became available in Firebird 2. If an argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant>s are passed to the function as
            empty strings and the result is a string with <replaceable>endlengh</replaceable>
            padchars (if <replaceable>str</replaceable> is <constant>NULL</constant>) or a copy of
            <replaceable>str</replaceable> itself (if <replaceable>padchar</replaceable> is
            <constant>NULL</constant>).</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>When calling this function, make sure <replaceable>endlength</replaceable> does
              not exceed the declared result length.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>endlength</replaceable> is less than
              <replaceable>str</replaceable>'s length, <replaceable>str</replaceable> is truncated
              to <replaceable>endlength</replaceable>. If <replaceable>endlength</replaceable> is
              negative, the result is <constant>NULL</constant>.</para>
            </listitem>
            <listitem>
              <para>A <constant>NULL</constant> <replaceable>endlength</replaceable> is treated as
              if it were 0.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>padchar</replaceable> is empty, or if
              <replaceable>padchar</replaceable> is <constant>NULL</constant> and the function has
              been declared without the <database>NULL</database> keyword after the last argument,
              <replaceable>str</replaceable> is returned unchanged (or truncated to
              <replaceable>endlength</replaceable>).</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>A bug that caused an endless loop if <replaceable>padchar</replaceable> was
              empty or <constant>NULL</constant> has been fixed in 2.0.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-rtrim">
      <title><function>rtrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-trim"><database>TRIM()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any trailing space characters removed. In new code, you
        are advised to use the internal function <link
        linkend="langrefupd25-intfunc-trim"><database>TRIM</database></link> instead, as it is both
        more powerful and more versatile.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>rtrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rtrim
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.0.x, this function returned <constant>NULL</constant> if the input
              string was either empty or <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-sdow">
      <title><function>sdow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the abbreviated day of the week from a timestamp argument. The returned
        abbreviation may be localized.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sdow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sdow
   TIMESTAMP,
   VARCHAR(5) RETURNS PARAMETER 2
   ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd25-udf-dow"><function>dow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-sign">
      <title><function>sign</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-sign"><database>SIGN()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the sign of the argument: -1, 0 or 1.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sign (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sign
   DOUBLE PRECISION
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_sign' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-sin">
      <title><function>sin</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-sin"><database>SIN()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's sine. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sin (<parameter>angle</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sin
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_sin' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-sinh">
      <title><function>sinh</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-sinh"><database>SINH()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the hyperbolic sine of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sinh (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sinh
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_sinh' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-sqrt">
      <title><function>sqrt</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-sqrt"><database>SQRT()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the square root of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sqrt (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sqrt
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_sqrt' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-srand">
      <title><function>srand</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Seeds the random number generator with the current time in seconds and then returns
        the first number. Multiple <function>srand()</function> calls within the same second will
        return the same value. This is exactly how <link
        linkend="langrefupd25-udf-srand"><function>rand()</function></link> behaved before Firebird
        2.0.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>srand ()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION srand
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_srand' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-sright">
      <title><function>sright</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-right"><database>RIGHT()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the rightmost <replaceable>numchars</replaceable> characters of the input
        string. Only works with 1-byte character sets.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(100)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sright (<parameter>str</parameter>, <parameter>numchars</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sright
   VARCHAR(100) BY DESCRIPTOR, SMALLINT,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'right' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-string2blob">
      <title><function>string2blob</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-cast"><database>CAST()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string as a <database>BLOB</database>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>string2blob (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION string2blob
   VARCHAR(300) BY DESCRIPTOR,
   BLOB RETURNS PARAMETER 2
   ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-strlen">
      <title><function>strlen</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternatives</title>
        <para>Internal functions <link
        linkend="langrefupd25-intfunc-bit_length"><database>BIT_LENGTH()</database></link>, <link
        linkend="langrefupd25-intfunc-char_length"><database>CHAR[ACTER]_LENGTH</database></link>
        and <link
        linkend="langrefupd25-intfunc-octet_length"><database>OCTET_LENGTH()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the length of the argument string.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>strlen (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION strlen
   CSTRING(32767)
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_strlen' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-substr">
      <title><function>substr</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0, 1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring from <parameter>startpos</parameter> to
        <parameter>endpos</parameter>, inclusively. Positions are 1-based. If
        <parameter>endpos</parameter> is past the end of the string, <function>substr</function>
        returns all the characters from <parameter>startpos</parameter> to the end of the string.
        This function only works correctly with single-byte characters.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>substr (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>endpos</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substr
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
            <listitem>
              <para>In InterBase, <function>substr</function> returned <constant>NULL</constant> if
              <parameter>endpos</parameter> lay past the end of the string.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <tip>
        <para>Although the function arguments are slightly different, consider using the internal
        SQL function <link
        linkend="langrefupd25-intfunc-substring"><database>SUBSTRING</database></link> instead, for
        better compatibility and multi-byte character set support.</para>
      </tip>
    </section>
    <section id="langrefupd25-udf-substrlen">
      <title><function>substrlen</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-substring"><database>SUBSTRING()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the substring starting at <parameter>startpos</parameter> and having
        <parameter>length</parameter> characters (or less, if the end of the string is reached
        first). Positions are 1-based. If either <parameter>startpos</parameter> or
        <parameter>length</parameter> is smaller than 1, an empty string is returned. This function
        only works correctly with single-byte characters.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>substrlen (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>length</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substrlen
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd25-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd25-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <tip>
        <para>Firebird 1.0 has also implemented the internal SQL function <link
        linkend="langrefupd25-intfunc-substring"><database>SUBSTRING</database></link>, effectively
        rendering <function>substrlen</function> obsolete in the same version in which it was
        introduced. <database>SUBSTRING</database> also supports multi-byte character sets. In new
        code, use <database>SUBSTRING</database>.</para>
      </tip>
    </section>
    <section id="langrefupd25-udf-tan">
      <title><function>tan</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-tan"><database>TAN()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns an angle's tangent. The argument must be given in radians.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>tan (<parameter>angle</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION tan
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_tan' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-tanh">
      <title><function>tanh</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-tanh"><database>TANH()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the hyperbolic tangent of the argument.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>tanh (<parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION tanh
   DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_tanh' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd25-udf-truncate">
      <title><function>truncate</function>, <function>i64truncate</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.1.3</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd25-intfunc-trunc"><database>TRUNC()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole-number portion of their (scaled numeric/decimal)
        argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>truncate    (<parameter>number</parameter>)
i64truncate (<parameter>bignumber</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Both functions round to the nearest whole number that is lower than or equal to the
        argument. This means that negative numbers are also <quote>truncated</quote> downward. For
        instance, <function>truncate(<parameter>-2.37</parameter>)</function> returns
        <literal>-3</literal>. The internal function <link
        linkend="langrefupd25-intfunc-trunc"><database>TRUNC</database></link>, available since
        Firebird 2.1, always truncates toward zero.</para>
      </caution>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>truncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbtruncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under round:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names. From Firebird 2.0 onward you can
            also perform this update with <link
            linkend="langrefupd25-ddl-extfunc-alter"><database>ALTER EXTERNAL
            FUNCTION</database></link>.</para>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <appendix id="langrefupd25-notes">
    <title>Notes</title>
    <section id="langrefupd25-notes-charset-none">
      <title>Character set <database>NONE</database> data accepted <quote>as is</quote></title>
      <subtitle>In Firebird 1.5.1 and up</subtitle>
      <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
      moved to and from fields or variables with another character set, resulting in fewer
      transliteration errors.</para>
      <para>In Firebird 1.5.0, from a client connected with character set <database>NONE</database>,
      you could read data in two incompatible character sets – such as <database>SJIS</database>
      (Japanese) and <database>WIN1251</database> (Russian) – even though you could not read one of
      those character sets while connected from a client with the other character set. Data would be
      received <quote>as is</quote> and be stored without raising an exception.</para>
      <para>However, from this character set <database>NONE</database> client connection, an attempt
      to update any Russian or Japanese data columns using either parameterized queries or literal
      strings without introducer syntax would fail with transliteration errors; and subsequent
      queries on the stored <quote><database>NONE</database></quote> data would similarly
      fail.</para>
      <para>In Firebird 1.5.1, both problems have been circumvented. Data received from the client
      in character set <database>NONE</database> are still stored <quote>as is</quote> but what is
      stored is an exact, binary copy of the received string. In the reverse case, when stored data
      are read into this client from columns with specific character sets, there will be no
      transliteration error. When the connection character set is <database>NONE</database>, no
      attempt is made in either case to resolve the string to well-formed characters, so neither the
      write nor the read will throw a transliteration error.</para>
      <para>This opens the possibility for working with data from multiple character sets in a
      single database, as long as the connection character set is <database>NONE</database>. The
      client has full responsibility for submitting strings in the appropriate character set and
      converting strings returned by the engine, as needed.</para>
      <para>Abstraction layers that have to manage this can read the low byte of the
      <structfield>sqlsubtype</structfield> field in the <structname>XSQLVAR</structname> structure,
      which contains the character set identifier.</para>
      <para>While character set <database>NONE</database> literals are accepted and implicitly
      stored in the character set of their context, the use of introducer syntax to coerce the
      character sets of literals is highly recommended when the application is handling literals in
      a mixture of character sets. This should avoid the string's being misinterpreted when the
      application shifts the context for literal usage to a different character set.</para>
      <note>
        <para>Coercion of the character set, using the introducer syntax or casting, is still
        required when handling heterogeneous character sets from a client context that is anything
        other than <database>NONE</database>. Both methods are shown below, using character set
        <database>ISO8859_1</database> as an example target. Notice the
        <quote><literal>_</literal></quote> prefix in the introducer syntax.</para>
        <variablelist>
          <varlistentry>
            <term>Introducer syntax:</term>
            <listitem>
              <para><code>_ISO8859_1 <replaceable>mystring</replaceable></code></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Casting:</term>
            <listitem>
              <para><code>CAST (<replaceable>mystring</replaceable> AS
              VARCHAR(<replaceable>n</replaceable>) CHARACTER SET ISO8859_1)</code></para>
            </listitem>
          </varlistentry>
        </variablelist>
      </note>
    </section>
    <section id="langrefupd25-notes-withlock">
      <title>Understanding the <database>WITH LOCK</database> clause</title>
      <para>This note looks a little deeper into explicit locking and its ramifications. The
      <database>WITH LOCK</database> feature, added in Firebird 1.5, provides a limited explicit
      pessimistic locking capability for cautious use in conditions where the affected row set
      is:<orderedlist numeration="loweralpha" spacing="compact">
          <listitem>
            <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
          </listitem>
          <listitem>
            <para>precisely controlled by the application code.</para>
          </listitem>
        </orderedlist></para>
      <para>Pessimistic locks are rarely needed in Firebird. This is an expert feature, intended for
      use by those who thoroughly understand its consequences. Knowledge of the various levels of
      transaction isolation is essential. <database>WITH LOCK</database> is available in DSQL and
      PSQL, and only for top-level, single-table <database>SELECT</database>s. As stated in the
      reference part of this guide, <database>WITH LOCK</database> is <emphasis>not</emphasis>
      available:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification;</para>
        </listitem>
        <listitem>
          <para>for joined sets;</para>
        </listitem>
        <listitem>
          <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
          clause or any other aggregating operation;</para>
        </listitem>
        <listitem>
          <para>with a view;</para>
        </listitem>
        <listitem>
          <para>with the output of a selectable stored procedure;</para>
        </listitem>
        <listitem>
          <para>with an external table.</para>
        </listitem>
      </itemizedlist>
      <section id="langrefupd25-appx-withlock-syntax">
        <title>Syntax and behaviour</title>
        <blockquote>
          <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
        </blockquote>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>
        <para>As the engine considers, in turn, each record falling under an explicit lock
        statement, it returns either the record version that is the most currently committed,
        regardless of database state when the statement was submitted, or an exception.</para>
        <para>Wait behaviour and conflict reporting depend on the transaction parameters specified
        in the TPB block:</para>
        <table id="langrefupd25-tbl-tpb-effects">
          <title>How TPB settings affect explicit locking</title>
          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />
            <colspec align="left" colname="behaviour" colwidth="3*" />
            <thead>
              <row>
                <entry align="center">TPB mode</entry>
                <entry align="center">Behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row valign="top">
                <entry><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explicit locks are overridden by implicit or explicit
                table-level locks and are ignored.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If a record is modified by any transaction that was
                committed since the transaction attempting to get explicit lock started, or an
                active transaction has performed a modification of this record, an update conflict
                exception is raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If the record is modified by any transaction that has
                committed since the transaction attempting to get explicit lock started, an update
                conflict exception is raised immediately.</para><para>If an active transaction is
                holding ownership on this record (via explicit locking or by a normal optimistic
                write-lock) the transaction attempting the explicit lock waits for the outcome of
                the blocking transaction and, when it finishes, attempts to get the lock on the
                record again. This means that, if the blocking transaction committed a modified
                version of this record, an update conflict exception will be raised.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or normal update), an update conflict exception is
                raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or by a normal optimistic write-lock), the
                transaction attempting the explicit lock waits for the outcome of blocking
                transation and when it finishes, attempts to get the lock on the record
                again.</para><para>Update conflict exceptions can never be raised by an explicit
                lock statement in this TPB mode.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="langrefupd25-appx-withlock-engine">
        <title>How the engine deals with <database>WITH LOCK</database></title>
        <para>When an <database>UPDATE</database> statement tries to access a record that is locked
        by another transaction, it either raises an update conflict exception or waits for the
        locking transaction to finish, depending on TPB mode. Engine behaviour here is the same as
        if this record had already been modified by the locking transaction.</para>
        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>
        <para>The engine guarantees that all records returned by an explicit lock statement are
        actually locked and <emphasis>do</emphasis> meet the search conditions specified in
        <database>WHERE</database> clause, as long as the search conditions do not depend on any
        other tables, via joins, subqueries, etc. It also guarantees that rows not meeting the
        search conditions will not be locked by the statement. It can <emphasis>not</emphasis>
        guarantee that there are no rows which, though meeting the search conditions, are not
        locked.</para>
        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during
          the course of the locking statement's execution.</para>
        </note>
        <para>The engine locks rows at fetch time. This has important consequences if you lock
        several rows at once. Many access methods for Firebird databases default to fetching output
        in packets of a few hundred rows (<quote>buffered fetches</quote>). Most data access
        components cannot bring you the rows contained in the last-fetched packet, where an error
        occurred.</para>
      </section>
      <section id="langrefupd25-appx-withlock-of">
        <title>The optional <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> sub-clause</title>
        <para>The <database>FOR UPDATE</database> clause provides a technique to prevent usage of
        buffered fetches, optionally with the <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> subclause to enable positioned
        updates.</para>
        <tip>
          <para>Alternatively, it may be possible in your access components to set the size of the
          fetch buffer to 1. This would enable you to process the currently-locked row before the
          next is fetched and locked, or to handle errors without rolling back your
          transaction.</para>
        </tip>
      </section>
      <section id="langrefupd25-appx-withlock-caveats">
        <title>Caveats using <database>WITH LOCK</database></title>
        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were
            taken under that savepoint, but it doesn't notify waiting transactions. Applications
            should not depend on this behaviour as it may get changed in the future.</para>
          </listitem>
          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict
            errors, the volume of deadlock errors will grow unless you design your locking strategy
            carefully and control it rigorously.</para>
          </listitem>
          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit
            locks are (1) to prevent expensive handling of update conflict errors in heavily loaded
            applications and (2) to maintain integrity of objects mapped to a relational database in
            a clustered environment. If your use of explicit locking doesn't fall in one of these
            two categories, then it's the wrong way to do the task in Firebird.</para>
          </listitem>
          <listitem>
            <para>Explicit locking is an advanced feature; do not misuse it! While solutions for
            these kinds of problems may be very important for web sites handling thousands of
            concurrent writers, or for ERP/CRM systems operating in large corporations, most
            application programs do not need to work in such conditions.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="langrefupd25-appx-withlock-examples">
        <title>Examples using explicit locking</title>
        <orderedlist numeration="lowerroman">
          <listitem>
            <para>Simple:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK</programlisting>
          </listitem>
          <listitem>
            <para>Multiple rows, one-by-one processing with DSQL cursor:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK</programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section id="langrefupd25-notes-cstring">
      <title>A note on <database>CSTRING</database> parameters</title>
      <para>External functions involving strings often use the type
      <database>CSTRING(<replaceable>n</replaceable>)</database> in their declarations. This type
      represents a zero-terminated string of maximum length <replaceable>n</replaceable>. Most of
      the functions handling <database>CSTRING</database>s are programmed in such a way that they
      can accept and return zero-terminated strings of any length. So why the
      <replaceable>n</replaceable>? Because the Firebird engine has to set up space to process the
      input an output parameters, and convert them to and from SQL data types. Most strings used in
      databases are only dozens to hundreds of bytes long; it would be a waste to reserve 32 KB of
      memory each time such a string is processed. Therefore, the <emphasis>standard</emphasis>
      declarations of most <database>CSTRING</database> functions – as found in the file
      <filename>ib_udf.sql</filename> – specify a length of 255 bytes. (In Firebird 1.5.1 and below,
      this default length is 80 bytes.) As an example, here's the SQL declaration of
      <function>lpad</function>:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
      </blockquote>
      <para>Once you've declared a <database>CSTRING</database> parameter with a certain length, you
      cannot call the function with a longer input string, or cause it to return a string longer
      than the declared output length. But the standard declarations are just reasonable defaults;
      they're not cast in concrete, and you can change them if you want to. If you have to left-pad
      strings of up to 500 bytes long, then it's perfectly OK to change both 255's in the
      declaration to 500 or more.</para>
      <para>A special case is when you usually operate on short strings (say less then 100 bytes)
      but occasionally have to call the function with a huge <database>(VAR)CHAR</database>
      argument. Declaring <database>CSTRING(32000)</database> makes sure that all the calls will be
      successful, but it will also cause 32000 bytes per parameter to be reserved, even in that
      majority of cases where the strings are under 100 bytes. In that situation you may consider
      declaring the function twice, with different names and different string lengths:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpad</emphasis>
   <emphasis role="bold">CSTRING(100)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(100)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';

DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpadbig</emphasis>
   <emphasis role="bold">CSTRING(32000)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(32000)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';</programlisting>
      </blockquote>
      <para>Now you can call <function>lpad()</function> for all the small strings and
      <function>lpadbig()</function> for the occasional monster. Notice how the declared names in
      the first line differ (they determine how you call the functions from within your SQL), but
      the entry point (the function name in the library) is the same in both cases.</para>
      <!--The Firebird Book states that the low default is there for security reasons, to prevent accidental or malicious overflow.-->
    </section>
    <section id="langrefupd25-notes-udf-null">
      <title>Passing <constant>NULL</constant> to UDFs in Firebird 2</title>
      <para>If a pre-2.0 Firebird engine must pass an SQL <constant>NULL</constant> argument to a
      user-defined function, it always converts it to a zero-equivalent, e.g. a numerical 0 or an
      empty string. The only exception to this rule are UDFs that make use of the
      <quote><database>BY DESCRIPTOR</database></quote> mechanism introduced in Firebird 1. The
      <systemitem class="library">fbudf</systemitem> library uses descriptors, but the vast majority
      of UDFs, including those in Firebird's standard <systemitem
      class="library">ib_udf</systemitem> library, still use the old style of parameter passing,
      inherited from InterBase.</para>
      <para>As a consequence, most UDFs can't tell the difference between <constant>NULL</constant>
      and zero input.</para>
      <para>Firebird 2 comes with a somewhat improved calling mechanism for these old-style UDFs.
      The engine will now pass <constant>NULL</constant> input as a null pointer to the function,
      <emphasis role="bold">if</emphasis> the function has been declared to the database with a
      <database>NULL</database> keyword after the argument(s) in question, e.g. like this:</para>
      <blockquote>
        <programlisting>declare external function ltrim
  cstring(255) <emphasis role="bold">null</emphasis>
  returns cstring(255) free_it
  entry_point 'IB_UDF_ltrim' module_name 'ib_udf';</programlisting>
      </blockquote>
      <para>This requirement ensures that existing databases and their applications can continue to
      function like before. Leave out the <database>NULL</database> keyword and the function will
      behave like it did under Firebird 1.5 and earlier.</para>
      <para>Please note that you can't just add <database>NULL</database> keywords to your
      declarations and then expect every function to handle <constant>NULL</constant> input
      correctly. Each function has to be (re)written in such a way that <constant>NULL</constant>s
      are dealt with correctly. Always look at the declarations provided by the function
      implementor. For the functions in the <systemitem class="library">ib_udf</systemitem> library,
      consult <filename>ib_udf2.sql</filename> in the Firebird <filename
      class="directory">UDF</filename> directory. Notice the <literal>2</literal> in the file name;
      the old-style declarations are in <filename>ib_udf.sql</filename>.</para>
      <para>These are the <systemitem class="library">ib_udf</systemitem> functions that have been
      updated to recognise <constant>NULL</constant> input and handle it properly:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><function>ascii_char</function></para>
        </listitem>
        <listitem>
          <para><function>lower</function></para>
        </listitem>
        <listitem>
          <para><function>lpad</function> and <function>rpad</function></para>
        </listitem>
        <listitem>
          <para><function>ltrim</function> and <function>rtrim</function></para>
        </listitem>
        <listitem>
          <para><function>substr</function> and <function>substrlen</function></para>
        </listitem>
      </itemizedlist>
      <para>Most <systemitem class="library">ib_udf</systemitem> functions remain as they were; in
      any case, passing <constant>NULL</constant> to an old-style UDF is never possible if the
      argument isn't of a referenced type.</para>
      <para>On a side note: don't use <function>lower</function>, <function>.trim</function> and
      <function>substr*</function> in new code; use the internal functions
      <database>LOWER</database>, <database>TRIM</database> and <database>SUBSTRING</database>
      instead.</para>
      <section id="langrefupd25-notes-udf-null-upgrade">
        <title><quote>Upgrading</quote> <systemitem class="library">ib_udf</systemitem> functions in
        an existing database</title>
        <para>If you are using an existing database with one or more of the functions listed above
        under Firebird 2, and you want to benefit from the improved <constant>NULL</constant>
        handling, run the script <filename>ib_udf_upgrade.sql</filename> against your database. It
        is located in the Firebird <filename class="directory">misc\upgrade\ib_udf</filename>
        directory.</para>
      </section>
    </section>
    <section id="langrefupd25-notes-maxindices">
      <title>Maximum number of indices in different Firebird versions</title>
      <para>Between Firebird 1.0 and 2.0 there have been quite a few changes to the maximum number
      of indices per database table. The table below sums them all up.</para>
      <table id="langrefupd25-tbl-maxindices-varversions">
        <title>Max. indices per table in Firebird 1.0 – 2.0</title>
        <tgroup cols="13">
          <colspec align="left" colname="colPageSize" />
          <colspec align="center" colname="colFb10_1" />
          <colspec align="center" colname="colFb10_2" />
          <colspec align="center" colname="colFb10_3" />
          <colspec align="center" colname="colFb103_1" />
          <colspec align="center" colname="colFb103_2" />
          <colspec align="center" colname="colFb103_3" />
          <colspec align="center" colname="colFb15_1" />
          <colspec align="center" colname="colFb15_2" />
          <colspec align="center" colname="colFb15_3" />
          <colspec align="center" colname="colFb20_1" />
          <colspec align="center" colname="colFb20_2" />
          <colspec align="center" colname="colFb20_3" />
          <spanspec align="center" nameend="colFb10_3" namest="colFb10_1" spanname="spanFb10" />
          <spanspec align="center" nameend="colFb103_3" namest="colFb103_1" spanname="spanFb103" />
          <spanspec align="center" nameend="colFb15_3" namest="colFb15_1" spanname="spanFb15" />
          <spanspec align="center" nameend="colFb20_3" namest="colFb20_1" spanname="spanFb20" />
          <spanspec align="center" nameend="colFb20_3" namest="colFb10_1" spanname="spanAllVersions" />
          <thead>
            <row valign="top">
              <entry align="left" morerows="2">Page size</entry>
              <entry spanname="spanAllVersions">Firebird version(s)</entry>
            </row>
            <row>
              <entry spanname="spanFb10">1.0, 1.0.2</entry>
              <entry spanname="spanFb103">1.0.3</entry>
              <entry spanname="spanFb15">1.5.x</entry>
              <entry spanname="spanFb20">2.0.x</entry>
            </row>
            <row>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1024</entry>
              <entry>62</entry>
              <entry>50</entry>
              <entry>41</entry>
              <entry>62</entry>
              <entry>50</entry>
              <entry>41</entry>
              <entry>62</entry>
              <entry>50</entry>
              <entry>41</entry>
              <entry>50</entry>
              <entry>35</entry>
              <entry>27</entry>
            </row>
            <row>
              <entry>2048</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>126</entry>
              <entry>101</entry>
              <entry>84</entry>
              <entry>126</entry>
              <entry>101</entry>
              <entry>84</entry>
              <entry>101</entry>
              <entry>72</entry>
              <entry>56</entry>
            </row>
            <row>
              <entry>4096</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>254</entry>
              <entry>203</entry>
              <entry>169</entry>
              <entry>254</entry>
              <entry>203</entry>
              <entry>169</entry>
              <entry>203</entry>
              <entry>145</entry>
              <entry>113</entry>
            </row>
            <row>
              <entry>8192</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>510</entry>
              <entry>408</entry>
              <entry>340</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>408</entry>
              <entry>291</entry>
              <entry>227</entry>
            </row>
            <row>
              <entry>16384</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>1022</entry>
              <entry>818</entry>
              <entry>681</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>818</entry>
              <entry>584</entry>
              <entry>454</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd25-notes-rdbvalid_blr">
      <title>The <database>RDB$VALID_BLR</database> field</title>
      <para>The field <database>RDB$VALID_BLR</database> was added to the system tables
      <database>RDB$PROCEDURES</database> and <database>RDB$TRIGGERS</database> in Firebird 2.1. Its
      purpose is to signal possible invalidation of a PSQL module when a domain or a table column
      upon which the module depends is altered. If such invalidations occur,
      <database>RDB$VALID_BLR</database> is set to 0 for any procedure or trigger whose code is no
      longer valid.</para>
      <para>The following query will find the modules that depend on a specific
      <emphasis>domain</emphasis> and report the state of their <database>RDB$VALID_BLR</database>
      fields:</para>
      <blockquote>
        <programlisting>select * from (
  select 'Procedure', rdb$procedure_name, rdb$valid_blr from rdb$procedures
    union
  select 'Trigger', rdb$trigger_name, rdb$valid_blr from rdb$triggers
) (type, name, valid)
where exists
  (select * from rdb$dependencies
   where rdb$dependent_name = name and rdb$depended_on_name = '<replaceable>MYDOMAIN</replaceable>')

/* Replace <replaceable>MYDOMAIN</replaceable> with the actual domain name. Use all-caps if the domain
   was created case-insensitively. Otherwise, use the exact capitalisation. */</programlisting>
      </blockquote>
      <para>The following query will find the modules that depend on a specific <emphasis>table
      column</emphasis> and report the state of their <database>RDB$VALID_BLR</database>
      fields:</para>
      <blockquote>
        <programlisting>select * from (
  select 'Procedure', rdb$procedure_name, rdb$valid_blr from rdb$procedures
    union
  select 'Trigger', rdb$trigger_name, rdb$valid_blr from rdb$triggers
) (type, name, valid)
where exists
  (select * from rdb$dependencies
   where rdb$dependent_name = name
   and rdb$depended_on_name = '<replaceable>MYTABLE</replaceable>' and rdb$field_name = '<replaceable>MYCOLUMN</replaceable>')

/* Replace <replaceable>MYTABLE</replaceable> and <replaceable>MYCOLUMN</replaceable> with the actual table and column names.
   Use all-caps if the table/column was created case-insensitively.
   Otherwise, use the exact capitalisation. */</programlisting>
      </blockquote>
      <para>Unfortunately, not all PSQL invalidations will be reflected in the
      <database>RDB$VALID_BLR</database> field. After changing a domain or table column, it is
      therefore advisable to have a good look at all the procedures and triggers reported by the
      above queries, even those having a 1 in the <quote><database>VALID</database></quote>
      column.</para>
      <!--CORE-3303: RDB$VALID_BLR unreliable-->
      <para>Please notice that for PSQL modules inherited from earlier Firebird versions (including
      a number of system triggers, even if the database was created under Firebird 2.1 or higher),
      <database>RDB$VALID_BLR</database> is <constant>NULL</constant>. This does
      <emphasis>not</emphasis> imply that their BLR is invalid.</para>
      <para>The <application>isql</application> commands <database>SHOW PROCEDURES</database> and
      <database>SHOW TRIGGERS</database> flag modules whose <database>RDB$VALID_BLR</database> field
      is zero with an asterisk. <database>SHOW PROCEDURE</database>
      <replaceable>PROCNAME</replaceable> and <database>SHOW TRIGGER</database>
      <replaceable>TRIGNAME</replaceable>, which display individual PSQL modules, do not signal
      invalid BLR.<!--Request for improvement CORE-3149--></para>
    </section>
  </appendix>
  <appendix id="langrefupd25-reskeywords-full">
    <title>Reserved words and keywords – full lists</title>
    <section id="langrefupd25-reskeywords-full-reswords">
      <title>Reserved words</title>
      <para>Full list of reserved words in Firebird 2.5:</para>
      <blockquote>
        <simplelist>
          <member><database>ADD</database></member>
          <member><database>ADMIN</database></member>
          <member><database>ALL</database></member>
          <member><database>ALTER</database></member>
          <member><database>AND</database></member>
          <member><database>ANY</database></member>
          <member><database>AS</database></member>
          <member><database>AT</database></member>
          <member><database>AVG</database></member>
          <member><database>BEGIN</database></member>
          <member><database>BETWEEN</database></member>
          <member><database>BIGINT</database></member>
          <member><database>BIT_LENGTH</database></member>
          <member><database>BLOB</database></member>
          <member><database>BOTH</database></member>
          <member><database>BY</database></member>
          <member><database>CASE</database></member>
          <member><database>CAST</database></member>
          <member><database>CHAR</database></member>
          <member><database>CHAR_LENGTH</database></member>
          <member><database>CHARACTER</database></member>
          <member><database>CHARACTER_LENGTH</database></member>
          <member><database>CHECK</database></member>
          <member><database>CLOSE</database></member>
          <member><database>COLLATE</database></member>
          <member><database>COLUMN</database></member>
          <member><database>COMMIT</database></member>
          <member><database>CONNECT</database></member>
          <member><database>CONSTRAINT</database></member>
          <member><database>COUNT</database></member>
          <member><database>CREATE</database></member>
          <member><database>CROSS</database></member>
          <member><database>CURRENT</database></member>
          <member><database>CURRENT_CONNECTION</database></member>
          <member><database>CURRENT_DATE</database></member>
          <member><database>CURRENT_ROLE</database></member>
          <member><database>CURRENT_TIME</database></member>
          <member><database>CURRENT_TIMESTAMP</database></member>
          <member><database>CURRENT_TRANSACTION</database></member>
          <member><database>CURRENT_USER</database></member>
          <member><database>CURSOR</database></member>
          <member><database>DATE</database></member>
          <member><database>DAY</database></member>
          <member><database>DEC</database></member>
          <member><database>DECIMAL</database></member>
          <member><database>DECLARE</database></member>
          <member><database>DEFAULT</database></member>
          <member><database>DELETE</database></member>
          <member><database>DISCONNECT</database></member>
          <member><database>DISTINCT</database></member>
          <member><database>DOUBLE</database></member>
          <member><database>DROP</database></member>
          <member><database>ELSE</database></member>
          <member><database>END</database></member>
          <member><database>ESCAPE</database></member>
          <member><database>EXECUTE</database></member>
          <member><database>EXISTS</database></member>
          <member><database>EXTERNAL</database></member>
          <member><database>EXTRACT</database></member>
          <member><database>FETCH</database></member>
          <member><database>FILTER</database></member>
          <member><database>FLOAT</database></member>
          <member><database>FOR</database></member>
          <member><database>FOREIGN</database></member>
          <member><database>FROM</database></member>
          <member><database>FULL</database></member>
          <member><database>FUNCTION</database></member>
          <member><database>GDSCODE</database></member>
          <member><database>GLOBAL</database></member>
          <member><database>GRANT</database></member>
          <member><database>GROUP</database></member>
          <member><database>HAVING</database></member>
          <member><database>HOUR</database></member>
          <member><database>IN</database></member>
          <member><database>INDEX</database></member>
          <member><database>INNER</database></member>
          <member><database>INSENSITIVE</database></member>
          <member><database>INSERT</database></member>
          <member><database>INT</database></member>
          <member><database>INTEGER</database></member>
          <member><database>INTO</database></member>
          <member><database>IS</database></member>
          <member><database>JOIN</database></member>
          <member><database>LEADING</database></member>
          <member><database>LEFT</database></member>
          <member><database>LIKE</database></member>
          <member><database>LONG</database></member>
          <member><database>LOWER</database></member>
          <member><database>MAX</database></member>
          <member><database>MAXIMUM_SEGMENT</database></member>
          <member><database>MERGE</database></member>
          <member><database>MIN</database></member>
          <member><database>MINUTE</database></member>
          <member><database>MONTH</database></member>
          <member><database>NATIONAL</database></member>
          <member><database>NATURAL</database></member>
          <member><database>NCHAR</database></member>
          <member><database>NO</database></member>
          <member><database>NOT</database></member>
          <member><database>NULL</database></member>
          <member><database>NUMERIC</database></member>
          <member><database>OCTET_LENGTH</database></member>
          <member><database>OF</database></member>
          <member><database>ON</database></member>
          <member><database>ONLY</database></member>
          <member><database>OPEN</database></member>
          <member><database>OR</database></member>
          <member><database>ORDER</database></member>
          <member><database>OUTER</database></member>
          <member><database>PARAMETER</database></member>
          <member><database>PLAN</database></member>
          <member><database>POSITION</database></member>
          <member><database>POST_EVENT</database></member>
          <member><database>PRECISION</database></member>
          <member><database>PRIMARY</database></member>
          <member><database>PROCEDURE</database></member>
          <member><database>RDB$DB_KEY</database></member>
          <member><database>REAL</database></member>
          <member><database>RECORD_VERSION</database></member>
          <member><database>RECREATE</database></member>
          <member><database>RECURSIVE</database></member>
          <member><database>REFERENCES</database></member>
          <member><database>RELEASE</database></member>
          <member><database>RETURNING_VALUES</database></member>
          <member><database>RETURNS</database></member>
          <member><database>REVOKE</database></member>
          <member><database>RIGHT</database></member>
          <member><database>ROLLBACK</database></member>
          <member><database>ROW_COUNT</database></member>
          <member><database>ROWS</database></member>
          <member><database>SAVEPOINT</database></member>
          <member><database>SECOND</database></member>
          <member><database>SELECT</database></member>
          <member><database>SENSITIVE</database></member>
          <member><database>SET</database></member>
          <member><database>SIMILAR</database></member>
          <member><database>SMALLINT</database></member>
          <member><database>SOME</database></member>
          <member><database>SQLCODE</database></member>
          <member><database>SQLSTATE</database> (2.5.1)</member>
          <member><database>START</database></member>
          <member><database>SUM</database></member>
          <member><database>TABLE</database></member>
          <member><database>THEN</database></member>
          <member><database>TIME</database></member>
          <member><database>TIMESTAMP</database></member>
          <member><database>TO</database></member>
          <member><database>TRAILING</database></member>
          <member><database>TRIGGER</database></member>
          <member><database>TRIM</database></member>
          <member><database>UNION</database></member>
          <member><database>UNIQUE</database></member>
          <member><database>UPDATE</database></member>
          <member><database>UPPER</database></member>
          <member><database>USER</database></member>
          <member><database>USING</database></member>
          <member><database>VALUE</database></member>
          <member><database>VALUES</database></member>
          <member><database>VARCHAR</database></member>
          <member><database>VARIABLE</database></member>
          <member><database>VARYING</database></member>
          <member><database>VIEW</database></member>
          <member><database>WHEN</database></member>
          <member><database>WHERE</database></member>
          <member><database>WHILE</database></member>
          <member><database>WITH</database></member>
          <member><database>YEAR</database></member>
        </simplelist>
      </blockquote>
    </section>
    <section id="langrefupd25-reskeywords-full-keywords">
      <title>Keywords</title>
      <para>The following terms have a special meaning in Firebird 2.5 DSQL. Some of them are also
      reserved words, others aren't.</para>
      <!--This list is simpy taken from src/dsql/keywords.cpp, and sorted.-->
      <blockquote>
        <simplelist>
          <member><literal>!&lt;</literal></member>
          <member><literal>^&lt;</literal></member>
          <member><literal>^=</literal></member>
          <member><literal>^&gt;</literal></member>
          <member><literal>,</literal></member>
          <member><literal>:=</literal></member>
          <member><literal>!=</literal></member>
          <member><literal>!&gt;</literal></member>
          <member><literal>(</literal></member>
          <member><literal>)</literal></member>
          <member><literal>&lt;</literal></member>
          <member><literal>&lt;=</literal></member>
          <member><literal>&lt;&gt;</literal></member>
          <member><literal>=</literal></member>
          <member><literal>&gt;</literal></member>
          <member><literal>&gt;=</literal></member>
          <member><literal>||</literal></member>
          <member><literal>~&lt;</literal></member>
          <member><literal>~=</literal></member>
          <member><literal>~&gt;</literal></member>
          <member><database>ABS</database></member>
          <member><database>ACCENT</database></member>
          <member><database>ACOS</database></member>
          <member><database>ACTION</database></member>
          <member><database>ACTIVE</database></member>
          <member><database>ADD</database></member>
          <member><database>ADMIN</database></member>
          <member><database>AFTER</database></member>
          <member><database>ALL</database></member>
          <member><database>ALTER</database></member>
          <member><database>ALWAYS</database></member>
          <member><database>AND</database></member>
          <member><database>ANY</database></member>
          <member><database>AS</database></member>
          <member><database>ASC</database></member>
          <member><database>ASCENDING</database></member>
          <member><database>ASCII_CHAR</database></member>
          <member><database>ASCII_VAL</database></member>
          <member><database>ASIN</database></member>
          <member><database>AT</database></member>
          <member><database>ATAN</database></member>
          <member><database>ATAN2</database></member>
          <member><database>AUTO</database></member>
          <member><database>AUTONOMOUS</database></member>
          <member><database>AVG</database></member>
          <member><database>BACKUP</database></member>
          <member><database>BEFORE</database></member>
          <member><database>BEGIN</database></member>
          <member><database>BETWEEN</database></member>
          <member><database>BIGINT</database></member>
          <member><database>BIN_AND</database></member>
          <member><database>BIN_NOT</database></member>
          <member><database>BIN_OR</database></member>
          <member><database>BIN_SHL</database></member>
          <member><database>BIN_SHR</database></member>
          <member><database>BIN_XOR</database></member>
          <member><database>BIT_LENGTH</database></member>
          <member><database>BLOB</database></member>
          <member><database>BLOCK</database></member>
          <member><database>BOTH</database></member>
          <member><database>BREAK</database></member>
          <member><database>BY</database></member>
          <member><database>CALLER</database></member>
          <member><database>CASCADE</database></member>
          <member><database>CASE</database></member>
          <member><database>CAST</database></member>
          <member><database>CEIL</database></member>
          <member><database>CEILING</database></member>
          <member><database>CHAR</database></member>
          <member><database>CHAR_LENGTH</database></member>
          <member><database>CHAR_TO_UUID</database></member>
          <member><database>CHARACTER</database></member>
          <member><database>CHARACTER_LENGTH</database></member>
          <member><database>CHECK</database></member>
          <member><database>CLOSE</database></member>
          <member><database>COALESCE</database></member>
          <member><database>COLLATE</database></member>
          <member><database>COLLATION</database></member>
          <member><database>COLUMN</database></member>
          <member><database>COMMENT</database></member>
          <member><database>COMMIT</database></member>
          <member><database>COMMITTED</database></member>
          <member><database>COMMON</database></member>
          <member><database>COMPUTED</database></member>
          <member><database>CONDITIONAL</database></member>
          <member><database>CONNECT</database></member>
          <member><database>CONSTRAINT</database></member>
          <member><database>CONTAINING</database></member>
          <member><database>COS</database></member>
          <member><database>COSH</database></member>
          <member><database>COT</database></member>
          <member><database>COUNT</database></member>
          <member><database>CREATE</database></member>
          <member><database>CROSS</database></member>
          <member><database>CSTRING</database></member>
          <member><database>CURRENT</database></member>
          <member><database>CURRENT_CONNECTION</database></member>
          <member><database>CURRENT_DATE</database></member>
          <member><database>CURRENT_ROLE</database></member>
          <member><database>CURRENT_TIME</database></member>
          <member><database>CURRENT_TIMESTAMP</database></member>
          <member><database>CURRENT_TRANSACTION</database></member>
          <member><database>CURRENT_USER</database></member>
          <member><database>CURSOR</database></member>
          <member><database>DATA</database></member>
          <member><database>DATABASE</database></member>
          <member><database>DATE</database></member>
          <member><database>DATEADD</database></member>
          <member><database>DATEDIFF</database></member>
          <member><database>DAY</database></member>
          <member><database>DEC</database></member>
          <member><database>DECIMAL</database></member>
          <member><database>DECLARE</database></member>
          <member><database>DECODE</database></member>
          <member><database>DEFAULT</database></member>
          <member><database>DELETE</database></member>
          <member><database>DELETING</database></member>
          <member><database>DESC</database></member>
          <member><database>DESCENDING</database></member>
          <member><database>DESCRIPTOR</database></member>
          <member><database>DIFFERENCE</database></member>
          <member><database>DISCONNECT</database></member>
          <member><database>DISTINCT</database></member>
          <member><database>DO</database></member>
          <member><database>DOMAIN</database></member>
          <member><database>DOUBLE</database></member>
          <member><database>DROP</database></member>
          <member><database>ELSE</database></member>
          <member><database>END</database></member>
          <member><database>ENTRY_POINT</database></member>
          <member><database>ESCAPE</database></member>
          <member><database>EXCEPTION</database></member>
          <member><database>EXECUTE</database></member>
          <member><database>EXISTS</database></member>
          <member><database>EXIT</database></member>
          <member><database>EXP</database></member>
          <member><database>EXTERNAL</database></member>
          <member><database>EXTRACT</database></member>
          <member><database>FETCH</database></member>
          <member><database>FILE</database></member>
          <member><database>FILTER</database></member>
          <member><database>FIRST</database></member>
          <member><database>FIRSTNAME</database></member>
          <member><database>FLOAT</database></member>
          <member><database>FLOOR</database></member>
          <member><database>FOR</database></member>
          <member><database>FOREIGN</database></member>
          <member><database>FREE_IT</database></member>
          <member><database>FROM</database></member>
          <member><database>FULL</database></member>
          <member><database>FUNCTION</database></member>
          <member><database>GDSCODE</database></member>
          <member><database>GEN_ID</database></member>
          <member><database>GEN_UUID</database></member>
          <member><database>GENERATED</database></member>
          <member><database>GENERATOR</database></member>
          <member><database>GLOBAL</database></member>
          <member><database>GRANT</database></member>
          <member><database>GRANTED</database></member>
          <member><database>GROUP</database></member>
          <member><database>HASH</database></member>
          <member><database>HAVING</database></member>
          <member><database>HOUR</database></member>
          <member><database>IF</database></member>
          <member><database>IGNORE</database></member>
          <member><database>IIF</database></member>
          <member><database>IN</database></member>
          <member><database>INACTIVE</database></member>
          <member><database>INDEX</database></member>
          <member><database>INNER</database></member>
          <member><database>INPUT_TYPE</database></member>
          <member><database>INSENSITIVE</database></member>
          <member><database>INSERT</database></member>
          <member><database>INSERTING</database></member>
          <member><database>INT</database></member>
          <member><database>INTEGER</database></member>
          <member><database>INTO</database></member>
          <member><database>IS</database></member>
          <member><database>ISOLATION</database></member>
          <member><database>JOIN</database></member>
          <member><database>KEY</database></member>
          <member><database>LAST</database></member>
          <member><database>LASTNAME</database></member>
          <member><database>LEADING</database></member>
          <member><database>LEAVE</database></member>
          <member><database>LEFT</database></member>
          <member><database>LENGTH</database></member>
          <member><database>LEVEL</database></member>
          <member><database>LIKE</database></member>
          <member><database>LIMBO</database></member>
          <member><database>LIST</database></member>
          <member><database>LN</database></member>
          <member><database>LOCK</database></member>
          <member><database>LOG</database></member>
          <member><database>LOG10</database></member>
          <member><database>LONG</database></member>
          <member><database>LOWER</database></member>
          <member><database>LPAD</database></member>
          <member><database>MANUAL</database></member>
          <member><database>MAPPING</database></member>
          <member><database>MATCHED</database></member>
          <member><database>MATCHING</database></member>
          <member><database>MAX</database></member>
          <member><database>MAXIMUM_SEGMENT</database></member>
          <member><database>MAXVALUE</database></member>
          <member><database>MERGE</database></member>
          <member><database>MIDDLENAME</database></member>
          <member><database>MILLISECOND</database></member>
          <member><database>MIN</database></member>
          <member><database>MINUTE</database></member>
          <member><database>MINVALUE</database></member>
          <member><database>MOD</database></member>
          <member><database>MODULE_NAME</database></member>
          <member><database>MONTH</database></member>
          <member><database>NAMES</database></member>
          <member><database>NATIONAL</database></member>
          <member><database>NATURAL</database></member>
          <member><database>NCHAR</database></member>
          <member><database>NEXT</database></member>
          <member><database>NO</database></member>
          <member><database>NOT</database></member>
          <member><database>NULL</database></member>
          <member><database>NULLIF</database></member>
          <member><database>NULLS</database></member>
          <member><database>NUMERIC</database></member>
          <member><database>OCTET_LENGTH</database></member>
          <member><database>OF</database></member>
          <member><database>ON</database></member>
          <member><database>ONLY</database></member>
          <member><database>OPEN</database></member>
          <member><database>OPTION</database></member>
          <member><database>OR</database></member>
          <member><database>ORDER</database></member>
          <member><database>OS_NAME</database></member>
          <member><database>OUTER</database></member>
          <member><database>OUTPUT_TYPE</database></member>
          <member><database>OVERFLOW</database></member>
          <member><database>OVERLAY</database></member>
          <member><database>PAD</database></member>
          <member><database>PAGE</database></member>
          <member><database>PAGE_SIZE</database></member>
          <member><database>PAGES</database></member>
          <member><database>PARAMETER</database></member>
          <member><database>PASSWORD</database></member>
          <member><database>PI</database></member>
          <member><database>PLACING</database></member>
          <member><database>PLAN</database></member>
          <member><database>POSITION</database></member>
          <member><database>POST_EVENT</database></member>
          <member><database>POWER</database></member>
          <member><database>PRECISION</database></member>
          <member><database>PRESERVE</database></member>
          <member><database>PRIMARY</database></member>
          <member><database>PRIVILEGES</database></member>
          <member><database>PROCEDURE</database></member>
          <member><database>PROTECTED</database></member>
          <member><database>RAND</database></member>
          <member><database>RDB$DB_KEY</database></member>
          <member><database>READ</database></member>
          <member><database>REAL</database></member>
          <member><database>RECORD_VERSION</database></member>
          <member><database>RECREATE</database></member>
          <member><database>RECURSIVE</database></member>
          <member><database>REFERENCES</database></member>
          <member><database>RELEASE</database></member>
          <member><database>REPLACE</database></member>
          <member><database>REQUESTS</database></member>
          <member><database>RESERV</database></member>
          <member><database>RESERVING</database></member>
          <member><database>RESTART</database></member>
          <member><database>RESTRICT</database></member>
          <member><database>RETAIN</database></member>
          <member><database>RETURNING</database></member>
          <member><database>RETURNING_VALUES</database></member>
          <member><database>RETURNS</database></member>
          <member><database>REVERSE</database></member>
          <member><database>REVOKE</database></member>
          <member><database>RIGHT</database></member>
          <member><database>ROLE</database></member>
          <member><database>ROLLBACK</database></member>
          <member><database>ROUND</database></member>
          <member><database>ROW_COUNT</database></member>
          <member><database>ROWS</database></member>
          <member><database>RPAD</database></member>
          <member><database>SAVEPOINT</database></member>
          <member><database>SCALAR_ARRAY</database></member>
          <member><database>SCHEMA</database></member>
          <member><database>SECOND</database></member>
          <member><database>SEGMENT</database></member>
          <member><database>SELECT</database></member>
          <member><database>SENSITIVE</database></member>
          <member><database>SEQUENCE</database></member>
          <member><database>SET</database></member>
          <member><database>SHADOW</database></member>
          <member><database>SHARED</database></member>
          <member><database>SIGN</database></member>
          <member><database>SIMILAR</database></member>
          <member><database>SIN</database></member>
          <member><database>SINGULAR</database></member>
          <member><database>SINH</database></member>
          <member><database>SIZE</database></member>
          <member><database>SKIP</database></member>
          <member><database>SMALLINT</database></member>
          <member><database>SNAPSHOT</database></member>
          <member><database>SOME</database></member>
          <member><database>SORT</database></member>
          <member><database>SOURCE</database></member>
          <member><database>SPACE</database></member>
          <member><database>SQLCODE</database></member>
          <member><database>SQLSTATE</database> (2.5.1)</member>
          <member><database>SQRT</database></member>
          <member><database>STABILITY</database></member>
          <member><database>START</database></member>
          <member><database>STARTING</database></member>
          <member><database>STARTS</database></member>
          <member><database>STATEMENT</database></member>
          <member><database>STATISTICS</database></member>
          <member><database>SUB_TYPE</database></member>
          <member><database>SUBSTRING</database></member>
          <member><database>SUM</database></member>
          <member><database>SUSPEND</database></member>
          <member><database>TABLE</database></member>
          <member><database>TAN</database></member>
          <member><database>TANH</database></member>
          <member><database>TEMPORARY</database></member>
          <member><database>THEN</database></member>
          <member><database>TIME</database></member>
          <member><database>TIMEOUT</database></member>
          <member><database>TIMESTAMP</database></member>
          <member><database>TO</database></member>
          <member><database>TRAILING</database></member>
          <member><database>TRANSACTION</database></member>
          <member><database>TRIGGER</database></member>
          <member><database>TRIM</database></member>
          <member><database>TRUNC</database></member>
          <member><database>TWO_PHASE</database></member>
          <member><database>TYPE</database></member>
          <member><database>UNCOMMITTED</database></member>
          <member><database>UNDO</database></member>
          <member><database>UNION</database></member>
          <member><database>UNIQUE</database></member>
          <member><database>UPDATE</database></member>
          <member><database>UPDATING</database></member>
          <member><database>UPPER</database></member>
          <member><database>USER</database></member>
          <member><database>USING</database></member>
          <member><database>UUID_TO_CHAR</database></member>
          <member><database>VALUE</database></member>
          <member><database>VALUES</database></member>
          <member><database>VARCHAR</database></member>
          <member><database>VARIABLE</database></member>
          <member><database>VARYING</database></member>
          <member><database>VIEW</database></member>
          <member><database>WAIT</database></member>
          <member><database>WEEK</database></member>
          <member><database>WEEKDAY</database></member>
          <member><database>WHEN</database></member>
          <member><database>WHERE</database></member>
          <member><database>WHILE</database></member>
          <member><database>WITH</database></member>
          <member><database>WORK</database></member>
          <member><database>WRITE</database></member>
          <member><database>YEAR</database></member>
          <member><database>YEARDAY</database></member>
        </simplelist>
      </blockquote>
    </section>
  </appendix>
  <appendix id="langrefupd25-dochist">
    <title>Document History</title>
    <para>The exact file history is recorded in the <filename class="directory">manual</filename>
    module in our CVS tree; see <ulink
    url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/</ulink></para>
    <para><revhistory>
        <revision>
          <revnumber>0.0</revnumber>
          <date>—</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>Creation of the document as a copy of the <citetitle>Firebird 2.1 Language
            Reference Update</citetitle> with IDs, titles, version numbers etc. updated to
            2.5.</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.0</revnumber>
          <date>12 Jun 2011</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para><citetitle>Introduction :: Subject matter</citetitle>: Added <quote>Security and
            access control statements</quote> to first list. Changed ulink to Firebird Documentation
            Index (both text and url).</para>
            <para><citetitle>Introduction :: Authorship</citetitle>: Changed percentage of included
            material to 2–3%.</para>
            <para><citetitle>Introduction</citetitle>: New section
            <citetitle>Acknowledgments</citetitle>.</para>
            <para>New chapter: <citetitle>New in Firebird 2.5</citetitle>.</para>
            <para><citetitle>Reserved words and keywords</citetitle>: Updated/corrected all the
            lists in all the subsections (except <citetitle>Possibly reserved in future
            versions</citetitle>). Also changed/added much of the text above and below the
            lists.</para>
            <para><citetitle>Reserved words and keywords :: Dropped since InterBase 6</citetitle>:
            Changed subsection titles to <citetitle>No longer reserved, still keywords</citetitle>
            and <citetitle>No longer reserved, not keywords</citetitle>, for better clarity.</para>
            <para><citetitle>Miscellaneous language elements</citetitle>: New section
            <citetitle>Hexadecimal notation for numerals</citetitle>.</para>
            <para><citetitle>Miscellaneous language elements</citetitle>: New section
            <citetitle>Hexadecimal notation for <quote>binary</quote> strings</citetitle>.</para>
            <para><citetitle>Data types and subtypes :: <database>BIGINT</database> data
            type</citetitle>: Added information on hex notation; added second example.</para>
            <para><citetitle>Data types and subtypes :: <database>BLOB</database> data type :: Text
            <database>BLOB</database> support in functions and operators</citetitle>: Altered
            <quote>Changed in</quote>; edited 2nd listitem under <quote>Level of support</quote>
            (CORE-3233 fixed).</para>
            <para><citetitle>Data types and subtypes :: New character sets</citetitle>: Added 2.5 to
            <quote>Changed in</quote>; added new charset <database>GB18030</database> and new alias
            <database>WIN_1258</database>.</para>
            <para><citetitle>Data types and subtypes :: New collations</citetitle>: Added 2.5 to
            <quote>Changed in</quote>; added new collations <database>GB18030_UNICODE</database>
            (for <database>GB18030</database>) and <database>UNICODE_CI_AI</database> (for
            <database>UTF8</database>). Added line on <database>UNICODE_CI_AI</database> to
            Note.</para>
            <para><citetitle>Data types and subtypes</citetitle>: New section
            <citetitle><database>SQL_NULL</database> data type</citetitle>.</para>
            <para><citetitle>DDL statements</citetitle>: Removed last line from introductory
            text.</para>
            <para><citetitle>DDL statements</citetitle>: New section <citetitle><database>CHARACTER
            SET</database></citetitle>, with subsection <citetitle><database>ALTER CHARACTER
            SET</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>COLLATION</database> :: <database>CREATE
            COLLATION</database></citetitle>: Added <quote>Changed in</quote>; altered explanation
            of <quote>UNI</quote> in specific attributes table; gave table body valign=top; added
            NUMERIC-SORT to specific attributes table and added note beneath table.</para>
            <para><citetitle>DDL statements :: <database>DATABASE</database> :: <database>CREATE
            DATABASE</database></citetitle>: New subsection <citetitle>Default collation for the
            database</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>DATABASE</database> :: <database>ALTER
            DATABASE</database> :: <database>END BACKUP</database></citetitle>: Updated URL of
            Firebird Documentation Index in Tip.</para>
            <para><citetitle>DDL statements :: <database>DOMAIN</database> :: <database>ALTER
            DOMAIN</database></citetitle>: Replaced contents of Warning with reference to
            <database>RDB$VALID_BLR</database> note.</para>
            <para><citetitle>DDL statements :: Privileges: <database>GRANT</database> and
            <database>REVOKE</database></citetitle>: Moved to chapter <citetitle>Security and access
            control</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database></citetitle>: Changed
            introductory text (mentioned executable blocks).</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>CREATE
            PROCEDURE</database></citetitle>: Altered Syntax (added <database>TYPE OF
            COLUMN</database>).</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>CREATE
            PROCEDURE</database></citetitle>: New subsection <citetitle><database>TYPE OF
            COLUMN</database> in parameter and variable declarations</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>CREATE
            PROCEDURE</database> :: Domains supported in parameter and variable
            declarations</citetitle>: Edited and extended Description. Replaced contents of Warning
            with reference to <database>RDB$VALID_BLR</database> note.</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>CREATE
            PROCEDURE</database> :: <database>NOT NULL</database> in variable and parameter
            declarations</citetitle>: Changed layout of Example (first line too long for
            PDF).</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>ALTER
            PROCEDURE</database></citetitle>: New subsection <citetitle>Classic Server: Altered
            procedure immediately visible to other clients</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>ALTER
            PROCEDURE</database></citetitle>: New subsection <citetitle><database>TYPE OF
            COLUMN</database> in parameter and variable declarations</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>TABLE</database> :: <database>ALTER
            TABLE</database></citetitle>: New subsection <citetitle><database>ALTER
            COLUMN</database> also for generated (computed) columns</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>TABLE</database> :: <database>ALTER
            TABLE</database></citetitle>: New subsection <citetitle><database>ALTER COLUMN ...
            TYPE</database> no longer fails if column is used in trigger or SP</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>TRIGGER</database> :: <database>CREATE
            TRIGGER</database></citetitle>: New subsection <citetitle><database>TYPE OF
            COLUMN</database> in variable declarations</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>TRIGGER</database> :: <database>ALTER
            TRIGGER</database></citetitle>: New subsection <citetitle><database>TYPE OF
            COLUMN</database> in variable declarations</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>VIEW</database> :: <database>CREATE
            VIEW</database></citetitle>: Added Syntax.</para>
            <para><citetitle>DDL statements :: <database>VIEW</database> :: <database>CREATE
            VIEW</database></citetitle>: New subsection <citetitle>Views can select from stored
            procedures</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>VIEW</database> :: <database>CREATE
            VIEW</database></citetitle>: New subsection <citetitle>Views can infer column names from
            derived tables or <database>GROUP BY</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>VIEW</database> :: <database>CREATE
            VIEW</database> :: Per-column aliases supported in view definition</citetitle>:
            Shortened partial Syntax.</para>
            <para><citetitle>DDL statements :: <database>VIEW</database> :: <database>CREATE
            VIEW</database> :: Full <database>SELECT</database> syntax supported</citetitle>:
            Altered <quote>Changed in</quote>. Altered Note on union views.</para>
            <para><citetitle>DDL statements :: <database>VIEW</database></citetitle>: New sections
            <citetitle><database>ALTER VIEW</database> </citetitle>and <citetitle><database>CREATE
            OR ALTER VIEW</database></citetitle>.</para>
            <para><citetitle>DML statements :: <database>DELETE</database></citetitle>: Improved
            formal syntax (<replaceable>values</replaceable> -&gt;
            <replaceable>&lt;values&gt;</replaceable> and added specification of latter).</para>
            <para><citetitle>DML statements :: <database>EXECUTE BLOCK</database></citetitle>: Added
            2.5 to <quote>Changed in</quote>. Altered Syntax (added <database>TYPE OF
            COLUMN</database>).</para>
            <para><citetitle>DML statements :: <database>EXECUTE BLOCK</database> :: Domains instead
            of datatypes</citetitle>: Extended Description. Added Warning about collations.</para>
            <para><citetitle>DML statements :: <database>EXECUTE BLOCK</database></citetitle>: New
            subsection <citetitle><database>TYPE OF COLUMN</database> in parameter and variable
            declarations</citetitle>.</para>
            <para><citetitle>DML statements :: <database>INSERT</database></citetitle>: Improved
            formal syntax (<replaceable>value</replaceable> -&gt;
            <replaceable>value_expression</replaceable>) and removed erroneous space.</para>
            <para><citetitle>DML statements :: <database>UPDATE</database></citetitle>: Improved
            formal syntax (<replaceable>values</replaceable> -&gt;
            <replaceable>&lt;values&gt;</replaceable> and added specification of latter).</para>
            <para><citetitle>DML statements :: <database>UPDATE</database></citetitle>: New section
            <citetitle>Changed <database>SET</database> semantics</citetitle>.</para>
            <para><citetitle>PSQL statements</citetitle>: Changed introductory paragraph to mention
            executable blocks.</para>
            <para><citetitle>PSQL statements :: <database>DECLARE</database></citetitle>: Altered
            Syntax (added <database>TYPE OF COLUMN</database>). Made itemizedlist after Syntax
            compact.</para>
            <para><citetitle>PSQL statements :: <database>DECLARE</database> ::
            <database>DECLARE</database> with <database>DOMAIN</database> instead of
            datatype</citetitle>: Extended Description. Replaced contents of Warning with reference
            to <database>RDB$VALID_BLR</database> note.</para>
            <para><citetitle>PSQL statements :: <database>DECLARE</database></citetitle>: New
            subsection <citetitle><database>TYPE OF COLUMN</database> in variable
            declaration</citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            Added <quote>Changed in</quote>. Altered Description. Added Syntax. Added para
            introducing following subsections.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database> :: Any number
            of data rows returned</citetitle>: Improved Syntax block. Removed spaces inside
            parentheses in Example.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            New section <citetitle>Improved performance</citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            New section <citetitle><database>WITH</database>
            {<database>AUTONOMOUS</database>|<database>COMMON</database>}
            <database>TRANSACTION</database></citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            New section <citetitle><database>WITH CALLER PRIVILEGES</database></citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            New section <citetitle><database>ON EXTERNAL</database> [<database>DATA
            SOURCE</database>]</citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            New section <citetitle><database>AS USER</database>, <database>PASSWORD</database> and
            <database>ROLE</database></citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database></citetitle>:
            New section <citetitle>Parameterized statements</citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database> :: Caveats
            with <database>EXECUTE STATEMENT</database></citetitle>: Edited item 3 (performance).
            Removed items 4 and 6. Edited final paragraph (less negative).</para>
            <para><citetitle>PSQL statements</citetitle>: New section <citetitle><database>IN
            AUTONOMOUS TRANSACTION</database></citetitle>.</para>
            <para><citetitle>PSQL statements</citetitle>: New section <citetitle>Subqueries as PSQL
            expressions</citetitle>.</para>
            <para>New chapter: <citetitle>Security and access control</citetitle>.</para>
            <para><citetitle>Security and access control</citetitle>: New section
            <citetitle><database>ALTER ROLE</database></citetitle>.</para>
            <para><citetitle>Security and access control :: <database>GRANT</database> and
            <database>REVOKE</database></citetitle>: Moved here from DDL chapter. Changed id.</para>
            <para><citetitle>Security and access control :: <database>GRANT</database> and
            <database>REVOKE</database></citetitle>: New section <citetitle><database>GRANTED
            BY</database></citetitle>.</para>
            <para><citetitle>Security and access control :: <database>GRANT</database> and
            <database>REVOKE</database></citetitle>: New section <citetitle><database>REVOKE ALL ON
            ALL</database></citetitle>.</para>
            <para><citetitle>Security and access control :: <database>GRANT</database> and
            <database>REVOKE</database> :: <database>REVOKE ADMIN OPTION</database></citetitle>:
            Changed id.</para>
            <para><citetitle>Security and access control</citetitle>: New section <citetitle>The
            <database>RDB$ADMIN</database> role</citetitle>.</para>
            <para><citetitle>Security and access control</citetitle>: New section
            <citetitle><database>AUTO ADMIN MAPPING</database></citetitle>.</para>
            <para><citetitle>Security and access control</citetitle>: New section <citetitle>SQL
            user management commands</citetitle>.</para>
            <para><citetitle>Operators and predicates</citetitle>: New section
            <citetitle><database>SIMILAR TO</database></citetitle>.</para>
            <para><citetitle>Aggregate functions :: <database>LIST()</database></citetitle>: Added
            <quote>Changed in</quote> formalpara. Edited second Syntax note (about separator).
            Removed Warning about truncation bug in 2.1–2.1.3.</para>
            <para><citetitle>Internal functions :: <database>ASCII_VAL()</database></citetitle>:
            Edited listitem about bug (mentioned 2.5.x versions).</para>
            <para><citetitle>Internal functions :: <database>ATAN2()</database></citetitle>: Edited
            3rd Syntax note (mentioned error raised in Fb 3).</para>
            <para><citetitle>Internal functions :: <database>CAST()</database></citetitle>: Added
            2.5 to <quote>Changed in</quote>. Altered Syntax (added <database>TYPE OF
            COLUMN</database>). Added formalpara <citetitle>Casting to a column's
            type</citetitle>.</para>
            <para><citetitle>Internal functions</citetitle>: New section
            <citetitle><database>CHAR_TO_UUID()</database></citetitle>.</para>
            <para><citetitle>Internal functions :: <database>DATEADD()</database></citetitle>:
            <database>WEEK</database> unit added and sub-<database>DAY</database> units allowed with
            <database>DATE</database>s: Added <quote>Changed in</quote>. Edited Description, Syntax,
            2nd listitem after Syntax, and added additional example.</para>
            <para><citetitle>Internal functions :: <database>DATEDIFF()</database></citetitle>:
            <database>WEEK</database> unit added and sub-<database>DAY</database> units allowed with
            <database>DATE</database>s: Added <quote>Changed in</quote>. Edited Description, Syntax,
            and 2nd listitem after Syntax.</para>
            <para><citetitle>Internal functions :: <database>EXTRACT()</database></citetitle>:
            Corrected millisecond range in table (0.0000 -&gt; 0.0).</para>
            <para><citetitle>Internal functions :: <database>EXTRACT()</database> ::
            <database>MILLISECOND</database></citetitle>: Removed Bug alert for 2.1–2.1.1.</para>
            <para><citetitle>Internal functions :: <database>GEN_UUID()</database></citetitle>:
            Added Example. Added links to new UUID functions.</para>
            <para><citetitle>Internal functions :: <database>LOG()</database></citetitle>: Added
            <quote>Changed in</quote>. Edited all the listitems under Syntax.</para>
            <para><citetitle>Internal functions :: <database>LOG10()</database></citetitle>: Added
            <quote>Changed in</quote>. Edited listitem under Syntax.</para>
            <para><citetitle>Internal functions :: <database>LOWER()</database></citetitle>:
            Replaced Important after Syntax with Note, with different text.</para>
            <para><citetitle>Internal functions :: <database>LPAD()</database></citetitle>: Added
            <quote>Changed in</quote>. Altered result type. Altered 2nd listitem after Syntax.
            Changed Tip to Note and edited text.</para>
            <para><citetitle>Internal functions :: <database>OVERLAY()</database></citetitle>:
            Changed 1st word of Description (<quote>Replaces</quote> -&gt;
            <quote>Overwrites</quote>). Shortened 1st listitem after Syntax: removed description of
            2.1-specific bug.</para>
            <para><citetitle>Internal functions ::
            <database>RDB$GET_CONTEXT()</database></citetitle>: Added
            <varname>ENGINE_VERSION</varname> context var (added in 2.1).</para>
            <para><citetitle>Internal functions :: <database>RIGHT()</database></citetitle>: Edited
            1st listitem after Syntax, about CORE-3228.</para>
            <para><citetitle>Internal functions :: <database>RPAD()</database></citetitle>: Added
            <quote>Changed in</quote>. Altered result type. Altered 2nd listitem after Syntax.
            Changed Tip to Note and edited text.</para>
            <para><citetitle>Internal functions :: <database>SUBSTRING()</database></citetitle>:
            Added 2.1.5 and 2.5.1 to <quote>Changed in</quote>. Noted fixing of first bug in 2.1.5
            and 2.5.1.</para>
            <para><citetitle>Internal functions</citetitle>: New section
            <citetitle><database>UUID_TO_CHAR()</database></citetitle>.</para>
            <para><citetitle>External functions :: <function>addWeek</function></citetitle>: Added
            <quote>Better alternative</quote>. Removed <quote>The <database>DATEADD</database>
            alternative</quote> formalpara.</para>
            <para><citetitle>External functions :: <function>lower</function></citetitle>: Dropped
            last sentence from Description. Altered first paragraph after Declaration block and
            removed comment.</para>
            <para><citetitle>External functions :: <function>round</function>,
            <function>i64round</function></citetitle>: Removed bug alert (fixed before 2.5).</para>
            <para><citetitle>External functions :: <function>truncate</function>,
            <function>i64truncate</function></citetitle>: Removed bug alert (fixed before
            2.5).</para>
            <para><citetitle>Notes</citetitle>: New section <citetitle>The
            <database>RDB$VALID_BLR</database> field</citetitle>. This note contains the (heavily
            edited and extended!) text previously contained in the Warnings in
            <citetitle><database>ALTER DOMAIN</database></citetitle>, <citetitle><database>CREATE
            PROCEDURE</database> :: Domains supported in parameter and variable
            declarations</citetitle> and <citetitle><database>DECLARE</database> ::
            <database>DECLARE</database> with <database>DOMAIN</database> instead of
            datatype</citetitle>.</para>
            <para>New appendix: <citetitle>Reserved words and keywords – full
            lists</citetitle>.</para>
            <para><citetitle>Document history</citetitle>: Link to CVS changed, points directly to
            manual module now.</para>
            <para><citetitle>License Notice</citetitle>: Copyright end year 2011.</para>
            <para>First publication, based on the <citetitle>Firebird 2.1 Language Reference
            Update</citetitle> with the above changes for 2.5 added (adding 25–30% to the
            size).</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.1</revnumber>
          <date>8 Oct 2011</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para><sgmltag class="element">articleinfo</sgmltag> and <citetitle>Introduction ::
            Versions covered</citetitle>: Added 2.5.1 to covered versions.</para>
            <para><citetitle>New in Firebird 2.5</citetitle>: Edited first para (mentioned
            2.5.1).</para>
            <para><citetitle>New in Firebird 2.5</citetitle>: Started all 10 subsections with
            <quote>Changed since Firebird 2.1</quote>, for clarity.</para>
            <para><citetitle>New in Firebird 2.5 :: Reserved words and keywords</citetitle>: Added
            <database>SQLSTATE</database> to <quote>Newly reserved words</quote>. Changed <quote>New
            keywords</quote> to <quote>New non-reserved keywords</quote>.</para>
            <para><citetitle>New in Firebird 2.5 :: Context variables</citetitle>: New
            subsection.</para>
            <para><citetitle>Reserved words and keywords :: Added since InterBase 6 :: Newly
            reserved words</citetitle>: Added <database>SQLSTATE</database>.</para>
            <para><citetitle>Reserved words and keywords :: Added since InterBase 6 :: New
            keywords</citetitle>: Renamed this section to <citetitle>New non-reserved
            keywords</citetitle>.</para>
            <para><citetitle>Miscellaneous language elements :: Shorthand casts</citetitle>: Renamed
            <citetitle>Shorthand datetime casts</citetitle>.</para>
            <para><citetitle>Miscellaneous language elements :: Shorthand datetime
            casts</citetitle>: Added Note warning that value stays the same as long as the statement
            remains prepared.</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>CREATE
            PROCEDURE</database></citetitle>: Shortened
            <replaceable>relname</replaceable>.<replaceable>colname</replaceable> to
            <replaceable>rel</replaceable>.<replaceable>col</replaceable> in Syntax, to keep line
            length within bounds for PDF.</para>
            <para><citetitle>DDL statements :: <database>PROCEDURE</database> :: <database>CREATE
            PROCEDURE</database> :: <citetitle><database>TYPE OF COLUMN</database> in parameter and
            variable declarations</citetitle></citetitle>: Moved title <quote>Warnings</quote> from
            itemizedlist to parent warning, where it belongs.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> :: <database>ORDER
            BY</database> :: Order by colum alias</citetitle>: Corrected section title:
            <citetitle>Order by column alias</citetitle>.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database> ::
            <database>ON EXTERNAL</database> [<database>DATA SOURCE</database>] :: Exception
            handling</citetitle>: <errorname>isc_eds_connection</errorname>,
            <errorname>isc_eds_statement</errorname> -&gt; <errorname>eds_connection</errorname>,
            <errorname>eds_statement</errorname>.</para>
            <para><citetitle>Context variables :: <varname>CURRENT_TIME</varname></citetitle>:
            Edited second Note to warn against shorthand syntax.</para>
            <para><citetitle>Context variables :: <varname>CURRENT_TIMESTAMP</varname></citetitle>:
            Edited second Note to warn against shorthand syntax.</para>
            <para><citetitle>Context variables :: <varname>GDSCODE</varname></citetitle>: Rewrote
            Description in light of new, so far undocumented behaviour since Firebird 2.0 (!).
            Corrected Example: after <database>WHEN GDSCODE</database> a symbolic name must follow,
            not a number. Added notice after Example to explain same.</para>
            <para><citetitle>Context variables :: <literal>'NOW'</literal></citetitle>: Edited the
            two existing Notes and inserted one about the freeze effect of the shorthand syntax. In
            the last Note, removed the link elements from around <varname>CURRENT_TIME</varname> and
            <varname>CURRENT_TIMESTAMP</varname>.</para>
            <para><citetitle>Context variables :: <varname>SQLCODE</varname></citetitle>: Added
            <quote>Changed in</quote> and <quote>Deprecated in</quote> formalparas. Rewrote
            Description in light of new, so far undocumented behaviour since Firebird 2.0 (!). Added
            Notice at the end (also about the deprecation).</para>
            <para><citetitle>Context variables :: <varname>SQLSTATE</varname></citetitle>: New
            section (variable implemented in 2.5.1).</para>
            <para><citetitle>Internal functions :: <database>CAST()</database></citetitle>: Added
            notice that when using the shorthand syntax, the value stays the same as long as the
            statement remains prepared.</para>
            <para><citetitle>Reserved words and keywords – full lists</citetitle>: Added
            <database>SQLSTATE</database> to both Reserved words and Keywords.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>
  <appendix id="langrefupd25-license">
    <title>License notice</title>
    <para>The contents of this Documentation are subject to the Public Documentation License Version
    1.0 (the <quote>License</quote>); you may only use this Documentation if you comply with the
    terms of this License. Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>
    <para>The Original Documentation is titled <citetitle>Firebird 2.5 Language Reference
    Update</citetitle>.</para>
    <para>The Initial Writers of the Original Documentation are: Paul Vinkenoog et al.</para>
    <para>Copyright (C) 2008-2011. All Rights Reserved. Initial Writers contact: paul at vinkenoog
    dot nl.</para>
    <para>Writers and Editors of included PDL-licensed material (the <quote>al.</quote>) are: J.
    Beesley, Helen Borrie, Arno Brinkman, Frank Ingermann, Vlad Khorsun, Alex Peshkov, Nickolay
    Samofatov, Adriano dos Santos Fernandes, Dmitry Yemanov.</para>
    <para>Included portions are Copyright (C) 2001-2010 by their respective authors. All Rights
    Reserved.</para>
  </appendix>
</book>
