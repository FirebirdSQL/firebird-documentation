<?xml version="1.0" encoding="UTF-8"?>
<!--
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-->
<book id="langrefupd20">
  <bookinfo>
    <title>Firebird 2.0 Language Reference Update</title>
    <subtitle>Everything new in Firebird SQL since InterBase 6</subtitle>
    <titleabbrev>Firebird 2.0 Language Ref. Update</titleabbrev>
    <author>
      <firstname>Paul</firstname>
      <surname>Vinkenoog et al.</surname>
    </author>
    <edition>?? ?????????? 2011, document version 1.1 — covers Firebird 2.0–2.0.6</edition>
  </bookinfo>
  <chapter id="langrefupd20-intro">
    <title>Introduction</title>
    <para>This guide documents the <emphasis role="bold">changes</emphasis> made in the Firebird SQL
    language between InterBase 6 and Firebird 2.0.<replaceable>x</replaceable>. It covers the
    following areas:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>Reserved words</para>
      </listitem>
      <listitem>
        <para>Data types and subtypes</para>
      </listitem>
      <listitem>
        <para>DDL statements (Data Definition Language)</para>
      </listitem>
      <listitem>
        <para>DML statements (Data Manipulation Language)</para>
      </listitem>
      <listitem>
        <para>Transaction control statements</para>
      </listitem>
      <listitem>
        <para>PSQL statements (Procedural SQL, used in stored procedures and triggers)</para>
      </listitem>
      <listitem>
        <para>Context variables</para>
      </listitem>
      <listitem>
        <para>Operators and predicates</para>
      </listitem>
      <listitem>
        <para>Internal functions</para>
      </listitem>
      <listitem>
        <para>UDFs (User Defined Functions, also known as external functions)</para>
      </listitem>
    </itemizedlist>
    <para>To have a complete Firebird 2.0 SQL reference, you need:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>The InterBase 6.0 beta SQL Reference (<filename>LangRef.pdf</filename> and/or
        <filename>SQLRef.html</filename>)</para>
      </listitem>
      <listitem>
        <para>This document</para>
      </listitem>
    </itemizedlist>
    <para>Topics <emphasis role="bold">not</emphasis> discussed in this document include:</para>
    <itemizedlist spacing="compact">
      <listitem>
        <para>ODS versions</para>
      </listitem>
      <listitem>
        <para>Bug listings</para>
      </listitem>
      <listitem>
        <para>Installation and configuration</para>
      </listitem>
      <listitem>
        <para>Upgrade, migration and compatibility</para>
      </listitem>
      <listitem>
        <para>Server architectures</para>
      </listitem>
      <listitem>
        <para>API functions</para>
      </listitem>
      <listitem>
        <para>Connection protocols</para>
      </listitem>
      <listitem>
        <para>Tools and utilities</para>
      </listitem>
    </itemizedlist>
    <para>Consult the Release Notes for information on these subjects. You can find the Release
    Notes and other documentation via the Firebird Documentation Index at <ulink
    url="http://www.firebirdsql.org/en/documentation/">http://www.firebirdsql.org/en/documentation/</ulink>.</para>
    <section id="langrefupd20-intro-versions">
      <title>Versions covered</title>
      <para>This document covers all Firebird versions up to and including 2.0.6.</para>
    </section>
    <section id="langrefupd20-intro-authors">
      <title>Authorship</title>
      <para>Most of this document was written by the main author. The remainder (5–7%) was lifted
      from various Firebird Release Notes editions, which in turn contain material from preceding
      sources like the Whatsnew documents. Authors and editors of the included material are:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>J. Beesley</para>
        </listitem>
        <listitem>
          <para>Helen Borrie</para>
        </listitem>
        <listitem>
          <para>Arno Brinkman</para>
        </listitem>
        <listitem>
          <para>Frank Ingermann</para>
        </listitem>
        <listitem>
          <para>Alex Peshkov</para>
        </listitem>
        <listitem>
          <para>Nickolay Samofatov</para>
        </listitem>
        <listitem>
          <para>Dmitry Yemanov</para>
        </listitem>
      </itemizedlist>
      <!--You don't get on this list unless your last name starts with 'B' or ends with 'ov'! :-)-->
    </section>
  </chapter>
  <chapter id="langrefupd20-reskeywords">
    <title>Reserved words and keywords</title>
    <para>Reserved words are part of the Firebird SQL language. They cannot be used as identifiers
    (e.g. table or procedure names), except when enclosed in double quotes in Dialect 3. However,
    you should avoid this unless you have a compelling reason.</para>
    <para>Keywords are also part of the language. They have a special meaning when used in the
    proper context, but they are not reserved for Firebird's own and exclusive use. You can use them
    as identifiers without double-quoting.</para>
    <section id="langrefupd20-reskeywords-added">
      <title>Added since InterBase 6</title>
      <section id="langrefupd20-reswords-added">
        <title>Newly reserved words</title>
        <para>The following reserved words have been added to Firebird:</para>
        <blockquote>
          <simplelist>
            <member><database>BIGINT</database></member>
            <member><database>BIT_LENGTH</database></member>
            <member><database>BOTH</database></member>
            <member><database>CASE</database></member>
            <member><database>CHAR_LENGTH</database></member>
            <member><database>CHARACTER_LENGTH</database></member>
            <member><database>CLOSE</database></member>
            <member><database>CROSS</database></member>
            <member><database>CURRENT_CONNECTION</database></member>
            <member><database>CURRENT_ROLE</database></member>
            <member><database>CURRENT_TRANSACTION</database></member>
            <member><database>CURRENT_USER</database></member>
            <member><database>FETCH</database></member>
            <member><database>LEADING</database></member>
            <member><database>LOWER</database></member>
            <member><database>OCTET_LENGTH</database></member>
            <member><database>OPEN</database></member>
            <member><database>RECREATE</database></member>
            <member><database>RELEASE</database></member>
            <member><database>ROW_COUNT</database></member>
            <member><database>ROWS</database></member>
            <member><database>SAVEPOINT</database></member>
            <member><database>TRAILING</database></member>
            <member><database>TRIM</database></member>
            <member><database>USING</database></member>
          </simplelist>
        </blockquote>
      </section>
      <section id="langrefupd20-keywords-added">
        <title>New keywords</title>
        <para>The following words have been added to Firebird as non-reserved keywords:</para>
        <blockquote>
          <simplelist>
            <member><database>BACKUP</database></member>
            <member><database>BLOCK</database></member>
            <member><database>COALESCE</database></member>
            <member><database>COLLATION</database></member>
            <member><database>COMMENT</database></member>
            <member><database>DELETING</database></member>
            <member><database>DIFFERENCE</database></member>
            <member><database>IIF</database></member>
            <member><database>INSERTING</database></member>
            <member><database>LAST</database></member>
            <member><database>LEAVE</database></member>
            <member><database>LOCK</database></member>
            <member><database>NEXT</database></member>
            <member><database>NULLIF</database></member>
            <member><database>NULLS</database></member>
            <member><database>RESTART</database></member>
            <member><database>RETURNING</database></member>
            <member><database>SCALAR_ARRAY</database></member>
            <member><database>SEQUENCE</database></member>
            <member><database>STATEMENT</database></member>
            <member><database>UPDATING</database></member>
          </simplelist>
        </blockquote>
      </section>
    </section>
    <section id="langrefupd20-reskeywords-dropped">
      <title>Dropped since InterBase 6</title>
      <section id="langrefupd20-reswords-dropped">
        <title>No longer reserved</title>
        <para>The following words are no longer reserved in Firebird 2.0, but are still recognized
        as keywords:</para>
        <blockquote>
          <simplelist>
            <member><database>ACTION</database></member>
            <member><database>CASCADE</database></member>
            <member><database>FREE_IT</database></member>
            <member><database>RESTRICT</database></member>
            <member><database>ROLE</database></member>
            <member><database>TYPE</database></member>
            <member><database>WEEKDAY</database></member>
            <member><database>YEARDAY</database></member>
          </simplelist>
        </blockquote>
      </section>
      <section id="langrefupd20-keywords-dropped">
        <title>No longer keywords</title>
        <para>The following are no longer keywords in Firebird 2.0:</para>
        <blockquote>
          <simplelist>
            <member><database>BASENAME</database></member>
            <member><database>CACHE</database></member>
            <member><database>CHECK_POINT_LEN</database></member>
            <member><database>GROUP_COMMIT_WAIT</database></member>
            <member><database>LOG_BUF_SIZE</database></member>
            <member><database>LOGFILE</database></member>
            <member><database>NUM_LOG_BUFS</database></member>
            <member><database>RAW_PARTITIONS</database></member>
          </simplelist>
        </blockquote>
      </section>
    </section>
    <section id="langrefupd20-reswords-future">
      <title>Possibly reserved in future versions</title>
      <para>The following words are not reserved in Firebird 2.0, but should be avoided as
      identifiers because they will likely be reserved in future versions:</para>
      <blockquote>
        <simplelist>
          <member><database>ABS</database></member>
          <member><database>BOOLEAN</database></member>
          <member><database>FALSE</database></member>
          <member><database>TRUE</database></member>
          <member><database>UNKNOWN</database></member>
        </simplelist>
      </blockquote>
    </section>
  </chapter>
  <chapter id="langrefupd20-misc">
    <title>Miscellaneous language elements</title>
    <section id="langrefupd20-linecomment">
      <title>-- (single-line comment)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A line starting with <quote><literal>--</literal></quote> (two dashes) is a comment
        and will be ignored. This also makes it easy to quickly comment out a line of SQL.</para>
      </formalpara>
      <para>In Firebird 1.5 and up, the <quote><literal>--</literal></quote> can be placed anywhere
      on the line, e.g. after an SQL statement. Everything from the double dash to the end of the
      line will be ignored.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>-- a table to store our valued customers in:
create table Customers (
  name varchar(32),
  added_by varchar(24),
  custno varchar(8),
  purchases integer      -- number of purchases
)</programlisting>
            <para>Notice that the second comment is only allowed in Firebird 1.5 and up.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-shorthandcast">
      <title>Shorthand casts</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Sure about shorthand casts in ESQL?-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>When converting a string literal to a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database>, Firebird allows the use of a
        shorthand <quote>C-style</quote> cast. This feature already existed in InterBase 6, but was
        never properly documented.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting><replaceable>datatype</replaceable> '<replaceable>date/timestring</replaceable>'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; <emphasis role="bold">date '1-Jan-1943'</emphasis></programlisting>
            <programlisting>insert into Appointments
  (Employee_Id, Client_Id, App_date, App_time)
values
  (973, 8804, <emphasis role="bold">date 'today'</emphasis> + 2, <emphasis role="bold">time '16:00'</emphasis>)</programlisting>
            <programlisting>new.lastmod = <emphasis role="bold">timestamp 'now'</emphasis>;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-cast"><database>CAST</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-case">
      <title><database>CASE</database> construct</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--KW_CASE is defined in ESQL to recognize Pascal case constructs. No support for SQL CASE found.-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>A <database>CASE</database> construct returns exactly one value from a number of
        possibilities. There are two syntactic variants:<itemizedlist spacing="compact">
            <listitem>
              <para>The simple <database>CASE</database>, comparable to a Pascal <code>case</code>
              or a C <code>switch</code>.</para>
            </listitem>
            <listitem>
              <para>The searched <database>CASE</database>, which works like a series of
              <quote><code>if ... else if ... else if</code></quote> clauses.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <section id="langrefupd20-case-simple">
        <title>Simple <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE <replaceable>&lt;expression&gt;</replaceable>
   WHEN <replaceable>&lt;exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>When this variant is used, <replaceable>&lt;expression&gt;</replaceable> is compared
        to <replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> etc.,
        until a match is found, upon which the corresponding result is returned. If there is no
        match and there is an <database>ELSE</database> clause,
        <replaceable>defaultresult</replaceable> is returned. If there is no match and no
        <database>ELSE</database> clause, <constant>NULL</constant> is returned.</para>
        <para>The match is determined with the <quote>=</quote> operator, so if
        <replaceable>&lt;expression&gt;</replaceable> is <constant>NULL</constant>, it won't match
        any of the <replaceable>&lt;expN&gt;</replaceable>s, not even those that are
        <constant>NULL</constant>.</para>
        <para>The results don't have to be literal values: they may also be field or variable names,
        compound expressions, or <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select name,
       age,
       case upper(sex)
         when 'M' then 'Male'
         when 'F' then 'Female'
         else 'Unknown'
       end,
       religion
from people</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-case-searched">
        <title>Searched <database>CASE</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>CASE
   WHEN <replaceable>&lt;bool_exp1&gt;</replaceable> THEN <replaceable>result1</replaceable>
   WHEN <replaceable>&lt;bool_exp2&gt;</replaceable> THEN <replaceable>result2</replaceable>
   ...
   [ELSE <replaceable>defaultresult</replaceable>]
END</programlisting>
            </blockquote></para>
        </formalpara>
        <para>Here, the <replaceable>&lt;bool_expN&gt;</replaceable>s are tests that give a ternary
        boolean result: <constant>true</constant>, <constant>false</constant>, or
        <constant>NULL</constant>. The first expression evaluating to <constant>TRUE</constant>
        determines the result. If no expression is <constant>TRUE</constant> and there is an
        <database>ELSE</database> clause, <replaceable>defaultresult</replaceable> is returned. If
        no expression is <constant>TRUE</constant> and there is no <database>ELSE</database> clause,
        <constant>NULL</constant> is returned.</para>
        <para>As with the simple <database>CASE</database>, the results don't have to be literal
        values: they may also be field or variable names, compound expressions, or
        <constant>NULL</constant> literals.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>CanVote = case
            when Age &gt;= 18 then 'Yes'
            when Age &lt;  18 then 'No'
            else 'Unsure'
          end;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd20-datatypes">
    <title>Data types and subtypes</title>
    <section id="langrefupd20-bigint">
      <title><database>BIGINT</database> data type</title>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BIGINT</database> is the SQL99-compliant 64-bit signed integer type. It is
        available in Dialect 3 only.</para>
      </formalpara>
      <para><database>BIGINT</database> numbers range from -2<superscript>63</superscript> ..
      2<superscript>63</superscript>-1, or -9,223,372,036,854,775,808 ..
      9,223,372,036,854,775,807.</para>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create table WholeLottaRecords (
  id bigint not null primary key,
  description varchar(32)
)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-blob">
      <title><database>BLOB</database> data type</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Several enhancements have been implemented for text
        <database>BLOB</database>s:<itemizedlist>
            <listitem>
              <para>DML <database>COLLATE</database> clauses are now supported.</para>
            </listitem>
            <listitem>
              <para>Equality comparisons can be performed on the full <database>BLOB</database>
              contents.</para>
            </listitem>
            <listitem>
              <para>Character set conversions are possible when assigning a
              <database>BLOB</database> to a <database>BLOB</database> or a string to a
              <database>BLOB</database>.</para>
            </listitem>
          </itemizedlist>When defining binary <database>BLOB</database>s, the mnemonic
        <constant>binary</constant> can now be used instead of the integer 0.</para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
          </blockquote><blockquote>
            <programlisting>create table MyPictures (
  id int not null primary key,
  title varchar(40),
  description varchar(200),
  picture blob sub_type binary
)</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-charsets">
      <title>New character sets</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5, 2.0</para>
      </formalpara>
      <para>The following table lists the character sets added in Firebird.</para>
      <table id="langrefupd20-tbl-charsets">
        <title>Character sets new in Firebird</title>
        <tgroup cols="4">
          <colspec colname="colName" colwidth="2*" />
          <colspec colname="colBytes" colwidth="*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Name</entry>
              <entry align="center">Max bytes/ch.</entry>
              <entry align="center">Languages</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>DOS737</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS775</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS858</entry>
              <entry>1</entry>
              <entry>= DOS850 plus € sign</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS862</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS864</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS866</entry>
              <entry>1</entry>
              <entry>Russian</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>DOS869</entry>
              <entry>1</entry>
              <entry>Modern Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_2</entry>
              <entry>1</entry>
              <entry>Latin-2, Central European</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO8859_3</entry>
              <entry>1</entry>
              <entry>Latin-3, Southern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_4</entry>
              <entry>1</entry>
              <entry>Latin-4, Northern European</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_5</entry>
              <entry>1</entry>
              <entry>Cyrillic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_6</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_7</entry>
              <entry>1</entry>
              <entry>Greek</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_8</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_9</entry>
              <entry>1</entry>
              <entry>Latin-5, Turkish</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>1</entry>
              <entry>Latin-7, Baltic Rim</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>KOI8R</entry>
              <entry>1</entry>
              <entry>Russian</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>KOI8U</entry>
              <entry>1</entry>
              <entry>Ukrainian</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>UTF8 <footnote label="(*)">
                  <para>In Firebird 1.5, <database>UTF8</database> is an alias for
                  <database>UNICODE_FSS</database>. This character set has some inherent problems.
                  In Firebird 2, <database>UTF8</database> is a character set in its own right,
                  without the drawbacks of <database>UNICODE_FSS</database>.</para>
                </footnote></entry>
              <entry>4</entry>
              <entry>All</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1255</entry>
              <entry>1</entry>
              <entry>Hebrew</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1256</entry>
              <entry>1</entry>
              <entry>Arabic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1257</entry>
              <entry>1</entry>
              <entry>Baltic</entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1258</entry>
              <entry>1</entry>
              <entry>Vietnamese</entry>
              <entry>2.0</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd20-charset-none">
      <title>Character set <database>NONE</database> handling changed</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.1</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
        moved to and from fields or variables with another character set, resulting in fewer
        transliteration errors. For more details, see the <link
        linkend="langrefupd20-notes-charset-none">Note</link> at the end of the book.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-collations">
      <title>New collations</title>
      <formalpara>
        <title>Added in</title>
        <para>1.0, 1.5, 1.5.1, 2.0</para>
      </formalpara>
      <para>The following table lists the collations added in Firebird. The <quote>Details</quote>
      column is based on what has been reported in the Release Notes and other documents. The
      information in this column is probably incomplete; some collations with an empty Details field
      may still be case insensitive (ci), accent insensitive (ai) or dictionary-sorted (dic).</para>
      <table id="langrefupd20-tbl-collations">
        <title>Collations new in Firebird</title>
        <tgroup cols="5">
          <colspec colname="colCharset" colwidth="2*" />
          <colspec colname="colCollation" colwidth="2*" />
          <colspec colname="colLang" colwidth="2*" />
          <colspec colname="colDetails" colwidth="*" />
          <colspec colname="colAdded" colwidth="*" />
          <thead>
            <row>
              <entry align="center">Character set</entry>
              <entry align="center">Collation</entry>
              <entry align="center">Language</entry>
              <entry align="center">Details</entry>
              <entry align="center">Added in</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry morerows="1">ISO8859_1</entry>
              <entry>ES_ES_CI_AI</entry>
              <entry>Spanish</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>PT_BR</entry>
              <entry>Brazilian Portuguese</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row valign="top">
              <entry morerows="2">ISO8859_2</entry>
              <entry>CS_CZ</entry>
              <entry>Czech</entry>
              <entry></entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>ISO_HUN</entry>
              <entry>Hungarian</entry>
              <entry></entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>ISO_PLK</entry>
              <entry>Polish</entry>
              <entry></entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>ISO8859_13</entry>
              <entry>LT_LT</entry>
              <entry>Lithuanian</entry>
              <entry></entry>
              <entry>1.5.1</entry>
            </row>
            <row>
              <entry morerows="1">UTF8</entry>
              <entry>UCS_BASIC</entry>
              <entry>All</entry>
              <entry></entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>UNICODE</entry>
              <entry>All</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry morerows="3">WIN1250</entry>
              <entry>BS_BA</entry>
              <entry>Bosnian</entry>
              <entry></entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>PXW_HUN</entry>
              <entry>Hungarian</entry>
              <entry>ci</entry>
              <entry>1.0</entry>
            </row>
            <row>
              <entry>WIN_CZ</entry>
              <entry>Czech</entry>
              <entry>ci</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN_CZ_CI_AI</entry>
              <entry>Czech</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1251</entry>
              <entry>WIN1251_UA</entry>
              <entry>Ukrainian and Russian</entry>
              <entry></entry>
              <entry>1.5</entry>
            </row>
            <row>
              <entry>WIN1252</entry>
              <entry>WIN_PTBR</entry>
              <entry>Brazilian Portuguese</entry>
              <entry>ci, ai</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry morerows="2">WIN1257</entry>
              <entry>WIN1257_EE</entry>
              <entry>Estonian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1257_LT</entry>
              <entry>Lithuanian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>WIN1257_LV</entry>
              <entry>Latvian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>KOI8R</entry>
              <entry>KOI8R_RU</entry>
              <entry>Russian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
            <row>
              <entry>KOI8U</entry>
              <entry>KOI8U_UA</entry>
              <entry>Ukrainian</entry>
              <entry>dic</entry>
              <entry>2.0</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note>
        <title>A note on the UTF8 collations</title>
        <para>The <database>UCS_BASIC</database> collation sorts in Unicode code-point order: A, B,
        a, b, á... This is exactly the same as <database>UTF8</database> with no collation
        specified. <database>UCS_BASIC</database> was added to comply with the SQL standard.</para>
        <para>The <database>UNICODE</database> collation sorts using UCA (Unicode Collation
        Algorithm): a, A, á, b, B...</para>
      </note>
    </section>
  </chapter>
  <chapter id="langrefupd20-ddl">
    <title>DDL statements</title>
    <!--ALTER INDEX

Fb1 RlsNotes say:

Allow FK indexes to be disabled
It is now possible to set FOREIGN KEY indexes inactive using ALTER INDEX. This should resolve
some performance issues related to maintaining indexes with low selectivity.

In practice, this doesn't work and has never been implemented (confirmed by Dmitry).
It should have been removed from the Rlsnotes.-->
    <section id="langrefupd20-alter-db">
      <title><database>ALTER DATABASE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Alters a database's file organisation or toggles its <quote>safe-to-copy</quote>
        state.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ALTER {DATABASE | SCHEMA}
   [<replaceable>&lt;add_sec_clause&gt;</replaceable> [<replaceable>&lt;add_sec_clause&gt;</replaceable> ...]]
   [ADD DIFFERENCE FILE '<replaceable>filepath</replaceable>' | DROP DIFFERENCE FILE]
   [{BEGIN | END} BACKUP]

<replaceable>&lt;add_sec_clause&gt;</replaceable>  ::=  ADD <replaceable>&lt;sec_file&gt;</replaceable> [<replaceable>&lt;sec_file&gt;</replaceable> ...]

<replaceable>&lt;sec_file&gt;</replaceable>        ::=  FILE '<replaceable>filepath</replaceable>'
                          [STARTING [AT [PAGE]] <replaceable>pagenum</replaceable>]
                          [LENGTH [=] <replaceable>num</replaceable> [PAGE[S]]</programlisting>
            <!-- Claudio reports (in 2.5 rlsnotes) that if the delta file name is set via CREATE DATABASE, and subsequently
           dropped by ALTER DATABASE, the default mechanism doesn't kick it, i.e. ALTER DATABSE BEGIN BACKUP fails
           (and so does nbackup?)
           Find out more and document. Has this been reported as a bug? Has it been fixed, or will it be? -->
            <para>The <database>DIFFERENCE FILE</database> and <database>BACKUP</database> clauses,
            added in Firebird 2.0, are not available in ESQL.</para>
          </blockquote></para>
      </formalpara>
      <!--Strange: in gpre/sql.cpp, under ALTER DATABASE, there is support for things not found in the
docs, like DROP LOG/CASCADE/CACHE, ADD FILE, ADD LOGFILE, an OVERFLOW keyword, BASE_NAME...
And a number of SET clauses:
  CHECK_POINT_LENGTH, NUM_LOG_BUFFERS, LOG_BUFFER_SIZE, GROUP_COMMIT_WAIT_TIME-->
      <section id="langrefupd20-alter-db-begin-backup">
        <title><database>BEGIN BACKUP</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Freezes the main database file so that it can be backed up safely by filesystem
          means, even while users are connected and perform operations on the data. Any mutations to
          the database will be written to a separate file, the <firstterm>delta file</firstterm>.
          Contrary to what the syntax suggests, this statement does <emphasis>not</emphasis>
          initiate the backup itself; it merely creates the conditions.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter database begin backup</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-db-end-backup">
        <title><database>END BACKUP</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Merges the delta file back into the main database file and restores the normal state
          of operation, thus closing the time window during which safe backups could be made via the
          filesystem. (Safe backups with <application>gbak</application> are still possible.)</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter database end backup</programlisting>
            </blockquote></para>
        </formalpara>
        <tip>
          <para>Instead of <database>BEGIN</database> and <database>END BACKUP</database>, consider
          using Firebird's <application>nbackup</application> tool: it can freeze and unfreeze the
          main database file as well as make full and incremental backups. A manual for nbackup is
          available via the <ulink url="http://www.firebirdsql.org/en/documentation/">Firebird
          Documentation Index</ulink>.</para>
        </tip>
      </section>
      <section id="langrefupd20-alter-db-add-diff">
        <title><database>ADD DIFFERENCE FILE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Presets path and name of the delta file to which mutations are written when the
          database goes into <quote>copy-safe</quote> mode after an <database>ALTER DATABASE BEGIN
          BACKUP</database> command.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter database add difference file 'C:\Firebird\Databases\Fruitbase.delta'</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>This statement doesn't really add any file. It just overrides the default path
                and name for the delta file that's going to be created if and when the database
                enters copy-safe mode.</para>
              </listitem>
              <listitem>
                <para>If you provide a relative path here (or a bare filename), it will be appended
                to the current directory as seen from the server. On Windows, this is often the
                system directory.</para>
              </listitem>
              <listitem>
                <para>If you want to change an existing path and name, <link
                linkend="langrefupd20-alter-db-drop-diff"><database>DROP</database></link> the old
                one first and then <database>ADD</database> the new one.</para>
              </listitem>
              <listitem>
                <para>When not overridden, the delta file gets the same path and filename as the
                database itself, but with the extension <filename
                class="extension">.delta</filename></para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-db-drop-diff">
        <title><database>DROP DIFFERENCE FILE</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Removes the delta file path and name that were previously set with <database>ALTER
          DATABASE ADD DIFFERENCE FILE</database>. This statement doesn't really drop a file. It
          only erases the name and path that would otherwise have been used the next time around and
          reverts to the default behaviour.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter database drop difference file</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-alter-domain">
      <title><database>ALTER DOMAIN</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <!--(for when we construct the formal syntax:)
In IB6 and Fb (tested 2.0) you cannot provide a default after ALTER DOMAIN ... TYPE-->
      <section id="langrefupd20-alter-domain-to">
        <title>Rename domain</title>
        <formalpara>
          <title>Added in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Renaming of a domain is possible with the <database>TO</database> clause. This
          feature was introduced in InterBase 6, but left out of the <citetitle>Language
          Reference</citetitle>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter domain posint to plusint</programlisting>
              <itemizedlist>
                <listitem>
                  <para>The <database>TO</database> clause can be combined with other clauses and
                  need not come first in that case.</para>
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-domain-default">
        <title><database>SET DEFAULT</database> to any context variable</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the domain's datatype can be
          used as a default. This was already the case in InterBase 6, but the <citetitle>Language
          Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter domain DDate
  set default current_date</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-alter-ext-func">
      <title><database>ALTER EXTERNAL FUNCTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Alters an external function's module name and/or entry point. Existing dependencies
        are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ALTER EXTERNAL FUNCTION <replaceable>funcname</replaceable>
   <replaceable>&lt;modification&gt;</replaceable> [<replaceable>&lt;modification&gt;</replaceable>]

<replaceable>&lt;modification&gt;</replaceable>  ::=  ENTRY_POINT '<replaceable>new-entry-point</replaceable>'
                     | MODULE_NAME '<replaceable>new-module-name</replaceable>'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>alter external function Phi module_name 'NewUdfLib'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-alter-proc">
      <title><database>ALTER PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-alter-proc-argdefaults">
        <title>Default argument values</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>You can now provide default values for stored procedure arguments, allowing the
          caller to omit one or more items from the end of the argument list.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER PROCEDURE <replaceable>procname</replaceable> (<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])
   ...

<replaceable>&lt;inparam&gt;</replaceable>  ::=  <replaceable>paramname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>]</programlisting>
              <para><emphasis role="bold">Important:</emphasis> If you give a parameter a default
              value, all parameters coming after it must also get default values.</para>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter procedure TestProc
  (a int, b int default 1007, s varchar(12) = '-')
  ...</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-proc-restr">
        <title>Restriction on altering used procedures</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.0.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from dropping,
          altering or recreating a trigger or stored procedure if it has been used since the
          database was opened. This restriction has been removed again in version 2.0.1. Still,
          performing these operations on a live database is potentially risky and should only be
          done with the utmost care.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-alter-seq">
      <title><database>ALTER SEQUENCE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>(Re)initializes a sequence or generator to the given value.
        <database>SEQUENCE</database> is the SQL-compliant term for what InterBase and Firebird have
        always called a generator. <quote><database>ALTER SEQUENCE ... RESTART
        WITH</database></quote> is fully equivalent to <quote><database>SET GENERATOR ...
        TO</database></quote> and is the recommended syntax from Firebird 2.0 onward.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ALTER SEQUENCE <replaceable>sequence-name</replaceable> RESTART WITH <replaceable>&lt;newval&gt;</replaceable>

<replaceable>&lt;newval&gt;</replaceable>  ::=  A signed 64-bit integer value.</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>alter sequence seqtest restart with 0</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>Careless use of <database>ALTER SEQUENCE</database> is a mighty fine way of screwing
        up your database! Under normal circumstances you should only use it right after
        <database>CREATE SEQUENCE</database>, to set the initial value.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-create-seq"><database>CREATE
        SEQUENCE</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-alter-table">
      <title><database>ALTER TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <!--(for when we construct the formal syntax:)
- In IB6 and Fb (tested 2.0) you cannot provide a default after ALTER [COLUMN] ... TYPE
- ALTER COLUMN ADD/DROP/ DEFAULT are not supported in ESQL-->
      <section id="langrefupd20-at-contextvars">
        <title><database>ADD</database> column: Context variables as defaults</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the new column's datatype can
          be used as a default. This was already the case in InterBase 6, but the
          <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table MyData
  add MyDay date default current_date</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-at-ac-dropdefault">
        <title><database>ALTER COLUMN</database>: <database>DROP DEFAULT</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2 adds the possibility to drop a column-level default. Once the default is
          dropped, there will either be no default in place or – if the column's type is a
          <database>DOMAIN</database> with a default – the domain default will resurface.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> DROP DEFAULT</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table Trees alter Girth drop default</programlisting>
            </blockquote></para>
        </formalpara>
        <para>An error is raised if you use <database>DROP DEFAULT</database> on a column that
        doesn't have a default or whose effective default is domain-based.</para>
      </section>
      <section id="langrefupd20-at-ac-setdefault">
        <title><database>ALTER COLUMN</database>: <database>SET DEFAULT</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird 2 adds the possibility to set/alter defaults on existing columns. If the
          column already had a default, the new default will replace it. Column-level defaults
          always override domain-level defaults.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> SET DEFAULT <replaceable>&lt;default&gt;</replaceable>

<replaceable>&lt;default&gt;</replaceable>  ::=  <replaceable>literal-value</replaceable> | <replaceable>context-variable</replaceable> | NULL</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table Customers alter EnteredBy set default current_user</programlisting>
            </blockquote></para>
        </formalpara>
        <tip>
          <para>If you want to switch off a domain-based default on a column, set the column default
          to <constant>NULL</constant>.</para>
        </tip>
      </section>
      <section id="langrefupd20-at-position">
        <title><database>ALTER COLUMN</database>: <database>POSITION</database> now 1-based</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>When changing a column's position, the engine now interprets the new position as
          1-based. This is in accordance with the SQL standard and the InterBase documentation, but
          in practice InterBase interpreted the position as 0-based.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ALTER TABLE <replaceable>tablename</replaceable> ALTER [COLUMN] <replaceable>colname</replaceable> POSITION <replaceable>&lt;newpos&gt;</replaceable>

<replaceable>&lt;newpos&gt;</replaceable>  ::=  an integer between 1 and the number of columns</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>alter table Stock alter Quantity position 3</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>Don't confuse this with the <database>POSITION</database> in <database>CREATE/ALTER
          TRIGGER</database>. Trigger positions are and will remain 0-based.</para>
        </note>
      </section>
      <section id="langrefupd20-at-check">
        <title><database>CHECK</database> accepts <constant>NULL</constant> outcome</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If a <database>CHECK</database> constraint resolves to <constant>NULL</constant>,
          Firebird versions before 2.0 reject the input. Following the SQL standard to the letter,
          Firebird 2.0 and above let <constant>NULL</constant>s pass and only consider the check
          failed if the outcome is <constant>false</constant>. For more information see under <link
          linkend="langrefupd20-ct-check"><database>CREATE TABLE</database></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-at-fk-notargetcol">
        <title><database>FOREIGN KEY</database> without target column references
        <database>PK</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you create a foreign key without specifying a target column, it will reference
          the <emphasis role="bold">primary key</emphasis> of the target table. This was already the
          case in InterBase 6, but the IB Language Reference wrongly states that in such cases, the
          engine scans the target table for a column with the same name as the referencing
          column.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table eik (
  a int not null primary key,
  b int not null unique
);

create table beuk (
  b int
);

alter table beuk
  add constraint fk_beuk
  foreign key (b) references eik;

-- beuk.b now references eik.a, not eik.b !</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-at-fk-noexclusive">
        <title><database>FOREIGN KEY</database> creation no longer requires exclusive access</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 and above, adding a foreign key constraint no longer requires
          exclusive access to the database.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-at-unique-keys">
        <title><database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple –
          are now allowed in columns with a <database>UNIQUE</database> constraint. For a full
          discussion, see <link linkend="langrefupd20-ct-unique-keys"><citetitle><database>CREATE
          TABLE</database> :: <database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-at-using-index">
        <title><database>USING INDEX</database> subclause</title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no support found in source-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>USING INDEX</database> subclause can be placed at the end of a primary,
          unique or foreign key definition. Its purpose is to<itemizedlist spacing="compact">
              <listitem>
                <para>provide a user-defined name for the automatically created index that enforces
                the constraint, and</para>
              </listitem>
              <listitem>
                <para>optionally define the index to be ascending or descending (the default being
                ascending).</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>[ADD] [CONSTRAINT <replaceable>constraint-name</replaceable>]
<replaceable>   &lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>For a full discussion and examples, see <link
        linkend="langrefupd20-ct-using-index"><citetitle><database>CREATE TABLE</database> ::
        <database>USING INDEX</database> subclause</citetitle></link>.</para>
      </section>
    </section>
    <section id="langrefupd20-alter-trigger">
      <title><database>ALTER TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Alters an existing trigger. The table or view that the trigger belongs to cannot be
        changed.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ALTER TRIGGER <replaceable>name</replaceable>
   [ACTIVE | INACTIVE]
   [{BEFORE | AFTER} <replaceable>&lt;action_list&gt;</replaceable>]
   [POSITION <replaceable>number</replaceable>]
   [AS <replaceable>&lt;trigger_body&gt;</replaceable>]

<replaceable>&lt;action_list&gt;</replaceable>   ::=  <replaceable>&lt;action&gt;</replaceable> [OR <replaceable>&lt;action&gt;</replaceable> [OR <replaceable>&lt;action&gt;</replaceable>]]
<replaceable>&lt;action&gt;</replaceable>        ::=  INSERT | UPDATE | DELETE</programlisting>
            <!--Fill in <trigger_body> !-->
            <!--Notice that ALTER TRIGGER can be called with just the name. This is a valid statement and
it can be committed as well. Of course, nothing changes.-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-alter-trigger-multiaction">
        <title>Multi-action triggers</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ALTER TRIGGER</database> syntax (see above) has been extended to
          support multi-action triggers. For a full discussion of this feature, see <link
          linkend="langrefupd20-create-trigger-multiaction"><citetitle><database>CREATE
          TRIGGER</database> :: Multi-action triggers</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-trigger-restr">
        <title>Restriction on altering used triggers</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.0.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from dropping,
          altering or recreating a trigger or stored procedure if it has been used since the
          database was opened. This restriction has been removed again in version 2.0.1. Still,
          performing these operations on a live database is potentially risky and should only be
          done with the utmost care.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-trigger-plan">
        <title><database>PLAN</database> allowed in trigger code</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
          would be rejected by the compiler. Now a valid plan can be included and will be
          used.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-alter-trigger-changecount">
        <title><database>ALTER TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Each time you use <database>CREATE</database>, <database>ALTER</database> or
          <database>DROP TRIGGER</database>, InterBase increments the metadata change counter of the
          associated table. Once that counter reaches 255, no more metadata changes are possible on
          the table (you can still work with the data though). A backup-restore cycle is needed to
          reset the counter and perform metadata operations again.</para>
        </formalpara>
        <para>While this obligatory cleanup after many metadata changes is in itself a useful
        feature, it also means that users who regularly use <database>ALTER TRIGGER</database> to
        deactivate triggers during e.g. bulk import operations are forced to backup and restore much
        more often then needed.</para>
        <para>Since changes to triggers don't imply structural changes to the table itself, Firebird
        no longer increments the table change counter when <database>CREATE</database>,
        <database>ALTER</database> or <database>DROP TRIGGER</database> is used. One thing has
        remained though: once the counter is at 255, you can no longer create, alter or drop
        triggers for that table.</para>
      </section>
    </section>
    <section id="langrefupd20-comment">
      <title><database>COMMENT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Allows you to enter comments for metadata objects. The comments will be stored in the
        various <database>RDB$DESCRIPTION</database> text <database>BLOB</database> fields in the
        system tables, from where client applications can pick them up.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COMMENT ON <replaceable>&lt;object&gt;</replaceable> IS {'<replaceable>sometext</replaceable>' | NULL}

<replaceable>&lt;object&gt;</replaceable>      ::=  DATABASE
                   | <replaceable>&lt;basic-type&gt;</replaceable> <replaceable>objectname</replaceable>
                   | COLUMN <replaceable>relationname</replaceable>.<replaceable>fieldname</replaceable>
                   | PARAMETER <replaceable>procname</replaceable>.<replaceable>paramname</replaceable>

<replaceable>&lt;basic-type&gt;</replaceable>  ::=  CHARACTER SET | COLLATION | DOMAIN | EXCEPTION
                   | EXTERNAL FUNCTION | FILTER | GENERATOR | INDEX
                   | PROCEDURE | ROLE | SEQUENCE | TABLE | TRIGGER | VIEW</programlisting>
            <note>
              <para>If you enter an empty comment (<literal>''</literal>), it will end up as
              <constant>NULL</constant> in the database.</para>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>comment on database is 'Here''s where we keep all our customer records.'</programlisting>
            <programlisting>comment on table Metals is 'Also for alloys'</programlisting>
            <programlisting>comment on column Metals.IsAlloy is '0 = pure metal, 1 = alloy'</programlisting>
            <programlisting>comment on index ix_sales is 'Set inactive during bulk inserts!'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-create-database">
      <title><database>CREATE DATABASE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax (partial)</title>
        <para><blockquote>
            <programlisting>CREATE {DATABASE | SCHEMA}
   ...
   [PAGE_SIZE [=] <replaceable>&lt;size&gt;</replaceable>]
   ...
   [DIFFERENCE FILE '<replaceable>filepath</replaceable>']

<replaceable>&lt;size&gt;</replaceable>  ::=  1024 | 2048 | 4096 | 8192 | 16384</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-cr-db-pagesize16k">
        <title>16 Kb page size supported</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum database page size has been raised from 8192 to 16384 bytes.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-cr-db-difffile">
        <title><database>DIFFERENCE FILE</database> parameter</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>For a full description of this parameter, see <link
          linkend="langrefupd20-alter-db-add-diff"><citetitle><database>ALTER DATABASE</database> ::
          <database>ADD DIFFERENCE FILE</database></citetitle></link>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-create-domain">
      <title><database>CREATE DOMAIN</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-create-domain-contextvars">
        <title>Context variables as defaults</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the new domain's datatype can
          be used as a default. This was already the case in InterBase 6, but the
          <citetitle>Language Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create domain DDate as
  date
  default current_date
  not null</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-create-exception">
      <title><database>CREATE EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-create-exception-msglength">
        <title>Message length increased</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 and higher, the maximum length of the exception message has been
          raised from 78 to 1021.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create exception Ex_TooManyManagers
  'Too many managers: An attempt was made to create more managers than the
   maximum defined in the Limits table. If you really need to create more
   managers than you have now, raise the limit first. However, please consult
   your department''s manager before doing so. Otherwise, your decision may
   be overturned later and the additional manager(s) removed.'</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>The maximum exception message length depends on a certain system table field.
          Therefore, pre-2.0 databases need to be backed up and restored under Firebird
          2.<replaceable>x</replaceable> before they can store exception messages of up to 1021
          bytes.</para>
        </note>
      </section>
    </section>
    <section id="langrefupd20-create-gen">
      <title><database>CREATE GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link linkend="langrefupd20-create-seq"><database>CREATE
        SEQUENCE</database></link></para>
      </formalpara>
      <section id="langrefupd20-creatgen-creatseq">
        <title><database>CREATE SEQUENCE</database> preferred</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>From Firebird 2.0 onward, the SQL-compliant <link
          linkend="langrefupd20-create-seq"><database>CREATE SEQUENCE</database></link> syntax is
          preferred.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-creatgen-limitraised">
        <title>Maximum number of generators significantly raised</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>InterBase reserved only one database page for generators, limiting the total number
          to 123 (on 1K pages) – 1019 (on 8K pages). Firebird has done away with that limit; you can
          now create more than 32,000 generators per database.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-create-index">
      <title><database>CREATE INDEX</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates an index on a table for faster searching, sorting and/or grouping.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CREATE [UNIQUE] [ASC[ENDING] | [DESC[ENDING]] INDEX <replaceable>indexname</replaceable>
   ON <replaceable>tablename</replaceable>
   { (<replaceable>&lt;col&gt;</replaceable> [, <replaceable>&lt;col&gt;</replaceable> ...]) | COMPUTED BY (<replaceable>expression</replaceable>) }

<replaceable>&lt;col&gt;</replaceable>  ::=  a column not of type ARRAY, BLOB or COMPUTED BY</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-creatind-unique-nulls">
        <title><database>UNIQUE</database> indices now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple –
          are now allowed in columns that have a <database>UNIQUE</database> index defined on them.
          For a full discussion, see <link
          linkend="langrefupd20-ct-unique-keys"><citetitle><database>CREATE TABLE</database> ::
          <database>UNIQUE</database> constraints now allow
          <constant>NULL</constant>s</citetitle></link>. As far as <constant>NULL</constant>s are
          concerned, the rules for unique indices are exactly the same as those for unique
          keys.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-creatind-on-expr">
        <title>Indexing on expressions</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Instead of one or more columns, you can now also specify a single <database>COMPUTED
          BY</database> expression in an index definition. Expression indices will be used in
          appropriate queries, provided that the expression in the <database>WHERE</database>,
          <database>ORDER BY</database> or <database>GROUP BY</database> clause exactly matches the
          expression in the index definition. Multi-segment expression indices are not supported,
          but the expression itself may involve multiple columns.</para>
          <!--Must the entire WHERE or ORDER BY be equal to the index, or does it work per item? Found out:

- With ORDER BY/GROUP BY, the entire clause must be the same, i.e. there can only be one order/group item.
  The same goes for column indices, btw: a 1-column index is never used in a multicolumn order/group by.
  A multicolumn index can be used for a multicolumn order/group by, provided they are fully equal.

- In the case of WHERE, the index can be used even if the expression doesn't constitute the entire search
  but is linked with AND (not OR!) to other predicates.

- HAVING seems not to use available expression indices. Column indices *are* used when appropriate.
  Asked Dmitry:
  > Another thing: I noticed that expression indices are used for ORDER BY, GROUP BY and WHERE clauses,
  > but not for HAVING clauses (unlike column indices). Is there a special reason for this?
  Answer (31-10-2008):
  No. Could you provide a test case?-->
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>create index ix_upname on persons computed by (upper(name));
commit;

-- the following queries will use ix_upname:
select * from persons order by upper(name);
select * from persons where upper(name) starting with 'VAN';
delete from persons where upper(name) = 'BROWN';
delete from persons where upper(name) = 'BROWN' and age &gt; 65;</programlisting>
              <programlisting>create descending index ix_events_yt
  on MyEvents
  computed by (extract(year from StartDate) || Town);
commit;

-- the following query will use ix_events_yt:
select * from MyEvents
  order by extract(year from StartDate) || Town desc;</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-creatind-keylength">
        <title>Maximum index key length increased</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum length of index keys, which used to be fixed at 252 bytes, is now equal
          to 1/4 of the page size, i.e. varying from 256 to 4096. The maximum indexable string
          length in bytes is 9 less than the key length. The table below shows the indexable string
          lengths in characters for the various page sizes and character sets.</para>
        </formalpara>
        <table id="langrefupd20-tbl-max-indexable-strlen">
          <title>Maximum indexable <database>(VAR)CHAR</database> length</title>
          <tgroup cols="5">
            <colspec align="left" colname="colPageSize" />
            <colspec align="center" colname="col1bpc" />
            <colspec align="center" colname="col2bpc" />
            <colspec align="center" colname="col3bpc" />
            <colspec align="center" colname="col4bpc" />
            <spanspec align="center" nameend="col4bpc" namest="col1bpc" spanname="spanAllCharsets" />
            <thead>
              <row valign="top">
                <entry align="left" morerows="1">Page size</entry>
                <entry spanname="spanAllCharsets">Maximum indexable string length per charset
                type</entry>
              </row>
              <row>
                <entry>1 byte/char</entry>
                <entry>2 bytes/char</entry>
                <entry>3 bytes/char</entry>
                <entry>4 bytes/char</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1024</entry>
                <entry>247</entry>
                <entry>123</entry>
                <entry>82</entry>
                <entry>61</entry>
              </row>
              <row>
                <entry>2048</entry>
                <entry>503</entry>
                <entry>251</entry>
                <entry>167</entry>
                <entry>125</entry>
              </row>
              <row>
                <entry>4096</entry>
                <entry>1015</entry>
                <entry>507</entry>
                <entry>338</entry>
                <entry>253</entry>
              </row>
              <row>
                <entry>8192</entry>
                <entry>2039</entry>
                <entry>1019</entry>
                <entry>679</entry>
                <entry>509</entry>
              </row>
              <row>
                <entry>16384</entry>
                <entry>4087</entry>
                <entry>2043</entry>
                <entry>1362</entry>
                <entry>1021</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="langrefupd20-creatind-maxnumber">
        <title>Maximum number of indices per table increased</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0.3, 1.5, 2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The maximum number of 65 indices per table has been removed in Firebird 1.0.3,
          reintroduced at the higher level of 257 in Firebird 1.5, and removed once again in
          Firebird 2.0.</para>
        </formalpara>
        <para>Although there is no longer a <quote>hard</quote> ceiling, the number of indices
        creatable in practice is still limited by the database page size and the number of columns
        per index, as shown in the table below.</para>
        <!--Why has the max. number of indices gone down again in 2.0?
According to Arno Brinkman, this *might* be due to extensions to the index root page,
probably the added segment selectivity.-->
        <table id="langrefupd20-tbl-maxindices">
          <title>Max. indices per table, Firebird 2.0</title>
          <tgroup cols="4">
            <colspec align="left" colname="colPageSize" />
            <colspec align="center" colname="colFb20_1" />
            <colspec align="center" colname="colFb20_2" />
            <colspec align="center" colname="colFb20_3" />
            <spanspec align="center" nameend="colFb20_3" namest="colFb20_1" spanname="spanColCounts" />
            <thead>
              <row valign="top">
                <entry align="left" morerows="1">Page size</entry>
                <entry spanname="spanColCounts">Number of indices depending on column count</entry>
              </row>
              <row>
                <entry>1 col</entry>
                <entry>2 cols</entry>
                <entry>3 cols</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1024</entry>
                <entry>50</entry>
                <entry>35</entry>
                <entry>27</entry>
              </row>
              <row>
                <entry>2048</entry>
                <entry>101</entry>
                <entry>72</entry>
                <entry>56</entry>
              </row>
              <row>
                <entry>4096</entry>
                <entry>203</entry>
                <entry>145</entry>
                <entry>113</entry>
              </row>
              <row>
                <entry>8192</entry>
                <entry>408</entry>
                <entry>291</entry>
                <entry>227</entry>
              </row>
              <row>
                <entry>16384</entry>
                <entry>818</entry>
                <entry>584</entry>
                <entry>454</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Please be aware that under normal circumstances, even 50 indices is way too many and
        will drastically reduce mutation speeds. The maximum was removed to accommodate
        data-warehousing applications and the like, which perform lots of bulk operations with the
        indices temporarily inactivated.</para>
        <para>For a full table also including Firebird versions 1.0–1.5, see the <link
        linkend="langrefupd20-notes-maxindices">Notes</link> at the end of the book.</para>
      </section>
    </section>
    <section id="langrefupd20-create-proc">
      <title><database>CREATE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>It is now possible to provide default values for stored procedure arguments, allowing
        the caller to omit one or more items from the end of the argument list.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CREATE PROCEDURE <replaceable>procname</replaceable> (<replaceable>&lt;inparam&gt;</replaceable> [, <replaceable>&lt;inparam&gt;</replaceable> ...])
   ...

<replaceable>&lt;inparam&gt;</replaceable>  ::=  <replaceable>paramname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>]</programlisting>
            <para><emphasis role="bold">Important:</emphasis> If you give a parameter a default
            value, all parameters coming after it must also get default values.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure TestProc
  (a int, b int default 8, s varchar(12) = '')
  ...</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-create-seq">
      <title><database>CREATE SEQUENCE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates a new sequence or generator. <database>SEQUENCE</database> is the
        SQL-compliant term for what InterBase and Firebird have always called a generator.
        <database>CREATE SEQUENCE</database> is fully equivalent to <database>CREATE
        GENERATOR</database> and is the recommended syntax from Firebird 2.0 onward.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CREATE SEQUENCE <replaceable>sequence-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create sequence seqtest</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Because internally sequences and generators are the same thing, you can freely mix the
      generator and sequence syntaxes, even when operating on the same object. This is not
      recommended however.</para>
      <para>Sequences (or generators) are always stored as 64-bit integer values, regardless of the
      database dialect. However:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>If the <emphasis>client</emphasis> dialect is set to 1, the server passes generator
          values as truncated 32-bit values to the client.</para>
        </listitem>
        <listitem>
          <para>If generator values are fed into a 32-bit field or variable, all goes well until the
          actual value exceeds the 32-bit range. At that point, a dialect 3 database will raise an
          error whereas a dialect 1 database will silently truncate the value (which could also lead
          to an error, e.g. if the receiving field has a unique key defined on it).</para>
        </listitem>
      </itemizedlist>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-alter-seq"><database>ALTER SEQUENCE</database></link>,
        <link linkend="langrefupd20-nextvaluefor"><database>NEXT VALUE FOR</database></link>, <link
        linkend="langrefupd20-drop-seq"><database>DROP SEQUENCE</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-create-table">
      <title><database>CREATE TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-ct-check">
        <title><database>CHECK</database> accepts <constant>NULL</constant> outcome</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If a <database>CHECK</database> constraint resolves to <constant>NULL</constant>,
          Firebird versions before 2.0 reject the input. Following the SQL standard to the letter,
          Firebird 2.0 and above let <constant>NULL</constant>s pass and only consider the check
          failed if the outcome is <constant>false</constant>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <para>Checks like these:</para>
              <programlisting>check (value &gt; 10000)</programlisting>
              <programlisting>check (Town like 'Amst%')</programlisting>
              <programlisting>check (upper(value) in ( 'A', 'B', 'X' ))</programlisting>
              <programlisting>check (Minimum &lt;= Maximum)</programlisting>
              <para>all <emphasis>fail</emphasis> in pre-2.0 Firebird versions if the value to be
              checked is <constant>NULL</constant>. In 2.0 and above they
              <emphasis>succeed</emphasis>.</para>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>This change may cause existing databases to behave differently when migrated to
          Firebird 2.0+. Carefully examine your <database>CREATE/ALTER TABLE</database> statements
          and add <quote><code>and XXX is not null</code></quote> predicates to your
          <database>CHECK</database>s if they should continue to reject <constant>NULL</constant>
          input.</para>
        </warning>
      </section>
      <section id="langrefupd20-ct-contextvars">
        <title>Context variables as column defaults</title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any context variable that is assignment-compatible to the column datatype can be
          used as a default. This was already the case in InterBase 6, but the <citetitle>Language
          Reference</citetitle> only mentioned <varname>USER</varname>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table MyData (
  id int not null primary key,
  record_created timestamp default current_timestamp,
  ...
)</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-ct-fk-notargetcol">
        <title><database>FOREIGN KEY</database> without target column references
        <database>PK</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you create a foreign key without specifying a target column, it will reference
          the <emphasis role="bold">primary key</emphasis> of the target table. This was already the
          case in InterBase 6, but the IB Language Reference wrongly states that in such cases, the
          engine scans the target table for a column with the same name as the referencing
          column.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create table eik (
  a int not null primary key,
  b int not null unique
);

create table beuk (
  b int references eik
);

-- beuk.b references eik.a, not eik.b !</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-ct-fk-noexclusive">
        <title><database>FOREIGN KEY</database> creation no longer requires exclusive access</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 and above, creating a foreign key constraint no longer requires
          exclusive access to the database.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-ct-unique-keys">
        <title><database>UNIQUE</database> constraints now allow <constant>NULL</constant>s</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In compliance with the SQL-99 standard, <constant>NULL</constant>s – even multiple –
          are now allowed in columns with a <database>UNIQUE</database> constraint. It is therefore
          possible to define a <database>UNIQUE</database> key on a column that has no <database>NOT
          NULL</database> constraint.</para>
        </formalpara>
        <para>For <database>UNIQUE</database> keys that span multiple columns, the logic is a little
        complicated:</para>
        <itemizedlist>
          <listitem>
            <para>Multiple rows having <emphasis>all</emphasis> the <database>UK</database> columns
            <constant>NULL</constant> are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having a <emphasis>different subset</emphasis> of
            <database>UK</database> colums <constant>NULL</constant> are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having the <emphasis>same subset</emphasis> of
            <database>UK</database> columns <constant>NULL</constant> and the rest filled with
            regular values and those regular values <emphasis>differ</emphasis> in at least one
            column, are allowed.</para>
          </listitem>
          <listitem>
            <para>Multiple rows having the <emphasis>same subset</emphasis> of
            <database>UK</database> columns <constant>NULL</constant> and the rest filled with
            regular values and those regular values are the <emphasis>same</emphasis> in every
            column, are forbidden.</para>
          </listitem>
        </itemizedlist>
        <para>One way of summarizing this is as follows: In principle, all
        <constant>NULL</constant>s are considered distinct. But if two rows have exactly the same
        subset of <database>UK</database> columns filled with non-<constant>NULL</constant> values,
        the <constant>NULL</constant> columns are ignored and the non-<constant>NULL</constant>
        columns are decisive, just as if they constituted the entire unique key.</para>
        <!--Give example tables to show what is and isn't allowed?-->
      </section>
      <section id="langrefupd20-ct-using-index">
        <title><database>USING INDEX</database> subclause</title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no support found in source-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>USING INDEX</database> subclause can be placed at the end of a primary,
          unique or foreign key definition. Its purpose is to<itemizedlist spacing="compact">
              <listitem>
                <para>provide a user-defined name for the automatically created index that enforces
                the constraint, and</para>
              </listitem>
              <listitem>
                <para>optionally define the index to be ascending or descending (the default being
                ascending).</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <para>Without <database>USING INDEX</database>, indices enforcing named constraints are
        named after the constraint (this is new behaviour in Firebird 1.5) and indices for unnamed
        constraints get names like <database>RDB$FOREIGN13</database> or something equally
        romantic.</para>
        <note>
          <para>You must always provide a <emphasis>new</emphasis> name for the index. It is not
          possible to use pre-existing indices to enforce constraints.</para>
        </note>
        <para><database>USING INDEX</database> can be applied at field level, at table level, and
        (in <database>ALTER TABLE</database>) with <database>ADD CONSTRAINT</database>. It works
        with named as well as unnamed key constraints. It does <emphasis>not</emphasis> work with
        <database>CHECK</database> constraints, as these don't have their own enforcing
        index.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>[CONSTRAINT <replaceable>constraint-name</replaceable>]
   <replaceable>&lt;constraint-type&gt;</replaceable> <replaceable>&lt;constraint-definition&gt;</replaceable>
   [USING [ASC[ENDING] | DESC[ENDING]] INDEX <replaceable>index_name</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The first example creates a primary key constraint <database>PK_CUST</database>
              using an index named <database>IX_CUSTNO</database>:</para>
              <programlisting>create table customers (
  custno int not null constraint pk_cust primary key using index ix_custno,
  ...</programlisting>
              <para>This, however:</para>
              <programlisting>create table customers (
  custno int not null primary key using index ix_custno,
  ...</programlisting>
              <para>...will give you a PK constraint called <database>INTEG_7</database> or
              something similar, and an index <database>IX_CUSTNO</database>.</para>
              <para>Some more examples:</para>
              <programlisting>create table people (
  id int not null,
  nickname varchar(12) not null,
  country char(4),
  ..
  ..
  constraint pk_people primary key (id),
  constraint uk_nickname unique (nickname) using index ix_nick
)</programlisting>
              <programlisting>alter table people
  add constraint fk_people_country
  foreign key (country) references countries(code)
  using desc index ix_people_country</programlisting>
            </blockquote></para>
        </formalpara>
        <important>
          <para>If you define a descending constraint-enforcing index on a primary or unique key, be
          sure to make any foreign keys referencing it descending as well.<!--Or else?--></para>
        </important>
      </section>
    </section>
    <section id="langrefupd20-create-trigger">
      <title><database>CREATE TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates a trigger, i.e. a block of PSQL code that is executed automatically before or
        after certain mutations to a table or view.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CREATE TRIGGER <replaceable>name</replaceable> FOR {<replaceable>table</replaceable> | <replaceable>view</replaceable>}
   [ACTIVE | INACTIVE]
   {BEFORE | AFTER} <replaceable>&lt;action_list&gt;</replaceable>
   [POSITION <replaceable>number</replaceable>]
   AS
   <replaceable>&lt;trigger_body&gt;</replaceable>

<replaceable>&lt;action_list&gt;</replaceable>  ::=  <replaceable>&lt;action&gt;</replaceable> [OR <replaceable>&lt;action&gt;</replaceable> [OR <replaceable>&lt;action&gt;</replaceable>]]
<replaceable>&lt;action&gt;</replaceable>       ::=  INSERT | UPDATE | DELETE</programlisting>
            <!--Fill in <trigger_body> !-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-create-trigger-multiaction">
        <title>Multi-action triggers</title>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Triggers can now be defined to fire upon multiple operations
          (<database>INSERT</database> and/or <database>UPDATE</database> and/or
          <database>DELETE</database>). Three new boolean context variables
          (<varname>INSERTING</varname>, <varname>UPDATING</varname> and
          <varname>DELETING</varname>) have been added so you can execute code conditionally within
          the trigger body depending on the type of operation.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create trigger biu_parts for parts
  before insert or update
as
begin
  /* conditional code when inserting: */
  if (inserting and new.id is null)
    then new.id = gen_id(gen_partrec_id, 1);
  
  /* common code: */
  new.partname_upper = upper(new.partname);
end</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>In multi-action triggers, both context variables <database>OLD</database> and
          <database>NEW</database> are always available. If you use them in the wrong situation
          (i.e. <database>OLD</database> while inserting or <database>NEW</database> while
          deleting), the following happens:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>If you try to read their field values, <constant>NULL</constant> is
              returned.</para>
            </listitem>
            <listitem>
              <para>If you try to assign values to them, a runtime exception is thrown.</para>
            </listitem>
          </itemizedlist>
        </note>
      </section>
      <section id="langrefupd20-create-trigger-changecount">
        <title><database>CREATE TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In contrast to InterBase, Firebird does not increment the metadata change counter of
          the associated table when <database>CREATE</database>, <database>ALTER</database> or
          <database>DROP TRIGGER</database> is used. For a full discussion, see <link
          linkend="langrefupd20-alter-trigger-changecount"><citetitle><database>ALTER
          TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-create-trigger-plan">
        <title><database>PLAN</database> allowed in trigger code</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement
          would be rejected by the compiler. Now a valid plan can be included and will be
          used.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-create-view">
      <title><database>CREATE VIEW</database></title>
      <!--In the 2.0 Rlsnotes:
  Changed Logic for View Updates
  Apply NOT NULL constraints to base tables only, ignoring the ones inherited by view columns
  from domain definitions.

This looked weird: view columns can't specify a datatype or domain, so how in the world
can they inherit a NOT NULL constraint from a domain, *other than through the base table* ?!

Reaction Dmitry (31-10-2008):
 "IIRC, this change allows to pass NULLs to views that are made updateable
  via triggers (as they can override that value with something valid)."

Some testing revealed that 1.5 had a problem, not with not-null fields that participated in the
view (as long as a trigger converted the nulls before submitting the data to the table), but with
not-null fields that were left out of the view - even if a trigger supplied a valid value for
them. For those columns you would get a validation error. This has been fixed in 2.0-->
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-creatview-fullselect">
        <title>Full <database>SELECT</database> syntax supported</title>
        <!--IB6 LangRef p.88: UNIONs in views supported in ESQL, but not in DSQL.-->
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>From Firebird 2.0 onward view definitions are considered full-fledged
          <database>SELECT</database> statements. Consequently, the following elements are
          (re)allowed in view definitions: <database>FIRST</database>, <database>SKIP</database>,
          <database>ROWS</database>, <database>ORDER BY</database>, <database>PLAN</database> and
          <database>UNION</database>.</para>
        </formalpara>
        <note>
          <para>The use of a <database>UNION</database> within a view is currently only supported if
          you supply a column list for the view (this list is normally optional):</para>
          <programlisting>create view vplanes <emphasis role="bold">(make, model)</emphasis> as
  select make, model from jets
    union
  select make, model from props
    union
  select make, model from gliders</programlisting>
          <para>In Firebird 2.5, the column list will become optional also for views with
          <database>UNION</database>s.</para>
        </note>
      </section>
      <section id="langrefupd20-creatview-noplan">
        <title><database>PLAN</database> subclause disallowed in 1.5, reallowed in 2.0</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5, 2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird versions 1.5.x forbid the use of a <database>PLAN</database> subclause in a
          view definition. From 2.0 onward a <database>PLAN</database> is allowed again.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-creatview-triggers">
        <title>Triggers on updatable views block auto-writethrough</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In versions prior to 2.0, Firebird often did not block the automatic writethrough to
          the underlying table if one or more triggers were defined on a naturally updatable view.
          This could cause mutations to be performed twice unintentionally, sometimes leading to
          data corruption and other mishaps. Starting at Firebird 2.0, this misbehaviour has been
          corrected: now if you define a trigger on a naturally updatable view, no mutations to the
          view will be automatically passed on to the table; either your trigger takes care of that,
          or nothing will. This is in accordance with the description in the InterBase 6
          <citetitle>Data Definition Guide</citetitle> under <citetitle>Updating views with
          triggers</citetitle>.</para>
        </formalpara>
        <warning>
          <para>Some people have developed code that counts on or takes advantage of the prior
          behaviour. Such code should be corrected for Firebird 2.0 and higher, or mutations may not
          reach the table at all.</para>
        </warning>
      </section>
      <section id="langrefupd20-creatview-insertable">
        <title>View with non-participating <database>NOT NULL</database> columns in base table can
        be made insertable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Any view whose base table contains one or more non-participating <database>NOT
          NULL</database> columns is read-only by nature. It can be made updatable by the use of
          triggers, but even with those, all <database>INSERT</database> attempts into such views
          used to fail because the <database>NOT NULL</database> constraint on the base table was
          checked before the view trigger got a chance to put things right. In Firebird 2.0 and up
          this is no longer the case: provided the right trigger is in place, such views are now
          insertable.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <para>The view below would give validation errors for any insert attempts in Firebird
              1.5 and earlier. In Firebird 2.0 and up it is insertable:</para>
              <programlisting>create table base (x int not null, y int not null);

create view vbase as select x from base;

set term #;
create trigger bi_base for vbase before insert
as
begin
  if (new.x is null) then new.x = 33;
  insert into base values (new.x, 0);
end#
set term ;#</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>Please notice that the problem described above only occurred for <database>NOT
                NULL</database> columns that were left <emphasis>outside</emphasis> the view.</para>
              </listitem>
              <listitem>
                <para>Oddly enough, the problem would be gone if the base table itself had a trigger
                converting <constant>NULL</constant> input to something valid.<!--Is this also true if adding the trigger does NOT make the view updatable according to Firebird?
Test with e.g. a join.--> But then there was a risk that the insert would take place twice, due to
                the <link linkend="langrefupd20-creatview-triggers">auto-writethrough bug</link>
                that has also been fixed in Firebird 2.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>
    <!--None of the "CREATE OR ALTER" statements seems available in ESQL:-->
    <section id="langrefupd20-create-or-alter-exception">
      <title><database>CREATE OR ALTER EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the exception does not yet exist, it is created just as if <database>CREATE
        EXCEPTION</database> were used. If it already exists, it is altered. Existing dependencies
        are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE EXCEPTION</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-create-or-alter-proc">
      <title><database>CREATE OR ALTER PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the procedure does not yet exist, it is created just as if <database>CREATE
        PROCEDURE</database> were used. If it already exists, it is altered and recompiled. Existing
        permissions and dependencies are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE PROCEDURE</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-create-or-alter-trigger">
      <title><database>CREATE OR ALTER TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>If the trigger does not yet exist, it is created just as if <database>CREATE
        TRIGGER</database> were used. If it already exists, it is altered and recompiled. Existing
        permissions and dependencies are preserved.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as for <database>CREATE TRIGGER</database>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-declare-extfunc">
      <title><database>DECLARE EXTERNAL FUNCTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>This statement makes an external function (UDF) known to the database.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION <replaceable>localname</replaceable>
   [<replaceable>&lt;arg_type_decl&gt;</replaceable> [, <replaceable>&lt;arg_type_decl&gt;</replaceable> ...]]
   RETURNS {<replaceable>&lt;return_type_decl&gt;</replaceable> | PARAMETER <replaceable>1-based_pos</replaceable>} [FREE_IT]
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;arg_type_decl&gt;</replaceable>     ::=  <replaceable>sqltype</replaceable> [BY DESCRIPTOR] | CSTRING(<replaceable>length</replaceable>)
<replaceable>&lt;return_type_decl&gt;</replaceable>  ::=  <replaceable>sqltype</replaceable> [BY {DESCRIPTOR|VALUE}] | CSTRING(<replaceable>length</replaceable>)</programlisting>
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>BY DESCRIPTOR</database> passing method is not supported in
                  ESQL.</para>
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <para>You may choose <replaceable>localname</replaceable> freely; this is the name by which
      the function will be known to your database. You may also vary the
      <replaceable>length</replaceable> argument of <database>CSTRING</database> parameters (more
      about <database>CSTRING</database>s in the <link
      linkend="langrefupd20-notes-cstring">note</link> near the end of the book).</para>
      <section id="langrefupd20-declareext-bydescriptor">
        <title><database>BY DESCRIPTOR</database> parameter passing</title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Firebird introduces the possibility to pass parameters <database>BY
          DESCRIPTOR</database>; this mechanism facilitates the processing of
          <constant>NULL</constant>s in a meaningful way. Notice that this only works if the person
          who wrote the function has implemented it. Simply adding <quote><database>BY
          DESCRIPTOR</database></quote> to an existing declaration does not make it work – on the
          contrary! Always use the declaration block provided by the function designer.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-declareext-retparamn">
        <title><database>RETURNS PARAMETER</database> <replaceable>n</replaceable></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>IB 6</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In order to return a <database>BLOB</database>, an extra input parameter must be
          declared and a <quote><database>RETURNS PARAMETER</database>
          <replaceable>n</replaceable></quote> clause added – <replaceable>n</replaceable> being the
          position of said parameter. This clause dates back to InterBase 6 beta, but somehow didn't
          make it into the <citetitle>Language Reference</citetitle> (it is documented in the
          <citetitle>Developer's Guide</citetitle> though).</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-declare-filter">
      <title><database>DECLARE FILTER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Makes a <database>BLOB</database> filter available to the database.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DECLARE FILTER <replaceable>filtername</replaceable>
   INPUT_TYPE <replaceable>&lt;sub_type&gt;</replaceable> OUTPUT_TYPE <replaceable>&lt;sub_type&gt;</replaceable>
   ENTRY_POINT '<replaceable>function_name</replaceable>' MODULE_NAME '<replaceable>library_name</replaceable>'

<replaceable>&lt;sub_type&gt;</replaceable>  ::=  <replaceable>number</replaceable> | <replaceable>&lt;mnemonic&gt;</replaceable>
<replaceable>&lt;mnemonic&gt;</replaceable>  ::=  binary | text | blr | acl | ranges | summary | format
                 | transaction_description | external_file_description
                 | <replaceable>user_defined</replaceable></programlisting>
            <itemizedlist>
              <listitem>
                <para>In Firebird 2 and up, no two <database>BLOB</database> filters in a database
                may have the same combination of input and output type. Declaring a filter with an
                already existing input-output type combination will fail. Restoring pre-2.0
                databases that contain such <quote>duplicate</quote> filters will also fail.</para>
              </listitem>
              <listitem>
                <para>The possibility to indicate the <database>BLOB</database> types with their
                mnemonics instead of numbers was added in Firebird 2. The
                <constant>binary</constant> mnemonic for subtype 0 was also added in Firebird 2. The
                predefined mnemonics are case-insensitive.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>declare filter Funnel
  input_type blr output_type text
  entry_point 'blr2asc' module_name 'myfilterlib'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>User-defined mnemonics</title>
        <para>If you want to define mnemonics for your own <database>BLOB</database> subtypes, you
        can add them to <database>the RDB$TYPES</database> system table as shown below. Once
        committed, the mnemonics can be used in subsequent filter declarations.<blockquote>
            <programlisting>insert into rdb$types (rdb$field_name, rdb$type, rdb$type_name)
  values ('RDB$FIELD_SUB_TYPE', -33, 'MIDI')</programlisting>
          </blockquote>The value for <literal>rdb$field_name</literal> must always be
        <database>'RDB$FIELD_SUB_TYPE'</database>. If you define your mnemonics in all-uppercase,
        you can use them case-insensitively and unquoted in your filter declarations.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-drop-generator">
      <title><database>DROP GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in source-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link linkend="langrefupd20-drop-seq"><database>DROP SEQUENCE</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Removes a generator or sequence from the database. Its (very small) storage space will
        be freed for re-use after a backup-restore cycle.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DROP GENERATOR <replaceable>generator-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <para>From Firebird 2.0 onward, the SQL-compliant <link
      linkend="langrefupd20-drop-seq"><database>DROP SEQUENCE</database></link> syntax is
      preferred.</para>
    </section>
    <section id="langrefupd20-drop-proc">
      <title><database>DROP PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-drop-proc-restr">
        <title>Restriction on dropping used procedures</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.0.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from dropping,
          altering or recreating a trigger or stored procedure if it has been used since the
          database was opened. This restriction has been removed again in version 2.0.1. Still,
          performing these operations on a live database is potentially risky and should only be
          done with the utmost care.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-drop-seq">
      <title><database>DROP SEQUENCE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Removes a sequence or generator from the database. Its (very small) storage space will
        be freed for re-use after a backup-restore cycle. <database>SEQUENCE</database> is the
        SQL-compliant term for what InterBase and Firebird have always called a generator.
        <database>DROP SEQUENCE</database> is fully equivalent to <database>DROP
        GENERATOR</database> and is the recommended syntax from Firebird 2.0 onward.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>DROP SEQUENCE <replaceable>sequence-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>drop sequence seqtest</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-create-seq"><database>CREATE
        SEQUENCE</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-drop-trigger">
      <title><database>DROP TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <section id="langrefupd20-drop-trigger-restr">
        <title>Restriction on dropping used triggers</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.0.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from dropping,
          altering or recreating a trigger or stored procedure if it has been used since the
          database was opened. This restriction has been removed again in version 2.0.1. Still,
          performing these operations on a live database is potentially risky and should only be
          done with the utmost care.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-drop-trigger-changecount">
        <title><database>DROP TRIGGER</database> no longer increments table change count</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In contrast to InterBase, Firebird does not increment the metadata change counter of
          the associated table when <database>CREATE</database>, <database>ALTER</database> or
          <database>DROP TRIGGER</database> is used. For a full discussion, see <link
          linkend="langrefupd20-alter-trigger-changecount"><citetitle><database>ALTER
          TRIGGER</database> no longer increments table change count</citetitle></link>.</para>
        </formalpara>
      </section>
    </section>
    <!--RECREATE seems totally absent from ESQL-->
    <section id="langrefupd20-recreate-exception">
      <title><database>RECREATE EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates an exception. If an exception with the same name already exists,
        <database>RECREATE EXCEPTION</database> will try to drop it and create a new exception. This
        wlll fail if there are existing dependencies on the exception.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <database>CREATE EXCEPTION</database>.</para>
      </formalpara>
      <note>
        <para>If you use <database>RECREATE EXCEPTION</database> on an exception that has dependent
        objects, you may not get an error message until you try to commit your transaction.</para>
        <!--I wonder why that is? It's not very practical. (Asked Dmitry.)
Answer (31-10-2008):
  The major part of the every DDL work is actually executed at commit. 
  Some DDL operations offer early (execute time) checks in order to be a 
  bit more friendly to the user. It seems this one is missing such a 
  check. Worth entering into the tracker.-->
      </note>
      <!--LangRef says that an exception can be dropped or altered by:
- its creator
- SYSDBA
- OS superuser
But where is the creator/owner of an exception kept? Not in rdb$exceptions...

OK, just created a new user without any privileges on whatever and he can just connect
and drop any exception (as long as there are no dependencies on it).
He can also ALTER existing exceptions that have dependencies.
Now find out how this is in Fb 1.5, 1.0 and IB6 - and DOCUMENT it.

(Asked Dmitry about this.)
Answer (31-10-2008):
  Yes, v3.0 is expected to implement ACLs for all metadata objects. The 
  same issue exists with generators and UDFs, BTW.-->
    </section>
    <section id="langrefupd20-recreate-proc">
      <title><database>RECREATE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a stored procedure. If a procedure with the same name already
        exists, <database>RECREATE PROCEDURE</database> will try to drop it and create a new
        procedure. <database>RECREATE PROCEDURE</database> will fail if the existing
        <database>SP</database> is in use.<!--Make sure this last statement is true!--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <link linkend="langrefupd20-create-proc"><database>CREATE
        PROCEDURE</database></link>.</para>
      </formalpara>
      <section id="langrefupd20-recreate-proc-restr">
        <title>Restriction on recreating used procedures</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.0.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from dropping,
          altering or recreating a trigger or stored procedure if it has been used since the
          database was opened. This restriction has been removed again in version 2.0.1. Still,
          performing these operations on a live database is potentially risky and should only be
          done with the utmost care.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-recreate-table">
      <title><database>RECREATE TABLE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a table. If a table with the same name already exists,
        <database>RECREATE TABLE</database> will try to drop it (destroying all its data in the
        process!) and create a new table. <database>RECREATE TABLE</database> will fail if the
        existing table is in use.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <link linkend="langrefupd20-create-table"><database>CREATE
        TABLE</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-recreate-trigger">
      <title><database>RECREATE TRIGGER</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a trigger. If a trigger with the same name already exists,
        <database>RECREATE TRIGGER</database> will try to drop it and create a new trigger.
        <database>RECREATE TRIGGER</database> will fail if the existing trigger is in use.<!--Make sure this last statement is true!--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <link linkend="langrefupd20-create-trigger"><database>CREATE
        TRIGGER</database></link>.</para>
      </formalpara>
      <section id="langrefupd20-recreate-trigger-restr">
        <title>Restriction on recreating used triggers</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0, 2.0.1</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 2.0 only, a restriction is in place which prevents anyone from dropping,
          altering or recreating a trigger or stored procedure if it has been used since the
          database was opened. This restriction has been removed again in version 2.0.1. Still,
          performing these operations on a live database is potentially risky and should only be
          done with the utmost care.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-recreate-view">
      <title><database>RECREATE VIEW</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates or recreates a view. If a view with the same name already exists,
        <database>RECREATE VIEW</database> will try to drop it and create a new view.
        <database>RECREATE VIEW</database> will fail if the existing view is in use.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para>Exactly the same as <link linkend="langrefupd20-create-view"><database>CREATE
        VIEW</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-revoke-admin-option">
      <title><database>REVOKE ADMIN OPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: No support found in sources. Even the older WITH ADMIN OPTION is not supported.-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Revokes a previously granted admin option (the right to pass on a granted role to
        others) from the grantee, without revoking the role itself. Multiple roles and/or multiple
        grantees can be handled in one statement.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>REVOKE ADMIN OPTION FOR <replaceable>&lt;role-list&gt;</replaceable> FROM <replaceable>&lt;grantee-list&gt;</replaceable>

<replaceable>&lt;role-list&gt;</replaceable>     ::=  <replaceable>role</replaceable> [, <replaceable>role</replaceable> ...]
<replaceable>&lt;grantee-list&gt;</replaceable>  ::=  [USER] <replaceable>&lt;grantee&gt;</replaceable> [, [USER] <replaceable>&lt;grantee&gt;</replaceable> ...]
<replaceable>&lt;grantee&gt;</replaceable>       ::=  <replaceable>username</replaceable> | PUBLIC</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>revoke admin option for manager from john, paul, george, ringo</programlisting>
          </blockquote></para>
      </formalpara>
      <para>If a user has received the admin option from several grantors, each of those grantors
      must revoke it or the user will still be able to grant the role(s) in question to
      others.</para>
    </section>
    <section id="langrefupd20-set-generator">
      <title><database>SET GENERATOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link linkend="langrefupd20-alter-seq"><database>ALTER
        SEQUENCE</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>(Re)initializes a generator or sequence to the given value. From Firebird 2 onward,
        the SQL-compliant <link linkend="langrefupd20-alter-seq"><database>ALTER
        SEQUENCE</database></link> syntax is preferred.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SET GENERATOR <replaceable>generator-name</replaceable> TO <replaceable>&lt;new-value&gt;</replaceable>

<replaceable>&lt;new-value&gt;</replaceable>  ::=  A 64-bit integer.</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>Once a generator or sequence is up and running, you should not tamper with its value
        (other than retrieving next values with <database>GEN_ID</database> or <database>NEXT VALUE
        FOR</database>) unless you know exactly what you are doing.</para>
      </warning>
    </section>
  </chapter>
  <chapter id="langrefupd20-dml">
    <title>DML statements</title>
    <!--Rlsnotes 1.0:
  New PLANONLY option for statements
  Support for PLANONLY setting, allows for a statement/query to be submitted to the engine and
  the plan retrieved, without executing the statement/query.

As it turns out, this refers to SET PLANONLY in isql. You can NOT just add PLANONLY
to SQL statements!-->
    <section id="langrefupd20-delete">
      <title><database>DELETE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Deletes rows from a database table (or from one or more tables underlying a view),
        depending on the <database>WHERE</database> and <database>ROWS</database> clauses.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <!--Both IB6 LangRef and IBP RefGuide forget to mention views.-->
            <!--DELETE and UPDATE allow a table/view alias, also in 1.5.3.
Find out since when (this is not mentioned in IB LangRef) and document it
with DELETE and UPDATE, possibly also in LangRefUpd-1.5-->
            <programlisting>DELETE
   [TRANSACTION <replaceable>name</replaceable>]
   FROM {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>
                <listitem>
                  <para>In a pure DSQL session, <database>WHERE CURRENT OF</database> isn't of much
                  use, since there exists no DSQL statement to create a cursor.</para>
                </listitem>
                <listitem>
                  <para>The <database>PLAN</database>, <database>ORDER BY</database> and
                  <database>ROWS</database> clauses are not available in ESQL.</para>
                </listitem>
              </itemizedlist>
            </note>
            <!--Are only 'loose' plan_items allowed, or also JOIN, SORT, MERGE ?-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-delete-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>delete from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-delete-orderby">
        <title><database>ORDER BY</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>DELETE</database> now allows an <database>ORDER BY</database> clause. This
          only makes sense in combination with <database>ROWS</database>, but is also valid without
          it.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-delete-plan">
        <title><database>PLAN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>DELETE</database> now allows a <database>PLAN</database> clause, so users
          can optimize the operation manually.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-delete-alias-use">
        <title>Relation alias makes real name unavailable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you give a table or view an alias in a Firebird 2.0 or above statement, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that relation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Correct usage:</para>
              <programlisting>delete from Cities where name starting 'Alex'</programlisting>
              <programlisting>delete from Cities where Cities.name starting 'Alex'</programlisting>
              <programlisting>delete from Cities C where name starting 'Alex'</programlisting>
              <programlisting>delete from Cities C where C.name starting 'Alex'</programlisting>
              <para>No longer possible:</para>
              <programlisting>delete from Cities C where Cities.name starting 'Alex'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-delete-rows">
        <title><database>ROWS</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Limits the amount of rows deleted to a specified number or range.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            </blockquote></para>
        </formalpara>
        <para>With a single argument <replaceable>m</replaceable>, the deletion is limited to the
        first <replaceable>m</replaceable> rows of the dataset defined by the table or view and the
        optional <database>WHERE</database> and <database>ORDER BY</database> clauses.</para>
        <para>Points to note:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> = 0, no rows are deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>
        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, the
        deletion is limited to rows <replaceable>m</replaceable> to <replaceable>n</replaceable>
        inclusively. Row numbers are 1-based.</para>
        <para>Points to note when using two arguments:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, no
            rows are deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, no rows are
            deleted.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>
        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd20-select-rows"><database>SELECT</database></link> and <link
        linkend="langrefupd20-update-rows"><database>UPDATE</database></link> statements.</para>
      </section>
    </section>
    <section id="langrefupd20-execblock">
      <title><database>EXECUTE BLOCK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a block of PSQL code as if it were a stored procedure, optionally with input
        and output parameters and variable declarations. This allows the user to perform
        <quote>on-the-fly</quote> PSQL within a DSQL context.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXECUTE BLOCK [(<replaceable>&lt;inparams&gt;</replaceable>)]
     [RETURNS (<replaceable>&lt;outparams&gt;</replaceable>)]
AS
   [<replaceable>&lt;declarations&gt;</replaceable>]
BEGIN
   [<replaceable>&lt;PSQL statements&gt;</replaceable>]
END

<replaceable>&lt;inparams&gt;</replaceable>      ::=  <replaceable>paramname</replaceable> <replaceable>type</replaceable> = ? [, <replaceable>&lt;inparams&gt;</replaceable>]
<replaceable>&lt;outparams&gt;</replaceable>     ::=  <replaceable>paramname</replaceable> <replaceable>type</replaceable> [, <replaceable>&lt;outparams&gt;</replaceable>]
<replaceable>&lt;declarations&gt;</replaceable>  ::=  See <link linkend="langrefupd20-psql-declare"><citetitle>PSQL::<database>DECLARE</database></citetitle></link> for the exact syntax</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>This example injects the numbers 0 through 127 and their corresponding ASCII
            characters into the table <database>ASCIITABLE</database>:</para>
            <programlisting>execute block
as
declare i int = 0;
begin
  while (i &lt; 128) do
  begin
    insert into AsciiTable values (:i, ascii_char(:i));
    i = i + 1;
  end
end</programlisting>
          </blockquote><blockquote>
            <para>The next example calculates the geometric mean of two numbers and returns it to
            the user:</para>
            <programlisting>execute block (x double precision = ?, y double precision = ?)
returns (gmean double precision)
as
begin
  gmean = sqrt(x*y);
  suspend;
end</programlisting>
            <para>Because this block has input parameters, it has to be prepared first. Then the
            parameters can be set and the block executed. It depends on the client software how this
            must be done and even if it is possible at all – see the notes below.</para>
            <para>Our last example takes two integer values, <varname>smallest</varname> and
            <varname>largest</varname>. For all the numbers in the range <varname>smallest</varname>
            .. <varname>largest</varname>, the block outputs the number itself, its square, its cube
            and its fourth power.</para>
            <programlisting>execute block (smallest int = ?, largest int = ?)
returns (number int, square bigint, cube bigint, fourth bigint)
as
begin
  number = smallest;
  while (number &lt;= largest) do
  begin
    square = number * number;
    cube   = number * square;
    fourth = number * cube;
    suspend;
    number = number + 1;
  end
end</programlisting>
            <para>Again, it depends on the client software if and how you can set the parameter
            values.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Some clients, especially those allowing the user to submit several statements at
              once, may require you to surround the <database>EXECUTE BLOCK</database> statement
              with <database>SET TERM</database> lines, like this:</para>
              <programlisting>set term #;
execute block (...)
as
begin
  statement1;
  statement2;
end
#
set term ;#</programlisting>
              <para>In Firebird's <application>isql</application> client you must set the terminator
              to something other than <quote><literal>;</literal></quote> before you type in the
              <database>EXECUTE BLOCK</database> statement. Otherwise
              <application>isql</application>, being line-oriented, will try to execute the part you
              have entered as soon as it encounters the first semicolon.</para>
            </listitem>
            <listitem>
              <para>Executing a block without input parameters should be possible with every
              Firebird client that allows the user to enter his or her own DSQL statements. If there
              are input parameters, things get trickier: these parameters must get their values
              after the statement is prepared but before it is executed. This requires special
              provisions, which not every client application offers. (Firebird's own
              <application>isql</application>, for one, doesn't.)</para>
            </listitem>
            <listitem>
              <para>The server only accepts question marks (<quote><literal>?</literal></quote>) as
              placeholders for the input values, not <quote><literal>:a</literal></quote>,
              <quote><literal>:MyParam</literal></quote> etc., or literal values. Client software
              may support the <quote><literal>:xxx</literal></quote> form though, which it will
              preprocess before sending it to the server.</para>
            </listitem>
            <listitem>
              <para>If the block has output parameters, you <emphasis>must</emphasis> use
              <database>SUSPEND</database> or nothing will be returned.</para>
            </listitem>
            <listitem>
              <para>Output is always returned in the form of a result set, just as with a
              <database>SELECT</database> statement. You can't use
              <database>RETURNING_VALUES</database> or execute the block <database>INTO</database>
              some variables, even if there's only one result row.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a stored procedure. In Firebird 1.0.x as well as in InterBase, any input
        parameters for the SP must be supplied as literals, host language variables (in ESQL) or
        local variables (in PSQL). In Firebird 1.5 and above, input parameters may also be
        (compound) expressions, except in static ESQL.</para>
      </formalpara>
      <!--Calling SP's with SELECT already allowed compound expressions as parameters in IB and Fb1.-->
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXECUTE PROCEDURE <replaceable>procname</replaceable>
   [TRANSACTION <replaceable>transaction</replaceable>]
   [<replaceable>&lt;in_item&gt;</replaceable> [, <replaceable>&lt;in_item&gt;</replaceable> ...]]
   [RETURNING_VALUES <replaceable>&lt;out_item&gt;</replaceable> [, <replaceable>&lt;out_item&gt;</replaceable> ...]]

<replaceable>&lt;in_item&gt;</replaceable>   ::=  <replaceable>&lt;inparam&gt;</replaceable> [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;out_item&gt;</replaceable>  ::=  <replaceable>&lt;outvar&gt;</replaceable>  [<replaceable>&lt;nullind&gt;</replaceable>]
<replaceable>&lt;inparam&gt;</replaceable>   ::=  an expression evaluating to the declared parameter type
<replaceable>&lt;outvar&gt;</replaceable>    ::=  a host language or PSQL variable to receive the return value
<replaceable>&lt;nullind&gt;</replaceable>   ::=  [INDICATOR]:<replaceable>host_lang_intvar</replaceable></programlisting>
            <note>
              <title>Notes</title>
              <itemizedlist>
                <listitem>
                  <para><database>TRANSACTION</database> clauses are not supported in PSQL.</para>
                  <!--And in DSQL they are? That would surprise me. Find out!-->
                </listitem>
                <listitem>
                  <para>Expression parameters are not supported in static ESQL, and not in Firebird
                  versions below 1.5.</para>
                </listitem>
                <listitem>
                  <para><constant>NULL</constant> indicators are only valid in ESQL code. They must
                  be host language variables of type integer.</para>
                </listitem>
                <listitem>
                  <para>In ESQL, variable names used as parameters or outvars must be preceded by a
                  colon (<quote>:</quote>). In PSQL the colon is generally optional, but forbidden
                  for the trigger context variables <database>OLD</database> and
                  <database>NEW</database>.</para>
                  <!--When called with SELECT, the colon must always be present if the parameter is a variable (except OLD/NEW).
(Does this go for inparms as well as INTO outparms?)-->
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>In PSQL (with optional colons):</para>
            <programlisting>execute procedure MakeFullName
  :FirstName, :MiddleName, :LastName
  returning_values :FullName;</programlisting>
            <para>The same call in ESQL (with obligatory colons):</para>
            <programlisting>exec sql
  execute procedure MakeFullName
    :FirstName, :MiddleName, :LastName
    returning_values :FullName;</programlisting>
            <para>...and in Firebird's command-line utility <application>isql (with literal
            parameters)</application>:</para>
            <programlisting>execute procedure MakeFullName
  'J', 'Edgar', 'Hoover';</programlisting>
            <para><emphasis role="bold">Note:</emphasis> In isql, don't use
            <database>RETURNING_VALUES</database>. Any output values are shown automatically.</para>
            <para>Finally, a PSQL example with expression parameters, only possible in Firebird 1.5
            and up:</para>
            <programlisting>execute procedure MakeFullName
  'Mr./Mrs. ' || FirstName, MiddleName, upper(LastName)
  returning_values FullName;</programlisting>
          </blockquote></para>
      </formalpara>
      <!--1.5 Release Notes say:

  Dmitry Yemanov
  Calls to EXECUTE PROCEDURE ProcName(<Argument-list>) and SELECT <Output-list> FROM
  ProcName(<Argument-list>) can now accept local variables (in PSQL) and expressions
  (in DSQL and PSQL) as arguments.

However:
- Local variables were already usable as arguments in InterBase.
- With SELECT, even expressions were already allowed as arguments in InterBase.
So the only novelty in Firebird 1.5 is:
- Using expressions as arguments when calling an SP with EXECUTE PROCEDURE.-->
    </section>
    <section id="langrefupd20-insert">
      <title><database>INSERT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Adds rows to a database table, or to one or more tables underlying a view. Field
        values can be given in the <database>VALUES</database> clause (in which case exactly one row
        is inserted) or they can come from a <database>SELECT</database> statement.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>INSERT [TRANSACTION <replaceable>name</replaceable>]
   INTO {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [(<replaceable>&lt;columns&gt;</replaceable>)]
   {VALUES (<replaceable>&lt;values&gt;</replaceable>) [RETURNING <replaceable>&lt;values&gt;</replaceable> [INTO <replaceable>&lt;variables&gt;</replaceable>]]
    | <replaceable>&lt;select_expr&gt;</replaceable>}

<replaceable>&lt;columns&gt;</replaceable>      ::=  <replaceable>colname</replaceable>  [, <replaceable>colname</replaceable>  ...]
<replaceable>&lt;values&gt;</replaceable>       ::=  <replaceable>value</replaceable>    [, <replaceable>value</replaceable>    ...]
<replaceable>&lt;variables&gt;</replaceable>    ::=  :<replaceable>varname</replaceable> [, :<replaceable>varname</replaceable> ...]
<replaceable>&lt;select_expr&gt;</replaceable>  ::=  a <database>SELECT</database> returning a set whose columns fit the target</programlisting>
            <!--":" before varname is NOT optional (in contrast to SELECT INTO?)-->
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>
                <listitem>
                  <para>The <database>RETURNING</database> clause is not available in ESQL.</para>
                </listitem>
                <listitem>
                  <para>The <quote><database>INTO</database>
                  <replaceable>&lt;variables&gt;</replaceable></quote> subclause is only available
                  in PSQL.</para>
                </listitem>
                <listitem>
                  <para>The trigger context variables <database>OLD</database> and
                  <database>NEW</database> must not be preceded by a colon
                  (<quote><literal>:</literal></quote>).</para>
                </listitem>
                <listitem>
                  <para>New in 2.0: No column may appear more than once in the insert list.</para>
                </listitem>
              </itemizedlist>
            </note>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-insert-returning">
        <title><database>RETURNING</database> clause</title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>An <quote><database>INSERT ... VALUES</database></quote> query may optionally
          specify a <database>RETURNING</database> clause in order to return the values that have
          actually been stored. The clause, if present, need not contain all of the insert columns
          and may also contain other columns or expressions. The returned values reflect any changes
          that may have been made in <database>BEFORE</database> tiggers, but not those in
          <database>AFTER</database> triggers.</para>
          <!--Tested in FlameRobin: no result set.
Tested in FirebirdAPI: "request synchronization error", but I also get the result set.
The error seems to occur while trying to fetch a (non-existent) second row.
Try this in isql too!-->
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>insert into Scholars (firstname, lastname, address, phone, email)
  values ('Henry', 'Higgins', '27A Wimpole Street', '3231212', null)
  returning lastname, fullname, id</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Note</title>
          <para>In Firebird 2.0, the <database>RETURNING</database> clause is only supported for
          <quote><database>INSERT ... VALUES</database></quote> queries. With
          <quote><database>INSERT ... SELECT</database></quote> it is rejected, even if it concerns
          a singleton select. This limitation will be lifted in version 2.1.</para>
        </formalpara>
        <!--In 2.0, a malformed query like
  insert into country select 'Hondenland', 'Vlees' from rdb$database returning
is successfully executed. It only works with SELECT; a VALUES insert with a dangling 'returning'
is rejected.
Funny enough, if you add field names after 'returning', the parser rejects the query, choking on
the first word after 'returning'
In 2.1, this type of malformed query is refused by the parser.-->
      </section>
      <section id="langrefupd20-insert-from-union">
        <title><database>UNION</database> allowed in feeding <database>SELECT</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A <database>SELECT</database> query used in an <database>INSERT</database> statement
          may now be a <database>UNION</database>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>insert into Members (number, name)
  select number, name from NewMembers where Accepted = 1
    union
  select number, name from SuspendedMembers where Vindicated = 1</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-select">
      <title><database>SELECT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd20-aggregates">
        <title>Aggregate functions: Extended functionality</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Several types of mixing and nesting aggragate functions are supported since Firebird
          1.5. They will be discussed in the following subsections. To get the complete picture,
          also look at the <database>SELECT</database> :: <database>GROUP BY</database>
          sections.</para>
        </formalpara>
        <section id="langrefupd20-aggregates-mix">
          <title>Mixing aggregate functions from different contexts</title>
          <para>Firebird 1.5 and up allow the use of aggregate functions from different contexts
          inside a single expression.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table name",
  ( select <emphasis role="bold">max(i.rdb$statistics) || ' (' || count(*) || ')'</emphasis>
    from rdb$relation_fields rf
    where rf.rdb$relation_name = r.rdb$relation_name
  ) as "Max. IndexSel (# fields)"
from
  rdb$relations r
  join rdb$indices i on (i.rdb$relation_name = r.rdb$relation_name)
group by r.rdb$relation_name
having max(i.rdb$statistics) &gt; 0
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
          <para>This admittedly rather contrived query shows, in the second column, the maximum
          index selectivity of any index defined on a table, followed by the table's field count
          between parentheses. Of course you would normally display the field count in a separate
          column, or in the column with the table name, but the purpose here is to demonstrate that
          you can combine aggregates from different contexts in a single expression.</para>
          <warning>
            <para>Firebird 1.0 also executes this type of query, but gives the wrong results!</para>
          </warning>
        </section>
        <section id="langrefupd20-aggregates-in-subqueries">
          <title>Aggregate functions and <database>GROUP BY</database> items inside
          subqueries</title>
          <para>Since Firebird 1.5 it is possible to use aggregate functions and/or expressions
          contained in the <database>GROUP BY</database> clause inside a subquery.</para>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>This query returns each table's ID and field count. The subquery refers to
                <literal><systemitem>flds.rdb$relation_name</systemitem></literal>, which is also a
                <database>GROUP BY</database> item:</para>
                <programlisting>select
  flds.rdb$relation_name as "Relation name",
  ( select rels.rdb$relation_id
    from rdb$relations rels
    where rels.rdb$relation_name = <emphasis role="bold">flds.rdb$relation_name</emphasis>
  ) as "ID",
  count(*) as "Fields"
from rdb$relation_fields flds
group by <emphasis role="bold">flds.rdb$relation_name</emphasis></programlisting>
                <para>The next query shows the last field from each table and and its 1-based
                position. It uses the aggregate function <database>MAX</database> in a
                subquery.</para>
                <programlisting>select
  flds.rdb$relation_name as "Table",
  ( select flds2.rdb$field_name
    from rdb$relation_fields flds2
    where
      flds2.rdb$relation_name = flds.rdb$relation_name
      and flds2.rdb$field_position = <emphasis role="bold">max(flds.rdb$field_position)</emphasis>
  ) as "Last field",
  max(flds.rdb$field_position) + 1 as "Last fieldpos"
from rdb$relation_fields flds
group by 1</programlisting>
                <para>The subquery also contains the <database>GROUP BY</database> item
                <systemitem>flds.rdb$relation_name</systemitem>, but that's not immediately obvious
                because in this case the <database>GROUP BY</database> clause uses the column
                number.</para>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-subqueries-in-aggregates">
          <title>Subqueries inside aggregate functions</title>
          <para>Using a singleton subselect inside (or as) an aggregate function argument is
          supported in Firebird 1.5 and up.</para>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select
  r.rdb$relation_name as "Table",
  <emphasis role="bold">sum</emphasis>( (<emphasis role="bold">select</emphasis> count(*)
        from rdb$relation_fields rf
        where rf.rdb$relation_name = r.rdb$relation_name)
  ) as "Ind. x Fields"
from
  rdb$relations r
  join rdb$indices i
    on (i.rdb$relation_name = r.rdb$relation_name)
group by
  r.rdb$relation_name</programlisting>
                <!--NEEDS A MORE MEANINGFUL EXAMPLE!

The above query returns, per table, the number of indices times the number
of fields. Yeah, really useful...

Once the example has been replaced, check if the reference from the next
subsection still applies.-->
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-aggregates-nesting">
          <title>Nesting aggregate function calls</title>
          <para>Firebird 1.5 allows the indirect nesting of aggregate functions, provided that the
          inner function is from a lower SQL context. Direct nesting of aggregate function calls, as
          in <quote><database>COUNT</database>( <database>MAX</database>( price ) )</quote>, is
          still forbidden and punishable by exception.</para>
          <formalpara>
            <title>Example</title>
            <para>See under <link
            linkend="langrefupd20-subqueries-in-aggregates"><citetitle>Subqueries inside aggregate
            functions</citetitle></link>, where <database>COUNT()</database> is used inside a
            <database>SUM()</database>.</para>
          </formalpara>
          <!--That example will (hopefully) be replaced, so check if the above sentence still holds.-->
        </section>
        <section id="langrefupd20-aggregates-having-orderby">
          <title>Aggregate statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></title>
          <para>Firebird 1.5 and above are stricter than previous versions about what can be
          included in the <database>HAVING</database> and <database>ORDER BY</database> clauses. If,
          in the context of an aggregate statement, an operand in a <database>HAVING</database> or
          <database>ORDER BY</database> item contains a column name,<!--This should probably be: ...contains a column name from the query context (i.e. from the table or join in the FROM clause).-->
          it is only accepted if one of the following is true:</para>
          <itemizedlist>
            <listitem>
              <para>The column name appears in an aggregate function call (e.g. <quote><code>HAVING
              MAX(SALARY) &gt; 10000</code></quote>).</para>
            </listitem>
            <listitem>
              <para>The operand equals or is based upon a non-aggregate column that appears in the
              <database>GROUP BY</database> list (by name or position).</para>
            </listitem>
            <!--This listitem commented out for now, needs research:
  o  The operand equals or is based upon a subquery, whether or not it is also a GROUP BY item.-->
            <!--See also under GROUP BY. Check if it is possible to include a non-aggregated subquery in the HAVING / ORDER BY
if that subquery contains columns not present in the GROUP BY.
And if this is possible, also look what happens if that subquery returns different values within a group.-->
          </itemizedlist>
          <para><quote>Is based upon</quote> means that the operand need not be exactly the same as
          the column name. Suppose there's a non-aggregate column
          <quote><database>STR</database></quote> in the select list. Then it's OK to use
          expressions like <quote><database>UPPER(STR)</database></quote>, <quote><database>STR ||
          '!'</database></quote> or <quote><database>SUBSTRING(STR FROM 4 FOR 2)</database></quote>
          in the <database>HAVING</database> clause – even if these expressions don't appear as such
          in the <database>SELECT</database> or <database>GROUP BY</database> list.</para>
          <!--If and when the subquery thing gets mentioned again, the above para must also be changed: ("...as the column name or subquery." etc.)-->
        </section>
      </section>
      <!--1.5 Rlsnotes say:
  HAVING - The having clause only allows aggregate functions or valid expressions that are
           part of the GROUP BY clause. Previously it was allowed to use columns that were
           not part of the GROUP BY clause and to use non-valid expressions.
This is at least partially wrong. E.g. "HAVING 'a' <> 'b'" is accepted w/o problem.
Also, in a query with aggregate columns and normal columns and a subquery column, where the
subquery column is neither aggregate nor in the GROUP BY list, I can still use that subquery
in the HAVING clause.
However, if I refer to a column not used in the query, I get this error indeed:
  Invalid expression in the HAVING clause (neither an aggregate function nor a part of
  the GROUP BY clause)
But then, if I refer to it within an aggr. in the HAVING, it's OK again.-->
      <!--*******

Maybe the entire GROUP BY thing should become something like this:

Every column that is present - in non-aggregrated form - on the highest (outermost?) level in the context of an aggregated query
(i.e., is a column of the relation(s) in the FROM clause)
*must* be included in the GROUP BY clause.

Question: If such a column is present in a subquery, but with the table alias as defined in the outermost query context,
must it go in the GROUP BY? I think yes, but test!
Question 2: As above, but this time with its own alias, belonging to the subselect?
I think it doesn't have to go in the GROUP BY then, but test.
Question 3: If a relation does not have an alias in the uppermost FROM, and it is used in a subselect
also without an alias, does that mean they have the same context? I hope not...-->
      <section id="langrefupd20-select-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>select NameBlob from MyTable
  where NameBlob collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-derived-tables">
        <title>Derived tables (<quote><database>SELECT FROM SELECT</database></quote>)</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A derived table is the result set of a <database>SELECT</database> query, used in an
          outer <database>SELECT</database> as if it were an ordinary table. In other words, it is a
          subquery in the <database>FROM</database> clause.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>(<replaceable>select-query</replaceable>)
   [[AS] <replaceable>derived-table-alias</replaceable>]
   [(<replaceable>&lt;derived-column-aliases&gt;</replaceable>)]

<replaceable>&lt;derived-column-aliases&gt;</replaceable>  :=  <replaceable>column-alias</replaceable> [, <replaceable>column-alias</replaceable> ...]</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The derived table in the query below (shown in boldface) contains all the
              relation names in the database followed by their field count. The outer
              <database>SELECT</database> produces, for each existing field count, the number of
              relations having that field count.</para>
              <programlisting>select fieldcount,
       count(relation) as num_tables
from   <emphasis role="bold">(select r.rdb$relation_name as relation,
               count(*) as fieldcount
        from   rdb$relations r
               join rdb$relation_fields rf
                 on rf.rdb$relation_name = r.rdb$relation_name
        group by relation)</emphasis>
group by fieldcount</programlisting>
              <para>A trivial example demonstrating the use of a derived table alias and column
              aliases list (both are optional):</para>
              <programlisting>select dbinfo.descr,
       dbinfo.def_charset
from   <emphasis role="bold">(select * from rdb$database) dbinfo
         (descr, rel_id, sec_class, def_charset)</emphasis></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>Derived tables can be nested.</para>
              </listitem>
              <listitem>
                <para>Derived tables can be unions and can be used in unions. They can contain
                aggregate functions, subselects and joins, and can themselves be used in aggregate
                functions, subselects and joins. They can also be or contain queries on selectable
                stored procedures. They can have <database>WHERE</database>, <database>ORDER
                BY</database> and <database>GROUP BY</database> clauses, <database>FIRST</database>,
                <database>SKIP</database> or <database>ROWS</database> directives, etc. etc.</para>
              </listitem>
              <listitem>
                <para>Every column in a derived table <emphasis>must</emphasis> have a name. If it
                doesn't have one by nature (e.g. because it's a constant) it must either be given an
                alias in the usual way, or a column aliases list must be added to the derived table
                specification.</para>
              </listitem>
              <listitem>
                <para>The column aliases list is optional, but if it is used it must be complete.
                That is: it must contain an alias for every column in the derived table.</para>
              </listitem>
              <listitem>
                <para>The optimizer can handle a derived table very efficiently. However, if the
                derived table is involved in an inner join and contains a subquery, then no join
                order can be made.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
      <section id="langrefupd20-first-skip">
        <title><database>FIRST</database> and <database>SKIP</database></title>
        <!--Seem unavailable in ESQL. But Dmitry writes to me: "Available since v1.0, I believe."
Checked again in gpre source (using SKIP search), and it really really really isn't there. So:-->
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.0</para>
        </formalpara>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Better alternative</title>
          <para><link linkend="langrefupd20-select-rows"><database>ROWS</database></link></para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>FIRST</database> limits the output of a query to the first so-many rows.
          <database>SKIP</database> will suppress the given number of rows before starting to return
          output.<tip>
              <para>In Firebird 2.0 and up, use the SQL-compliant <link
              linkend="langrefupd20-select-rows"><database>ROWS</database></link> syntax
              instead.</para>
            </tip></para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT [FIRST (<replaceable>&lt;int-expr&gt;</replaceable>)] [SKIP (<replaceable>&lt;int-expr&gt;</replaceable>)] <replaceable>&lt;columns&gt;</replaceable> FROM ...

<replaceable>&lt;int-expr&gt;</replaceable>  ::=  Any expression evaluating to an integer.
<replaceable>&lt;columns&gt;</replaceable>   ::=  The usual output column specifications.</programlisting>
              <note>
                <para>If <replaceable>&lt;int-expr&gt;</replaceable> is an integer literal or a
                query parameter, the <quote><literal>()</literal></quote> may be omitted. Subselects
                on the other hand require an extra pair of parentheses.</para>
              </note>
            </blockquote></para>
        </formalpara>
        <para><database>FIRST</database> and <database>SKIP</database> are both optional. When used
        together as in <quote><database>FIRST</database> <replaceable>m</replaceable>
        <database>SKIP</database> <replaceable>n</replaceable></quote>, the
        <replaceable>n</replaceable> topmost rows of the output set are discarded and the first
        <replaceable>m</replaceable> rows of the remainder are returned.</para>
        <para><database>SKIP</database> 0 is allowed, but of course rather pointless.
        <database>FIRST</database> 0 is allowed in version 1.5 and up, where it returns an empty
        set. In 1.0.x, <database>FIRST</database> 0 causes an error. Negative
        <database>SKIP</database> and/or <database>FIRST</database> values always result in an
        error.</para>
        <para>If a <database>SKIP</database> lands past the end of the dataset, an empty set is
        returned. If the number of rows in the dataset (or the remainder after a
        <database>SKIP</database>) is less than the value given after <database>FIRST</database>,
        that smaller number of rows is returned. These are valid results, not error
        situations.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>The following query will return the first 10 names from the People table:</para>
              <programlisting>select first 10 id, name from People
  order by name asc</programlisting>
              <para>The following query will return everything <emphasis>but</emphasis> the first 10
              names:</para>
              <programlisting>select skip 10 id, name from People
  order by name asc</programlisting>
              <para>And this one returns the last 10 rows. Notice the double parentheses:</para>
              <programlisting>select skip ((select count(*) - 10 from People))
  id, name from People
  order by name asc</programlisting>
              <para>This query returns rows 81–100 of the People table:</para>
              <programlisting>select first 20 skip 80 id, name from People
  order by name asc</programlisting>
            </blockquote></para>
        </formalpara>
        <caution>
          <title>Two Gotchas with <database>FIRST</database> in subselects</title>
          <itemizedlist>
            <listitem>
              <para>This:</para>
              <blockquote>
                <programlisting>delete from MyTable where ID in (select first 10 ID from MyTable)</programlisting>
              </blockquote>
              <para>will delete all of the rows in the table. Ouch! The sub-select is evaluating
              each 10 candidate rows for deletion, deleting them, slipping forward 10 more... ad
              infinitum, until there are no rows left. Beware! Or better: use the
              <database>ROWS</database> syntax, available since Firebird 2.0.</para>
            </listitem>
            <listitem>
              <para>Queries like:</para>
              <blockquote>
                <programlisting>...where F1 in (select first 5 F2 from Table2 order by 1 desc)</programlisting>
              </blockquote>
              <para>won't work as expected, because the optimization performed by the engine
              transforms the <database>IN</database> predicate to the correlated
              <database>EXISTS</database> predicate shown below. It's obvious that in this case
              <database>FIRST</database> <replaceable>N</replaceable> doesn't make any sense:</para>
              <blockquote>
                <programlisting>...where exists
   ( select first 5 F2 from Table2
     where Table2.F2 = Table1.F1
     order by 1 desc )</programlisting>
              </blockquote>
              <!--This still so with ROWS? BTW, I think this is a grave error in the optimizer!-->
            </listitem>
          </itemizedlist>
        </caution>
      </section>
      <section id="langrefupd20-groupby">
        <title><database>GROUP BY</database></title>
        <formalpara>
          <title>Description</title>
          <para><database>GROUP BY</database> merges rows that have the same combination of values
          and/or <constant>NULL</constant>s in the item list into a single row. Any aggregate
          functions in the select list are applied to each group individually instead of to the
          dataset as a whole.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   GROUP BY <replaceable>&lt;item&gt;</replaceable> [, <replaceable>&lt;item&gt;</replaceable> ...]
   ...

<replaceable>&lt;item&gt;</replaceable>  ::=  <replaceable>column-name</replaceable> [COLLATE <replaceable>collation-name</replaceable>]
               | <replaceable>column-alias</replaceable>
               | <replaceable>column-position</replaceable>
               | <replaceable>expression</replaceable></programlisting>
              <itemizedlist>
                <listitem>
                  <para>Only non-negative integer <emphasis>literals</emphasis> will be interpreted
                  as column positions. If they are outside the range from 1 to the number of
                  columns, an error is raised. Integer values resulting from expressions or
                  parameter substitutions are simply invariables and will be used as such in the
                  grouping. They will have no effect though, as their value is the same for each
                  row.</para>
                </listitem>
                <listitem>
                  <para>A <database>GROUP BY</database> item cannot be a reference to an aggregate
                  function (including one that is buried inside an expression) from the same
                  context.</para>
                </listitem>
                <listitem>
                  <para>The select list may not contain expressions that can have different values
                  within a group. To avoid this, the rule of thumb is to include each non-aggregate
                  item from the select list in the <database>GROUP BY</database> list (whether by
                  copying, alias or position).</para>
                  <!--Some exceptions and variations are possible, but they could be discussed
later in notes. For instance, a GROUP BY item may be 'narrower' than the
corresponding select item (SELECT upper(ColA) GROUP BY ColA is fine, but
the reverse isn't). Also think of certain subselects, and items that don't
refer to the current context.-->
                </listitem>
              </itemizedlist>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Note</title>
          <para>If you group by a column position, the expression at that position is copied
          internally from the select list. If it concerns a subquery, that subquery will be executed
          at least twice.<!--I suppose the same goes for grouping by aliases?--></para>
        </formalpara>
        <section id="langrefupd20-groupby-extensions">
          <title>Grouping by alias, position and expressions</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0, 1.5, 2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In addition to column names, Firebird 2 allows column aliases, column positions
            and arbitrary valid expressions as <database>GROUP BY</database> items.</para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>These three queries all achieve the same result:</para>
                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by len_name</programlisting>
                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by 1</programlisting>
                <programlisting>select strlen(lastname) as len_name, count(*)
  from people
  group by strlen(lastname)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>History</title>
            <para>Grouping by UDF results was added in Firebird 1. Grouping by column positions,
            <database>CASE</database> outcomes and a limited number of internal functions in
            Firebird 1.5. Firebird 2 added column aliases and expressions in general as valid
            <database>GROUP BY</database> items (<quote>expressions in general</quote> absorbing the
            UDF, <database>CASE</database> and internal functions lot).</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd20-having-stricter">
        <title><database>HAVING</database>: Stricter rules</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>See <link linkend="langrefupd20-aggregates-having-orderby"><citetitle>Aggregate
          statements: Stricter <database>HAVING</database> and <database>ORDER
          BY</database></citetitle></link>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-join">
        <title><database>JOIN</database></title>
        <section id="langrefupd20-join-amb-fields">
          <title>Ambiguous field names rejected</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>InterBase 6 accepts and executes statements like the one below, which refers to an
            unqualified column name even though that name exists in both tables participating in the
            <database>JOIN</database>:</para>
          </formalpara>
          <blockquote>
            <programlisting>select buses.name, garages.name
  from buses join garages on buses.garage_id = garage.id
  where name = 'Phideaux III'</programlisting>
          </blockquote>
          <para>The results of such a query are unpredictable. Firebird Dialect 3 returns an error
          if there are ambiguous field names in <database>JOIN</database> statements. Dialect 1
          gives a warning but will execute the query anyway.</para>
        </section>
        <section id="langrefupd20-join-crossjoin">
          <title><database>CROSS JOIN</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.0 supports <database>CROSS JOIN</database>, which performs a full set
            multiplication on the tables involved. Previously you had to achieve this by joining on
            a tautology (a condition that is always true) or by using the comma syntax, now
            deprecated.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>SELECT ...
   FROM <replaceable>table1</replaceable> CROSS JOIN <replaceable>table2</replaceable>
   [WHERE ...]
   ...</programlisting>
                <para><emphasis role="bold">Note:</emphasis> If you use <database>CROSS
                JOIN</database>, you can't use <database>ON</database>.</para>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select * from Men cross join Women
order by Men.age, Women.age

-- old syntax:
--   select * from Men join Women on 1 = 1
--   order by Men.age, Women.age

-- comma syntax:
--   select * from Men, Women
--   order by Men.age, Women.age</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd20-orderby">
        <title><database>ORDER BY</database></title>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM ...
   ...
   ORDER BY <replaceable>&lt;ordering-item&gt;</replaceable> [, <replaceable>&lt;ordering-item&gt;</replaceable> ...]

<replaceable>&lt;ordering-item&gt;</replaceable>  ::=  {<replaceable>col-name</replaceable> | <replaceable>col-alias</replaceable> | <replaceable>col-position</replaceable> | <replaceable>expression</replaceable>}
                         [COLLATE <replaceable>collation-name</replaceable>]
                         [ASC[ENDING] | DESC[ENDING]]
                         [NULLS {FIRST|LAST}]</programlisting>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd20-orderby-alias">
          <title>Order by colum alias</title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 2.0 and above support ordering by column alias.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select rdb$character_set_id as charset_id,
       rdb$collation_id as coll_id,
       rdb$collation_name as name
from rdb$collations
order by charset_id, coll_id</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-order-star-by-colpos">
          <title>Ordering by column position causes * expansion</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>If you order by column position in a <quote><database>SELECT</database> *</quote>
            query, the engine will now expand the * to determine the sort column(s).</para>
          </formalpara>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <para>The following wasn't possible in pre-2.0 versions:</para>
                <programlisting>select * from rdb$collations
order by 3, 2</programlisting>
                <para>The following would sort the output set on <literal>Films.Director</literal>
                in previous versions. In Firebird 2 and up, it will sort on the second column of
                <literal>Books</literal>:</para>
                <programlisting>select Books.*, Films.Director from Books, Films
order by 2</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-orderby-expr">
          <title>Ordering by expressions</title>
          <formalpara>
            <title>Added in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 1.5 introduced the possibility to use expressions as ordering items.
            Please note that expressions consisting of a single non-negative whole number will be
            interpreted as column positions and cause an exception if they're not in the range from
            1 to the number of columns.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select x, y, note from Pairs
order by x+y desc</programlisting>
              </blockquote></para>
          </formalpara>
          <note>
            <para>The number of function or procedure invocations resulting from a sort based on a
            UDF or stored procedure is unpredictable, regardless whether the ordering is specified
            by the expression itself or by the column position number.</para>
          </note>
          <formalpara>
            <title>Notes</title>
            <para><itemizedlist>
                <listitem>
                  <para>The number of function or procedure invocations resulting from a sort based
                  on a UDF or stored procedure is unpredictable, regardless whether the ordering is
                  specified by the expression itself or by the column position number.</para>
                </listitem>
                <listitem>
                  <para>Only non-negative whole number <emphasis>literals</emphasis> are interpreted
                  as column positions. A whole number resulting from an expression evaluation or
                  parameter substitution is seen as an integer invariable and will lead to a dummy
                  sort, since its value is the same for each row.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
          <!--Rlsnotes 1.5 say:

  An ordering clause for sorting the output of a union query may use only
  ordinal (degree) numbers to refer to the ordering columns.

This is correct, but:
a) afaik was already the case in IB6 and Fb1;
b) has nothing to do with the expressions and nulls placement bits.
So better not include it here but do include it in the full Firebird SQL ref.-->
          <!--Rlsnotes 1.5 say (by Nickolay):

  The results of a sort based on values returned from a UDF or a stored procedure
  will be unpredictable if the values returned cannot be used to determine a logical
  sorting sequence.

That as such stands to reason, but which datatype(s) has/have no defined ordering?
In other words: can this happen in practice? Maybe with ARRAYs?-->
        </section>
        <section id="langrefupd20-orderby-nulls">
          <title><constant>NULL</constant>s placement</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5, 2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firebird 1.5 has introduced the per-column <database>NULLS FIRST</database> and
            <database>NULLS LAST</database> directives to specify where <constant>NULL</constant>s
            appear in the sorted column. Firebird 2.0 has changed the default placement of
            <constant>NULL</constant>s.</para>
          </formalpara>
          <para>Unless overridden by <database>NULLS FIRST</database> or <database>NULLS
          LAST</database>, <constant>NULL</constant>s in ordered columns are placed as
          follows:</para>
          <itemizedlist>
            <listitem>
              <para>In Firebird 1.0 and 1.5: at the end of the sort, regardless whether the order is
              ascending or descending.</para>
            </listitem>
            <listitem>
              <para>In Firebird 2.0 and up: at the <emphasis>start</emphasis> of ascending orderings
              and at the <emphasis>end</emphasis> of descending orderings.</para>
            </listitem>
          </itemizedlist>
          <para>See also the table below for an overview of the different versions.</para>
          <table id="langrefupd20-tbl-null-placement">
            <title><constant>NULL</constant>s placement in ordered columns</title>
            <tgroup cols="4">
              <colspec colname="colStatement" colwidth="2*" />
              <colspec colname="colPlac10" colwidth="1*" />
              <colspec colname="colPlac15" colwidth="1*" />
              <colspec colname="colPlac2" colwidth="1*" />
              <thead>
                <row valign="top">
                  <entry morerows="1">Ordering</entry>
                  <entry align="center" nameend="colPlac2"
                  namest="colPlac10"><constant>NULL</constant>s placement</entry>
                </row>
                <row valign="top">
                  <entry align="center">Firebird 1</entry>
                  <entry align="center">Firebird 1.5</entry>
                  <entry align="center">Firebird 2</entry>
                </row>
              </thead>
              <tbody>
                <row valign="top">
                  <entry>order by Field [asc]</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                  <entry>top</entry>
                </row>
                <row valign="top">
                  <entry>order by Field desc</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                </row>
                <row valign="top">
                  <entry>order by Field [asc | desc] nulls first</entry>
                  <entry>—</entry>
                  <entry>top</entry>
                  <entry>top</entry>
                </row>
                <row valign="top">
                  <entry>order by Field [asc | desc] nulls last</entry>
                  <entry>—</entry>
                  <entry>bottom</entry>
                  <entry>bottom</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <note>
            <title>Notes</title>
            <itemizedlist>
              <listitem>
                <para>Pre-existing databases may need a backup-restore cycle before they show the
                correct <constant>NULL</constant> ordering behaviour under Firebird 2.0 and
                up.</para>
                <!--CHECK! Is this always true, or only when the column is indexed?-->
              </listitem>
              <listitem>
                <para>No index will be used on columns for which a non-default
                <constant>NULLS</constant> placement is chosen. In Firebird 1.5, that is the case
                with <database>NULLS FIRST</database>. In 2.0 and higher, with <database>NULLS
                LAST</database> on ascending and <database>NULLS FIRST</database> on descending
                sorts.</para>
              </listitem>
            </itemizedlist>
          </note>
          <formalpara>
            <title>Examples</title>
            <para><blockquote>
                <programlisting>select * from msg
  order by process_time desc nulls first</programlisting>
                <programlisting>select * from document
  order by strlen(description) desc
  rows 10</programlisting>
                <programlisting>select doc_number, doc_date from payorder
union all
select doc_number, doc_date from budgorder
  order by 2 desc nulls last, 1 asc nulls first</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-orderby-stricter">
          <title>Stricter ordering rules with aggregate statements</title>
          <formalpara>
            <title>Changed in</title>
            <para>1.5</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>See <link linkend="langrefupd20-aggregates-having-orderby"><citetitle>Aggregate
            statements: Stricter <database>HAVING</database> and <database>ORDER
            BY</database></citetitle></link>.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd20-select-plan">
        <title><database>PLAN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL, PSQL</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Specifies a user plan for the data retrieval, overriding the plan that the optimizer
          would have generated automatically.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <para><!--This is (a modified view of) the syntax as given in the IB6 LangRef, with the
Fb 2.0 extension of optionally providing an INDEX list after ORDER:--><programlisting>PLAN <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;plan_expr&gt;</replaceable>   ::=  [JOIN | [SORT] [MERGE]] (<replaceable>&lt;plan_item&gt;</replaceable> [, <replaceable>&lt;plan_item&gt;</replaceable> ...])

<replaceable>&lt;plan_item&gt;</replaceable>   ::=  <replaceable>&lt;basic_item&gt;</replaceable> | <replaceable>&lt;plan_expr&gt;</replaceable>

<replaceable>&lt;basic_item&gt;</replaceable>  ::=  {<replaceable>table</replaceable> | <replaceable>alias</replaceable>}
                   {NATURAL
                    | INDEX (<replaceable>&lt;indexlist&gt;</replaceable>))
                    | ORDER <replaceable>index</replaceable> [INDEX (<replaceable>&lt;indexlist&gt;</replaceable>)]}

<replaceable>&lt;indexlist&gt;</replaceable>   ::=  <replaceable>index</replaceable> [, <replaceable>index</replaceable> ...]</programlisting><!--The syntax given in the 2.0 Rlsnotes differs considerably, but contains at
least some errors. However, the same is probably true for the above.
Points to investigate wrt syntax in Rlsnotes 2.0:
- Must MERGE always take place on *exactly* 2 streams?
- Must MERGE always take place on explicitly SORTed streams?

Points to improve in the syntax above (either in the syntax itself, or
in notes):
- With JOIN and MERGE, the number of plan_items must be at least 2.--></para>
            </blockquote></para>
        </formalpara>
        <section id="langrefupd20-select-plan-improved">
          <title>Handling of user <database>PLAN</database>s improved</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>Firbird 2 has implemented the following improvements in the handling of
            user-specified <database>PLAN</database>s:<itemizedlist>
                <listitem>
                  <para>Plan fragments are propagated to nested levels of joins, enabling manual
                  optimization of complex outer joins.</para>
                </listitem>
                <listitem>
                  <para>User-supplied plans will be checked for correctness in outer joins.</para>
                </listitem>
                <listitem>
                  <para>Short-circuit optimization for user-supplied plans has been added.</para>
                </listitem>
                <listitem>
                  <para>A user-specified access path can be supplied for any
                  <database>SELECT</database>-based statement or clause.</para>
                </listitem>
              </itemizedlist></para>
          </formalpara>
        </section>
        <section id="langrefupd20-select-plan-order-index">
          <title><database>ORDER</database> with <database>INDEX</database></title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>A single plan item can now contain both an <database>ORDER</database> and an
            <database>INDEX</database> directive (in that order).</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>plan (MyTable order ix_myfield index (ix_this, ix_that))</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-select-plan-alltables">
          <title><database>PLAN</database> must include all tables</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>In Firebird 2 and up, a <database>PLAN</database> clause must handle all the
            tables in the query. Previous versions sometimes accepted incomplete plans, but this is
            no longer the case.</para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd20-select-alias-use">
        <title>Relation alias makes real name unavailable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you give a table or view an alias in a Firebird 2.0 or above statement, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that relation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Correct usage:</para>
              <programlisting>select pears from Fruit</programlisting>
              <programlisting>select Fruit.pears from Fruit</programlisting>
              <programlisting>select pears from Fruit F</programlisting>
              <programlisting>select F.pears from Fruit F</programlisting>
              <para>No longer possible:</para>
              <programlisting>select Fruit.pears from Fruit F</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-select-rows">
        <title><database>ROWS</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Limits the amount of rows returned by the <database>SELECT</database> statement to a
          specified number or range.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <para>With a single <database>SELECT</database>:</para>
              <programlisting>SELECT <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]
   ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;columns&gt;</replaceable>  ::=  The usual output column specifications.
<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>   ::=  Any expression evaluating to an integer.</programlisting>
              <para>With a <database>UNION</database>:</para>
              <programlisting>SELECT [FIRST <replaceable>p</replaceable>] [SKIP <replaceable>q</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]

UNION [ALL | DISTINCT]

SELECT [FIRST <replaceable>r</replaceable>] [SKIP <replaceable>s</replaceable>] <replaceable>&lt;columns&gt;</replaceable> FROM ...
   [WHERE ...]
   [ORDER BY ...]

ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]</programlisting>
            </blockquote></para>
        </formalpara>
        <para>With a single argument <replaceable>m</replaceable>, the first
        <replaceable>m</replaceable> rows of the dataset are returned.</para>
        <para>Points to note:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> = 0, an empty set is returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>
        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, rows
        <replaceable>m</replaceable> to <replaceable>n</replaceable> of the dataset are returned,
        inclusively. Row numbers are 1-based.</para>
        <para>Points to note when using two arguments:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, an
            empty set is returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, an empty set is
            returned.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>
        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
        <para>The SQL-compliant <database>ROWS</database> syntax obviates the need for <link
        linkend="langrefupd20-first-skip"><database>FIRST</database> and
        <database>SKIP</database></link>, except in one case: a <database>SKIP</database> without
        <database>FIRST</database>, which returns the entire remainder of the set after skipping a
        given number of rows. (You can often <quote>fake it</quote> though, by supplying a second
        argument that you know to be bigger than the number of rows in the set.)</para>
        <para>You cannot use <database>ROWS</database> together with <database>FIRST</database>
        and/or <database>SKIP</database> in a single <database>SELECT</database> statement, but is
        it valid to use one form in the top-level statement and the other in subselects, or to use
        the two syntaxes in different subselects.</para>
        <para>When used with a <database>UNION</database>, the <database>ROWS</database> subclause
        applies to the UNION as a whole and must be placed after the last
        <database>SELECT</database>. If you want to limit the output of one or more individual
        <database>SELECT</database>s within the <database>UNION</database>, you have two options:
        either use <database>FIRST</database>/<database>SKIP</database> on those
        <database>SELECT</database> statements, or convert them to <link
        linkend="langrefupd20-derived-tables">derived tables</link> with <database>ROWS</database>
        clauses.</para>
        <!--Dmitry's SELECT syntax in the 2.0 Rlsnotes is incorrect here, as it states that you can use ROWS on every SELECT in a UNION. Let him know!-->
        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd20-update-rows"><database>UPDATE</database></link> and <link
        linkend="langrefupd20-delete-rows"><database>DELETE</database></link> statements.</para>
        <!--SKIP and FIRST can be used - and could already in 1.5 - with UNIONs and in subqueries, even though the 2.0 RlsNotes seem to suggest otherwise.-->
      </section>
      <section id="langrefupd20-union">
        <title><database>UNION</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL, PSQL</para>
        </formalpara>
        <section id="langrefupd20-union-in-subqueries">
          <title><database>UNION</database>s in subqueries</title>
          <formalpara>
            <title>Changed in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para><database>UNION</database>s are now allowed in subqueries. This applies not only
            to column-level subqueries in a <database>SELECT</database> list, but also to subqueries
            in <database>ANY</database>|<database>SOME</database>, <database>ALL</database> and
            <database>IN</database> predicates, as well as the optional <database>SELECT</database>
            expression that feeds an <database>INSERT</database>.</para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select name, phone, hourly_rate from clowns
where hourly_rate &lt; all
  (select hourly_rate from jugglers
     union
   select hourly_rate from acrobats)
order by hourly_rate</programlisting>
              </blockquote></para>
          </formalpara>
        </section>
        <section id="langrefupd20-union-distinct">
          <title><database>UNION DISTINCT</database></title>
          <formalpara>
            <title>Added in</title>
            <para>2.0</para>
          </formalpara>
          <formalpara>
            <title>Description</title>
            <para>You can now use the optional <database>DISTINCT</database> keyword when defining a
            <database>UNION</database>. This will show duplicate rows only once instead of every
            time they occur in one of the tables. Since <database>DISTINCT</database>, being the
            opposite of <database>ALL</database>, is the default mode anyway, this doesn't add any
            new functionality.</para>
          </formalpara>
          <formalpara>
            <title>Syntax</title>
            <para><blockquote>
                <programlisting>SELECT (...) FROM (...)
UNION [DISTINCT | ALL]
SELECT (...) FROM (...)</programlisting>
              </blockquote></para>
          </formalpara>
          <formalpara>
            <title>Example</title>
            <para><blockquote>
                <programlisting>select name, phone from translators
  union distinct
select name, phone from proofreaders</programlisting>
                <para>Translators who also work as proofreaders (a not uncommon combination) will
                show up only once in the result set, provided their phone number is the same in both
                tables. The same result would have been obtained without
                <database>DISTINCT</database>. With <database>ALL</database>, they would appear
                twice.</para>
              </blockquote></para>
          </formalpara>
        </section>
      </section>
      <section id="langrefupd20-with-lock">
        <title><database>WITH LOCK</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no support found in sources-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description:</title>
          <para><database>WITH LOCK</database> provides a limited explicit pessimistic locking
          capability for cautious use in conditions where the affected row set is:<orderedlist
              numeration="loweralpha" spacing="compact">
              <listitem>
                <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
              </listitem>
              <listitem>
                <para>precisely controlled by the application code.</para>
              </listitem>
            </orderedlist></para>
        </formalpara>
        <caution>
          <title>This is for experts only!</title>
          <para>The need for a pessimistic lock in Firebird is very rare indeed and should be well
          understood before use of this extension is considered.</para>
          <para>It is essential to understand the effects of transaction isolation and other
          transaction attributes before attempting to implement explicit locking in your
          application.</para>
        </caution>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   WITH LOCK</programlisting>
            </blockquote></para>
        </formalpara>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>
        <para><database>WITH LOCK</database> can only be used with a top-level, single-table
        <database>SELECT</database> statement. It is <emphasis>not</emphasis> available:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>in a subquery specification;</para>
          </listitem>
          <listitem>
            <para>for joined sets;</para>
          </listitem>
          <listitem>
            <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
            clause or any other aggregating operation;</para>
          </listitem>
          <listitem>
            <para>with a view;</para>
          </listitem>
          <listitem>
            <para>with the output of a selectable stored procedure;</para>
          </listitem>
          <listitem>
            <para>with an external table.</para>
          </listitem>
        </itemizedlist>
        <para>A lengthier, more in-depth discussion of <quote><database>SELECT ... WITH
        LOCK</database></quote> is included in the <link
        linkend="langrefupd20-notes-withlock">Notes</link>. It is a must-read for everybody who
        considers using this feature.</para>
      </section>
    </section>
    <section id="langrefupd20-update">
      <title><database>UPDATE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Changes values in a table (or in one or more tables underlying a view). The columns
        affected are specified in the <database>SET</database> clause; the rows affected may be
        limited by the <database>WHERE</database> and <database>ROWS</database> clauses.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>UPDATE [TRANSACTION <replaceable>name</replaceable>] {<replaceable>tablename</replaceable> | <replaceable>viewname</replaceable>} [[AS] <replaceable>alias</replaceable>]
   SET <replaceable>col</replaceable> = <replaceable>newval</replaceable> [, <replaceable>col</replaceable> = <replaceable>newval</replaceable> ...]
   [WHERE {<replaceable>search-conditions</replaceable> | CURRENT OF <replaceable>cursorname</replaceable>}]
   [PLAN <replaceable>plan_items</replaceable>]
   [ORDER BY <replaceable>sort_items</replaceable>]
   [ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            <note>
              <title>Restrictions</title>
              <itemizedlist spacing="compact">
                <listitem>
                  <para>The <database>TRANSACTION</database> directive is only available in
                  ESQL.</para>
                </listitem>
                <listitem>
                  <para>In a pure DSQL session, <database>WHERE CURRENT OF</database> isn't of much
                  use, since there exists no DSQL statement to create a cursor.</para>
                </listitem>
                <listitem>
                  <para>The <database>PLAN</database>, <database>ORDER BY</database> and
                  <database>ROWS</database> clauses are not available in ESQL.</para>
                </listitem>
                <listitem>
                  <para>New in 2.0: No column may be <database>SET</database> more than once in the
                  same <database>UPDATE</database> statement.</para>
                </listitem>
              </itemizedlist>
            </note>
            <!--Are only loose plan_items allowed, or also JOIN, SORT, MERGE ?-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-update-collate">
        <title><database>COLLATE</database> subclause for text <database>BLOB</database>
        columns</title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>COLLATE</database> subclauses are now also supported for text
          <database>BLOB</database>s.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>update MyTable
  set NameBlobSp = 'Juan'
  where NameBlobBr collate pt_br = 'João'</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-update-orderby">
        <title><database>ORDER BY</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>UPDATE</database> now allows an <database>ORDER BY</database> clause. This
          only makes sense in combination with <database>ROWS</database>, but is also valid without
          it.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-update-plan">
        <title><database>PLAN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para><database>UPDATE</database> now allows a <database>PLAN</database> clause, so users
          can optimize the operation manually.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-update-alias-use">
        <title>Relation alias makes real name unavailable</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>If you give a table or view an alias in a Firebird 2.0 or above statement, you
          <emphasis>must</emphasis> use the alias, not the table name, if you want to qualify fields
          from that relation.</para>
        </formalpara>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <para>Correct usage:</para>
              <programlisting>update Fruit set soort = 'pisang' where ...</programlisting>
              <programlisting>update Fruit set Fruit.soort = 'pisang' where ...</programlisting>
              <programlisting>update Fruit F set soort = 'pisang' where ...</programlisting>
              <programlisting>update Fruit F set F.soort = 'pisang' where ...</programlisting>
              <para>No longer possible:</para>
              <programlisting>update Fruit F set Fruit.soort = 'pisang' where ...</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-update-rows">
        <title><database>ROWS</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, PSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Limits the amount of rows updated to a specified number or range.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROWS <replaceable>&lt;m&gt;</replaceable> [TO <replaceable>&lt;n&gt;</replaceable>]

<replaceable>&lt;m&gt;</replaceable>, <replaceable>&lt;n&gt;</replaceable>  ::=  Any expression evaluating to an integer.</programlisting>
            </blockquote></para>
        </formalpara>
        <para>With a single argument <replaceable>m</replaceable>, the update is limited to the
        first <replaceable>m</replaceable> rows of the dataset defined by the table or view and the
        optional <database>WHERE</database> and <database>ORDER BY</database> clauses.</para>
        <para>Points to note:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, the
            entire set is updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> = 0, no rows are updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 0, an error is raised.</para>
          </listitem>
        </itemizedlist>
        <para>With two arguments <replaceable>m</replaceable> and <replaceable>n</replaceable>, the
        update is limited to rows <replaceable>m</replaceable> to <replaceable>n</replaceable>
        inclusively. Row numbers are 1-based.</para>
        <para>Points to note when using two arguments:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If <replaceable>m</replaceable> &gt; the total number of rows in the dataset, no
            rows are updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> lies within the set but
            <replaceable>n</replaceable> doesn't, the rows from <replaceable>m</replaceable> to the
            end of the set are updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>m</replaceable> &lt; 1 or <replaceable>n</replaceable> &lt; 1, an
            error is raised.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> = <replaceable>m</replaceable>-1, no rows are
            updated.</para>
          </listitem>
          <listitem>
            <para>If <replaceable>n</replaceable> &lt; <replaceable>m</replaceable>-1, an error is
            raised.</para>
          </listitem>
        </itemizedlist>
        <!--Contact Dmitry about the last 2 points: is this as intended? If not, possibly alter text.-->
        <para><database>ROWS</database> can also be used with the <link
        linkend="langrefupd20-select-rows"><database>SELECT</database></link> and <link
        linkend="langrefupd20-delete-rows"><database>DELETE</database></link> statements.</para>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd20-transcontrol">
    <title>Transaction control statements</title>
    <section id="langrefupd20-release-savepoint">
      <title><database>RELEASE SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Deletes a named savepoint, freeing up all the resources it binds.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Unless <database>ONLY</database> is added, all the savepoints created after the named
      savepoint are released as well.</para>
      <para>For a full discussion of savepoints, see <link
      linkend="langrefupd20-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
    </section>
    <section id="langrefupd20-rollback">
      <title><database>ROLLBACK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>ROLLBACK [WORK]
   [TRANSACTION <replaceable>tr_name</replaceable>]
   [RETAIN [SNAPSHOT] | TO [SAVEPOINT] <replaceable>sp_name</replaceable> | RELEASE]</programlisting>
            <itemizedlist>
              <listitem>
                <para>The <database>TRANSACTION</database> clause is only available in ESQL.</para>
              </listitem>
              <listitem>
                <para>The <database>RELEASE</database> clause is only available in ESQL, and is
                discouraged.</para>
              </listitem>
              <listitem>
                <para><database>RETAIN</database> and <database>TO</database> are only available in
                DSQL.</para>
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-rollback-retain">
        <title><database>ROLLBACK RETAIN</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Undoes all the database changes carried out in the transaction without closing it.
          User variables set with <link
          linkend="langrefupd20-set-context"><database>RDB$SET_CONTEXT()</database></link> remain
          unchanged.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROLLBACK [WORK] RETAIN [SNAPSHOT]</programlisting>
              <!--IB6 LangRef says for COMMIT RETAIN [SNAPSHOT]:
  "Make the transaction’s changes visible to subsequent SNAPSHOT transactions or
   READ COMMITTED transactions."
But since ROLLBACK doesn't apply any changes, I wonder what SNAPSHOT would
do here... still, the syntax IS supported.-->
            </blockquote></para>
        </formalpara>
        <note>
          <para>The functionality provided by <database>ROLLBACK RETAIN</database> has been present
          since InterBase 6, but the only way to access it was through the API call
          <function>isc_rollback_retaining()</function>.</para>
        </note>
      </section>
      <section id="langrefupd20-rollback-to-savepoint">
        <title><database>ROLLBACK TO SAVEPOINT</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>Undoes everything that happened in a transaction since the creation of the
          savepoint.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
            </blockquote></para>
        </formalpara>
        <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
        <!--Keep this itemizedlist synchronized with the one under SAVEPOINT !-->
        <itemizedlist>
          <listitem>
            <para>All the database mutations performed within the transaction since the savepoint
            was created are undone. User variables set with <link
            linkend="langrefupd20-set-context"><database>RDB$SET_CONTEXT()</database></link> remain
            unchanged.</para>
          </listitem>
          <listitem>
            <para>All savepoints created after the one named are destroyed. All earlier savepoints
            are preserved, as is the savepoint itself. This means that you can rollback to the same
            savepoint several times.</para>
          </listitem>
          <listitem>
            <para>All implicit and explicit record locks acquired since the savepoint are released.
            Other transactions that have requested access to rows locked after the savepoint must
            continue to wait until the transaction is committed or rolled back. Other transactions
            that have not already requested the rows can request and access the unlocked rows
            immediately.</para>
          </listitem>
        </itemizedlist>
        <para>For a full discussion of savepoints, see <link
        linkend="langrefupd20-savepoint"><citetitle><database>SAVEPOINT</database></citetitle></link>.</para>
      </section>
    </section>
    <section id="langrefupd20-savepoint">
      <title><database>SAVEPOINT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL</para>
      </formalpara>
      <!--ESQL: no-->
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates an SQL-99 compliant savepoint, to which you can later rollback your work
        without rolling back the entire transaction. Savepoint mechanisms are also known as
        <quote>nested transactions</quote>.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SAVEPOINT <replaceable>&lt;name&gt;</replaceable>

<replaceable>&lt;name&gt;</replaceable>  ::=  a user-chosen identifier, unique within the transaction</programlisting>
          </blockquote></para>
      </formalpara>
      <para>If the supplied name exists already within the same transaction, the existing savepoint
      is deleted and a new one is created with the same name.</para>
      <para>If you later want to rollback your work to the point where the savepoint was created,
      use:</para>
      <blockquote>
        <programlisting>ROLLBACK [WORK] TO [SAVEPOINT] <replaceable>name</replaceable></programlisting>
      </blockquote>
      <para><database>ROLLBACK TO SAVEPOINT</database> performs the following operations:</para>
      <!--Keep this itemizedlist synchronized with the one under ROLLBACK TO SAVEPOINT !-->
      <itemizedlist>
        <listitem>
          <para>All the database mutations performed within the transaction since the savepoint was
          created are undone. User variables set with <link
          linkend="langrefupd20-set-context"><database>RDB$SET_CONTEXT()</database></link> remain
          unchanged.</para>
        </listitem>
        <listitem>
          <para>All savepoints created after the one named are destroyed. All earlier savepoints are
          preserved, as is the savepoint itself. This means that you can rollback to the same
          savepoint several times.</para>
        </listitem>
        <listitem>
          <para>All implicit and explicit record locks acquired since the savepoint are released.
          Other transactions that have requested access to rows locked after the savepoint must
          continue to wait until the transaction is committed or rolled back. Other transactions
          that have not already requested the rows can request and access the unlocked rows
          immediately.</para>
        </listitem>
      </itemizedlist>
      <para>The internal savepoint bookkeeping can consume huge amounts of memory, especially if you
      update the same records multiple times in one transaction. If you don't need a savepoint
      anymore but you're not yet ready to end the transaction, you can delete the savepoint and free
      the resources it uses with:</para>
      <blockquote>
        <programlisting>RELEASE SAVEPOINT <replaceable>name</replaceable> [ONLY]</programlisting>
      </blockquote>
      <para>With <database>ONLY</database>, the named savepoint is the only one that gets released.
      Without it, all savepoints created after it are released as well.</para>
      <formalpara>
        <title>Example DSQL session using a savepoint</title>
        <para><blockquote>
            <programlisting>create table test (id integer);
commit;
insert into test values (1);
commit;
insert into test values (2);
savepoint y;
delete from test;
select * from test;   -- returns no rows
rollback to y;
select * from test;   -- returns two rows
rollback;
select * from test;   -- returns one row</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-savepoint-internal">
        <title>Internal savepoints</title>
        <!--Does this belong here? Is it SQL? The TPB is an API thing, right?-->
        <para>By default, the engine uses an automatic transaction-level system savepoint to perform
        transaction rollback. When you issue a <database>ROLLBACK</database> statement, all changes
        performed in this transaction are backed out via a transaction-level savepoint and the
        transaction is then committed. This logic reduces the amount of garbage collection caused by
        rolled back transactions.</para>
        <para>When the volume of changes performed under a transaction-level savepoint is getting
        large (10<superscript>4</superscript>–10<superscript>6</superscript> records affected), the
        engine releases the transaction-level savepoint and uses the TIP mechanism to roll back the
        transaction if needed.</para>
        <tip>
          <para>If you expect the volume of changes in your transaction to be large, you can specify
          the <database>NO AUTO UNDO</database> option in your <database>SET TRANSACTION</database>
          statement, or – if you use the API – set the TPB flag <systemitem
          class="constant">isc_tpb_no_auto_undo</systemitem>. Both prevent the creation of the
          transaction-level savepoint.</para>
        </tip>
      </section>
      <section id="langrefupd20-savepoint-psql">
        <title>Savepoints and PSQL</title>
        <!--Here again the question whether it belongs here.-->
        <para>Transaction control statements are not allowed in PSQL, as that would break the
        atomicity of the statement that calls the procedure. But Firebird does support the raising
        and handling of exceptions in PSQL, so that actions performed in stored procedures and
        triggers can be selectively undone without the entire procedure failing. Internally,
        automatic savepoints are used to:</para>
        <itemizedlist>
          <listitem>
            <para>undo all actions in a <database>BEGIN...END</database> block where an exception
            occurs;<!--Even if the exception is caught by a WHEN at the end of the block? Test!--></para>
          </listitem>
          <listitem>
            <para>undo all actions performed by the SP/trigger (or, in the case of a selectable SP,
            all actions performed since the last <database>SUSPEND</database>) when it terminates
            prematurely due to an uncaught error or exception.</para>
          </listitem>
        </itemizedlist>
        <para>Each PSQL exception handling block is also bounded by automatic system
        savepoints.</para>
      </section>
    </section>
    <section id="langrefupd20-set-trans">
      <title><database>SET TRANSACTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Starts and optionally configures a transaction.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SET TRANSACTION
   [NAME <replaceable>hostvar</replaceable>]
   [READ WRITE | READ ONLY]
   [ [ISOLATION LEVEL] { SNAPSHOT [TABLE STABILITY]
                         | READ COMMITTED [[NO] RECORD_VERSION] } ]
   [WAIT | NO WAIT]
   [LOCK TIMEOUT <replaceable>seconds</replaceable>]
   [NO AUTO UNDO]
   [IGNORE LIMBO]
   [RESERVING <replaceable>&lt;tables&gt;</replaceable> | USING <replaceable>&lt;dbhandles&gt;</replaceable>]

<replaceable>&lt;tables&gt;</replaceable>      ::=  <replaceable>&lt;table_spec&gt;</replaceable> [, <replaceable>&lt;table_spec&gt;</replaceable> ...]

<replaceable>&lt;table_spec&gt;</replaceable>  ::=  <replaceable>tablename</replaceable> [, <replaceable>tablename</replaceable> ...]
                      [FOR [SHARED | PROTECTED] {READ | WRITE}]

<replaceable>&lt;dbhandles&gt;</replaceable>   ::=  <replaceable>dbhandle</replaceable> [, <replaceable>dbhandle</replaceable> ...]</programlisting>
            <!--In Fb 1.0 gpre I find "NO_AUTO_UNDO" (with underscores).
In DSQL, the underscored version is rejected.
Dmitry says: "I suspect it was inherited from InterBase 6.0 and nobody
cared to document it there."
- It's still not documented in IB 6.5 LangRef and EmbedSQL-->
            <itemizedlist>
              <listitem>
                <para>The <database>NAME</database> option is only available in ESQL. It must be
                followed by a previously declared and initialized host-language variable. Without
                <database>NAME</database>, <database>SET TRANSACTION</database> applies to the
                default transaction.</para>
              </listitem>
              <listitem>
                <para>The <database>USING</database> option is also ESQL-only. It limits the
                databases that the transaction can access to the ones mentioned here.</para>
              </listitem>
              <listitem>
                <para><database>IGNORE LIMBO</database> and <database>LOCK TIMEOUT</database> are
                not supported in ESQL.</para>
              </listitem>
              <listitem>
                <para><database>LOCK TIMEOUT</database> and <database>NO WAIT</database> are
                mutually exclusive.</para>
              </listitem>
              <listitem>
                <para>Default option settings are: <database>READ WRITE</database> +
                <database>WAIT</database> + <database>SNAPSHOT</database>.</para>
              </listitem>
            </itemizedlist>
            <!--Ask Claudio or Dmitry:
- Is LOCK TIMEOUT 0 the same as no timeout, or as NO WAIT?-->
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-set-trans-ignore-limbo">
        <title><database>IGNORE LIMBO</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>With this option, records created by limbo transactions are ignored. Transactions
          are in limbo if the second stage of a two-phase commit fails.</para>
        </formalpara>
        <note>
          <para><database>IGNORE LIMBO</database> surfaces the <systemitem
          class="constant">isc_tpb_ignore_limbo</systemitem> TPB parameter, available in the API
          since <application>InterBase</application> times and mainly used by
          <application>gfix</application>.</para>
        </note>
      </section>
      <section id="langrefupd20-set-trans-lock-timeout">
        <title><database>LOCK TIMEOUT</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL</para>
          <!--ESQL: no-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>This option is only available for <database>WAIT</database> transactions. It takes a
          non-negative integer as argument, prescribing the maximum number of seconds that the
          transaction should wait when a lock conflict occurs. If the the waiting time has passed
          and the lock has still not been released, an error is generated.</para>
        </formalpara>
        <note>
          <para>This is a brand new feature in Firebird 2. Its API equivalent is the new <systemitem
          class="constant">isc_tpb_lock_timeout</systemitem> TPB parameter.</para>
        </note>
      </section>
      <section id="langrefupd20-set-trans-no-auto-undo">
        <title><database>NO AUTO UNDO</database></title>
        <formalpara>
          <title>Available in</title>
          <para>DSQL, ESQL</para>
          <!--In ESQL probably as NO_AUTO_UNDO, i.e. with underscores! See comment under Syntax, above.-->
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>With <database>NO AUTO UNDO</database>, the transaction refrains from keeping the
          log that is normally used to undo changes in the event of a rollback. Should the
          transaction be rolled back after all, other transactions will pick up the garbage
          (eventually).<!--Is that correct? Under SAVEPOINT, it says that the TIP mechanism is used. What is that?-->
          This option can be useful for massive insertions that don't need to be rolled back. For
          transactions that don't perform any mutations, <database>NO AUTO UNDO</database> makes no
          difference at all.</para>
        </formalpara>
        <note>
          <para><database>NO AUTO UNDO</database> is the SQL equivalent of the <systemitem
          class="constant">isc_tpb_no_auto_undo</systemitem> TPB parameter, available in the API
          since <application>InterBase</application> times.</para>
        </note>
      </section>
    </section>
  </chapter>
  <chapter id="langrefupd20-psql">
    <title>PSQL statements</title>
    <para>PSQL – Procedural SQL – is the Firebird programming language used in stored procedures,
    triggers and executable blocks.</para>
    <section id="langrefupd20-psql-begin-end">
      <title><database>BEGIN ... END</database> blocks may be empty</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BEGIN ... END</database> blocks may be empty in Firebird 1.5 and up,
        allowing you to write stub code without having to resort to dummy statements.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_atable for atable
active before insert position 0
as
begin
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-break">
      <title><database>BREAK</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link linkend="langrefupd20-psql-leave"><database>LEAVE</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>BREAK</database> immediately terminates a <database>WHILE</database> or
        <database>FOR</database> loop and continues with the first statement after the loop.</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create procedure selphrase(num int)
returns (phrase varchar(40))
as
begin
  for select Phr from Phrases into phrase do
  begin
    if (num &lt; 1) then <emphasis role="bold">break;</emphasis>
    suspend;
    num = num - 1;
  end
  phrase = '***  Ready!  ***';
  suspend;
end</programlisting>
            <para>This selectable SP returns at most <replaceable>num</replaceable> rows from the
            table Phrases. The variable <replaceable>num</replaceable> is decremented in each
            iteration; once it is smaller than 1, the loop is terminated with
            <database>BREAK</database>. The program then continues at the line
            <quote><literal>phrase = '*** Ready! ***';</literal></quote>.</para>
          </blockquote></para>
      </formalpara>
      <important>
        <para>Since Firebird 1.5, use of the SQL-99 compliant alternative <link
        linkend="langrefupd20-psql-leave"><database>LEAVE</database></link> is preferred.</para>
        <!--Not synonyms anymore, for in 2.0 LEAVE supports a label whereas BREAK doesn't.-->
      </important>
      <!--TESTED:
Contrary to what Fb 1.5 rlsnotes suggest, BREAK works in SPs *and* triggers as from 1.0.
In IB6 it doesn't exist.-->
    </section>
    <section id="langrefupd20-psql-close-cursor">
      <title><database>CLOSE</database> cursor</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Closes an open cursor. Any cursors still open when the trigger, stored procedure or
        <database>EXECUTE BLOCK</database> statement they belong to is exited, will be closed
        automatically.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CLOSE <replaceable>cursorname</replaceable>;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para>See <link linkend="langrefupd20-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-declare">
      <title><database>DECLARE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <section id="langrefupd20-psql-declare-cursor">
        <title><database>DECLARE</database> ... <database>CURSOR</database></title>
        <formalpara>
          <title>Added in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <!--ATTENTION: DECLARE ... CURSOR was already available in ESQL. Difference: according to LangRef, the SELECT need not go between () in ESQL.

Then there is a DSQL form:
  DECLARE cursor CURSOR FOR <statement_id>
Here, <statement_id> is the id of an already prepared stmt. How do you do that in DSQL?
PREPARE seems only supported in ESQL. Should you prepare via the API, and is the handle the ID?
Incidentally,  "declare cursor billie cursor for..." already breaks on "billie".
This suggests that this use is not supported after all, at least not in the form given in the LangRef.
Indeed, in IBPhoenix's FirebirdReference, in the head of the DECLARE CURSOR section, DSQL has been stricken out.

And is the optional [VARIABLE] supported in DSQL and ESQL?-->
          <para>Declares a named cursor and binds it to its own <database>SELECT</database>
          statement. The cursor can later be opened, used to walk the result set, and closed again.
          Positioned updates and deletes (using <link
          linkend="langrefupd20-psql-wherecurrentof"><database>WHERE CURRENT OF</database></link>)
          are also supported. PSQL cursors are available in triggers, stored procedures and <link
          linkend="langrefupd20-execblock"><database>EXECUTE BLOCK</database></link>
          statements.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DECLARE [VARIABLE] <replaceable>cursorname</replaceable> CURSOR FOR (<replaceable>select-statement</replaceable>);</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>execute block
returns (relation char(31), sysflag int)
as
declare cur cursor for 
  (select rdb$relation_name, rdb$system_flag from rdb$relations);
begin
  open cur;
  while (1=1) do
  begin
    fetch cur into relation, sysflag;
    if (row_count = 0) then leave;
    suspend;
  end
  close cur;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>A <quote><database>FOR UPDATE</database></quote> clause is allowed in the
                <database>SELECT</database> statement, but not required for a positioned update or
                delete to succeed.</para>
              </listitem>
              <listitem>
                <para>Make sure that declared cursor names do not clash with any names defined later
                on in <link linkend="langrefupd20-psql-forselect-ascursor"><database>AS
                CURSOR</database></link> clauses.</para>
              </listitem>
              <listitem>
                <para>If you need a cursor to loop through an output set, it is almost always easier
                – and less error-prone – to use a <database>FOR SELECT</database> statement with an
                <database>AS CURSOR</database> clause. Declared cursors must be explicitly opened,
                fetched from, and closed. Furthermore, you need to check
                <varname>row_count</varname> after every fetch and break out of the loop if it is
                zero. <database>AS CURSOR</database> takes care of all of that automagically.
                However, declared cursors give you more control over the sequence of events, and
                allow you to operate several cursors in parallel.</para>
              </listitem>
              <listitem>
                <para>The <database>SELECT</database> statement may contain named SQL parameters,
                like in <quote><code>select name || :sfx from names where number =
                :num</code></quote>. Each parameter must be a PSQL variable that has been declared
                previously (this includes any in/out params of the PSQL module). When the cursor is
                opened, the parameter is assigned the current value of the variable.</para>
              </listitem>
              <listitem>
                <para>Caution! If the value of a PSQL variable that is used in the
                <database>SELECT</database> statement changes during execution of the loop, the
                statement <emphasis>may</emphasis> (but will not always) be re-evaluated for the
                remaining rows. In general, this situation should be avoided. If you really need
                this behaviour, test your code thoroughly and make sure you know how variable
                changes affect the outcome. Also be advised that the behaviour may depend on the
                query plan, in particular the use of indices. As it is currently not strictly
                defined, it may change in some future version of Firebird.</para>
                <!--I have noticed that the statement is NOT re-avaluated if an index is used, and IS re-evaluated if no index is used.
Adding PLAN (T NATURAL) to a certain query forced re-evaluation and thus altered the outcome.
But I don't know if this is always the case, and if the use of an index is the only factor.-->
              </listitem>
            </itemizedlist></para>
        </formalpara>
        <formalpara>
          <title>See also</title>
          <para><link linkend="langrefupd20-psql-open-cursor"><database>OPEN</database>
          cursor</link>, <link linkend="langrefupd20-psql-fetch-cursor"><database>FETCH</database>
          cursor</link>, <link linkend="langrefupd20-psql-close-cursor"><database>CLOSE</database>
          cursor</link></para>
        </formalpara>
      </section>
      <section id="langrefupd20-psql-declare-init">
        <title><database>DECLARE [VARIABLE]</database> with initialization</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.5</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird 1.5 and above, a PSQL local variable can be initialized upon
          declaration. The <database>VARIABLE</database> keyword has become optional.</para>
        </formalpara>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>DECLARE [VARIABLE] <replaceable>varname</replaceable> <replaceable>datatype</replaceable> [{= | DEFAULT} <replaceable>value</replaceable>];</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure proccie (a int)
returns (b int)
as
  declare p int;
  declare q int = 8;
  declare r int default 9;
  declare variable s int;
  declare variable t int = 10;
  declare variable u int default 11;
begin
  <replaceable>&lt;intelligent code here&gt;</replaceable>
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-psql-exception">
      <title><database>EXCEPTION</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>EXCEPTION</database> syntax has been extended so that the user
        can<orderedlist numeration="loweralpha" spacing="compact">
            <listitem>
              <para>Rethrow a caught exception or error.</para>
            </listitem>
            <listitem>
              <para>Provide a custom message when throwing a user-defined exception.</para>
            </listitem>
          </orderedlist></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXCEPTION [<replaceable>&lt;exception-name&gt;</replaceable> [<replaceable>custom-message</replaceable>]]

<replaceable>&lt;exception-name&gt;</replaceable>  ::=  A previously defined exception name</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-psql-exception-rethrow">
        <title>Rethrowing a caught exception</title>
        <para>Within the exception handling block only, you can rethrow the caught exception or
        error by giving the <database>EXCEPTION</database> command without any arguments. Outside
        such blocks, this <quote>bare</quote> command has no effect.</para>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>when any do
begin
  insert into error_log (...) values (sqlcode, ...);
  exception;
end</programlisting>
              <para>This example first logs some information about the exception or error, and then
              rethrows it.</para>
              <!--So it also works with SQL en GDS errors? Answered by Dmitry: YES.-->
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-psql-exception-custom-msg">
        <title>Providing a custom error message</title>
        <para>Firebird 1.5 and up allow you to override an exception's default error message by
        supplying an alternative one when throwing the exception.</para>
        <formalpara>
          <title>Examples</title>
          <para><blockquote>
              <programlisting>exception ex_data_error 'You just lost some valuable data';</programlisting>
              <programlisting>exception ex_bad_type 'Wrong type for record with id ' || new.id;</programlisting>
            </blockquote></para>
        </formalpara>
        <note>
          <para>Starting at version 2.0, the maximum message length is 1021 instead of 78
          characters.</para>
        </note>
      </section>
    </section>
    <section id="langrefupd20-psql-execproc">
      <title><database>EXECUTE PROCEDURE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and above, (compound) expressions are allowed as input parameters for
        stored procedures called with <database>EXECUTE PROCEDURE</database>. See <link
        linkend="langrefupd20-execproc"><citetitle>DML statements :: <database>EXECUTE
        PROCEDURE</database></citetitle></link> for full info and examples.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-execstat">
      <title><database>EXECUTE STATEMENT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>EXECUTE STATEMENT</database> takes a single string argument and executes it
        as if it had been submitted as a DSQL statement. The exact syntax depends on the number of
        data rows that the supplied statement may return.</para>
      </formalpara>
      <section id="langrefupd20-psql-execstat-nooutput">
        <title>No data returned</title>
        <para>This form is used with <database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database> and <database>EXECUTE PROCEDURE</database> statements that
        return no data.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;statement&gt;</replaceable>

<replaceable>&lt;statement&gt;</replaceable>  ::=  An SQL statement returning no data.</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleOne (ProcName varchar(100))
as
declare variable stmt varchar(1024);
declare variable param int;
begin
   select min(SomeField) from SomeTable into param;
   stmt = 'execute procedure ' 
          || ProcName 
          || '(' 
          || cast(param as varchar(20)) 
          || ')';
   execute statement stmt;
end</programlisting>
            </blockquote></para>
        </formalpara>
        <warning>
          <para>Although this form of <database>EXECUTE STATEMENT</database> can also be used with
          all kinds of DDL strings (except <database>CREATE/DROP DATABASE</database>), it is
          generally very, very unwise to use this trick in order to circumvent the no-DDL rule in
          PSQL.</para>
        </warning>
      </section>
      <section id="langrefupd20-psql-execstat-singleton">
        <title>One row of data returned</title>
        <para>This form is used with singleton <database>SELECT</database> statements.</para>
        <!--EXECUTE PROCEDURE with RETURNING_VALUES is NOT possible in EXECUTE STATEMENT
(Token unknown - line 1, char 25 returning_values). Why?-->
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  An SQL statement returning at most one row of data.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleTwo (TableName varchar(100))
as
declare variable param int;
begin
  execute statement
    'select max(CheckField) from ' || TableName into :param;
  if (param &gt; 100) then
    exception Ex_Overflow 'Overflow in ' || TableName;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-psql-execstat-multirow">
        <title>Any number of data rows returned</title>
        <para>This form – analogous to <quote><database>FOR SELECT ... DO</database></quote> – is
        used with <database>SELECT</database> statements that may return a multi-row dataset.</para>
        <formalpara>
          <title>Syntax</title>
          <para><blockquote>
              <programlisting>FOR EXECUTE STATEMENT <replaceable>&lt;select-statement&gt;</replaceable> INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   DO <replaceable>&lt;compound-statement&gt;</replaceable>

<replaceable>&lt;select-statement&gt;</replaceable>  ::=  Any SELECT statement.
<replaceable>&lt;var&gt;</replaceable>               ::=  A PSQL variable, optionally preceded by <quote><literal>:</literal></quote></programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure DynamicSampleThree 
  ( TextField varchar(100),
    TableName varchar(100) )
returns 
  ( LongLine varchar(32000) )
as
declare variable Chunk varchar(100);
begin
  Chunk = '';
  for execute statement
    'select ' || TextField || ' from ' || TableName into :Chunk
  do
    if (Chunk is not null) then
      LongLine = LongLine || Chunk || ' ';
  suspend;
end</programlisting>
            </blockquote></para>
        </formalpara>
      </section>
      <section id="langrefupd20-psql-execstat-caveats">
        <title>Caveats with <database>EXECUTE STATEMENT</database></title>
        <orderedlist>
          <listitem>
            <para>There is no way to validate the syntax of the enclosed statement.</para>
          </listitem>
          <listitem>
            <para>There are no dependency checks to discover whether tables or columns have been
            dropped.</para>
          </listitem>
          <listitem>
            <para>Operations will be slow because the embedded statement has to be prepared every
            time it is executed.</para>
          </listitem>
          <listitem>
            <para>The argument string cannot contain any parameters. All variable substitution into
            the static part of the DSQL statement should be performed before <database>EXECUTE
            STATEMENT</database> is called.</para>
          </listitem>
          <listitem>
            <para>Return values are strictly checked for data type in order to avoid unpredictable
            type-casting exceptions. For example, the string <literal>'1234'</literal> would convert
            to an integer, 1234, but <literal>'abc'</literal> would give a conversion error.</para>
          </listitem>
          <listitem>
            <para>The submitted DSQL statement is always executed with the privileges of the current
            <emphasis role="bold">user</emphasis>. Privileges granted to the trigger or SP that
            contains the <database>EXECUTE STATEMENT</database> statement are not in effect while
            the DSQL statement runs.</para>
          </listitem>
        </orderedlist>
        <para>All in all, this feature is intended only for very cautious use and you should always
        take the above factors into account. Bottom line: use <database>EXECUTE STATEMENT</database>
        only when other methods are impossible, or perform even worse than <database>EXECUTE
        STATEMENT</database>.</para>
      </section>
    </section>
    <section id="langrefupd20-psql-exit">
      <title><database>EXIT</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <database>EXIT</database> can be used in all PSQL. In earlier
        versions it is only supported in stored procedures, not in triggers.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-fetch-cursor">
      <title><database>FETCH</database> cursor</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Fetches the next data row from a cursor's result set and stores the column values in
        PSQL variables.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>FETCH <replaceable>cursorname</replaceable> INTO [:]<replaceable>varname</replaceable> [, [:]<replaceable>varname</replaceable> ...];</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The <link linkend="langrefupd20-row_count"><varname>ROW_COUNT</varname></link>
              context variable will be 1 if the fetch returned a data row and 0 if the end of the
              set has been reached.</para>
            </listitem>
            <listitem>
              <para>You can do a positioned <link
              linkend="langrefupd20-update"><database>UPDATE</database></link> or <link
              linkend="langrefupd20-delete"><database>DELETE</database></link> on the fetched row
              with the <database>WHERE CURRENT OF</database> clause.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para>See <link linkend="langrefupd20-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-forexecstatdo">
      <title><database>FOR EXECUTE STATEMENT ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>See <link linkend="langrefupd20-psql-execstat-multirow"><citetitle><database>EXECUTE
        STATEMENT</database> :: Any number of data rows returned</citetitle></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-forselect">
      <title><database>FOR SELECT ... INTO ... DO</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Executes a <database>SELECT</database> statement and retrieves the result set. In each
        iteration of the loop, the field values of the current row are copied into local variables.
        Adding an <database>AS CURSOR</database> clause enables positioned deletes and updates.
        <database>FOR SELECT</database> statements may be nested.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>FOR <replaceable>&lt;select-stmt&gt;</replaceable>
   INTO <replaceable>&lt;var&gt;</replaceable> [, <replaceable>&lt;var&gt;</replaceable> ...]
   [AS CURSOR <replaceable>name</replaceable>]
DO
   <replaceable>&lt;psql-stmt&gt;</replaceable>

<replaceable>&lt;select-stmt&gt;</replaceable>  ::=  A valid <database>SELECT</database> statement.
<replaceable>&lt;var&gt;</replaceable>          ::=  A PSQL variable name, optionally preceded by <quote><literal>:</literal></quote>
<replaceable>&lt;psql-stmt&gt;</replaceable>    ::=  A single statement or a block of PSQL code.</programlisting>
            <itemizedlist>
              <listitem>
                <para>The <database>SELECT</database> statement may contain named SQL parameters,
                like in <quote><code>select name || :sfx from names where number =
                :num</code></quote>. Each parameter must be a PSQL variable that has been declared
                previously (this includes any in/out params of the PSQL module).</para>
              </listitem>
              <listitem>
                <para>Caution! If the value of a PSQL variable that is used in the
                <database>SELECT</database> statement changes during execution of the loop, the
                statement <emphasis>may</emphasis> (but will not always) be re-evaluated for the
                remaining rows. In general, this situation should be avoided. If you really need
                this behaviour, test your code thoroughly and make sure you know how variable
                changes affect the outcome. Also be advised that the behaviour may depend on the
                query plan, in particular the use of indices. As it is currently not strictly
                defined, it may change in some future version of Firebird.</para>
                <!--I have noticed that the statement is NOT re-avaluated if an index is used, and IS re-evaluated if no index is used.
Adding PLAN (T NATURAL) to a certain query forced re-evaluation and thus altered the outcome.
But I don't know if this is always the case, and if the use of an index is the only factor.-->
              </listitem>
            </itemizedlist>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>create procedure shownums
  returns (aa int, bb int, sm int, df int)
as
begin
  for select distinct a, b from numbers order by a, b
    into :aa, :bb
  do
  begin
    sm = aa + bb;
    df = aa - bb;
    suspend;
  end
end</programlisting>
            <programlisting>create procedure relfields
  returns (relation char(32), pos int, field char(32))
as
begin
  for select rdb$relation_name from rdb$relations
      into :relation
  do
  begin
    for select rdb$field_position + 1, rdb$field_name
        from rdb$relation_fields
        where rdb$relation_name = :relation
        order by rdb$field_position
        into :pos, :field
    do
    begin
      if (pos = 2) then relation = '  "';   -- for nicer output
      suspend;
    end
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
      <section id="langrefupd20-psql-forselect-ascursor">
        <title><database>AS CURSOR</database> clause</title>
        <formalpara>
          <title>Available in</title>
          <para>PSQL</para>
        </formalpara>
        <formalpara>
          <title>Added in</title>
          <para>IB</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The optional <database>AS CURSOR</database> clause creates a named cursor that can
          be referenced (after <link linkend="langrefupd20-psql-wherecurrentof"><database>WHERE
          CURRENT OF</database></link>) within the <database>FOR SELECT</database> loop in order to
          update or delete the current row. This feature was already added in InterBase, but not
          mentioned in the <citetitle>Language Reference</citetitle>.</para>
        </formalpara>
        <formalpara>
          <title>Example</title>
          <para><blockquote>
              <programlisting>create procedure deltown (towntodelete varchar(24))
  returns (town varchar(24), pop int)
as
begin
  for select town, pop from towns into :town, :pop as cursor tcur do
  begin
    if (town = towntodelete)
      then delete from towns where current of tcur;
      else suspend;
  end
end</programlisting>
            </blockquote></para>
        </formalpara>
        <formalpara>
          <title>Notes</title>
          <para><itemizedlist>
              <listitem>
                <para>A <quote><database>FOR UPDATE</database></quote> clause is allowed in the
                <database>SELECT</database> statement., but not required for a positioned update or
                delete to succeed.</para>
              </listitem>
              <listitem>
                <para>Make sure that cursor names defined here do not clash with any names created
                earlier on in <link linkend="langrefupd20-psql-declare-cursor"><database>DECLARE
                CURSOR</database></link> statements.</para>
              </listitem>
              <listitem>
                <para><database>AS CURSOR</database> is not supported in <database>FOR EXECUTE
                STATEMENT</database> loops, even if the statement to execute is a suitable
                <database>SELECT</database> query.</para>
              </listitem>
            </itemizedlist></para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-psql-leave">
      <title><database>LEAVE</database></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>LEAVE</database> immediately terminates the innermost
        <database>WHILE</database> or <database>FOR</database> loop. With the optional
        <replaceable>label</replaceable> argument introduced in Firebird 2.0,
        <database>LEAVE</database> can break out of surrounding loops as well. Execution continues
        with the first statement after the outermost terminated loop.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>[<replaceable>label</replaceable>:]
{FOR | WHILE} ... DO
   ...
   (possibly nested loops, with or without labels)
   ...
   LEAVE [<replaceable>label</replaceable>];</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <para>If an error occurs during the insert in the example below, the event is logged and
            the loop terminated. The program continues at the line of code reading <quote><literal>c
            = 0;</literal></quote></para>
            <programlisting>while (b &lt; 10) do
begin
  insert into Numbers(B) values (:b);
  b = b + 1;
  when any do
  begin
    execute procedure log_error (current_timestamp, 'Error in B loop');
    <emphasis role="bold">leave;</emphasis>
  end
end
c = 0;</programlisting>
            <para>The next example uses labels. <quote><code>Leave LoopA</code></quote> terminates
            the outer loop, <quote><code>leave LoopB</code></quote> the inner loop. Notice that a
            plain <quote><code>leave</code></quote> would also suffice to terminate the inner
            loop.</para>
            <programlisting>stmt1 = 'select Name from Farms';
<emphasis role="bold">LoopA:</emphasis>
for execute statement :stmt1 into :farm do
begin
  stmt2 = 'select Name from Animals where Farm = ''';
  <emphasis role="bold">LoopB:</emphasis>
  for execute statement :stmt2 || :farm || '''' into :animal do
  begin
    if  (animal = 'Fluffy') then <emphasis role="bold">leave LoopB</emphasis>;
    else if (animal = farm) then <emphasis role="bold">leave LoopA</emphasis>;
    else suspend;
  end
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-open-cursor">
      <title><database>OPEN</database> cursor</title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Opens a previously declared cursor, executing its <database>SELECT</database>
        statement and enabling it to fetch records from the result set.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>OPEN <replaceable>cursorname</replaceable>;</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para>See <link linkend="langrefupd20-psql-declare-cursor"><database>DECLARE</database> ...
        <database>CURSOR</database></link>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-plan">
      <title><database>PLAN</database> allowed in trigger code</title>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Before Firebird 1.5, a trigger containing a <database>PLAN</database> statement would
        be rejected by the compiler. Now a valid plan can be included and will be used.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-psql-udf-as-proc">
      <title>UDFs callable as void functions</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 2.0 and above, PSQL code may call UDFs without assigning the result value,
        i.e. like a Pascal procedure or C void function. In most cases this is senseless, because
        the main purpose of almost every UDF is to produce the result value. Some functions however
        perform a specific task, and if you're not interested in the result value you can now spare
        yourself the trouble of assigning it to a dummy variable.<!--Also possible in DSQL? No. And ESQL? Asked Dmitry, but he forgot to answer that one.--></para>
      </formalpara>
      <note>
        <para><link linkend="langrefupd20-get-context"><function>RDB$GET_CONTEXT</function></link>
        and <link linkend="langrefupd20-set-context"><function>RDB$SET_CONTEXT</function></link>,
        though classified in this guide under internal functions, are actually a kind of
        auto-declared UDFs. You may therefore call them without catching the result. Of course this
        only makes sense for <function>RDB$SET_CONTEXT</function>.</para>
      </note>
    </section>
    <section id="langrefupd20-psql-wherecurrentof">
      <title><database>WHERE CURRENT OF</database> invalid for view cursors</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In versions 2.0.<replaceable>x</replaceable>, positioned updates and deletes using
        <database>WHERE CURRENT OF</database> are no longer possible for view cursors, due to some
        problems that could make such cursors unreliable. This restriction will be lifted again in
        Firebird 2.1, which has an improved validation logic for views.</para>
        <!--Find out if this also goes for DSQL and/or ESQL !-->
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd20-variables">
    <title>Context variables</title>
    <section id="langrefupd20-current_connection">
      <title><varname>CURRENT_CONNECTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_CONNECTION</varname> returns a unique identifier for the current
        connection.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_connection from rdb$database</programlisting>
            <programlisting>execute procedure P_Login(current_connection)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_CONNECTION</varname> is stored on the database header page
      and reset upon restore. Since the engine itself is not interested in this value, it is only
      incremented if the client reads it during a session. Hence it is only useful as a unique
      identifier, not as an indicator of the number of connections since the creation or latest
      restoration of the database. Please note that this will change in Firebird 2.1.</para>
    </section>
    <section id="langrefupd20-current_role">
      <title><varname>CURRENT_ROLE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_ROLE</varname> is a context variable containing the role of the
        currently connected user. If there is no active role, <varname>CURRENT_ROLE</varname> is
        <database>NONE</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (current_role &lt;&gt; 'MANAGER')
  then exception only_managers_may_delete;
else
  delete from Customers where custno = :custno;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><varname>CURRENT_ROLE</varname> always represents a valid role or
      <database>NONE</database>. If a user connects with a non-existing role, the engine silently
      resets it to <database>NONE</database> without returning an error.</para>
    </section>
    <section id="langrefupd20-current_time">
      <title><varname>CURRENT_TIME</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIME</varname> returns the current server time. In versions prior to
        2.0, the fractional part used to be always <quote><literal>.0000</literal></quote>, giving
        an effective precision of 0 decimals. From Firebird 2.0 onward you can specify a precision
        when polling this variable. The default is still 0 decimals, i.e. seconds precision.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIME</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIME [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_time from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select current_time(2) from rdb$database
-- returns e.g. 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Unlike <varname>CURRENT_TIME</varname>, the default precision of
              <varname>CURRENT_TIMESTAMP</varname> has changed to 3 decimals. As a result,
              <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum of
              <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIME</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langrefupd20-now"><literal>'NOW'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-current_timestamp">
      <title><varname>CURRENT_TIMESTAMP</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TIMESTAMP</varname> returns the current server date and time. In
        versions prior to 2.0, the fractional part used to be always
        <quote><literal>.0000</literal></quote>, giving an effective precision of 0 decimals. From
        Firebird 2.0 onward you can specify a precision when polling this variable. The default is 3
        decimals, i.e. milliseconds precision.<!--This new functionality also available in ESQL? Dimtry says about the new ms precision:
"I believe it should be supported automagically." About the precision arg: "Not supported."--></para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CURRENT_TIMESTAMP [(<replaceable>precision</replaceable>)]

<replaceable>precision</replaceable>  ::=  0 | 1 | 2 | 3</programlisting>
            <para>The optional <replaceable>precision</replaceable> argument is not supported in
            ESQL.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_timestamp from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <programlisting>select current_timestamp(2) from rdb$database
-- returns e.g. 2008-08-13 14:20:23.1200</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The default precision of <varname>CURRENT_TIME</varname> is still 0 decimals, so
              in Firebird 2.0 and up <varname>CURRENT_TIMESTAMP</varname> is no longer the exact sum
              of <varname>CURRENT_DATE</varname> and <varname>CURRENT_TIME</varname>, unless you
              explicitly specify a precision.</para>
            </listitem>
            <listitem>
              <para>Within a PSQL module (procedure, trigger or executable block), the value of
              <varname>CURRENT_TIMESTAMP</varname> will remain constant every time it is read. If
              multiple modules call or trigger each other, the value will remain constant throughout
              the duration of the outermost module. If you need a progressing value in PSQL (e.g. to
              measure time intervals), use <link
              linkend="langrefupd20-now"><literal>'NOW'</literal></link>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-current_transaction">
      <title><varname>CURRENT_TRANSACTION</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_TRANSACTION</varname> contains the unique identifier of the current
        transaction.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select current_transaction from rdb$database</programlisting>
            <programlisting>New.Txn_ID = current_transaction;</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The value of <varname>CURRENT_TRANSACTION</varname> is stored on the database header
      page and reset upon restore. Unlike <varname>CURRENT_CONNECTION</varname>, it is incremented
      with every new transaction, whether the client reads the value or not.</para>
    </section>
    <section id="langrefupd20-current_user">
      <title><varname>CURRENT_USER</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: in 2.1--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>CURRENT_USER</varname> is a context variable containing the name of the
        currently connected user. It is fully equivalent to <database>USER</database>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>VARCHAR(31)</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>create trigger bi_customers for customers before insert as
begin
  New.added_by  = CURRENT_USER;
  New.purchases = 0;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-deleting">
      <title><varname>DELETING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>DELETING</varname> indicates if the trigger fired
        because of a <database>DELETE</database> operation. Intended for use in <link
        linkend="langrefupd20-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (deleting) then
begin
  insert into Removed_Cars (id, make, model, removed)
    values (old.id, old.make, old.model, current_timestamp);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-gdscode">
      <title><varname>GDSCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>GDSCODE</varname> context variable contains the numerical representation of the
        current Firebird error code. Prior to Firebird 2.0, <varname>GDSCODE</varname> was only set
        in <database>WHEN GDSCODE</database> handlers. Now it may also be non-zero in <database>WHEN
        ANY</database>, <database>WHEN SQLCODE</database> and <database>WHEN EXCEPTION</database>
        blocks, provided that the condition raising the error corresponds with a Firebird error
        code. Outside error handlers, <varname>GDSCODE</varname> is always 0. Outside PSQL it
        doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when gdscode grant_obj_notfound, gdscode grant_fld_notfound,
     gdscode grant_nopriv, gdscode grant_nopriv_on_base
do
begin
  execute procedure log_grant_error(gdscode);
  exit;
end</programlisting>
          </blockquote></para>
      </formalpara>
      <para>Please notice: After <database>WHEN GDSCODE</database>, you must use symbolic names like
      <errorcode>grant_obj_notfound</errorcode> etc. But the <varname>GDSCODE</varname> context
      variable is an <database>INTEGER</database>. If you want to compare it against a certain
      error, you have to use the numeric value, e.g. 335544551 for
      <errorcode>grant_obj_notfound</errorcode>.</para>
    </section>
    <section id="langrefupd20-inserting">
      <title><varname>INSERTING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>INSERTING</varname> indicates if the trigger
        fired because of an <database>INSERT</database> operation. Intended for use in <link
        linkend="langrefupd20-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-new">
      <title><varname>NEW</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>NEW</varname> contains the new version of a database record that has just
        been inserted or updated. Starting with Firebird 2.0 it is read-only in
        <database>AFTER</database> triggers.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>NEW</varname> is
        always available. But if the trigger is fired by a <database>DELETE</database>, there will
        be no new version of the record. In that situation, reading from <varname>NEW</varname> will
        always return <constant>NULL</constant>; writing to it will cause a runtime
        exception.</para>
      </note>
    </section>
    <section id="langrefupd20-now">
      <title><literal>'NOW'</literal></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL, ESQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><literal>'NOW'</literal> is not a variable but a string literal. It is, however,
        special in the sense that when you <database>CAST()</database> it to a date/time type, you
        will get the current date and/or time. The fractional part of the time used to be always
        <quote><literal>.0000</literal></quote>, giving an effective seconds precision. In Firebird
        2.0 the precision is 3 decimals, i.e. milliseconds. <literal>'NOW'</literal> is
        case-insensitive, and the engine ignores leading or trailing spaces when casting.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>CHAR(3)</database></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select 'Now' from rdb$database
-- returns 'Now'</programlisting>
            <programlisting>select cast('Now' as date) from rdb$database
-- returns e.g. 2008-08-13</programlisting>
            <programlisting>select cast('now' as time) from rdb$database
-- returns e.g. 14:20:19.6170</programlisting>
            <programlisting>select cast('NOW' as timestamp) from rdb$database
-- returns e.g. 2008-08-13 14:20:19.6170</programlisting>
            <para><link linkend="langrefupd20-shorthandcast">Shorthand syntax</link> for the last
            three statements:</para>
            <programlisting>select date 'Now' from rdb$database
select time 'now' from rdb$database
select timestamp 'NOW' from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><literal>'NOW'</literal> always returns the actual date/time, even in PSQL
              modules, where <varname>CURRENT_DATE</varname>, <link
              linkend="langrefupd20-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langrefupd20-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              return the same value throughout the duration of the outermost routine. This makes
              <literal>'NOW'</literal> useful for measuring time intervals in triggers, procedures
              and executable blocks.</para>
            </listitem>
            <listitem>
              <para>Except in the situation mentioned above, reading
              <varname>CURRENT_DATE</varname>, <link
              linkend="langrefupd20-current_time"><varname>CURRENT_TIME</varname></link> and <link
              linkend="langrefupd20-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>
              is generally preferable to casting <literal>'NOW'</literal>. Be aware though that
              <varname>CURRENT_TIME</varname> defaults to seconds precision; to get milliseconds
              precision, use <varname>CURRENT_TIME</varname>(<parameter>3</parameter>).</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-old">
      <title><varname>OLD</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL, triggers only</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><varname>OLD</varname> contains the existing version of a database record just before
        a deletion or update. Starting with Firebird 2.0 it is read-only.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>Data row</para>
      </formalpara>
      <note>
        <para>In multi-action triggers – introduced in Firebird 1.5 – <varname>OLD</varname> is
        always available. But if the trigger is fired by an <database>INSERT</database>, there is
        obviously no pre-existing version of the record. In that situation, reading from
        <varname>OLD</varname> will always return <constant>NULL</constant>; writing to it will
        cause a runtime exception.</para>
      </note>
    </section>
    <section id="langrefupd20-row_count">
      <title><varname>ROW_COUNT</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <varname>ROW_COUNT</varname> context variable contains the number of rows affected
        by the most recent DML statement (<database>INSERT</database>, <database>UPDATE</database>,
        <database>DELETE</database>, <database>SELECT</database> or <database>FETCH</database>) in
        the current trigger, stored procedure or executable block.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>update Figures set Number = 0 where id = :id;
if (row_count = 0) then
  insert into Figures (id, Number) values (:id, 0);</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Behaviour with <database>SELECT</database> and <database>FETCH</database></title>
        <para><itemizedlist>
            <listitem>
              <para>After a singleton <database>SELECT</database>, <varname>ROW_COUNT</varname> is 1
              if a data row was retrieved and 0 otherwise.</para>
            </listitem>
            <listitem>
              <para>In a <database>FOR SELECT</database> loop, <varname>ROW_COUNT</varname> is
              incremented with every iteration (starting at 0 before the first).</para>
            </listitem>
            <listitem>
              <para>After a <database>FETCH</database> from a cursor, <varname>ROW_COUNT</varname>
              is 1 if a data row was retrieved and 0 otherwise. Fetching more records from the same
              cursor does <emphasis>not</emphasis> increment <varname>ROW_COUNT</varname> beyond
              1.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.<replaceable>x</replaceable>, <varname>ROW_COUNT</varname> is 0
              after any type of <database>SELECT</database> statement.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <note>
        <para><varname>ROW_COUNT</varname> cannot be used to determine the number of rows affected
        by an <database>EXECUTE STATEMENT</database> or <database>EXECUTE PROCEDURE
        </database>command.</para>
      </note>
    </section>
    <section id="langrefupd20-sqlcode">
      <title><varname>SQLCODE</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In a <quote><database>WHEN ... DO</database></quote> error handling block, the
        <varname>SQLCODE</varname> context variable contains the current SQL error code. Prior to
        Firebird 2.0, <varname>SQLCODE</varname> was only set in <database>WHEN SQLCODE</database>
        and <database>WHEN ANY</database> handlers. Now it may also be non-zero in <database>WHEN
        GDSCODE</database> and <database>WHEN EXCEPTION</database> blocks, provided that the
        condition raising the error corresponds with an SQL error code. Outside error handlers,
        <varname>SQLCODE</varname> is always 0. Outside PSQL it doesn't exist at all.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>when any
do
begin
  if (sqlcode &lt;&gt; 0) then
    Msg = 'An SQL error occurred!';
  else
    Msg = 'Something bad happened!';
  exception ex_custom Msg;
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-updating">
      <title><varname>UPDATING</varname></title>
      <formalpara>
        <title>Available in</title>
        <para>PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Available in triggers only, <varname>UPDATING</varname> indicates if the trigger fired
        because of an <database>UPDATE</database> operation. Intended for use in <link
        linkend="langrefupd20-create-trigger-multiaction">multi-action triggers</link>.</para>
      </formalpara>
      <formalpara>
        <title>Type</title>
        <para>boolean</para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>if (inserting or updating) then
begin
  if (new.serial_num is null) then
    new.serial_num = gen_id(gen_serials, 1);
end</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd20-operators">
    <title>Operators and predicates</title>
    <section id="langrefupd20-operators-null">
      <title><constant>NULL</constant> literals allowed as operands</title>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Before Firebird 2.0, most operators and predicates did not allow
        <constant>NULL</constant> literals as operands. Tests or operations like <quote><code>A
        &lt;&gt; NULL</code></quote>, <quote><code>B + NULL</code></quote> or <quote><code>NULL &lt;
        ANY(...)</code></quote> would be rejected by the parser. Now they are allowed almost
        everywhere, but please be aware of the following:<blockquote>
            <para><emphasis>The vast majority of these newly allowed expressions return
            <constant>NULL</constant> regardless of the state or value of the other operand, and are
            therefore worthless for any practicle purpose whatsoever.</emphasis></para>
          </blockquote></para>
      </formalpara>
      <!--Made this a separate para because otherwise there is no space between it and the blockquote above in the PDF version:-->
      <para>In particular, don't try to determine (non-)nullness of a field or variable by testing
      with <quote><code>= NULL</code></quote> or <quote><code>&lt;&gt; NULL</code></quote>. Always
      use <quote><code>IS [NOT] NULL</code></quote>.</para>
      <formalpara>
        <title>Predicates</title>
        <para>The <database>IN</database>, <database>ANY</database>/<database>SOME</database> and
        <database>ALL</database> predicates now also allow <constant>NULL</constant> literals where
        they were previously taboo. Here too, there is no practical benefit to enjoy, but the
        situation is a little more complicated in that predicates with <constant>NULL</constant>s do
        not always return a <constant>NULL</constant> result. For details, see the
        <citetitle>Firebird Null Guide</citetitle>, section <ulink
        url="http://www.firebirdsql.org/manual/nullguide-predicates.html"><citetitle>Predicates</citetitle></ulink>.</para>
      </formalpara>
    </section>
    <section id="langrefupd20-concat">
      <title><database>||</database> (string concatenator)</title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd20-concat-resulttype">
        <title>Result type <database>VARCHAR</database></title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The result type of string concatenations used to be
          <database>CHAR</database>(<replaceable>n</replaceable>). Starting with Firebird 2.0, it is
          <database>VARCHAR</database>(<replaceable>n</replaceable>). As a result, the maximum
          length of a concatenation outcome is now 32765 instead of 32767.</para>
          <!--Bug report CORE-3195: max should be 32767.-->
        </formalpara>
      </section>
      <section id="langrefupd20-concat-overflow">
        <title>Overflow checking</title>
        <formalpara>
          <title>Changed in</title>
          <para>1.0, 2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>In Firebird versions 1.x, an error would be raised if the sum of the
          <emphasis>declared</emphasis> string lengths in a concatenation exceeded 65535 bytes, even
          if the <emphasis>actual</emphasis> result lay within the maximum string length of 32767
          bytes. In Firebird 2.0 and up, the declared string lengths will never cause an error. Only
          if the actual outcome exceeds 32765 bytes (the new limit for concatenation results) will
          an error be raised.</para>
          <!--Bug report CORE-3195: max should be 32767.-->
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-all">
      <title><database>ALL</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd20-all-null">
        <title><constant>NULL</constant> literals allowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ALL</database> predicate now allows a <constant>NULL</constant> as the
          test value. Notice that this brings no practical benefits. In particular, a
          <constant>NULL</constant> test value will not be considered equal to
          <constant>NULL</constant>s in the subquery result set. Even if the entire set is filled
          with <constant>NULL</constant>s and the operator chosen is <quote>=</quote>, the predicate
          will not return <constant>true</constant>, but <constant>NULL</constant>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-all-union">
        <title><database>UNION</database> as subselect</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The subselect in an <database>ALL</database> predicate may now also be a
          <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-any">
      <title><database>ANY</database> / <database>SOME</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd20-any-null">
        <title><constant>NULL</constant> literals allowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>ANY</database> (or <database>SOME</database>) predicate now allows a
          <constant>NULL</constant> as the test value. Notice that this brings no practical
          benefits. In particular, a <constant>NULL</constant> test value will not be considered
          equal to a <constant>NULL</constant> in the subquery result set.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-any-union">
        <title><database>UNION</database> as subselect</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The subselect in an <database>ANY</database> (or <database>SOME</database>)
          predicate may now also be a <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-in">
      <title><database>IN</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <section id="langrefupd20-in-null">
        <title><constant>NULL</constant> literals allowed</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>The <database>IN</database> predicate now allows <constant>NULL</constant> literals,
          both as the test value and in the list. Notice that this brings no practical benefits. In
          particular, <quote><constant>NULL</constant> <database>IN</database> (...,
          <constant>NULL</constant>, ..., ...)</quote> will not return <constant>true</constant> and
          <quote><constant>NULL</constant> <database><database>NOT</database></database>
          <database>IN</database> (..., <constant>NULL</constant>, ..., ...)</quote> will not return
          <constant>false</constant>.</para>
        </formalpara>
      </section>
      <section id="langrefupd20-in-union">
        <title><database>UNION</database> as subselect</title>
        <formalpara>
          <title>Changed in</title>
          <para>2.0</para>
        </formalpara>
        <formalpara>
          <title>Description</title>
          <para>A subselect in an <database>IN</database> predicate may now also be a
          <database>UNION</database>.</para>
        </formalpara>
      </section>
    </section>
    <section id="langrefupd20-distinct">
      <title><database>IS [NOT] DISTINCT FROM</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Two operands are considered <database>DISTINCT</database> if they have a different
        value or if one of them is <constant>NULL</constant> and the other isn't. They are
        <database>NOT DISTINCT</database> if they have the same value or if both of them are
        <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Boolean</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting><replaceable>op1</replaceable> IS [NOT] DISTINCT FROM <replaceable>op2</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select id, name, teacher from courses
  where start_day is not distinct from end_day</programlisting>
            <programlisting>if (New.Job is distinct from Old.Job)
  then post_event 'job_changed';</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>IS [NOT] DISTINCT FROM</database> always returns <constant>true</constant> or
      <constant>false</constant>, never <constant>NULL</constant> (unknown). The
      <quote><literal>=</literal></quote> and <quote><literal>&lt;&gt;</literal></quote> operators,
      by contrast, return <constant>NULL</constant> if one or both operands are
      <constant>NULL</constant>. See also the table below.</para>
      <table id="langrefupd20-tbl-distinct">
        <title>Comparison of <database>[NOT] DISTINCT</database> to
        <quote><literal>=</literal></quote> and <quote><literal>&lt;&gt;</literal></quote></title>
        <tgroup cols="5">
          <colspec colname="colOperands" />
          <colspec align="center" colname="colResult1" />
          <colspec align="center" colname="colResult2" />
          <colspec align="center" colname="colResult3" />
          <colspec align="center" colname="colResult4" />
          <spanspec nameend="colResult4" namest="colResult1" spanname="spanResults" />
          <thead>
            <row>
              <entry align="center" morerows="1">Operand characteristics</entry>
              <entry align="center" spanname="spanResults">Results with the different
              operators</entry>
            </row>
            <row>
              <entry align="center">=</entry>
              <entry align="center">NOT DISTINCT</entry>
              <entry align="center">&lt;&gt;</entry>
              <entry align="center">DISTINCT</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Same value</entry>
              <entry><constant>true</constant></entry>
              <entry><constant>true</constant></entry>
              <entry><constant>false</constant></entry>
              <entry><constant>false</constant></entry>
            </row>
            <row>
              <entry>Different values</entry>
              <entry><constant>false</constant></entry>
              <entry><constant>false</constant></entry>
              <entry><constant>true</constant></entry>
              <entry><constant>true</constant></entry>
            </row>
            <row>
              <entry>Both <constant>NULL</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>true</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>false</constant></entry>
            </row>
            <row>
              <entry>One <constant>NULL</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>false</constant></entry>
              <entry><constant>NULL</constant></entry>
              <entry><constant>true</constant></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
    <section id="langrefupd20-nextvaluefor">
      <title><database>NEXT VALUE FOR</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL<!--ESQL: no--></para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the next value in a sequence. <database>SEQUENCE</database> is the
        SQL-compliant term for what InterBase and Firebird have always called a generator.
        <database>NEXT VALUE FOR</database> is fully equivalent to <database>GEN_ID(...,
        1)</database> and is the recommended syntax from Firebird 2.0 onward.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>NEXT VALUE FOR <replaceable>sequence-name</replaceable></programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>new.cust_id = next value for custseq;</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>NEXT VALUE FOR</database> doesn't support increment values other than 1. If
      you absolutely need other step values, use the legacy GEN_ID function.</para>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-create-seq"><database>CREATE SEQUENCE</database></link>,
        <link linkend="langrefupd20-genid"><database>GEN_ID()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-some">
      <title><database>SOME</database></title>
      <para>See <link linkend="langrefupd20-any"><database>ANY</database></link></para>
    </section>
  </chapter>
  <chapter id="langrefupd20-functions">
    <title>Internal functions</title>
    <section id="langrefupd20-bit-length">
      <title><database>BIT_LENGTH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Gives the length in bits of the input string. For multi-byte character sets, this may
        be less than the number of characters times 8 times the <quote>formal</quote> number of
        bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
      </formalpara>
      <note>
        <para>With arguments of type <database>CHAR</database>, this function takes the entire
        formal string length (e.g. the declared length of a field or variable) into account. If you
        want to obtain the <quote>logical</quote> bit length, not counting the trailing spaces,
        right-<link linkend="langrefupd20-trim"><database>TRIM</database></link> the argument before
        passing it to <database>BIT_LENGTH</database>.</para>
      </note>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>BIT_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select bit_length('Hello!') from rdb$database
  -- returns 48</programlisting>
            <programlisting>select bit_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 64: ü and ß take up one byte each in ISO8859_1</programlisting>
            <programlisting>select bit_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 80: ü and ß take up two bytes each in UTF8</programlisting>
            <programlisting>select bit_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 208: all 24 <database>CHAR</database> positions count, and two of them are 16-bit</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-octet-length"><database>OCTET_LENGTH()</database></link>,
        <link linkend="langrefupd20-char-length"><database>CHARACTER_LENGTH</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-cast">
      <title><database>CAST()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>CAST</database> converts an expression to the desired datatype. If the
        conversion is not possible, an error is thrown.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>User-chosen.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CAST (<replaceable>expression</replaceable> AS <replaceable>datatype</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Shorthand syntax</title>
        <para><blockquote>
            <para>Alternative syntax, supported only when casting a string literal to a
            <database>DATE</database>, <database>TIME</database> or
            <database>TIMESTAMP</database>:</para>
            <programlisting><replaceable>datatype</replaceable> <replaceable>'date/timestring'</replaceable></programlisting>
            <para>This syntax was already available in InterBase, but was never properly
            documented.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <para>A full-syntax cast:</para>
            <programlisting>select cast ('12' || '-June-' || '1959' as date) from rdb$database</programlisting>
            <para>A shorthand string-to-date cast:</para>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; date '1-Jan-1943'</programlisting>
            <para>Notice that you can drop even the shorthand cast from the example above, as the
            engine will understand from the context (comparison to a <database>DATE</database>
            field) how to interpret the string:</para>
            <programlisting>update People set AgeCat = 'Old'
  where BirthDate &lt; '1-Jan-1943'</programlisting>
            <para>But this is not always possible. The cast below cannot be dropped, otherwise the
            engine would find itself with an integer to be subtracted from a string:</para>
            <programlisting>select date 'today' - 7 from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The following table shows the type conversions possible with
      <database>CAST</database>.</para>
      <table id="langrefupd20-tbl-cast">
        <title>Possible <database>CAST</database>s</title>
        <tgroup cols="2">
          <colspec colname="colFromType" />
          <colspec colname="colToType" />
          <thead>
            <row valign="top">
              <entry>From</entry>
              <entry>To</entry>
            </row>
          </thead>
          <tbody>
            <row valign="top">
              <entry><simplelist>
                  <member>Numeric types</member>
                </simplelist></entry>
              <entry><simplelist>
                  <member>Numeric types</member>
                  <member><database>[VAR]CHAR</database></member>
                </simplelist></entry>
            </row>
            <row valign="top">
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                </simplelist></entry>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member>Numeric types</member>
                  <member><database>DATE</database></member>
                  <member><database>TIME</database></member>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
            </row>
            <row valign="top">
              <entry><simplelist>
                  <member><database>DATE</database></member>
                  <member><database>TIME</database></member>
                </simplelist></entry>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
            </row>
            <row valign="top">
              <entry><simplelist>
                  <member><database>TIMESTAMP</database></member>
                </simplelist></entry>
              <entry><simplelist>
                  <member><database>[VAR]CHAR</database></member>
                  <member><database>DATE</database></member>
                  <member><database>TIME</database></member>
                </simplelist></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Keep in mind that sometimes information is lost, for instance when you cast a
      <database>TIMESTAMP</database> to a <database>DATE</database>. Also, the fact that types are
      <database>CAST</database>-compatible is in itself no guarantee that a conversion will succeed.
      <quote><database>CAST</database>(123456789 as <database>SMALLINT</database>)</quote> will
      definitely result in an error, as will <quote><database>CAST</database>('Judgement Day' as
      <database>DATE</database>)</quote>.</para>
      <formalpara>
        <title>New in Firebird 2.0:</title>
        <para>You can now cast statement parameters to a datatype, as in:</para>
      </formalpara>
      <blockquote>
        <programlisting>cast (? as integer)</programlisting>
      </blockquote>
      <para>This gives you control over the type of input field set up by the engine. Please notice
      that with statement parameters, you always need a full-syntax cast – shorthand casts are not
      supported.</para>
    </section>
    <section id="langrefupd20-char-length">
      <title><database>CHAR_LENGTH()</database>, <database>CHARACTER_LENGTH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Gives the length in characters of the input string.</para>
      </formalpara>
      <note>
        <para>With arguments of type <database>CHAR</database>, this function returns the formal
        string length (i.e. the declared length of a field or variable). If you want to obtain the
        <quote>logical</quote> length, not counting the trailing spaces, right-<link
        linkend="langrefupd20-trim"><database>TRIM</database></link> the argument before passing it
        to <database>CHAR[ACTER]_LENGTH</database>.</para>
        <!--This is the case when
- CASTing to CHAR(n)
- Reading a CHAR(n) variable or table field

But e.g. a SUBSTRING result, although formally of the same length as the first
argument, has a CHAR_LENGTH (and strlen) equal to the 'FOR' argument or the
length to the end of the string, e.g:
SUBSTRING('Hello' from 3 for 2) is a CHAR(5) with CHAR_LENGTH 2
SUBSTRING('Hello' from 2) is a CHAR(5) with CHAR_LENGTH 4
SUBSTRING('Hello' from 2 for 8) is a CHAR(5) with CHAR_LENGTH 4

However, as soon as you CAST such substrings to a CHAR(n) or store them
in a CHAR(n) field or variable, the CHAR_LENGTH becomes n.

Another example: if you have a char(12) column with the string 'AB', it has
a CHAR_LENGTH of 12 and concatenation with '.' shows the 10 spaces. Now if
you select SUBSTRING(field from 2 for 2), you get a CHAR(12) with CHAR_LENGTH 2.
You see only an A, but concatenation with '.' shows there's a space behind it.

The conclusion must be (I think) that SUBSTRING puts a zero character after the
result, or maybe fills the entire formal length with zero chars.-->
      </note>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>CHAR_LENGTH (<replaceable>str</replaceable>)
CHARACTER_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select char_length('Hello!') from rdb$database
  -- returns 6</programlisting>
            <programlisting>select char_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 8</programlisting>
            <programlisting>select char_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 8; the fact that ü and ß take up two bytes each is irrelevant</programlisting>
            <programlisting>select char_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 24: all 24 <database>CHAR</database> positions count</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-bit-length"><database>BIT_LENGTH()</database></link>,
        <link linkend="langrefupd20-octet-length"><database>OCTET_LENGTH</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-coalesce">
      <title><database>COALESCE()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The <database>COALESCE</database> function takes two or more arguments and returns the
        value of the first non-<constant>NULL</constant> argument. If all the arguments evaluate to
        <constant>NULL</constant>, the result is <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>COALESCE (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> [, <replaceable>&lt;expN&gt;</replaceable> ... ])</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select 
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
  as FullName
from Persons</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This example picks the Nickname from the Persons table. If it happens to be
      <constant>NULL</constant>, it goes on to FirstName. If that too is <constant>NULL</constant>,
      <quote>Mr./Mrs.</quote> is used. Finally, it adds the family name. All in all, it tries to use
      the available data to compose a full name that is as informal as possible. Notice that this
      scheme only works if absent nicknames and first names are really <constant>NULL</constant>: if
      one of them is an empty string instead, <database>COALESCE</database> will happily return that
      to the caller.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>COALESCE</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd20-udf-nvl"><function>*nvl</function></link> external functions.</para>
      </note>
    </section>
    <section id="langrefupd20-extract">
      <title><database>EXTRACT()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB 6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Extracts and returns an element from a <database>DATE</database>,
        <database>TIME</database> or <database>TIMESTAMP</database> expression. It was already added
        in InterBase 6, but not documented in the <citetitle>Language Reference</citetitle> at the
        time.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>SMALLINT</database> or <database>DECIMAL(6,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>EXTRACT (<replaceable>&lt;part&gt;</replaceable> FROM <replaceable>&lt;datetime&gt;</replaceable>)

<replaceable>&lt;part&gt;</replaceable>      ::=  YEAR | MONTH | DAY | WEEKDAY | YEARDAY
                   | HOUR | MINUTE | SECOND
<replaceable>&lt;datetime&gt;</replaceable>  ::=  An expression of type DATE, TIME or TIMESTAMP</programlisting>
          </blockquote></para>
      </formalpara>
      <para>The returned datatype is <database>DECIMAL(6,4)</database> for the
      <database>SECOND</database> part and <database>SMALLINT</database> for all others. The ranges
      are shown in the table below.</para>
      <para>If you try to extract a part that isn't present in the date/time argument (e.g.
      <database>SECOND</database> from a <database>DATE</database> or <database>YEAR</database> from
      a <database>TIME</database>), an error occurs.</para>
      <table id="langrefupd20-tbl-extractranges">
        <title>Ranges for <database>EXTRACT</database> results</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Part</entry>
              <entry>Range</entry>
              <entry>Comment</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><database>YEAR</database></entry>
              <entry>1–9999</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MONTH</database></entry>
              <entry>1–12</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>DAY</database></entry>
              <entry>1–31</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>WEEKDAY</database></entry>
              <entry>0–6</entry>
              <entry>0 = Sunday</entry>
            </row>
            <row>
              <entry><database>YEARDAY</database></entry>
              <entry>0–365</entry>
              <entry>0 = January 1</entry>
            </row>
            <row>
              <entry><database>HOUR</database></entry>
              <entry>0–23</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>MINUTE</database></entry>
              <entry>0–59</entry>
              <entry></entry>
            </row>
            <row>
              <entry><database>SECOND</database></entry>
              <entry>0.0000–59.999</entry>
              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <!--Tested: year in a DATE (when casting from dd.mm.yyyy string) can be 0-9999 in Fb1.5;
0 and 10000 give errors.
IB 6.5 doc specifies 0-5400 here
Oddly enough, DatDef sez DATE and TIMESTAMP can range from 1 Jan 100 a.d. to 29 Feb 32768 a.d.-->
    </section>
    <section id="langrefupd20-genid">
      <title><database>GEN_ID()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Increments a generator or sequence and returns its new value. From Firebird 2.0
        onward, the SQL-compliant <database>NEXT VALUE FOR</database> syntax is preferred, except
        when an increment other than 1 is needed.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BIGINT</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>GEN_ID (<replaceable>generator-name</replaceable>, <replaceable>&lt;step&gt;</replaceable>)

<replaceable>&lt;step&gt;</replaceable>  ::=  An integer expression.</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>new.rec_id = gen_id(gen_recnum, 1);</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>Unless you know very well what you are doing, using <database>GEN_ID()</database> with
        step values lower than 1 may compromise your data's integrity.</para>
      </warning>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-nextvaluefor"><database>NEXT VALUE FOR</database></link>,
        <link linkend="langrefupd20-create-gen"><database>CREATE GENERATOR</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-iif">
      <title><database>IIF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>IIF</database> takes three arguments. If the first evaluates to
        <constant>true</constant>, the second argument is returned; otherwise the third is
        returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>IIF (<replaceable>&lt;condition&gt;</replaceable>, <replaceable>ResultT</replaceable>, <replaceable>ResultF</replaceable>)

<replaceable>&lt;condition&gt;</replaceable>  ::=  A boolean expression.</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select iif( sex = 'M', 'Sir', 'Madam' ) from Customers</programlisting>
          </blockquote></para>
      </formalpara>
      <para><database>IIF</database>(<parameter>Cond</parameter>, <parameter>Result1</parameter>,
      <parameter>Result2</parameter>) is a shortcut for <quote><database>CASE</database>
      <database>WHEN</database> <parameter>Cond</parameter> <database>THEN</database>
      <parameter>Result1</parameter> <database>ELSE</database> <parameter>Result2</parameter>
      <database>END</database></quote>. You can also compare <database>IIF</database> to the ternary
      <quote><literal>?</literal> <literal>:</literal></quote> operator in C-like languages.</para>
    </section>
    <section id="langrefupd20-lower">
      <title><database>LOWER()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the lower-case equivalent of the input string. This function also correctly
        lowercases non-ASCII characters, even if the default (binary) collation is used. The
        character set must be appropriate though: with <database>ASCII</database> or
        <database>NONE</database> for instance, only ASCII characters are lowercased; with
        <database>OCTETS</database>, the entire string is returned unchanged.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>(VAR)CHAR</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>LOWER (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <para>Because <database>LOWER</database> is a reserved word, the internal function wil take
        precedence even if the <link linkend="langrefupd20-udf-lower">external function by that
        name</link> has also been declared. To call the (inferior!) external function, use
        double-quotes and the exact capitalisation, as in
        <function>"LOWER"</function>(<replaceable>str</replaceable>).</para>
      </note>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select Sheriff from Towns
  where lower(Name) = 'cooper''s valley'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-upper"><database>UPPER</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-nullif">
      <title><database>NULLIF()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para><database>NULLIF</database> returns the value of the first argument, unless it is
        equal to the second. In that case, <constant>NULL</constant> is returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Depends on input.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>NULLIF (<replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>select avg( nullif(Weight, -1) ) from FatPeople</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This will return the average weight of the persons listed in FatPeople, excluding those
      having a weight of -1, since <database>AVG</database> skips <constant>NULL</constant> data.
      Presumably, -1 indicates <quote>weight unknown</quote> in this table. A plain
      <database>AVG</database>(Weight) would include the -1 weights, thus skewing the result.</para>
      <note>
        <para>In Firebird 1.0.x, where <database>NULLIF</database> is not available, you can
        accomplish the same with the <link
        linkend="langrefupd20-udf-nullif"><function>*nullif</function></link> external
        functions.</para>
      </note>
    </section>
    <section id="langrefupd20-octet-length">
      <title><database>OCTET_LENGTH()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Gives the length in bytes (octets) of the input string. For multi-byte character sets,
        this may be less than the number of characters times the <quote>formal</quote> number of
        bytes per character as found in <database>RDB$CHARACTER_SETS</database>.</para>
      </formalpara>
      <note>
        <para>With arguments of type <database>CHAR</database>, this function takes the entire
        formal string length (e.g. the declared length of a field or variable) into account. If you
        want to obtain the <quote>logical</quote> byte length, not counting the trailing spaces,
        right-<link linkend="langrefupd20-trim"><database>TRIM</database></link> the argument before
        passing it to <database>OCTET_LENGTH</database>.</para>
      </note>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>OCTET_LENGTH (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select octet_length('Hello!') from rdb$database
  -- returns 6</programlisting>
            <programlisting>select octet_length(_iso8859_1 'Grüß di!') from rdb$database
  -- returns 8: ü and ß take up one byte each in ISO8859_1</programlisting>
            <programlisting>select octet_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
  -- returns 10: ü and ß take up two bytes each in UTF8</programlisting>
            <programlisting>select octet_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
  -- returns 26: all 24 <database>CHAR</database> positions count, and two of them are 2-byte</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-bit-length"><database>BIT_LENGTH()</database></link>,
        <link linkend="langrefupd20-char-length"><database>CHARACTER_LENGTH</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-get-context">
      <title><database>RDB$GET_CONTEXT()</database></title>
      <note>
        <para><database>RDB$GET_CONTEXT</database> and its counterpart
        <database>RDB$SET_CONTEXT</database> are actually predeclared UDFs. They are listed here as
        internal functions because they are always present – the user doesn't have to do anything to
        make them available.</para>
      </note>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Since it's a declared UDF, it should be availabe in ESQL-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Retrieves the value of a context variable from one of the namespaces
        <database>SYSTEM</database>, <database>USER_SESSION</database> and
        <database>USER_TRANSACTION</database>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(255)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RDB$GET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>')

<replaceable>&lt;namespace&gt;</replaceable>  ::=  SYSTEM | USER_SESSION | USER_TRANSACTION
<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title role="block">The namespaces</title>
        <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
        namespaces are initially empty. The user can create and set variables in them with
        <database>RDB$SET_CONTEXT()</database> and retrieve them with
        <database>RDB$GET_CONTEXT()</database>. The <database>SYSTEM</database> namespace is
        read-only. It contains a number of predefined variables, shown in the table below.<table
            border="topbot" id="langrefupd20-tbl-systemnamespace">
            <title>Context variables in the SYSTEM namespace</title>
            <tgroup cols="2">
              <colspec colname="colVarname" colwidth="1*" />
              <colspec colname="colVardescr" colwidth="3*" />
              <tbody>
                <row valign="top">
                  <entry><varname>DB_NAME</varname></entry>
                  <entry>Either the full path to the database or – if connecting via the path is
                  disallowed – its alias.</entry>
                </row>
                <row valign="top">
                  <entry><varname>NETWORK_PROTOCOL</varname></entry>
                  <entry>The protocol used for the connection. Can be <literal>'TCPv4'</literal>,
                  <literal>'WNET'</literal>, <literal>'XNET'</literal> or
                  <constant>NULL</constant>.</entry>
                </row>
                <row valign="top">
                  <entry><varname>CLIENT_ADDRESS</varname></entry>
                  <entry>For TCPv4, this is the IP address. For XNET, the local process ID. For all
                  other protocols this variable is <constant>NULL</constant>.</entry>
                </row>
                <row valign="top">
                  <entry><varname>CURRENT_USER</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd20-current_user"><varname>CURRENT_USER</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>CURRENT_ROLE</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd20-current_role"><varname>CURRENT_ROLE</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>SESSION_ID</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd20-current_connection"><varname>CURRENT_CONNECTION</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>TRANSACTION_ID</varname></entry>
                  <entry>Same as global <link
                  linkend="langrefupd20-current_transaction"><varname>CURRENT_TRANSACTION</varname></link>
                  variable.</entry>
                </row>
                <row valign="top">
                  <entry><varname>ISOLATION_LEVEL</varname></entry>
                  <entry>The isolation level of the current transaction; can be
                  <literal>'READ</literal> <literal>COMMITTED'</literal>,
                  <literal>'SNAPSHOT'</literal> or <literal>'CONSISTENCY'</literal>.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </formalpara>
      <formalpara>
        <title>Return values and error behaviour</title>
        <para>If the polled variable exists in the given namespace, its value will be returned as a
        string of max. 255 characters. If the namespace doesn't exist or if you try to access a
        non-existing variable in the <database>SYSTEM</database> namespace, an error is raised. If
        you poll a non-existing variable in one of the other namespaces, <constant>NULL</constant>
        is returned. Both namespace and variable names must be given as single-quoted,
        case-sensitive, non-<constant>NULL</constant> strings.</para>
        <!--Funny enough, a variable's name may be the empty string.-->
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database</programlisting>
          </blockquote><blockquote>
            <programlisting>New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');</programlisting>
            <programlisting>insert into MyTable (TestField)
  values (rdb$get_context('USER_SESSION', 'MyVar'))</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd20-set-context"><database>RDB$SET_CONTEXT()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-set-context">
      <title><database>RDB$SET_CONTEXT()</database></title>
      <note>
        <para><database>RDB$SET_CONTEXT</database> and its counterpart
        <database>RDB$GET_CONTEXT</database> are actually predeclared UDFs. They are listed here as
        internal functions because they are always present – the user doesn't have to do anything to
        make them available.</para>
      </note>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
        <!--Since it's a declared UDF, it should be availabe in ESQL-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Creates, sets or unsets a variable in one of the user-writable namespaces
        <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>RDB$SET_CONTEXT ('<replaceable>&lt;namespace&gt;</replaceable>', '<replaceable>&lt;varname&gt;</replaceable>', <replaceable>&lt;value&gt;</replaceable> | <constant>NULL</constant>)

<replaceable>&lt;namespace&gt;</replaceable>  ::=  USER_SESSION | USER_TRANSACTION
<replaceable>&lt;varname&gt;</replaceable>    ::=  A case-sensitive string of max. 80 characters
<replaceable>&lt;value&gt;</replaceable>      ::=  A value of any type, as long as it's castable
                  to a VARCHAR(255)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title role="block">The namespaces</title>
        <para>The <database>USER_SESSION</database> and <database>USER_TRANSACTION</database>
        namespaces are initially empty. The user can create and set variables in them with
        <database>RDB$SET_CONTEXT()</database> and retrieve them with
        <database>RDB$GET_CONTEXT()</database>. The <database>USER_SESSION</database> context is
        bound to the current connection. Variables in <database>USER_TRANSACTION</database> only
        exist in the transaction in which they have been set. When the transaction ends, the context
        and all the variables defined in it are destroyed.</para>
      </formalpara>
      <formalpara>
        <title role="block">Return values and error behaviour</title>
        <para>The function returns 1 if the variable already existed before the call and 0 if it
        didn't. To remove a variable from a context, set it to <constant>NULL</constant>. If the
        given namespace doesn't exist, an error is raised. Both namespace and variable names must be
        entered as single-quoted, case-sensitive, non-<constant>NULL</constant> strings.</para>
        <!--Funny enough, a variable's name may be the empty string.-->
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database</programlisting>
          </blockquote><blockquote>
            <programlisting>rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);</programlisting>
            <programlisting>select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
  from rdb$database</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>The maximum number of variables in any single context is 1000.</para>
            </listitem>
            <listitem>
              <para>All <database>USER_TRANSACTION</database> variables will survive a <link
              linkend="langrefupd20-rollback-retain"><database>ROLLBACK RETAIN</database></link> or
              <link linkend="langrefupd20-rollback-to-savepoint"><database>ROLLBACK TO
              SAVEPOINT</database></link> unaltered, no matter at which point during the transaction
              they were set.</para>
            </listitem>
            <listitem>
              <para>Due to its UDF-like nature, <database>RDB$SET_CONTEXT</database> can – in PSQL
              only – be called like a void function, without assigning the result, as in the second
              example above. Regular internal functions don't allow this type of use.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link
        linkend="langrefupd20-get-context"><database>RDB$GET_CONTEXT()</database></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-substring">
      <title><database>SUBSTRING()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a substring starting at the given position, either to the end of the string or
        with a given length.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>(VAR)CHAR(<replaceable>n</replaceable>)</database><!--Also if used with text BLOBs > max varchar size? Test! Result is VARCHAR for 'small' BLOBs in 2.0. In 2.1 and 2.5 it's BLOB even then.
And with binary BLOBs in 2.0?--></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>SUBSTRING (<replaceable>str</replaceable> FROM <replaceable>pos</replaceable> [FOR <replaceable>len</replaceable>])

<replaceable>str</replaceable>  ::=  a string expression
<replaceable>pos</replaceable>  ::=  an integer expression
<replaceable>len</replaceable>  ::=  an integer expression</programlisting>
          </blockquote></para>
      </formalpara>
      <para>This function returns the substring starting at character position
      <replaceable>pos</replaceable> (the first position being 1). Without the optional
      <database>FOR</database> argument, it returns all the remaining characters in the string. With
      it, it returns <replaceable>len</replaceable> characters or the remainder of the string,
      whichever is shorter.</para>
      <para>Since Firebird 2.0, <database>SUBSTRING</database> fully supports multi-byte character
      sets.</para>
      <para>In Firebird 1.x, <replaceable>pos</replaceable> and <replaceable>len</replaceable> had
      to be be integer literals. In 2.0 and above they can be any valid integer expression.</para>
      <para>The result type is <database>VARCHAR</database> for a <database>VARCHAR</database> or
      <database>BLOB</database> argument, and <database>CHAR</database> for a
      <database>CHAR</database> or literal argument.</para>
      <para>The width – in characters – of the result field is always equal to the length of
      <replaceable>str</replaceable>, regardless of <replaceable>pos</replaceable> and
      <replaceable>len</replaceable>. So, <code>substring('pinhead' from 4 for 2)</code> will return
      a <database>CHAR(7)</database> containing the string <literal>'he'</literal>.</para>
      <para><database>SUBSTRING</database> can be used with:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>Any string, (var)char or text <database>BLOB</database> argument, regardless of its
          character set;<!--BLOBs must not be larger than max varchar size, I suppose.--></para>
        </listitem>
        <listitem>
          <para>Subtype 0 (binary) <database>BLOB</database>s.</para>
        </listitem>
      </itemizedlist>
      <formalpara>
        <title>Example</title>
        <para><blockquote>
            <programlisting>insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames</programlisting>
          </blockquote></para>
      </formalpara>
      <note>
        <title>Effect of <constant>NULL</constant>s</title>
        <itemizedlist>
          <listitem>
            <para>If <replaceable>str</replaceable> is <constant>NULL</constant>, the function
            returns <constant>NULL</constant>.</para>
            <!--With a NULL string, the result type is the type the NULL was cast to (possibly after subsequent conversion to char).
If the NULL was a literal (2.0+), the result type is CHAR(1).-->
          </listitem>
          <listitem>
            <para>If <replaceable>str</replaceable> is a valid string but
            <replaceable>pos</replaceable> and/or <replaceable>len</replaceable> is
            <constant>NULL</constant>, the function returns <constant>NULL</constant> but describes
            the result field as non-nullable. As a result, most clients (including
            <application>isql</application>) will incorrectly show the result as an empty
            string.</para>
            <!--Nullguide says: This bug seems to be fixed in 2.1.-->
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="langrefupd20-trim">
      <title><database>TRIM()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, PSQL</para>
        <!--ESQL: no-->
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Removes leading and/or trailing spaces (or optionally other strings) from the input
        string. The result is a <database>VARCHAR</database>(<replaceable>n</replaceable>) with
        <replaceable>n</replaceable> the formal length of the input string.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR</database>(<replaceable>n</replaceable>)</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>TRIM ([<replaceable>&lt;adjust&gt;</replaceable>] <replaceable>str</replaceable>)

<replaceable>&lt;adjust&gt;</replaceable>  ::=  {[<replaceable>where</replaceable>] [<replaceable>what</replaceable>]} FROM

<replaceable>where</replaceable>     ::=  BOTH | LEADING | TRAILING       /* default is BOTH */

<replaceable>what </replaceable>     ::=  The substring to be removed (repeatedly if necessary)
               from <replaceable>str</replaceable>'s head and/or tail. Default is ' ' (space).</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select trim ('  Waste no space   ') from rdb$database
  -- returns 'Waste no space'</programlisting>
            <programlisting>select trim (leading from '  Waste no space   ') from rdb$database
  -- returns 'Waste no space   '</programlisting>
            <programlisting>select trim (leading '.' from '  Waste no space   ') from rdb$database
  -- returns '  Waste no space   '</programlisting>
            <programlisting>select trim (trailing '!' from 'Help!!!!') from rdb$database
  -- returns 'Help'</programlisting>
            <programlisting>select trim ('la' from 'lalala I love you Ella') from rdb$database
  -- returns ' I love you El'</programlisting>
            <programlisting>select trim ('la' from 'Lalala I love you Ella') from rdb$database
  -- returns 'Lalala I love you El'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-upper">
      <title><database>UPPER()</database></title>
      <formalpara>
        <title>Available in</title>
        <para>DSQL, ESQL, PSQL</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the upper-case equivalent of the input string. Since Firebird 2 this function
        also correctly uppercases non-ASCII characters, even if the default (binary) collation is
        used. The character set must be appropriate though: with <database>ASCII</database> or
        <database>NONE</database> for instance, only ASCII characters are uppercased; with
        <database>OCTETS</database>, the entire string is returned unchanged.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>(VAR)CHAR</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>UPPER (<replaceable>str</replaceable>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Examples</title>
        <para><blockquote>
            <programlisting>select upper(_iso8859_1 'Débâcle')
from rdb$database
  -- returns 'DÉBÂCLE' (before Firebird 2.0: 'DéBâCLE')</programlisting>
            <programlisting>select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
  -- returns 'DEBACLE', following French uppercasing rules</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-lower"><database>LOWER</database></link></para>
      </formalpara>
    </section>
  </chapter>
  <chapter id="langrefupd20-udf">
    <title>External functions (UDFs)</title>
    <para>External functions must be <quote>declared</quote> (made known) to the database before
    they can be used. Firebird ships with two external function libraries:</para>
    <itemizedlist>
      <listitem>
        <para><systemitem class="library">ib_udf</systemitem> – inherited from InterBase;</para>
      </listitem>
      <listitem>
        <para><systemitem class="library">fbudf</systemitem> – a new library using <link
        linkend="langrefupd20-declareext-bydescriptor">descriptors</link>, present as from Firebird
        1.0 (Windows) and 1.5 (Linux).</para>
      </listitem>
    </itemizedlist>
    <para>Users can also create their own UDF libraries or acquire them from third parties.</para>
    <!--Wherever appropriate I used 32767 as a max string length, not 32765 (max. VARCHAR-length).
This is about what the function itself and the Firebird engine can handle when you call it
from your SQL, *not* about whether the result subsequently fits in a VARCHAR.-->
    <section id="langrefupd20-udf-addday">
      <title><function>addDay</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> days added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addday (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addDay
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addDay' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addhour">
      <title><function>addHour</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> hours added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addhour (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addHour
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addHour' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addmillisecond">
      <title><function>addMilliSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> milliseconds added.
        Use negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmillisecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMilliSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMilliSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addminute">
      <title><function>addMinute</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> minutes added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addminute (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMinute
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMinute' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addmonth">
      <title><function>addMonth</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> months added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addmonth (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addMonth
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addMonth' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addsecond">
      <title><function>addSecond</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> seconds added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addsecond (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addSecond
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addSecond' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addweek">
      <title><function>addWeek</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> weeks added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addweek (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addWeek
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addWeek' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-addyear">
      <title><function>addYear</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the first argument with <replaceable>number</replaceable> years added. Use
        negative numbers to subtract.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>addyear (<parameter>atimestamp</parameter>, <parameter>number</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION addYear
   TIMESTAMP, INT
   RETURNS TIMESTAMP
   ENTRY_POINT 'addYear' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-ascii_char">
      <title><function>ascii_char</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the ASCII character corresponding to the integer value passed in.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(1)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ascii_char (<parameter>intval</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ascii_char
   INTEGER <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(1) FREE_IT
   ENTRY_POINT 'IB_UDF_ascii_char' MODULE_NAME 'ib_udf'</programlisting>
            <para>The declaration reflects the fact that the UDF as such returns a 1-character C
            string, not an SQL <database>CHAR(1)</database> as stated in the InterBase declaration.
            The engine will pass the result to the caller as a <database>VARCHAR(1)</database>
            though.</para>
            <para>The <emphasis role="bold">NULL</emphasis> after INTEGER is an optional addition
            that became available in Firebird 2. When declared with the <database>NULL</database>
            keyword, the engine will pass a <constant>NULL</constant> argument unchanged to the
            function. This causes a <constant>NULL</constant> result, which is correct. Without the
            <database>NULL</database> keyword (your only option in pre-2.0 versions),
            <constant>NULL</constant> is passed to the function as 0 and the result is an empty
            string.</para>
            <!--Actually, the UDF fills in a \0 here (NUL character), but since it's a
C string, this acts as a string terminator so the result is an empty string.-->
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para><function>ascii_char(0)</function> returns an empty string in all versions, not
              a character with ASCII value 0.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was <database>CHAR(1)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-dow">
      <title><function>dow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the day of the week from a timestamp argument. The returned name may be
        localized.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(15)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dow
   TIMESTAMP,
   VARCHAR(15) RETURNS PARAMETER 2
   ENTRY_POINT 'DOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-udf-sdow"><function>sdow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-dpower">
      <title><function>dpower</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns <replaceable>x</replaceable> to the <replaceable>y</replaceable>'th
        power.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>dpower (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION dPower
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR,
   DOUBLE PRECISION BY DESCRIPTOR
   RETURNS PARAMETER 3
   ENTRY_POINT 'power' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-getexacttimestamp">
      <title><function>getExactTimestamp</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para><link
        linkend="langrefupd20-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link> or
        <link linkend="langrefupd20-now"><literal>'NOW'</literal></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the system time with milliseconds precision. This function was added because
        in pre-2.0 versions, <varname>CURRENT_TIMESTAMP</varname> always had
        <literal>.0000</literal> in the fractional part of the second. In Firebird 2.0 and up it is
        better to use <link
        linkend="langrefupd20-current_timestamp"><varname>CURRENT_TIMESTAMP</varname></link>, which
        now also defaults to milliseconds precision. To measure time intervals in PSQL modules, use
        <link linkend="langrefupd20-now"><literal>'NOW'</literal></link>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>TIMESTAMP</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>getexacttimestamp()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION getExactTimestamp
   TIMESTAMP RETURNS PARAMETER 1
   ENTRY_POINT 'getExactTimestamp' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-i64round">
      <title><function>i64round</function></title>
      <para>See <link linkend="langrefupd20-udf-round"><function>round</function></link>.</para>
    </section>
    <section id="langrefupd20-udf-i64truncate">
      <title><function>i64truncate</function></title>
      <para>See <link
      linkend="langrefupd20-udf-truncate"><function>truncate</function></link>.</para>
    </section>
    <section id="langrefupd20-udf-log">
      <title><function>log</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>In Firebird 1.5 and up, <function>log(x,y)</function> returns the the
        base-<parameter>x</parameter> logarithm of <parameter>y</parameter>. In Firebird 1.0.x and
        InterBase, it erroneously returns the base-<parameter>y</parameter> logarithm of
        <parameter>x</parameter>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>log (<parameter>x</parameter>, <parameter>y</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration (unchanged)</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION log
   DOUBLE PRECISION, DOUBLE PRECISION
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_log' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
      <warning>
        <para>If any of your pre-1.5 databases use <function>log</function>, check your PSQL and
        application code. It may contain workarounds to return the right results. Under Firebird 1.5
        and up, any such workarounds should be removed or you'll get the wrong results.</para>
      </warning>
    </section>
    <section id="langrefupd20-udf-lower">
      <title><function>lower</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd20-lower"><database>LOWER()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the lower-case version of the input string. Please notice that only ASCII
        characters are handled correctly. If possible, use the new, superior internal function <link
        linkend="langrefupd20-lower"><database>LOWER</database></link> instead.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>"LOWER" (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION "LOWER"
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lower' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>.
            <function>"LOWER"</function> has been surrounded by double-quotes because
            <database>LOWER</database>, being a reserved word, cannot be used as an identifier
            except when quoted. When you call the function, you also have to add the quotes and use
            the exact capitalization, otherwise the internal function will take precedence. (Most
            other internal function names are not reserved words; in those cases, the external
            function prevails if it is declared.)</para>
            <para>The <emphasis role="bold">NULL</emphasis> after CSTRING(255) is an optional
            addition that became available in Firebird 2. When declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument unchanged to the function. This leads to a <constant>NULL</constant> result,
            which is correct. Without the <database>NULL</database> keyword (your only option in
            pre-2.0 versions), <constant>NULL</constant> is passed to the function as an empty
            string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-lpad">
      <title><function>lpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string left-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>lpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, INTEGER, CSTRING(1) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis>s after the CSTRING arguments are an optional
            addition that became available in Firebird 2. If an argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant>s are passed to the function as
            empty strings and the result is a string with <replaceable>endlengh</replaceable>
            padchars (if <replaceable>str</replaceable> is <constant>NULL</constant>) or a copy of
            <replaceable>str</replaceable> itself (if <replaceable>padchar</replaceable> is
            <constant>NULL</constant>).</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>When calling this function, make sure <replaceable>endlength</replaceable> does
              not exceed the declared result length.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>endlength</replaceable> is less than
              <replaceable>str</replaceable>'s length, <replaceable>str</replaceable> is truncated
              to <replaceable>endlength</replaceable>. If <replaceable>endlength</replaceable> is
              negative, the result is <constant>NULL</constant>.</para>
            </listitem>
            <listitem>
              <para>A <constant>NULL</constant> <replaceable>endlength</replaceable> is treated as
              if it were 0.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>padchar</replaceable> is empty, or if
              <replaceable>padchar</replaceable> is <constant>NULL</constant> and the function has
              been declared without the <database>NULL</database> keyword after the last argument,
              <replaceable>str</replaceable> is returned unchanged (or truncated to
              <replaceable>endlength</replaceable>).</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>A bug that caused an endless loop if <replaceable>padchar</replaceable> was
              empty or <constant>NULL</constant> has been fixed in 2.0.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-ltrim">
      <title><function>ltrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd20-trim"><database>TRIM()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any leading space characters removed. In new code, you
        are advised to use the internal function <database><link
        linkend="langrefupd20-trim"><database>TRIM</database></link></database> instead, as it is
        both more powerful and more versatile.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>ltrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION ltrim
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_ltrim' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.0.x, this function returned <constant>NULL</constant> if the input
              string was either empty or <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-nullif">
      <title><function>*nullif</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd20-nullif"><database>NULLIF()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>*nullif</function> functions – for integers, bigints, doubles and
        strings, respectively – each return the first argument if it is not equal to the second. If
        the arguments are equal, the functions return <constant>NULL</constant>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>inullif   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nullif (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnullif   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snullif   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5, use of the internal function <link
      linkend="langrefupd20-nullif"><database>NULLIF</database></link> is preferred.</para>
      <warning>
        <title>Warnings</title>
        <itemizedlist>
          <listitem>
            <para>These functions return <constant>NULL</constant> when the second argument is
            <constant>NULL</constant>, even if the first argument is a proper value. This is a wrong
            result. The <database>NULLIF</database> internal function doesn't have this bug.</para>
          </listitem>
          <listitem>
            <para><function>i64nullif</function> and <function>dnullif</function> will return wrong
            and/or bizarre results if it is not 100% clear to the engine that each argument is of
            the intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE
            PRECISION</database>). If in doubt, cast them both explicitly to the declared type (see
            declarations below).</para>
          </listitem>
        </itemizedlist>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION inullif
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nullif
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS NUMERIC(18,4) BY DESCRIPTOR
   ENTRY_POINT 'iNullIf' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <programlisting>DECLARE EXTERNAL FUNCTION dnullif
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'dNullIf' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snullif
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNullIf' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-nvl">
      <title><function>*nvl</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd20-coalesce"><database>COALESCE()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>The four <function>nvl</function> functions – for integers, bigints, doubles and
        strings, respectively – are <constant>NULL</constant> replacers. They each return the first
        argument's value if it is not <constant>NULL</constant>. If the first argument is
        <constant>NULL</constant>, the value of the second argument is returned.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para>Varies, see declarations.</para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>invl   (<parameter>int1</parameter>, <parameter>int2</parameter>)
i64nvl (<parameter>bigint1</parameter>, <parameter>bigint2</parameter>)
dnvl   (<parameter>double1</parameter>, <parameter>double2</parameter>)
snvl   (<parameter>string1</parameter>, <parameter>string2</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <para>As from Firebird 1.5, use of the internal function <link
      linkend="langrefupd20-coalesce"><database>COALESCE</database></link> is preferred.</para>
      <warning>
        <para><function>i64nvl</function> and <function>dnvl</function> will return wrong and/or
        bizarre results if it is not absolutely clear to the engine that each argument is of the
        intended type (<database>NUMERIC(18,0)</database> or <database>DOUBLE PRECISION</database>).
        If in doubt, cast both arguments explicitly to the declared type (see declarations
        below).</para>
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION invl
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS INT BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64nvl
   NUMERIC(18,0) BY DESCRIPTOR, NUMERIC(18,0) BY DESCRIPTOR
   RETURNS NUMERIC(18,0) BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION dnvl
   DOUBLE PRECISION BY DESCRIPTOR, DOUBLE PRECISION BY DESCRIPTOR
   RETURNS DOUBLE PRECISION BY DESCRIPTOR
   ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION snvl
   VARCHAR(100) BY DESCRIPTOR, VARCHAR(100) BY DESCRIPTOR,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'sNvl' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-rand">
      <title><function>rand</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a pseudo-random number. Before Firebird 2.0, this function would first seed
        the random number generator with the current time in seconds. Multiple
        <function>rand()</function> calls within the same second would therefore return the same
        value. If you want that old behaviour in Firebird 2 and up, use the new function <link
        linkend="langrefupd20-udf-srand"><function>srand()</function></link>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>rand ()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rand
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_rand' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-right">
      <title><function>right</function></title>
      <para>See <link linkend="langrefupd20-udf-sright"><function>sright</function></link>.</para>
    </section>
    <section id="langrefupd20-udf-round">
      <title><function>round</function>, <function>i64round</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0.6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole number that is nearest to their (scaled
        numeric/decimal) argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18,4)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>round    (<parameter>number</parameter>)
i64round (<parameter>bignumber</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Halves are always rounded upward, i.e. away from zero for positive numbers and toward
        zero for negative numbers. For instance, <literal>3.5</literal> is rounded to
        <literal>4</literal>, but <literal>-3.5</literal> is rounded to
        <literal>-3</literal>.</para>
      </caution>
      <warning>
        <title>Bug alert</title>
        <para>In versions 2.0 through 2.0.5, these functions are <emphasis>broken</emphasis> for
        negative numbers:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>Anything between 0 and -0.6 (that's right: -0.6, not -0.5) is rounded to 0.</para>
          </listitem>
          <listitem>
            <para>Anything between -0.6 and -1 is rounded to +1 (<emphasis>plus</emphasis>
            1).</para>
          </listitem>
          <listitem>
            <para>Anything between -1 and -1.6 is rounded to -1.</para>
          </listitem>
          <listitem>
            <para>Anything between -1.6 and -2 is rounded to -2.</para>
          </listitem>
          <listitem>
            <para>Etcetera.</para>
          </listitem>
        </itemizedlist>
        <para>Fixed in 2.0.6 (backport from 2.5).</para>
        <!--http://tracker.firebirdsql.org/browse/CORE-2281
Fixed in Jan 2009 in 1.5, 2.0, 2.1, 2.5 and main branches.
Fix will be effective in 1.5.6, 2.0.6, 2.1.3 and 2.5-->
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>round</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'round' MODULE_NAME 'fbudf'</programlisting>
            <!--Why return numeric(18,4) ????? Ask Claudio! -> No clear answer-->
            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbround</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Round
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Round
   NUMERIC(18,4) BY DESCRIPTOR, NUMERIC(18,4) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbround' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under truncate:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names. From Firebird 2.0 onward you can
            also perform this update with <link
            linkend="langrefupd20-alter-ext-func"><database>ALTER EXTERNAL
            FUNCTION</database></link>.</para>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-rpad">
      <title><function>rpad</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.5</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string right-padded with <parameter>padchar</parameter>s until
        <parameter>endlength</parameter> is reached.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>rpad (<parameter>str</parameter>, <parameter>endlength</parameter>, <parameter>padchar</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rpad
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, INTEGER, CSTRING(1) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rpad' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis>s after the CSTRING arguments are an optional
            addition that became available in Firebird 2. If an argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant>s are passed to the function as
            empty strings and the result is a string with <replaceable>endlengh</replaceable>
            padchars (if <replaceable>str</replaceable> is <constant>NULL</constant>) or a copy of
            <replaceable>str</replaceable> itself (if <replaceable>padchar</replaceable> is
            <constant>NULL</constant>).</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>When calling this function, make sure <replaceable>endlength</replaceable> does
              not exceed the declared result length.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>endlength</replaceable> is less than
              <replaceable>str</replaceable>'s length, <replaceable>str</replaceable> is truncated
              to <replaceable>endlength</replaceable>. If <replaceable>endlength</replaceable> is
              negative, the result is <constant>NULL</constant>.</para>
            </listitem>
            <listitem>
              <para>A <constant>NULL</constant> <replaceable>endlength</replaceable> is treated as
              if it were 0.</para>
            </listitem>
            <listitem>
              <para>If <replaceable>padchar</replaceable> is empty, or if
              <replaceable>padchar</replaceable> is <constant>NULL</constant> and the function has
              been declared without the <database>NULL</database> keyword after the last argument,
              <replaceable>str</replaceable> is returned unchanged (or truncated to
              <replaceable>endlength</replaceable>).</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>A bug that caused an endless loop if <replaceable>padchar</replaceable> was
              empty or <constant>NULL</constant> has been fixed in 2.0.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-rtrim">
      <title><function>rtrim</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd20-trim"><database>TRIM()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string with any trailing space characters removed. In new code, you
        are advised to use the internal function <database><link
        linkend="langrefupd20-trim"><database>TRIM</database></link></database> instead, as it is
        both more powerful and more versatile.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>rtrim (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION rtrim
   CSTRING(255) <emphasis role="bold">NULL</emphasis>
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_rtrim' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.0.x, this function returned <constant>NULL</constant> if the input
              string was either empty or <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-sdow">
      <title><function>sdow</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the abbreviated day of the week from a timestamp argument. The returned
        abbreviation may be localized.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(5)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sdow (<parameter>atimestamp</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sdow
   TIMESTAMP,
   VARCHAR(5) RETURNS PARAMETER 2
   ENTRY_POINT 'SDOW' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>See also</title>
        <para><link linkend="langrefupd20-udf-dow"><function>dow</function></link></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-srand">
      <title><function>srand</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Seeds the random number generator with the current time in seconds and then returns
        the first number. Multiple <function>srand()</function> calls within the same second will
        return the same value. This is exactly how <link
        linkend="langrefupd20-udf-srand"><function>rand()</function></link> behaved before Firebird
        2.0.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>DOUBLE PRECISION</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>srand ()</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION srand
   RETURNS DOUBLE PRECISION BY VALUE
   ENTRY_POINT 'IB_UDF_srand' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-sright">
      <title><function>sright</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the rightmost <replaceable>numchars</replaceable> characters of the input
        string. Only works with 1-byte character sets.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(100)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>sright (<parameter>str</parameter>, <parameter>numchars</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION sright
   VARCHAR(100) BY DESCRIPTOR, SMALLINT,
   VARCHAR(100) BY DESCRIPTOR RETURNS PARAMETER 3
   ENTRY_POINT 'right' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-string2blob">
      <title><function>string2blob</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the input string as a <database>BLOB</database>.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>BLOB</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>string2blob (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION string2blob
   VARCHAR(300) BY DESCRIPTOR,
   BLOB RETURNS PARAMETER 2
   ENTRY_POINT 'string2blob' MODULE_NAME 'fbudf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-strlen">
      <title><function>strlen</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>IB</para>
      </formalpara>
      <formalpara>
        <title>Better alternatives</title>
        <para>Internal functions <link
        linkend="langrefupd20-bit-length"><database>BIT_LENGTH()</database></link>, <link
        linkend="langrefupd20-char-length"><database>CHAR[ACTER]_LENGTH</database></link> and <link
        linkend="langrefupd20-octet-length"><database>OCTET_LENGTH()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the length of the argument string.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>strlen (<parameter>str</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION strlen
   CSTRING(32767)
   RETURNS INTEGER BY VALUE
   ENTRY_POINT 'IB_UDF_strlen' MODULE_NAME 'ib_udf'</programlisting>
          </blockquote></para>
      </formalpara>
    </section>
    <section id="langrefupd20-udf-substr">
      <title><function>substr</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.0, 1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns a string's substring from <parameter>startpos</parameter> to
        <parameter>endpos</parameter>, inclusively. Positions are 1-based. If
        <parameter>endpos</parameter> is past the end of the string, <function>substr</function>
        returns all the characters from <parameter>startpos</parameter> to the end of the string.
        This function only works correctly with single-byte characters.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax (unchanged)</title>
        <para><blockquote>
            <programlisting>substr (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>endpos</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substr
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substr' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
            <listitem>
              <para>In InterBase, <function>substr</function> returned <constant>NULL</constant> if
              <parameter>endpos</parameter> lay past the end of the string.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <tip>
        <para>Although the function arguments are slightly different, consider using the internal
        SQL function <link linkend="langrefupd20-substring"><database>SUBSTRING</database></link>
        instead, for better compatibility and multi-byte character set support.</para>
      </tip>
    </section>
    <section id="langrefupd20-udf-substrlen">
      <title><function>substrlen</function></title>
      <formalpara>
        <title>Library</title>
        <para>ib_udf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5.2, 2.0</para>
      </formalpara>
      <formalpara>
        <title>Better alternative</title>
        <para>Internal function <link
        linkend="langrefupd20-substring"><database>SUBSTRING()</database></link></para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>Returns the substring starting at <parameter>startpos</parameter> and having
        <parameter>length</parameter> characters (or less, if the end of the string is reached
        first). Positions are 1-based. If either <parameter>startpos</parameter> or
        <parameter>length</parameter> is smaller than 1, an empty string is returned. This function
        only works correctly with single-byte characters.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>VARCHAR(<replaceable>n</replaceable>)<!--Why wasn't this change documented?--></database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>substrlen (<parameter>str</parameter>, <parameter>startpos</parameter>, <parameter>length</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Declaration</title>
        <para><blockquote>
            <programlisting>DECLARE EXTERNAL FUNCTION substrlen
   CSTRING(255) <emphasis role="bold">NULL</emphasis>, SMALLINT, SMALLINT
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_substrlen' MODULE_NAME 'ib_udf'</programlisting>
            <para>The above declaration is from the file <filename>ib_udf2.sql</filename>. The
            <emphasis role="bold">NULL</emphasis> after the argument is an optional addition that
            became available in Firebird 2. If the argument is declared with the
            <database>NULL</database> keyword, the engine will pass a <constant>NULL</constant>
            argument value unchanged to the function. This leads to a <constant>NULL</constant>
            result, which is correct. Without the <database>NULL</database> keyword (your only
            option in pre-2.0 versions), <constant>NULL</constant> is passed to the function as an
            empty string and the result is an empty string as well.</para>
            <para>For more information about passing <constant>NULL</constant>s to UDFs, see the
            <link linkend="langrefupd20-notes-udf-null">note</link> at the end of this book.</para>
          </blockquote></para>
      </formalpara>
      <formalpara>
        <title>Notes</title>
        <para><itemizedlist>
            <listitem>
              <para>Depending on how you declare it (see <link
              linkend="langrefupd20-notes-cstring"><database>CSTRING</database> note</link>), this
              function can accept and return strings of up to 32767 characters.</para>
            </listitem>
            <listitem>
              <para>Before Firebird 2.0, the result type was
              <database>CHAR(<replaceable>n</replaceable>)</database>.</para>
            </listitem>
            <listitem>
              <para>In Firebird 1.5.1 and below, the default declaration used
              <database>CSTRING(80)</database> instead of <database>CSTRING(255)</database>.</para>
            </listitem>
          </itemizedlist></para>
      </formalpara>
      <tip>
        <para>Firebird 1.0 has also implemented the internal SQL function <link
        linkend="langrefupd20-substring"><database>SUBSTRING</database></link>, effectively
        rendering <function>substrlen</function> obsolete in the same version in which it was
        introduced. <database>SUBSTRING</database> also supports multi-byte character sets. In new
        code, use <database>SUBSTRING</database>.</para>
      </tip>
    </section>
    <section id="langrefupd20-udf-truncate">
      <title><function>truncate</function>, <function>i64truncate</function></title>
      <formalpara>
        <title>Library</title>
        <para>fbudf</para>
      </formalpara>
      <formalpara>
        <title>Added in</title>
        <para>1.0 (Win), 1.5 (Linux)</para>
      </formalpara>
      <formalpara>
        <title>Changed in</title>
        <para>1.5, 2.0.6</para>
      </formalpara>
      <formalpara>
        <title>Description</title>
        <para>These functions return the whole-number portion of their (scaled numeric/decimal)
        argument. They do not work with floats or doubles.</para>
      </formalpara>
      <formalpara>
        <title>Result type</title>
        <para><database>INTEGER</database> / <database>NUMERIC(18)</database></para>
      </formalpara>
      <formalpara>
        <title>Syntax</title>
        <para><blockquote>
            <programlisting>truncate    (<parameter>number</parameter>)
i64truncate (<parameter>bignumber</parameter>)</programlisting>
          </blockquote></para>
      </formalpara>
      <caution>
        <para>Both functions round to the nearest whole number that is lower than or equal to the
        argument. This means that negative numbers are also <quote>truncated</quote> downward. For
        instance, <function>truncate(<parameter>-2.37</parameter>)</function> returns
        <literal>-3</literal>.</para>
      </caution>
      <warning>
        <title>Bug alert</title>
        <para>Contrary to what's mentioned above, in versions 2.0 through 2.0.5 anything between -1
        and 0 is truncated to 0. This anomaly has been corrected in Firebird 2.0.6 and above (as a
        backport from 2.5).</para>
        <!--http://tracker.firebirdsql.org/browse/CORE-2282
Fixed in Jan 2009 in 1.5, 2.0, 2.1, 2.5 and main branches.
Fix will be effective in 1.5.6, 2.0.6, 2.1.3 and 2.5-->
      </warning>
      <formalpara>
        <title>Declarations</title>
        <para><blockquote>
            <para>In Firebird 1.0.x, the entry point for both functions is
            <function>truncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'truncate' MODULE_NAME 'fbudf'</programlisting>
            <para>In Firebird 1.5, the entry point has been renamed to
            <function>fbtruncate</function>:</para>
            <programlisting>DECLARE EXTERNAL FUNCTION Truncate
   INT BY DESCRIPTOR, INT BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <programlisting>DECLARE EXTERNAL FUNCTION i64Truncate
   NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
   RETURNS PARAMETER 2
   ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf'</programlisting>
            <!--Keep the line below in sync with that under round:-->
            <para>If you move an existing database from Firebird 1.0.x to 1.5 or higher, drop any
            existing <function>*round</function> and <function>*truncate</function> declarations and
            declare them anew, using the updated entry point names. From Firebird 2.0 onward you can
            also perform this update with <link
            linkend="langrefupd20-alter-ext-func"><database>ALTER EXTERNAL
            FUNCTION</database></link>.</para>
          </blockquote></para>
      </formalpara>
    </section>
  </chapter>
  <appendix id="langrefupd20-notes">
    <title>Notes</title>
    <section id="langrefupd20-notes-charset-none">
      <title>Character set <database>NONE</database> data accepted <quote>as is</quote></title>
      <subtitle>In Firebird 1.5.1 and up</subtitle>
      <para>Firebird 1.5.1 has improved the way character set <database>NONE</database> data are
      moved to and from fields or variables with another character set, resulting in fewer
      transliteration errors.</para>
      <para>In Firebird 1.5.0, from a client connected with character set <database>NONE</database>,
      you could read data in two incompatible character sets – such as <database>SJIS</database>
      (Japanese) and <database>WIN1251</database> (Russian) – even though you could not read one of
      those character sets while connected from a client with the other character set. Data would be
      received <quote>as is</quote> and be stored without raising an exception.</para>
      <para>However, from this character set <database>NONE</database> client connection, an attempt
      to update any Russian or Japanese data columns using either parameterized queries or literal
      strings without introducer syntax would fail with transliteration errors; and subsequent
      queries on the stored <quote><database>NONE</database></quote> data would similarly
      fail.</para>
      <para>In Firebird 1.5.1, both problems have been circumvented. Data received from the client
      in character set <database>NONE</database> are still stored <quote>as is</quote> but what is
      stored is an exact, binary copy of the received string. In the reverse case, when stored data
      are read into this client from columns with specific character sets, there will be no
      transliteration error. When the connection character set is <database>NONE</database>, no
      attempt is made in either case to resolve the string to well-formed characters, so neither the
      write nor the read will throw a transliteration error.</para>
      <para>This opens the possibility for working with data from multiple character sets in a
      single database, as long as the connection character set is <database>NONE</database>. The
      client has full responsibility for submitting strings in the appropriate character set and
      converting strings returned by the engine, as needed.</para>
      <para>Abstraction layers that have to manage this can read the low byte of the
      <structfield>sqlsubtype</structfield> field in the <structname>XSQLVAR</structname> structure,
      which contains the character set identifier.</para>
      <para>While character set <database>NONE</database> literals are accepted and implicitly
      stored in the character set of their context, the use of introducer syntax to coerce the
      character sets of literals is highly recommended when the application is handling literals in
      a mixture of character sets. This should avoid the string's being misinterpreted when the
      application shifts the context for literal usage to a different character set.</para>
      <note>
        <para>Coercion of the character set, using the introducer syntax or casting, is still
        required when handling heterogeneous character sets from a client context that is anything
        other than <database>NONE</database>. Both methods are shown below, using character set
        <database>ISO8859_1</database> as an example target. Notice the
        <quote><literal>_</literal></quote> prefix in the introducer syntax.</para>
        <variablelist>
          <varlistentry>
            <term>Introducer syntax:</term>
            <listitem>
              <para><code>_ISO8859_1 <replaceable>mystring</replaceable></code></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Casting:</term>
            <listitem>
              <para><code>CAST (<replaceable>mystring</replaceable> AS
              VARCHAR(<replaceable>n</replaceable>) CHARACTER SET ISO8859_1)</code></para>
            </listitem>
          </varlistentry>
        </variablelist>
      </note>
    </section>
    <section id="langrefupd20-notes-withlock">
      <title>Understanding the <database>WITH LOCK</database> clause</title>
      <para>This note looks a little deeper into explicit locking and its ramifications. The
      <database>WITH LOCK</database> feature, added in Firebird 1.5, provides a limited explicit
      pessimistic locking capability for cautious use in conditions where the affected row set
      is:<orderedlist numeration="loweralpha" spacing="compact">
          <listitem>
            <para>extremely small (ideally, a singleton), <emphasis>and</emphasis></para>
          </listitem>
          <listitem>
            <para>precisely controlled by the application code.</para>
          </listitem>
        </orderedlist></para>
      <para>Pessimistic locks are rarely needed in Firebird. This is an expert feature, intended for
      use by those who thoroughly understand its consequences. Knowledge of the various levels of
      transaction isolation is essential. <database>WITH LOCK</database> is available in DSQL and
      PSQL, and only for top-level, single-table <database>SELECT</database>s. As stated in the
      reference part of this guide, <database>WITH LOCK</database> is <emphasis>not</emphasis>
      available:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>in a subquery specification;</para>
        </listitem>
        <listitem>
          <para>for joined sets;</para>
        </listitem>
        <listitem>
          <para>with the <database>DISTINCT</database> operator, a <database>GROUP BY</database>
          clause or any other aggregating operation;</para>
        </listitem>
        <listitem>
          <para>with a view;</para>
        </listitem>
        <listitem>
          <para>with the output of a selectable stored procedure;</para>
        </listitem>
        <listitem>
          <para>with an external table.</para>
        </listitem>
      </itemizedlist>
      <section id="langrefupd20-appx-withlock-syntax">
        <title>Syntax and behaviour</title>
        <blockquote>
          <programlisting>SELECT ... FROM <replaceable>single_table</replaceable>
   [WHERE ...]
   [FOR UPDATE [OF ...]]
   [WITH LOCK]</programlisting>
        </blockquote>
        <para>If the <database>WITH LOCK</database> clause succeeds, it will secure a lock on the
        selected rows and prevent any other transaction from obtaining write access to any of those
        rows, or their dependants, until your transaction ends.</para>
        <para>If the <database>FOR UPDATE</database> clause is included, the lock will be applied to
        each row, one by one, as it is fetched into the server-side row cache. It becomes possible,
        then, that a lock which appeared to succeed when requested will nevertheless <emphasis>fail
        subsequently</emphasis>, when an attempt is made to fetch a row which becomes locked by
        another transaction.</para>
        <para>As the engine considers, in turn, each record falling under an explicit lock
        statement, it returns either the record version that is the most currently committed,
        regardless of database state when the statement was submitted, or an exception.</para>
        <para>Wait behaviour and conflict reporting depend on the transaction parameters specified
        in the TPB block:</para>
        <table id="langrefupd20-tbl-tpb-effects">
          <title>How TPB settings affect explicit locking</title>
          <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*" />
            <colspec align="left" colname="behaviour" colwidth="3*" />
            <thead>
              <row>
                <entry align="center">TPB mode</entry>
                <entry align="center">Behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row valign="top">
                <entry><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explicit locks are overridden by implicit or explicit
                table-level locks and are ignored.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If a record is modified by any transaction that was
                committed since the transaction attempting to get explicit lock started, or an
                active transaction has performed a modification of this record, an update conflict
                exception is raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_concurrency</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If the record is modified by any transaction that has
                committed since the transaction attempting to get explicit lock started, an update
                conflict exception is raised immediately.</para><para>If an active transaction is
                holding ownership on this record (via explicit locking or by a normal optimistic
                write-lock) the transaction attempting the explicit lock waits for the outcome of
                the blocking transaction and, when it finishes, attempts to get the lock on the
                record again. This means that, if the blocking transaction committed a modified
                version of this record, an update conflict exception will be raised.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or normal update), an update conflict exception is
                raised immediately.</para></entry>
              </row>
              <row valign="top">
                <entry><para>isc_tpb_read_committed</para><para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on
                this record (via explicit locking or by a normal optimistic write-lock), the
                transaction attempting the explicit lock waits for the outcome of blocking
                transation and when it finishes, attempts to get the lock on the record
                again.</para><para>Update conflict exceptions can never be raised by an explicit
                lock statement in this TPB mode.</para></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="langrefupd20-appx-withlock-engine">
        <title>How the engine deals with <database>WITH LOCK</database></title>
        <para>When an <database>UPDATE</database> statement tries to access a record that is locked
        by another transaction, it either raises an update conflict exception or waits for the
        locking transaction to finish, depending on TPB mode. Engine behaviour here is the same as
        if this record had already been modified by the locking transaction.</para>
        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>
        <para>The engine guarantees that all records returned by an explicit lock statement are
        actually locked and <emphasis>do</emphasis> meet the search conditions specified in
        <database>WHERE</database> clause, as long as the search conditions do not depend on any
        other tables, via joins, subqueries, etc. It also guarantees that rows not meeting the
        search conditions will not be locked by the statement. It can <emphasis>not</emphasis>
        guarantee that there are no rows which, though meeting the search conditions, are not
        locked.</para>
        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during
          the course of the locking statement's execution.</para>
        </note>
        <para>The engine locks rows at fetch time. This has important consequences if you lock
        several rows at once. Many access methods for Firebird databases default to fetching output
        in packets of a few hundred rows (<quote>buffered fetches</quote>). Most data access
        components cannot bring you the rows contained in the last-fetched packet, where an error
        occurred.</para>
      </section>
      <section id="langrefupd20-appx-withlock-of">
        <title>The optional <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> sub-clause</title>
        <para>The <database>FOR UPDATE</database> clause provides a technique to prevent usage of
        buffered fetches, optionally with the <quote><database>OF</database>
        <replaceable>&lt;column-names&gt;</replaceable></quote> subclause to enable positioned
        updates.</para>
        <tip>
          <para>Alternatively, it may be possible in your access components to set the size of the
          fetch buffer to 1. This would enable you to process the currently-locked row before the
          next is fetched and locked, or to handle errors without rolling back your
          transaction.</para>
        </tip>
      </section>
      <section id="langrefupd20-appx-withlock-caveats">
        <title>Caveats using <database>WITH LOCK</database></title>
        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were
            taken under that savepoint, but it doesn't notify waiting transactions. Applications
            should not depend on this behaviour as it may get changed in the future.</para>
          </listitem>
          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict
            errors, the volume of deadlock errors will grow unless you design your locking strategy
            carefully and control it rigorously.</para>
          </listitem>
          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit
            locks are (1) to prevent expensive handling of update conflict errors in heavily loaded
            applications and (2) to maintain integrity of objects mapped to a relational database in
            a clustered environment. If your use of explicit locking doesn't fall in one of these
            two categories, then it's the wrong way to do the task in Firebird.</para>
          </listitem>
          <listitem>
            <para>Explicit locking is an advanced feature; do not misuse it! While solutions for
            these kinds of problems may be very important for web sites handling thousands of
            concurrent writers, or for ERP/CRM systems operating in large corporations, most
            application programs do not need to work in such conditions.</para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="langrefupd20-appx-withlock-examples">
        <title>Examples using explicit locking</title>
        <orderedlist numeration="lowerroman">
          <listitem>
            <para>Simple:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK</programlisting>
          </listitem>
          <listitem>
            <para>Multiple rows, one-by-one processing with DSQL cursor:</para>
            <programlisting>SELECT * FROM DOCUMENT WHERE PARENT_ID=?
   FOR UPDATE WITH LOCK</programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section id="langrefupd20-notes-cstring">
      <title>A note on <database>CSTRING</database> parameters</title>
      <para>External functions involving strings often use the type
      <database>CSTRING(<replaceable>n</replaceable>)</database> in their declarations. This type
      represents a zero-terminated string of maximum length <replaceable>n</replaceable>. Most of
      the functions handling <database>CSTRING</database>s are programmed in such a way that they
      can accept and return zero-terminated strings of any length. So why the
      <replaceable>n</replaceable>? Because the Firebird engine has to set up space to process the
      input an output parameters, and convert them to and from SQL data types. Most strings used in
      databases are only dozens to hundreds of bytes long; it would be a waste to reserve 32 KB of
      memory each time such a string is processed. Therefore, the <emphasis>standard</emphasis>
      declarations of most <database>CSTRING</database> functions – as found in the file
      <filename>ib_udf.sql</filename> – specify a length of 255 bytes. (In Firebird 1.5.1 and below,
      this default length is 80 bytes.) As an example, here's the SQL declaration of
      <function>lpad</function>:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION lpad
   CSTRING(255), INTEGER, CSTRING(1)
   RETURNS CSTRING(255) FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf'</programlisting>
      </blockquote>
      <para>Once you've declared a <database>CSTRING</database> parameter with a certain length, you
      cannot call the function with a longer input string, or cause it to return a string longer
      than the declared output length. But the standard declarations are just reasonable defaults;
      they're not cast in concrete, and you can change them if you want to. If you have to left-pad
      strings of up to 500 bytes long, then it's perfectly OK to change both 255's in the
      declaration to 500 or more.</para>
      <para>A special case is when you usually operate on short strings (say less then 100 bytes)
      but occasionally have to call the function with a huge <database>(VAR)CHAR</database>
      argument. Declaring <database>CSTRING(32000)</database> makes sure that all the calls will be
      successful, but it will also cause 32000 bytes per parameter to be reserved, even in that
      majority of cases where the strings are under 100 bytes. In that situation you may consider
      declaring the function twice, with different names and different string lengths:</para>
      <blockquote>
        <programlisting>DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpad</emphasis>
   <emphasis role="bold">CSTRING(100)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(100)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';

DECLARE EXTERNAL FUNCTION <emphasis role="bold">lpadbig</emphasis>
   <emphasis role="bold">CSTRING(32000)</emphasis>, INTEGER, CSTRING(1)
   RETURNS <emphasis role="bold">CSTRING(32000)</emphasis> FREE_IT
   ENTRY_POINT 'IB_UDF_lpad' MODULE_NAME 'ib_udf';</programlisting>
      </blockquote>
      <para>Now you can call <function>lpad()</function> for all the small strings and
      <function>lpadbig()</function> for the occasional monster. Notice how the declared names in
      the first line differ (they determine how you call the functions from within your SQL), but
      the entry point (the function name in the library) is the same in both cases.</para>
      <!--The Firebird Book states that the low default is there for security reasons, to prevent accidental or malicious overflow.-->
    </section>
    <section id="langrefupd20-notes-udf-null">
      <title>Passing <constant>NULL</constant> to UDFs in Firebird 2</title>
      <para>If a pre-2.0 Firebird engine must pass an SQL <constant>NULL</constant> argument to a
      user-defined function, it always converts it to a zero-equivalent, e.g. a numerical 0 or an
      empty string. The only exception to this rule are UDFs that make use of the
      <quote><database>BY DESCRIPTOR</database></quote> mechanism introduced in Firebird 1. The
      <systemitem class="library">fbudf</systemitem> library uses descriptors, but the vast majority
      of UDFs, including those in Firebird's standard <systemitem
      class="library">ib_udf</systemitem> library, still use the old style of parameter passing,
      inherited from InterBase.</para>
      <para>As a consequence, most UDFs can't tell the difference between <constant>NULL</constant>
      and zero input.</para>
      <para>Firebird 2 comes with a somewhat improved calling mechanism for these old-style UDFs.
      The engine will now pass <constant>NULL</constant> input as a null pointer to the function,
      <emphasis role="bold">if</emphasis> the function has been declared to the database with a
      <database>NULL</database> keyword after the argument(s) in question, e.g. like this:</para>
      <blockquote>
        <programlisting>declare external function ltrim
  cstring(255) <emphasis role="bold">null</emphasis>
  returns cstring(255) free_it
  entry_point 'IB_UDF_ltrim' module_name 'ib_udf';</programlisting>
      </blockquote>
      <para>This requirement ensures that existing databases and their applications can continue to
      function like before. Leave out the <database>NULL</database> keyword and the function will
      behave like it did under Firebird 1.5 and earlier.</para>
      <para>Please note that you can't just add <database>NULL</database> keywords to your
      declarations and then expect every function to handle <constant>NULL</constant> input
      correctly. Each function has to be (re)written in such a way that <constant>NULL</constant>s
      are dealt with correctly. Always look at the declarations provided by the function
      implementor. For the functions in the <systemitem class="library">ib_udf</systemitem> library,
      consult <filename>ib_udf2.sql</filename> in the Firebird <filename
      class="directory">UDF</filename> directory. Notice the <literal>2</literal> in the file name;
      the old-style declarations are in <filename>ib_udf.sql</filename>.</para>
      <para>These are the <systemitem class="library">ib_udf</systemitem> functions that have been
      updated to recognise <constant>NULL</constant> input and handle it properly:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><function>ascii_char</function></para>
        </listitem>
        <listitem>
          <para><function>lower</function></para>
        </listitem>
        <listitem>
          <para><function>lpad</function> and <function>rpad</function></para>
        </listitem>
        <listitem>
          <para><function>ltrim</function> and <function>rtrim</function></para>
        </listitem>
        <listitem>
          <para><function>substr</function> and <function>substrlen</function></para>
        </listitem>
      </itemizedlist>
      <para>Most <systemitem class="library">ib_udf</systemitem> functions remain as they were; in
      any case, passing <constant>NULL</constant> to an old-style UDF is never possible if the
      argument isn't of a referenced type.</para>
      <para>On a side note: don't use <function>lower</function>, <function>.trim</function> and
      <function>substr*</function> in new code; use the internal functions
      <database>LOWER</database>, <database>TRIM</database> and <database>SUBSTRING</database>
      instead.</para>
      <section id="langrefupd20-notes-udf-null-upgrade">
        <title><quote>Upgrading</quote> <systemitem class="library">ib_udf</systemitem> functions in
        an existing database</title>
        <para>If you are using an existing database with one or more of the functions listed above
        under Firebird 2, and you want to benefit from the improved <constant>NULL</constant>
        handling, run the script <filename>ib_udf_upgrade.sql</filename> against your database. It
        is located in the Firebird <filename class="directory">misc\upgrade\ib_udf</filename>
        directory.</para>
      </section>
    </section>
    <section id="langrefupd20-notes-maxindices">
      <title>Maximum number of indices in different Firebird versions</title>
      <para>Between Firebird 1.0 and 2.0 there have been quite a few changes to the maximum number
      of indices per database table. The table below sums them all up.</para>
      <table id="langrefupd20-tbl-maxindices-varversions">
        <title>Max. indices per table in Firebird 1.0 – 2.0</title>
        <tgroup cols="13">
          <colspec align="left" colname="colPageSize" />
          <colspec align="center" colname="colFb10_1" />
          <colspec align="center" colname="colFb10_2" />
          <colspec align="center" colname="colFb10_3" />
          <colspec align="center" colname="colFb103_1" />
          <colspec align="center" colname="colFb103_2" />
          <colspec align="center" colname="colFb103_3" />
          <colspec align="center" colname="colFb15_1" />
          <colspec align="center" colname="colFb15_2" />
          <colspec align="center" colname="colFb15_3" />
          <colspec align="center" colname="colFb20_1" />
          <colspec align="center" colname="colFb20_2" />
          <colspec align="center" colname="colFb20_3" />
          <spanspec align="center" nameend="colFb10_3" namest="colFb10_1" spanname="spanFb10" />
          <spanspec align="center" nameend="colFb103_3" namest="colFb103_1" spanname="spanFb103" />
          <spanspec align="center" nameend="colFb15_3" namest="colFb15_1" spanname="spanFb15" />
          <spanspec align="center" nameend="colFb20_3" namest="colFb20_1" spanname="spanFb20" />
          <spanspec align="center" nameend="colFb20_3" namest="colFb10_1" spanname="spanAllVersions" />
          <thead>
            <row valign="top">
              <entry align="left" morerows="2">Page size</entry>
              <entry spanname="spanAllVersions">Firebird version(s)</entry>
            </row>
            <row>
              <entry spanname="spanFb10">1.0, 1.0.2</entry>
              <entry spanname="spanFb103">1.0.3</entry>
              <entry spanname="spanFb15">1.5.x</entry>
              <entry spanname="spanFb20">2.0.x</entry>
            </row>
            <row>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
              <entry>1 col</entry>
              <entry>2 cols</entry>
              <entry>3 cols</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1024</entry>
              <entry>62</entry>
              <entry>50</entry>
              <entry>41</entry>
              <entry>62</entry>
              <entry>50</entry>
              <entry>41</entry>
              <entry>62</entry>
              <entry>50</entry>
              <entry>41</entry>
              <entry>50</entry>
              <entry>35</entry>
              <entry>27</entry>
            </row>
            <row>
              <entry>2048</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>126</entry>
              <entry>101</entry>
              <entry>84</entry>
              <entry>126</entry>
              <entry>101</entry>
              <entry>84</entry>
              <entry>101</entry>
              <entry>72</entry>
              <entry>56</entry>
            </row>
            <row>
              <entry>4096</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>254</entry>
              <entry>203</entry>
              <entry>169</entry>
              <entry>254</entry>
              <entry>203</entry>
              <entry>169</entry>
              <entry>203</entry>
              <entry>145</entry>
              <entry>113</entry>
            </row>
            <row>
              <entry>8192</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>510</entry>
              <entry>408</entry>
              <entry>340</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>408</entry>
              <entry>291</entry>
              <entry>227</entry>
            </row>
            <row>
              <entry>16384</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>65</entry>
              <entry>1022</entry>
              <entry>818</entry>
              <entry>681</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>257</entry>
              <entry>818</entry>
              <entry>584</entry>
              <entry>454</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </appendix>
  <appendix id="langrefupd20-dochist">
    <title>Document History</title>
    <para>The exact file history is recorded in the <filename class="directory">manual</filename>
    module in our CVS tree; see <ulink url="http://sourceforge.net/cvs/?group_id=9028"><ulink
    url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/</ulink></ulink></para>
    <para><revhistory>
        <revision>
          <revnumber>0.9</revnumber>
          <date>24 Sep 2008</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>First publication, based on the <citetitle>Firebird 1.5 Language Reference
            Update</citetitle> with all the changes for 2.0 added (roughly doubling the
            size).</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.0</revnumber>
          <date>8 Dec 2010</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>GLOBAL: Renamed all <quote>Deprecated in</quote> section headers to <quote>Better
            alternative</quote>. This also required editing the text immediately following the
            header and in some cases additional text in the section (if the
            <quote>deprecation</quote> was discussed in the section body).</para>
            <para><citetitle>Bookinfo</citetitle>: Added 2.0.6 to covered versions.</para>
            <para><citetitle>Introduction :: Versions covered</citetitle>: Added 2.0.6.</para>
            <para><citetitle>Introduction :: Authorship</citetitle>: Edited first paragraph. Added
            Frank Ingermann to contributor list.</para>
            <para><citetitle>Miscellaneous language elements</citetitle>: Added section
            <citetitle>Shorthand casts</citetitle>.</para>
            <para><citetitle>Data types and subtypes :: <database>BLOB</database> data
            type</citetitle>: In Description, <database>BLOB</database>s -&gt; text
            <database>BLOB</database>s. Also added information on new <constant>binary</constant>
            mnemonic + extra example.</para>
            <para><citetitle>Data types and subtypes :: New collations</citetitle>: Edited paragraph
            above table. Improved the two paragraphs below the table and moved them into a
            Note.</para>
            <para><citetitle>DDL statements :: <database>ALTER DATABASE</database></citetitle>:
            Merged difference file clauses onto one line in Syntax.</para>
            <para><citetitle>DDL statements :: <database>ALTER DOMAIN</database></citetitle>: Added
            section <citetitle>Rename domain</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>ALTER TABLE</database></citetitle>: Added
            section <citetitle><database>FOREIGN KEY</database> without target column references
            <database>PK</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>ALTER TRIGGER</database></citetitle>:
            Corrected formal syntax (can be called with just the trigger name and no
            modifications).</para>
            <para><citetitle>DDL statements :: <database>CREATE DATABASE</database></citetitle>:
            Moved Syntax one level up, marked it as partial and added <database>DIFFERENCE
            FILE</database> clause. Added new subsection <citetitle><database>DIFFERENCE
            FILE</database> parameter</citetitle>.</para>
            <para><citetitle>DDL statements</citetitle>: Added section <citetitle><database>CREATE
            EXCEPTION</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>CREATE INDEX</database></citetitle>: Edited
            Description and Syntax.</para>
            <para><citetitle>DDL statements :: <database>CREATE INDEX</database> :: Indexing on
            expressions</citetitle>: Edited Description.</para>
            <para><citetitle>DDL statements :: <database>CREATE INDEX</database> :: Maximum number
            of indices per table increased</citetitle>: Edited paragraph under table.</para>
            <para><citetitle>DDL statements :: <database>CREATE TABLE</database></citetitle>: Added
            section <citetitle><database>FOREIGN KEY</database> without target column references
            <database>PK</database></citetitle>.</para>
            <para><citetitle>DDL statements :: <database>CREATE VIEW</database> :: Full
            <database>SELECT</database> syntax supported</citetitle>: Added Note about the necessity
            of a full column list when using a union within a view (to become optional in
            2.5).</para>
            <para><citetitle>DDL statements :: <database>CREATE VIEW</database> ::
            <database>PLAN</database> subclause disallowed in 1.5</citetitle>: Changed title to
            <citetitle><database>PLAN</database> subclause disallowed in 1.5, reallowed in
            2.0</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>CREATE VIEW</database></citetitle>: Added
            subsection <citetitle>View with non-participating <database>NOT NULL</database> columns
            in base table can be made insertable</citetitle>.</para>
            <para><citetitle>DDL statements :: <database>DECLARE EXTERNAL
            FUNCTION</database></citetitle>: Added Note under Syntax.</para>
            <para><citetitle>DDL statements :: <database>DECLARE EXTERNAL FUNCTION</database> ::
            <database>BY DESCRIPTOR</database> parameter passing</citetitle>: Added <quote>Available
            in</quote>.</para>
            <para><citetitle>DDL statements :: <database>DECLARE EXTERNAL FUNCTION</database> ::
            <database>RETURNS PARAMETER</database> <replaceable>n</replaceable></citetitle>: Added
            <quote>Available in</quote>. Changed <literal>subclause</literal> -&gt;
            <literal>clause</literal> in Description (2x).</para>
            <para><citetitle>DDL statements :: <database>DECLARE FILTER</database></citetitle>:
            Edited Description. Added <replaceable>user_defined</replaceable> to Syntax. Added more
            info under Syntax block and made it an itemizedlist. Converted Tip to formalpara
            <citetitle>User-defined mnemonics</citetitle>.</para>
            <para><citetitle>DML statements :: <database>DELETE</database></citetitle>: Added
            <database>[AS]</database> to Syntax. Corrected syntax note on <database>WHERE CURRENT
            OF</database>.</para>
            <para><citetitle>DML statements :: <database>DELETE</database></citetitle>: Added
            subsection <citetitle><database>COLLATE</database> subclause for text
            <database>BLOB</database> columns</citetitle>.</para>
            <para><citetitle>DML statements :: <database>DELETE</database></citetitle>: Added
            subsection <citetitle>Relation alias makes real name unavailable</citetitle>.</para>
            <para><citetitle>DML statements :: <database>EXECUTE BLOCK</database></citetitle>:
            Edited Syntax block.</para>
            <para><citetitle>DML statements :: <database>INSERT</database></citetitle>: Added
            definition of <replaceable>&lt;select_expr&gt;</replaceable> to Syntax.</para>
            <para><citetitle>DML statements :: <database>INSERT</database> ::
            <database>RETURNING</database> clause</citetitle>: Edited Description. Added formalpara
            <quote>Note</quote>.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> :: Aggregate functions:
            Extended functionality :: Aggregate statements: Stricter <database>HAVING</database> and
            <database>ORDER BY</database></citetitle>: Edited second listitem. Edited last
            paragraph.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> ::
            <database>FIRST</database> and <database>SKIP</database></citetitle>: Added
            <quote>Available in</quote>.</para>
            <para><citetitle>DML statements :: <database>SELECT</database> :: Table alias must be
            used if present</citetitle>: Renamed to <citetitle>Relation alias makes real name
            unavailable</citetitle>. Also changed Description and paragraph before last
            example.</para>
            <para><citetitle>DML statements :: <database>UPDATE</database></citetitle>: Added
            <database>[AS]</database> to Syntax. Corrected syntax note on <database>WHERE CURRENT
            OF</database>.</para>
            <para><citetitle>DML statements :: <database>UPDATE</database></citetitle>: Added
            subsection <citetitle><database>COLLATE</database> subclause for text
            <database>BLOB</database> columns</citetitle>.</para>
            <para><citetitle>DML statements :: <database>UPDATE</database></citetitle>: Added
            subsection <citetitle>Relation alias makes real name unavailable</citetitle>.</para>
            <para><citetitle>Transaction control statements :: <database>SET
            TRANSACTION</database></citetitle>: Edited 2nd listitem after Syntax block.</para>
            <para><citetitle>PSQL statements</citetitle>: Changed introductory paragraph to mention
            executable blocks.</para>
            <para><citetitle>PSQL statements :: <database>DECLARE</database> ::
            <database>DECLARE</database> ... <database>CURSOR</database></citetitle>: Edited
            Description. Added Notes formalpara.</para>
            <para><citetitle>PSQL statements :: <database>DECLARE [VARIABLE]</database> with
            initialization</citetitle>: Indented var declarations in Example.</para>
            <para><citetitle>PSQL statements :: <database>EXCEPTION</database> :: Providing a custom
            error message</citetitle>: Added note about max message length.</para>
            <para><citetitle>PSQL statements :: <database>EXECUTE STATEMENT</database> :: Caveats
            with <database>EXECUTE STATEMENT</database></citetitle>: Changed SQL -&gt; DSQL in item
            4. Rewrote item 6.</para>
            <para><citetitle>PSQL statements</citetitle>: Added section <citetitle><database>FOR
            SELECT ... INTO ... DO</database></citetitle>.</para>
            <para><citetitle>PSQL statements</citetitle>: Added section <citetitle><database>WHERE
            CURRENT OF</database> invalid for view cursors</citetitle>.</para>
            <para><citetitle>Context variables :: <varname>CURRENT_CONNECTION</varname></citetitle>:
            Improved Description. Added note about upcoming change in 2.1 to last paragraph.</para>
            <para><citetitle>Context variables :: <varname>CURRENT_TIME</varname></citetitle>:
            Edited description. Removed Note and added Notes formalpara.</para>
            <para><citetitle>Context variables :: <varname>CURRENT_TIMESTAMP</varname></citetitle>:
            Edited description. Removed Note and added Notes formalpara.</para>
            <para><citetitle>Context variables ::
            <varname>CURRENT_TRANSACTION</varname></citetitle>: Improved Description.</para>
            <para><citetitle>Context variables :: <literal>'NOW'</literal></citetitle>: Added
            shorthand cast examples. Removed Note and added Notes formalpara.</para>
            <para><citetitle>Operators and predicates :: <database>||</database> (string
            concatenator)</citetitle>: New subsection <citetitle>Result type
            <database>VARCHAR</database></citetitle>.</para>
            <para><citetitle>Operators and predicates :: <database>||</database> (string
            concatenator) :: Overflow checking</citetitle>: Corrected <quote>Changed in</quote> and
            Description.</para>
            <para><citetitle>Internal functions :: <database>BIT_LENGTH()</database></citetitle>:
            Edited Note after Syntax block and placed it after Description.</para>
            <para><citetitle>Internal functions :: <database>CAST()</database></citetitle>: Added
            introductory paragraphs before 1st and 2nd example. Gave table rows top alignment. Added
            paragraph after <quote><literal>cast (? as integer)</literal></quote> example.</para>
            <para><citetitle>Internal functions :: <database>CHAR_LENGTH()</database>,
            <database>CHARACTER_LENGTH()</database></citetitle>: Edited Note after Syntax block and
            placed it after Description.</para>
            <para><citetitle>Internal functions :: <database>LOWER()</database></citetitle>:
            Corrected Result type: <database>VAR(CHAR)</database> -&gt;
            <database>(VAR)CHAR</database>.</para>
            <para><citetitle>Internal functions :: <database>OCTET_LENGTH()</database></citetitle>:
            Edited Note after Description.</para>
            <para><citetitle>Internal functions ::
            <database>RDB$GET_CONTEXT()</database></citetitle>: Added Note after title. Replaced
            <quote>general</quote> with <quote>global</quote> (4x) in System namespace table.</para>
            <para><citetitle>Internal functions ::
            <database>RDB$SET_CONTEXT()</database></citetitle>: Added Note after title. Altered 3rd
            listitem in Notes formalpara.</para>
            <para><citetitle>Internal functions :: <database>SUBSTRING()</database></citetitle>:
            Edited Result type, Syntax and much of the text in the rest of this section.</para>
            <para><citetitle>Internal functions :: <database>TRIM()</database></citetitle>:
            Edited/corrected Description, Result type and Syntax.</para>
            <para><citetitle>Internal functions :: <database>UPPER()</database></citetitle>:
            Corrected Result type: <database>VAR(CHAR)</database> -&gt;
            <database>(VAR)CHAR</database>. Corrected <quote>See also</quote> link:
            <database>UPPER</database> -&gt; <database>LOWER</database>.</para>
            <para><citetitle>External functions ::
            <function>getExactTimestamp</function></citetitle>: Edited <quote>Better
            alternative</quote> and Description.</para>
            <para><citetitle>External functions :: <function>log</function></citetitle>: Changed
            <function>log</function> -&gt; <function>log(x,y)</function> in Description.</para>
            <para><citetitle>External functions :: <function>right</function></citetitle>: moved to
            <citetitle><function>sright</function></citetitle> and left a symlink in place.</para>
            <para><citetitle>External functions :: <function>round</function>,
            <function>i64round</function></citetitle>: Added 2.0.6 to Changed in. Added Caution box.
            Edited and extended Bug warning box. Extended last paragraph.</para>
            <para>External functions: Added section
            <citetitle><function>strlen</function></citetitle>.</para>
            <para><citetitle>External functions :: <function>truncate</function>,
            <function>i64truncate</function></citetitle>: Added 2.0.6 to Changed in. Added Caution
            box. Edited Warning box. Extended last paragraph.</para>
            <para><citetitle>Notes :: Understanding the <database>WITH LOCK</database> clause ::
            Syntax and behaviour</citetitle>: In table, aligned 1st column left, all rows top, and
            added periods to sentences in first two rows.</para>
            <para><citetitle>License notice</citetitle>: Added Frank Ingermann as contributor.
            Copyright end year now 2010.</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.1</revnumber>
          <date>00 Xxx 2011</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para><citetitle>Introduction :: Subject matter</citetitle>: Changed ulink to Firebird
            Documentation Index (both text and url).</para>
            <para><citetitle>DDL statements :: <database>ALTER DATABASE</database> :: <database>END
            BACKUP</database></citetitle>: Updated URL of Firebird Documentation Index in
            Tip.</para>
            <para><citetitle>Context variables :: <varname>GDSCODE</varname></citetitle>: Rewrote
            Description in light of new, so far undocumented behaviour since Firebird 2.0. Corrected
            Example: after <database>WHEN GDSCODE</database> a symbolic name must follow, not a
            number. Added notice after Example to explain same.</para>
            <para><citetitle>Context variables :: <varname>SQLCODE</varname></citetitle>: Added
            <quote>Changed in</quote> formalpara. Rewrote Description in light of new, so far
            undocumented behaviour since Firebird 2.0.</para>
            <para><citetitle>Internal functions :: <database>LOWER()</database></citetitle>: Added
            Note after Syntax.</para>
            <para><citetitle>External functions :: <function>lower</function></citetitle>: Dropped
            last sentence from Description. Altered first paragraph after Declaration block and
            removed comment.</para>
            <para><citetitle>Document history</citetitle>: Link to CVS changed, points directly to
            manual module now.</para>
            <para><citetitle>License Notice</citetitle>: (C) end year now 2011.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>
  <appendix id="langrefupd20-license">
    <title>License notice</title>
    <para>The contents of this Documentation are subject to the Public Documentation License Version
    1.0 (the <quote>License</quote>); you may only use this Documentation if you comply with the
    terms of this License. Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>
    <para>The Original Documentation is titled <citetitle>Firebird 2.0 Language Reference
    Update</citetitle>.</para>
    <para>The Initial Writers of the Original Documentation are: Paul Vinkenoog et al.</para>
    <para>Copyright (C) 2008–2011 All Rights Reserved. Initial Writers contact: paul at vinkenoog
    dot nl.</para>
    <para>Writers and Editors of included PDL-licensed material (the <quote>al.</quote>) are: J.
    Beesley, Helen Borrie, Arno Brinkman, Frank Ingermann, Alex Peshkov, Nickolay Samofatov, Dmitry
    Yemanov.</para>
    <para>Included portions are Copyright (C) 2001-2007 by their respective authors. All Rights
    Reserved.</para>
  </appendix>
</book>
