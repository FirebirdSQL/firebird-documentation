<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../tools/docbook-dtd/docbookx.dtd">
<article id="gfix">
  <title>Firebird Database Housekeeping Utility</title>

  <titleabbrev>Gfix - Database Housekeeping</titleabbrev>

  <articleinfo>
    <date>20 October 2009</date>

    <author>
      <firstname>Norman</firstname>

      <surname>Dunbar</surname>
    </author>

    <edition>11 October 2011 â€“ Document version 1.3</edition>
  </articleinfo>

  <section id="gfix-intro">
    <title>Introduction</title>

    <para><application>Gfix</application> allows attempts to fix corrupted
    databases, starting and stopping of databases, resolving 'in limbo'
    transactions between multiple databases, changing the number of page
    buffers and so on. <application>Gfix</application> is a general purpose
    tool for system administrators (and database owners) to use to make
    various 'system level' changes to their databases.</para>

    <para>Almost all the <application>gfix</application> commands have the
    same format when typed on the command line:</para>

    <para><command>gfix [commands and parameters]
    database_name</command></para>

    <para>The commands and their options are described in the following
    sections. The database name is the name of the
    <emphasis>primary</emphasis> database file which for a single file
    database is simply the database name and for multi-file databases, it is
    the first data file added.</para>

    <para>Coming up in the remainder of this manual, we will discuss the
    following:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Command line options for the <application>gfix</application>
        database utility.</para>
      </listitem>

      <listitem>
        <para>Shadow file handling.</para>
      </listitem>

      <listitem>
        <para>Cache and buffer handling.</para>
      </listitem>

      <listitem>
        <para>Transaction management.</para>
      </listitem>

      <listitem>
        <para>Cache management.</para>
      </listitem>

      <listitem>
        <para>Starting and stopping a database.</para>
      </listitem>

      <listitem>
        <para>And much, much more ...</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="gfix-cmdline">
    <title>Command Line Options</title>

    <para>Running <application>gfix</application> without a command (or an
    invalid command), or with the new <userinput>-?</userinput> switch in
    Firebird 2.5, results in the following screen of helpful information being
    displayed:</para>

    <screen>usage: gfix [options] &lt;database&gt;
plausible options are:
        -activate       activate shadow file for database usage
        -attach         shutdown new database attachments
        -buffers        set page buffers &lt;n&gt;
        -commit         commit transaction &lt;tr / all&gt;
        -cache          shutdown cache manager
        -full           validate record fragments (-v)
        -force          force database shutdown
        -fetch_password fetch_password from file
        -housekeeping   set sweep interval &lt;n&gt;
        -ignore         ignore checksum errors
        -kill           kill all unavailable shadow files
        -list           show limbo transactions
        -mend           prepare corrupt database for backup
        -mode           read_only or read_write
        -no_update      read-only validation (-v)
        -online         database online &lt;single / multi / normal&gt;
        -prompt         prompt for commit/rollback (-l)
        -password       default password
        -rollback       rollback transaction &lt;tr / all&gt;
        -sql_dialect    set database dialect n
        -sweep          force garbage collection
        -shut           shutdown &lt;full / single / multi&gt;
        -two_phase      perform automated two-phase recovery
        -tran           shutdown transaction startup
        -use            use full or reserve space for versions
        -user           default user name
        -validate       validate database structure
        -write          write synchronously or asynchronously
        -z              print software version number

    qualifiers show the major option in parenthesis
</screen>
  </section>

  <section id="gfix-commands">
    <title><application>Gfix</application> Commands</title>

    <note>
      <para>In the following discussion, I use the full parameter names in all
      examples. This is not necessary as each command can be abbreviated. When
      the command is shown with '[' and ']' in the name then these are the
      optional characters.</para>

      <para>For example, the command <userinput>-validate</userinput> is shown
      as <userinput>-v[alidate]</userinput> and so can be specified as
      <userinput>-v</userinput>, <userinput>-va</userinput>,
      <userinput>-val</userinput> and so on up to the full
      <userinput>-validate</userinput> version.</para>
    </note>

    <para>For almost all of the options in the following sections, two of the
    above command line options will be required. These are
    <userinput>-u[ser]</userinput> and <userinput>-pa[ssword]</userinput>.
    These can be supplied for every command as parameters on the command line,
    or can be configured once in a pair of environment variables.</para>

    <itemizedlist spacing="normal">
      <listitem>
        <para><userinput>-?</userinput></para>

        <para>This switch displays the command line options and switches. It
        replaces the old method in which you had to supply an invalid switch
        (such as <userinput>-help</userinput>) in order to see the list of
        valid ones.</para>

        <note>
          <para>Firebird 2.5 onwards.</para>
        </note>
      </listitem>

      <listitem>
        <para><userinput>-FE[TCH_PASSWORD] &lt;password file name&gt; | stdin
        | /dev/tty</userinput></para>

        <para>This switch causes the password for the appropriate user to be
        read from a file as opposed to being specified on the command line.
        The file name supplied is <emphasis>not</emphasis> in quotes and must
        be readable by the user running <application>gfix</application>. If
        the file name is specified as <filename>stdin</filename>, then the
        user will be prompted for a password. On POSIX systems, the file name
        <filename class="devicefile">/dev/tty</filename> will also result in a
        prompt for the password.</para>

        <note>
          <para>Firebird 2.5 onwards.</para>
        </note>
      </listitem>

      <listitem>
        <para><userinput>-u[ser] username</userinput></para>

        <para>Allows the username of the SYSDBA user, or the owner of the
        database to be specified This need not be supplied if the
        <envar>ISC_USER</envar> environment variable has been defined and has
        the correct value.</para>
      </listitem>

      <listitem>
        <para><userinput>-pa[ssword] password</userinput></para>

        <para>Supplies the password for the username specified above. This
        need not be supplied if the <envar>ISC_PASSWORD</envar> environment
        variable has been defined and have the correct value.</para>

        <note>
          <para>Up until Firebird 2, any utility which was executed with a
          password on the command line could result in other users of the
          server seeing that password using a command like <command>ps -efx |
          grep -i pass</command>. From Firebird 2 onwards, this is no longer
          the case as the password on the command line can no longer be seen
          by the <command>ps</command> (or other) commands.</para>
        </note>
      </listitem>
    </itemizedlist>

    <para>To define the username and password as environment variables on a
    Linux system:</para>

    <screen>linux&gt; export ISC_USER=sysdba
linux&gt; export ISC_PASSWORD=masterkey</screen>

    <para>Alternatively, on Windows:</para>

    <screen>C:\&gt; set ISC_USER=sysdba
C:\&gt; set ISC_PASSWORD=masterkey</screen>

    <warning>
      <para>This is very insecure as it allows anyone who can access your
      session the ability to perform DBA functions that you might not want to
      allow.</para>
    </warning>

    <itemizedlist spacing="normal">
      <listitem>
        <para><userinput>-u[ser]</userinput> default user name</para>
      </listitem>

      <listitem>
        <para><userinput>-pa[ssword]</userinput> default password</para>
      </listitem>
    </itemizedlist>

    <para>If you have not defined the above environment variables, some
    commands will not work unless you supply <userinput>-u[ser]</userinput>
    and <userinput>-pa[ssword]</userinput> on the command line. For
    example:</para>

    <screen>linux&gt; gfix -validate my_employee
linux&gt; Unable to perform operation. You must be either SYSDBA -
or owner of the database</screen>

    <note>
      <para>The line that starts with 'Unable to perform' above, has had to be
      split to fit on the page of the PDF file. In reality, it is a single
      line.</para>
    </note>

    <para>However, passing the username and password works:</para>

    <screen>linux&gt; gfix -validate my_employee -user sysdba -password masterkey</screen>

    <para>You will notice, hopefully, that some commands do not give any
    printed output at all. <application>gfix</application>, in the main, only
    reports when problems are encountered. Always check the response code
    returned by <application>gfix</application> to be sure that it worked.
    However, see the caveats section below for details because it looks like
    the response code is always zero - at least up until Firebird 2.0.</para>

    <note>
      <para>When logging into a database on a remote server, you will always
      be required to pass the <userinput>-u[ser]</userinput> and
      <userinput>-pa[ssword]</userinput> parameters.</para>
    </note>
  </section>

  <section id="gfix-shadow">
    <title>Shadow Files</title>

    <para>A shadow file is an additional copy of the primary database file(s).
    More than one shadow file may exist for any given database and these may
    be activated and de-activated at will using the <application>gfix
    </application>utility.</para>

    <para>The following descriptions of activating and de-activating shadow
    files assume that a shadow file already exists for the database. To this
    end, a shadow was created as follows:</para>

    <screen>
linux&gt; isql my_employee;
SQL&gt; create shadow 1 manual '/home/norman/firebird/shadow/my_employee.shd1';
SQL&gt; create shadow 2 manual '/home/norman/firebird/shadow/my_employee.shd2';
SQL&gt; commit;
SQL&gt; show database;
Database: my_employee
 Owner: SYSDBA
 Shadow 1: "/home/norman/firebird/shadow/my_employee.shd1" manual
 Shadow 2: "/home/norman/firebird/shadow/my_employee.shd2" manual
...
SQL&gt; quit;
</screen>

    <para>It can be seen that the database now has two separate shadow files
    created, but as they are manual, they have not been activated. We can see
    that shadows are in use if we use <application>gstat</application> as
    follows:</para>

    <screen>linux&gt; gstat -header my_employee | grep -i shadow
Shadow count 2
</screen>

    <note>
      <para>Sometimes, it takes <application>gstat</application> a while to
      figure out that there are shadow files for the database.</para>
    </note>

    <note>
      <para>Shadow file details can be found in the
      <database>RDB$FILES</database> table within the database.</para>
    </note>

    <section id="gfix-shadow-activate">
      <title>Activating Shadows</title>

      <para>The command to activate a database shadow is:</para>

      <para><command>gfix -ac[tivate]
      &lt;shadow_file_name&gt;</command></para>

      <para>This makes the shadow file the new database file and the users are
      able to continue processing data as normal and without loss.</para>

      <para>In the event that your main database file(s) become corrupted or
      unreadable, the DBA can activate a shadow file. Once activated, the file
      is no longer a shadow file and a new one should be created to replace
      it. Additionally, the shadow file should be renamed (at the operating
      system prompt) to the name of the old database file that it
      replaces.</para>

      <warning>
        <para>It should be noted that activating a shadow while the database
        itself is active can lead to corruption of the shadow. Make sure that
        the database file is really unavailable before activating a
        shadow.</para>
      </warning>

      <para>Once a shadow file has been activated, you can see the fact that
      there are active shadows in the output from
      <application>gstat</application>:</para>

      <screen>linux&gt; gstat -header my_employee | grep -i shadow
Shadow count 2
Attributes   active shadow, multi-user maintenance    </screen>

      <note>
        <para>The DBA can set up the database to automatically create a new
        shadow file in the event of a current shadow being activated. This
        allows a continuous supply of shadow files and prevents the database
        ever running without one.</para>
      </note>
    </section>

    <section id="gfix-shadow-kill">
      <title>Killing Shadows</title>

      <para>The command to kill <emphasis>all unavailable</emphasis> database
      shadows, for a specific database, is:</para>

      <para><command>gfix -k[ill] database_name</command></para>

      <para>In the event that a database running with shadow files loses a
      shadow, or a shadow becomes unusable for some reason, the database will
      stop accepting new connections until such time as the DBA kills the
      faulty shadow and, ideally, creates a new shadow to replace the broken
      one.</para>

      <para>The following (contrived) example, shows what happens when the
      database loses a shadow file and an attempt is made to connect to that
      database. There are two sessions in the following example, one is
      connected to the database while the second deletes a shadow file and
      then tries to connect to the database. The command line prompts shows
      which of the two sessions we are using at the time.</para>

      <para>First, the initial session is connected to the database and can
      see that there are two shadow files attached:</para>

      <screen>linux_1&gt;isql my_employee
Database: my_employee
SQL&gt; show database;
Database: my_employee
   Owner: SYSDBA
Shadow 1: "/home/norman/firebird/shadow/my_employee.shd1" manual
Shadow 2: "/home/norman/firebird/shadow/my_employee.shd2" manual
 ...</screen>

      <para>In the second session, we delete one of the shadow files, and then
      try to connect to the database</para>

      <screen>linux_2&gt; rm /home/norman/firebird/shadow/my_employee.shd2
linux_2&gt; isql_my_employee
Statement failed, SQLCODE = -901
lock conflict on no wait transaction
-I/O error for file "/home/norman/firebird/shadow/my_employee.shd2"
-Error while trying to open file
-No such file or directory
-a file in manual shadow 2 in unavailable
Use CONNECT or CREATE DATABASE to specify a database
SQL&gt; quit; </screen>

      <para>The second session cannot connect to the database until the
      problem is fixed. The DBA would use the <command>gfix -k[ill]</command>
      command to remove details of the problem shadow file from the database
      and once completed, the second (and subsequent) sessions would be able
      to connect.</para>

      <screen>linux_2&gt; gfix -kill my_employee
 
linux_2&gt; isql my_employee
Database: my_employee
SQL&gt; show database;
Database: my_employee
   Owner: SYSDBA
Shadow 1: "/home/norman/firebird/shadow/my_employee.shd1" manual
...</screen>

      <para>The database now has a single shadow file where before it had two.
      It is noted, however, that <application>gstat</application> still shows
      the database as having two shadows, even when one has been
      removed.</para>

      <screen>linux&gt; gstat -header my_employee | grep -i shadow
Shadow count 2
Attributes   active shadow, multi-user maintenance</screen>

      <note>
        <para>In addition to the above strange result, if I subsequently
        <database>DROP SHADOW 1</database> and <database>COMMIT</database>, to
        remove the remaining shadow file, <application>gstat</application> now
        shows that the shadow count has gone up to three when it should have
        gone down to zero!</para>
      </note>
    </section>
  </section>

  <section id="gfix-buffers">
    <title>Set Database Page Buffers</title>

    <para>The database cache is an area of RAM allocated to store (cache)
    database pages in memory to help improve the efficiency of the database
    performance. It is far quicker to read data from memory that it is to have
    to physically read the data from disc.</para>

    <para>The size of the database cache is dependent on the database page
    size and the number of buffers allocated, a buffer is the same size as a
    database page, and whether the installation is using Classic or
    Superserver versions of Firebird.</para>

    <para>In a Classic Server installation, each connection to the database
    gets its own relatively small cache of 75 pages while Superserver creates
    a much larger cache of 2,048 pages which is shared between all the
    connections.</para>

    <para>The command to set the number of cache pages is:</para>

    <para><command>gfix -b[uffers] BUFFERS database_name</command></para>

    <para>This command allows you to change the number of buffers (pages)
    allocated in RAM to create the database cache.</para>

    <para>You cannot change the database page size in this manner, only the
    number of pages reserved in RAM. One parameter is required which must be
    numeric and between 50 (the minimum) and 131,072 (the maximum).</para>

    <para>The setting applies only to the database you specify. No other
    databases running on the same server are affected.</para>

    <para>The following example shows the use of
    <application>gstat</application> to read the current number of buffers,
    the <application>gfix</application> utility being used to set the buffers
    to 4,000 pages and <application>gstat</application> being used to confirm
    the setting. The value of zero for page buffers indicates the default
    setting for the server type is in use.</para>

    <note>
      <para>You can use the <application>gstat</application> command line
      utility to display the database details with the command line:
      <command>gstat -header db_name</command> however, to run
      <application>gstat</application>, you need to be logged into the server
      - it cannot be used remotely.</para>
    </note>

    <screen>linux&gt; gstat -header my_employee | grep -i "page buffers"
Page buffers    0
    
linux&gt; gfix -buffers 4000 my_employee
    
linux&gt; gstat -header my_employee | grep -i "page buffers"
Page buffers 4000</screen>
  </section>

  <section id="gfix-transactions">
    <title>Limbo Transaction Management</title>

    <para>Limbo transactions can occur when an application is updating two (or
    more) databases at the same time, in the same transaction. At
    <database>COMMIT</database> time, Firebird will prepare each database for
    the <database>COMMIT</database> and then <database>COMMIT</database> each
    database separately.</para>

    <para>In the event of a network outage, for example, it is possible for
    part of the transaction to have been committed on one database but the
    data on the other database(s) may not have been committed. Because
    Firebird cannot tell if these transactions (technically sub-transactions)
    should be committed or rolled back, they are flagged as being in
    limbo.</para>

    <para><application>Gfix</application> offers a number of commands to allow
    the management of these limbo transactions.</para>

    <note>
      <para>The following examples of limbo transactions are based on Firebird
      1.5 and have kindly been provided by Paul Vinkenoog. Because of the
      limitation of my setup, I am unable to create limbo transactions in my
      current location.</para>

      <para>In the spirit of consistency, however, I have renamed Paul's
      servers and database locations to match the remainder of this
      document.</para>
    </note>

    <section>
      <title>Listing Limbo Transactions</title>

      <para>The <application>gfix</application> command
      <userinput>-l[ist]</userinput> will display details of transactions that
      are in limbo. If there is no output, then there are no transactions in
      limbo and no further work need be done. The command is:</para>

      <para><command>gfix -l[ist] database_name</command></para>

      <para>An example of listing limbo transactions is shown below. This
      command is run against the local database on the server named linux
      where a multi-database transaction had been run connected to databases
      <database>linux@my_employee</database> and
      <database>remote:testlimbo</database>. Both of these database names are
      aliases.</para>

      <screen>linux&gt; gfix -list my_employee
Transaction 67 is in limbo.
 Multidatabase transaction:
 Host Site: linux
 Transaction 67
has been prepared.
 Remote Site: remote
 Database path: /opt/firebird/examples/testlimbo.fdb</screen>

      <para>If the command is run against the remote database then nothing
      will be listed because that database does not have any limbo
      transactions - the transaction that went into limbo, when the network
      failed, for example, was initiated on the local database.</para>

      <para>You may also supply the <userinput>-p[rompt]</userinput> option to
      the command and you will be prompted to <database>COMMIT</database> or
      <database>ROLLBACK</database> each detected limbo transaction. In this
      case, the command would be:</para>

      <para><command>gfix -l[ist] -p[rompt] database_name</command></para>

      <para>An example of this is shown below.</para>

      <screen>linux&gt; gfix -list -prompt my_employee
Transaction 67 is in limbo.
 Multidatabase transaction:
 Host Site: linux
 Transaction 67
has been prepared.
 Remote Site: remote
 Database path: /opt/firebird/examples/testlimbo.fdb
Commit, rollback or neither (c, r, or n)?</screen>
    </section>

    <section>
      <title>Committing Or Rolling Back</title>

      <para>When a limbo transaction has been detected, the DBA has the option
      of committing or rolling back one or more of the transactions reported
      as being in limbo.</para>

      <para>When more than one transaction is listed, the DBA can either
      commit or roll back all transactions in limbo, or a specific transaction
      number.</para>

      <para>The following commands show the <userinput>-c[ommit]</userinput>
      option being used, but the <userinput>-r[ollback]</userinput> option
      applies as well, it all depends on what the DBA is trying to
      achieve.</para>

      <para>To commit every limbo transaction on the database, the following
      command would be used:</para>

      <para><command>gfix -commit all database_name</command></para>

      <para>If the DBA wanted to commit a single transaction, then the command
      would change to the following:</para>

      <para><command>gfix -commit TXN database_name</command></para>

      <para>Where TXN is the transaction number to be committed.</para>

      <para>When either of these options are user, there is no feedback from
      gfix to advise you that the commit actually worked. You would need to
      rerun the <command>gfix -list</command> command to make sure that all,
      or the selected, limbo transactions had indeed gone.</para>

      <para>You cannot commit or rollback a transaction that is not in limbo.
      If you try , the following will occur:</para>

      <screen>linux&gt; gfix -commit 388 my_employee
failed to reconnect to a transaction in database my_employee
transaction is not in limbo
-transaction 388 is active
unknown ISC error 0
</screen>

      <para>When committing or rolling back all limbo transactions, the
      <userinput>-p[rompt]</userinput> option can be specified. It is,
      however, not permitted when processing a single transaction. An example
      of using the <userinput>-p[rompt]</userinput> option has been shown
      above under listing limbo transactions.</para>
    </section>

    <section>
      <title>Automatic Two-phase Recovery</title>

      <para><application>Gfix</application> can be used to perform automatic
      two-phase recovery. The command for this is
      <userinput>-t[wo_phase]</userinput> and, like
      <userinput>-c[ommit]</userinput> and <userinput>-r[ollback]</userinput>
      above, requires either 'all' or a transaction number.</para>

      <para>The output of the <userinput>-l[ist]</userinput> command shows
      what will happen to each listed transaction in the event that the DBA
      runs the <userinput>-t[wo_phase]</userinput> command.</para>

      <para>The command also takes the <userinput>-p[rompt]</userinput>
      option, as above, when used to process all transaction.</para>

      <para>The command line to carry out automatic two-phase recovery
      is:</para>

      <para><command>gfix -t[wo_phase] TXN database_name</command> or</para>

      <para><command>gfix -t[wo_phase] all database_name</command></para>

      <para>As above, TXN is a single transaction number from the list of
      limbo transactions.</para>

      <note>
        <para>Paul has noted that when using the
        <userinput>-c[ommit]</userinput>, <userinput>-r[ollback]</userinput>
        or <userinput>-t[wo_phase]</userinput> options, the output is exactly
        the same and appears to show that these three are all just synonyms
        for the <userinput>-l[ist] -p[rompt]</userinput> pair of options. This
        occurred whether or not Paul used the transaction number, 67, or 'all'
        in the command line.</para>
      </note>
    </section>
  </section>

  <section id="gfix-cache">
    <title>Cache Manager</title>

    <para>When the help page for <application>gfix</application> is displayed
    there is a message in the output for the <userinput>-ca[che]</userinput>
    option which states:</para>

    <para><screen>...
-ca[che]      shutdown cache manager
...</screen></para>

    <para>However, when called this option simply displays the help page
    again.</para>

    <para>The question that immediately springs to my mind is, if we can
    shutdown the cache manager with this option, how do we start it back up
    again?</para>
  </section>

  <section id="gfix-dbmode">
    <title>Changing The Database Mode</title>

    <para>Databases can be set to run in one of two modes, read only - where
    no updates are permitted, and read/write - where both reading and writing
    of data is permitted. By default, Firebird creates read/write databases
    and as such, all read/write databases must be placed on a file system
    which allows writing to take place.</para>

    <para>Should you wish to put a Firebird database on a CD, for example, you
    wouldn't be able to do so. After a new database has been populated with
    data it can be changed to read only mode, and then used on a CD (or other
    read only file systems) with no problems.</para>

    <note>
      <para>Firebird uses <database>SQL</database> internally to maintain its
      internal structures with details about transactions, for example, and
      this is the reason that a database must be placed on a read/write file
      system regardless of whether only <database>SELECT</database> statements
      are run or not.</para>
    </note>

    <note>
      <para>Only databases in dialect 3 can be changed to read only
      mode.</para>
    </note>

    <para>The command to set the required mode for a database is:</para>

    <para><command>gfix -mo[de] MODE database_name</command></para>

    <para>The command takes two parameters, the MODE which must be one of the
    following:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><userinput>read_only</userinput> - the database cannot be
        written to.</para>
      </listitem>

      <listitem>
        <para><userinput>read_write</userinput> - the database can be written
        to.</para>
      </listitem>
    </itemizedlist>

    <para>The meaning of the two modes should be quite meaningful.</para>

    <para>The second parameter is a database name to apply the mode change
    to.</para>

    <para>The following example shows how to put a database into read only
    mode, and then change it back again. The example also shows what happens
    when you try to update the database while running in read only
    mode.</para>

    <screen>linux&gt; gfix -mode read_only my_employee

linux&gt; isql my_employee
Database: my_employee

SQL&gt; create table test(stuff integer);
Statement failed, SQLCODE = -902
Dynamic SQL Error
-attempted update on read-only database

SQL&gt; quit;

linux&gt; gfix -mode read_write my_employee

linux&gt; isql my_employee
Database: my_employee

SQL&gt; create table test(stuff integer);

SQL&gt; show table test;
STUFF      INTEGER Nullable

SQL&gt; quit;</screen>

    <para>If there are any connections to the database in read/write mode when
    you attempt to convert the database to read only, the attempt will fail as
    shown below with Firebird 1.5.</para>

    <screen>linux&gt; gfix -mode read_only my_employee
lock time-out on wait transaction
-lock time-out on wait transaction
-object my_employee is in use

linux&gt; echo $?
0</screen>

    <warning>
      <para>As with many failures of <application>gfix</application>, the
      response code returned to the operating system is zero.</para>
    </warning>

    <para>Under Firebird 2, the error message is more self explanatory:</para>

    <screen>linux&gt; gfix -mode read_only my_employee
lock time-out on wait transaction
-object /opt/firebird/databases/my_employee.fdb is in use

linux&gt; echo $?
0</screen>
  </section>

  <section id="gfix-dialect">
    <title>Setting The Database Dialect</title>

    <para>The dialect of the database is simply a term that defines the
    specific features of the <database>SQL</database> language that are
    available when accessing that database. There are three dialects at
    present (Firebird version 2.0), these are:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Dialect 1 stores date and time information in a
        <database>DATE</database> data type and has a
        <database>TIMESTAMP</database> data type which is identical to DATE.
        Double quotes are used to delimit string data. The precision for
        <database>NUMERIC</database> and <database>DECIMAL</database> data
        types is less than a dialect 3 database and if the precision is
        greater than 9, Firebird stores these as <database>DOUBLE
        PRECISION</database>. <database>INT64</database> is not permitted as a
        data type.</para>
      </listitem>

      <listitem>
        <para>Dialect 2 is available only on the Firebird client connection
        and cannot be set in the database. It is intended to assist debugging
        of possible problems with legacy data when migrating a database from
        dialect 1 to 3. This dialect cannot be set for a database using
        <application>gfix</application>. (See below.)</para>
      </listitem>

      <listitem>
        <para>Dialect 3 databases allow numbers (<database>DECIMAL</database>
        and <database>NUMERIC</database> data types) to be stored as
        <database>INT64</database> when the precision is greater than 9. The
        <database>TIME</database> data type is able to be used and stores time
        data only. The <database>DATE</database> data type stores on date
        information. Double quotes can be used but only for identifiers that
        are case dependent, not for string data which has to use single
        quotes.</para>
      </listitem>
    </itemizedlist>

    <para>The command to change the SQL dialect for a database is:</para>

    <para><command>gfix -s[ql_dialect] DIALECT database_name</command></para>

    <para>The DIALECT parameter is simply 1 or 3.</para>

    <para>The following example changes a database to use dialect 3 which will
    allow many newer features of SQL 92 to be used.</para>

    <screen>linux&gt; gfix -sql_dialect 3 my_employee

linux&gt; gstat -header my_employee | grep dialect
Database dialect    3

linux&gt; gfix -sql_dialect 1 my_employee

linux&gt; gstat -header my_employee | grep dialect
Database dialect    1</screen>

    <para>Because you cannot use <application>gstat</application> remotely,
    you may also use the <application>isql</application> command
    <database>SHOW SQL DIALECT</database> from a remote location to see which
    dialect your client and database are using, as follows:</para>

    <screen>remote&gt; isql my_employee -user norman -password whatever
Database: my_employee

SQL&gt; show sql dialect;
Client SQL dialect is set to: 3 and database SQL dialect is: 3</screen>

    <para>Although dialect 2 is possible on the client, trying to set a
    dialect of 2 will fail on the server as the following example
    shows.</para>

    <screen>linux&gt; gfix -sql_dialect 2 my_employee
Database dialect 2 is not a valid dialect.
-Valid database dialects are 1 and 3.
-Database dialect not changed.
</screen>

    <para>To set dialect 2 for your <emphasis>client</emphasis> connection,
    you use <application>isql</application> as follows:</para>

    <screen>linux&gt; isql my_employee
Database: my_employee

SQL&gt; set sql dialect 2;
WARNING: Client SQL dialect has been set to 2 when connecting -
to Database SQL dialect 3 database.

SQL&gt; show sql dialect;
Client SQL dialect is set to: 2 and database SQL dialect is: 3</screen>

    <note>
      <para>The WARNING line above has had to be split to fit on the page of
      the PDF version of this manual. In reality, it is a single line of
      text.</para>
    </note>
  </section>

  <section id="gfix-housekeeping">
    <title>Database Housekeeping And Garbage Collection</title>

    <titleabbrev>DB Housekeeping and Garbage Collection</titleabbrev>

    <section>
      <title>Garbage</title>

      <para>Garbage, for want of a better name, is the detritus that Firebird
      leaves around in the database after a rollback has been carried out.
      This is basically a copy of the row(s) from the table(s) that were being
      updated (or deleted) by the transaction prior to the rollback.</para>

      <para>Because Firebird uses multi-generational architecture, every time
      a row is updated or deleted, Firebird keeps a copy in the database.
      These copies use space in the pages and can remain in the database for
      some time.</para>

      <para>In addition to taking up space in the database, these old copies
      can lead to increased transaction startup times.</para>

      <para>There are two types of garbage:</para>

      <para><itemizedlist>
          <listitem>
            <para>Remnants from a committed transaction.</para>
          </listitem>

          <listitem>
            <para>Remnants from an aborted (rolled back) transaction.</para>
          </listitem>
        </itemizedlist>These remnants are simply older copies of the rows that
      were being updated by the respective transactions. The differences are
      that:</para>

      <para><itemizedlist>
          <listitem>
            <para>Whenever a subsequent transaction reaches garbage from a
            <emphasis>committed</emphasis> transaction, that garbage is
            automatically cleared out.</para>
          </listitem>

          <listitem>
            <para>Rolled back garbage is <emphasis>never</emphasis>
            automatically cleared out.</para>
          </listitem>
        </itemizedlist>This means that on a database with a lot of rolled back
      transactions, there could be a large build up of old copies of the rows
      that were updated and then rolled back.</para>

      <para>Firebird will automatically sweep through the database and remove
      the remnants of rolled back transactions and this has two
      effects:</para>

      <itemizedlist>
        <listitem>
          <para>The database size is reduced as the old copies of rows are
          deleted.</para>
        </listitem>

        <listitem>
          <para>The performance of the database may be affected while the
          sweep is in progress.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>One other method of clearing out old rolled back transactions'
        garbage is simply to carry out a database backup.</para>
      </note>

      <para>In the Super Server version of Firebird 2.0, garbage collection
      has been vastly improved. There are now three different ways of
      operation and these are configurable by setting the
      <emphasis>GCPOLICY</emphasis> parameter in the
      <filename>firebird.conf</filename> configuration file. By default, Super
      Server uses <emphasis>combined</emphasis> while Classic Server uses
      <emphasis>cooperative</emphasis>. The other option is
      <emphasis>background</emphasis>.</para>

      <note>
        <para>Classic Server ignores the setting and always uses cooperative
        garbage collection.</para>
      </note>

      <section>
        <title>Cooperative Garbage Collection</title>

        <para>This is the default setting, indeed the only setting, that
        Classic Server uses. In this mode, the normal operation - as described
        above - takes place. When a full scan is performed (perhaps during a
        backup) old versions of the rows are deleted at that point in
        time.</para>
      </section>

      <section>
        <title>Background garbage Collection</title>

        <para>Super Server has, even since before version 1.0, performed
        background garbage collection where the server informs the garbage
        collector about old versions of updated and deleted rows when they are
        ready to be cleaned up. This helps avoid the need to force a full scan
        of each record in the database tables to get the garbage collector to
        remove these old versions.</para>

        <para>When all rows in a table are read by the server, any old record
        versions are flagged to the garbage collector as being ready to be
        cleared out. They are not deleted by the scanning process as in the
        cooperative method. The garbage collector runs as a separate
        background thread and it will, at some point, remove these older
        record versions from the database.</para>
      </section>

      <section>
        <title>Combined Garbage Collection</title>

        <para>This is the default garbage collection method for Super Server
        installations. In this mode, both the above methods are used
        together.</para>
      </section>
    </section>

    <section>
      <title>Setting Sweep Interval</title>

      <para>The default sweep interval for a new database is 20,000. The sweep
      interval is the <emphasis>difference</emphasis> between the
      <emphasis>oldest interesting transaction</emphasis> or OIT and the next
      transaction number.</para>

      <note>
        <para>This doesn't mean that every 20,000 transaction a sweep will
        take place. It will take place when the
        <emphasis>difference</emphasis> between the OIT and the next
        transaction is greater than the sweep interval.</para>
      </note>

      <para>An interesting transaction is one which has not yet committed. It
      may be still active, in limbo or may have been rolled back.</para>

      <para>The sweep facility runs through the database and gets rid of old
      rows in tables that are out of date. This prevents the database from
      growing too big and helps reduce the time it takes to start a new
      transaction on the database.</para>

      <note>
        <para>If you find that starting a new transaction takes a long time,
        it may be a good idea to run a manual sweep of the database in case
        the need for a sweep is causing the hold-up.</para>
      </note>

      <para>You can check if a manual sweep may be required by running the
      <application>gstat</application> utility to check the database header
      page and extract the oldest and next transaction numbers from the
      output. If the gap is small (less than the sweep interval) then a manual
      sweep may be in order. Alternatively, the <database><database>SHOW
      DATABASE</database></database> command in
      <application>isql</application> will also show the details you
      need.</para>

      <para>A manual sweep can be run by using the
      <userinput>-s[weep]</userinput> command. (See below).</para>

      <para>To alter the database's automatic sweep interval, use the
      following command:</para>

      <para><command>gfix -h[ousekeeping] INTERVAL
      database_name</command></para>

      <para>The INTERVAL parameter is the new value for the sweep interval.
      The database name parameter is the database upon which you wish to alter
      the setting for automatic sweeping. The following example shows the
      setting being changed from the default to a new value of 1,000.</para>

      <screen>linux&gt; gfix -h 1000 my_employee

linux&gt; gstat -header my_employee | grep Sweep
Sweep interval:     1000</screen>
    </section>

    <section>
      <title>Manual Garbage Collection</title>

      <para>If automatic sweeping has been turned off, or only runs rarely
      because of the sweep interval setting, the DBA can manually force a
      sweep to be performed. The command to carry out this task is:</para>

      <para><command>gfix -s[weep] [-i[gnore]] database_name</command></para>

      <para>This command will force the garbage left over from old rolled back
      transactions to be removed, reducing the database size and improving the
      performance of new transactions.</para>

      <para>The <userinput>-i[gnore]</userinput> option may be supplied. This
      forces Firebird to ignore checksum errors on database pages. This is not
      a good idea and should rarely need to be used, however, if your database
      has suffered some problems it might be necessary to use it.</para>

      <para>The following example shows a manual database sweep being
      implemented:</para>

      <screen>linux&gt; gfix -sweep my_employee</screen>
    </section>

    <section>
      <title>Disabling Automatic Sweeping</title>

      <para>If you set the sweep interval to zero then automatic sweeping will
      be disabled. This implies that there will be no automatic housekeeping
      done so your database performance will not suffer as a result of the
      processing requirements of the automatic sweep.</para>

      <para>If you disable sweeping you are advised to run a manual sweep at
      regular intervals when the database is quiet. Alternatively, simply make
      sure that you take regular backups of the database and as this is
      something you should be doing anyway, it shouldn't be a problem.</para>
    </section>
  </section>

  <section id="gfix-dbstartstop">
    <title>Database Startup and Shutdown</title>

    <note>
      <para>The first part of this section describes the shutdown and startup
      options up to Firebird 2.0. There is a separate section at the end which
      discusses the new <firstterm>states</firstterm> for starting and
      stopping a database using Firebird 2.0 onwards.</para>
    </note>

    <section>
      <title>Database Shutdown</title>

      <para>If there is maintenance work required on a database, you may wish
      to close down that database under certain circumstances. This is
      different from stopping the Firebird server as the server may well be
      running other databases which you do not wish to affect.</para>

      <para>The command to close a database is:</para>

      <para><command>gfix -shut OPTION TIMEOUT database_name</command></para>

      <para>The TIMEOUT parameter is the time, in seconds, that the shutdown
      must complete in. If the command cannot complete in the specified time,
      the shutdown is aborted. There are various reasons why the shutdown may
      not complete in the given time and these vary with the mode of the
      shutdown and are described below.</para>

      <para>The OPTION parameter is one of the following:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><userinput>-at[tach]</userinput> - prevents new
          connections.</para>
        </listitem>

        <listitem>
          <para><userinput>-tr[an]</userinput> - prevents new
          transactions.</para>
        </listitem>

        <listitem>
          <para><userinput>-f[orce]</userinput> - simply aborts all
          connections and transactions.</para>
        </listitem>
      </itemizedlist>

      <para>When a database is closed, the SYSDBA or the database owner can
      still connect to perform maintenance operations or even query and update
      the database tables.</para>

      <note>
        <para>If you specify a long time for the shutdown command to complete
        in, you can abort the shutdown by using the
        <userinput>-online</userinput> command (see below) if the timeout
        period has not completed.</para>
      </note>

      <section>
        <title>Preventing New Connections</title>

        <para><userinput>-at[tach]</userinput> : this parameter prevents any
        new connections to the database from being made with the exception of
        the SYSDBA and the database owner. The shutdown will fail if there are
        any sessions connected after the timeout period has expired. It makes
        no difference if those connected sessions belong to the SYSDBA, the
        database owner or any other user. Any connections remaining will
        terminate the shutdown with the following details:</para>

        <screen>linux&gt; gfix -shut -attach 5 my_employee
lock conflick on no wait transaction
-database shutdown unsuccessful</screen>

        <para>Anyone other than the SYSDBA or database owner, attempting to
        connect to the database will see the following:</para>

        <screen>linux&gt; isql my_employee -user norman -password whatever
Statement failed, SQLCODE = -901
database my_employee shutdown
Use CONNECT or CREATE DATABASE to specify a database
SQL&gt;</screen>

        <para>Connections in the database will still be able to start new
        transactions or complete old ones.</para>
      </section>

      <section>
        <title>Preventing New Transactions</title>

        <para><userinput>-tr[an]</userinput> : prevents any new transactions
        from being started and also prevents new connections to the database.
        If there are any active transactions after the timeout period has
        expired, then the shutdown will fail as follows:</para>

        <screen>linux&gt; gfix -shut -tran 5 my_employee
lock conflick on no wait transaction
-database shutdown unsuccessful</screen>

        <para>If any user connected to the database being shutdown with the
        <userinput>-tr[an]</userinput> tries to start a new transaction during
        the shutdown timeout period, the following will result:</para>

        <screen>SQL&gt; select * from test;
Statement failed, SQLCODE = -902
database /home/norman/firebird/my_employee.fdb shutdown in progress
Statement failed, SQLCODE = -902
database /home/norman/firebird/my_employee.fdb shutdown in progress
Statement failed, SQLCODE = -901
Dynamic SQL Error
-SQL error code = -901
-invalid transaction handle (expecting explicit transaction start)</screen>
      </section>

      <section>
        <title>Force Closure</title>

        <para><userinput>-f[orce]</userinput> : shuts down with no regard for
        the connection or transaction status of the database. No new
        connections or transactions are permitted and any active sessions are
        terminated along with any active transactions.</para>

        <para>Anyone other than SYSDBA or the database owner trying to connect
        to the database during the timeout period will not be able to connect
        successfully or start any (new) transactions.</para>

        <para>Be nice to your users, use the <userinput>-f[orce]</userinput>
        option with great care.</para>

        <warning>
          <para>There is a bug in Classic Server which still exists at version
          2.0. The bug is such that the <userinput>-f[orce]</userinput> option
          behaves in exactly the same way as the
          <userinput>-at[tach]</userinput> option.</para>
        </warning>
      </section>
    </section>

    <section>
      <title>Starting a Database</title>

      <para>Once all maintenance work required on a database has been carried
      out, you need to restart the database to allow normal use again. (See
      shutdown option above for details of closing a database.)</para>

      <para>The <userinput>-o[nline]</userinput> command allows a database to
      be restarted. It takes a single parameter which is the database name as
      follows:</para>

      <para><command>gfix -o[nline] database_name</command></para>

      <para>The following example shows a closed database being
      started.</para>

      <screen>linux&gt; gfix -online my_employee</screen>
    </section>

    <section>
      <title>New Startup and Shutdown States in Firebird 2.0</title>

      <para>The above discussion of stopping and starting a database apply to
      all versions of the server up to version 2.0. From 2.0 the commands will
      work as described above, but a new <emphasis>state</emphasis> has been
      added to define exactly how the database is to be stopped or started.
      The commands change from those described above to the following:</para>

      <para><command>gfix -shut STATE OPTION TIMEOUT
      database_name</command></para>

      <para><command>gfix -o[nline] STATE database_name</command></para>

      <para>STATE is new in Firebird 2.0 and is one of the following:</para>

      <itemizedlist>
        <listitem>
          <para><userinput>normal</userinput> - This is the default state for
          starting the database backup. It allows connections from any
          authorised users - not just SYSDBA or the database owner. This
          option is not accepted for shutdown operations.</para>
        </listitem>

        <listitem>
          <para><userinput>multi</userinput> - this is the default mode as
          described above. When the database is shutdown as above, or using
          the multi state, then <emphasis>unlimited</emphasis> connections can
          be made by the SYSDBA or the database owner. No other connections
          are allowed.</para>
        </listitem>

        <listitem>
          <para><userinput>single</userinput> - Similar to the multi option
          above, but only <emphasis>one</emphasis> SYSDBA or database owner
          connection is allowed.</para>
        </listitem>

        <listitem>
          <para><userinput>full</userinput> - Shutdown and don't allow
          <emphasis>any</emphasis> connections from anyone, even SYSDBA or the
          database owner. This is not an acceptable option for starting up a
          database.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>There is no leading dash for the state parameters, unlike the
        command itself and the <userinput>-shut</userinput> OPTION.</para>
      </note>

      <para>There is a hierarchy of states for a database. The above list
      shows them in order with normal at the top and full at the
      bottom.</para>

      <para>This hierarchy is important, you cannot
      <emphasis>shutdown</emphasis> a database to a <emphasis>higher or
      equal</emphasis> level that it currently is, nor can you
      <emphasis>startup</emphasis> a database to a <emphasis>lower or
      equal</emphasis> level.</para>

      <para>If you need to identify which level a database is currently
      running at, <application>gstat</application> will supply the answers.
      The following example puts a database fully online then progressively
      shuts it down to fully offline. At each stage,
      <application>gstat</application> is run to extract the Attributes of the
      database.</para>

      <screen>linux&gt; gfix -online normal my_employee
linux&gt; gstat -header my_employee | grep Attributes

        Attributes

linux&gt; gfix -shut multi -attach 0 my_employee
linux&gt; gstat -header my_employee | grep Attributes

        Attributes              multi-user maintenance

linux&gt; gfix -shut single -attach 0 my_employee
linux&gt; gstat -header my_employee | grep Attributes

        Attributes              single-user maintenance

linux&gt; gfix -shut full -attach 0 my_employee
linux&gt; gstat -header my_employee | grep Attributes

        Attributes              full shutdown

linux&gt;                                    </screen>
    </section>
  </section>

  <section id="gfix-pagespace">
    <title>Database Page Space Utilisation</title>

    <para>When a database page is being written to, Firebird reserves 20% of
    the page for future use. This could be used to extend
    <database>VARCHAR</database> columns that started off small and then were
    updated to a longer value, for example.</para>

    <para>If you wish to use all the available space in each database page,
    you may use the <userinput>-use</userinput> command to configure the
    database to do so. If you subsequently wish to return to the default
    behaviour, the <userinput>-use</userinput> command can be used to revert
    back to leaving 20% free space per page.</para>

    <note>
      <para>Once a page has been filled to 'capacity' (80 or 100%) changing
      the page usage setting will not change those pages, only subsequently
      written pages will be affected.</para>
    </note>

    <para>The <userinput>-use</userinput> command takes two parameters as
    follows:</para>

    <para><command>gfix -use USAGE database_name</command></para>

    <para>The USAGE is one of:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><userinput>full</userinput> : use 100% of the space in each
        database page.</para>
      </listitem>

      <listitem>
        <para><userinput>reserve</userinput> : revert to the default behaviour
        and only use 80% of each page.</para>
      </listitem>
    </itemizedlist>

    <para>The following example configures a database to use all available
    space in each database page:</para>

    <screen>linux&gt; gfix -use full my_employee
linux&gt; gstat -header my_employee | grep Attributes
Attributes no reserve</screen>

    <para>The following example sets the page usage back to the
    default:</para>

    <screen>linux&gt; gfix -use reserve my_employee
linux&gt; gstat -header my_employee | grep Attributes
Attributes</screen>

    <para>If you are using full page utilisation then the Attributes show up
    with 'no reserve' in the text. This doesn't appear for normal 80%
    utilisation mode.</para>
  </section>

  <section id="gfix-dbverify">
    <title>Database Validation and Recovery</title>

    <section>
      <title>Database Validation</title>

      <para>Sometimes, databases get corrupted. Under certain circumstances,
      you are advised to validate the database to check for corruption. The
      times you would check are:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>When an application receives a <emphasis>database
          corrupt</emphasis> error message.</para>
        </listitem>

        <listitem>
          <para>When a backup fails to complete without errors.</para>
        </listitem>

        <listitem>
          <para>If an application aborts rather than shutting down
          cleanly.</para>
        </listitem>

        <listitem>
          <para>On demand - when the SYSDBA decides to check the
          database.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>Database validation requires that you have exclusive access to
        the database. To prevent other users from accessing the database while
        you validate it, use the <command>gfix -shut</command> command to
        shutdown the database.</para>
      </note>

      <para>When a database is validated the following checks are made
      <emphasis>and corrected</emphasis> by default:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>Orphan pages are returned to free space. This updates the
          database.</para>
        </listitem>

        <listitem>
          <para>Pages that have been misallocated are reported.</para>
        </listitem>

        <listitem>
          <para>Corrupt data structures are reported.</para>
        </listitem>
      </itemizedlist>

      <para>There are options to perform further, more intensive, validation
      and these are discussed below.</para>

      <section>
        <title>Default Validation</title>

        <para>The command to carry out default database validation is:</para>

        <para><command>gfix -v[alidate] database_name</command></para>

        <para>This command validates the database and makes updates to it when
        any orphan pages are found. An orphan page is one which was allocated
        for use by a transaction that subsequently failed, for example, when
        the application aborted. In this case, committed data is safe but
        uncommitted data will have been rolled back. The page appears to have
        been allocated for use, but is unused.</para>

        <para>This option updates the database and fixes any corrupted
        structures.</para>
      </section>

      <section>
        <title>Full Validation</title>

        <para>By default, validation works at page level. If no need to go
        deeper and validate at the record level as well, the command to do
        this is:</para>

        <para><command>gfix -v[alidate] -full database_name</command></para>

        <para>using this option will validate, report and update at both page
        and record level. Any corrupted structures etc will be fixed.</para>
      </section>

      <section>
        <title>Read-only Validation</title>

        <para>As explained above, a validation of a database will actually
        validate and update the database structures to, hopefully, return the
        database to a working state. However, you may not want this to happen
        and in this case, you would perform a read only validation which
        simply reports any problem areas and does not make any changes to the
        database.</para>

        <para>To carry out a read only validation, simply supply the
        <userinput>-n[o_update]</userinput> option to whichever command line
        you are using for the validation. To perform a full validation, at
        record and page level, but in reporting mode only, use the following
        command:</para>

        <para><command>gfix -v[alidate] -full -n[o_update]
        database_name</command></para>

        <para>On the other hand, to stay at page level validation only, the
        command would be:</para>

        <para><command>gfix -v[alidate] -n[o_update]
        database_name</command></para>
      </section>

      <section>
        <title>Ignore Checksum Errors</title>

        <para>Checksums are used to ensure that data in a page is valid. If
        the checksum no longer matches up, then it is possible that a database
        corruption has occurred. You can run a validation against a database,
        but ignore the checksums using the <userinput>-i[gnore]</userinput>
        option.</para>

        <para>This option can be combined with the
        <userinput>-n[o_update]</userinput> option described above and applies
        to both full and default validations. So, to perform a full validation
        and ignore checksums on a database, but reporting errors only, use the
        following command:</para>

        <para><command>gfix -v[alidate] -full -i[gnore] -n[o_update]
        database_name</command></para>

        <para>Alternatively, to carry out a page level validation, ignoring
        checksum errors but updating the database structures to repair it, the
        command would be:</para>

        <para><command>gfix -v[alidate] -i[gnore]
        database_name</command></para>

        <para>Ignoring checksums would allow a corrupted database to be
        validated (unless you specify the <userinput>-n[o_update]</userinput>
        option) but it is unlikely that the recovered data would be usable, if
        at all, present.</para>
      </section>
    </section>

    <section>
      <title>Database Recovery</title>

      <para>If the database validation described above produces no output then
      the database <emphasis>structures</emphasis> can be assumed to be valid.
      However, in the event that errors are reported, you may have to repair
      the database before it can be used again.</para>

      <section>
        <title>Recover a Corrupt Database</title>

        <para>The option required to fix a corrupted database is the
        <command>gfix -m[end]</command> command. However, it cannot fix all
        problems and <emphasis>may result in a loss of data</emphasis>. It all
        depends on the level of corruption detected. The command is:</para>

        <para><command>gfix -m[end] database_name</command></para>

        <para>This causes the corruptions in data records to be ignored. While
        this sounds like a good thing, it is not. Subsequent database actions
        (such as taking a backup) will not include the corrupted records,
        leading to data loss.</para>

        <important>
          <para>The best way to avoid data loss is to make sure that you have
          enough regular backups of your database and to regularly carry out
          test restorations. There is no point taking backups every night, for
          example, if they cannot be used when required. Test always and
          frequently.</para>

          <para>Equally, when attempting to recover a potentially corrupted
          database, <emphasis>always</emphasis> work with a copy of the main
          database file and never with the original. Using the
          <command>-mend</command> option can lead to silent deletions of data
          because <application>gfix</application> doesn't care about internal
          database constraints like foreign keys etc, the
          <command>-mend</command> option simply says to
          <application>gfix</application> "<emphasis>go ahead and clean out
          anything you don't like</emphasis>".</para>
        </important>
      </section>
    </section>
  </section>

  <section id="gfix-sync">
    <title>Database Write Mode</title>

    <para>Many operating systems employ a disc cache mechanism. This uses an
    area of memory (which may be part of your server's overall RAM or may be
    built into the disc hardware) to buffer writes to the hardware. This
    improves the performance of applications that are write intensive but
    means that the user is never certain when their data has actually been
    written to the physical disc.</para>

    <para>With a database application, it is highly desirable to have the data
    secured as soon as possible. Using Firebird, it is possible to specify
    whether the data should be physically written to disc on a
    <database>COMMIT</database> or simply left to the operating system to
    write the data <emphasis>when it gets around to it</emphasis>.</para>

    <para>To give the DBA or database owner full control of when data is
    written, the <command>gfix -w[rite]</command> command can be used. The
    command takes two parameters:</para>

    <para><command>gfix -write MODE database_name</command></para>

    <para>The MODE parameter specifies whether data would be written
    immediately or later, and is one of:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><userinput>sync</userinput> - data is written synchronously.
        This means that data is flushed to disc on
        <database>COMMIT</database>. This is safest for your data.</para>
      </listitem>

      <listitem>
        <para><userinput>async</userinput> - data is written asynchronously.
        The operating system controls when the data is actually written to
        disc.</para>
      </listitem>
    </itemizedlist>

    <para>If your system is highly robust, and protected by a reliable UPS
    (uninterruptable Power Supply) then it is possible to run asynchronously
    but for most systems, synchronous running is safest this will help prevent
    corruption in the event of a power outage or other uncontrolled shutdown
    of the server and/or database.</para>

    <note>
      <para>Firebird defaults to synchronous mode (forced writes enabled) on
      Linux, Windows NT, XP, 2000, 2003 and Vista.</para>
    </note>

    <para>This command has no effect on Windows 95, 98 and ME.</para>

    <warning>
      <para>Cache flushing on Windows servers (up to but not including Vista -
      which has not been confirmed yet) is unreliable. If you set the database
      to <userinput>async</userinput> mode (forced writes disabled) then it is
      possible that the cache will never be flushed and data could be lost if
      the server is never shutdown tidily.</para>
    </warning>

    <warning>
      <para>If your database was originally created with Interbase 6 or an
      early beta version of Firebird then the database will be running in
      asynchronous mode - which is not ideal.</para>
    </warning>
  </section>

  <section id="gfix-version">
    <title>Version Number</title>

    <para>The <userinput>-z</userinput> option to
    <application>gfix</application> simply prints out the version of the
    Firebird utility software that you are running. It takes no parameters as
    the following example (running on Linux) shows.</para>

    <screen>linux&gt; gfix -z 
gfix version LI-V2.0.0.12748 Firebird 2.0</screen>
  </section>

  <section id="gfix-caveats">
    <title>Caveats</title>

    <para>This section summarises the various problems that you may encounter
    from time to time when using <application>gfix</application>. They have
    already been discussed above, or mentioned in passing, but are explained
    in more details here.</para>

    <section>
      <title>Shadows</title>

      <para>The <application>gstat</application> seems to take some time to
      respond to the addition of shadow files to a database. After adding two
      shadows to a test database, <application>gstat</application> still
      showed that there was a Shadow count of zero.</para>

      <para>Even worse, after killing the second shadow file and running the
      <database>DROP SHADOW</database> command in
      <application>isql</application> to remove the one remaining shadow file,
      <application>gstat</application> decided that there were now three
      shadow files in use.</para>
    </section>

    <section>
      <title>Response Codes Are Usually Zero</title>

      <para>Even using Firebird version 2 it appears that many commands, which
      fail to complete without an error, return a response of 0 to the
      operating system.</para>

      <para>For example, the following shows two attempts to shut down the
      same database, the second one should fail - it displays an error message
      - but still returns a zero response to the operating system. This makes
      it impossible to built correctly error trapped database shutdown scripts
      as you can never tell whether it actually worked or not.</para>

      <screen>linux&gt; gfix -shut -force 5 my_employee
linux&gt; echo $?
0

linux&gt; gfix -shut -force 5 my_employee
Target shutdown mode is invalid for database -
"/home/norman/firebird/my_employee.fdb"
linux&gt; echo $?
0</screen>
    </section>

    <section>
      <title>Force Closing a Database</title>

      <para>Under classic server, using the <userinput>-f[orce]</userinput>
      option to the <userinput>-shut</userinput> command acts exactly the same
      as the <userinput>-at[tach]</userinput> option.</para>
    </section>

    <section>
      <title>Limbo Transactions</title>

      <para>There are a couple of problems with limbo transactions as
      discovered by Paul in his testing.</para>

      <section>
        <title>Limbo Transaction Options - All The Same?</title>

        <para>When processing limbo transactions, it appears under Firebird
        1.5 at least, that the <userinput>-l[ist] -p[rompt]</userinput> option
        is called regardless of whether you use
        <userinput>-c[ommit]</userinput>, <userinput>-r[ollback]</userinput>
        or <userinput>-t[wo_phase]</userinput>. The outcome is the same
        regardless of whether the DBA specifies a specific transaction number
        or 'all' on the command line - a prompt is given with the option to
        commit, rollback or neither.</para>
      </section>

      <section>
        <title>Limbo Transactions - Can Be Backed Up</title>

        <para>Paul's testing of limbo transactions revealed that it is
        possible to make a backup of a database with limbo transactions. This
        backup can then be used to create a new database and the limbo
        transactions will still be able to be listed. This applies to a file
        system copy of the database and to version 1.5 of Firebird.</para>

        <para>If you attempt to list the limbo transactions in the copy
        database <emphasis>and</emphasis> the original database has been
        deleted, renamed or has been set to read-only, then
        <application>gfix</application> will present you with a request to
        supply the correct path to the original database</para>

        <screen>linux&gt;cd /home/norman/firebird
linux&gt;cp my_employee.fdb my_new_employee.fdb

linux&gt; mv my_employee.fdb my_old_employee.fdb

linux&gt; gfix -list /home/norman/firebird/my_new_employee.fdb
Transaction 67 is in limbo.
Could not reattach to database for transaction 67.
Original path: /home/norman/firebird/my_employee.fdb

Enter a valid path: /home/norman/firebird/my_old_employee.fdb

 Multidatabase transaction:
 Host Site: linux
 Transaction 67
has been prepared.
 Remote Site: remote
 Database path: /opt/firebird/examples/testlimbo.fdb</screen>

        <para>In the above example, the original database
        <database>my_employee.fdb</database> was first of all copied using the
        operating system command <command>cp</command> to
        <database>my_new_employee.fdb</database> and then renamed to
        <database>my_old_employee.fdb</database>.</para>

        <para><application>Gfix</application> was then run on the copy named
        <database>my_new_employee.fdb</database> and it noted the limbo
        transaction. However, it could not find the original database file as
        it had been renamed, so <application>gfix</application> prompted for
        the path to the original database file. When this was entered,
        <application>gfix</application> happily listed the details.</para>

        <warning>
          <para>This implies that if you have a database with limbo
          transactions and you copy it using the operating system utilities
          and subsequently run <application>gfix</application> against the new
          database, it is possible to have <application>gfix</application> fix
          limbo transactions in the original database file and not in the one
          you think it is updating - the copy.</para>

          <para>It is also a good warning about making copies of databases
          without using the correct tools for the job.</para>
        </warning>
      </section>
    </section>
  </section>

  <appendix id="gfix-dochist">
    <title>Document history</title>

    <para>The exact file history is recorded in the <filename
    class="directory">manual</filename> module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink>.
    The full URL of the CVS log for this file can be found at <ulink
    url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_gfix.xml?view=log"
    userlevel="">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_gfix.xml?view=log</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>1.0</revnumber>

          <date>19 June 2007</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Created as a chapter in the Command Line Utilities
            manual.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.1</revnumber>

          <date>20 October 2009</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>More minor updates and converted to a stand alone
            manual.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.2</revnumber>

          <date>25 June 2010</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Fixed spacing on a couple of lists. Added an enhancement to
            the details of the -mend recovery option. It can lead to a loss of
            data.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.3</revnumber>

          <date>11 October 2011</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Spelling errors corrected.</para>

            <para>Updated for Firebird 2.5.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="gfix-license">
    <title>License notice</title>

    <para>The contents of this Documentation are subject to the Public
    Documentation License Version 1.0 (the <quote>License</quote>); you may
    only use this Documentation if you comply with the terms of this License.
    Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>The Original Documentation is titled <citetitle>Firebird Database
    Housekeeping Utility</citetitle>.</para>

    <para>The Initial Writer of the Original Documentation is: Norman
    Dunbar.</para>

    <para>Copyright (C) 2007â€“2009. All Rights Reserved. Initial Writer
    contact: NormanDunbar at users dot sourceforge dot net.</para>
  </appendix>
</article>
