<?xml version="1.0" encoding="UTF-8"?>
<!-- For standalone validation, uncomment the following DOCTYPE declaration. -->
<!-- DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"> "file:../docs/docbookx/docbookx.dtd" -->
<!-- book id="usingfirebird" -->
<chapter id="ufb-cs">
  <title>About Clients and Servers</title>

  <!--TODO : Update to Firebird 2. Remove obsolete Borland-age stuff.-->

  <para>In this chapter we take a look at the essential pieces of
  client/server systems as they are implemented in Firebird and examine how
  applications interact with the client and server.</para>

  <section id="ufb-cs-clients">
    <title>What is a Firebird client?</title>

    <para>A Firebird client is a program, usually written in a high-level
    language such as C, C++, Delphi, Java, PHP or Perl, that provides end-user
    access to the features and tools of the Firebird database database
    management system and to data stored in databases. The isql interactive
    SQL utility is an example of a client application.</para>

    <para>In the client/server model, applications never touch the database
    physically. Any application process converses with the server through the
    Firebird client library which resides on the client workstation. It
    surfaces a programming interface of function call structures known as the
    Firebird API. This client library must be installed on every user's
    workstation. Generally, other layers are also involved in the interface
    between the application program and the Firebird client, providing generic
    or application-language-specific mechanisms for populating and calling the
    API functions.</para>

    <para>Firebird clients typically reside on remote workstations and connect
    to a Firebird server running on a host node in a network. Firebird also
    supports local connection, that is, a client application, the Firebird
    client library and the Firebird server all executing on the same physical
    box.</para>

    <para>Firebird clients need not run on the same type of hardware and/or
    operating system as the server they connect to. It is quite common to have
    a number of Windows 98 or XP workstations talking to a server that runs
    under Windows NT, 2000 or 2003, or any of several flavors of UNIX or
    Linux.</para>

    <figure>
      <title>The Firebird client/server model</title>

      <graphic fileref="images/clientserver.png" format="PNG" />
    </figure>
  </section>

  <section id="ufb-cs-clientlib">
    <title>The Firebird client library</title>

    <para>The Firebird client library – named <filename
    class="libraryfile">fbclient.dll</filename> on Windows and <filename
    class="libraryfile">fbclient.so</filename> on Linux/UNIX – provides an
    Application Program Interface (API) with functions for connecting to
    servers and working with databases. The library functions communicate with
    the server(s) using a dedicated Firebird client/server protocol that sits
    on top of the general network protocol provided by the OS.</para>

    <para>All client applications and middleware must use the API in some way
    to access Firebird databases. The Firebird API is backwardly compatible
    with the InterBase API. The InterBase API Guide (available from Borland)
    contains extensive documentation on the use the API in applications.
    Additional features available in the Firebird API are documented in the
    Firebird release notes.</para>
  </section>

  <section id="ufb-cs-server">
    <title>The server</title>

    <para>The Firebird server is a program that runs on a machine with which
    client workstations can communicate by way of a network. Clients connect
    to databases physically located on this server host machine. The same
    machine that hosts the executing Firebird server process must host the
    Firebird databases in its own storage space. Only the server process has
    direct (filesystem-level) access to the database files. The server is
    fully network-enabled, serving multiple connections simultaneously, in
    response to requests from other nodes in the network. If the network runs
    under TCP/IP protocol, the scope of the network is virtually
    limitless.</para>

    <para>In the SuperServer architecture, the server process is
    multi-threaded. In Classic, a new process is started for each
    connection.</para>

    <para>The server's job is to</para>

    <itemizedlist>
      <listitem>
        <para>regulate access by transactions to individual sets of
        data</para>
      </listitem>

      <listitem>
        <para>ensure that each transaction gets and keeps a consistent view of
        the permanently stored data which it has requested through the
        client</para>
      </listitem>

      <listitem>
        <para>receive requests to modify or delete a row and either</para>
      </listitem>

      <listitem>
        <para>grant a transaction exclusive write access to the row or</para>
      </listitem>

      <listitem>
        <para>deny access if another transaction already has a write
        pending.</para>
      </listitem>

      <listitem>
        <para>maintain the statistics for each database</para>
      </listitem>

      <listitem>
        <para>maintain and refer to the metadata for each database, in order
        to manage transactions, data and <quote>house-cleaning</quote>.</para>
      </listitem>
    </itemizedlist>

    <para>Clients' requests result in the server performing tasks such
    as</para>

    <itemizedlist>
      <listitem>
        <para>creating new databases</para>
      </listitem>

      <listitem>
        <para>creating new data structures inside databases</para>
      </listitem>

      <listitem>
        <para>validating and compiling source code for procedures</para>
      </listitem>

      <listitem>
        <para>searching tables for data matching provided criteria</para>
      </listitem>

      <listitem>
        <para>collating, sorting and tabulating sets of data</para>
      </listitem>

      <listitem>
        <para>passing sets of data back to the requesting client</para>
      </listitem>

      <listitem>
        <para>modifying the values of data</para>
      </listitem>

      <listitem>
        <para>inserting new data into tables</para>
      </listitem>

      <listitem>
        <para>removing (deleting) data</para>
      </listitem>

      <listitem>
        <para>executing compiled procedures</para>
      </listitem>

      <listitem>
        <para>routing messages to clients</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="ufb-cs-appdev">
    <title>Application development</title>

    <para>Once a database has been created and populated, its information can
    be accessed through a client application. Some applications – such as the
    Firebird isql tool, EMS QuickDesk, IB_SQL, IBAccess or IBConsole – provide
    the capability to query data interactively and to create new
    metadata.</para>

    <para>Any application developed as a user interface to one or more
    Firebird databases will use the SQL query language, both to define the
    sets of data that can be stored and to pass requests to the server about
    rows it wants to update, insert into or delete from. SQL statements also
    convey the values which the application wants to be applied to those
    rows.</para>

    <para>Firebird implements a set of SQL syntaxes which have a high degree
    of compliance with the recognized SQL-92 standards. The Firebird API
    provides complete structures for packaging SQL statements and the
    associated parameters and for receiving the results.</para>

    <section id="ufb-cs-appdev-embed">
      <title>Embedded Firebird applications</title>

      <para>Firebird provides the capability to embed SQL statements in
      applications written in C, C++, and some other programming languages.
      The code is then passed through <emphasis>gpre</emphasis>, the
      pre-processor, which substitutes the embedded SQL statements with
      equivalent host language code that calls functions in Firebird's client
      API library. The gpre pre-processor generates a file that the host
      language compiler can compile.</para>

      <para>A special, extra subset of SQL-like source commands is available
      for this style of application, which are pre-processed into internal
      macro calls to the API. Known as Embedded SQL (ESQL), it provides a
      simpler, high-level language syntax for the programmer, that gpre can
      interpret and re-code according to the more complex structure of the
      equivalent API calls.</para>

      <note>
        <para>The <citetitle>InterBase Embedded SQL Guide</citetitle>
        (available from Borland) provides extensive documentation on this
        subject.</para>
      </note>
    </section>

    <section id="ufb-cs-appdev-stat-dyn">
      <title>Predefined vs. dynamic queries</title>

      <para>Some queries have to be run in exactly the same form every time
      they are needed. Queries like this are good candidates for embedding in
      the host language and pre-processing by gpre. The pre-processor turns
      them into API function calls, giving a somewhat better performance than
      SQL that has to be interpreted at runtime.</para>

      <para>But many applications need to build queries that are at least
      partially dependent on information provided by the user – freely entered
      in a text box, or selected from a list of options. This is called
      <firstterm>Dynamic SQL</firstterm> or <firstterm>DSQL</firstterm>; that
      is, SQL code whose form is not (or not exactly) known at design time.
      DSQL can be embedded and preprocessed too, but some additional
      requirements and restrictions apply. More on this, again, in the
      <citetitle>InterBase Embedded SQL Guide</citetitle>.</para>

      <!--Instead of elaborating on component interfaces is this section, should't we confine ourselves to a few
concise remarks here, and move the bulk of the following paras to the sections on components?-->

      <para>Delphi and C++ data access components provide properties and
      methods to analyze and parse DSQL request statements and manage the
      results passed back. Applications that use ODBC or other generic
      interfaces always work with DSQL statements, even if the user doesn't
      always see them. Query-by-example and other visual query tools for
      instance provide the user with a convenient, easy to use, and often
      <quote>SQL-free</quote> interface to extract, modify or delete data from
      the database. Yet the underlying code translates the user's input into
      DSQL statements, which are subsequently passed to the ODBC (or other)
      layer.</para>

      <para>Component interfaces provide methods and properties for building
      and preparing SQL template statements, allowing you to use placeholders
      for value criteria. At run-time, the application supplies input
      parameters of the appropriate data type to complete the statement.
      Provision is made also for retrieving output parameters from statements
      that return results after the statement is executed.</para>

      <note>
        <para>Of course the use of data access components isn't limited to
        dynamic SQL. You can also store static SQL strings – known at design
        time – in them.</para>
      </note>
    </section>

    <section id="ufb-cs-appdev-rad">
      <title>RAD environments and component suites</title>

      <para>With the rise of rapid application development (RAD) tools in the
      past decade, the encapsulation of the API functions in suites of
      components presents a variety of attractive application development
      options for Firebird developers.</para>

      <section id="ufb-cs-appdev-rad-borland">
        <title>Borland RAD environments</title>

        <section>
          <title>The Borland Database Engine (BDE)</title>

          <para>Borland markets <quote>enterprise versions</quote> of a number
          of integrated development tools – Delphi, Kylix, C++Builder,
          JBuilder and some older products – which can use the proprietary
          Borland Database Engine and native SQL Links InterBase drivers as a
          <quote>black box</quote> middleware layer to make InterBase and,
          latterly, Firebird databases behave like desktop databases. BDE
          version 5.2 and its associated InterBase driver, which first shipped
          with Delphi 6E, supports both Firebird and InterBase version 6,
          although it has known bugs affecting the Dialect 3 date and time
          datatypes.</para>

          <para>Because the BDE's purpose is to surface a generic,
          database-vendor-independent, client-centered data access layer to
          the IDE tools, it flattens out the differences between a wide range
          of different database systems. Hence, it limits the capability of
          applications to exploit the best features of Firebird, particularly
          multiple transactions per connection, control of transaction aging
          and concurrency control.</para>

          <para>The BDE can be useful where you need to develop an application
          that might be used with a choice of back-ends, of which Firebird is
          only one.</para>
        </section>

        <section>
          <title>DBExpress and Datasnap</title>

          <para>DBExpress and Datasnap were introduced in later versions of
          the Borland tools to provide alternative generic interfaces to
          databases. They replace the BDE by moving its functionality into
          expanded native drivers for supported databases. Like the BDE, they
          do not support multiple concurrent transactions. They are of
          especial use where a data interface is required that is independent
          of the idiosyncrasies of different database management systems.. The
          InterBase native drivers should provide adequate support for
          Firebird databases where optimizing client/server performance is not
          high among the objectives.</para>
        </section>

        <section>
          <title>Direct-to-API Components</title>

          <para>In response to the shortcomings of the BDE, a number of
          component suites have become available for Delphi and Borland
          C++Builder that bypass the BDE layer completely and encapsulate the
          Firebird API directly.</para>

          <itemizedlist>
            <listitem>
              <para>IB Objects is the most mature, having been in production
              for four years. It offers two BDE-free suites for data access,
              one compatible with the native Delphi and C++Builder TDatasource
              and visual controls, the other completely independent of the
              Delphi data access architecture and supplied with its own visual
              controls.</para>
            </listitem>

            <listitem>
              <para>FIBPlus developed from the FreeIBComponents suite of
              Gregory Deatz, offers a connectivity based on TDataset.</para>
            </listitem>

            <listitem>
              <para>InterBaseXpress (IBX) was also developed from
              FreeIBComponents. Its TDataset-based data access components were
              purchased for developing as a proprietary product by Borland.
              Components encapsulating the new Services API were added. It was
              left unfinished in 1999. Its source code was opened under the
              InterBase Public License in 2000 and it continues to be
              developed as an open source project. Borland distributes
              versions of IBX with some Delphi, Kylix and C++Builder
              versions.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section id="ufb-cs-appdev-rad-others">
        <title>Other RAD environments</title>

        <!--Uhm... are the following really RAD environments ???-->

        <section>
          <title>Microsoft <quote>open connectivity</quote></title>

          <para>Third-party ODBC and OLE-DB drivers are available for Windows
          programmers using Microsoft and other vendor's rapid application
          development tools.</para>
        </section>

        <section>
          <title>Java</title>

          <para>A pure Java Type 4 JDBC driver called Jaybird is available for
          Firebird. Jaybird is compliant with both the new JCA standard for
          application server connections to enterprise information systems and
          the established JDBC standard.</para>

          <note>
            <para>Firebird has abandoned re-implementation of the Borland
            InterClient and Interserver platform-independent client
            layers.</para>
          </note>
        </section>
      </section>
    </section>

    <section id="ufb-cs-appdev-api">
      <title>API applications</title>

      <para>The Firebird client program supports three discrete application
      programming interface (API) modules. The most important is the core API,
      through which all database work is performed. Two lesser API modules –
      the Services API and the Install API – provide functions for accessing
      various command-line and other utilities from application programs.
      Developers can write high-level programming or script language
      applications that populate the structures and call the API functions
      directly.</para>

      <section id="ufb-cs-appdev-coreapi">
        <title>The Firebird core API</title>

        <para>Programmers who want to use the core API have to write code for
        allocating and populating the data structures that provide the
        communication layer between the client library and the server.
        Interactive SQL clients, component interfaces and embedded SQL
        <quote>hide</quote> these structures from the programmer by
        encapsulating them in their own higher level interfaces. Writing code
        that calls the API functions directly can be more powerful and
        flexible, with the following benefits:</para>

        <itemizedlist>
          <listitem>
            <para>Memory allocation control</para>
          </listitem>

          <listitem>
            <para>No precompiling necessary</para>
          </listitem>

          <listitem>
            <para>Access to transaction handles and options</para>
          </listitem>

          <listitem>
            <para>Full access to error messages</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="ufb-cs-appdev-coreapi-funcs">
        <title>Core API function categories</title>

        <para>Based on their operation targets, we can divide the API
        functions into the following categories:</para>

        <itemizedlist>
          <listitem>
            <para>Database connection control</para>
          </listitem>

          <listitem>
            <para>Transaction control</para>
          </listitem>

          <listitem>
            <para>Statement execution</para>
          </listitem>

          <listitem>
            <para>Blob functions</para>
          </listitem>

          <listitem>
            <para>Array functions</para>
          </listitem>

          <listitem>
            <para>Security functions</para>
          </listitem>

          <listitem>
            <para>Informational functions</para>
          </listitem>

          <listitem>
            <para>Type conversions</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="ufb-cs-appdev-servicesapi">
        <title>The Services API</title>

        <para>The opened InterBase 6.0 code from which Firebird was developed
        surfaced for the first time an application programming interface (API)
        providing a function call interface to certain server activities such
        as backup/restore, statistics and user management. Many of these calls
        provide programming interfaces to the code in the command-line tools.
        A few lower-level server functions are included as well, some of which
        overlap functions already available in the core API.</para>

        <para>Borland's InterBaseXpress (IBX) components include a subset –
        known as the Service components – encapsulating access to services API
        calls from some versions of their Delphi, Kylix and C++Builder
        development environments.</para>

        <warning>
          <para>The Services API and the Borland service components work only
          with Superserver servers.</para>
        </warning>

        <!-- Editor's note: this is of course no longer the case. -->
      </section>

      <section id="ufb-cs-appdev-installapi">
        <title>The Install API</title>

        <para>The Install API enables you to develop programs for installing
        Firebird. Your application could, for instance, perform a
        <quote>silent</quote> Firebird install as part of its own
        installation.</para>

        <note>
          <para>This API should be regarded as deprecated in Firebird until
          such time as the source code should be released to open
          source.</para>
        </note>

        <!--Has this ever happened?-->
      </section>
    </section>
  </section>

  <section id="ufb-cs-serverprogr">
    <title>Server-side programming</title>

    <para>Among Firebird's powerful features for dynamic client/server
    application programming is its capability to precompile source code on the
    server, storing the object code right inside the database in most cases.
    Such procedures and functions are executed completely on the server,
    optionally returning values or data sets to the client application.
    Firebird provides three styles of server-side programming capability:
    stored procedures, triggers and user-defined functions (UDFs).</para>

    <section id="ufb-cs-storedprocs">
      <title>Stored procedures</title>

      <para>Firebird's procedure language (PSQL) implements extensions to its
      SQL language, providing conditional logic, flow control structures,
      exception handling (both built-in and user-defined), local variables, an
      event mechanism and the capability to accept input arguments of almost
      any type supported by Firebird. It implements a powerful flow control
      structure for processing cursors which can output a dataset directly to
      client memory without the need to create temporary tables. Such
      procedures are called from the client with a SELECT statement and are
      known to developers as selectable stored procedures.</para>

      <para>Stored procedures can embed other stored procedures and can be
      recursive. All stored procedure execution, including selection of data
      sets from procedures and embedded calls to other procedures, is under
      the control of the single transaction that calls it. Accordingly, the
      work of a stored procedure call will be cancelled totally if the client
      rolls back the transaction.</para>
    </section>

    <section id="ufb-cs-triggers">
      <title>Triggers</title>

      <para>Triggers are special procedures created for specific tables, for
      automatic execution during the process of committing DML work to the
      server. Any table can have any number of triggers to be executed before
      or after inserts, updates and deletions. Execution order is determined
      by a position parameter in the trigger's declaration. Triggers have some
      language extensions not available to regular stored procedures or to
      dynamic sql, notably the context variables OLD and NEW which, when
      prefixed to a column identifier, provide references to the existing and
      requested new values of the column. Triggers can embed other stored
      procedures.</para>

      <para>Work performed by triggers will be rolled back if the transaction
      that prompted them is rolled back.</para>

      <para>Stored procedures and triggers can not start transactions.</para>
    </section>

    <section id="ufb-cs-udfs">
      <title>User-defined functions</title>

      <para>By design, in order to preserve its small footprint, Firebird
      comes with a very modest arsenal of internally-defined (native) data
      transformation functions. Developers can write their own very precise
      functions in familiar host-language code such as C/C++, Pascal or Object
      Pascal to accept arguments and return a single result. Once an external
      function – UDF – is declared to a database, it becomes available as a
      valid SQL function to applications, stored procedures and
      triggers.</para>

      <para>Firebird supplies two libraries of ready-to-use UDFs: ib_udf
      (available for both Windows and Linux) and FBUDF, currently available
      for Windows and under development for Linux. Firebird looks for UDFs in
      libraries stored in the /udf directory of its installation or in other
      directories configured by the
      <emphasis>external_function_directory</emphasis> parameter in the
      Firebird configuration file.</para>
    </section>
  </section>

  <section id="ufb-cs-multidb">
    <title>Multi-database applications</title>

    <!--Should logically be a subsection of "Application development"-->

    <para>Firebird applications can work with several databases at the same
    time through the client library. Many other relational database systems
    don't allow this. <!--Is that a fact?-->Tables from separate databases can
    not be joined to return linked sets, but cursors can be used to combine
    information.</para>

    <para>If consistency across database boundaries is required, Firebird can
    manage output sets from querying multiple databases inside a single
    transaction. Firebird implements automatic two-phase commit when data
    changes occur, to ensure that changes cannot be committed in one database
    if changes in another database, within the same transaction context, are
    rolled back or lost through a network failure.</para>
  </section>
</chapter>