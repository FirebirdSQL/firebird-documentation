<?xml version="1.0" encoding="UTF-8"?>
<!-- - - > <!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"><	! - - -->
<chapter id="datadefinition">
	<chapterinfo>
		<author>
			<firstname>Tilo</firstname>
			<surname>Muetze</surname>
			<affiliation>
				<address>
					<email>tmuetze@alanti.net</email>
				</address>
			</affiliation>
		</author>
	</chapterinfo>
	<title>Firebird Data Definition Guide</title>
	<para>All <application>InterBase</application> products are trademarks or registered trademarks of Borland. All Borland products are trademarks or registered trademarks of Borland. Other brand and product names are trademarks or registered trademarks of their respective holders.</para>
	<section id="datadefinition-using-the-data-definition-guide">
		<title>Using the Data Definition Guide</title>
		<para>The <application>Firebird</application>
			<emphasis>Data Definition Guide</emphasis>provides information on the following topics:</para>
		<itemizedlist>
			<listitem>
				<para>Designing and creating databases</para>
			</listitem>
			<listitem>
				<para>Working with <application>Firebird</application> structures and objects, including datatypes, domains, tables, indexes and views</para>
			</listitem>
			<listitem>
				<para>Working with tools and utilities such as stored procedures, triggers, blob, filters and generators</para>
			</listitem>
			<listitem>
				<para>Planning and implementing database security</para>
			</listitem>
			<listitem>
				<para>Character sets and collation orders</para>
			</listitem>
		</itemizedlist>
		<section id="datadefinition-what-is-a-data-definition">
			<title>What is a data definition</title>
			<para>An <application>Firebird</application> database is created and populated using SQL statements, which can be divided into two major categories: data definition language(DDL) statements and data manipulation language (DML) statements.</para>
			<para>The underlying structures of the database;its tables, views, and indexes;are created using DDL statements. Collectively, the objects defined with DDL statements are known as <emphasis>metadata</emphasis>. <emphasis>Data definition</emphasis> is the process of creating, modifying, and deleting metadata. Conversely, DML statements are used to populate the database with data, and to manipulate existing data stored in the structures previously defined with DDL statements. The focus of this book is how to use DDL statements. For more information on using DML statements, see the <emphasis>Language Reference</emphasis>.</para>
			<para>DDL statements that create metadata begin with the keyword <command>CREATE</command>, statements that modify metadata begin with the keyword <command>ALTER</command>, and statements that delete metadata begin with the keyword <command>DROP</command>. Some of the basic data definition tasks include:</para>
			<itemizedlist>
				<listitem>
					<para>Creating a database (<command>CREATE DATABASE</command>)</para>
				</listitem>
				<listitem>
					<para>Creating tables (<command>CREATE TABLE</command>)</para>
				</listitem>
				<listitem>
					<para>Altering tables (<command>ALTER TABLE</command>)</para>
				</listitem>
				<listitem>
					<para>Dropping tables (<command>DROP TABLE</command>)</para>
				</listitem>
			</itemizedlist>
			<para>In <application>Firebird</application>, metadata is stored in system tables, which are a set of tables that is automatically created when you create a database. These tables store information about the structure of the database. All system tables begin with "RDB$". Examples of system tables include <command>RDB$RELATIONS</command>, which has information about each table in the database, and <command>RDB$FIELDS</command>, which has information on the domains in the database. For more information about the system tables, see the <emphasis>Language Reference</emphasis>.</para>
			<important>
				<para>You can directly modify columns of a system table, but unless you understand all of the interrelationships between the system tables, modifying them directly can adversely affect other system tables and disrupt your database.</para>
			</important>
		</section>
		<section id="datadefinition-who-should-use-this-guide">
			<title>Who should use this guide</title>
			<para>The <emphasis>Data Definition Guide</emphasis> is a resource for programmers, database designers, and users who create or change an <application>Firebird</application> database or its elements.</para>
			<para>This book assumes the reader has:</para>
			<itemizedlist>
				<listitem>
					<para>Previous understanding of relational database concepts</para>
				</listitem>
				<listitem>
					<para>Read the <command>isql</command> sections in the <application>Firebird</application>
						<emphasis>Getting Started</emphasis> book</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id="datadefinition-related-firebird-documentation">
			<title>Related <application>Firebird</application> documentation</title>
			<para>The <emphasis>Language Reference</emphasis> is the main reference companion to the <emphasis>Data Definition Guide</emphasis>. It supplies the complete syntax and usage for SQL data definition statements. For a complete list of books in the <application>Firebird</application> documentation set, see<!--Link-->Appendix A, "Firebird Document Conventions."</para>
		</section>
		<section id="datadefinition-topics-covered-in-this-guide">
			<title>Topics covered in this guide</title>
			<para>The following table lists and describes the chapters in the Data Definition Guide:</para>
			<table>
				<title>Chapter list for the <emphasis>Data Definition Guide</emphasis>
				</title>
				<tgroup cols="3" align="center" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>
								<para>Chapter</para>
							</entry>
							<entry>
								<para>Description</para>
							</entry>
							<entry>
								<para>SQL statements</para>
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 1, Using the Data Definition Guide</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Overview of <application>Firebird</application> Data Definition features</para>
									</listitem>
									<listitem>
										<para>Using <command>isql</command>, the SQL Data Definition Utility</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<para/>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 2, Designing Databases</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Planning and designing a database</para>
									</listitem>
									<listitem>
										<para>Understanding data integrity rules and using them in a database</para>
									</listitem>
									<listitem>
										<para>Planning physical storage</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<para/>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 3, Creating Databases</para>
							</entry>
							<entry>
								<para>Creating an Firebird database</para>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER/DROP DATABASE</command>
								</para>
								<para>
									<command>CREATE/ALTER/DROP SHADOW</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 4, Specifying Datatypes</para>
							</entry>
							<entry>
								<para>Choosing a datatype</para>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER TABLE</command>
								</para>
								<para>
									<command>CREATE/ALTER DOMAIN</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 5, Working with Domains</para>
							</entry>
							<entry>
								<para>Creating, altering, and dropping domains</para>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER/DROP DOMAIN</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 6, Working with Tables</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Creating and altering database tables, columns, and domains</para>
									</listitem>
									<listitem>
										<para>Setting up referential integrity</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER/DROP TABLE</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 7, Working with Indexes</para>
							</entry>
							<entry>
								<para>Creating and dropping indexes</para>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER/DROP INDEX</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 8, Working with Views</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Creating and dropping views</para>
									</listitem>
									<listitem>
										<para>Using<command>WITH CHECK OPTION</command>
										</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<para>
									<command>CREATE/DROP VIEW</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 9, Working with Stored Procedures</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Using stored procedures</para>
									</listitem>
									<listitem>
										<para>What you can do with stored procedures</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER/DROP PROCEDURE</command>
								</para>
								<para>
									<command>CREATE/ALTER/DROP EXCEPTION</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 10, Working with Triggers</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Using triggers</para>
									</listitem>
									<listitem>
										<para>What you can do with triggers</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<para>
									<command>CREATE/ALTER/DROP TRIGGER</command>
								</para>
								<para>
									<command>CREATE/ALTER/DROP EXCEPTION</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 11, Working with Generators</para>
							</entry>
							<entry>
								<para>Creating, setting, and resetting generators</para>
							</entry>
							<entry>
								<para>
									<command>CREATE/SET GENERATOR</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 12, Planning security</para>
							</entry>
							<entry>
								<para>Securing data and system catalogs with SQL: tables, views, triggers, and procedures</para>
							</entry>
							<entry>
								<para>
									<command>GRANT, REVOKE</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Chapter 13, Character Sets and Collation Orders</para>
							</entry>
							<entry>
								<para>Specifying character sets and collation orders</para>
							</entry>
							<entry>
								<para>
									<command>CHARACTER SET, COLLATE</command>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<!--Link-->Appendix A, Firebird Document Conventions</para>
							</entry>
							<entry>
								<para>Lists typefaces and special characters used in this book to describe syntax and identify object types</para>
							</entry>
							<entry>
								<para/>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</section>
		<section id="datadefinition-using-isql">
			<title>Using <command>isql</command>
			</title>
			<para>You can use <command>isql</command> to interactively create, update, and drop metadata, or you can input a file to<command>isql</command>that contains data definition statements, which is then executed by <command>isql</command> without prompting the user. It is usually preferable to use a data definition file because it is easier to modify the file than to retype a series of individual SQL statements, and the file provides a record of the changes made to the database.</para>
			<para>The <command>isql</command> interface can be convenient for simple changes to existing data, or for querying the database and displaying the results. You can also use the interactive interface as a learning tool. By creating one or more sample databases, you can quickly become more familiar with <application>Firebird</application>.</para>
		</section>
		<section id="datadefinition-using-a-data-definition-file">
			<title>Using a data definition file</title>
			<para>A data definition file can include statements to create, alter, or drop a database, or any other SQL statement. To issue SQL statements through a data definition file, follow these steps:</para>
			<para>
				<orderedlist>
					<listitem>
						<para>Use a text editor to create the data definition file. Each DDL statement should be followed by a<command>COMMIT</command>to ensure its visibility to all subsequent DDL statements in the data definition file.</para>
					</listitem>
					<listitem>
						<para>Save the file.</para>
					</listitem>
					<listitem>
						<para>Input the file into <command>isql</command>. For information on how to input the data definition file using <command>Windows ISQL</command>, see the <emphasis>Operations Guide</emphasis>. For information on how to input the data definition file using command-line <command>isql</command>, see the <emphasis>Operations Guide</emphasis>
						</para>
					</listitem>
				</orderedlist>
			</para>
		</section>
	</section>
	<section id="datadefinition-designing-databases">
		<title>Designing Databases</title>
		<para>This chapter provides a general overview of how to design an <application>Firebird</application> database;it is not intended to be a comprehensive description of the principles of database design. This chapter includes:</para>
		<itemizedlist>
			<listitem>
				<para>An overview of basic design issues and goals</para>
			</listitem>
			<listitem>
				<para>A framework for designing the database</para>
			</listitem>
			<listitem>
				<para>Working with tools and utilities such as stored procedures, triggers, blob, filters and generators</para>
			</listitem>
			<listitem>
				<para>
					<application>Firebird</application>-specific suggestions for designing your database</para>
			</listitem>
			<listitem>
				<para>Suggestions for planning database security</para>
			</listitem>
		</itemizedlist>
		<section id="datadefinition-overview-of-design-issues">
			<title>Overview of design issues</title>
			<para>A database describes real-world organizations and their processes, symbolically representing real-world objects as tables and other database objects. Once the information is organized and stored as database objects, it can be accessed by applications or a user interface displayed on desktop workstations and computer terminals.</para>
			<para>The most significant factor in producing a database that performs well is good database design. Logical database design is an iterative process which consists of breaking down large, heterogeneous structures of information into smaller, homogenous data objects. This process is called <emphasis>normalization</emphasis>. The goal of normalization is to determine the natural relationships between data in the database. This is done by splitting a table into two or more tables with fewer columns. When a table is split during the normalization process, there is no loss of data because the two tables can be put back together with a join operation. Simplifying tables in this manner allows the most compatible data elements and attributes to be grouped into one table.</para>
			<section id="datadefinition-database-versus-data-model">
				<title>Database versus data model</title>
				<para>It is important to distinguish between the <emphasis>description</emphasis> of the database, and the database itself. The description of the database is called the <emphasis>data model</emphasis> and is created at design time. The model is a template for creating the tables and columns; it is created before the table or any associated data exists in the database. The data model describes the logical structure of the database, including the data objects or entities, datatypes, user operations, relationships between objects, and integrity constraints.</para>
				<para>In the relational database model, decisions about logical design are completely independent of the physical structure of the database. This separation allows great flexibility:</para>
				<itemizedlist>
					<listitem>
						<formalpara>
							<title>You do not have to define the physical access paths between the data objects at design time,</title>
							<para>so you can query the database about almost any logical relationship that exists in it.</para>
						</formalpara>
					</listitem>
					<listitem>
						<formalpara>
							<title>The logical structures that describe the database are not affected by changes in the underlying physical storage structures.</title>
							<para>This capability ensures cross-platform portability. You can easily transport a relational database to a different hardware platform because the database access mechanisms defined by the data model remain the same regardless of how the data is stored.</para>
						</formalpara>
					</listitem>
					<listitem>
						<formalpara>
							<title>The logical structure of the database is also independent of what the end-user sees.</title>
							<para>The designer can create a customized version of the underlying database tables with <emphasis>views</emphasis>. A view displays a subset of the data to a given user or group. Views can be used to hide sensitive data, or to filter out data that a user is not interested in. For more information on views, see<!--Link-->Chapter 8, "Working with Views."</para>
						</formalpara>
					</listitem>
				</itemizedlist>
			</section>
			<section id="datadefinition-design-goals">
				<title>Design goals</title>
				<para>Although relational databases are very flexible, the only way to guarantee data integrity and satisfactory database performance is a solid database design; there is no built-in protection against poor design decisions. A good database design:</para>
				<itemizedlist>
					<listitem>
						<formalpara>
							<title>Satisfies the users' content requirements</title>
							<para>for the database. Before you can design the database, you must do extensive research on the requirements of the users and how the database will be used.</para>
						</formalpara>
					</listitem>
					<listitem>
						<formalpara>
							<title>Ensures the consistency and integrity of the data.</title>
							<para>When you design a table, you define certain attributes and constraints that restrict what a user or an application can enter into the table and its columns. By validating the data before it is stored in the table, the database enforces the rules of the data model and reserves data integrity.</para>
						</formalpara>
					</listitem>
					<listitem>
						<formalpara>
							<title>Provides a natural, easy-to-understand structuring of information.</title>
							<para>Good design makes queries easier to understand, so users are less likely to introduce inconsistencies into the data, or to be forced to enter redundant data. This facilitates database updates and maintenance.</para>
						</formalpara>
					</listitem>
					<listitem>
						<formalpara>
							<title>Satisfies the users' performance requirements.</title>
							<para>Good database design ensures better performance. If tables are allowed to be too large, or if there are too many (or too few) indexes, long waits can result. If the database is very large with a high volume of transactions, performance problems resulting from poor design are magnified.</para>
						</formalpara>
					</listitem>
				</itemizedlist>
			</section>
		</section>
		<section id="datadefinition-design-framework">
			<title>Design framework</title>
			<para>The following steps provide a framework for designing a database:</para>
			<para>
				<orderedlist>
					<listitem>
						<para>Determine the information requirements for the database by interviewing prospective users.</para>
					</listitem>
					<listitem>
						<para>Analyze the real-world objects that you want to model in your database. Organize the objects into entities and attributes and make a list.</para>
					</listitem>
					<listitem>
						<para>Map the entities and attributes to <application>Firebird</application> tables and columns.</para>
					</listitem>
					<listitem>
						<para>Determine an attribute that will uniquely identify each object.</para>
					</listitem>
					<listitem>
						<para>Develop a set of rules that govern how each table is accessed, populated, and modified.</para>
					</listitem>
					<listitem>
						<para>Establish relationships between the objects (tables and columns).</para>
					</listitem>
					<listitem>
						<para>Plan database security.</para>
					</listitem>
				</orderedlist>
			</para>
			<para>The following sections describe each of these steps in more detail.</para>
		</section>
		<section id="datadefinition-analyzing-requirements">
			<title>Analyzing requirements</title>
			<para>The first step in the design process is to research the environment that you are trying to model. This involves interviewing prospective users in order to understand and document their requirements. Ask the following types of questions:</para>
			<itemizedlist>
				<listitem>
					<para>Will your applications continue to function properly during the implementation phase? Will the system accommodate existing applications, or will you need to restructure applications to fit the new system?</para>
				</listitem>
				<listitem>
					<para>Whose applications use which data? Will your applications share common data?</para>
				</listitem>
				<listitem>
					<para>How do the applications use the data stored in the database? Who will be entering the data, and in what form? How often will the data objects be changed?</para>
				</listitem>
				<listitem>
					<para>What access do current applications require? Do your applications use only one database, or do they need to use several databases which might be different in structure? What access do they anticipate for future applications, and how easy is it be to implement new access paths?</para>
				</listitem>
				<listitem>
					<para>Which information is the most time-critical, requiring fast retrieval or updates?</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id="datadefinition-collecting-and-analyzing-data">
			<title>Collecting and analyzing data</title>
			<para>Before designing the database objects; the tables and columns; you need to organize and analyze the real-world data on a conceptual level. There are four primary goals:</para>
			<itemizedlist>
				<listitem>
					<formalpara>
						<title>Identify the major functions and activities of your organization.</title>
						<para>For example: hiring employees, shipping products, ordering parts, processing paychecks, and so on.</para>
					</formalpara>
				</listitem>
				<listitem>
					<formalpara>
						<title>Identify the objects of those functions and activities.</title>
						<para>Building a business operation or transaction into a sequence of events will help you identify all of the entities and relationships the operation entails. For example, when you look at a process like "hiring employees," you can immediately identify entities such as the <database>JOB</database>, the <database>EMPLOYEE</database>, and the <database>DEPARTMENT</database>.</para>
					</formalpara>
				</listitem>
				<listitem>
					<formalpara>
						<title>Identify the characteristics of those objects.</title>
						<para>For example, the <database>EMPLOYEE</database> entity might include such information as <database>EMPLOYEE_ID, FIRST_NAME, LAST_NAME, JOB, SALARY</database>, and so on.</para>
					</formalpara>
				</listitem>
				<listitem>
					<formalpara>
						<title>Identify certain relationships between the objects.</title>
						<para>For example, how do the <database>EMPLOYEE, JOB</database>, and <database>DEPARTMENT</database> entities relate to each other? The employee has one job title and belongs to one department, while a single department has many employees and jobs. Simple graphical flow charts help to identify the relationships.</para>
					</formalpara>
				</listitem>
			</itemizedlist>
			<figure>
				<title>Identifying relationships between objects</title>
				<graphic srccredit="Tilo Muetze, 2001" fileref="images/figuredatadef21.gif"/>
			</figure>
		</section>
		<section id="datadefinition-identifying-entities-and-attributes">
			<title>Identifying entities and attributes</title>
			<para>Based on the requirements that you collect, identify the objects that need to be in the database; the entities and attributes. An <emphasis>entity</emphasis> is a type of person, object, or thing that needs to be described in the database. It might be an object with a physical existence, like a person, a car, or an employee, or it might be an object with a conceptual existence, like a company, a job, or a project. Each entity has properties, called <emphasis>attributes</emphasis>, that describe it. For example, suppose you are designing a database that must contain information about each employee in the company, departmental-level information, information about current projects, and information about customers and sales. The example below shows how to create a list of entities and attributes that organizes the required data.</para>
			<table>
				<title>List of entities and attributes</title>
				<tgroup cols="2" align="center" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>
								<para>Entities</para>
							</entry>
							<entry>
								<para>Attributes</para>
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para>
									<database>EMPLOYEE</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Employee Number</database>
								</para>
								<para>
									<database>Last Name</database>
								</para>
								<para>
									<database>First Name</database>
								</para>
								<para>
									<database>Department Number</database>
								</para>
								<para>
									<database>Job Code</database>
								</para>
								<para>
									<database>Phone Extension</database>
								</para>
								<para>
									<database>Salary</database>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<database>DEPARTMENT</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Department Number</database>
								</para>
								<para>
									<database>Department Name</database>
								</para>
								<para>
									<database>Department Head Name</database>
								</para>
								<para>
									<database>Department Head Employee Number</database>
								</para>
								<para>
									<database>Budget</database>
								</para>
								<para>
									<database>Location</database>
								</para>
								<para>
									<database>Phone Number</database>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<database>PROJECT</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Project ID</database>
								</para>
								<para>
									<database>Project Name</database>
								</para>
								<para>
									<database>Project Description</database>
								</para>
								<para>
									<database>Team Leader</database>
								</para>
								<para>
									<database>Product</database>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<database>CUSTOMER</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Customer Number</database>
								</para>
								<para>
									<database>Customer Name</database>
								</para>
								<para>
									<database>Contact Name</database>
								</para>
								<para>
									<database>Phone Number</database>
								</para>
								<para>
									<database>Address</database>
								</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>
									<database>SALES</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>PO Number</database>
								</para>
								<para>
									<database>Customer Number</database>
								</para>
								<para>
									<database>Sales Rep</database>
								</para>
								<para>
									<database>Order Date</database>
								</para>
								<para>
									<database>Ship Date</database>
								</para>
								<para>
									<database>Order Status</database>
								</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>By listing the entities and associated attributes this way, you can begin to eliminate redundant entries. Do the entities in your list work as tables? Should some columns be moved from one group to another? Does the same attribute appear in several entities? Each attribute should appear only once, and you need to determine which entity is the primary owner of the attribute. For example, <database>DEPARTMENT HEAD NAME</database> should be eliminated because employee names (<database>FIRST NAME</database> and <database>LAST NAME</database>) already exist in the <database>EMPLOYEE</database> entity.<database>DEPARTMENT HEAD EMPLOYEE NUM</database> can then be used to access all of the employee-specific information by referencing <database>EMPLOYEE NUMBER</database> in the <database>EMPLOYEE</database> entity. For more information about accessing information by reference, see<!--link--> "Establishing relationships between objects".</para>
			<para>The next section describes how to map your lists to actual database objects; entities to tables and attributes to columns.</para>
		</section>
		<section id="datadefinition-designing-tables">
			<title>Designing tables</title>
			<para>In a relational database, the database object that represents a single entity is a <emphasis>table</emphasis>, which is a two-dimensional matrix of rows and columns. Each column in a table represents an attribute. Each row in the table represents a specific <emphasis>instance</emphasis> of the entity. After you identify the entities and attributes, create the <emphasis>data model</emphasis>, which serves as a logical design framework for creating your <application>Firebird</application> database. The data model maps entities and attributes to <application>Firebird</application> tables and columns, and is a detailed description of the database; the tables, the columns, the properties of the columns, and the relationships between tables and columns.</para>
			<para>The example below shows how the <database>EMPLOYEE</database> entity from the entities/attributes list has been converted to a table.</para>
			<table>
				<title>
					<database>EMPLOYEE</database> table</title>
				<tgroup cols="7" align="center" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>
								<para>
									<database>EMP_NO</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>LAST_NAME</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>FIRST_NAME</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>DEPT_NO</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>JOB_CODE</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>PHONE_EXT</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>SALARY</database>
								</para>
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para>24</para>
							</entry>
							<entry>
								<para>Smith</para>
							</entry>
							<entry>
								<para>John</para>
							</entry>
							<entry>
								<para>100</para>
							</entry>
							<entry>
								<para>Eng</para>
							</entry>
							<entry>
								<para>4968</para>
							</entry>
							<entry>
								<para>64000</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>48</para>
							</entry>
							<entry>
								<para>Carter</para>
							</entry>
							<entry>
								<para>Catherine</para>
							</entry>
							<entry>
								<para>900</para>
							</entry>
							<entry>
								<para>Sales</para>
							</entry>
							<entry>
								<para>4967</para>
							</entry>
							<entry>
								<para>72500</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>36</para>
							</entry>
							<entry>
								<para>Smith</para>
							</entry>
							<entry>
								<para>Jane</para>
							</entry>
							<entry>
								<para>600</para>
							</entry>
							<entry>
								<para>Admin</para>
							</entry>
							<entry>
								<para>4800</para>
							</entry>
							<entry>
								<para>37500</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>Each row in the <database>EMPLOYEE</database> table represents a single employee.<database>EMP_NO, LAST_NAME, FIRST_NAME, DEPT_NO, JOB_CODE, PHONE_EXT</database>, and <database>SALARY</database> are the columns that represent employee attributes. When the table is populated with data, rows are added to the table, and a <emphasis>value</emphasis> is stored at the intersection of each row and column, called a field. In the <database>EMPLOYEE</database> table, "Smith" is a data value that resides in a single field of an employee record.</para>
		</section>
		<section id="datadefinition-determining-unique-attributes">
			<title>Determining unique attributes</title>
			<para>One of the tasks of database design is to provide a way to uniquely identify each occurrence or instance of an entity so that the system can retrieve any single row in a table. The values specified in the table's primary key distinguish the rows from each other. A <command>PRIMARY KEY</command> or <command>UNIQUE</command> constraint ensures that values entered into the column or set of columns are unique in each row. If you try to insert a value in a <command>PRIMARY KEY</command> or <command>UNIQUE</command> column that already exists in another row of the same column, <application>Firebird</application> prevents the operation and returns an error.</para>
			<para>For example, in the <command>EMPLOYEE</command> table, <command>EMP_NO</command> is a unique attribute that can be used to identify each employee in the database, so it is the primary key. When you choose a value as a primary key, determine whether it is inherently unique. For example, no two social security numbers or driver's license numbers are ever the same. Conversely, you should not choose a name column as a unique identifier due to the probability of duplicate values. If no single column has this property of being inherently unique, then define the primary key as a composite of two or more columns which, when taken together, are unique.</para>
			<para>A unique key is different from a primary key in that a unique key is not the primary identifier for the row, and is not typically referenced by a foreign key in another table. The main purpose of a unique key is to force a unique value to be entered into the column. You can have only one primary key defined for a table, but any number of unique keys.</para>
		</section>
		<section id="datadefinition-developing-a-set-of-rules">
			<title>Developing a set of rules</title>
			<para>When designing a table, you need to develop a set of rules for each table and column that establishes and enforces data integrity. These rules include:</para>
			<itemizedlist>
				<listitem>
					<para>Specifying a datatype</para>
				</listitem>
				<listitem>
					<para>Choosing international character sets</para>
				</listitem>
				<listitem>
					<para>Creating a domain-based column</para>
				</listitem>
				<listitem>
					<para>Setting default values and <command>NULL</command> status</para>
				</listitem>
				<listitem>
					<para>Defining integrity constraints and cascading rules</para>
				</listitem>
				<listitem>
					<para>Defining <command>CHECK</command> constraints</para>
				</listitem>
			</itemizedlist>
			<section id="datadefinition-specifying-a-datatype">
				<title>Specifying a datatype</title>
				<para>Once you have chosen a given attribute as a column in the table, you must choose a datatype for the attribute. The datatype defines the set of valid data that the column can contain. The datatype also determines which operations can be performed on the data, and defines the disk space requirements for each data item.</para>
				<para>The general categories of SQL datatypes include:</para>
				<itemizedlist>
					<listitem>
						<para>Character datatypes</para>
					</listitem>
					<listitem>
						<para>Whole number (integer) datatypes</para>
					</listitem>
					<listitem>
						<para>Fixed and floating decimal datatypes</para>
					</listitem>
					<listitem>
						<para>Datatypes for dates and times</para>
					</listitem>
					<listitem>
						<para>A Blob datatype to represent data of unspecified length and structure, such as such as graphics and digitized voice; blobs can be numeric, text, or binary</para>
					</listitem>
				</itemizedlist>
				<para>For more information about datatypes supported by Firebird, see <!--link-->Chapter 4, “Specifying Datatypes.”</para>
			</section>
			<section id="datadefinition-choosing-international-character-sets">
				<title>Choosing international character sets</title>
				<para>When you create the database, you can specify a default character set. A default character set determines:</para>
				<itemizedlist>
					<listitem>
						<para>What characters can be used in <command>CHAR</command>, <command>VARCHAR</command>, and <command>BLOB</command> text columns.</para>
					</listitem>
					<listitem>
						<para>The default collation order that is used in sorting a column.</para>
					</listitem>
				</itemizedlist>
				<para>The collation order determines the order in which values are sorted. The <command>COLLATE</command> clause of <command>CREATE TABLE</command> allows users to specify a particular collation order for columns defined as <command>CHAR</command> and <command>VARCHAR</command> text datatypes. You must choose a collation order that is supported for the column’s given character set. The collation order set at the column level overrides a collation order set at the domain level.</para>
				<para>Choosing a default character set is primarily intended for users who are interested in providing a database for international use. For example, the following statement creates a database that uses the ISO8859_1 character set, typically used to support European languages:</para>
				<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’ DEFAULT CHARACTER SET ISO8859_1; ]]></programlisting>
				<para>You can override the database default character set by creating a different character set for a column when specifying the datatype. The datatype specification for a <command>CHAR, VARCHAR</command>, or <command>BLOB</command> text column definition can include a <command>CHARACTER SET</command> clause to specify a particular character set for a column. If you do not specify a character set, the column assumes the default database character set. If the database default character set is subsequently changed, all columns defined after the change have the new character set, but existing columns are not affected.</para>
				<para>If you do not specify a default character set at the time the database is created, the character set defaults to <command>NONE</command>. This means that there is no character set assumption for the columns; data is stored and retrieved just as it was originally entered. You can load any character set into a column defined with <command>NONE</command>, but you cannot load that same data into another column that has been defined with a different character set. No transliteration will be performed between the source and the destination character sets.</para>
				<para>For a list of the international character sets and collation orders that <application>Firebird</application> supports, see <!--link-->Chapter 13, “Character Sets and Collation Orders.”</para>
			</section>
			<section id="datadefinition-specifying-domains">
				<title>Specifying domains</title>
				<para>When several tables in the database contain columns with the same definitions and datatypes, you can create domain definitions and store them in the database. Users who create tables can then reference the domain definition to define column attributes locally.</para>
				<para>For more information about creating and referencing domains, see <!--link-->Chapter 5, "Working with Domains."</para>
			</section>
			<section id="datadefinition-setting-default-values-and-null-status">
				<title>Setting default values and <command>NULL</command> status</title>
				<para>When you define a column, you have the option of setting a <command>DEFAULT</command> value. This value is used whenever an <command>INSERT</command> or <command>UPDATE</command> on the table does not supply an explicit value for the column. Defaults can save data entry time and prevent data entry errors. For example, a possible default for a <command>DATE</command> column could be today’s date; in a Y/N flag column for saving changes, “Y” could be the default. Column-level defaults override defaults set at the domain level.</para>
				<para>Assign a <command>NULL</command> default to insert a <command>NULL</command> into the column if the user does not enter a value. Assign <command>NOT NULL</command> to force the user to enter a value, or to define a default value for the column. <command>NOT NULL</command> must be defined for <command>PRIMARY KEY</command> and <command>UNIQUE</command> key columns.</para>
			</section>
			<section id="datadefinition-defining-integrity-constraints">
				<title>Defining integrity constraints</title>
				<para>
					<emphasis>Integrity constraints</emphasis> are rules that govern column-to-table and table-to-table relationships, and validate data entries. They span all transactions that access the database and are maintained automatically by the system. Integrity constraints can be applied to an entire table or to an individual column. A <command>PRIMARY KEY</command> or <command>UNIQUE</command> constraint guarantees that no two values in a column or set of columns are the same.</para>
				<para>Data values that uniquely identify rows (a primary key) in one table can also appear in other tables. A foreign key is a column or set of columns in one table that contain values that match a primary key in another table. The <command>ON UPDATE</command> and <command>ON DELETE</command> referential constraints allow you to specify what happens to the referencing foreign key when the primary key changes or is deleted.</para>
				<para>For more information on using <command>PRIMARY KEY</command> and <command>FOREIGN KEY</command> constraints, see <!--link-->Chapter 6, “Working with Tables.” For more information on the reasons for using foreign keys, see <!--link-->“Establishing relationships between objects”.</para>
			</section>
			<section id="datadefinition-defining-check-constraints">
				<title>Defining <command>CHECK</command> constraints</title>
				<para>Along with preventing the duplication of values using <command>UNIQUE</command> and <command>PRIMARY KEY</command> constraints, you can specify another type of data entry validation. A <command>CHECK</command> constraint places a condition or requirement on the data values in a column at the time the data is entered. The <command>CHECK</command> constraint enforces a search condition that must be true in order to insert into or update the table or column.</para>
			</section>
		</section>
		<section id="datadefinition-establishing-relationships-between-objects">
			<title>Establishing relationships between objects</title>
			<para>The relationship between tables and columns in the database must be defined in the design. For example, how are employees and departments related? An employee can have only one department (a one-to-one relationship), but a department has many employees (a one-to-many relationship). How are projects and employees related? An employee can be working on more than one project, and a project can include several employees (a many-to-many relationship). Each of these different types of relationships has to be modeled in the database.</para>
			<para>The relational model represents one-to-many relationships with primary key/foreign key pairings. Refer to the following two tables. A project can include many employees, so to avoid duplication of employee data, the <database>PROJECT</database> table can reference employee information with a foreign key. <database>TEAM_LEADER</database> is a foreign key referencing the primary key, <database>EMP_NO</database>, in the <database>EMPLOYEE</database> table.</para>
			<table>
				<title>
					<database>PROJECT</database> table</title>
				<tgroup cols="5" align="center" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>
								<para>
									<database>PROJ_ID</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>TEAM_LEADER</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>PROJ_NAME</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>PROJ_DESC</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>PRODUCT</database>
								</para>
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para>DGPII</para>
							</entry>
							<entry>
								<para>44</para>
							</entry>
							<entry>
								<para>Automap</para>
							</entry>
							<entry>
								<para>blob data</para>
							</entry>
							<entry>
								<para>hardware</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>VBASE</para>
							</entry>
							<entry>
								<para>47</para>
							</entry>
							<entry>
								<para>Video database</para>
							</entry>
							<entry>
								<para>blob data</para>
							</entry>
							<entry>
								<para>software</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>HWRII</para>
							</entry>
							<entry>
								<para>24</para>
							</entry>
							<entry>
								<para>Translator upgrade</para>
							</entry>
							<entry>
								<para>blob data</para>
							</entry>
							<entry>
								<para>software</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<table>
				<title>
					<database>EMPLOYEE</database> table</title>
				<tgroup cols="7" align="center" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>
								<para>
									<database>EMP_NO</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>LAST_NAME</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>FIRST_NAME</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>DEPT_NO</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>JOB_CODE</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>PHONE_EXT</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>SALARY</database>
								</para>
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para>24</para>
							</entry>
							<entry>
								<para>Smith</para>
							</entry>
							<entry>
								<para>John</para>
							</entry>
							<entry>
								<para>100</para>
							</entry>
							<entry>
								<para>Eng</para>
							</entry>
							<entry>
								<para>4968</para>
							</entry>
							<entry>
								<para>64000</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>48</para>
							</entry>
							<entry>
								<para>Carter</para>
							</entry>
							<entry>
								<para>Catherine</para>
							</entry>
							<entry>
								<para>900</para>
							</entry>
							<entry>
								<para>Sales</para>
							</entry>
							<entry>
								<para>4967</para>
							</entry>
							<entry>
								<para>72500</para>
							</entry>
						</row>
						<row>
							<entry>
								<para>36</para>
							</entry>
							<entry>
								<para>Smith</para>
							</entry>
							<entry>
								<para>Jane</para>
							</entry>
							<entry>
								<para>600</para>
							</entry>
							<entry>
								<para>Admin</para>
							</entry>
							<entry>
								<para>4800</para>
							</entry>
							<entry>
								<para>37500</para>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>For more information on using <command>PRIMARY KEY</command> and <command>FOREIGN KEY</command> constraints, see <!--Link-->Chapter 6, “Working with Tables.”</para>
			<section id="datadefinition-enforcing-referential-integrity">
				<title>Enforcing referential integrity</title>
				<para>The primary reason for defining foreign keys is to ensure that the integrity of the data is maintained when more than one table references the same data; rows in one table must always have corresponding rows in the
referencing table. <application>Firebird</application> enforces <emphasis>referential integrity</emphasis> in the following ways:</para>
				<itemizedlist>
					<listitem>
						<para>Before a foreign key can be added, the unique or primary keys that the foreign key references must already be defined.</para>
					</listitem>
					<listitem>
						<para>If information is changed in one place, it must be changed in every other place that it appears. <application>Firebird</application> does this automatically when you use the <command>ON UPDATE</command> option to the <command>REFERENCES</command> clause when defining the constraints for a table or its columns. You can specify that the foreign key value be changed to match the	new primary key value (<command>CASCADE</command>), or that it be set to the column default (<command>SET DEFAULT</command>), or to null (<command>SET NULL</command>). If you choose <command>NO ACTION</command> as the <command>ON UPDATE</command> action, you must manually ensure that the foreign key is updated when the primary key changes. For example, to change a value in the <database>EMP_NO</database> column of the <database>EMPLOYEE</database> table (the primary key), that value must also be updated in the <database>TEAM_LEADER</database> column of the <database>PROJECT</database> table (the foreign key).</para>
					</listitem>
					<listitem>
						<para>When a row containing a primary key in one table is deleted, the meaning of any rows in another table that contain that value as a foreign key is lost unless appropriate action is taken. <application>Firebird</application> provides the <command>ON DELETE</command> option to the <command>REFERENCES</command> clause of <command>CREATE TABLE</command> and <command>ALTER TABLE</command> so that you can specify whether the foreign key is deleted, set to the column default, or set to null when the primary key is deleted. If you choose <command>NO ACTION</command> as the <command>ON DELETE</command> action, you must manually delete the foreign key before deleting the referenced primary key.</para>
					</listitem>
					<listitem>
						<para>
							<application>Firebird</application> also prevents users from adding a value in a column defined as a foreign key that does not reference an existing primary key value. For example, to change a value in the <database>TEAM_LEADER</database> column of the <database>PROJECT</database> table, that value must first be updated in the <database>EMP_NO</database> column of the <database>EMPLOYEE</database> table.</para>
					</listitem>
				</itemizedlist>
				<para>For more information on using <command>PRIMARY KEY</command> and <command>FOREIGN KEY</command> constraints, see <!--links-->Chapter 6, “Working with Tables.”</para>
			</section>
			<section id="datadefinition-normalizing-the-database">
				<title>Normalizing the database</title>
				<para>After your tables, columns, and keys are defined, look at the design as a whole and analyze it using normalization guidelines in order to find logical errors. As mentioned in the overview, normalization involves breaking down larger tables into smaller ones in order to group data together that is naturally related.</para>
				<note>
					<para>A detailed explanation of the normal forms are out of the scope of this document. There are many excellent books on the subject on the market.</para>
				</note>
				<para>When a database is designed using proper normalization methods, data related to other data does not need to be stored in more than one place; if the relationship is properly specified. The advantages of storing the data in one place are:</para>
				<itemizedlist>
					<listitem>
						<para>The data is easier to update or delete.</para>
					</listitem>
					<listitem>
						<para>When each data item is stored in one location and accessed by reference, the possibility for error due to the existence of duplicates is reduced.</para>
					</listitem>
					<listitem>
						<para>Because the data is stored only once, the possibility for introducing inconsistent data is reduced.</para>
					</listitem>
				</itemizedlist>
				<para>In general, the normalization process includes:</para>
				<itemizedlist>
					<listitem>
						<para>Eliminating repeating groups.</para>
					</listitem>
					<listitem>
						<para>Removing partially-dependent columns.</para>
					</listitem>
					<listitem>
						<para>Removing transitively-dependent columns.</para>
					</listitem>
				</itemizedlist>
				<para>An explanation of each step follows.</para>
				<section id="datadefinition-eliminating-repeating-groups">
					<title>Eliminating repeating groups</title>
					<para>When a field in a given row contains more than one value for each occurrence of the primary key, then that group of data items is called a <emphasis>repeating group</emphasis>. This is a violation of the first normal form, which does not allow multi-valued attributes.</para>
					<para>Refer to the <database>DEPARTMENT</database> table. For any occurrence of a given primary key, if a column can have more than one value, then this set of values is a repeating group. Therefore, the first row, where <database>DEPT_NO</database> = “100”, contains a repeating group in the <database>DEPT_LOCATIONS</database> column.</para>
					<table>
						<title>
							<database>DEPARTMENT</database> table</title>
						<tgroup cols="5" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>DEPT_NO</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>DEPARTMENT</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>HEAD_DEPT</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>BUDGET</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>DEPT_LOCATIONS</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Sales</para>
									</entry>
									<entry>
										<para>000</para>
									</entry>
									<entry>
										<para>1000000</para>
									</entry>
									<entry>
										<para>Monterrey, Santa Cruz, Salinas</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>600</para>
									</entry>
									<entry>
										<para>Engineering</para>
									</entry>
									<entry>
										<para>120</para>
									</entry>
									<entry>
										<para>1100000</para>
									</entry>
									<entry>
										<para>San Francisco</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>900</para>
									</entry>
									<entry>
										<para>Finance</para>
									</entry>
									<entry>
										<para>000</para>
									</entry>
									<entry>
										<para>400000</para>
									</entry>
									<entry>
										<para>Monterey</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>In the next example, even if you change the attribute to represent only one location, for every occurrence of the primary key “100”, all of the columns contain repeating information except for <database>DEPT_LOCATION</database>, so this is still a repeating group.</para>
					<table>
						<title>
							<database>DEPARTMENT</database> table</title>
						<tgroup cols="5" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>DEPT_NO</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>DEPARTMENT</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>HEAD_DEPT</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>BUDGET</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>DEPT_LOCATIONS</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Sales</para>
									</entry>
									<entry>
										<para>000</para>
									</entry>
									<entry>
										<para>1000000</para>
									</entry>
									<entry>
										<para>Monterrey</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Sales</para>
									</entry>
									<entry>
										<para>000</para>
									</entry>
									<entry>
										<para>1000000</para>
									</entry>
									<entry>
										<para>Santa Cruz</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>600</para>
									</entry>
									<entry>
										<para>Engineering</para>
									</entry>
									<entry>
										<para>120</para>
									</entry>
									<entry>
										<para>1100000</para>
									</entry>
									<entry>
										<para>San Francisco</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Sales</para>
									</entry>
									<entry>
										<para>000</para>
									</entry>
									<entry>
										<para>1000000</para>
									</entry>
									<entry>
										<para>Salinas</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>To normalize this table, we could eliminate the <database>DEPT_LOCATION</database> attribute from the <database>DEPARTMENT</database> table, and create another table called <database>DEPT_LOCATIONS</database>. We could then create a primary key that is a combination of <database>DEPT_NO</database> and <database>DEPT_LOCATION</database>. Now a distinct row exists for each location of the department, and we have eliminated the repeating groups.</para>
					<table>
						<title>
							<database>DEPT_LOCATIONS</database> table</title>
						<tgroup cols="2" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>DEPT_NO</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>DEPT_LOCATIONS</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Monterey</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Santa Cruz</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>600</para>
									</entry>
									<entry>
										<para>San Francisco</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Salinas</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</section>
				<section id="datadefinition-removing-partially-dependent-columns">
					<title>Removing partially-dependent columns</title>
					<para>Another important step in the normalization process is to remove any non-key columns that are dependent on only part of a composite key. Such columns are said to have a <emphasis>partial key dependency</emphasis>. Non-key columns provide information about the subject, but do not uniquely define it.</para>
					<para>For example, suppose you wanted to locate an employee by project, and you created the <database>PROJECT</database> table with a composite primary key of <database>EMP_NO</database> and <database>PROJ_ID</database>.</para>
					<table>
						<title>
							<database>PROJECT</database> table</title>
						<tgroup cols="6" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>EMP_NO</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_ID</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>LAST_NAME</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_NAME</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_DESC</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PRODUCT</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>44</para>
									</entry>
									<entry>
										<para>DGPII</para>
									</entry>
									<entry>
										<para>Smith</para>
									</entry>
									<entry>
										<para>Automap</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>hardware</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>47</para>
									</entry>
									<entry>
										<para>VBASE</para>
									</entry>
									<entry>
										<para>Jenner</para>
									</entry>
									<entry>
										<para>Video database</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>software</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>24</para>
									</entry>
									<entry>
										<para>HWRII</para>
									</entry>
									<entry>
										<para>Stevens</para>
									</entry>
									<entry>
										<para>Translator upgrade</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>software</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>The problem with this table is that <database>PROJ_NAME, PROJ_DESC</database>, and <database>PRODUCT</database> are attributes of <database>PROJ_ID</database>, but not <database>EMP_NO</database>, and are therefore only partially dependent on the <database>EMP_NO/PROJ_ID</database> primary key. This is also true for <database>LAST_NAME</database> because it is an attribute of <database>EMP_NO</database>, but does not relate to <database>PROJ_ID</database>. To normalize this table, we would remove the <database>EMP_NO</database> and <database>LAST_NAME</database> columns from the <database>PROJECT</database> table, and create another table called <database>EMPLOYEE_PROJECT</database> that has <database>EMP_NO</database> and <database>PROJ_ID</database> as a composite primary key. Now a unique row exists for every project that an employee is assigned to.</para>
				</section>
				<section id="datadefinition-removing-transitively-dependent-columns">
					<title>Removing transitively-dependent columns</title>
					<para>The third step in the normalization process is to remove any non-key columns that depend upon other non-key columns. Each non-key column must be a fact about the primary key column. For example, suppose we added <database>TEAM_LEADER_ID</database> and <database>PHONE_EXT</database> to the <database>PROJECT</database> table, and made <database>PROJ_ID</database> the primary key. <database>PHONE_EXT</database> is a fact about <database>TEAM_LEADER_ID</database>, a non-key column, not about <database>PROJ_ID</database>, the primary key column.</para>
					<table>
						<title>
							<database>PROJECT</database> table</title>
						<tgroup cols="6" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>PROJ_ID</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>TEAM_LEADER_ID</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PHONE_EXT</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_NAME</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_DESC</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PRODUCT</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>DGPII</para>
									</entry>
									<entry>
										<para>44</para>
									</entry>
									<entry>
										<para>4929</para>
									</entry>
									<entry>
										<para>Automap</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>hardware</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>VBASE</para>
									</entry>
									<entry>
										<para>47</para>
									</entry>
									<entry>
										<para>4967</para>
									</entry>
									<entry>
										<para>Video database</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>software</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>HWRII</para>
									</entry>
									<entry>
										<para>24</para>
									</entry>
									<entry>
										<para>4668</para>
									</entry>
									<entry>
										<para>Translator upgrade</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>software</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<para>To normalize this table, we would remove <database>PHONE_EXT</database>, change <database>TEAM_LEADER_ID</database> to <database>TEAM_LEADER</database>, and make <database>TEAM_LEADER</database> a foreign key referencing <database>EMP_NO</database> in the <database>EMPLOYEE</database> table.</para>
					<table>
						<title>
							<database>PROJECT</database> table</title>
						<tgroup cols="5" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>PROJ_ID</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>TEAM_LEADER</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_NAME</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PROJ_DESC</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PRODUCT</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>DGPII</para>
									</entry>
									<entry>
										<para>44</para>
									</entry>
									<entry>
										<para>Automap</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>hardware</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>VBASE</para>
									</entry>
									<entry>
										<para>47</para>
									</entry>
									<entry>
										<para>Video database</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>software</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>HWRII</para>
									</entry>
									<entry>
										<para>24</para>
									</entry>
									<entry>
										<para>Translator upgrade</para>
									</entry>
									<entry>
										<para>blob data</para>
									</entry>
									<entry>
										<para>software</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<table>
						<title>
							<database>EMPLOYEE</database> table</title>
						<tgroup cols="7" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>EMP_NO</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>LAST_NAME</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>FIRST_NAME</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>DEPT_NO</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>JOB_CODE</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>PHONE_EXT</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>SALARY</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>24</para>
									</entry>
									<entry>
										<para>Smith</para>
									</entry>
									<entry>
										<para>John</para>
									</entry>
									<entry>
										<para>100</para>
									</entry>
									<entry>
										<para>Eng</para>
									</entry>
									<entry>
										<para>4968</para>
									</entry>
									<entry>
										<para>64000</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>48</para>
									</entry>
									<entry>
										<para>Carter</para>
									</entry>
									<entry>
										<para>Catherine</para>
									</entry>
									<entry>
										<para>900</para>
									</entry>
									<entry>
										<para>Sales</para>
									</entry>
									<entry>
										<para>4967</para>
									</entry>
									<entry>
										<para>72500</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>36</para>
									</entry>
									<entry>
										<para>Smith</para>
									</entry>
									<entry>
										<para>Jane</para>
									</entry>
									<entry>
										<para>600</para>
									</entry>
									<entry>
										<para>Admin</para>
									</entry>
									<entry>
										<para>4800</para>
									</entry>
									<entry>
										<para>37500</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
				</section>
				<section id="datadefinition-when-to-break-the-rules">
					<title>When to break the rules</title>
					<para>You should try to correct any normalization violations, or else make a conscious decision to ignore them in the interest of ease of use or performance. Just be sure that you understand the design trade-offs that you are making, and document your reasons. It might take several iterations to reach a design that is a desirable compromise between purity and reality, but this is the heart of the design	process.</para>
					<para>For example, suppose you always want data about dependents every time you look up an employee, so you decide to include <database>DEP1_NAME, DEP1_BIRTHDATE</database>, and so on for <database>DEP1</database> through <database>DEP30</database>, in the <database>EMPLOYEE</database> table. Generally speaking, that is terrible design, but the requirements of your application are more important than the abstract purity of your design. In this case, if you wanted to compute the average age of a given employee’s dependents, you would have to explicitly add field values together, rather than asking for a simple average. If you wanted to find all employees with a dependent named “Jennifer,” you would have to test 30 fields for each employee instead of one. If those are not operations that you intend to perform, then go ahead and break the rules. If the efficiency attracts you less than the simplicity, you might consider defining a view that combines records from employees with records from a separate <database>DEPENDENTS</database> table.</para>
					<para>While you are normalizing your data, remember that <application>Firebird</application> offers direct support for array columns, so if your data includes, for example, hourly temperatures for twenty cities for a year, you could define a table with a character column that contains the city name, and a 24 by 366 matrix to hold all of the temperature data for one city for one year. This would result in a table containing 20 rows (one for each city) and two columns, one <database>NAME</database> column and one <database>TEMP_ARRAY</database> column. A normalized version of that record might have 366 rows per city, each of which would hold a city name, a Julian date, and 24 columns to hold the hourly temperatures.</para>
				</section>
			</section>
			<section id="datadefinition-choosing-indexes">
				<title>Choosing indexes</title>
				<para>Once you have your design, you need to consider what indexes are necessary. The basic trade-off with indexes is that more distinct indexes make retrieval by specific criteria faster, but updating and storage slower. One optimization is to avoid creating several indexes on the same column. For example, if you sometimes retrieve employees based on name, department, badge number, or	department name, you should define one index for each of these columns. If a query includes more than one column value to retrieve, Firebird will use more than one index to qualify records. In contrast, defining indexes for every permutation of those three columns will actually slow both retrieval and update operations.</para>
				<para>When you are testing your design to find the optimum combination of indexes, remember that the size of the tables affects the retrieval performance significantly. If you expect to have tables with 10,000 to 100,000 records each, do not run tests with only 10 to 100 records.</para>
				<para>Another factor that affects index and data retrieval times is page size. By increasing the page size, you can store more records on each page, thus reducing the number of pages used by	indexes. If any of your indexes are more than 4 levels deep, you should consider increasing the page size. If indexes on volatile data (data that is regularly deleted and restored, or data that has index key values that change frequently) are less than three levels deep, you should consider reducing your page size. In general, you should use a page size larger than your largest record, although <application>Firebird’s</application> data compression will generally shrink records that contain lots of string data, or lots of numeric values that are 0 or NULL. If your records have those characteristics, you can probably store records on pages which are 20% smaller than the full record size. On the other hand, if your records are not compressible, you should add 5% to the actual record size when
comparing it to the page size.</para>
				<para>For more information on creating indexes, see <!--Link-->Chapter 7, “Working with Indexes.”</para>
			</section>
			<section id="datadefinition-increasing-cache-size">
				<title>Increasing cache size</title>
				<para>When <application>Firebird</application> reads a page from the database onto disk, it stores that page in its cache, which is a set of buffers that are reserved for holding database pages. Ordinarily, the default cache	size of 256 buffers is adequate. If your application includes joins of 5 or more tables, <application>Firebird</application> automatically increases the size of the cache. If your application is well localized, that is, it uses the same small part  of the database repeatedly, you might want to consider increasing the cache size so that you never have to release one page from cache to make room for another.</para>
				<para>You can use the <command>gfix</command> utility to increase the default number of buffers for a specific database using the following command:</para>
				<programlisting><![CDATA[ gfix -buffers n database_name ]]></programlisting>
				<para>You can also change the default cache size for an entire server either by setting the value of <command>DATABASE_CACHE_PAGES</command> in the configuration file or by changing is on the <application>Firebird</application> Settings page of the <application>Firebird</application> Server Properties dialog on Windows platforms. This setting is not recommended because it affects all databases on the server and can easily result in overuse of memory or in unusably small caches. It’s is better to tune your cache on a per-database basis using <command>gfix -buffers</command>.</para>
				<para>For more information about cache size, see the <emphasis>Embedded SQL Guide</emphasis>. For more information about using <command>gfix -buffers</command>, see the <emphasis>Operations Guide</emphasis>
				</para>
			</section>
			<section id="datadefinition-creating-a-multifile-distributed-database">
				<title>Creating a multifile, distributed database</title>
				<para>If you feel that your application performance is limited by disk bandwidth, you might consider creating a multifile database and distributing it across several disks. Multifile databases were  designed to avoid limiting databases to the size of a disk on systems that do not support multi-disk files.</para>
			</section>
		</section>
		<section id="datadefinition-planning-security">
			<title>Planning security</title>
			<para>Planning security for a database is important. When implementing the database design, you should answer the following questions:</para>
			<itemizedlist>
				<listitem>
					<para>Who will have authority to use Firebird?</para>
				</listitem>
				<listitem>
					<para>Who will have authority to open a particular database?</para>
				</listitem>
				<listitem>
					<para>Who will have authority to create and access a particular database object within a given database?</para>
				</listitem>
			</itemizedlist>
			<para>For more information about database security, see <!--Link-->Chapter 12, “Planning Security.”</para>
		</section>
	</section>
	<section id="datadefinition-creating-databases">
		<title>Creating Databases</title>
		<para>This chapter describes how to:</para>
		<itemizedlist>
			<listitem>
				<para>Create a database with <command>CREATE DATABASE</command>
				</para>
			</listitem>
			<listitem>
				<para>Modify the database with <command>ALTER DATABASE</command>
				</para>
			</listitem>
			<listitem>
				<para>Delete a database with <command>DROP DATABASE</command>
				</para>
			</listitem>
			<listitem>
				<para>Create an in-sync, online duplication of the database for recovery purposes with <command>CREATE SHADOW</command>
				</para>
			</listitem>
			<listitem>
				<para>Stop database shadowing with <command>DROP SHADOW</command>
				</para>
			</listitem>
			<listitem>
				<para>Increase the size of a shadow</para>
			</listitem>
			<listitem>
				<para>Extract metadata from an existing database</para>
			</listitem>
		</itemizedlist>
		<section id="datadefinition-what-you-should-know">
			<title>What you should know</title>
			<para>Before creating the database, you should know:</para>
			<itemizedlist>
				<listitem>
					<para>Where to create the database. Users who create databases need to know only the logical names of the available devices in order to allocate database storage. Only the system	administrator needs to be concerned about physical storage (disks, disk partitions, operating system files).</para>
				</listitem>
				<listitem>
					<para>The tables that the database will contain.</para>
				</listitem>
				<listitem>
					<para>The <emphasis>record size</emphasis> of each table, which affects what database page size you choose. A record that is too large to fit on a single page requires more than one page fetch to read or write to it, so access could be faster if you increase the page size.</para>
				</listitem>
				<listitem>
					<para>How large you expect the database to grow. The <emphasis>number of records</emphasis> also affects the page size because the number of pages affects the depth of the index tree. Larger page size means fewer total pages. <application>Firebird</application> operates more efficiently with a shallow index tree.</para>
				</listitem>
				<listitem>
					<para>The number of users that will be accessing the database.</para>
				</listitem>
			</itemizedlist>
		</section>
		<section id="datadefinition-creating-a-database">
			<title>Creating a database</title>
			<para>Create a database in <command>isql</command> with an interactive command or with the <command>CREATE DATABASE</command> statement in an isql script file. For a description of creating a database interactively with <command>IBConsole</command>, see the <emphasis>Operations Guide</emphasis>.</para>
			<para>Although you <emphasis>can</emphasis> create, alter, and drop a database interactively, it is preferable to use a data definition file because it provides a record of the structure of the database. It is easier to modify a source file than it is to start over by retyping interactive SQL statements.</para>
			<section id="datadefinition-using-a-data-definition-file2">
				<title>Using a data definition file</title>
				<para>A data definition file contains SQL statements, including those for creating, altering, or dropping a database. To issue SQL statements through a data definition file, follow these steps:</para>
				<para>
					<orderedlist>
						<listitem>
							<para>Use a text editor to write the data definition file.</para>
						</listitem>
						<listitem>
							<para>Save the file.</para>
						</listitem>
						<listitem>
							<para>Process the file with <command>isql</command>.</para>
						</listitem>
					</orderedlist>
				</para>
				<para>Use <command>-input</command> in command-line <command>isql</command> or use <command>File | Run</command> in an ISQL Script in Windows ISQL. For more information about command-line <command>isql</command> and Windows ISQL, see the Operations Guide.</para>
			</section>
			<section id="datadefinition-using-create-database">
				<title>Using <command>CREATE DATABASE</command>
				</title>
				<para>
					<command>CREATE DATABASE</command> establishes a new database and populates its system tables, or metadata, which are the tables that describe the internal structure of the database. <command>CREATE DATABASE</command> must occur before creating database tables, views, and indexes.</para>
				<para>
					<command>CREATE DATABASE</command> optionally allows you to do the following:</para>
				<itemizedlist>
					<listitem>
						<para>Specify a user name and a password</para>
					</listitem>
					<listitem>
						<para>Change the default page size of the new database</para>
					</listitem>
					<listitem>
						<para>Specify a default character set for the database</para>
					</listitem>
					<listitem>
						<para>Add secondary files to expand the database</para>
					</listitem>
				</itemizedlist>
				<para>
					<command>CREATE DATABASE</command> must be the first statement in the data definition file.</para>
				<important>
					<para>In DSQL, <command>CREATE DATABASE</command> can be executed only with <command>EXECUTE IMMEDIATE</command>. The database handle and transaction name, if present, must be initialized to zero prior to use.</para>
				</important>
				<para>The syntax for <command>CREATE DATABASE</command> is:</para>
				<programlisting><![CDATA[ CREATE {DATABASE | SCHEMA} ’filespec’
	[USER ’username’ [PASSWORD ’password’]]
	[PAGE_SIZE [=] int]
	[LENGTH [=] int [PAGE[S]]]
	[DEFAULT CHARACTER SET charset]
	[ <secondary_file>];
	
<secondary_file> =FILE 'filespec' [<fileinfo>][<secondary_file>]

<fileinfo> = LENGTH [=] int [PAGE[S]] | STARTING [AT [PAGE]] int [ <fileinfo>] ]]></programlisting>
				<important>
					<para>Use single quotes to delimit strings such as file names, user names, and passwords.</para>
				</important>
				<section id="datadefinition-creating-a-single-file-database">
					<title>Creating a single-file database</title>
					<para>Although there are many optional parameters, <command>CREATE DATABASE</command> requires only one parameter, <emphasis>filespec</emphasis>, which is the new database file specification. The file specification contains the device name, path name, and database name.
</para>
					<para>By default, a database is created as a single file, called the <emphasis>primary file</emphasis>. The following example creates a single-file database, named <database>employee.gdb</database>, in the current directory.</para>
					<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’; ]]></programlisting>
					<para>For more information about file naming conventions, see the <emphasis>Operations Guide</emphasis>.</para>
					<section id="datadefinition-specifying-file-size-for-a-single-file-database">
						<title>Specifying file size for a single file database</title>
						<para>You can optionally specify a file length, in pages, for the primary file. For example, the following statement creates a database that is stored in one 10,000-page- long file:</para>
						<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’ LENGTH 10000; ]]></programlisting>
						<para>If the database grows larger than the specified file length, <application>Firebird</application> extends the primary file beyond the <command>LENGTH</command> limit until the disk space runs out. To avoid this, you can store a	database in more than one file, called a <emphasis>secondary file</emphasis>.</para>
						<note>
							<para>Use <command>LENGTH</command> for the primary file only if defining a secondary file in the same statement.</para>
						</note>
					</section>
				</section>
				<section id="datadefinition-creating-a-multifile-database">
					<title>Creating a multifile database</title>
					<para>A multifile database consists of a <emphasis>primary file</emphasis> and one or more <emphasis>secondary files</emphasis>. You cannot specify what information goes into each secondary file because <application>Firebird</application> handles this automatically. Each secondary file is typically assigned to a different disk than that of the main database. In a multifile database, <application>Firebird</application> writes to the primary file until it has filled the specified number of pages, then proceeds to fill the next specified secondary file.</para>
					<para>When you define a secondary file, you can choose to specify its size in database pages (<command>LENGTH</command>), or you can specify the initial page number of the following file 
					(<command>STARTING AT</command>). <application>Firebird</application> always treats the final file of a multifile database as dynamically sizeable: it grows the last file as needed. Although specifying a <command>LENGTH</command> for the final file does not return an error, a <command>LENGTH</command> specification for the last; or only; file of a database is meaningless.</para>
					<important>
						<para>Whenever possible, create the database locally. If the database is created locally, secondary file names can include a full file specification, including a host or node names as well as a path and database file name. If you create the database on a remote server, secondary file specifications cannot include a node name, and all secondary files must reside on the same node.</para>
					</important>
					<section id="datadefinition-specifying-a-secondary-file-using-length">
						<title>Secifying a secondary file using <command>LENGTH</command>
						</title>
						<para>The <command>LENGTH</command> parameter specifies the number of database pages for the file. The eventual maximum file size is then the number of pages times the page size for the database. (See <!--link-->"Specifying database page size”) The following example creates a database with a primary file and three secondary files. The primary file and the first two secondary files are each 10,000 pages long.</para>
						<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’
	FILE ’employee2.gdb’ STARTING AT PAGE 10001 LENGTH 10000 PAGES
	FILE ’employee3.gdb’ LENGTH 10000 PAGES
	FILE ’employee4.gdb’; ]]></programlisting>
						<note>
							<para>Because file-naming conventions are platform-specific, for the sake of simplicity, none of the examples provided include the device and path name portions of the file specification.</para>
						</note>
					</section>
					<section id="datadefinition-specifying-the-starting-page-number-of-a-secondary-file">
						<title>Specifying the starting page number of a secondary file</title>
						<para>If you do not declare a length for a secondary file, then you must specify a starting page number. <command>STARTING AT</command> specifies the beginning page number for a secondary file. The <command>PAGE</command> keyword is optional. You can specify a combination of length and starting page numbers for secondary files.</para>
						<para>If you specify a <command>STARTING AT</command> parameter that is inconsistent with a <command>LENGTH</command> parameter for the previous file, the <command>LENGTH</command> specification takes precedence:</para>
						<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’ LENGTH 10000
	FILE ’employee2.gdb’ LENGTH 10000 PAGES
	FILE ’employee3.gdb’ LENGTH 10000 PAGES
	FILE ’employee4.gdb’; ]]></programlisting>
						<para>The following example produces exactly the same results as the previous one, but uses a mixture of <command>LENGTH</command> and <command>STARTING AT</command>:</para>
						<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’
	FILE ’employee2.gdb’ STARTING AT 10001 LENGTH 10000 PAGES
	FILE ’employee3.gdb’ LENGTH 10000 PAGES
	FILE ’employee4.gdb’; ]]></programlisting>
					</section>
				</section>
				<section id="datadefinition-specifying-user-name-and-password">
					<title>Specifying user name and password</title>
					<para>If provided, the user name and password are checked against valid user name and password combinations in the security database on the server where the database will reside. Only the first 8 characters of the password are significant.</para>
					<important>
						<para>Windows client applications must create their databases on a remote server. For these remote connections, the user name and password are not optional. Windows clients must provide the <command>USER</command> and <command>PASSWORD</command> options with <command>CREATE DATABASE</command> before connecting to a remote server.</para>
					</important>
					<para>The following statement creates a database with a user name and password:</para>
					<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’ USER ’SALES’ PASSWORD ’mycode’; ]]></programlisting>
				</section>
				<section id="datadefinition-specifying-database-page-size">
					<title>Specifying database page size</title>
					<para>You can override the default page size of 1024 bytes for database pages by specifying a different <command>PAGE_SIZE</command>. <command>PAGE_SIZE</command> can be 1024, 2048, 4096, or 8192. The next statement creates a single-file database with a page size of 2048 bytes:</para>
					<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’ PAGE_SIZE 2048; ]]></programlisting>
					<section id="datadefinition-when-to-increase-page-size">
						<title>When to increase page size</title>
						<para>Increasing page size can improve performance for several reasons:</para>
						<itemizedlist>
							<listitem>
								<para>Indexes work faster because the depth of the index is kept to a minimum.</para>
							</listitem>
							<listitem>
								<para>Keeping large rows on a single page is more efficient. (A row that is too large to fit on a single page requires more than one page fetch to read or write to it.)</para>
							</listitem>
							<listitem>
								<para>BLOB data is stored and retrieved more efficiently when it fits on a single page. If an application typically stores large BLOB columns (between 1K and 2K), a page size of 2048 bytes is preferable to the default (1024).</para>
							</listitem>
						</itemizedlist>
						<para>If most transactions involve only a few rows of data, a smaller page size might be appropriate, since less data needs to be passed back and forth and less memory is used by the disk cache.</para>
					</section>
					<section id="datadefinition-changing-page-size-for-an-existing-database">
						<title>Changing page size for an existing database</title>
						<para>To change a page size of an existing database, follow these steps:</para>
						<para>
							<orderedlist>
								<listitem>
									<para>Back up the database.</para>
								</listitem>
								<listitem>
									<para>Restore the database using the <command>PAGE_SIZE</command> option to specify a new page size.</para>
								</listitem>
							</orderedlist>
						</para>
						<para>For more detailed information on backing up the database, see the <emphasis>Operations Guide</emphasis>.</para>
					</section>
				</section>
				<section id="datadefinition-specifying-the-default-character-set">
					<title>Specifying the default character set</title>
					<para>
						<command>DEFAULT CHARACTER SET</command> allows you to optionally set the default character set for the database. The character set determines:</para>
					<itemizedlist>
						<listitem>
							<para>What characters can be used in <command>CHAR</command>, <command>VARCHAR</command>, and <command>BLOB</command> text columns.</para>
						</listitem>
						<listitem>
							<para>The default collation order that is used in sorting a column.</para>
						</listitem>
					</itemizedlist>
					<para>Choosing a default character set is useful for all databases, even those where international use is not an issue. Choice of character set determines if transliteration among character sets is possible. For example, the following statement creates a database that uses the ISO8859_1 character set, typically used in Europe to support European languages:</para>
					<programlisting><![CDATA[ CREATE DATABASE ’employee.gdb’ DEFAULT CHARACTER SET ’ISO8859_1’; ]]></programlisting>
					<para>For a list of the international character sets and collation orders that <application>Firebird</application> supports, see <!--link-->Chapter 13, “Character Sets and Collation Orders.”</para>
					<section id="datadefinition-using-character-set-none">
						<title>Using character set <command>NONE</command>
						</title>
						<para>If you do not specify a default character set, the character set defaults to <command>NONE</command>. Using <command>CHARACTER SET NONE</command> means that there is no character set assumption for columns; data is stored and retrieved just as you originally entered it. You can load any character set into a column defined with <command>NONE</command>, but you cannot load that same data into another column that has been defined with a different character set. No transliteration will be performed between the source and destination character sets, so in most cases, errors will occur during the attempted assignment.</para>
						<para>For example:</para>
						<programlisting><![CDATA[ CREATE TABLE MYDATA (PART_NUMBER CHARACTER(30) CHARACTER SET NONE);
SET NAMES LATIN1;
INSERT INTO MYDATA (PART_NUMBER) VALUES ('à');
SET NAMES DOS437;
SELECT * FROM MYDATA; ]]></programlisting>
						<para>The data (“à”) is returned just as it was entered, without the à being transliterated from the input character (<command>LATIN1</command>) to the output character (<command>DOS437</command>). If the column had been set to anything other than <command>NONE</command>, the transliteration would have occurred.</para>
					</section>
				</section>
			</section>
			<section id="datadefinition-read-only-databases">
				<title>Read-only databases</title>
				<para>By default, databases are in read-write mode at creation time. Such tables must be on a writable filesystem even if they are used only for <command>SELECT</command>, because <application>Firebird</application> writes information about transaction states to a data structure in the database file.</para>
				<para>But you also have the option of changing a database to read-only mode. Such databases can reside on read-only filesystems, such as CD-ROMs.</para>
				<para>To change the mode of a database to read-only, you can either use <command>gfix</command> (or the equivalent choice in <command>IBConsole</command>), or you can back up the database and restore it in read-only mode. See the <emphasis>Operations Guide</emphasis> for details on how to change the mode of a database using <command>gfix</command>, <command>gbak</command>, or <command>IBConsole</command>.</para>
			</section>
		</section>
		<section id="datadefinition-altering-a-database">
			<title>Altering a database</title>
			<para>Use <command>ALTER DATABASE</command> to add one or more secondary files to an existing database. Secondary files are useful for controlling the growth and location of a database. They permit database files to be spread across storage devices, but must remain on the same node as the primary database file. For more information on secondary files, see <!--link-->“Creating a multifile database”.</para>
			<para>A database can be altered by its creator, the <command>SYSDBA</command> user, and any users with operating system root privileges.</para>
			<para>
				<command>ALTER DATABASE</command> requires exclusive access to the database. For more information about exclusive database access, see <!--link-->“Shutting down and restarting databases” of the <emphasis>Operations Guide</emphasis>.</para>
			<para>The syntax for <command>ALTER DATABASE</command> is:</para>
			<programlisting><![CDATA[ ALTER {DATABASE | SCHEMA}
	ADD <add_clause>;

<add_clause> = FILE ’filespec’ <fileinfo> [<add_clause>]

<fileinfo> = {LENGTH [=] int [PAGE[S]] | STARTING [AT [PAGE]] int } [<fileinfo>] ]]></programlisting>
			<para>You must specify a range of pages for each file either by providing the number of pages in each file, or by providing the starting page number for the file.</para>
			<note>
				<para>Note It is never necessary to specify a length for the last; or only; file, because <application>Firebird</application> always dynamically sizes the last file and will increase the file size as necessary until all the available space is used or until it reaches the maximum database file size of 4GB.</para>
			</note>
			<para>The first example adds two secondary files to the currently connected database by specifying the starting page numbers:</para>
			<programlisting><![CDATA[ ALTER DATABASE
	ADD FILE ’employee2.gdb’ STARTING AT PAGE 10001
	ADD FILE ’employee3.gdb’ STARTING AT PAGE 20001 ]]></programlisting>
			<para>The next example does nearly the same thing as the previous example, but it specifies the secondary file length rather than the starting page number. The difference is that in the previous example, the original file will grow until it reaches 10000 pages. In the second example, <application>Firebird</application> starts the secondary file at the next available page and begins using it immediately.</para>
			<programlisting><![CDATA[ ALTER DATABASE
	ADD FILE ’employee2.gdb’ LENGTH 10000
	ADD FILE ’employee3.gdb’ ]]></programlisting>
		</section>
		<section id="datadefinition-dropping-a-database">
			<title>Dropping a database</title>
			<para>
				<command>DROP DATABASE</command> is the command that deletes the database currently connected to, including any associated shadow and log files. Dropping a database deletes any data it contains. A database can be dropped by its creator, the <command>SYSDBA</command> user, and any users with operating system root privileges.</para>
			<para>The following statement deletes the current database:</para>
			<programlisting><![CDATA[ DROP DATABASE; ]]></programlisting>
		</section>
		<section id="datadefinition-creating-a-database-shadow">
			<title>Creating a database shadow</title>
			<para>
				<application>Firebird</application> lets you recover a database in case of disk failure, network failure, or accidental deletion of the database. The recovery method is called shadowing. This  section describes the various tasks involved in shadowing, as well as the advantages and limitations of <emphasis>shadowing</emphasis>. The main tasks in setting up and maintaining shadowing are as follows:</para>
			<itemizedlist>
				<listitem>
					<formalpara>
						<title>Creating a shadow.</title>
						<para>Shadowing begins with the creation of a <emphasis>shadow</emphasis>. A shadow is an identical physical copy of a database. When a shadow is defined for a database, changes to the database are written simultaneously to its shadow. In this way, the shadow always reflects the current state of the database. For information about the different ways to define a shadow, see <!--link-->“Using CREATE SHADOW”.</para>
					</formalpara>
				</listitem>
				<listitem>
					<formalpara>
						<title>Deleting a shadow.</title>
						<para>If shadowing is no longer desired, the shadow can be deleted. For more information about deleting a shadow, see <!--link-->“Dropping a shadow”.</para>
					</formalpara>
				</listitem>
				<listitem>
					<formalpara>
						<title>Adding files to a shadow.</title>
						<para>A shadow can consist of more than one file. As shadows grow in size, files can be added to accommodate the increased space requirements.</para>
					</formalpara>
				</listitem>
			</itemizedlist>
			<section id="datadefinition-advantages-of-shadowing">
				<title>Advantages of shadowing</title>
				<para>Shadowing offers several advantages:</para>
				<itemizedlist>
					<listitem>
						<para>Recovery is quick: Activating a shadow makes it available immediately.</para>
					</listitem>
					<listitem>
						<para>Creating a shadow does not require exclusive access to the database.</para>
					</listitem>
					<listitem>
						<para>You can control the allocation of disk space. A shadow can span multiple files on multiple disks.</para>
					</listitem>
					<listitem>
						<para>Shadowing does not use a separate process. The database process handles writing to the shadow.</para>
					</listitem>
					<listitem>
						<para>Shadowing runs behind the scenes and needs little or no maintenance.</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="datadefinition-limitations-of-shadowing">
				<title>Limitations of shadowing</title>
				<para>Shadowing has the following limitations:</para>
				<itemizedlist>
					<listitem>
						<para>Shadowing is useful only for recovery from hardware failures or accidental deletion of the database. User errors or software failures that corrupt the database are duplicated in the shadow.</para>
					</listitem>
					<listitem>
						<para>Recovery to a specific point in time is not possible. When a shadow is activated, it takes over as a duplicate of the database. Shadowing is an “all or nothing” recovery method.</para>
					</listitem>
					<listitem>
						<para>Shadowing can occur only to a local disk. <application>Firebird</application> does not support shadowing to an NFS file system, mapped drive, tape, or other media.</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="datadefinition-before-creating-a-shadow">
				<title>Before creating a shadow</title>
				<para>Before creating a shadow, consider the following questions:</para>
				<itemizedlist>
					<listitem>
						<para>Where will the shadow reside?</para>
						<para>A shadow should be created on a different disk from where the main database resides. Because shadowing is intended as a recovery mechanism in case of disk failure, maintaining a database and its shadow on the same disk defeats the purpose of shadowing.</para>
					</listitem>
					<listitem>
						<para>How will the shadow be distributed?</para>
						<para>A shadow can be created as a single disk file called a shadow file or as multiple files called a shadow set. To improve space allocation and disk I/O, each file in a shadow set can be placed on a different disk.</para>
					</listitem>
					<listitem>
						<para>If something happens that makes a shadow unavailable, should users be allowed to access the database?</para>
						<para>If a shadow becomes unavailable, <application>Firebird</application> can either deny user access until shadowing is resumed, or <application>Firebird</application> can allow access even though database changes are not being shadowed. Depending on which database behavior is desired, the database administrator (DBA) creates a shadow either in auto mode or in manual mode. For more information about these modes, see <!--link-->“Auto mode and manual mode”.</para>
					</listitem>
					<listitem>
						<para>If a shadow takes over for a database, should a new shadow be automatically created?</para>
						<para>To ensure that a new shadow is automatically created, create a conditional shadow. For more information, see <!--link-->“Conditional shadows”.</para>
					</listitem>
				</itemizedlist>
			</section>
			<section id="datadefinition-using-create-shadow">
				<title>Using <command>CREATE SHADOW</command>
				</title>
				<para>Use the <command>CREATE SHADOW</command> statement to create a database shadow. Because this does not require exclusive access, it can be done without affecting other users. A shadow can be created using a combination of the following options:</para>
				<itemizedlist>
					<listitem>
						<para>Single-file or multifile shadows</para>
					</listitem>
					<listitem>
						<para>Auto or manual shadows</para>
					</listitem>
					<listitem>
						<para>Conditional shadows</para>
					</listitem>
				</itemizedlist>
				<para>These options are not mutually exclusive. For example, you can create a single-file, manual, conditional shadow.</para>
				<para>The syntax of <command>CREATE SHADOW</command> is:</para>
				<programlisting><![CDATA[ CREATE SHADOW set_num [AUTO | MANUAL] [CONDITIONAL]
	’filespec’ [LENGTH [=] int [PAGE[S]]] [<secondary_file>];

<secondary_file> = FILE ’filespec’ [<fileinfo>] [<secondary_file>]

<fileinfo> = {LENGTH[=]int [PAGE[S]] | STARTING [AT [PAGE]] int } [<fileinfo>] ]]></programlisting>
				<section id="datadefinition-creating-a-single-file-shadow">
					<title>Creating a single-file shadow</title>
					<para>To create a single-file shadow for the database <database>employee.gdb</database>, enter:</para>
					<programlisting><![CDATA[ CREATE SHADOW 1 ’employee.shd’; ]]></programlisting>
					<para>The shadow is associated with the currently connected database, <database>employee.gdb</database>. The name of the shadow file is <database>employee.shd</database>, and it is identified by a shadow set number, 1, in this example. The shadow set number tells <application>Firebird</application> that all of the shadow files listed are grouped together under this identifier.</para>
					<para>To verify that the shadow has been created, enter the <command>isql</command> command <command>SHOW DATABASE</command>:</para>
					<programlisting><![CDATA[ SHOW DATABASE;
Database: employee.gdb;
Shadow 1: ’/usr/Firebird/employee.shd’ auto
PAGE_SIZE 1024
Number of DB pages allocated = 392
Sweep interval = 20000 ]]></programlisting>
					<para>The page size of the shadow is the same as that of the database.</para>
				</section>
				<section id="datadefinition-shadow-location">
					<title>Shadow location</title>
					<para>On non-NFS systems, which includes all Windows machines, the shadow must reside on the same host as the database. You cannot specify a different host name or a mapped drive as the location of the shadow.</para>
					<para>On UNIX systems, it is possible to place the shadow on any NFS-mounted directory, but you run the risk of losing the shadow if you experience problems with NFS, so this is not a recommended procedure.</para>
				</section>
				<section id="datadefinition-creating-a-multifile-shadow">
					<title>Creating a multifile shadow</title>
					<para>You can create multifile shadows, similarly to the way you create multifile databases. To create a multifile shadow, specify the name and size of each file in the shadow set. File specifications are platform-specific.</para>
					<para>The following examples illustrate the creation of a multifile shadow on a UNIX platform. They create the shadow files on the A, B, and C drives of the <emphasis>IB_bckup</emphasis> node.</para>
					<para>The first example creates a shadow set consisting of three files. The primary file, <database>employee.shd</database>, is 10,000 database pages in length and the first secondary file is 20,000 database pages long. The final secondary file, as always, grows as needed.</para>
					<programlisting><![CDATA[ CREATE SHADOW 1 ’D:/shadows/employee.shd’ LENGTH 10000
	FILE ’D:/shadows/employee2.shd’ LENGTH 5000
	FILE ’D:/shadows/employee3.shd’; ]]></programlisting>
					<para>Instead of specifying the page length of secondary files, you can specify their starting pages. The previous example could be entered as follows:</para>
					<programlisting><![CDATA[ CREATE SHADOW 1 ’D:/shadows/employee.shd’ LENGTH 10000
	FILE ’D:/shadows/employee2.shd’ STARTING AT 10000
	FILE ’D:/shadows/employee3.shd’ STARTING AT 30000; ]]></programlisting>
					<para>In either case, you can use <command>SHOW DATABASE</command> to verify the file names, page lengths, and starting pages for the shadow just created:</para>
					<programlisting><![CDATA[ SHOW DATABASE;
Database: employee.gdb;
	Owner: SYSDBA
 Shadow 1: "D:\SHADOWS\EMPLOYEE.SHD" auto length 10000
	file D:\SHADOWS\EMPLOYEE2.SHD starting 10000
	file D:\SHADOWS\EMPLOYEE3.SHD starting 30000	
PAGE_SIZE 1024
Number of DB pages allocated = 462
Sweep interval = 20000 ]]></programlisting>
					<note>
						<para>The page length allocated for secondary shadow files need not correspond to the page length of the database’s secondary files. As the database grows and its first shadow file becomes full, updates to the database automatically overflow into the next shadow file.</para>
					</note>
				</section>
				<section id="datadefinition-auto-mode-and-manual-mode">
					<title>Auto mode and manual mode</title>
					<para>A shadow can become unavailable for the same reasons a database becomes unavailable: disk failure, network failure, or accidental deletion. If a shadow becomes unavailable, and it was created in <command>AUTO</command> mode, database operations continue automatically without shadowing. If a shadow becomes unavailable, and it was created in <command>MANUAL</command> mode, further access to the database is denied until the database administrator intervenes. The benefits of <command>AUTO</command> mode and <command>MANUAL</command> mode are compared</para>
					<table>
						<title>Auto vs. manual shadows</title>
						<tgroup cols="3" align="center" colsep="1" rowsep="1">
							<thead>
								<row>
									<entry>
										<para>
											<database>Mode</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>Advantage</database>
										</para>
									</entry>
									<entry>
										<para>
											<database>Disadvantage</database>
										</para>
									</entry>
								</row>
							</thead>
							<tbody>
								<row>
									<entry>
										<para>AUTO</para>
									</entry>
									<entry>
										<para>Database operation is uninterrupted</para>
									</entry>
									<entry>
										<para>Creates a temporary period when the database is not shadowed; the DBA might be unaware that the database is operating without a shadow.</para>
									</entry>
								</row>
								<row>
									<entry>
										<para>MANUAL</para>
									</entry>
									<entry>
										<para>Prevents the database from running unintentionally without a shadow</para>
									</entry>
									<entry>
										<para>Halts database operation until the problem is fixed; needs intervention of the DBA</para>
									</entry>
								</row>
							</tbody>
						</tgroup>
					</table>
					<section id="datadefinition-auto-mode">
						<title>Auto mode</title>
						<para>The <command>AUTO</command> keyword directs the <command>CREATE SHADOW</command> statement to create a shadow in <command>AUTO</command> mode:</para>
						<programlisting><![CDATA[ CREATE SHADOW 1 AUTO 'employee.shd'; ]]></programlisting>
						<para>Auto mode is the default, so omitting the <command>AUTO</command> keyword achieves the same result.</para>
						<para>In <command>AUTO</command> mode, database operation continues even if the shadow becomes inoperable. If the original shadow was created as a conditional shadow, a new shadow is automatically created. If the shadow was not conditional, you must create a new shadow manually. For more information about conditional shadows, see <!--link-->“Conditional shadows”.</para>
					</section>
					<section id="datadefinition-manual-mode">
						<title>Manual mode</title>
						<para>The <command>MANUAL</command> keyword directs the <command>CREATE SHADOW</command> statement to create a shadow in manual mode:</para>
						<programlisting><![CDATA[ CREATE SHADOW 1 MANUAL 'employee.shd'; ]]></programlisting>
						<para>Manual mode is useful when continuous shadowing is more important than continuous operation of the database. When a manual-mode shadow becomes unavailable, further connections to the database are prevented. To allow database connections again, the database administrator must remove the old shadow file, delete references to it, and create a new shadow.</para>
					</section>
				</section>
				<section id="datadefinition-conditional-shadows">
					<title>Conditional shadows</title>
					<para>A shadow can be defined so that if it replaces a database, a new shadow will be automatically created, allowing shadowing to continue uninterrupted. A shadow defined with this behavior is called a <emphasis>conditional</emphasis> shadow.</para>
					<para>To create a conditional shadow, specify the <command>CONDITIONAL</command> keyword with the <command>CREATE SHADOW</command> statement. For example:</para>
					<programlisting><![CDATA[ CREATE SHADOW 3 CONDITIONAL 'employee.shd'; ]]></programlisting>
					<para>Creating a conditional file directs <application>Firebird</application> to automatically create a new shadow. This happens in either of two cases:</para>
					<itemizedlist>
						<listitem>
							<para>The database or one of its shadow files becomes unavailable.</para>
						</listitem>
						<listitem>
							<para>The shadow takes over for the database due to hardware failure.</para>
						</listitem>
					</itemizedlist>
				</section>
			</section>
		</section>
		<section id="datadefinition-dropping-a-shadow">
			<title>Dropping a shadow</title>
			<para>To stop shadowing, use the shadow number as an argument to the <command>DROP SHADOW</command> statement. <command>DROP SHADOW</command> deletes shadow references from a database’s metadata, as well as the physical files on disk.</para>
			<para>A shadow can be dropped by its creator, the <command>SYSDBA</command> user, or any user with operating system root privileges.</para>
			<section id="datadefinition-drop-shadow-syntax">
				<title>
					<command>DROP SHADOW</command> syntax</title>
				<programlisting><![CDATA[ DROP SHADOW set_num; ]]></programlisting>
				<para>The following example drops all of the files associated with the shadow set number 1:</para>
				<programlisting><![CDATA[ DROP SHADOW 1; ]]></programlisting>
				<para>If you need to look up the shadow number, use the <command>isql</command> command <command>SHOW DATABASE</command>.</para>
				<programlisting><![CDATA[ SHOW DATABASE;
Database: employee.gdb;
Shadow 1: ’employee.shd’ auto
PAGE_SIZE 1024
Number of DB pages allocated = 392
Sweep interval = 20000 ]]></programlisting>
			</section>
		</section>
		<section id="datadefinition-expanding-the-size-of-a-shadow">
			<title>Expanding the size of a shadow</title>
			<para>If a database is expected to increase in size, or if the database is already larger than the space available for a shadow on one disk, you might need to expand the size of the shadow. To do this, drop the current shadow and create a new one containing additional files. To add a shadow file, first use <command>DROP SHADOW</command> to delete the existing shadow, then use <command>CREATE SHADOW</command> to recreate it with the desired number of secondary files.</para>
			<para>The page length allocated for secondary shadow files need not correspond to the page length of the database’s secondary files. As the database grows and its first shadow file becomes full,	updates to the database automatically overflow into the next shadow file.</para>
		</section>
		<section id="datadefinition-using-isql-to-extract-data-definitions">
			<title>Using <command>isql</command> to extract data definitions</title>
			<para>
				<command>isql</command> enables you to extract data definition statements from a database and store them in an output file. All keywords and objects are extracted into the file in uppercase.</para>
			<para>The output file enables users to:</para>
			<itemizedlist>
				<listitem>
					<para>Examine the current state of a database’s system tables before planning alterations. This is especially useful when the database has changed significantly since its creation.</para>
				</listitem>
				<listitem>
					<para>Create a database with schema definitions that are identical to the extracted database.</para>
				</listitem>
				<listitem>
					<para>Make changes to the database, or create a new database source file with a text editor.</para>
				</listitem>
			</itemizedlist>
			<!--Here are the IB 3 and 4 extract mechanisms left away-->
		</section>
	</section>
	<section id="datadefinition-specifying-datatypes">
		<title>Specifying Datatypes</title>
		<para>This chapter describes the following:</para>
		<itemizedlist>
			<listitem>
				<para>All of the datatypes that are supported by <application>Firebird</application>, and the allowable operations on each type</para>
			</listitem>
			<listitem>
				<para>Where to specify the datatype, and which data definition statements reference or define the datatype</para>
			</listitem>
			<listitem>
				<para>How to specify a default character set</para>
			</listitem>
			<listitem>
				<para>How to create each datatype, including <command>BLOB</command> data</para>
			</listitem>
			<listitem>
				<para>How to create arrays of datatypes</para>
			</listitem>
			<listitem>
				<para>How to perform datatype conversions</para>
			</listitem>
		</itemizedlist>
		<section id="datadefinition-about-firebird-datatypes">
			<title>About <application>Firebird</application> datatypes</title>
			<para>When creating a new column in an <application>Firebird</application> table, the primary attribute that you must define is the <emphasis>datatype</emphasis>, which establishes the set of valid data that the column can contain. Only values that	can be represented by that datatype are allowed. Besides establishing the set of valid data that a column can contain, the datatype defines the kinds of operations that you can perform on the data. For example, numbers in <command>INTEGER</command> columns can be manipulated with arithmetic operations, while <command>CHARACTER</command> columns cannot.</para>
			<para>The datatype also defines how much space each data item occupies on the disk. Choosing an optimum size for the data value is an important consideration when disk space is limited, especially if a table is very large.</para>
			<para><application>Firebird</application> supports the following datatypes:</para>
			<itemizedlist>
				<listitem>
					<para><command>INTEGER</command> and <command>SMALLINT</command></para>
				</listitem>
				<listitem>
					<para><command>FLOAT</command> and <command>DOUBLE PRECISION</command></para>
				</listitem>
				<listitem>
					<para><command>NUMERIC</command> and <command>DECIMAL</command></para>
				</listitem>
				<listitem>
					<para><command>DATE</command>, <command>TIME</command>, and <command>TIMESTAMP</command></para>
				</listitem>
				<listitem>
					<para><command>CHARACTER</command> and <command>VARYING CHARACTER</command></para>
				</listitem>
				<listitem>
					<para><command>BLOB</command></para>
				</listitem>
			</itemizedlist>
			<para><application>Firebird</application> provides the binary large object (<command>BLOB</command>) datatype to store data that cannot easily be stored in one of the standard SQL datatypes. A <command>BLOB</command> is used to store very large data objects of indeterminate and variable size, such as bitmapped graphics images, vector drawings, sound files, video segments, chapter or book-length documents, or any other kind of multimedia information.</para>
			<para><application>Firebird</application> also supports arrays of most datatypes. An <emphasis>array</emphasis> is a matrix of individual items composed of any single Firebird datatype (except <command>BLOB</command>). An array can have from 1 to 16 dimensions. An array can be handled as a single entity, or manipulated item-by-item.</para>
			<para>A <command>TIMESTAMP</command> datatype is supported that includes information about year, month, day of the month, and time. The <command>TIMESTAMP</command> datatype is stored as two long integers, and requires conversion to and from <application>Firebird</application> when entered or manipulated in a host-language program. The <command>DATE</command> datatype includes information on the year, month, and day of the month. The <command>TIME</command> datatype includes information about time in hours, minutes, seconds, and tenths, hundredths, and thousandths of seconds.</para>
			<para>The following table describes the datatypes supported by <application>Firebird</application>:</para>
			<table>
				<title>Datatypes supported by <application>Firebird</application></title>
				<tgroup cols="3" align="center" colsep="1" rowsep="1">
					<thead>
						<row>
							<entry>
								<para>
									<database>Name</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Size</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Range/Precision</database>
								</para>
							</entry>
							<entry>
								<para>
									<database>Description</database>
								</para>
							</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>
								<para><command>BLOB</command></para>
							</entry>
							<entry>
								<para>Variable</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>None</para>
									</listitem>
									<listitem>
										<para>Blob segment size is limited to 64K</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Dynamically sizable datatype for storing large data such as graphics, text, and digitized voice</para>
									</listitem>
									<listitem>
										<para>Basic structural unit is the segment</para>
									</listitem>
									<listitem>
										<para>Blob subtype describes Blob contents</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>CHAR(n)</command></para>
							</entry>
							<entry>
								<para>n characters</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>1 to 32,767 bytes</para>
									</listitem>
									<listitem>
										<para>Character set character size determines the maximum number of characters that can fit in 32K</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Fixed length <command>CHAR</command> or text string type</para>
									</listitem>
									<listitem>
										<para>Alternate keyword: <command>CHARACTER</command></para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>DATE</command></para>
							</entry>
							<entry>
								<para><command>64 bits</command></para>
							</entry>
							<entry>
								<para>1 Jan 100 a.d. to 29 Feb 32768 a.d.</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>DECIMAL</command>(<emphasis>precision</emphasis>, <emphasis>scale</emphasis>)</para>
							</entry>
							<entry>
								<para>Variable (16, 32, or 64 bits)</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para><emphasis>precision</emphasis> = 1 to 18; specifies at least <emphasis>precision</emphasis> digits of precision to store</para>
									</listitem>
									<listitem>
										<para><emphasis>scale</emphasis> = 0 to 18; specifies number of decimal places must be less than or equal to <emphasis>precision</emphasis></para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Number with a decimal point <emphasis>scale</emphasis> digits from the right</para>
									</listitem>
									<listitem>
										<para>Example: <command>DECIMAL(10, 3)</command> holds numbers accurately in the following format: ppppppp.sss</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>DOUBLE PRECISION</command></para>
							</entry>
							<entry>
								<para><command>64 bits</command><superscript>a</superscript></para>
							</entry>
							<entry>
								<para>2.225 x 10<superscript>–308</superscript> to 1.797 x 10<superscript>308</superscript></para>
							</entry>
							<entry>
								<para>IEEE double precision: 15 digits</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>FLOAT</command></para>
							</entry>
							<entry>
								<para><command>32 bits</command></para>
							</entry>
							<entry>
								<para>1.175 x 10<superscript>–38</superscript> to 3.402 x 10<superscript>38</superscript></para>
							</entry>
							<entry>
								<para>IEEE single precision: 7 digits</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>INTEGER</command></para>
							</entry>
							<entry>
								<para><command>32 bits</command></para>
							</entry>
							<entry>
								<para>–2,147,483,648 to 2,147,483,647</para>
							</entry>
							<entry>
								<para>Signed long (longword)</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>NUMERIC</command>(<emphasis>precision</emphasis>, <emphasis>scale</emphasis>)</para>
							</entry>
							<entry>
								<para>Variable (16, 32, or 64 bits)</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para><emphasis>precision</emphasis> = 1 to 18; specifies at exactly<emphasis>precision</emphasis> digits of precision to store</para>
									</listitem>
									<listitem>
										<para><emphasis>scale</emphasis> = 0 to 18; specifies number of decimal places and must be less than or equal to <emphasis>precision</emphasis></para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>Number with a decimal point <emphasis>scale</emphasis> digits from the right</para>
									</listitem>
									<listitem>
										<para>Example: <command>NUMERIC(10, 3)</command> holds numbers accurately in the following format: ppppppp.sss</para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>SMALLINT</command></para>
							</entry>
							<entry>
								<para><command>16 bits</command></para>
							</entry>
							<entry>
								<para>–32,768 to 32,767</para>
							</entry>
							<entry>
								<para>Signed short (word)</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>TIME</command></para>
							</entry>
							<entry>
								<para><command>64 bits</command></para>
							</entry>
							<entry>
								<para>0:00 AM-23:59.9999 PM</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>TIMESTAMP</command></para>
							</entry>
							<entry>
								<para><command>64 bits</command></para>
							</entry>
							<entry>
								<para>1 Jan 100 a.d. to 29 Feb 32768 a.d.</para>
							</entry>
							<entry>
								<para>Also includes time information</para>
							</entry>
						</row>
						<row>
							<entry>
								<para><command>VARCHAR(n)</command></para>
							</entry>
							<entry>
								<para>n characters</para>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>1 to 32,767 bytes</para>
									</listitem>
									<listitem>
										<para>Character set character size determines the maximum number of characters that can fit in 32K</para>
									</listitem>
								</itemizedlist>
							</entry>
							<entry>
								<itemizedlist>
									<listitem>
										<para>•Variable length <command>CHAR</command> or text string type</para>
									</listitem>
									<listitem>
										<para>Alternate keyword: <command>CHAR VARYING</command>, <command>CHARACTER VARYING</command></para>
									</listitem>
								</itemizedlist>
							</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>a. Actual size of <command>DOUBLE</command> is platform-dependent. Most platforms support the 64-bit size.</para>
		</section>
	</section>
</chapter>
