<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../tools/docbook-dtd/docbookx.dtd">
<article id="isql">
  <articleinfo>
    <title>Firebird Interactive SQL Utility</title>

    <titleabbrev>Isql - Interactive SQL</titleabbrev>

    <author>
      <surname>Kamala Vadlamani</surname>
    </author>

    <othercredit>
      <firstname>Paul</firstname>

      <surname>Vinkenoog</surname>

      <contrib>Extensive review and many changes.</contrib>
    </othercredit>

    <othercredit>
      <firstname>Norman</firstname>

      <surname>Dunbar</surname>

      <contrib>Firebird 2.x updates, conversion to stand alone
      manual.</contrib>
    </othercredit>

    <edition>15 February 2012 – Document version 0.4</edition>
  </articleinfo>

  <section id="isql-intro">
    <title>Introduction</title>

    <para>This manual provides reference material for the Firebird
    <application>Interactive SQL Utility</application>
    (<application>isql</application>), and instructions on how to use it to
    perform tasks within the database.</para>

    <warning>
      <para>This manual is a work in progress. It is subject to change and
      possible restructuring as new versions appear.</para>
    </warning>

    <section id="isql-audience">
      <title>Audience</title>

      <para>This manual assumes prior knowledge of basic database
      concepts.</para>
    </section>

    <section id="isql-version">
      <title>Version</title>

      <para>This manual describes the <application>isql</application> utility
      in Firebird version 1.5 and higher.</para>
    </section>
  </section>

  <section id="isql-overview">
    <title>Overview</title>

    <para>The <application>isql</application> utility is a text-mode client
    tool located in the <filename class="directory">bin</filename> directory
    of the Firebird installation. It provides a command line interface for
    interactive access to a Firebird database. It accepts DSQL statements
    along with a group of SET and SHOW commands to query and interact with the
    Firebird database. Some SET commands can be incorporated in DDL scripts to
    perform batch executions within <application>isql</application>. It also
    accepts DDL, DML and console commands.</para>

    <para>The <application>isql</application> utility can be used in three
    modes: as an interactive session; directly from the command line; and as a
    non-interactive session, using a shell script or batch file. Different
    tasks may be performed in each of the modes, as illustrated below:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>An interactive session can be invoked from the command line of
        the operating system shell, and lasts until the session is terminated,
        using a QUIT or EXIT command. <application>Isql</application> can be
        used interactively to:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Create, update, query, and drop data or meta data.</para>
          </listitem>

          <listitem>
            <para>Input a script file containing a batch of SQL statements in
            sequence without prompting.</para>
          </listitem>

          <listitem>
            <para>Add and modify data.</para>
          </listitem>

          <listitem>
            <para>Grant user permissions.</para>
          </listitem>

          <listitem>
            <para>Perform database administrative functions.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Directly from the command line, with individual options and
        without starting an interactive session. Commands execute, and upon
        completion, return control automatically to the operating
        system.</para>
      </listitem>

      <listitem>
        <para>In a non-interactive session, the user employs a shell script or
        batch file to perform database functions.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Because other applications in the Linux environment, for example,
      mySQL, also use <application>isql</application> as a utility name, you
      are advised to run the Firebird utility from its own directory, or
      provide the absolute file path if you have another relational database,
      besides Firebird, installed on your machine.</para>
    </note>
  </section>

  <section id="isql-invoke">
    <title>Invoking <application>Isql</application></title>

    <para>Go to the <filename class="directory">bin</filename> subdirectory of
    your Firebird installation and type <command>isql</command> (Windows) or
    <command>./isql</command> (Linux) at the command prompt.</para>

    <para>Example:</para>

    <para><screen>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql 
Use CONNECT or CREATE DATABASE to specify a database
SQL&gt; CONNECT "C:\DATABASES\FIREBIRD\MY_EMPLOYEE.FDB" 
CON&gt; user 'SYSDBA' password 'secret';</screen></para>
  </section>

  <section id="isql-start">
    <title>Starting An <application>Isql</application> Session</title>

    <para>To begin an <application>isql</application> session, enter the
    command line options and the name of the database in the Linux /Unix shell
    or Windows command console. For example:</para>

    <para><command>isql [options] [database_name_or_alias]</command></para>

    <note>
      <para>When invoking <application>isql</application>, you will need to
      include an appropriate <userinput>-user</userinput> and
      <userinput>-password</userinput> in your options, unless users have the
      <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar> declared as
      operating system variables. For example:</para>

      <para><command>isql -user SYSDBA -password masterkey</command></para>
    </note>

    <para><application>Isql</application> starts an interactive session if no
    options are specified. If no database is specified, users must connect to
    an existing database or create a new one after starting
    <application>isql</application>. It starts the interactive session by
    connecting to the named database, provided the login options are accurate
    and valid for the specified database. Depending on the options specified,
    <application>isql</application> starts an interactive or non-interactive
    session.</para>

    <para>Reading an input file and writing to an output file are not
    considered interactive tasks, therefore the <userinput>-input</userinput>
    or <userinput>-output</userinput> command line options do not initiate an
    interactive session. Options used to extract DDL statements, such as
    <userinput>-a</userinput> and <userinput>-x</userinput> also only initiate
    a non-interactive session.</para>

    <para><application>Isql</application> can be run from either a local or
    remote client:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>When connecting using a local client, you may set the
        environment variables <envar>ISC_USER</envar> and
        <envar>ISC_PASSWORD</envar>. For more information on these, see
        below.</para>
      </listitem>

      <listitem>
        <para>When connecting from a remote client, you will need a valid name
        and password.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-connect">
    <title>Connecting To A Database</title>

    <para>A sample database named <filename>employee.fdb</filename> is located
    in the <filename class="directory">examples/empbuild</filename>
    subdirectory of your Firebird installation. Users can use this database to
    experiment with Firebird.</para>

    <para>It is possible to connect to a database using
    <application>isql</application> in two ways: locally and remotely.</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>To connect locally, on Windows XP, use the CONNECT statement
        with the full file path or an alias (for a local database):</para>

        <para><command>SQL&gt; CONNECT
        "C:\DATABASES\FIREBIRD\MY_EMPLOYEE.FDB"</command></para>

        <para>On Linux, a similar example would be:</para>

        <para><command>SQL&gt; CONNECT
        "/databases/firebird/MY_EMPLOYEE.FDB"</command></para>
      </listitem>

      <listitem>
        <para>If connecting remotely (using TCP/IP), use the
        <database>CONNECT</database> statement with the server name and
        complete file path of the database or, an alias. When using the full
        path, remember to ensure that the server name is separated from the
        database path with a colon.</para>

        <para>To connect to a database on a Linux/UNIX server named
        cosmos:</para>

        <para><command>SQL&gt; CONNECT
        'cosmos:/usr/firebird/examples/employee.gdb';</command></para>

        <para>To connect to a database on a Windows server named
        cosmos:</para>

        <para><command>SQL&gt; CONNECT
        'cosmos:C:\DATABASES\FIREBIRD\MY_EMPLOYEE.FDB'</command></para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Firebird is slash agnostic and automatically converts either type
      of slash to suit the relevant operating system.</para>
    </note>

    <section>
      <title>Using Database Alias Names</title>

      <para>In the examples above, we have been using the full path to the
      database file. This has a disadvantage in that all clients will be able
      to determine exactly where the database is to be found, or, may cause
      problems when the database has to be moved. To alleviate these problems,
      database aliases can be used.</para>

      <para>Once Firebird has been installed, a file named
      <filename>aliases.conf</filename> can be found in the main installation
      folder. By adding an entry to this folder, the full path to the database
      can be simplified to an alias name. This makes connecting easier, hides
      the actual database path from inquisitive users and allows the database
      to be moved around as necessary without having to change all the clients
      to allow them to connect to the database at the new location.</para>

      <para>To create an alias for the database currently known as
      <filename>/databases/firebird/MY_EMPLOYEE.FDB</filename> on the cosmos
      Linux server, we need to add the following to the
      <filename>aliases.conf</filename> file on the cosmos server. By default,
      this will be in the folder <filename
      class="directory">/opt/firebird</filename>. On Linux, this file is owned
      by the root user and so, must be updated by the root user. On Windows,
      you need to be either an administrator, a power user or SYSTEM to change
      the file.</para>

      <screen>my_employee = /databases/firebird/MY_EMPLOYEE.FDB
</screen>

      <para>There should be no quotes around the path to the database
      file.</para>

      <para>Regardless of where the database file is currently located, or if
      it has its physical filename renamed, etc, all the local users will
      refer to the database simply as <emphasis>my_employee</emphasis>. Remote
      users will refer to this database as
      <emphasis>cosmos:my_employee</emphasis>. The following example shows an
      <application>isql</application> session being connected locally to the
      database using the alias name rather than a full path:</para>

      <screen>cosmos&gt; /opt/firebird/bin/isql my_employee
Database:  test, User: sysdba

SQL&gt;</screen>

      <para>Alternatively, a remote connection would be made as follows,
      specifying the server name and the database alias together:</para>

      <screen>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql cosmos:my_employee
Database:  cosmos:my_employee

SQL&gt;</screen>

      <para>Because the alias is defined on the server where the database
      resides, then the remote client needs to supply the server name and the
      alias name (as defined on that server) in order to make a
      connection.</para>

      <para>Using the <command>CONNECT</command> command in an existing
      <application>isql</application> session is equally as simple using alias
      names:</para>

      <screen>SQL&gt; CONNECT 'cosmos:my_employee;
Database:  cosmos:my_employee

SQL&gt;</screen>

      <caution>
        <para>Regarding the security aspect of using database alias names to
        hide the full path to the actual database file(s), it's not really all
        that secure as the following SQL command shows:</para>

        <screen>SQL&gt; select MON$DATABASE_NAME from mon$database;

MON$DATABASE_NAME
=================================
/data/databases/firebird/test.fdb</screen>
      </caution>
    </section>
  </section>

  <section>
    <title>Creating A Database</title>

    <para>To create a database interactively using the
    <application>isql</application> command shell, get to a command prompt in
    Firebird's <filename class="directory">bin</filename> subdirectory and
    type <command>isql</command> (Windows) or <command>./isql</command>
    (Linux):</para>

    <para><screen>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql
Use CONNECT or CREATE DATABASE to specify a database</screen></para>

    <para>To create a database named <filename>monkey.fdb</filename> and store
    it in a directory named <filename class="directory">test</filename> on
    your <systemitem class="filesystem">C </systemitem>drive:</para>

    <para><screen>SQL&gt;CREATE DATABASE 'C:\test\monkey.fdb' page_size 8192
CON&gt;user 'SYSDBA' password 'masterkey';↵</screen></para>

    <note>
      <para>In the <command>CREATE DATABASE</command> statement it is
      <emphasis>mandatory</emphasis> to place quote characters (single or
      double) around path, user name and password.</para>

      <para>When running Classic Server on Linux, if the database is not
      started with a host name, the database file will be created with the
      Linux login name as the owner. This may cause access rights to others
      who may want to connect at a later stage. By prepending the <systemitem
      class="systemname">localhost:</systemitem> to the path, the server
      process, with Firebird 2.0 running as user <systemitem
      class="username">firebird</systemitem>, will create and own the
      file.</para>
    </note>

    <para>To test the newly created database type:</para>

    <para><screen>SQL&gt;SELECT RDB$RELATION_ID FROM RDB$DATABASE;

RDB$RELATION_ID
===============
128

SQL&gt; commit;</screen></para>

    <para>To get back to the command prompt type <command>quit</command> or
    <command>exit</command>.</para>

    <note>
      <para>The above technique, as demonstrated, works, but ideally databases
      and meta data objects should be created and maintained using data
      definition scripts.</para>
    </note>
  </section>

  <section id="isql-envars">
    <title>Setting The ISC_USER And ISC_PASSWORD Environment Variables</title>

    <para>An environment variable is a named object that contains information
    used by one or more applications. They are global to their specific
    Operating Systems. The Firebird server recognises and uses certain
    environment variables configured in Windows, Linux and other Unix
    systems.</para>

    <para>The ISC_USER and ISC_PASSWORD environment variables in Firebird are
    designed to give SYSDBA access to the database from the command line
    utilities and client applications to anyone who has access to a host
    machine.</para>

    <caution>
      <para>When running command line utilities like
      <application>isql</application>, <application>gbak</application>,
      <application>gstat</application>, and <application>gfix</application>,
      Firebird will search to see if the <envar>ISC_USER</envar> and
      <envar>ISC_PASSWORD</envar> environment variables are set. If you do not
      provide a user name and password while connecting to a database locally,
      Firebird will let you log in provided it finds these variables.</para>

      <para>For security reasons, it is not advised to specify the SYSDBA user
      name and password using these two environment variables especially on an
      insecure computer.</para>
    </caution>

    <para>The <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar>
    environment variables may be set in order to start
    <application>isql</application> locally. To set the environment
    variables:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>In Windows 2000 / XP, this is done in the Control Panel -&gt;
        System -&gt; Advanced -&gt; Environment Variables. Any changes made
        here will be permanent. You may also define these variables in a
        command window prior to running any of the Firebird utilities, such as
        <application>isql</application>. For example:</para>

        <screen>C:\&gt; set ISC_USER=sysdba
C:\&gt; set ISC_PASSWORD=secret
C:\&gt; isql my_employee

SQL&gt;</screen>
      </listitem>

      <listitem>
        <para>In Linux and Unix platforms, this depends on the type of shell
        being used and how the desktop is configured. Please refer to your
        Operating System documentation to set environmental variables. For the
        bash shell, the following example shows the process:</para>

        <screen>cosmos&gt; export ISC_USER=sysdba
cosmos&gt; export ISC_PASSWORD=secret
cosmos&gt; /opt/firebird/bin/isql my_employee

SQL&gt;</screen>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-dialects">
    <title>Dialects</title>

    <para>Firebird supports three SQL dialects in each client and database
    server. These SQL dialects are differentiated in the context of the
    date-time format and the precision of a numerical data type. The dialects
    serve to instruct the Firebird server on how to process features
    implemented in legacy Borland Interbase databases, earlier than version
    6.0. Dialects are set up at runtime and can be changed for the client at
    connection time or with a <command>SET SQL DIALECT</command>
    command.</para>

    <note>
      <para>Dialect 2 is only used when converting a dialect 1 database to a
      dialect 3 database.</para>
    </note>

    <para>The following table illustrates the differences between the
    dialects.</para>

    <table>
      <title>SQL Dialects</title>

      <tgroup cols="4">
        <thead>
          <row>
            <entry>SQL</entry>

            <entry>Dialect 1</entry>

            <entry>Dialect 2</entry>

            <entry>Dialect 3</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Date</entry>

            <entry>Date &amp; Time (Timestamp)</entry>

            <entry>ERROR Message</entry>

            <entry>Date only</entry>
          </row>

          <row>
            <entry>Time Stamp</entry>

            <entry>Timestamp (v.6.x only)</entry>

            <entry>Timestamp</entry>

            <entry>Timestamp</entry>
          </row>

          <row>
            <entry>Time</entry>

            <entry>Error message</entry>

            <entry>Error message</entry>

            <entry>Time only</entry>
          </row>

          <row>
            <entry>&lt;"quoted item"&gt;</entry>

            <entry>String</entry>

            <entry>Error message</entry>

            <entry>Symbol only</entry>
          </row>

          <row>
            <entry>Precision: 1/3 =</entry>

            <entry>0.3333333... (double precision)</entry>

            <entry>0</entry>

            <entry>0</entry>
          </row>

          <row>
            <entry>Numeric 11</entry>

            <entry>double precision</entry>

            <entry>64 bit int</entry>

            <entry>64 bit int</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <note>
      <para>Currently it is possible to create databases in Dialect 1 and 3
      only, however it is recommended that you use Dialect 3 exclusively,
      since Dialect 1 will eventually be deprecated. Dialect 2 cannot be used
      to create a database since it only serves to convert Dialect 1 to
      Dialect 3.</para>
    </note>

    <para>When connecting to a database using <application>isql</application>,
    the utility takes on the dialect of the database, unless you specify
    otherwise. Dialects cannot be set as a parameter of a <command>CREATE
    DATABASE</command> statement. So, when creating a database using
    <application>isql</application>, the database will be in the dialect that
    is current in <application>isql</application> at the time the
    <command>CREATE DATABASE</command> statement is issued. You may set the
    dialect using the <application>isql</application> utility in two
    ways:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>When you start <application>isql</application> type:</para>

        <para><filename><command>cosmos&gt; isql -sql_dialect
        n</command></filename></para>

        <para><filename>(where n refers to the dialect
        number)</filename></para>
      </listitem>
    </itemizedlist>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Within a SQL script or <application>isql</application> session,
        type:</para>

        <para><command>SQL&gt; SET SQL DIALECT n;</command></para>

        <note>
          <para>Prior to Firebird 2.0 when <application>isql</application>
          disconnected from a database, either by dropping it or by trying to
          connect to a non-existent database, it remembered the SQL dialect of
          the previous connection, which lead to some inappropriate warning
          messages. This has been fixed in 2.0</para>
        </note>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-setterm">
    <title>Terminator Character</title>

    <para>The default terminator symbol for the Firebird database is the
    semicolon (;). Statements will only be executed if they end with a
    semicolon. However, you may use <application>isql</application> to change
    the symbol to any printable character from the first 127 characters of the
    ASCII subset, by using the <command>SET TERM</command> command.</para>

    <note>
      <para>The default terminator maybe changed in all instances except in
      the case of<emphasis> procedure language statements</emphasis> or PSQL.
      PSQL does not accept any terminator other than a semicolon.</para>
    </note>

    <para>To change the terminator character to a tilda (~) enter the
    following code:</para>

    <para><command>SQL&gt; SET TERM ~;</command></para>

    <para>You must terminate this command with the current terminator of
    course! Changing the terminator is useful if you wish to type in a PSQL
    function as the following example shows. Because PSQL will
    <emphasis>only</emphasis> accept the semicolon as a terminator, then
    <application>isql</application> needs to know which semicolon is being
    used for the PSQL code and which is being used to terminate the SQL
    commands being entered.</para>

    <programlisting>SQL&gt; set term ~;

SQL&gt; create procedure test_proc (iInput integer = 666)
CON&gt; returns (oOutput integer)
CON&gt; as
CON&gt; begin
CON&gt;   oOutput = iInput;
CON&gt;   suspend;
CON&gt; end~

SQL&gt; set term ;~

SQL&gt; commit;

SQL&gt; select * from test_proc;

     OOUTPUT 
============ 
         666 
</programlisting>

    <para>You can see that withing the code for the procedure itself, the
    terminator is the semicolon. However, outside of the actual procedure
    code, the terminator is the tilde (~). <application>isql</application> is
    processing a single <command>CREATE PROCEDURE</command> command, but
    within that one SQL statement, there are multiple embedded PSQL
    statements:</para>

    <programlisting>oOutput = iInput;
suspend;</programlisting>

    <para>These have the semicolon terminator, as required by PSQL. The end of
    the <command>CREATE PROCEDURE</command> command is indicated by the use of
    the tilde as the terminator:</para>

    <programlisting>end~</programlisting>
  </section>

  <section>
    <title>Isql Prompts</title>

    <formalpara>
      <title>The SQL prompt</title>

      <para>As shown above, the normal <application>isql</application> prompt
      for input is the <prompt>SQL&gt;</prompt> prompt. This indicates that
      the previous command has been completed and
      <application>isql</application> is now waiting for a new command to
      process.</para>
    </formalpara>

    <formalpara>
      <title>The CON prompt</title>

      <para>The <prompt>CON&gt;</prompt> or Continuation prompt is displayed
      if users press ENTER without ending a SQL statement with a terminator.
      For example:</para>
    </formalpara>

    <screen>SQL&gt; HELP
CON&gt;</screen>

    <para>Whenever you see the <prompt>CON&gt;</prompt> prompt, you may either
    continue entering the remainder of the command, or, enter a terminator to
    terminate the command. When you press return, the command will be executed
    in the latter case.</para>
  </section>

  <section id="isql-errors">
    <title>Error Handling And Exception Support</title>

    <para>Exception handling is a programming construct designed to handle an
    occurrence that disrupts the normal execution of a program. These are
    called errors. Exceptions are user-defined named error messages, written
    specifically for a database and stored in that database for use in stored
    procedures and triggers.</para>

    <para>For example, if it is ascertained in a trigger that the value in a
    table is incorrect, the exception is fired. This leads to a rollback of
    the total transaction that the client application is attempting to commit.
    Exceptions can be interleaved, and shared among the different modules of
    an application, and even among different applications sharing a database.
    They provide a simple way to standardize the handling of preprogrammed
    input errors.</para>

    <para>Exceptions are database objects, like Tables, Views and Domains, and
    are part of the database's meta data. They can be created, modified and
    dropped like all other Firebird objects using
    <application>isql</application>.</para>

    <para>In <application>isql</application>, error messages comprise the
    <database>SQLCODE</database> variable and the Firebird status array. The
    following table provides some examples:</para>

    <table frame="all">
      <title>ISQL Error Codes and Messages</title>

      <tgroup cols="3">
        <colspec colname="col1" colwidth="2*" />

        <colspec colname="col2" colwidth="2*" />

        <colspec colname="col3" colwidth="5*" />

        <thead>
          <row>
            <entry><para>SQLCODE</para></entry>

            <entry><para>Message</para></entry>

            <entry><para>Meaning</para></entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para>&lt;0</para></entry>

            <entry><para>SQLERROR</para></entry>

            <entry><para>Error occurred: statement did not
            execute</para></entry>
          </row>

          <row>
            <entry><para>0</para></entry>

            <entry><para>SUCCESS</para></entry>

            <entry><para>Successful execution</para></entry>
          </row>

          <row>
            <entry><para>+1 to +99</para></entry>

            <entry><para>SQLWARNING</para></entry>

            <entry><para>System warning or information message</para></entry>
          </row>

          <row>
            <entry><para>+100</para></entry>

            <entry><para>NOT FOUND</para></entry>

            <entry><para>No qualifying rows found, or end of current active
            set of rows reached</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="isql-transactions">
    <title>Transaction Handling</title>

    <para>The Firebird architecture allows high transaction concurrency.
    Transaction save points (nested transactions) are also supported. All
    Firebird transactions are ACID compliant. ACID is explained below:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><emphasis>Atomicity</emphasis> ensures that transactions either
        complete in their entirety or not at all, even if the system fails
        halfway through the process.</para>
      </listitem>

      <listitem>
        <para><emphasis>Consistency</emphasis> ensures that only valid data
        will be written to the database. If a transaction is executed that
        violates the database’s consistency rules, the entire transaction will
        be rolled back and the database will be restored to a state consistent
        with those rules. If a transaction successfully executes, it will take
        the database from one state that is consistent with the rules to
        another state that is also consistent with the rules, without
        necessarily preserving consistency at all intermediate levels.</para>
      </listitem>

      <listitem>
        <para><emphasis>Isolation</emphasis> ensures that transactions are
        isolated from one another, even if several transactions are running
        concurrently. Concurrency refers to a state within the database where
        two or more tasks are running simultaneously. This way, a
        transaction's updates are concealed from the rest until that
        transaction commits. Transactions in Firebird are isolated within
        separate contexts defined by client applications passing transaction
        parameters.</para>
      </listitem>

      <listitem>
        <para><emphasis>Durability</emphasis> ensures that once a transaction
        commits, its updates survive within the database, even if there is a
        subsequent system crash.</para>
      </listitem>
    </itemizedlist>

    <para>There are several parameters available to configure transactions in
    order to ensure consistency within the database. These parameters invoke
    the concept of concurrency. To ensure data integrity, there are four
    configurable parameters affecting concurrency: isolation level; lock
    resolution mode; access mode; and table reservation.</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><emphasis>Isolation Level:</emphasis> A transaction isolation
        level defines the interaction and visibility of work performed by
        simultaneously running transactions. There are four transaction
        isolation levels according to the SQL standard:<itemizedlist
            spacing="compact">
            <listitem>
              <para>READ COMMITTED: A transaction sees only data committed
              before the statement has been executed.</para>
            </listitem>

            <listitem>
              <para>READ UNCOMMITTED: A transaction sees changes done by
              uncommitted transactions.</para>
            </listitem>

            <listitem>
              <para>REPEATABLE READ: A transaction sees during its lifetime
              only data committed before the transaction has been
              started.</para>
            </listitem>

            <listitem>
              <para>SERIALIZABLE: This is the strictest isolation level, which
              enforces transaction serialization. Data accessed in the context
              of a serializable transaction cannot be accessed by any other
              transaction.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <para>In <application>isql</application>, a transaction is begun as soon
    as the utility is started. The transaction is begun in SNAPSHOT isolation,
    with a lock resolution set to WAIT. Since the Firebird
    <application>isql</application> utility accepts DDL, DML and other
    commands, transactions are handled accordingly, in the following
    ways:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>DDL statements are committed automatically when issued at the
        SQL prompt in two ways:<itemizedlist spacing="compact">
            <listitem>
              <para>When <command>COMMIT</command> statements are included in
              the script.</para>
            </listitem>

            <listitem>
              <para>By ensuring the automatic commit of DDL in a
              <application>isql</application> script, by issuing a
              <command>SET AUTODDL ON</command> statement. To turn it off,
              issue a <command>SET AUTODDL OFF</command> statement at the
              <application>isql</application> prompt.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para>DML statements are not committed automatically. You must issue a
        <command>COMMIT</command> statement to commit any DML changes to the
        database.</para>
      </listitem>

      <listitem>
        <para>You can use various <command>SHOW</command> commands in
        <application>isql</application> to query database meta data. Meta data
        is stored in system tables. When a <command>SHOW</command> command is
        issued it operates in a separate transaction from user statements.
        They run as READ COMMITTED background statements and acknowledge all
        meta data changes immediately.</para>
      </listitem>
    </itemizedlist>

    <para>Users can specify the access mode and level of isolation for the
    next transaction, and explicitly commit the current transaction by using
    the <command>SET TRANSACTION</command> statement. <emphasis>SET
    TRANSACTION</emphasis> can be executed only when there is no other
    transaction being processed. It does not by itself initiate a transaction.
    Here is the syntax:</para>

    <para><command>SQL&gt; SET TRANSACTION;</command></para>

    <para>In Firebird 2.0 the <command>SET TRANSACTION</command> statement has
    been enhanced to support all Transaction Parameter Buffer (TPB) options.
    These include:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>NO AUTO UNDONE</para>
      </listitem>

      <listitem>
        <para>IGNORE LIMBO</para>
      </listitem>

      <listitem>
        <para>LOCK TIMEOUT &lt;number&gt;</para>
      </listitem>
    </itemizedlist>

    <para>Example:</para>

    <para><filename><userinput>SET TRANSACTION WAIT SNAPSHOT NO AUTO UNDONE
    LOCK TIMEOUT 10;</userinput></filename></para>

    <note>
      <para>If you request help on the <command>set</command> in
      <application>isql </application> then the <command>set
      transaction</command> command is not shown.</para>
    </note>
  </section>

  <section id="isql-scripts">
    <title>Script Handling</title>

    <para>A batch of DDL or DML statements in a text file is known as a
    script. Scripts can be used to create and alter database objects. These
    are referred to as Data Definition Language (DDL) scripts. Scripts that
    manipulate data by inserting, updating or performing data conversions, are
    called Data manipulation Language (DML) scripts.</para>

    <para>One of the most important tasks handled by
    <application>isql</application> is to process scripts. It can handle both
    DDL and DML Scripts, but they should be included in separate scripts to
    avoid data integrity problems. This script processing feature of
    <application>isql</application> allows the linking of one script to
    another using the <application>isql</application> command <command>INPUT
    &lt;filespec&gt;</command>. Scripts statements are executed in order. The
    default setting in <application>isql</application> for AUTODDL is set to
    ON. You may use the <command>SET AUTODDL</command> command to control
    where or when statements will be committed.</para>

    <note>
      <para>The AUTODDL setting <emphasis>only</emphasis> affects DDL
      statements. It doesn't commit DML statements. If you mix DDL and DML
      statements within the same interactive session, then the AUTODDL commits
      <emphasis>do not</emphasis> commit your DML transactions. For
      example:</para>

      <screen>SQL&gt; insert into test(a) values (666);
SQL&gt; commit;

SQL&gt; select * from test;

           A 
============ 
         666

SQL&gt; insert into test(a) values (999);
SQL&gt; select * from test;

           A 
============ 
         666
         999 

SQL&gt; create table another_test(b integer);
SQL&gt; rollback;

SQL&gt; select * from test;

           A 
============ 
         666
</screen>
    </note>

    <!--ation>isql</application> utility processes scripts in two
    ways: directly at the command line, or through a tool that processes
    <application>isql</application> scripts. At the command line you may create
    a script using the OUTPUT command or run scripts created in
    <application>isql</application> in another text editor using the INPUT
      command.</para> -->
  </section>

  <section id="isql-interactive">
    <title>Using <application>Isql</application> Interactively</title>

    <para>The Firebird <application>isql</application> utility can be used
    interactively to:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Create, update, query, and drop data and meta data.</para>
      </listitem>

      <listitem>
        <para>Add and modify data.</para>
      </listitem>

      <listitem>
        <para>Test queries.</para>
      </listitem>

      <listitem>
        <para>Perform database administrative functions.</para>
      </listitem>

      <listitem>
        <para>Input a script file containing a batch of SQL statements in
        sequence without prompting.</para>
      </listitem>
    </itemizedlist>

    <para>To perform these functions, <application>isql</application> accepts
    three kinds of commands at the prompt:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>DDL statements: Data Definition Language statements are used to
        define database schemas and/or objects. Examples of DDL commands
        include: <command>CREATE</command>, <command>ALTER</command>,
        <command>RECREATE</command> and <command>DROP</command>.</para>
      </listitem>

      <listitem>
        <para>DML statements: Data Manipulation Language statements allow the
        user to manipulate data objects and relationships between them, in the
        context of given database schemas. DML supports the manipulation and
        processing of database objects. Examples of DML statements are:
        <command>INSERT</command>, <command>UPDATE</command> and
        <command>DELETE</command>.</para>
      </listitem>

      <listitem>
        <para><application>Isql</application> commands, which are instructions
        to <application>isql</application> itself, including
        <command>SET</command> and <command>SHOW</command> commands. These are
        discussed below.<itemizedlist spacing="compact">
            <listitem>
              <para>Commands that perform general tasks, such as processing
              scripts and executing shell commands. These commands are:
              <command>INPUT</command>, <command>OUTPUT</command>,
              <command>QUIT</command>, <command>SHELL</command>,
              <command>BLOBDUMP</command>, <command>BLOBVIEW</command>,
              <command>HELP</command>, <command>EDIT</command>,
              <command>ADD</command>, <command>COPY</command> and
              <command>EXIT</command>. <itemizedlist spacing="compact">
                  <listitem>
                    <formalpara>
                      <title>INPUT</title>

                      <para>reads and executes SQL scripts from a defined text
                      file. These files can have several embedded DDL scripts
                      in them. Scripts, can be created using a text editor or
                      built interactively, using the <command>OUTPUT</command>
                      or <command>EDIT</command> command. For example:</para>
                    </formalpara>

                    <para><command>SQL&gt; INPUT filename;</command></para>

                    <table>
                      <title>INPUT arguments</title>

                      <tgroup cols="2">
                        <colspec align="center" />

                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTIONS</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>FILENAME</entry>

                            <entry>Name of a file containing SQL statements and
                            commands.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>OUTPUT</title>

                      <para>redirects output to a disk file or to a
                      monitor(output screen). To output both data and
                      commands, use <command>SET ECHO ON</command>. To output
                      data only, use <command>SET ECHO OFF</command>. Here is
                      the code:</para>
                    </formalpara>

                    <para><command>SQL&gt; OUTPUT [filename];</command><table>
                        <title>OUTPUT arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>FILENAME</entry>

                              <entry>Name of the file where output is saved. If no
                              file name is given, results appear on the
                              monitor.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example:</para>

                    <screen>SQL&gt; OUTPUT C:\data\managers.dta; 
SQL&gt; SELECT EMP_NO, EMP_NAME FROM MANAGER; /* Output goes to file */ 
SQL&gt; OUTPUT;                               /* Output goes back to screen */</screen>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>SHELL</title>

                      <para>provides temporary access to the command line of
                      the operating system shell without committing or rolling
                      back any transactions. Here is the code:</para>
                    </formalpara>

                    <para><command>SQL&gt; SHELL [operating system
                    command];</command><table>
                        <title>SHELL arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>Operating System command</entry>

                              <entry>A valid operating system command or call.
                              After the command is executed, control returns to
                              <application>isql</application>. In cases where no
                              command is issued, <application>isql</application>
                              opens an interactive session in the OS shell. To
                              return control to <application>isql</application>,
                              type exit.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <screen>SQL&gt; SHELL dir /mydir;</screen></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>BLOBDUMP</title>

                      <para>stores BLOB(Binary Large Object) data in a defined
                      file. Here is the code:</para>
                    </formalpara>

                    <para><command>SQL&gt; BLOBDUMP blob_id
                    filename;</command><table>
                        <title>BLOBDUMP arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>BLOB ID</entry>

                              <entry>Identifier consisting of two hex numbers
                              separated by a colon (:). The first number is the ID
                              of the table containing the BLOB column, the second
                              is a sequenced instance number. To get the blob_id,
                              issue any SELECT statement that selects a column of
                              BLOB data. The output will show the hex blob_id
                              above or in place of the BLOB column data, depending
                              on whether SET BLOB[DISPLAY] is ON or OFF.</entry>
                            </row>

                            <row>
                              <entry>FILENAME</entry>

                              <entry>Fully qualified file system name of the file
                              which is to receive the data.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <screen>SQL&gt; BLOBDUMP 32:d48 IMAGE.JPG;</screen></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>BLOBVIEW</title>

                      <para><command>BLOBVIEW</command> displays BLOB data in
                      the default text editor. Here is the code:</para>
                    </formalpara>

                    <para><command>BLOBVIEW blob_id;</command><table>
                        <title>BLOBVIEW arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>BLOB ID</entry>

                              <entry>Identifier consisting of two hex numbers
                              separated by a colon (:). See BLOBDUMP for
                              instructions on how to determine the blob_id you are
                              looking for. In current versions, BLOBVIEW does not
                              support online editing of the BLOB. It may be
                              introduced in a future release.</entry>
                            </row>

                            <row>
                              <entry>FILENAME</entry>

                              <entry>Fully qualified file system name of the file
                              which is to receive the data.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <screen><code>SQL&gt; BLOBVIEW 85:7;</code></screen><note>
                        <para><command>BLOBVIEW</command> may return an
                        “Invalid transaction handle” error after you close the
                        editor. This is a known bug. To correct the situation,
                        start a transaction manually, with the command
                        <command>SET TRANSACTION;</command></para>
                      </note></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>HELP</title>

                      <para>displays a list of <application>isql</application>
                      commands with descriptions. You can combine it with
                      <command>OUTPUT</command> to print the list to a file.
                      Here is the code:</para>
                    </formalpara>

                    <para><command>SQL&gt; HELP;</command></para>

                    <para>For example, to create a text file containing all
                    the output from the <command>help</command>
                    command:</para>

                    <para><screen>SQL&gt; OUTPUT HELPLIST.TXT; 
SQL&gt; HELP; 
SQL&gt; OUTPUT; /* toggles output back to the monitor */</screen></para>

                    <para>No arguments.</para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>EDIT</title>

                      <para>allows editing and re-execution of the previous
                      <application>isql</application> command or of a batch of
                      commands in a source file. Here is the code:</para>
                    </formalpara>

                    <para><command>SQL&gt; EDIT [filename];</command><table>
                        <title>EDIT arguments</title>

                        <tgroup cols="2">
                          <thead>
                            <row>
                              <entry>ARGUMENT</entry>

                              <entry>DESCRIPTION</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>FILENAME</entry>

                              <entry>Optional, fully qualified file system name of
                              file to edit.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <screen>SQL&gt; EDIT /usr/mystuff/batch.sql;</screen></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>ADD</title>

                      <para>adds rows interactively to a table, field after
                      field.</para>
                    </formalpara>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>COPY</title>

                      <para>copies the structure of a table into a new table,
                      either in the same database or in another.</para>
                    </formalpara>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>EXIT</title>

                      <para>commits the current transaction without prompting,
                      closes the database and ends the
                      <application>isql</application> session.</para>
                    </formalpara>

                    <note>
                      <para>If you need to rollback the transaction instead of
                      committing it, use <command>QUIT</command>
                      instead.</para>
                    </note>

                    <para>Example : <screen>SQL&gt; EXIT;</screen></para>

                    <para>No arguments.</para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>QUIT</title>

                      <para>rolls back the current transaction without
                      prompting, closes the database and ends the
                      <application>isql</application> session.</para>
                    </formalpara>

                    <note>
                      <para>If you need to commit the transaction instead of
                      rolling it back, use <command>EXIT</command>
                      instead.</para>
                    </note>

                    <para>Example : <screen>SQL&gt; QUIT;</screen></para>

                    <para>No arguments.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <formalpara>
                <title>SHOW COMMANDS</title>

                <para>are used to query the database to display meta data.
                Meta data is stored in system tables. Meta data includes the
                definition of database objects such as domains, generators,
                tables, constraints, indices, views, triggers, stored
                procedures, user-defined functions(UDFs), and blob filters.
                <command>SHOW</command> commands run in READ COMMITTED mode to
                ensure the return of the most up-to-date view of the database.
                Here is the list of SHOW commands:</para>
              </formalpara>

              <itemizedlist spacing="compact">
                <listitem>
                  <formalpara>
                    <title>SHOW DOMAIN[S]</title>

                    <para>displays domain information. A domain is a
                    user-defined data type, global to the database. It is used
                    to define the format and range of columns, upon which the
                    actual column definitions in tables are based.</para>
                  </formalpara>

                  <para>Firebird tables are defined by the specification of
                  columns, which store appropriate information in each column
                  using data types.</para>

                  <para>A data type is an elemental unit when defining data,
                  which specifies the type of data stored in tables, and which
                  operations may be performed on this data. It can also
                  include permissible calculative operations and maximum data
                  size. Examples of data types include: numerical (numeric,
                  decimal, integer);textual (char, varchar, nchar, nvarchar);
                  date (date, time, timestamp) and blobs(binary large
                  objects).</para>

                  <para>Here is the syntax to display domain
                  information:</para>

                  <para><command>SQL&gt; SHOW { DOMAINS | DOMAIN name
                  };</command><table>
                      <title>SHOW DOMAIN[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>DOMAIN[S]</entry>

                            <entry>Lists the names of all the domains declared
                            in the database</entry>
                          </row>

                          <row>
                            <entry>DOMAIN name</entry>

                            <entry>Displays definition of the named
                            domain</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>Example :</para>

                  <para><screen>SQL&gt; SHOW DOMAIN;

       ADDRESSLINE                            BUDGET
       COUNTRYNAME                            CUSTNO
       DEPTNO                                 EMPNO
       FIRSTNAME                              JOBCODE
...

SQL&gt; SHOW DOMAIN ADRESSLINE;
ADDRESSLINE                     VARCHAR(30) Nullable</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW GENERATOR[S}</title>

                    <para>displays information about generators. Generators
                    are automatic sequential counters, spanning the entire
                    database. They are outside the purview of transaction
                    control. Here is the syntax to display generator
                    information:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW { GENERATORS | GENERATOR name
                  };</command><table>
                      <title>SHOW GENERATOR[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>GENERATORS</entry>

                            <entry>Lists the names of all generators declared in
                            the database, along with their next values</entry>
                          </row>

                          <row>
                            <entry>GENERATOR NAMES</entry>

                            <entry>Displays the declaration of the named
                            generator, along with its next value</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>Example :</para>

                  <para><screen>SQL&gt; SHOW GENERATORS;
Generator CUST_NO_GEN, current value is 1015
Generator EMP_NO_GEN, current value is 145

SQL&gt; SHOW GENERATOR EMP_NO_GEN;
Generator EMP_NO_GEN, current value is 145
</screen></para>

                  <note>
                    <para>The term <emphasis>generator</emphasis> is non
                    standard and has been replaced by the ANSI Standard term
                    <emphasis>sequence</emphasis>. The above should now be
                    replaced by the following:</para>
                  </note>

                  <screen>SQL&gt; SHOW SEQUENCES;
Generator CUST_NO_GEN, current value is 1015
Generator EMP_NO_GEN, current value is 145

SQL&gt; SHOW SEQUENCE EMP_NO_GEN;
Generator EMP_NO_GEN, current value is 145
</screen>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW CHECK</title>

                    <para>displays all user-defined check constraints defined
                    for a table. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW CHECK &lt;table
                  name&gt;;</command><table>
                      <title>SHOW CHECK arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>Table Name</entry>

                            <entry>Name of a table that exists in the attached
                            database, and if it has any user-defined check
                            constraints</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>Example :</para>

                  <para><screen>SQL&gt; SHOW CHECK COUNTRY;
There are no check constraints on table COUNTRY in this database</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW DATABASE</title>

                    <para>displays information about the attached database
                    (file name, page size and allocation, sweep interval,
                    transaction numbers and Forced Writes status) and starting
                    in Firebird 2.0, also reveals the On-Disk Structure or ODS
                    version.</para>
                  </formalpara>

                  <para>On-Disk structure or ODS identifies a database with
                  the release version of Firebird. The ODS of a database
                  affects its compatibility with server versions. The ODS can
                  be upgraded by using the gbak utility. In Firebird 2.0 ODS
                  has been changed to 11.</para>

                  <para>For version, see <command>SHOW VERSION</command>. Here
                  is the syntax for the code:</para>

                  <para><command>SQL&gt; SHOW DATABASE | DB;</command></para>

                  <para>No arguments.</para>

                  <para>Example :</para>

                  <para><screen>SQL&gt; SHOW DATABASE;
Database: C:\Databases\Firebird\employee.fdb
        Owner: SYSDBA
PAGE_SIZE 4096
Number of DB pages allocated = 259
Sweep interval = 20000
Forced Writes are ON
Transaction - oldest = 179
Transaction - oldest active = 180
Transaction - oldest snapshot = 180
Transaction - Next = 187
ODS = 11.0
Default Character set: NONE</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW EXCEPTION[S]</title>

                    <para>displays exception information.</para>
                  </formalpara>

                  <para>Exceptions are user-defined named error messages,
                  written specifically for a database and stored in that
                  database for use in stored procedures and triggers. An
                  exception is triggered when the value in a table is
                  ascertained to be incorrect. This leads to a rollback of the
                  transaction that the client application is attempting to
                  commit. Exceptions can be interleaved. They can be shared
                  among the different modules of an application, and even
                  among different applications sharing a database. They
                  provide a simple way to standardize the handling of
                  preprogrammed input errors. Here is the syntax for the
                  code:</para>

                  <para><command>SQL&gt; SHOW { EXCEPTIONS | EXCEPTION name
                  };</command><table>
                      <title>SHOW EXCEPTION[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>EXCEPTIONS</entry>

                            <entry>Lists the names and texts of all exceptions
                            declared in the database</entry>
                          </row>

                          <row>
                            <entry>EXCEPTION NAME</entry>

                            <entry>Displays text of the named single
                            exception</entry>
                          </row>

                          <row>
                            <entry>TYPE</entry>

                            <entry>Stored Procedure</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Example :</para>

                  <para><screen>SQL&gt; SHOW EXCEPTIONS;

Exception Name                  Used by, Type
=============================== =================================
CUSTOMER_CHECK                  SHIP_ORDER, Stored procedure
Msg: Overdue balance -- can not ship.

CUSTOMER_ON_HOLD                SHIP_ORDER, Stored procedure
Msg: This customer is on hold.
...

SQL&gt; SHOW EXCEPTION CUSTOMER_CHECK;

Exception Name                  Used by, Type
=============================== =================================
CUSTOMER_CHECK                  SHIP_ORDER, Stored procedure
Msg: Overdue balance -- can not ship.
</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW FUNCTION[S]</title>

                    <para>displays information about user-defined functions
                    (UDFs) declared in the attached database.</para>
                  </formalpara>

                  <para>A user-defined function (UDF) is used to perform tasks
                  that Firebird cannot. It can be described as an external
                  database function written entirely in another language, such
                  as C++ or Pascal, to perform data manipulation tasks not
                  directly supported by Firebird.</para>

                  <para>UDFs can be called from Firebird and executed on the
                  server. These functions can exist on their own or be
                  collected into libraries. UDFs offer the possibility to
                  create your own functions (such as SUBSTR) and integrate
                  them in the database itself. Each UDF is arranged as a
                  function, belonging to a DLL (Linux: .so). Thus one
                  dynamically loaded library consists of at least one
                  function.</para>

                  <para>UDF definitions are database dependent and not server
                  dependent, i.e. they need to be registered for each database
                  individually. Since in Firebird, the libraries need to be
                  stored in the Firebird UDF folder. Please refer to the
                  <command>DECLARE EXTERNAL FUNCTION</command> statement for
                  details of incorporating UDFs in Firebird.</para>

                  <note>
                    <para>It is important to note that the majority of UDFs,
                    when used in a WHERE condition, prevent indices from being
                    used during execution.</para>
                  </note>

                  <para>Here is the syntax for the code:</para>

                  <para><command>SQL&gt; SHOW { FUNCTIONS | FUNCTION name
                  };</command><!--NEED EXAMPLE FUNCTION HERE.--><table>
                      <title>SHOW FUNCTION[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>FUNCTION[S]</entry>

                            <entry>Lists the names of all UDFs declared in the
                            database</entry>
                          </row>

                          <row>
                            <entry>FUNCTION NAME[S]</entry>

                            <entry>Displays the declaration of the named
                            UDF</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW GRANT</title>

                    <para>displays privileges and ROLE ownership information
                    about a named object in the attached database; or displays
                    user membership within roles.</para>
                  </formalpara>

                  <para><command>GRANT</command> is the SQL statement, used to
                  assign privileges to database users for specified database
                  objects. Here is the syntax for the code:</para>

                  <para><command>SQL&gt; SHOW GRANT { object | role name
                  };</command><table>
                      <title>SHOW GRANT arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>OBJECT</entry>

                            <entry>Name of an existing table, view or procedure
                            in the current database</entry>
                          </row>

                          <row>
                            <entry>ROLE NAME</entry>

                            <entry>Name of an existing role in the current
                            database. Use SHOW ROLES to list all the roles
                            defined for this database.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW GRANT;

...
GRANT EXECUTE ON PROCEDURE ADD_EMP_PROJ TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE ALL_LANGS TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE DELETE_EMPLOYEE TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE DEPT_BUDGET TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE GET_EMP_PROJ TO PUBLIC WITH GRANT OPTION
...

SQL&gt; SHOW GRANT ADD_EMP_PROJ;
GRANT EXECUTE ON PROCEDURE ADD_EMP_PROJ TO PUBLIC WITH GRANT OPTION
</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW INDEX | INDICES</title>

                    <para>displays information about a named index, about
                    indices for a specified table or about indices for all
                    tables in the attached database. Here is the syntax for
                    the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW {INDICES | INDEX { index | table
                  } };</command><table>
                      <title>SHOW INDEX| INDICES arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>INDEX</entry>

                            <entry>Name of an existing index in the current
                            database</entry>
                          </row>

                          <row>
                            <entry>TABLE</entry>

                            <entry>Name of an existing table in the current
                            database</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table><note>
                      <para><command>SHOW IND</command> is an alias for either
                      <command>SHOW INDEX</command> or <command>SHOW
                      INDICES</command>.</para>
                    </note></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW INDEX;

RDB$PRIMARY1 UNIQUE INDEX ON COUNTRY(COUNTRY)
CUSTNAMEX INDEX ON CUSTOMER(CUSTOMER)
CUSTREGION INDEX ON CUSTOMER(COUNTRY, CITY)
RDB$FOREIGN23 INDEX ON CUSTOMER(COUNTRY)
RDB$PRIMARY22 UNIQUE INDEX ON CUSTOMER(CUST_NO)
...

SQL&gt; SHOW INDEX CUSTNAMEX;
CUSTNAMEX INDEX ON CUSTOMER(CUSTOMER)
</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW PROCEDURE[S]</title>

                    <para>lists all procedures in the attached database, with
                    their dependencies; or displays the text of the named
                    procedure with the declarations and types (input/output)
                    of any parameters. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW {PROCEDURES | PROCEDURE name
                  };</command><table>
                      <title>SHOW PROCEDURE[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>NAME</entry>

                            <entry>Name of an existing stored procedure in the
                            current database.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table><note>
                      <para><command>SHOW PROC</command> is an alias for
                      either <command>SHOW PROCEDURE</command> or
                      <command>SHOW PROCEDURES</command>.</para>
                    </note></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW PROCEDURE;

Procedure Name                    Dependency, Type
================================= ======================================
ADD_EMP_PROJ                      EMPLOYEE_PROJECT, Table
                                  UNKNOWN_EMP_ID, Exception
ALL_LANGS                         JOB, Table
                                  SHOW_LANGS, Procedure
...

SQL&gt; SHOW PROCEDURE ADD_EMP_PROJ;

Procedure text:
========================================================================
BEGIN
        BEGIN
        INSERT INTO employee_project (emp_no, proj_id) 
        VALUES (:emp_no, :proj_id);
        WHEN SQLCODE -530 DO
                EXCEPTION unknown_emp_id;
        END
        SUSPEND;
END
========================================================================
Parameters:
EMP_NO                            INPUT SMALLINT
PROJ_ID                           INPUT CHAR(5)
</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW ROLE[S]</title>

                    <para>displays the names of SQL roles for the attached
                    database. A role is a set of privileges on a set of
                    database objects such as tables and views. Roles are
                    assigned using a <command>GRANT</command> statement. To
                    show user membership within roles, use <command>SHOW
                    GRANT</command><command>| ROLE NAME</command>.</para>
                  </formalpara>

                  <note>
                    <para>There can be a chain of roles; for example, in a
                    bank, the role <emphasis>employee</emphasis> may be
                    granted to all tellers, and the role of
                    <emphasis>teller</emphasis> may be granted to all
                    managers, in addition to all privileges automatically
                    granted to managers. Thus all actions executed by a
                    session have all the privileges granted directly to the
                    user, as well as all privileges granted to roles that are
                    granted (directly or indirectly via other roles) to that
                    user.</para>
                  </note>

                  <para>Here is the syntax for the code:</para>

                  <para><command>SQL&gt; SHOW ROLES;</command></para>

                  <para>No arguments.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW SQL DIALECT</title>

                    <para>displays the SQL dialects of the client and of the
                    attached database, if there is one. Here is the syntax for
                    the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW SQL DIALECT;</command></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW SQL DIALECT;
        Client SQL dialect is set to: 3 and database SQL dialect is: 3</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW SYSTEM</title>

                    <para>displays the names of system tables and system views
                    for the attached database. Here is the syntax:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW SYS [ TABLES ];</command></para>

                  <para>No arguments.</para>

                  <para>TABLES is an optional keyword that does not affect the
                  behavior of the command in versions up to Firebird 1.5.3(?).
                  This changes in version 2.0 onwards.</para>

                  <para>In Firebird Version 2.0, the <command>SHOW
                  SYSTEM</command> command shows predefined UDFs. The
                  <command>SHOW &lt; object_type&gt;</command> command is
                  designed to show user objects of that type. In versions
                  earlier than 2.0, the <command>SHOW SYSTEM</command> command
                  showed only system tables. Starting with 2.0, it also lists
                  predefined system UDFs. In future releases it could also
                  display views.</para>

                  <para>Shorthand:<command> SHOW SYS</command> is
                  equivalent.</para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW SYSTEM;

Tables:
       RDB$BACKUP_HISTORY                     RDB$CHARACTER_SETS
       RDB$CHECK_CONSTRAINTS                  RDB$COLLATIONS
       RDB$DATABASE                           RDB$DEPENDENCIES
       RDB$EXCEPTIONS                         RDB$FIELDS
       RDB$FIELD_DIMENSIONS                   RDB$FILES
...

Functions:
       RDB$GET_CONTEXT                        RDB$SET_CONTEXT</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW TABLES</title>

                    <para>lists all tables or views in the database, and or
                    displays information on specific named table[s] or
                    view[s].</para>
                  </formalpara>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW TABLES;
       COUNTRY                                CUSTOMER
       DEPARTMENT                             EMPLOYEE
       EMPLOYEE_PROJECT                       JOB
       PROJECT                                PROJ_DEPT_BUDGET
       SALARY_HISTORY                         SALES</screen></para>

                  <note>
                    <para>See also SHOW VIEW[s].</para>
                  </note>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW TRIGGERS</title>

                    <para>displays all the triggers defined in the database
                    along with the associated table name. A database trigger
                    is procedural code, that is automatically executed in
                    response to specific events, on a specified table, in a
                    database. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt;SHOW TRIGGERS;</command></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW TRIGGERS;
Table name                       Trigger name
===========                      ============
CUSTOMER                         SET_CUST_NO
EMPLOYEE                         SAVE_SALARY_CHANGE
EMPLOYEE                         SET_EMP_NO
SALES                            POST_NEW_ORDER</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW VERSION</title>

                    <para>displays information about the software versions of
                    <application>isql</application> and the Firebird server
                    program, and the on-disk structure of the attached
                    database. However, in Firebird 2.0 onwards the ODS version
                    can also be returned using the <command>SHOW
                    DATABASE</command> statement. Here is the syntax for the
                    code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SHOW VERSION;</command></para>

                  <para>No arguments.</para>

                  <para>Shorthand: <command>SHOW VER</command> is
                  equivalent.</para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW VERSION;
ISQL Version: WI-V2.0.0.12745 Firebird 2.0 Release Candidate 5
Server version:
Firebird/x86/Windows NT (access method), version "WI-V2.0.0.12745 -
Firebird 2.0 Release Candidate 5"
Firebird/x86/Windows NT (remote server), version "WI-V2.0.0.12745 -
Firebird 2.0 Release Candidate 5/XNet (PLAYTHING)/P10"
Firebird/x86/Windows NT (remote interface), version "WI-V2.0.0.12745 -
Firebird 2.0 Release Candidate 5/XNet (PLAYTHING)/P10"
on disk structure version 11.0</screen><note>
                      <para>The output listed above has been split over more
                      than one line to allow it to fit on a PDF pege. Hyphens
                      show the location where certain lines have been
                      split.</para>
                    </note></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW VIEW[s]</title>

                    <para>lists all views, or displays information about the
                    named view.</para>
                  </formalpara>

                  <para>Here is the syntax for the code:</para>

                  <para><command>SQL&gt; SHOW { VIEWS | VIEW name
                  };</command><table>
                      <title>SHOW VIEW[S]</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>NAME</entry>

                            <entry>Name of an existing view in the current
                            database. The output contains column names and the
                            SELECT statement that the view is based on.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW VIEW;
       PHONE_LIST</screen></para>

                  <note>
                    <para>See also SHOW TABLES.</para>
                  </note>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <formalpara>
                <title>SET COMMANDS</title>

                <para>enable users to view and change the
                <application>isql</application> environment. To view the
                current settings for the various set commands in the database,
                issue the following command:</para>
              </formalpara>

              <para><userinput>SET;</userinput></para>

              <para><screen>SQL&gt; SET;
Print statistics:        OFF
Echo commands:           OFF
List format:             OFF
Row Count:               OFF
Autocommit DDL:          ON
Access Plan:             OFF
Access Plan only:        OFF
Display BLOB type:       1
Column headings:         ON
Terminator:              ;
Time:                    OFF
Warnings:                ON
Bail on error:           OFF</screen></para>

              <itemizedlist>
                <listitem>
                  <formalpara>
                    <title>SET AUTODDL</title>

                    <para>specifies whether DDL statements are committed
                    automatically after being executed, or committed only
                    after an explicit <command>COMMIT</command>. Here is the
                    syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET AUTODDL [ON | OFF]; /* default is
                  ON */</command><table>
                      <title>SET AUTODDL arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles automatic commit on.</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles automatic commit off.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shorthand : <command>SET AUTO</command> (with no
                  argument) simply toggles AUTODDL on and off.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET BLOBDISPLAY</title>

                    <para>specifies both sub_type of BLOB to display and
                    whether BLOB data should be displayed. Here is the syntax
                    for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET BLOBDISPLAY [ n | ALL | OFF
                  ];</command><table>
                      <title>SET BLOBDISPLAY arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>n</entry>

                            <entry>BLOB SUB_TYPE to display. Default: n= 1
                            (text)</entry>
                          </row>

                          <row>
                            <entry>ON</entry>

                            <entry>Display BLOB data of any sub_type</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles display of BLOB data off. The output
                            shows only the Blob ID (two hex numbers separated by
                            a colon (:). The first number is the ID of the table
                            containing the BLOB column. The second is a
                            sequenced instance number.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shorthand: <command>SET BLOB</command> is the
                  same.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET COUNT</title>

                    <para>toggles off/on whether to display the number of rows
                    retrieved by queries. Here is the syntax for the
                    code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET COUNT [ON | OFF];</command><table>
                      <title>SET COUNT arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on display of "rows returned"
                            message</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles off display of "rows returned"
                            message (default)</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET ECHO</title>

                    <para>toggles off/on whether commands are displayed before
                    being executed. Default is ON but you might want to toggle
                    it to OFF if sending your output to a script file. Here is
                    the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET ECHO [ON | OFF]; /* default is ON
                  */</command><table>
                      <title>SET ECHO arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on command echoing (default)</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles off command echoing</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET NAME[s]</title>

                    <para>specifies the character set that is to be active in
                    database transactions. Here is the syntax for the
                    code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET NAMES charset;</command><table>
                      <title>SET NAMES arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>CHARSET</entry>

                            <entry>Name of the active character set. Default:
                            NONE</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET PLAN</title>

                    <para>specifies whether to display the optimizer's query
                    plan. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET PLAN [ ON | OFF
                  ];</command><table>
                      <title>SET PLAN arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Turns on display of the query plan.
                            Default.</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Turns off display of the query plan.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shortcut: omit ON | OFF and use just SET PLAN as a
                  toggle.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET PLANONLY</title>

                    <para>specifies to use the optimizer's query plan and
                    display just the plan, without executing the actual query.
                    (Available in Firebird 1 and higher). Here is the syntax
                    for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET PLANONLY ON |
                  OFF;</command></para>

                  <para>The command works as a toggle switch. The argument is
                  optional.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET SQL DIALECT</title>

                    <para>specifies the Firebird SQL dialect to which the
                    client session is to be changed. If the session is
                    currently attached to a database of a different dialect to
                    the one specified in the command, a warning is displayed.
                    Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET SQL DIALECT n;</command><table>
                      <title>SET SQL DIALECT arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>n</entry>

                            <entry>n = 1 for Dialect 1, 2 for Dialect 2, 3 for
                            Dialect 3</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET STATS</title>

                    <para>specifies whether to display performance statistics
                    following the output of a query. Here is the syntax for
                    the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET STATS [ ON | OFF
                  ];</command><table>
                      <title>SET STATS arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Turns on display of performance statistics.
                            Displays: • Current memory available (bytes)• Change
                            in available memory (bytes) • Maximum memory
                            available (bytes) • Elapsed time for the operation
                            (seconds) • CPU time for the operation (seconds) •
                            Number of cache buffers used • Number of reads
                            requested • Number of writes requested • Number of
                            fetches done</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Turns off display of performance statistics.
                            Default.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shortcut: omit ON | OFF and use just <command>SET
                  STATS</command> as a toggle.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET TERM</title>

                    <para>specifies the character which will be used as the
                    command or statement terminator, from the next statement
                    forward. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET TERM string;</command><table>
                      <title>SET TERM arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>String</entry>

                            <entry>Character or characters which will be used as
                            statement terminator. Default: ;</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET TIME</title>

                    <para>specifies whether to display the time portion of a
                    DATE value (Dialect 1 only). Here is the syntax for the
                    code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET TIME [ ON | OFF
                  ];</command><table>
                      <title>SET TIME arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on time portion display in Dialect 1
                            DATE value</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles on time portion display in Dialect 1
                            DATE value. Default.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET TRANSACTION</title>

                    <!--TODO: Explain and example.-->

                    <para><command>To be completed.</command></para>
                  </formalpara>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET WARNINGS</title>

                    <para>specifies whether warnings are to be output. A few
                    examples for which <application>isql</application> issues
                    warnings are: <itemizedlist>
                        <listitem>
                          <para>SQL statement that cause no effect.</para>
                        </listitem>

                        <listitem>
                          <para>Pending database shutdown.</para>
                        </listitem>

                        <listitem>
                          <para>API calls that may be replaced in future
                          versions of Firebird.</para>
                        </listitem>
                      </itemizedlist>Here is the syntax for the code:</para>
                  </formalpara>

                  <para><command>SQL&gt; SET WARNINGS [ ON | OFF
                  ];</command><table>
                      <title>SET WARNINGS arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTIONS</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on display of warnings if it was
                            toggled off, or if the session was started with the
                            - nowarnings option.</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles off display of warnings if it is
                            currently toggled on.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shorthand: <command>SET WNG</command> can be used as a
                  substitute, as a simple on/off toggle.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET HEADING[S]</title>

                    <para>This allows users to disable the printing of column
                    headers, when doing a <command>SELECT</command> inside
                    <application>isql</application>, and having the output
                    sent to a file, for processing at a later stage. In
                    versions before 2.0, <application>isql</application> used
                    to print all the column headers by default, and sometimes
                    the sheer number of columns made the display in
                    <application>isql</application> impractical. This has now
                    been fixed with the <command>SET HEADING[s] on |
                    off</command> toggle.</para>
                  </formalpara>

                  <note>
                    <para>This switch cannot be deactivated with a command
                    line parameter. Using <command>SET</command> will display
                    the state of <command>SET HEAD</command>, along with other
                    switches that can be toggled on/off in the
                    <application>isql</application> shell.</para>
                  </note>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET BAIL</title>

                    <para>will toggle the state between activated and
                    deactivated. Using <command>SET</command> will display the
                    state of the switch among many others. Even if
                    <command>BAIL</command> is activated, it doesn't mean it
                    will change <application>isql</application>. For example
                    <command>isql -b -i my_fb.sql -o results.log -m
                    -m2</command>behavior. An additional requirement should be
                    met: the session should be non-interactive. A
                    non-interactive session happens when the user calls
                    <application>isql</application> in batch mode, giving it a
                    script as input.</para>
                  </formalpara>

                  <para><note>
                      <para>If the user loads <application>isql
                      </application>interactively, and later executes a script
                      with the input command; this is considered an
                      interactive session, even though
                      <application>isql</application> knows it is executing a
                      script.</para>
                    </note></para>

                  <para>Example:</para>

                  <para><screen>Use CONNECT or CREATE DATABASE to specify a database 
SQL&gt; set bail; 
SQL&gt; input my_fb.sql; SQL&gt; ^Z</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET SQLDA_DISPLAY ON | OFF</title>

                    <para>The <command>SQLDA_DISPLAY</command> command shows
                    the input SQLDA parameters of INSERTS, UPDATES AND
                    DELETES. It reveals information on the raw SQLVARS. A
                    SQLVAR represents a field in XSQLDA, the main structure
                    used by the Firebird API to talk to clients, transferring
                    data in and out of the server. This feature has been
                    introduced in Firebird 2.0. It was previously available
                    only in DEBUG builds.</para>
                  </formalpara>

                  <note>
                    <para>As of Firebird 2.0 this feature is not yet displayed
                    by <application>isql</application> when you type SET; to
                    view the settings of options.</para>
                  </note>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <section>
      <title><application>Isql</application> Commands</title>

      <para><application>Isql</application> commands affect the running of
      <application>isql</application> itself and do not affect the database or
      data in any way. These commands are used to display help, run scripts,
      create listings and so on. You can easily see a list of the available
      commands by typing the <command>help</command> command which will
      produce the following output:</para>

      <screen>SQL&gt; help;

Frontend commands:
BLOBDUMP &lt;blobid&gt; &lt;file&gt;   -- dump BLOB to a file
BLOBVIEW &lt;blobid&gt;          -- view BLOB in text editor
EDIT     [&lt;filename&gt;]      -- edit SQL script file and execute
EDIT                       -- edit current command buffer and execute
HELP                       -- display this menu
INput    &lt;filename&gt;        -- take input from the named SQL file
OUTput   [&lt;filename&gt;]      -- write output to named file
OUTput                     -- return output to stdout
SET      &lt;option&gt;          -- (Use HELP SET for complete list)
SHELL    &lt;command&gt;         -- execute Operating System command in sub-shell
SHOW     &lt;object&gt; [&lt;name&gt;] -- display system information
    &lt;object&gt; = CHECK, COLLATION, DATABASE, DOMAIN, EXCEPTION, FILTER, FUNCTION,
               GENERATOR, GRANT, INDEX, PROCEDURE, ROLE, SQL DIALECT, SYSTEM,
               TABLE, TRIGGER, VERSION, USERS, VIEW
EXIT                       -- exit and commit changes
QUIT                       -- exit and roll back changes

All commands may be abbreviated to letters in CAPitals
</screen>

      <para>Each of these commands will now be discussed. Note the last line
      of output from the <command>help</command> command. It explains that
      each of the commands may be abbreviated to just those letters displayed
      in capital letters. In the following discussion, the optional characters
      will be wrapped in square brackets. For example, the
      <command>input</command> command will be shown as
      <command>in[put]</command> to indicate that the characters 'put' are
      optional.</para>

      <section>
        <title>Blobdump</title>

        <para></para>
      </section>

      <section>
        <title>Blobview</title>

        <para></para>
      </section>

      <section>
        <title>Edit</title>

        <para></para>
      </section>

      <section>
        <title>Help</title>

        <para>The help command has been discussed above.</para>
      </section>

      <section>
        <title>Input</title>

        <para></para>
      </section>

      <section>
        <title>Output</title>

        <para></para>
      </section>

      <section>
        <title>Shell</title>

        <para></para>
      </section>

      <section>
        <title>Exit</title>

        <para></para>
      </section>

      <section>
        <title>Quit</title>

        <para></para>
      </section>
    </section>

    <section>
      <title><application>Isql</application> Show commands</title>

      <para>As explained in the <command>help</command> command, there are a
      number of individual show commands within
      <application>isql</application>. These are as follows:</para>

      <!--SHOW     <object> [<name>]  display system information
    <object> = CHECK, COLLATION, DATABASE, DOMAIN, EXCEPTION, FILTER, FUNCTION,
               GENERATOR, GRANT, INDEX, PROCEDURE, ROLE, SQL DIALECT, SYSTEM,
               TABLE, TRIGGER, VERSION, USERS, VIEW-->

      <section>
        <title>Show Check</title>

        <para></para>
      </section>

      <section>
        <title>Show Collation</title>

        <para></para>
      </section>

      <section>
        <title>Show Database</title>

        <para></para>
      </section>

      <section>
        <title>Show Domain</title>

        <para></para>
      </section>

      <section>
        <title>Show Exception</title>

        <para></para>
      </section>

      <section>
        <title>Show Filter</title>

        <para></para>
      </section>

      <section>
        <title>Show Function</title>

        <para></para>
      </section>

      <section>
        <title>Show Generator/Sequence</title>

        <para></para>
      </section>

      <section>
        <title>Show Grant</title>

        <para></para>
      </section>

      <section>
        <title>Show Index</title>

        <para></para>
      </section>

      <section>
        <title>Show Procedure</title>

        <para></para>
      </section>

      <section>
        <title>Show Role</title>

        <para></para>
      </section>

      <section>
        <title>Show SQL Dialect</title>

        <para></para>
      </section>

      <section>
        <title>Show System</title>

        <para></para>
      </section>

      <section>
        <title>Show Table</title>

        <para></para>
      </section>

      <section>
        <title>Show Trigger</title>

        <para></para>
      </section>

      <section>
        <title>Show Version</title>

        <para></para>
      </section>

      <section>
        <title>Show Users</title>

        <para></para>
      </section>

      <section>
        <title>Show View</title>

        <para></para>
      </section>
    </section>

    <section>
      <title><application>Isql</application> Set Commands</title>

      <para>As explained in the <command>help</command> command, you may enter
      the <command>help set</command> command to drill down into the various
      options available for the <command>set</command> command. These are all
      discussed below. Note that the output from the <command>help
      set</command> command does not include the <command>set
      transaction</command> command. The <command>help set</command> command
      produces the following output:</para>

      <screen>SQL&gt; help set;

Set commands:
    SET                    -- display current SET options
    SET AUTOddl            -- toggle autocommit of DDL statements
    SET BAIL               -- toggle bailing out on errors in non-interactive mode
    SET BLOB [ALL|&lt;n&gt;]     -- display BLOBS of subtype &lt;n&gt; or ALL
    SET BLOB               -- turn off BLOB display
    SET COUNT              -- toggle count of selected rows on/off
    SET ROWCOUNT [&lt;n&gt;]     -- limit select stmt to &lt;n&gt; rows, zero is no limit
    SET ECHO               -- toggle command echo on/off
    SET HEADING            -- toggle display of query column titles
    SET LIST               -- toggle column or table display format
    SET NAMES &lt;csname&gt;     -- set name of runtime character set
    SET PLAN               -- toggle display of query access plan
    SET PLANONLY           -- toggle display of query plan without executing
    SET SQL DIALECT &lt;n&gt;    -- set sql dialect to &lt;n&gt;
    SET STATs              -- toggle display of performance statistics
    SET TIME               -- toggle display of timestamp with DATE values
    SET TERM &lt;string&gt;      -- change statement terminator string
    SET WIDTH &lt;col&gt; [&lt;n&gt;]  -- set/unset print width to &lt;n&gt; for column &lt;col&gt;

All commands may be abbreviated to letters in CAPitals
</screen>

      <para>The last line of the above output indicates that these commands
      can be abbreviated to the letters in capitals. Unfortunately, other than
      the <command>set autoddl</command> command, none of the others appear to
      have a short form.</para>

      <section>
        <title>Set</title>

        <para>The set command, with no parameters, displays the current
        settings, as the following example from Firebird 2.5 shows:</para>

        <screen>SQL&gt; set;

Print statistics:        OFF
Echo commands:           OFF
List format:             OFF
List Row Count:          OFF
Select rowcount limit:   0
Autocommit DDL:          ON
Access Plan:             OFF
Access Plan only:        OFF
Display BLOB type:       1
Column headings:         ON
Terminator:              ;
Time:                    OFF
Warnings:                ON
Bail on error:           OFF
</screen>
      </section>

      <section>
        <title>Set Autoddl</title>

        <para><command>set auto[ddl] [on | off];</command></para>

        <para>This command sets whether all DDL statements executed will be
        automatically committed or not. The command without any parameters
        acts as a toggle and turns autoddl off if it is currently on and vice
        versa. You may supply a specific parameter to make your intentions
        clear. The parameter must be one of <command>on</command> or
        <command>off</command>. The <command>set</command> command, with no
        parameters, will display the current setting. The default in
        <application>isql</application> is equivalent to <command>set autoddl
        on</command>.</para>
      </section>

      <section>
        <title>Set Bail</title>

        <para></para>
      </section>

      <section>
        <title>Set Blob</title>

        <para></para>
      </section>

      <section>
        <title>Set Count</title>

        <para></para>
      </section>

      <section>
        <title>Set Rowcount</title>

        <para></para>
      </section>

      <section>
        <title>Set Echo</title>

        <para></para>
      </section>

      <section>
        <title>Set Heading</title>

        <para></para>
      </section>

      <section>
        <title>Set List</title>

        <para></para>
      </section>

      <section>
        <title>Set List Rowcount CHECK THIS ONE!!!</title>

        <para></para>
      </section>

      <section>
        <title>Set Names</title>

        <para></para>
      </section>

      <section>
        <title>Set Plan</title>

        <para></para>
      </section>

      <section>
        <title>Set Planonly</title>

        <para></para>
      </section>

      <section>
        <title>Set SQLDA_Display</title>

        <para>This is a hidden command which is not mentioned in the output
        from the <command>help set</command> command.</para>
      </section>

      <section>
        <title>Set SQL Dialect</title>

        <para></para>
      </section>

      <section>
        <title>Set Stats</title>

        <para></para>
      </section>

      <section>
        <title>Set Time</title>

        <para></para>
      </section>

      <section>
        <title>Set Term</title>

        <para></para>
      </section>

      <section>
        <title>Set Transaction</title>

        <para>This is another hidden command which is not mentioned in the
        output from the <command>help set</command> command.</para>
      </section>

      <section>
        <title>Set Width</title>

        <para></para>
      </section>
    </section>
  </section>

  <section id="isql-switches">
    <title>Command Line Switches</title>

    <para>Command line switches are arguments that begin with a minus/hyphen
    (-) character. The following table tabulates all the switches that can be
    employed when executing <application>isql</application>.</para>

    <table>
      <title>ISQL COMMAND-LINE SWITCHES</title>

      <!--TODO: finishe checking the versions and update the table.-->

      <tgroup cols="3">
        <colspec colname="switch" colwidth="4*" />

        <colspec colname="version" colwidth="2*" />

        <colspec colname="description" colwidth="10*" />

        <thead>
          <row>
            <entry>SWITCH</entry>

            <entry>VERSION</entry>

            <entry>DESCRIPTION</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>-a(ll)</entry>

            <entry>1.0</entry>

            <entry>extract meta data including legacy non-SQL tables</entry>
          </row>

          <row>
            <entry>-b(ail)</entry>

            <entry>1.5.3</entry>

            <entry>instructs <application>isql</application> to bail out on
            error when used in non-interactive mode, and returns an error code
            to the operating system.</entry>
          </row>

          <row>
            <entry>-c(ache) &lt;num&gt;</entry>

            <entry> </entry>

            <entry>number of cache buffers</entry>
          </row>

          <row>
            <entry>ch(arset) &lt;charset&gt;</entry>

            <entry> </entry>

            <entry>connection charset (set names)</entry>
          </row>

          <row>
            <entry>-d(atabase) &lt;database&gt;</entry>

            <entry> </entry>

            <entry>database name to put in script creation</entry>
          </row>

          <row>
            <entry>-e(cho)</entry>

            <entry> </entry>

            <entry>echoes commands to find out where a script has caused
            errors (set echo on)</entry>
          </row>

          <row>
            <entry>-ex(tract)</entry>

            <entry> </entry>

            <entry>extract meta data</entry>
          </row>

          <row>
            <entry>-f(etch_password)</entry>

            <entry> </entry>

            <entry>fetch password from file</entry>
          </row>

          <row>
            <entry>-i(nput) &lt;file&gt;</entry>

            <entry> </entry>

            <entry>input file (set input)</entry>
          </row>

          <row>
            <entry>-m(erge)</entry>

            <entry> </entry>

            <entry>to merge standard error</entry>
          </row>

          <row>
            <entry>-m2</entry>

            <entry>2.0</entry>

            <entry>merge diagnostic</entry>
          </row>

          <row>
            <entry>-n(noautocommit)</entry>

            <entry> </entry>

            <entry>no autocommit DDL (set autoddl off)</entry>
          </row>

          <row>
            <entry>-nod(btriggers)</entry>

            <entry> </entry>

            <entry>do not run database triggers</entry>
          </row>

          <row>
            <entry>-now(arning)</entry>

            <entry> </entry>

            <entry>do not show warnings</entry>
          </row>

          <row>
            <entry>-o(utput) <replaceable>file</replaceable></entry>

            <entry> </entry>

            <entry>to send the output to a file(set output)</entry>
          </row>

          <row>
            <entry>-p(assword) &lt;password&gt;</entry>

            <entry> </entry>

            <entry>connection password</entry>
          </row>

          <row>
            <entry>-pag(elength) &lt;size&gt;</entry>

            <entry> </entry>

            <entry>page length</entry>
          </row>

          <row>
            <entry>-q(uiet)</entry>

            <entry> </entry>

            <entry>do not show the message "Use CONNECT..."</entry>
          </row>

          <row>
            <entry>-r(ole) &lt;role&gt;</entry>

            <entry> </entry>

            <entry>role name</entry>
          </row>

          <row>
            <entry>-r2 &lt;role&gt;</entry>

            <entry> </entry>

            <entry>role (uses quoted identifier)</entry>
          </row>

          <row>
            <entry>-s(qldialect) &lt;dialect&gt;</entry>

            <entry>1.0</entry>

            <entry>SQL dialect (set sql dialect)</entry>
          </row>

          <row>
            <entry>-t(erminator) &lt;term&gt;</entry>

            <entry> </entry>

            <entry>command terminator (set term)</entry>
          </row>

          <row>
            <entry>-u(ser) &lt;user&gt;</entry>

            <entry> </entry>

            <entry>user name</entry>
          </row>

          <row>
            <entry>-x</entry>

            <entry> </entry>

            <entry>extract meta data</entry>
          </row>

          <row>
            <entry>-z</entry>

            <entry> </entry>

            <entry>shows program and server version</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Some of the switches are explained in greater depth below:</para>

    <!--TODO: Need more and/or better examples here. One each, if possible.-->

    <itemizedlist>
      <listitem>
        <para><emphasis>Using -b(ail)</emphasis>:</para>

        <para>The command line switch -b(ail) instructs the
        <application>isql</application> utility to bail on error, but only
        when used in a non-interactive mode. The switch returns an error code
        to the Operating System.</para>

        <para>This switch was added to prevent <application>isql</application>
        from executing scripts after an error has been detected. No further
        statements will be executed and <application>isql</application> will
        return an error code to the OS.</para>

        <para>Users still need to use the -e(cho) switch to echo commands to
        an output file, to isolate the exact statement that caused the
        error.</para>

        <para>When the server provides line and column information, users can
        see the exact line of the DML in the script that caused the problem.
        When the server only indicates failure, users can view the first line
        of the statement that caused the failure, in relation to the entire
        script.</para>

        <para>This feature is also supported in nested scripts. For example,
        Script A includes Script B and Script B causes a failure, the line
        number is related to Script B. When Script B is read completely,
        <application>isql</application> continues counting the lines related
        to Script A, since each file gets a separate line counter. Script A
        includes Script B when Script A uses the INPUT command to load Script
        B.</para>

        <para>Lines are counted according to what the underlying IO layer
        considers separate lines. For ports using EDITLINE, a line is what
        readline() provides in a single call. The line length limit of 32767
        bytes remains uncharged.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using -ex(tract):</emphasis></para>

        <para>The command line switch -ex(tract) can be used to extract meta
        data from the database. It can be used in conjunction with the
        -o(utput) switch to extract the information to a specified output
        file.</para>

        <para>The resultant information can be used to view all the changes
        made to the database since its creation. Before making any more
        changes, create a new database with identical schema definitions or
        new ones, or create a new database source file.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using -m2 and -m(erge):</emphasis></para>

        <para>The command line switch m2, has been added in Firebird 2.0 and
        can be used to send the statistics and plans to the same output file
        that receives the input from the -o(utput) switch.</para>

        <para>In earlier versions of Firebird (before version 2.0), when a
        user specified that the output should be sent to a file, two options
        existed : the command line switch -o(utput) with a file name to store
        the output, or the command OUTput with a file name to store the
        output. Both these options could be employed either in a batch session
        or in the interactive <application>isql</application> shell. In both
        cases, simply passing the command OUTput would return the output to
        the console. While the console displayed error messages, these were
        not sent to the output file.</para>

        <para>The -m(erge) command line switch, can be used to incorporate the
        error messages into the output files.</para>

        <para>The -m2 command line switch ensures that the stats and plan
        information derived from the SET STATS, SET PLAN and SET PLANONLY
        commands are also sent to the output file and not just returned to the
        console.</para>

        <note>
          <para>Neither -m(erge) nor -m2 has an interactive counterpart
          through a SET command. They are for use only as command line
          <application>isql</application> options.</para>
        </note>
      </listitem>

      <listitem>
        <para><emphasis>Using -r2 and -r(ole):</emphasis></para>

        <para>This switch can be used to specify a case-sensitive role name.
        The default switch for this is -r(ole). Roles provided in the command
        line are uppercased With -r2, and passed to the engine exactly as
        typed in the command line.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using -o(utput)</emphasis>:</para>

        <para>The OUTPUT switch allows users to store records of commands to a
        script file. The TMP setting on a client can be used to control where
        these script files will be stored, if an absolute file path is not
        specified.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-endsession">
    <title>Ending An <application>Isql</application> Session</title>

    <para>There are two ways to exit <application>isql</application>.</para>

    <itemizedlist>
      <listitem>
        <para>If you wish to roll back all uncommitted work and exit
        <application>isql</application> type this command at the
        prompt:</para>

        <para><command>SQL&gt; QUIT;</command></para>
      </listitem>

      <listitem>
        <para>If you wish to commit all your work before exiting
        <application>isql</application>, then type in the following
        command:</para>

        <para><command>SQL&gt; EXIT;</command></para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Isql's Help</title>

    <para><application>Isql</application> comes with the
    <command>HELP</command> command. This gives brief details of the commands
    available, and allows you to drill down for further information. To
    activate the help system, simply type <command>HELP</command> at the
    prompt, as shown below (from Firebird 2.5):</para>

    <screen>SQL&gt; help;

Frontend commands:
BLOBDUMP &lt;blobid&gt; &lt;file&gt;   -- dump BLOB to a file
BLOBVIEW &lt;blobid&gt;          -- view BLOB in text editor
EDIT     [&lt;filename&gt;]      -- edit SQL script file and execute
EDIT                       -- edit current command buffer and execute
HELP                       -- display this menu
INput    &lt;filename&gt;        -- take input from the named SQL file
OUTput   [&lt;filename&gt;]      -- write output to named file
OUTput                     -- return output to stdout
SET      &lt;option&gt;          -- (Use HELP SET for complete list)
SHELL    &lt;command&gt;         -- execute Operating System command in sub-shell
SHOW     &lt;object&gt; [&lt;name&gt;] -- display system information
    &lt;object&gt; = CHECK, COLLATION, DATABASE, DOMAIN, EXCEPTION, FILTER, FUNCTION,
               GENERATOR, GRANT, INDEX, PROCEDURE, ROLE, SQL DIALECT, SYSTEM,
               TABLE, TRIGGER, VERSION, USERS, VIEW
EXIT                       -- exit and commit changes
QUIT                       -- exit and roll back changes

All commands may be abbreviated to letters in CAPitals
</screen>

    <para>Most of these commands have no further levels of detail, while the
    <command>SET</command> command does. To drill down into those extra
    levels, proceed as follows:</para>

    <screen>SQL&gt; help set;

Set commands:
    SET                    -- display current SET options
    SET AUTOddl            -- toggle autocommit of DDL statements
    SET BAIL               -- toggle bailing out on errors in non-interactive mode
    SET BLOB [ALL|&lt;n&gt;]     -- display BLOBS of subtype &lt;n&gt; or ALL
    SET BLOB               -- turn off BLOB display
    SET COUNT              -- toggle count of selected rows on/off
    SET ROWCOUNT [&lt;n&gt;]     -- limit select stmt to &lt;n&gt; rows, zero is no limit
    SET ECHO               -- toggle command echo on/off
    SET HEADING            -- toggle display of query column titles
    SET LIST               -- toggle column or table display format
    SET NAMES &lt;csname&gt;     -- set name of runtime character set
    SET PLAN               -- toggle display of query access plan
    SET PLANONLY           -- toggle display of query plan without executing
    SET SQL DIALECT &lt;n&gt;    -- set sql dialect to &lt;n&gt;
    SET STATs              -- toggle display of performance statistics
    SET TIME               -- toggle display of timestamp with DATE values
    SET TERM &lt;string&gt;      -- change statement terminator string
    SET WIDTH &lt;col&gt; [&lt;n&gt;]  -- set/unset print width to &lt;n&gt; for column &lt;col&gt;

All commands may be abbreviated to letters in CAPitals
</screen>

    <para>If you attempt to drill down into any other command, the effect is
    exactly the same as executing the <command>HELP</command> command on its
    own.</para>

    <note>
      <para>In the output from <command>HELP SET</command>, there doesn't
      appear to be any help on the <command>SET TRANSACTION</command>
      command.</para>
    </note>
  </section>

  <section>
    <title>Glossary</title>

    <!--TODO: Complete this glossary.-->

    <glossary>
      <glossdiv>
        <title>Glossary</title>

        <glossentry>
          <glossterm>DML</glossterm>

          <glossdef>
            <para>Data Manipulation Language. Commands that are used to
            create, change or delete <emphasis>data</emphasis>. </para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>DDL</glossterm>

          <glossdef>
            <para>Data Definition Language. Commands that create, alter or
            drop database <emphasis>objects</emphasis> such as views, tables
            etc.</para>
          </glossdef>
        </glossentry>

        <glossentry>
          <glossterm>SQL</glossterm>

          <glossdef>
            <para>Structured Query Language. The language used to query the
            data in the database as well as the objects in the
            database.</para>
          </glossdef>
        </glossentry>
      </glossdiv>
    </glossary>

    <para></para>
  </section>

  <appendix id="isql-dochist">
    <title>Document History</title>

    <para>The exact file history is recorded in the <filename
    class="directory">manual</filename> module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink>.
    The full URL of the CVS log for this file can be found at <ulink
    url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_isql.xml?view=log">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_isql.xml?view=log</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>December 2006</date>

          <authorinitials>KV</authorinitials>

          <revdescription>
            <para>First version by Kamala Vadlamani.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>5 July 2008</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Changed title to <citetitle><application>Isql</application>
            - Firebird Interactive SQL Utility</citetitle> to bring it in line
            with the other manuals. Added <sgmltag
            class="element">titleabbrev</sgmltag> and edition info. Moved
            <citetitle>Audience</citetitle> and <citetitle>Version</citetitle>
            sections into <citetitle>Introduction</citetitle>. Removed
            <citetitle>Related Documentation</citetitle> section. Fixed typos,
            interpunction (still more to do here). Replaced most <sgmltag
            class="element">emphasis</sgmltag>es and all <sgmltag
            class="element">citetitle</sgmltag>s with more appropriate tags.
            Gave IDs to manual and all (sub)sections. Added manual History and
            License Notice.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.3</revnumber>

          <date>20 October 2009</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Converted from a chapter in the <citetitle>Command Line
            Utilities</citetitle> manual to stand alone manual in its own
            right.</para>

            <para>Changed title to <citetitle>Firebird Interactive SQL
            Utility</citetitle> to bring it in line with the other utility
            manuals.</para>

            <para>Many other updates to bring this manual into line with the
            others and to incorporate Firebird 2 changes etc.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.4</revnumber>

          <date>15 February 2012</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>General tidy up. Changes to formatting. Corrected some
            Docbook "misuse". Spelling &amp; punctuation corrections. Lists
            compacted. Corrected &lt;screen&gt; overflow in pdf rendering.
            Etc.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="isql-license">
    <title>License Notice</title>

    <para>The contents of this Documentation are subject to the Public
    Documentation License Version 1.0 (the <quote>License</quote>); you may
    only use this Documentation if you comply with the terms of this License.
    Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>The Original Documentation is titled <citetitle>Firebird Interactive
    SQL Utility</citetitle>.</para>

    <para>The Initial Writer of the Original Documentation is: Kamala
    Vadlamani.</para>

    <para>Copyright (C) 2006. All Rights Reserved. Initial Writer contact:
    kamala dot vadlamani at gmail dot com.</para>

    <para>Contributor: Paul Vinkenoog - see <link
    linkend="isql-dochist">Document history</link>.</para>

    <para>Portions created by Paul Vinkenoog are Copyright (C) 2008. All
    Rights Reserved. Contributor contact: paul at vinkenoog dot nl.</para>

    <para>Contributor: Norman Dunbar - see <link
    linkend="isql-dochist">Document history</link>.</para>

    <para>Portions created by Norman Dunbar are Copyright (C) 2009 and 2011.
    All Rights Reserved. Contributor contact: NormanDunbar at users dot
    sourceforge dot net.</para>
  </appendix>
</article>
