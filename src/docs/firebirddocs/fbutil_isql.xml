<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../tools/docbook-dtd/docbookx.dtd">
<article id="isql">
  <articleinfo>
    <title>Firebird Interactive SQL Utility</title>

    <titleabbrev>Isql - Interactive SQL</titleabbrev>

    <author>
      <surname>Kamala Vadlamani</surname>
    </author>

    <othercredit>
      <firstname>Paul</firstname>

      <surname>Vinkenoog</surname>

      <contrib>Extensive review and many changes.</contrib>
    </othercredit>

    <othercredit>
      <firstname>Norman</firstname>

      <surname>Dunbar</surname>

      <contrib>Firebird 2.x updates, conversion to stand alone
      manual.</contrib>
    </othercredit>

    <edition>10 April 2013 – Document version 0.5</edition>
  </articleinfo>

  <section id="isql-introduction">
    <title>Introduction</title>

    <para>This manual provides reference material for the Firebird
    <application>Interactive SQL Utility</application>
    (<application>isql</application>), and instructions on how to use it to
    perform tasks within the database.</para>

    <warning>
      <para>This manual is a work in progress. It is subject to change and
      possible restructuring as new versions appear.</para>
    </warning>

    <section id="isql-audience">
      <title>Audience</title>

      <para>This manual assumes prior knowledge of basic database
      concepts.</para>
    </section>

    <section id="isql-version">
      <title>Version</title>

      <para>This manual describes the <application>isql</application> utility
      in Firebird version 1.5 and higher.</para>
    </section>
  </section>

  <section id="isql-overview">
    <title>Overview</title>

    <para>The <application>isql</application> utility is a text-mode client
    tool located in the <filename class="directory">bin</filename> directory
    of the Firebird installation. It provides a command line interface for
    interactive access to a Firebird database. It accepts DSQL statements
    along with a group of SET and SHOW commands to query and interact with the
    Firebird database. Some SET commands can be incorporated in DDL scripts to
    perform batch executions within <application>isql</application>. It also
    accepts DDL, DML and console commands.</para>

    <para>The <application>isql</application> utility can be used in three
    modes: as an interactive session; directly from the command line; and as a
    non-interactive session, using a shell script or batch file. Different
    tasks may be performed in each of the modes, as illustrated below:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>An interactive session can be invoked from the command line of
        the operating system shell, and lasts until the session is terminated,
        using a QUIT or EXIT command. <application>Isql</application> can be
        used interactively to:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Create, update, query, and drop data or meta data.</para>
          </listitem>

          <listitem>
            <para>Input a script file containing a batch of SQL statements in
            sequence without prompting.</para>
          </listitem>

          <listitem>
            <para>Add and modify data.</para>
          </listitem>

          <listitem>
            <para>Grant user permissions.</para>
          </listitem>

          <listitem>
            <para>Perform database administrative functions.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Directly from the command line, with individual options and
        without starting an interactive session. Commands execute, and upon
        completion, return control automatically to the operating
        system.</para>
      </listitem>

      <listitem>
        <para>In a non-interactive session, the user employs a shell script or
        batch file to perform database functions.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Because other applications in the Linux environment, for example,
      mySQL, also use <application>isql</application> as a utility name, you
      are advised to run the Firebird utility from its own directory, or
      provide the absolute file path if you have another relational database,
      besides Firebird, installed on your machine.</para>
    </note>

    <note>
      <para>Some of the affected distributions, such as Mint Linux - based on
      Ubuntu - have renamed Firebird's <application>isql</application> to be
      <application>isql-fb</application>. There may be similar changes in
      other distributions.</para>

      <para>In addition, not all distributions install Firebird to the same
      location. OpenSuse, for example, installs just about everything to
      <filename class="directory">/opt/firebird/n.n</filename> but Ubuntu and
      derivatives install it to a number of different locations but the
      utilities are in <filename class="directory">/usr/bin</filename>.</para>

      <para>For the remainder of this document, the assumption will be that
      the utility is called <application>isql</application>.</para>
    </note>
  </section>

  <section id="isql-invoke">
    <title>Invoking <application>Isql</application></title>

    <para>If you do not have the Firebird <filename
    class="directory">bin</filename> directory on your path, then either go to
    the <filename class="directory">bin</filename> subdirectory of your
    Firebird installation and type <command>isql</command> (Windows) or
    <command>./isql</command> (Linux) at the command prompt, or, type the full
    path to the <application>isql</application> application to execute it. If
    the <filename class="directory">bin</filename> is on your path, you may
    start it by typing <command>isql</command> regardless of your operating
    system.</para>

    <para>Example:</para>

    <para><screen>C:\Firebird_2_0\bin&gt;isql 

Use CONNECT or CREATE DATABASE to specify a database
SQL&gt; CONNECT "C:\DATABASES\FIREBIRD\MY_EMPLOYEE.FDB" 
CON&gt; user 'SYSDBA' password 'secret';</screen></para>

    <para>The above is the simplest method of starting
    <application>isql</application>, and once activated in this way, you must
    begin by either creating a new database, or connecting to one. The prompt
    given by <application>isql</application> is a hint as to what you must do
    next. If you wish to connect to an already existing database, you may pass
    the database name on the command line. You should be aware that unless you
    also pass the username and password as well, you may see an error message
    telling you that your username or password have not bee defined. In this
    case, you need to supply the username and password, or create two
    environment variables as discussed <link
    linkend="isql-environment-variables">below</link>.</para>

    <para>The following example shows how to pass the database name plus user
    credentials on the command line.</para>

    <screen>C:\Firebird_2_0\bin&gt;isql -user sysdba -password secret employee

Database:  employee, User: sysdba

SQL&gt; </screen>

    <para>In this example, we used a database alias for the employee database.
    This example comes predefined in the file aliases.conf which normally
    lives under the directory that Firebird was installed in, but some Linux
    distributions put it in <filename>/etc/firebird/n.n</filename> where n.n
    is the version of the Firebird database server. There is more information
    on connecting to databases, using full paths or alias names, <link
    linkend="isql-connect-database">below</link>.</para>
  </section>

  <section id="isql-switches">
    <title>Command Line Switches</title>

    <!--TODO: Need to expand this section to link those switches to the set command that does the same. Everything else gets a section and an example or two.-->

    <para>Command line switches are arguments that begin with a minus/hyphen
    (-) character. The following is an example of what happens when you
    attempt to start isql with an invalid switch - it displayes the list of
    valid switches with a brief explanation of each.</para>

    <screen>tux&gt; $ isql --help

Unknown switch: -help
usage:    isql [options] [&lt;database&gt;]
        -a(ll)                  extract metadata incl. legacy non-SQL tables
        -b(ail)                 bail on errors (set bail on)
        -c(ache) &lt;num&gt;          number of cache buffers
        -ch(arset) &lt;charset&gt;    connection charset (set names)
        -d(atabase) &lt;database&gt;  database name to put in script creation
        -f(etch_password)       fetch password from file
        -e(cho)                 echo commands (set echo on)
        -ex(tract)              extract metadata
        -i(nput) &lt;file&gt;         input file (set input)
        -m(erge)                merge standard error
        -m2                     merge diagnostic
        -n(oautocommit)         no autocommit DDL (set autoddl off)
        -nod(btriggers)         do not run database triggers
        -now(arnings)           do not show warnings
        -o(utput) &lt;file&gt;        output file (set output)
        -pag(elength) &lt;size&gt;    page length
        -p(assword) &lt;password&gt;  connection password
        -q(uiet)                do not show the message "Use CONNECT..."
        -r(ole) &lt;role&gt;          role name
        -r2 &lt;role&gt;              role (uses quoted identifier)
        -s(qldialect) &lt;dialect&gt; SQL dialect (set sql dialect)
        -t(erminator) &lt;term&gt;    command terminator (set term)
        -u(ser) &lt;user&gt;          user name
        -x                      extract metadata
        -z                      show program and server version</screen>

    <para>Not all of these switches appear in every release of Firebird. Some
    will be seen in more recent releases. Many of the switches have an
    equivalent set command, and these will be discussed below.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Using -b(ail)</emphasis>:</para>

        <para>The command line switch -b(ail) instructs the
        <application>isql</application> utility to bail on error, but only
        when used in a non-interactive mode. The switch returns an error code
        to the Operating System.</para>

        <para>This switch was added to prevent <application>isql</application>
        from executing scripts after an error has been detected. No further
        statements will be executed and <application>isql</application> will
        return an error code to the OS.</para>

        <para>Users still need to use the -e(cho) switch to echo commands to
        an output file, to isolate the exact statement that caused the
        error.</para>

        <para>When the server provides line and column information, users can
        see the exact line of the DML in the script that caused the problem.
        When the server only indicates failure, users can view the first line
        of the statement that caused the failure, in relation to the entire
        script.</para>

        <para>This feature is also supported in nested scripts. For example,
        Script A includes Script B and Script B causes a failure, the line
        number is related to Script B. When Script B is read completely,
        <application>isql</application> continues counting the lines related
        to Script A, since each file gets a separate line counter. Script A
        includes Script B when Script A uses the INPUT command to load Script
        B.</para>

        <para>Lines are counted according to what the underlying IO layer
        considers separate lines. For ports using EDITLINE, a line is what
        readline() provides in a single call. The line length limit of 32767
        bytes remains uncharged.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using -ex(tract):</emphasis></para>

        <para>The command line switch -ex(tract) can be used to extract meta
        data from the database. It can be used in conjunction with the
        -o(utput) switch to extract the information to a specified output
        file.</para>

        <para>The resultant information can be used to view all the changes
        made to the database since its creation. Before making any more
        changes, create a new database with identical schema definitions or
        new ones, or create a new database source file.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using -m2 and -m(erge):</emphasis></para>

        <para>The command line switch m2, has been added in Firebird 2.0 and
        can be used to send the statistics and plans to the same output file
        that receives the input from the -o(utput) switch.</para>

        <para>In earlier versions of Firebird (before version 2.0), when a
        user specified that the output should be sent to a file, two options
        existed : the command line switch -o(utput) with a file name to store
        the output, or the command OUTput with a file name to store the
        output. Both these options could be employed either in a batch session
        or in the interactive <application>isql</application> shell. In both
        cases, simply passing the command OUTput would return the output to
        the console. While the console displayed error messages, these were
        not sent to the output file.</para>

        <para>The -m(erge) command line switch, can be used to incorporate the
        error messages into the output files.</para>

        <para>The -m2 command line switch ensures that the stats and plan
        information derived from the SET STATS, SET PLAN and SET PLANONLY
        commands are also sent to the output file and not just returned to the
        console.</para>

        <note>
          <para>Neither -m(erge) nor -m2 has an interactive counterpart
          through a SET command. They are for use only as command line
          <application>isql</application> options.</para>
        </note>
      </listitem>

      <listitem>
        <para><emphasis>Using -r2 and -r(ole):</emphasis></para>

        <para>This switch can be used to specify a case-sensitive role name.
        The default switch for this is -r(ole). Roles provided in the command
        line are uppercased With -r2, and passed to the engine exactly as
        typed in the command line.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using -o(utput)</emphasis>:</para>

        <para>The OUTPUT switch allows users to store records of commands to a
        script file. The TMP setting on a client can be used to control where
        these script files will be stored, if an absolute file path is not
        specified.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-start-session">
    <title>Starting An <application>Isql</application> Session</title>

    <para>To begin an <application>isql</application> session, enter the
    command line options and the name of the database in the Linux /Unix shell
    or Windows command console. For example:</para>

    <para><command>isql [options] [database_name_or_alias]</command></para>

    <note>
      <para>When invoking <application>isql</application>, you will need to
      include an appropriate <userinput>-user</userinput> and
      <userinput>-password</userinput> in your options, unless users have the
      <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar> declared as
      operating system variables. For example:</para>

      <para><command>isql -user SYSDBA -password masterkey</command></para>
    </note>

    <para><application>Isql</application> starts an interactive session if no
    options are specified. If no database is specified, users must connect to
    an existing database or create a new one after starting
    <application>isql</application>. It starts the interactive session by
    connecting to the named database, provided the login options are accurate
    and valid for the specified database. Depending on the options specified,
    <application>isql</application> starts an interactive or non-interactive
    session.</para>

    <para>Reading an input file and writing to an output file are not
    considered interactive tasks, therefore the <userinput>-input</userinput>
    or <userinput>-output</userinput> command line options do not initiate an
    interactive session. Options used to extract DDL statements, such as
    <userinput>-a</userinput> and <userinput>-x</userinput> also only initiate
    a non-interactive session.</para>

    <para><application>Isql</application> can be run from either a local or
    remote client:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>When connecting using a local client, you may set the
        environment variables <envar>ISC_USER</envar> and
        <envar>ISC_PASSWORD</envar>. For more information on these, see
        below.</para>
      </listitem>

      <listitem>
        <para>When connecting from a remote client, you will need a valid name
        and password.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-end-session">
    <title>Ending An <application>Isql</application> Session</title>

    <para>There are two ways to exit <application>isql</application>.</para>

    <itemizedlist>
      <listitem>
        <para>If you wish to roll back all uncommitted work and exit
        <application>isql</application> type this command at the
        prompt:</para>

        <para><command>SQL&gt; QUIT;</command></para>
      </listitem>

      <listitem>
        <para>If you wish to commit all your work before exiting
        <application>isql</application>, then type in the following
        command:</para>

        <para><command>SQL&gt; EXIT;</command></para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-help">
    <title>Getting Help</title>

    <para><application>Isql</application> comes with the
    <command>HELP</command> command. This gives brief details of most of the
    commands available - unfortunately, some are missing. The
    <command>help</command> command also allows you to drill down for further
    information. To activate the help system, simply type
    <command>HELP</command> at the prompt, as shown below (from Firebird
    2.5):</para>

    <screen>SQL&gt; help;

Frontend commands:
BLOBDUMP &lt;blobid&gt; &lt;file&gt;   -- dump BLOB to a file
BLOBVIEW &lt;blobid&gt;          -- view BLOB in text editor
EDIT     [&lt;filename&gt;]      -- edit SQL script file and execute
EDIT                       -- edit current command buffer and execute
HELP                       -- display this menu
INput    &lt;filename&gt;        -- take input from the named SQL file
OUTput   [&lt;filename&gt;]      -- write output to named file
OUTput                     -- return output to stdout
SET      &lt;option&gt;          -- (Use HELP SET for complete list)
SHELL    &lt;command&gt;         -- execute Operating System command in sub-shell
SHOW     &lt;object&gt; [&lt;name&gt;] -- display system information
    &lt;object&gt; = CHECK, COLLATION, DATABASE, DOMAIN, EXCEPTION, FILTER, FUNCTION,
               GENERATOR, GRANT, INDEX, PROCEDURE, ROLE, SQL DIALECT, SYSTEM,
               TABLE, TRIGGER, VERSION, USERS, VIEW
EXIT                       -- exit and commit changes
QUIT                       -- exit and roll back changes

All commands may be abbreviated to letters in CAPitals
</screen>

    <para>Most of these commands have no further levels of detail, while the
    <command>SET</command> command does. To drill down into those extra
    levels, proceed as follows:</para>

    <screen>SQL&gt; help set;

Set commands:
    SET                    -- display current SET options
    SET AUTOddl            -- toggle autocommit of DDL statements
    SET BAIL               -- toggle bailing out on errors in non-interactive mode
    SET BLOB [ALL|&lt;n&gt;]     -- display BLOBS of subtype &lt;n&gt; or ALL
    SET BLOB               -- turn off BLOB display
    SET COUNT              -- toggle count of selected rows on/off
    SET ROWCOUNT [&lt;n&gt;]     -- limit select stmt to &lt;n&gt; rows, zero is no limit
    SET ECHO               -- toggle command echo on/off
    SET HEADING            -- toggle display of query column titles
    SET LIST               -- toggle column or table display format
    SET NAMES &lt;csname&gt;     -- set name of runtime character set
    SET PLAN               -- toggle display of query access plan
    SET PLANONLY           -- toggle display of query plan without executing
    SET SQL DIALECT &lt;n&gt;    -- set sql dialect to &lt;n&gt;
    SET STATs              -- toggle display of performance statistics
    SET TIME               -- toggle display of timestamp with DATE values
    SET TERM &lt;string&gt;      -- change statement terminator string
    SET WIDTH &lt;col&gt; [&lt;n&gt;]  -- set/unset print width to &lt;n&gt; for column &lt;col&gt;

All commands may be abbreviated to letters in CAPitals
</screen>

    <para>If you attempt to drill down into any other command, the effect is
    exactly the same as executing the <command>HELP</command> command on its
    own.</para>

    <note>
      <para>In the output from <command>HELP SET</command>, there doesn't
      appear to be any help on the <command>SET TRANSACTION</command>
      command.</para>
    </note>
  </section>

  <section id="isql-connect-database">
    <title>Connecting To A Database</title>

    <para>A sample database named <filename>employee.fdb</filename> is located
    in the <filename class="directory">examples/empbuild</filename>
    subdirectory of your Firebird installation. Users can use this database to
    experiment with Firebird. Note that on some POSIX systems, the example
    database may not be located in the location given above. Each Linux
    Distribution, for example, may have decided to relocate some files.</para>

    <para><command>SQL&gt; CONNECT database name [user username] [password
    password] [role role_name];</command></para>

    <para>If any of the the parameters to the connect command contains spaces,
    you must wrap that parameter in single or double quotes.</para>

    <para>If username or password are not supplied, then the current values in
    the <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar> environment
    variables are used instead. There is no environment variable to preset the
    required role.</para>

    <para>It is possible to connect to a database using
    <application>isql</application> in two ways: locally and remotely.</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>To connect locally, on Windows XP, use the CONNECT statement
        with the full file path or an alias (for a local database):</para>

        <para><command>SQL&gt; CONNECT
        "C:\DATABASES\FIREBIRD\MY_EMPLOYEE.FDB"</command></para>

        <para>On Linux, a similar example would be:</para>

        <para><command>SQL&gt; CONNECT
        "/databases/firebird/MY_EMPLOYEE.FDB"</command></para>
      </listitem>

      <listitem>
        <para>If connecting remotely (using TCP/IP), use the
        <database>CONNECT</database> statement with the server name and
        complete file path of the database or, an alias. When using the full
        path, remember to ensure that the server name is separated from the
        database path with a colon.</para>

        <para>To connect to a database on a Linux/UNIX server named
        cosmos:</para>

        <para><command>SQL&gt; CONNECT
        'cosmos:/usr/firebird/examples/employee.gdb';</command></para>

        <para>To connect to a database on a Windows server named
        cosmos:</para>

        <para><command>SQL&gt; CONNECT
        'cosmos:C:\DATABASES\FIREBIRD\MY_EMPLOYEE.FDB'</command></para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Firebird is slash agnostic and automatically converts either type
      of slash to suit the relevant operating system.</para>
    </note>

    <section id="isql-connect-alias">
      <title>Using Database Alias Names</title>

      <para>In the examples above, we have been using the full path to the
      database file. This has a disadvantage in that all clients will be able
      to determine exactly where the database is to be found, or, may cause
      problems when the database has to be moved. To alleviate these problems,
      database aliases can be used.</para>

      <para>Once Firebird has been installed, a file named
      <filename>aliases.conf</filename> can be found in the main installation
      folder. By adding an entry to this folder, the full path to the database
      can be simplified to an alias name. This makes connecting easier, hides
      the actual database path from inquisitive users and allows the database
      to be moved around as necessary without having to change all the clients
      to allow them to connect to the database at the new location.</para>

      <para>To create an alias for the database currently known as
      <filename>/databases/firebird/MY_EMPLOYEE.FDB</filename> on the cosmos
      Linux server, we need to add the following to the
      <filename>aliases.conf</filename> file on the cosmos server. By default,
      this will be in the folder <filename
      class="directory">/opt/firebird</filename>. On Linux, this file is owned
      by the root user and so, must be updated by the root user. On Windows,
      you need to be either an administrator, a power user or SYSTEM to change
      the file.</para>

      <screen>my_employee = /databases/firebird/MY_EMPLOYEE.FDB
</screen>

      <para>There should be no quotes around the path to the database
      file.</para>

      <para>Regardless of where the database file is currently located, or if
      it has its physical filename renamed, etc, all the local users will
      refer to the database simply as <emphasis>my_employee</emphasis>. Remote
      users will refer to this database as
      <emphasis>cosmos:my_employee</emphasis>. The following example shows an
      <application>isql</application> session being connected locally to the
      database using the alias name rather than a full path:</para>

      <screen>cosmos&gt; /opt/firebird/bin/isql my_employee
Database:  test, User: sysdba

SQL&gt;</screen>

      <para>Alternatively, a remote connection would be made as follows,
      specifying the server name and the database alias together:</para>

      <screen>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql cosmos:my_employee
Database:  cosmos:my_employee

SQL&gt;</screen>

      <para>Because the alias is defined on the server where the database
      resides, then the remote client needs to supply the server name and the
      alias name (as defined on that server) in order to make a
      connection.</para>

      <para>Using the <command>CONNECT</command> command in an existing
      <application>isql</application> session is equally as simple using alias
      names:</para>

      <screen>SQL&gt; CONNECT 'cosmos:my_employee';
Database:  cosmos:my_employee

SQL&gt;</screen>

      <caution>
        <para>Regarding the security aspect of using database alias names to
        hide the full path to the actual database file(s), it's not really all
        that secure as the following SQL command shows:</para>

        <screen>SQL&gt; select MON$DATABASE_NAME from mon$database;

MON$DATABASE_NAME
=================================
/data/databases/firebird/test.fdb</screen>
      </caution>
    </section>
  </section>

  <section id="isql-create-database">
    <title>Creating A Database</title>

    <para>To create a database interactively using the
    <application>isql</application> command shell, get to a command prompt in
    Firebird's <filename class="directory">bin</filename> subdirectory and
    type <command>isql</command> (Windows) or <command>./isql</command>
    (Linux):</para>

    <para><screen>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql
Use CONNECT or CREATE DATABASE to specify a database</screen></para>

    <para>To create a database named <filename>monkey.fdb</filename> and store
    it in a directory named <filename class="directory">test</filename> on
    your <systemitem class="filesystem">C </systemitem>drive:</para>

    <para><screen>SQL&gt;CREATE DATABASE 'C:\test\monkey.fdb' page_size 8192
CON&gt;user 'SYSDBA' password 'masterkey';</screen></para>

    <note>
      <para>In the <command>CREATE DATABASE</command> statement it is
      <emphasis>mandatory</emphasis> to place quote characters (single or
      double) around path, user name and password.</para>

      <para>When running Classic Server on Linux, if the database is not
      started with a host name, the database file will be created with the
      Linux login name as the owner. This may cause access rights to others
      who may want to connect at a later stage. By prepending the <systemitem
      class="systemname">localhost:</systemitem> to the path, the server
      process, with Firebird 2.0 running as user <systemitem
      class="username">firebird</systemitem>, will create and own the
      file.</para>
    </note>

    <para>To test the newly created database type:</para>

    <para><screen>SQL&gt;SELECT RDB$RELATION_ID FROM RDB$DATABASE;

RDB$RELATION_ID
===============
128

SQL&gt; commit;</screen></para>

    <para>To get back to the command prompt type <command>quit</command> or
    <command>exit</command>.</para>

    <note>
      <para>The above technique, as demonstrated, works, but ideally databases
      and meta data objects should be created and maintained using data
      definition scripts.</para>
    </note>
  </section>

  <section id="isql-environment-variables">
    <title>Setting The ISC_USER And ISC_PASSWORD Environment Variables</title>

    <para>An environment variable is a named object that contains information
    used by one or more applications. They are global to their specific
    Operating Systems. The Firebird server recognises and uses certain
    environment variables configured in Windows, Linux and other Unix
    systems.</para>

    <para>The <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar>
    environment variables in Firebird are designed to give SYSDBA access to
    the database from the command line utilities and client applications to
    anyone who has access to a host machine.</para>

    <caution>
      <para>When running command line utilities like
      <application>isql</application>, <application>gbak</application>,
      <application>gstat</application>, and <application>gfix</application>,
      Firebird will search to see if the <envar>ISC_USER</envar> and
      <envar>ISC_PASSWORD</envar> environment variables are set. If you do not
      provide a user name and password while connecting to a database locally,
      Firebird will let you log in provided it finds these variables.</para>

      <para>For security reasons, it is not advised to specify the SYSDBA user
      name and password using these two environment variables especially on an
      insecure computer.</para>
    </caution>

    <para>The <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar>
    environment variables may be set in order to start
    <application>isql</application> locally. To set the environment
    variables:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>In Windows 2000 / XP, this is done in the Control Panel -&gt;
        System -&gt; Advanced -&gt; Environment Variables. Any changes made
        here will be permanent. You may also define these variables in a
        command window prior to running any of the Firebird utilities, such as
        <application>isql</application>. For example:</para>

        <screen>C:\&gt; set ISC_USER=sysdba
C:\&gt; set ISC_PASSWORD=secret
C:\&gt; isql my_employee

SQL&gt;</screen>
      </listitem>

      <listitem>
        <para>In Linux and Unix platforms, this depends on the type of shell
        being used and how the desktop is configured. Please refer to your
        Operating System documentation to set environmental variables. For the
        bash shell, the following example shows the process:</para>

        <screen>cosmos&gt; export ISC_USER=sysdba
cosmos&gt; export ISC_PASSWORD=secret
cosmos&gt; /opt/firebird/bin/isql my_employee

SQL&gt;</screen>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-dialects">
    <title>SQL Dialects</title>

    <para>Firebird supports three SQL dialects in each client and database
    server. These SQL dialects are differentiated in the context of the
    date-time format and the precision of a numerical data type. The dialects
    serve to instruct the Firebird server on how to process features
    implemented in legacy Borland Interbase databases, earlier than version
    6.0. Dialects are set up at runtime and can be changed for the client at
    connection time or with a <command>SET SQL DIALECT</command>
    command.</para>

    <note>
      <para>Dialect 2 is only used when converting a dialect 1 database to a
      dialect 3 database.</para>
    </note>

    <para>The following table illustrates the differences between the
    dialects.</para>

    <table>
      <title>SQL Dialects</title>

      <tgroup cols="4">
        <thead>
          <row>
            <entry>SQL</entry>

            <entry>Dialect 1</entry>

            <entry>Dialect 2</entry>

            <entry>Dialect 3</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Date</entry>

            <entry>Date &amp; Time (Timestamp)</entry>

            <entry>ERROR Message</entry>

            <entry>Date only</entry>
          </row>

          <row>
            <entry>Time Stamp</entry>

            <entry>Timestamp (v.6.x only)</entry>

            <entry>Timestamp</entry>

            <entry>Timestamp</entry>
          </row>

          <row>
            <entry>Time</entry>

            <entry>Error message</entry>

            <entry>Error message</entry>

            <entry>Time only</entry>
          </row>

          <row>
            <entry>&lt;"quoted item"&gt;</entry>

            <entry>String</entry>

            <entry>Error message</entry>

            <entry>Symbol only</entry>
          </row>

          <row>
            <entry>Precision: 1/3 =</entry>

            <entry>0.3333333... (double precision)</entry>

            <entry>0</entry>

            <entry>0</entry>
          </row>

          <row>
            <entry>Numeric 11</entry>

            <entry>double precision</entry>

            <entry>64 bit int</entry>

            <entry>64 bit int</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <note>
      <para>Currently it is possible to create databases in Dialect 1 and 3
      only, however it is recommended that you use Dialect 3 exclusively,
      since Dialect 1 will eventually be deprecated. Dialect 2 cannot be used
      to create a database since it only serves to convert Dialect 1 to
      Dialect 3.</para>
    </note>

    <para>When connecting to a database using <application>isql</application>,
    the utility takes on the dialect of the database, unless you specify
    otherwise. Dialects cannot be set as a parameter of a <command>CREATE
    DATABASE</command> statement. So, when creating a database using
    <application>isql</application>, the database will be in the dialect that
    is current in <application>isql</application> at the time the
    <command>CREATE DATABASE</command> statement is issued. You may set the
    dialect using the <application>isql</application> utility in two
    ways:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>When you start <application>isql</application> type:</para>

        <para><filename><command>cosmos&gt; isql -sql_dialect
        n</command></filename></para>

        <para><filename>(where n refers to the dialect
        number)</filename></para>
      </listitem>
    </itemizedlist>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Within a SQL script or <application>isql</application> session,
        type:</para>

        <para><command>SQL&gt; SET SQL DIALECT n;</command></para>

        <note>
          <para>Prior to Firebird 2.0 when <application>isql</application>
          disconnected from a database, either by dropping it or by trying to
          connect to a non-existent database, it remembered the SQL dialect of
          the previous connection, which lead to some inappropriate warning
          messages. This has been fixed in 2.0</para>
        </note>
      </listitem>
    </itemizedlist>
  </section>

  <section id="isql-terminator">
    <title>Terminator Character</title>

    <para>The default terminator symbol for the Firebird database is the
    semicolon (;). Statements will only be executed if they end with a
    semicolon. However, you may use <application>isql</application> to change
    the symbol to any printable character, or characters, from the first 127
    characters of the ASCII subset, by using the <command>SET TERM</command>
    command.</para>

    <note>
      <para>The default terminator maybe changed in all instances except in
      the case of <firstterm>Procedural SQL</firstterm> or PSQL. PSQL does not
      accept any terminator other than a semicolon.</para>
    </note>

    <para>To change the terminator character to a tilda (~) enter the
    following code:</para>

    <para><command>SQL&gt; SET TERM ~ ;</command></para>

    <para>You must terminate this command with the current terminator of
    course! Changing the terminator is useful if you wish to type in a PSQL
    function as the following example shows. Because PSQL will
    <emphasis>only</emphasis> accept the semicolon as a terminator, then
    <application>isql</application> needs to know which semicolon is being
    used for the PSQL code and which is being used to terminate the SQL
    commands being entered.</para>

    <programlisting>SQL&gt; set term ~ ;

SQL&gt; create procedure test_proc (iInput integer = 666)
CON&gt; returns (oOutput integer)
CON&gt; as
CON&gt; begin
CON&gt;   oOutput = iInput;
CON&gt;   suspend;
CON&gt; end~

SQL&gt; set term ; ~

SQL&gt; commit;

SQL&gt; select * from test_proc;

     OOUTPUT 
============ 
         666 
</programlisting>

    <para>You can see that withing the code for the procedure itself, the
    terminator is the semicolon. However, outside of the actual procedure
    code, the terminator is the tilde (~). <application>isql</application> is
    processing a single <command>CREATE PROCEDURE</command> command, but
    within that one SQL statement, there are multiple embedded PSQL
    statements:</para>

    <programlisting>oOutput = iInput;
suspend;</programlisting>

    <para>These have the semicolon terminator, as required by PSQL. The end of
    the <command>CREATE PROCEDURE</command> command is indicated by the use of
    the tilde as the terminator:</para>

    <programlisting>end~</programlisting>

    <para>You can, if desired, simply change the terminator because you prefer
    something other than a semi-colon. You don't have to be writing procedures
    in order to change it.</para>

    <screen>SQL&gt; -- Change terminator from ; to +
SQL&gt; set term + ;

SQL&gt; select count(*) from employee+

       COUNT 
============ 
          42 

SQL&gt; -- Change terminator from + to 'fred'
SQL&gt; set term fred +

SQL&gt; select count(*) from employee fred

       COUNT 
============ 
          42 

SQL&gt; -- Change back from 'fred' to ;
SQL&gt; set term ; fred</screen>

    <para>However, you must be careful not to pick a terminator character that
    will cause SQL statements to fail due to the terminator being used at some
    point within the SQL statement.</para>

    <screen>SQL&gt; select 600+60+6 as The_Beast from rdb$database;

            THE_BEAST 
===================== 
                  666 


SQL&gt; set term + ;
SQL&gt; select 600+60+6 as The_Beast from rdb$database+

Statement failed, SQLSTATE = 42000
Dynamic SQL Error
-SQL error code = -104
-Unexpected end of command - line 1, column 8
...


SQL&gt; set term ; +</screen>

    <para>The presence of the terminator within an expression has caused the
    "unexpected end of command" error. The SQL Parser within the Firebird
    database engine has determined that "select 600" is not a valid statement.
    For this reason, it is best to always choose a character, or characters,
    that will not confuse the parser.</para>

    <screen>SQL&gt; set term ++ ;

SQL&gt; select 600+60+6 as The_Beast from rdb$database++

            THE_BEAST 
===================== 
                  666</screen>
  </section>

  <section id="isql-prompts">
    <title>Isql Prompts</title>

    <formalpara>
      <title>The SQL prompt</title>

      <para>As shown above, the normal <application>isql</application> prompt
      for input is the <prompt>SQL&gt;</prompt> prompt. This indicates that
      the previous command has been completed and
      <application>isql</application> is now waiting for a new command to
      process.</para>
    </formalpara>

    <formalpara>
      <title>The CON prompt</title>

      <para>The <prompt>CON&gt;</prompt> or Continuation prompt is displayed
      if users press ENTER without ending a SQL statement with a terminator.
      For example:</para>
    </formalpara>

    <screen>SQL&gt; HELP
CON&gt;</screen>

    <para>Whenever you see the <prompt>CON&gt;</prompt> prompt, you may either
    continue entering the remainder of the command, or, enter a terminator to
    terminate the command. When you press return, the command will be executed
    in the latter case.</para>
  </section>

  <section id="isql-errors">
    <title>Error Handling And Exception Support</title>

    <para>Exception handling is a programming construct designed to handle an
    occurrence that disrupts the normal execution of a program. These are
    called errors. Exceptions are user-defined named error messages, written
    specifically for a database and stored in that database for use in stored
    procedures and triggers.</para>

    <para>For example, if it is ascertained in a trigger that the value in a
    table is incorrect, the exception is fired. This leads to a rollback of
    the total transaction that the client application is attempting to commit.
    Exceptions can be interleaved, and shared among the different modules of
    an application, and even among different applications sharing a database.
    They provide a simple way to standardize the handling of preprogrammed
    input errors.</para>

    <para>Exceptions are database objects, like Tables, Views and Domains, and
    are part of the database's meta data. They can be created, modified and
    dropped like all other Firebird objects using
    <application>isql</application>.</para>

    <para>In <application>isql</application>, error messages comprise the
    <database>SQLCODE</database> variable and the Firebird status array. The
    following table provides some examples:</para>

    <table frame="all">
      <title>ISQL Error Codes and Messages</title>

      <tgroup cols="3">
        <colspec colname="col1" colwidth="2*" />

        <colspec colname="col2" colwidth="2*" />

        <colspec colname="col3" colwidth="5*" />

        <thead>
          <row>
            <entry><para>SQLCODE</para></entry>

            <entry><para>Message</para></entry>

            <entry><para>Meaning</para></entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para>&lt;0</para></entry>

            <entry><para>SQLERROR</para></entry>

            <entry><para>Error occurred: statement did not
            execute</para></entry>
          </row>

          <row>
            <entry><para>0</para></entry>

            <entry><para>SUCCESS</para></entry>

            <entry><para>Successful execution</para></entry>
          </row>

          <row>
            <entry><para>+1 to +99</para></entry>

            <entry><para>SQLWARNING</para></entry>

            <entry><para>System warning or information message</para></entry>
          </row>

          <row>
            <entry><para>+100</para></entry>

            <entry><para>NOT FOUND</para></entry>

            <entry><para>No qualifying rows found, or end of current active
            set of rows reached</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="isql-transactions">
    <title>Transaction Handling</title>

    <para>The Firebird architecture allows high transaction concurrency.
    Transaction save points (nested transactions) are also supported. All
    Firebird transactions are ACID compliant. ACID is explained below:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><emphasis>Atomicity</emphasis> ensures that transactions either
        complete in their entirety or not at all, even if the system fails
        halfway through the process.</para>
      </listitem>

      <listitem>
        <para><emphasis>Consistency</emphasis> ensures that only valid data
        will be written to the database. If a transaction is executed that
        violates the database’s consistency rules, the entire transaction will
        be rolled back and the database will be restored to a state consistent
        with those rules. If a transaction successfully executes, it will take
        the database from one state that is consistent with the rules to
        another state that is also consistent with the rules, without
        necessarily preserving consistency at all intermediate levels.</para>
      </listitem>

      <listitem>
        <para><emphasis>Isolation</emphasis> ensures that transactions are
        isolated from one another, even if several transactions are running
        concurrently. Concurrency refers to a state within the database where
        two or more tasks are running simultaneously. This way, a
        transaction's updates are concealed from the rest until that
        transaction commits. Transactions in Firebird are isolated within
        separate contexts defined by client applications passing transaction
        parameters.</para>
      </listitem>

      <listitem>
        <para><emphasis>Durability</emphasis> ensures that once a transaction
        commits, its updates survive within the database, even if there is a
        subsequent system crash.</para>
      </listitem>
    </itemizedlist>

    <para>There are several parameters available to configure transactions in
    order to ensure consistency within the database. These parameters invoke
    the concept of concurrency. To ensure data integrity, there are four
    configurable parameters affecting concurrency: isolation level; lock
    resolution mode; access mode; and table reservation.</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para><emphasis>Isolation Level:</emphasis> A transaction isolation
        level defines the interaction and visibility of work performed by
        simultaneously running transactions. There are four transaction
        isolation levels according to the SQL standard:<itemizedlist
            spacing="compact">
            <listitem>
              <para>READ COMMITTED: A transaction sees only data committed
              before the statement has been executed.</para>
            </listitem>

            <listitem>
              <para>READ UNCOMMITTED: A transaction sees changes done by
              uncommitted transactions.</para>
            </listitem>

            <listitem>
              <para>REPEATABLE READ: A transaction sees during its lifetime
              only data committed before the transaction has been
              started.</para>
            </listitem>

            <listitem>
              <para>SERIALIZABLE: This is the strictest isolation level, which
              enforces transaction serialization. Data accessed in the context
              of a serializable transaction cannot be accessed by any other
              transaction.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <para>In <application>isql</application>, a transaction is begun as soon
    as the utility is started. The transaction is begun in SNAPSHOT isolation,
    with a lock resolution set to WAIT. Since the Firebird
    <application>isql</application> utility accepts DDL, DML and other
    commands, transactions are handled accordingly, in the following
    ways:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>DDL statements are committed automatically when issued at the
        SQL prompt in two ways:<itemizedlist spacing="compact">
            <listitem>
              <para>When <command>COMMIT</command> statements are included in
              the script.</para>
            </listitem>

            <listitem>
              <para>By ensuring the automatic commit of DDL in a
              <application>isql</application> script, by issuing a
              <command>SET AUTODDL ON</command> statement. To turn it off,
              issue a <command>SET AUTODDL OFF</command> statement at the
              <application>isql</application> prompt.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para>DML statements are not committed automatically. You must issue a
        <command>COMMIT</command> statement to commit any DML changes to the
        database.</para>
      </listitem>

      <listitem>
        <para>You can use various <command>SHOW</command> commands in
        <application>isql</application> to query database meta data. Meta data
        is stored in system tables. When a <command>SHOW</command> command is
        issued it operates in a separate transaction from user statements.
        They run as READ COMMITTED background statements and acknowledge all
        meta data changes immediately.</para>
      </listitem>
    </itemizedlist>

    <para>Users can specify the access mode and level of isolation for the
    next transaction, and explicitly commit the current transaction by using
    the <command>SET TRANSACTION</command> statement. <emphasis>SET
    TRANSACTION</emphasis> can be executed only when there is no other
    transaction being processed. It does not by itself initiate a transaction.
    Here is the syntax:</para>

    <para><command>SQL&gt; SET TRANSACTION;</command></para>

    <para>In Firebird 2.0 the <command>SET TRANSACTION</command> statement has
    been enhanced to support all Transaction Parameter Buffer (TPB) options.
    These include:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>NO AUTO UNDONE</para>
      </listitem>

      <listitem>
        <para>IGNORE LIMBO</para>
      </listitem>

      <listitem>
        <para>LOCK TIMEOUT &lt;number&gt;</para>
      </listitem>
    </itemizedlist>

    <para>Example:</para>

    <para><filename><userinput>SET TRANSACTION WAIT SNAPSHOT NO AUTO UNDONE
    LOCK TIMEOUT 10;</userinput></filename></para>

    <note>
      <para>If you request help on the <command>set</command> in
      <application>isql </application> then the <command>set
      transaction</command> command is not shown.</para>
    </note>
  </section>

  <section id="isql-scripts">
    <title>Script Handling</title>

    <para>A batch of DDL and/or DML statements in a text file is known as a
    script. Scripts can be used to create and alter database objects. These
    are referred to as <firstterm>Data Definition Language</firstterm> (DDL)
    scripts. Scripts that manipulate data by selecting, inserting, updating,
    deleting or performing data conversions, are called <firstterm>Data
    manipulation Language</firstterm> (DML) scripts.</para>

    <para>One of the most important tasks handled by
    <application>isql</application> is to process scripts. It can handle both
    DDL and DML Scripts, but they should be included in separate scripts to
    avoid data integrity problems. This script processing feature of
    <application>isql</application> allows the linking of one script to
    another using the <application>isql</application> command <command>INPUT
    &lt;filespec&gt;</command>. Scripts statements are executed in order that
    they appear in the script file. The default setting in
    <application>isql</application> for AUTODDL is set to ON. You may use the
    <command>SET AUTODDL</command> command to control where or when statements
    will be committed.</para>

    <note>
      <para>The AUTODDL setting <emphasis>only</emphasis> affects DDL
      statements. It doesn't commit DML statements. If you mix DDL and DML
      statements within the same interactive session, then the AUTODDL commits
      <emphasis>do not</emphasis> commit your DML transactions. For
      example:</para>

      <screen>SQL&gt; set autoddl on;

SQL&gt; insert into test(a) values (666);
SQL&gt; commit;

SQL&gt; select * from test;

           A 
============ 
         666

SQL&gt; insert into test(a) values (999);
SQL&gt; select * from test;

           A 
============ 
         666
         999 

SQL&gt; create table another_test(b integer);
SQL&gt; rollback;

SQL&gt; select * from test;

           A 
============ 
         666
</screen>
    </note>

    <para>Scripts can redirect their output to a log file using the
    <command>OUTPUT file_name</command> command. This can be entered directly
    at the <application>isql</application> prompt, or as part of a script file
    itself.</para>
  </section>

  <section id="isql-commands">
    <title><application>Isql</application> Commands</title>

    <para><application>Isql</application> commands affect the running of
    <application>isql</application> itself and do not affect the database or
    data in any way. These commands are used to display help, run scripts,
    create listings and so on. You can easily see a list of the available
    commands by typing the <command>help</command> command which will produce
    the following output:</para>

    <screen>SQL&gt; help;

Frontend commands:
BLOBDUMP &lt;blobid&gt; &lt;file&gt;   -- dump BLOB to a file
BLOBVIEW &lt;blobid&gt;          -- view BLOB in text editor
EDIT     [&lt;filename&gt;]      -- edit SQL script file and execute
EDIT                       -- edit current command buffer and execute
HELP                       -- display this menu
INput    &lt;filename&gt;        -- take input from the named SQL file
OUTput   [&lt;filename&gt;]      -- write output to named file
OUTput                     -- return output to stdout
SET      &lt;option&gt;          -- (Use HELP SET for complete list)
SHELL    &lt;command&gt;         -- execute Operating System command in sub-shell
SHOW     &lt;object&gt; [&lt;name&gt;] -- display system information
    &lt;object&gt; = CHECK, COLLATION, DATABASE, DOMAIN, EXCEPTION, FILTER, FUNCTION,
               GENERATOR, GRANT, INDEX, PROCEDURE, ROLE, SQL DIALECT, SYSTEM,
               TABLE, TRIGGER, VERSION, USERS, VIEW
EXIT                       -- exit and commit changes
QUIT                       -- exit and roll back changes

All commands may be abbreviated to letters in CAPitals
</screen>

    <para>Each of these commands will now be discussed. Note the last line of
    output from the <command>help</command> command. It explains that each of
    the commands may be abbreviated to just those letters displayed in capital
    letters. In the following discussion, the optional characters will be
    displays, as above, in lower case letters. For example, the
    <command>input</command> command will be shown as <command>INput</command>
    to indicate that the characters 'put' are optional.</para>

    <section>
      <title>Blobdump</title>

      <para><command>SQL&gt; BLOBDUMP blob_id filename;</command></para>

      <para>This command allows you to copy a BLOB from the database into an
      external file. It is the responsibility of the user to ensure that the
      correct file type is used - don't call an image file something.txt when
      it should be a jpeg for example.</para>

      <para><command>Blobdump</command> requires two parameters, a blob id and
      a filename. The latter is simple but the former is more convoluted. You
      are required to pass the blob id as a pair of hexadecimal numbers,
      separated by a colon. The first number is the relation id number for the
      table in question and the second is a sequential number within the
      database. You will see this pair of numbers when you select any BLOB
      column's data from a table - it is displayed above the BLOB contents,
      assuming that the display of BLOBs is turned on. See the <command>set
      blobdisplay</command> command below for details.</para>

      <screen>SQL&gt; set blobdisplay off;


SQL&gt; select proj_id, proj_desc
CON&gt; from project
CON&gt; where proj_id = 'MKTPR';

PROJ_ID         PROJ_DESC 
======= ================= 
MKTPR               85:10 


SQL&gt; blobdump 85:10 project.jpg;

SQL&gt; blobdump 85:10 project.txt;</screen>

      <para>The blob id required in the above example is the '85:10' value.
      You will notice that I have dumped this BLOB to both a jpeg and a text
      file. Isql gave no errors for the fact that I attempred to dump the BLOB
      to a jpeg file when the BLOB in question is text. Attempting to open the
      jpeg file with any image viewers will, however, result in an error. The
      text file opens happily in any of the assorted text viewers or editors
      installed on the system.</para>
    </section>

    <section>
      <title>Blobview</title>

      <para><command>SQL&gt; BLOBVIEW blob_id;</command></para>

      <para>This command is similar to blobdump above, but only requires the
      blob id parameter as the BLOB data will be displayed in an
      editor.</para>

      <screen>SQL&gt; blobview 85:10;</screen>

      <para>The contents of the selected BLOB are displayed in an external
      editor. When the editor is closed, control returns to
      <application>isql</application>. You cannot use
      <application>isql</application> while the editor is open.</para>

      <note>
        <para><command>BLOBVIEW</command> may return an “Invalid transaction
        handle” error after you close the editor. This is a known bug. To
        correct the situation, start a transaction manually, with the command
        <command>SET TRANSACTION;</command></para>
      </note>
    </section>

    <section>
      <title>Edit</title>

      <para><command>SQL&gt; EDIT [filename];</command></para>

      <para>This command allows you to edit an existing file. This may be a
      file of SQL commands to be used by the isql input command (see below) or
      any other text file. The file must, however, already exist.</para>

      <para>If no filename is supplied, a history of all your previous
      commands will be displayed for editing. Please note that when you exit
      from the editor in this case, the commands left in the buffer at the end
      of the edit will be executed as a script file.</para>
    </section>

    <section>
      <title>Help</title>

      <para>The <command>help</command> command has been discussed
      above.</para>
    </section>

    <section>
      <title>Add</title>

      <para><command>SQL&gt; ADD table_name;</command></para>

      <para>This command, when passed a table name, prompts you for each
      column's data and adds a row to the table. You may add as many rows as
      you wish as the command continues until either an error occurs or the
      RETURN key is pressed with no data. If you wish to set a column to NULL,
      type it in exactly as shown.</para>

      <screen>SQL&gt; add country;

Enter data or NULL for each column.  RETURN to end.
Enter COUNTRY&gt;Scotland
Enter CURRENCY&gt;GBP

Enter COUNTRY&gt;


SQL&gt; commit;</screen>
    </section>

    <section>
      <title>Copy</title>

      <para><command>SQL&gt; COPY from_table_name to_table_name
      [other_database];</command></para>

      <para>The <command>copy</command> command allows you to copy
      <emphasis>most of</emphasis> the <emphasis>structure</emphasis> of a
      table to a new table, in the current database or to a different one.
      Unfortunately it has a couple of problems:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>It shells out to the command line to do the work, and connects
          to the receiving database using an application named
          <application>isql</application>. If, like me, your system has
          renamed <application>isql</application> to
          <application>isql-fb</application>, you will actually end up running
          the wrong <application>isql</application> application and confusing
          error messages will be the only result.</para>
        </listitem>

        <listitem>
          <para>It assumes that <application>isql</application> will be on the
          <envar>$PATH</envar> or <envar>%PATH%</envar>.</para>
        </listitem>

        <listitem>
          <para>You need to define <envar>ISC_USER</envar> and
          <envar>ISC_PASSWORD</envar> for the child
          <application>isql</application> process to login to the receiving
          database to create the table. This is <emphasis>very</emphasis>
          insecure.</para>
        </listitem>

        <listitem>
          <para>Because of the need for <envar>ISC_USER</envar> and
          <envar>ISC_PASSWORD</envar>, the receiving database must be running
          on the <emphasis>same server</emphasis> as the source
          database.</para>
        </listitem>

        <listitem>
          <para>The data in the table is not copied to the receiving database.
          Only the following parts of the table's structure is copied.</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>Domains required to recreate the table. This only applies
              if the copy is to another database.</para>
            </listitem>

            <listitem>
              <para>The table itself will be created.</para>
            </listitem>

            <listitem>
              <para>Primary key constraint, if there is one.</para>
            </listitem>

            <listitem>
              <para>The index used to support the primary key constraint, if
              there is one.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Not all of the table structure is actually copied. Missing
          are:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>Foreign Key constraints.</para>
            </listitem>

            <listitem>
              <para>Check constraints.</para>
            </listitem>

            <listitem>
              <para>Indices other than the primary key index.</para>
            </listitem>

            <listitem>
              <para>Triggers.</para>
            </listitem>

            <listitem>
              <para>All of the table's data.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>

      <para>If you wish to copy to a different database, then the other
      database must be on the <emphasis>same server</emphasis> as the current
      one. You cannot, for example, connect to a database on a server named
      tux, and copy a table to a database running on the server tuxrep. The
      <command>copy</command> command has no way to allow you to pass a
      username and/or password and, equally, setting <envar>ISC_USER</envar>
      and <envar>ISC_PASSWORD</envar> only affects databases on the current
      server.</para>

      <screen>tux&gt; $ export ISC_USER=SYSDBA
tux&gt; $ export ISC_PASSWORD=secret
tux&gt; isql employee

Database:  employee, User: sysdba

SQL&gt; -- MAke a copy of the employee table into this database.
SQL&gt; copy employee employee_2;


SQL&gt; -- Compare table structures...
SQL&gt; show table employee;

EMP_NO                          (EMPNO) SMALLINT Not Null 
FIRST_NAME                      (FIRSTNAME) VARCHAR(15) Not Null 
LAST_NAME                       (LASTNAME) VARCHAR(20) Not Null 
PHONE_EXT                       VARCHAR(4) Nullable 
HIRE_DATE                       TIMESTAMP Not Null DEFAULT 'NOW'
DEPT_NO                         (DEPTNO) CHAR(3) Not Null 
                                CHECK (VALUE = '000' OR 
                                (VALUE &gt; '0' AND VALUE &lt;= '999') OR VALUE IS NULL)
JOB_CODE                        (JOBCODE) VARCHAR(5) Not Null 
                                CHECK (VALUE &gt; '99999')
JOB_GRADE                       (JOBGRADE) SMALLINT Not Null 
                                CHECK (VALUE BETWEEN 0 AND 6)
JOB_COUNTRY                     (COUNTRYNAME) VARCHAR(15) Not Null 
SALARY                          (SALARY) NUMERIC(10, 2) Not Null DEFAULT 0
                                CHECK (VALUE &gt; 0)
FULL_NAME                       Computed by: (last_name || ', ' || first_name)

CONSTRAINT INTEG_28:
  Foreign key (DEPT_NO)    References DEPARTMENT (DEPT_NO)
CONSTRAINT INTEG_29:
  Foreign key (JOB_CODE, JOB_GRADE, JOB_COUNTRY)    
  References JOB (JOB_CODE, JOB_GRADE, JOB_COUNTRY)
CONSTRAINT INTEG_27:
  Primary key (EMP_NO)
CONSTRAINT INTEG_30:
  CHECK ( salary &gt;= (SELECT min_salary FROM job WHERE
                        job.job_code = employee.job_code AND
                        job.job_grade = employee.job_grade AND
                        job.job_country = employee.job_country) AND
            salary &lt;= (SELECT max_salary FROM job WHERE
                        job.job_code = employee.job_code AND
                        job.job_grade = employee.job_grade AND
                        job.job_country = employee.job_country))

Triggers on Table EMPLOYEE:
SET_EMP_NO, Sequence: 0, Type: BEFORE INSERT, Active
SAVE_SALARY_CHANGE, Sequence: 0, Type: AFTER UPDATE, Active


SQL&gt; show table employee_2;

EMP_NO                          (EMPNO) SMALLINT Not Null 
FIRST_NAME                      (FIRSTNAME) VARCHAR(15) Not Null 
LAST_NAME                       (LASTNAME) VARCHAR(20) Not Null 
PHONE_EXT                       VARCHAR(4) Nullable 
HIRE_DATE                       TIMESTAMP Not Null DEFAULT 'NOW'
DEPT_NO                         (DEPTNO) CHAR(3) Not Null 
                                CHECK (VALUE = '000' OR 
                                (VALUE &gt; '0' AND VALUE &lt;= '999') OR VALUE IS NULL)
JOB_CODE                        (JOBCODE) VARCHAR(5) Not Null 
                                CHECK (VALUE &gt; '99999')
JOB_GRADE                       (JOBGRADE) SMALLINT Not Null 
                                CHECK (VALUE BETWEEN 0 AND 6)
JOB_COUNTRY                     (COUNTRYNAME) VARCHAR(15) Not Null 
SALARY                          (SALARY) NUMERIC(10, 2) Not Null DEFAULT 0
                                CHECK (VALUE &gt; 0)
FULL_NAME                       Computed by: (last_name || ', ' || first_name)

CONSTRAINT INTEG_93:
  Primary key (EMP_NO)



SQL&gt; -- Check indices on both tables...
SQL&gt; show indices employee;

NAMEX INDEX ON EMPLOYEE(LAST_NAME, FIRST_NAME) 
RDB$FOREIGN8 INDEX ON EMPLOYEE(DEPT_NO) 
RDB$FOREIGN9 INDEX ON EMPLOYEE(JOB_CODE, JOB_GRADE, JOB_COUNTRY) 
RDB$PRIMARY7 UNIQUE INDEX ON EMPLOYEE(EMP_NO) 


SQL&gt; show indices employee_2;
RDB$PRIMARY27 UNIQUE INDEX ON EMPLOYEE_2(EMP_NO)


SQL&gt; -- Check data counts on both tables...
SQL&gt; select count(*) from employee;

       COUNT 
============ 
          42


SQL&gt; select count(*) from employee_2;

       COUNT 
============ 
           0
</screen>

      <para>The <application>copy</application> command only works provided
      your <application>isql</application> application is really named
      <application>isql</application>. In addition, if you have lots of data
      in the table, you still have to copy it manually as the
      <command>copy</command> command will only copy the table structure.
      Remember that the new table will have no triggers, no foreign keys, no
      indices - other than the primary key one - and no data.</para>

      <note>
        <para>It is possible that the <command>copy</command> command will be
        removed from <application>isql</application> at some future
        release.</para>
      </note>
    </section>

    <section>
      <title>Input</title>

      <para><command>SQL&gt; INput filename;</command></para>

      <para>This command enables the user to execute a number of commands from
      a script file rather than manually typing them all into
      <application>isql</application> at the prompt. The script may contain
      any mix of DDL and/or DDL commands, along with
      <application>isql</application> commands to redirect output, change
      options, etc.</para>

      <screen>SQL&gt; shell;

$ cat test.sql
drop table fred;
commit;

$ exit;


SQL&gt; show table fred;

A                               INTEGER Nullable 
B                               INTEGER Not Null


SQL&gt; input test.sql;


SQL&gt; show table fred;
There is no table FRED in this database
</screen>
    </section>

    <section>
      <title>Output</title>

      <para><command>SQL&gt; OUTput [filename];</command></para>

      <para>This command redirects all output that normally is displayed on
      the screen, to a specific file. If a file name is supplied, all
      subsequent output goes to that file and is not displayed on screen. If
      no file name is supplied, output is once more redirected to the
      screen.</para>

      <screen>SQL&gt; output test.log;

SQL&gt; show tables;

SQL&gt; output;

SQL&gt; shell;

$ cat test.log

       COUNTRY                                CUSTOMER                       
       DEPARTMENT                             EMPLOYEE                       
       EMPLOYEE_PROJECT                       FRED                           
       JOB                                    PROJECT                        
       PROJ_DEPT_BUDGET                       SALARY_HISTORY                 
       SALES
</screen>
    </section>

    <section>
      <title>Set</title>

      <para>There are a number of settings and options that can be changed to
      suit how you wish <application>isql</application> to operate. These
      settings are changed by the <command>set</command> command which is
      discussed <link linkend="isql-set">below</link>.</para>
    </section>

    <section>
      <title>Shell</title>

      <para><command>SQL&gt; SHELL;</command></para>

      <para>This command allows you to temporarily exit from
      <application>isql</application> and use a shell session to carry out
      some further processing. On exiting from the shell, you will return to
      <application>isql</application>. You cannot use the
      <application>isql</application> session that activated the shell while
      the shell session remains open.</para>

      <screen>SQL&gt; shell;

$ cat test.log

       COUNTRY                                CUSTOMER                       
       DEPARTMENT                             EMPLOYEE                       
       EMPLOYEE_PROJECT                       FRED                           
       JOB                                    PROJECT                        
       PROJ_DEPT_BUDGET                       SALARY_HISTORY                 
       SALES                           

$ exit

SQL&gt; 
</screen>
    </section>

    <section>
      <title>Show</title>

      <para>There are a number of settings and options that can be changed to
      suit how you wish <application>isql</application> to operate. The
      <command>show</command> command allows you to view the way that these
      have been set up by the <command>set</command> commands, or by other
      options. These are discussed <link
      linkend="isql-show">below</link>.</para>
    </section>

    <section>
      <title>Exit</title>

      <para><command>SQL&gt; EXIT;</command></para>

      <para>The exit command will commit any uncommitted work and exit from
      <application>isql</application>.</para>
    </section>

    <section>
      <title>Quit</title>

      <para><command>SQL&gt; QUIT;</command></para>

      <para>The quit command will rollback any uncommitted work and exit from
      <application>isql</application>.</para>
    </section>
  </section>

  <section id="isql-set">
    <title><application>Isql</application> Set Commands</title>

    <para>As explained in the <command>help</command> command, you may enter
    the <command>help set</command> command to drill down into the various
    options available for the <command>set</command> command. These are all
    discussed below. Note that the output from the <command>help set</command>
    command does not include the <command>set transaction</command> command.
    The <command>help set</command> command produces the following output
    (from Firebird 2.5):</para>

    <screen>SQL&gt; help set;

Set commands:
    SET                    -- display current SET options
    SET AUTOddl            -- toggle autocommit of DDL statements
    SET BAIL               -- toggle bailing out on errors in non-interactive mode
    SET BLOB [ALL|&lt;n&gt;]     -- display BLOBS of subtype &lt;n&gt; or ALL
    SET BLOB               -- turn off BLOB display
    SET COUNT              -- toggle count of selected rows on/off
    SET ROWCOUNT [&lt;n&gt;]     -- limit select stmt to &lt;n&gt; rows, zero is no limit
    SET ECHO               -- toggle command echo on/off
    SET HEADING            -- toggle display of query column titles
    SET LIST               -- toggle column or table display format
    SET NAMES &lt;csname&gt;     -- set name of runtime character set
    SET PLAN               -- toggle display of query access plan
    SET PLANONLY           -- toggle display of query plan without executing
    SET SQL DIALECT &lt;n&gt;    -- set sql dialect to &lt;n&gt;
    SET STATs              -- toggle display of performance statistics
    SET TIME               -- toggle display of timestamp with DATE values
    SET TERM &lt;string&gt;      -- change statement terminator string
    SET WIDTH &lt;col&gt; [&lt;n&gt;]  -- set/unset print width to &lt;n&gt; for column &lt;col&gt;

All commands may be abbreviated to letters in CAPitals
</screen>

    <note>
      <para>In the above, the <command>BLOB</command> commands are incomplete.
      They should be <command>BLOBdisplay</command>. The above is displayed
      when the <command>set</command> command is executed with no parameters,
      however, in the following descriptions of the various
      <command>set</command> commands, I will be using the full
      <command>BLOBdisplay</command> version of the appropriate
      commands.</para>
    </note>

    <para>The last line of the above output indicates that these commands can
    be abbreviated to the letters in capitals. Unfortunately, other than the
    <command>set autoddl</command> command, none of the others appear to have
    a short form.</para>

    <section>
      <title>Set</title>

      <para>The <command>set</command> command, with no parameters, displays
      the current settings, as the following example from Firebird 2.5
      shows:</para>

      <screen>SQL&gt; set;

Set commands:
    SET                    -- display current SET options
    SET AUTOddl            -- toggle autocommit of DDL statements
    SET BAIL               -- toggle bailing out on errors in non-interactive mode
    SET BLOB [ALL|&lt;n&gt;]     -- display BLOBS of subtype &lt;n&gt; or ALL
    SET BLOB               -- turn off BLOB display
    SET COUNT              -- toggle count of selected rows on/off
    SET ROWCOUNT [&lt;n&gt;]     -- limit select stmt to &lt;n&gt; rows, zero is no limit
    SET ECHO               -- toggle command echo on/off
    SET HEADING            -- toggle display of query column titles
    SET LIST               -- toggle column or table display format
    SET NAMES &lt;csname&gt;     -- set name of runtime character set
    SET PLAN               -- toggle display of query access plan
    SET PLANONLY           -- toggle display of query plan without executing
    SET SQL DIALECT &lt;n&gt;    -- set sql dialect to &lt;n&gt;
    SET STATs              -- toggle display of performance statistics
    SET TIME               -- toggle display of timestamp with DATE values
    SET TERM &lt;string&gt;      -- change statement terminator string
    SET WIDTH &lt;col&gt; [&lt;n&gt;]  -- set/unset print width to &lt;n&gt; for column &lt;col&gt;
</screen>
    </section>

    <section id="isql-set-autoddl">
      <title>Set Autoddl</title>

      <para><command>SQL&gt; SET AUTOddl [on | off];</command></para>

      <para>This command sets whether all DDL statements executed will be
      automatically committed or not. The command without any parameters acts
      as a toggle and turns autoddl off if it is currently on and vice versa.
      You may supply a specific parameter to make your intentions clear. The
      parameter must be one of <command>on</command> or
      <command>off</command>. The <command>set</command> command, with no
      parameters, will display the current setting. The default in
      <application>isql</application> is equivalent to <command>set autoddl
      on</command>.</para>
    </section>

    <section id="isql-set-bail">
      <title>Set Bail</title>

      <para><command>SQL&gt; SET BAIL [on | off];</command></para>

      <para>Setting this command determines whether or not
      <application>isql</application> will "bail out" on any errors when the
      input command has been used to read a script file.
      <application>Isql</application> will not exit if it is running in
      interactive mode, and you cause an error.</para>

      <para>Executing this command, without passing a parameter, results in a
      toggling of the current state. If <command>bail</command> is on, it will
      trun off and vice versa.</para>
    </section>

    <section id="isql-set-blobdisplay">
      <title>Set Blobdisplay</title>

      <para><command>SQL&gt; SET BLOBdisplay [n | all | off];</command></para>

      <para>This command determines if BLOB column data is to be displayed in
      the output when a table with BLOB columns is queried. The deafult for
      this command, if no parameters are passed, is to set BLOB data off - it
      will not be displayed, only the blob id will be shown.</para>

      <para>The blob id is discussed above in the section describing the
      <command>blobdump</command> and <command>blobview</command>
      commands.</para>

      <para>If all is passed, then all BLOB sub-types will be
      displayed.</para>

      <para>If a number representing the blob sub-type is passed, then only
      BLOBs with the specififc sub-type will be displayed. The default is 1
      for text sub-types.</para>

      <screen>SQL&gt; -- Don't display any blob data.
SQL&gt; set blob off;

SQL&gt; select proj_desc 
CON&gt; from project
CON&gt; where proj_id = 'HWRII';

        PROJ_DESC 
================= 
             85:e 


SQL&gt; -- Display all blob data.
SQL&gt; set blobdisplay all;

SQL&gt; select proj_desc
CON&gt; from project
CON&gt; where proj_id = 'HWRII';

        PROJ_DESC 
================= 
             85:e 
==============================================================================
PROJ_DESC:  
Integrate the hand-writing recognition module into the
universal language translator.
==============================================================================


SQL&gt; -- Only display type 1 blob data = text.
SQL&gt; set blob 1;

SQL&gt; select proj_desc
CON&gt; from project
CON&gt; where proj_id = 'HWRII';

        PROJ_DESC 
================= 
             85:e 
==============================================================================
PROJ_DESC:  
Integrate the hand-writing recognition module into the
universal language translator.
==============================================================================


SQL&gt; -- Only display blob type 7 = not text!
SQL&gt; set blob 7;

SQL&gt; select proj_desc
CON&gt; from project
CON&gt; where proj_id = 'HWRII';

        PROJ_DESC 
================= 
             85:e 
==============================================================================
PROJ_DESC:  
BLOB display set to subtype 7. This BLOB: subtype = 1
==============================================================================</screen>

      <para>You will notice in the last example that a message was displayed
      advising that we are only displaying BLOB data for sub-type 7 and the
      BLOB data in this table is a sub-type 1, so the data are not
      displayed.</para>
    </section>

    <section id="isql-set-count">
      <title>Set Count</title>

      <para><command>SQL&gt; SET COUNT [on | off];</command></para>

      <para>This command determines whether a line of text is displayed at the
      end of the output from a DML statement, telling the user how many rows
      were affected.</para>

      <screen>SQL&gt; set count on;

SQL&gt; select count(*) from employee;

       COUNT 
============ 
          42 

Records affected: 1</screen>

      <para>The record count is displayed for all DDL operations, not just for
      a SELECT.</para>

      <screen>SQL&gt; create table fred( a integer);
SQL&gt; commit;

SQL&gt; insert into fred values (666);
Records affected: 1

SQL&gt; update fred set a = 123 where a = 666;
Records affected: 1

SQL&gt; delete from fred;
Records affected: 1

SQL&gt; commit;</screen>
    </section>

    <section id="isql-set-rowcount">
      <title>Set Rowcount</title>

      <para><command>SQL&gt; SET ROWCOUNT [n];</command></para>

      <para>Setting <command>rowcount</command> to zero, which is the default
      when <application>isql</application> is started, results in a select
      statement returning all rows which meet the criteria in the where
      clause. There are circumstances where you do not want lots and lots of
      output scrolling up the screen, so you may <command>set
      rowcount</command> to a smaller number and all subsequent select
      statements will only display the first 'n' rows instead of
      everything.</para>

      <screen>SQL&gt; set count on;
SQL&gt; set rowcount 0;

SQL&gt; select emp_no from employee;

 EMP_NO 
======= 
      2 
      4 
...
    144 
    145 

Records affected: 42


SQL&gt; set rowcount 10;
SQL&gt; select emp_no from employee;

 EMP_NO 
======= 
      2 
      4 
...
     15 
     20 

Records affected: 10
</screen>

      <para>There is no indication that <command>rowcount</command> is
      restricting the number of rows returned, it is the responsibility of the
      user to remember, or check whether <command>rowcount</command> is on or
      off. Using <command>rowcount</command> can lead to confusion about
      exactly how many rows there are in a table!</para>
    </section>

    <section id="isql-set-echo">
      <title>Set Echo</title>

      <para><command>SQL&gt; SET ECHO [ON | OFF];</command></para>

      <para>The default is on if you do not supply a value. This command
      causes all the SQL commands being executed to be displayed on the output
      device prior to their execution. You may wish to turn echo off as part
      of a script file although the <application>isql</application> default is
      for echo to be off.</para>

      <screen>SQL&gt; set echo on;

SQL&gt; select count(*) from rdb$database;
select count(*) from rdb$database;

       COUNT 
============ 
           1 


SQL&gt; set echo off;
set echo off;

SQL&gt; select count(*) from rdb$database;

       COUNT 
============ 
           1</screen>

      <para>This command can be handy in a script file. If you receive an
      error, it can sometimes be difficult to determine the exact SQL
      statement that caused it. If you <command>set echo on</command> in your
      script, you will at least be able to determine exactly which statement
      failed.</para>
    </section>

    <section id="isql-set-heading">
      <title>Set Heading</title>

      <para><command>SQL&gt; SET HEADING [ON | OFF];</command></para>

      <para>This command turns the display of column headings on or off as
      desired. If no parameter is supplied to the command, it toggles the
      current state of the heading display.</para>

      <screen>SQL&gt; set heading off;

SQL&gt; select count(*) from employee;

          42 


SQL&gt; set heading on;

SQL&gt; select count(*) from employee;

       COUNT 
============ 
          42</screen>
    </section>

    <section id="isql-set-list">
      <title>Set List</title>

      <para><command>SQL&gt; SET LIST [ON | OFF];</command></para>

      <para>This command controls how the data returned by a select statement
      will be displayed. The default setting to to display the data in tabular
      form with optional column headings at the top of each 'page'. Setting
      the list mode to on results in a different format where each column
      heading is displayed on the left and the column data on the right. This
      repeats for each and every row returned by the query.</para>

      <para>As with other commands, not providing a value to the command
      results in a toggle of the current setting.</para>

      <screen>SQL&gt; set list off;

SQL&gt; select emp_no, first_name, last_name, salary
CON&gt; from employee;

 EMP_NO FIRST_NAME      LAST_NAME                           SALARY 
======= =============== ==================== ===================== 
      2 Robert          Nelson                           105900.00 
      4 Bruce           Young                             97500.00 
      5 Kim             Lambert                          102750.00 
      8 Leslie          Johnson                           64635.00
...


SQL&gt; set list on;

SQL&gt; select emp_no, first_name, last_name, salary
CON&gt; from employee;

EMP_NO                          2
FIRST_NAME                      Robert
LAST_NAME                       Nelson
SALARY                          105900.00

EMP_NO                          4
FIRST_NAME                      Bruce
LAST_NAME                       Young
SALARY                          97500.00
...
</screen>
    </section>

    <section id="isql-set-names">
      <title>Set Names</title>

      <para><command>SQL&gt; SET NAMES [character_set];</command></para>

      <para>This command defines the character set to be used in subsequent
      database transactions. If the default database charcter set is not NONE,
      then in situations where the client uses a different character set to
      the database, it is possible to suffer from data corruption as some
      character sets cannot convert some characters to a suitable character in
      another character set.</para>

      <para>If you don't pass a character set, the default will be to use the
      NONE character set.</para>

      <para>You can determine a list of the valid character sets to use with
      the following query:</para>

      <screen>SQL&gt; set width RDB$CHARACTER_SET_NAME 30;

SQL&gt; select RDB$CHARACTER_SET_NAME
CON&gt; from RDB$CHARACTER_SETS
CON&gt; order by 1;

RDB$CHARACTER_SET_NAME         
============================== 
ASCII                          
BIG_5                          
CP943C                         
CYRL                           
DOS437                         
...                   
ISO8859_1                      
ISO8859_13                     
...                    
NONE                           
OCTETS                         
...
UTF8                           
...
WIN1258</screen>
    </section>

    <section id="isql-set-plan">
      <title>Set Plan</title>

      <para><command>SQL&gt; SET PLAN [ON | OFF];</command></para>

      <para>This command determines whether or not isql will display the plan
      it used to access the data for each statement executed. The isql default
      is never to display the plan. As with many other commands, not providing
      a parameter toggles the current state.</para>

      <screen>SQL&gt; set plan on;

SQL&gt; select emp_no, first_name, last_name
CON&gt; from employee
CON&gt; where emp_no = 107;

PLAN (EMPLOYEE INDEX (RDB$PRIMARY7))

 EMP_NO FIRST_NAME      LAST_NAME            
======= =============== ==================== 
    107 Kevin           Cook                


SQL&gt; update employee
CON&gt; set first_name = 'Norman'
CON&gt; where last_name = 'Cook';

PLAN (EMPLOYEE INDEX (NAMEX))


SQL&gt; select count(*) from employee;

PLAN (EMPLOYEE NATURAL)

       COUNT 
============ 
          42
</screen>

      <para>The execution plan is displayed before the output from a select
      statement.</para>
    </section>

    <section id="isql-set-planonly">
      <title>Set Planonly</title>

      <para><command>SQL&gt; SET PLANONLY [ON | OFF];</command></para>

      <para>This command prevents Firebird from actually executing the SQL
      statement and instead, simply shows the plan that it would use to access
      the data. This command relies on the <command>set plan</command>
      command. If <command>set plan off</command> had been executed, this
      command would have no effect, so turning <command>planonly</command> on
      has the additional effect of executing <command>set plan on</command>
      implicitly. Executing <command>set planonly off</command> does
      <emphasis>not</emphasis> implicitly execute <command>set plan
      off</command>.</para>

      <screen>SQL&gt; set planonly on;

SQL&gt; select count(*) from employee;

PLAN (EMPLOYEE NATURAL)</screen>

      <para>As before, not supplying a parameter toggles the current
      setting.</para>
    </section>

    <section id="isql-set-sqldadisplay">
      <title>Set SQLDA_Display</title>

      <para>This is a hidden command which is not mentioned in the output from
      the <command>help set</command> command. It displays internal details
      about the SQL statements being executed by
      <application>isql</application>. This used to be only available in a
      special debug build, but since version 2.0, it is available in
      <application>isql</application>.</para>

      <screen>SQL&gt; set sqlda_display on;

SQL&gt; select count(*) from employee;

INPUT  SQLDA version: 1 sqln: 10 sqld: 0

OUTPUT SQLDA version: 1 sqln: 20 sqld: 1
01: sqltype: 496 LONG                    sqlscale: 0 sqlsubtype: 0 sqllen: 4
  :  name: (5)COUNT  alias: (5)COUNT
  : table: (0)  owner: (0)

       COUNT 
============ 
          42</screen>

      <para>Note that when you run the <command>help set</command> or
      <command>set</command> commands, no information about this command will
      be displayed.</para>
    </section>

    <section id="isql-set-sqldialect">
      <title>Set SQL Dialect</title>

      <para><command>SQL&gt; SET SQL DIALECT {1 | 2 | 3};</command></para>

      <para>This command specifies the Firebird SQL dialect to which the
      client session is to be changed. If the session is currently attached to
      a database of a different dialect to the one specified in the command, a
      warning is displayed. The values permitted are:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>1 - which sets the client connection to SQL dialect 1</para>
        </listitem>

        <listitem>
          <para>2 - which sets the client connection to SQL dialect 2.</para>
        </listitem>

        <listitem>
          <para>3 - which sets the client connection to SQL dialect 3.</para>
        </listitem>
      </itemizedlist>

      <para>See <link linkend="isql-dialects">Dialects</link> for details of
      the differences between the three dialects.</para>

      <screen>SQL&gt; set sql dialect 1;
WARNING: Client SQL dialect has been set to 1 when 
connecting to Database SQL dialect 3 database.
...
SQL&gt; set sql dialect 3;
SQL&gt;
</screen>

      <para>The warning in the above example has had to be split over two
      lines in order to have it fit on the page. Normally, it consist of a
      single line.</para>
    </section>

    <section id="isql-set-stats">
      <title>Set Stats</title>

      <para><command>SQL&gt; SET STATs [ON | OFF];</command></para>

      <para>This command determines whether or not isql should display various
      statistics about each SQL command executed. As usual, failing to pass a
      parameter results in the current setting being toggled.</para>

      <screen>SQL&gt; set stats on;

SQL&gt; select count(*) from employee;

       COUNT 
============ 
          42 

Current memory = 10094216
Delta memory = 16
Max memory = 10227608
Elapsed time= 0.00 sec
Cpu = 0.00 sec
Buffers = 2048
Reads = 0
Writes = 0
Fetches = 92</screen>
    </section>

    <section id="isql-set-time">
      <title>Set Time</title>

      <para><command>SQL&gt; SET TIME [ON | OFF];</command></para>

      <para>This command applies to dialect 1 databases only. It causes the
      time portion to be displayed or not, when the selected data is a column
      defined with the DATE data type. It has no effect in other
      dialects.</para>
    </section>

    <section id="isql-set-term">
      <title>Set Term</title>

      <para><command>SQL&gt; SET TERM new_terminator
      current_terminator</command></para>

      <para>This command changes the default statement terminator from a
      semi-colon to something else as defined in the passed string. This is
      mostly useful when you are about to enter a string of SQL statements
      making up a procedure, for example, or a trigger.
      <application>Isql</application> would attempt to execute each statement
      when it sees a termianting semi-colon, so you would change the
      terminator first, then enter the required code. When complete, you would
      change it back, but when doing so, you must remember to terminate the
      <command>set term</command> command with the
      <emphasis>current</emphasis> terminating character(s).</para>

      <para>When first started, <application>isql</application> uses the
      semi-colon as the default terminator.</para>

      <para>You can, if desired, simply change the terminator because you
      prefer something other than a semi-colon. You don't have to be writing
      procedures in order to change it.</para>

      <screen>SQL&gt; -- Change terminator from ; to +
SQL&gt; set term +;

SQL&gt; select count(*) from employee+

       COUNT 
============ 
          42 

SQL&gt; -- Change terminator from + to 'fred'
SQL&gt; set term fred +

SQL&gt; select count(*) from employee fred

       COUNT 
============ 
          42 

SQL&gt; -- Change back from 'fred' to ;
SQL&gt; set term ; fred</screen>

      <para>See the section on the <link
      linkend="isql-terminator">terminator</link> for full details.</para>
    </section>

    <section id="isql-set-transaction">
      <title>Set Transaction</title>

      <!--TODO: Need to write this one up and add an example or two.-->

      <para>This is another hidden command which is not mentioned in the
      output from the <command>help set</command> command.</para>

      <para>There is a default transaction started for you when you use isql.
      When you commit or rollback in isql, the default transaction ends, and a
      new default transaction begins. These transactions are:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>READ WRITE - meaning that any SQL statment that is executed
          may make changes in the database.</para>
        </listitem>

        <listitem>
          <para>WAIT - meaning that if a row in a table is currently locked by
          another session, the execution of the statement will appear to hang
          until the other session either commits or rolls back.</para>
        </listitem>

        <listitem>
          <para>SNAPSHOT - meaning that this transaction will be guaranteed a
          non-volatile view of the data and will be unaffected by any changes
          made and committed in any other transactions that take place while
          this one remains unfinished by a commit or rollback.</para>
        </listitem>
      </itemizedlist>

      <para>A full explanation of transactions is beyond the scope of this
      manual. For more information see <emphasis>The Firebird Book</emphasis>
      by Helen Borrie.</para>
    </section>

    <section id="isql-set-warnings">
      <title>Set Warnings</title>

      <para><command>SQL&gt; SET {WARNINGS | WNG} [ON | OFF];</command></para>

      <para>This command specifies whether warnings are to be output. A few
      examples for which <application>isql</application> issues warnings are:
      <itemizedlist spacing="compact">
          <listitem>
            <para>SQL statements with no effect.</para>
          </listitem>

          <listitem>
            <para>Pending database shutdown.</para>
          </listitem>

          <listitem>
            <para>API calls that may be replaced in future versions of
            Firebird.</para>
          </listitem>

          <listitem>
            <para>Expressions that may cause differing results in different
            versions of Firebird.</para>
          </listitem>

          <listitem>
            <para>In Firebird 1.0, SQL statements with ambiguous join
            specifications. More recent Firebird versions will raise an
            exception rather than a warning.</para>
          </listitem>
        </itemizedlist>As with many of the set commands, set warnings acts as
      a toggle if no parameter is supplied.</para>
    </section>

    <section id="isql-set-width">
      <title>Set Width</title>

      <para>Normally the width of a <emphasis>character</emphasis> column in a
      table defines the width of the output when that column is selected.
      Using the <command>set width</command> command allows the user to define
      a wider or narrower output column width.</para>

      <para>The format of the command is <command>set width column_or_alias
      width;</command> The setting remains until changed to a new width, or
      until cancelled by the <command>set width column_or_alias;</command>
      command - no width supplied means use the default width setting for this
      column.</para>

      <para>The following example shows the width of the last_name column
      being amended. The first SELECT shows the default setting which is a
      wdith of 20 characters (count the '=' in the headings) which is the
      definition of the last_name column in the employee table. The second
      shows the width being reduced to 10 characters.</para>

      <screen>SQL&gt; select first 10 emp_no, last_name
CON&gt; from employee
CON&gt; order by last_name;

 EMP_NO LAST_NAME            
======= ==================== 
     34 Baldwin              
    105 Bender               
     28 Bennet               
     83 Bishop               
    109 Brown                


SQL&gt; set width last_name 10;

SQL&gt; select first 10 emp_no, last_name
CON&gt; from employee
CON&gt; order by last_name;

 EMP_NO LAST_NAME  
======= ========== 
     34 Baldwin    
    105 Bender     
     28 Bennet     
     83 Bishop     
    109 Brown      
</screen>

      <para>Emp_no is a smallint data type. Unfortunately, it doesn't appear
      to be possible to change the width on non-character columns like
      integer, smallint etc. The <command>set width emp_no 10;</command>
      command, for example, has no effect, as shown below, which also
      demonstrates turning off a previous width setting for the last_name
      column:</para>

      <screen>SQL&gt; set width last_name;

SQL&gt; set width emp_no 10;

SQL&gt; select first 10 emp_no, last_name
CON&gt; from employee
CON&gt; order by last_name;

 EMP_NO LAST_NAME            
======= ==================== 
     34 Baldwin              
    105 Bender               
     28 Bennet               
     83 Bishop               
    109 Brown                
</screen>
    </section>
  </section>

  <section id="isql-show">
    <title><application>Isql</application> Show commands</title>

    <para>As explained in the <command>help</command> command, there are a
    number of individual show commands within <application>isql</application>.
    The general format of the show commands is:</para>

    <para><command>SQL&gt; SHOW &lt;object&gt; [name] ;</command></para>

    <para>The object is always required and the name is required to display
    details of a specific object. Without a name, the commands will normally
    display all the objects of the requested type.</para>

    <para>Unfortunately, unlike the <command>set</command> commands, there is
    no handy drill down into the various <command>show</command> commands
    using the help command. However, if you type <command>show</command> on
    its own, you will be given a little more assistance.</para>

    <screen>SQL&gt; show;

Valid options are:
CHECKs                   COMMENTs                 COLLATEs                 
COLLATIONs               DOMAINs                  DB                       
DATABASE                 DEPENdency               DEPENdencies             
EXCEPtions               FILTERs                  FUNCtions                
GENerators               GRANTs                   INDexes                  
INDICES                  PROCedures               ROLEs                    
SYStem                   SEQuences                SECURITY CLAsses         
SECCLAsses               TABLEs                   TRIGgers                 
USERS                    VIEWs                    
Command error: show
</screen>

    <para>The upper case letters indocate what you must type as an absolute
    minimum.</para>

    <para>The show commands are detailed and described below. Where possible,
    examples from the employee database are shown.</para>

    <section>
      <title>Show Checks</title>

      <para><command>SQL&gt; SHOW CHECKs table_name;</command></para>

      <para>This command displays all user-defined check constraints defined
      for a specific table. Unlike other <command>show</command> commands,
      there is no option to display a list of all the check constraints in the
      database. You must always provide a table name as part of the
      command.</para>

      <screen>SQL&gt; show check employee;

CONSTRAINT INTEG_30:
  CHECK ( salary &gt;= (SELECT min_salary FROM job WHERE
                        job.job_code = employee.job_code AND
                        job.job_grade = employee.job_grade AND
                        job.job_country = employee.job_country) AND
            salary &lt;= (SELECT max_salary FROM job WHERE
                        job.job_code = employee.job_code AND
                        job.job_grade = employee.job_grade AND
                        job.job_country = employee.job_country))</screen>
    </section>

    <section>
      <title>Show Collations</title>

      <para><command>SQL&gt; SHOW {COLLATIONs | COLLATION
      name};</command></para>

      <para><command>SQL&gt; SHOW {COLLATEs | COLLATE name};</command></para>

      <para>These commands display a list of all the user defined collations
      in the current database. It is only available from Firebird 2.0 onwards.
      The first form of the commands display a list of all the collations
      while a specific collation may be displayed by providing the collation
      name.</para>

      <screen>SQL&gt; show collations;
UNICODE_ENUS_CI, CHARACTER SET UTF8, FROM EXTERNAL ('UNICODE'), PAD SPACE, 
CASE INSENSITIVE, 'COLL-VERSION=58.0.6.48'
UNICODE_ENUS_CS, CHARACTER SET UTF8, FROM EXTERNAL ('UNICODE'), PAD SPACE, 
'COLL-VERSION=58.0.6.48'

SQL&gt; show collation unicode_enus_ci;
UNICODE_ENUS_CI, CHARACTER SET UTF8, FROM EXTERNAL ('UNICODE'), PAD SPACE, 
CASE INSENSITIVE, 'COLL-VERSION=58.0.6.48'
</screen>

      <para>You can see from the output above, which is not part of the
      employee database, does appear to display all the relevant information
      in the first form of the command. There does not appear to be much
      reason to drill down into a specific collation - at least, not according
      to this example. Some lines in the above have had to be split over two
      to allow it to fit on the page.</para>
    </section>

    <section>
      <title>Show Comments</title>

      <para><command>SQL&gt; SHOW COMMENTs;</command></para>

      <para>This command displays all comments that have been created, on
      various objects, in the current database. There is no option to display
      a specific comment. Each comments is listed along with the object type
      and name, to whihc it has been applied.</para>

      <screen>SQL&gt; show comments;

COMMENT ON DATABASE IS This is the demonstration EMPLOYEE database.;
COMMENT ON TABLE EMPLOYEE IS The EMPLOYEE table has details of our employees.;</screen>

      <para>The actual comment text is shown between the word 'IS' and the
      trailing semicolon.</para>
    </section>

    <section>
      <title>Show Database</title>

      <para><command>SQL&gt; SHOW DATABASE;</command></para>

      <para><command>SQL&gt; SHOW DB;</command></para>

      <para>The <command>show database</command> (or <command>show
      db</command>) command displays details about the
      <emphasis>current</emphasis> database. The ODS version, shown in the
      following examples, is only displayed from Firebird version 2.0
      onwards.</para>

      <screen>SQL&gt; show database;

Database: employee
        Owner: SYSDBA                         
PAGE_SIZE 4096
Number of DB pages allocated = 270
Sweep interval = 20000
Forced Writes are ON
Transaction - oldest = 190
Transaction - oldest active = 191
Transaction - oldest snapshot = 191
Transaction - Next = 211
ODS = 11.2
Default Character set: NONE</screen>

      <para>No parameters, such as a specific database name, are required and
      if supplied, will be ignored. The details displayed will always be for
      the current database.</para>

      <screen>SQL&gt; show database testing_db;

Database: employee
        Owner: SYSDBA                         
PAGE_SIZE 4096
...
Default Character set: NONE</screen>

      <para>You will note from the above that the details displayed are still
      for the employee database.</para>
    </section>

    <section>
      <title>Show Dependencies</title>

      <para><command>SQL&gt; SHOW DEPENdencies object_name;</command></para>

      <para><command>SQL&gt; SHOW DEPENdency object_name;</command></para>

      <para>These commands display all dependencies for the specified object
      name supplied as a parameter. The object name supplied need not
      necessarily be a table name, it could be a function or procedure name, a
      sequence name etc.</para>

      <para>The output listed is a comma separated list of the other objects
      in the database <emphasis>upon which</emphasis> the supplied object is
      dependent. In other words, a procedure would fail to compile if any of
      the listed dependencies was to be removed, for example.</para>

      <screen>SQL&gt; show dependencies SET_CUST_NO;

        [SET_CUST_NO:Trigger]
CUSTOMER:Table&lt;-CUST_NO, CUST_NO_GEN:Generator
+++
</screen>

      <para>The listing above shows that SET_CUST_NO is a trigger and that it
      is dependent on two separate objects, the CUST_NO column of table
      CUSTOMER and the sequence/generator named CUST_NO_GEN. If you display
      the trigger itself, you will see both of those objects mentioned:</para>

      <screen>SQL&gt; show trigger set_cust_no;

Triggers on Table CUSTOMER:
SET_CUST_NO, Sequence: 0, Type: BEFORE INSERT, Active
AS
BEGIN
    if (new.cust_no is null) then
    new.cust_no = gen_id(cust_no_gen, 1);
END
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
</screen>

      <para>Sometimes, the output can be a little confusing. You may see
      various objects in the list that don't appear to be relevant. The
      RDB$DEPENDENCIES table, where the data comes from, also holds details of
      system objects upon which a given object will depend.</para>
    </section>

    <section>
      <title>Show Domains</title>

      <para><command>SQL&gt; SHOW {DOMAINs | DOMAIN name};</command></para>

      <para>This command displays domain information. A domain is a
      user-defined data type, global to the database. It is used to define the
      format and range of columns, upon which the actual column definitions in
      tables are based.</para>

      <para>Firebird tables are defined by the specification of columns, which
      store appropriate information in each column using data types.</para>

      <para>A data type is an elemental unit when defining data, which
      specifies the type of data stored in tables, and which operations may be
      performed on this data. It can also include permissible calculative
      operations and maximum data size. Examples of data types include:
      numerical (numeric, decimal, integer);textual (char, varchar, nchar,
      nvarchar); date (date, time, timestamp) and blobs(binary large
      objects).</para>

      <para>As with many <command>show</command> commands, there are two
      forms. The first displays a list of all known domains in the database
      while the second allows you to display the details of a specific
      domain.</para>

      <para><screen>SQL&gt; show domain;

       ADDRESSLINE                            BUDGET
       COUNTRYNAME                            CUSTNO
       DEPTNO                                 EMPNO
       FIRSTNAME                              JOBCODE
...

SQL&gt; show domain addressline;
ADDRESSLINE                     VARCHAR(30) Nullable</screen></para>
    </section>

    <section>
      <title>Show Exceptions</title>

      <para><command>SQL&gt; SHOW {EXCEPtions | EXCEPtion
      name};</command></para>

      <para>This command displays all the exceptions which have been defined
      in the current database. Details of the exception's error message and
      objects which use the exception - those which are dependant upon the
      exception - are also shown. You may display individual exception's
      details with the second for of the command.</para>

      <screen>SQL&gt; show exceptions;

Exception Name                  Used by, Type
=============================== =============================================
CUSTOMER_CHECK                  SHIP_ORDER, Stored procedure
Msg: Overdue balance -- can not ship.

CUSTOMER_ON_HOLD                SHIP_ORDER, Stored procedure
Msg: This customer is on hold.

...


SQL show exception customer_on_hold;

Exception Name                  Used by, Type
=============================== =============================================
CUSTOMER_ON_HOLD                SHIP_ORDER, Stored procedure
Msg: This customer is on hold.
</screen>
    </section>

    <section>
      <title>Show Filters</title>

      <para><command>SQL&gt; SHOW {FILTERs | FILTER name};</command></para>

      <para>This command displays a list of all known BLOB filters declared in
      the current database using the declare filter command. The second form
      of the command allows the full details of a specific filter to be
      displayed.</para>

      <screen>SQL&gt; show filter;

       FUNNEL  
       ...
     
                   
SQL&gt; show filter funnel;
BLOB Filter: FUNNEL 
        Input subtype: 2 Output subtype: 1
        Filter library is myfilterlib
        Entry point is blr2asc
</screen>
    </section>

    <section>
      <title>Show Functions</title>

      <para><command>SQL&gt; SHOW {FUNCtions | FUNCtion
      name};</command></para>

      <para>This command allows a list of all external functions declared in
      the current database, to be displayed. External functions are those
      defined and coded in various UDF libraries.</para>

      <para>The second form of the command allows the details of a specific
      function to be displayed.</para>

      <screen>SQL&gt; show functions;

       ADDDAY                                 ADDDAY2                        
       ADDHOUR                                ADDMILLISECOND                 
       ADDMINUTE                              ADDMONTH                       
       ADDSECOND                              ADDWEEK                        
       ADDYEAR


SQL&gt; show function addyear;

Function ADDYEAR:
Function library is fbudf
Entry point is addYear
Returns  TIMESTAMP
Argument 1: TIMESTAMP
Argument 2: INTEGER

</screen>
    </section>

    <section>
      <title>Show Generators</title>

      <para><command>SQL&gt; SHOW {GENERATORs | DOMAIN name};</command></para>

      <para><command>SQL&gt; SHOW {SEQuences | SEQuence
      name};</command></para>

      <para>These two commands are identical. Generators was the old Firebird
      term for what are more commonly known as sequences in other databases,
      as well as the ANSII Standards. You are encouraged to use sequences
      rather than generators but <application>isql</application> considers
      them to be the same.</para>

      <para>The first form of the commands above list all the sequences in the
      current database, while the second form displays details of a specific
      sequence.</para>

      <screen>SQL&gt; show sequences;

Generator CUST_NO_GEN, current value is 1015
Generator EMP_NO_GEN, current value is 145


SQL&gt; show sequence emp_no_gen;

Generator EMP_NO_GEN, current value is 145
</screen>
    </section>

    <section>
      <title>Show Grants</title>

      <para><command>SQL&gt; SHOW {GRANTs | GRANT {object_name |
      role_name}};</command></para>

      <para>This command displays a list of all grants in the current database
      if the first format of the command is used. The second drills down and
      displays only those details for the selected object, which may be a
      table, procedure, etc. Alternatively, if a role name is provided, only a
      list of users who have been granted that role will be displayed.</para>

      <screen>SQL&gt; show grants;

/* Grant permissions for this database */
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES 
ON COUNTRY TO PUBLIC WITH GRANT OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES 
ON CUSTOMER TO PUBLIC WITH GRANT OPTION
...
GRANT SELECT ON EMPLOYEE TO ROLE DEFAULT_USER
...
GRANT EXECUTE ON PROCEDURE ADD_EMP_PROJ TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE ALL_LANGS TO PUBLIC WITH GRANT OPTION
...


SQL&gt; show grants employee;

GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES 
ON EMPLOYEE TO PUBLIC WITH GRANT OPTION


SQL&gt; show grants ship_order;

GRANT EXECUTE ON PROCEDURE SHIP_ORDER TO PUBLIC WITH GRANT OPTION


SQL&gt; show grants default_user;

GRANT DEFAULT_USER TO SYSDBA
</screen>

      <para>Note that some lines in the above have been split to allow them to
      fit on the page.</para>
    </section>

    <section>
      <title>Show Indexes</title>

      <para><command>SQL&gt; SHOW {INDexes | INDICES};</command></para>

      <para><command>SQL&gt; SHOW {INDICES | INDexes}
      table_name;</command></para>

      <para><command>SQL&gt; SHOW INDex index_name;</command></para>

      <para>The first form of this command will list all the indexes in the
      current database. In this form, you may specify either
      <command>indexes</command> or <command>indices</command>, they are
      treated as identical by Firebird. The second form of the command will
      display the list of indices for a specific table as determined by the
      table_name parameter. Again, you may specify <command>indexes</command>
      or <command>indices</command>. The final form of the command displays
      details of a given index and in this form of the command, you must use
      the keyword <command>index</command>.</para>

      <screen>SQL&gt; show indices;

RDB$PRIMARY1 UNIQUE INDEX ON COUNTRY(COUNTRY) 
CUSTNAMEX INDEX ON CUSTOMER(CUSTOMER) 
...
SALESTATX INDEX ON SALES(ORDER_STATUS, PAID) 


SQL&gt; show indices employee;

NAMEX INDEX ON EMPLOYEE(LAST_NAME, FIRST_NAME) 
RDB$FOREIGN8 INDEX ON EMPLOYEE(DEPT_NO) 
RDB$FOREIGN9 INDEX ON EMPLOYEE(JOB_CODE, JOB_GRADE, JOB_COUNTRY) 
RDB$PRIMARY7 UNIQUE INDEX ON EMPLOYEE(EMP_NO) 


SQL&gt; show index namex;

NAMEX INDEX ON EMPLOYEE(LAST_NAME, FIRST_NAME)
</screen>
    </section>

    <section>
      <title>Show Procedures</title>

      <para><command>SQL&gt; SHOW {PROCedures | PROCedure
      name};</command></para>

      <para>This command allows a list of all procedures created in the
      current database, to be displayed. The second form of the command allows
      the details and source code to be shown for a specific procedure. See
      also the <command>show functions</command> and <command>show
      triggers</command> commands.</para>

      <screen>SQL&gt; show procedures;

Procedure Name                    Invalid Dependency, Type
================================= ======= =====================================
ADD_EMP_PROJ                              EMPLOYEE_PROJECT, Table
                                          UNKNOWN_EMP_ID, Exception
ALL_LANGS                                 JOB, Table
                                          SHOW_LANGS, Procedure
...


SQL&gt; show procedure all_langs;
Procedure text:
=============================================================================
    BEGIN
        FOR SELECT job_code, job_grade, job_country FROM job 
                INTO :code, :grade, :country

        DO
        BEGIN
            FOR SELECT languages FROM show_langs 
                    (:code, :grade, :country) INTO :lang DO
                SUSPEND;
            /* Put nice separators between rows */
            code = '=====';
            grade = '=====';
            country = '===============';
            lang = '==============';
            SUSPEND;
        END
    END
=============================================================================
Parameters:
CODE                              OUTPUT VARCHAR(5)
GRADE                             OUTPUT VARCHAR(5)
COUNTRY                           OUTPUT VARCHAR(15)
LANG                              OUTPUT VARCHAR(15)</screen>
    </section>

    <section>
      <title>Show Roles</title>

      <para><command>SQL&gt; SHOW {ROLEs | ROLE name};</command></para>

      <para>This command lists all the roles in the current database if the
      first form is used or, drills down to display a list of all the users
      who have been granted a specific role if the second form of the command
      is used.</para>

      <screen>SQL&gt; show roles;

       DEFAULT_USER      

              
SQL&gt; show role default_user;

Role DEFAULT_USER is granted to:

SYSDBA
</screen>
    </section>

    <section>
      <title>Show Secclasses</title>

      <para><command>SQL&gt; SHOW SECCLAsses object_name;</command></para>

      <para>This command displays details about the security classes for a
      given object. The object_name passed to the command need not be a table
      name, the command works for tables, procedures etc.</para>

      <screen>SQL&gt; show secclasses employee;

Table's main sec class SQL$7
Table's default sec class SQL$DEFAULT7
</screen>
    </section>

    <section>
      <title>Show Security Classes</title>

      <para><command>SQL&gt; SHOW SECURITY CLAsses name;</command></para>

      <para>This command always returns an error.</para>

      <screen>SQL&gt; show security classes;
Command error: show security classes

SQL&gt; show security classes employee;
Command error: show security_classes employee
</screen>
    </section>

    <section>
      <title>Show Sequences</title>

      <para>The Firebird specific name, <emphasis>generator</emphasis>, has
      been updated to match the ANSII standard term
      <emphasis>sequence</emphasis>. The <command>show sequences</command>
      command is identical to <command>show generators</command> (above) and
      the output is identical.</para>
    </section>

    <section>
      <title>Show SQL Dialect</title>

      <para><command>SQL&gt; SHOW SQL DIALECT;</command></para>

      <para>This command, which must be enetered in full, shows the current
      database's dialect as well as the dialect used by the currently
      connected client.</para>

      <screen>SQL&gt; show SQL Dialect;
        Client SQL dialect is set to: 3 and database SQL dialect is: 3</screen>
    </section>

    <section>
      <title>Show System</title>

      <para><command>SQL&gt; SHOW SYStem [tables];</command></para>

      <para>This command lists the internal, ie system, objects created and
      used in the current database. The optional parameter -
      <command>tables</command> - restricts the listing to show only tables.
      This applies from Firebird 2.0 onwards. Prior to version 2.0, the
      command would only list the system tables - equivalent to the
      <command>show system tables</command> command.</para>

      <para>If no parameter is passed, the listing will display tables,
      functions (internal as opposed to external ones) and collations.</para>

      <screen>SQL&gt; show system;
Tables:
       MON$ATTACHMENTS                        MON$CALL_STACK                 
...
       RDB$USER_PRIVILEGES                    RDB$VIEW_RELATIONS             

Functions:
       RDB$GET_CONTEXT                        RDB$SET_CONTEXT                

Collations:
       ASCII                                  BIG_5                          
...
       WIN1258                                WIN_CZ                         
       WIN_CZ_CI_AI                           WIN_PTBR</screen>

      <para>If you wish to drill down and display details of a specific
      object, simply use the corresponding <command>show</command>
      command.</para>

      <screen>SQL&gt; show table mon$io_stats;

MON$STAT_ID                     (RDB$STAT_ID) INTEGER Nullable 
MON$STAT_GROUP                  (RDB$STAT_GROUP) SMALLINT Nullable 
MON$PAGE_READS                  (RDB$COUNTER) BIGINT Nullable 
MON$PAGE_WRITES                 (RDB$COUNTER) BIGINT Nullable 
MON$PAGE_FETCHES                (RDB$COUNTER) BIGINT Nullable 
MON$PAGE_MARKS                  (RDB$COUNTER) BIGINT Nullable 


SQL&gt; show function rdb$get_context;

Function RDB$GET_CONTEXT:
Function library is system_module
Entry point is get_context
Returns  FREE_IT VARCHAR(255) CHARACTER SET NONE
Argument 1: NULL VARCHAR(80) CHARACTER SET NONE
Argument 2: NULL VARCHAR(80) CHARACTER SET NONE


SQL&gt; show collation ascii;

ASCII, CHARACTER SET ASCII, PAD SPACE, SYSTEM
</screen>

      <para>You will note that the <command>show function</command> command
      will display details of internal functions as well as those defined
      externally.</para>
    </section>

    <section>
      <title>Show Tables</title>

      <para><command>SQL&gt; SHOW {TABLEs | TABLE name};</command></para>

      <para>This command lists the user defined tables in the database if the
      first form of the command is used, or displays the columns and data
      types or domains making up the table if the second form is used with a
      table name supplied as a parameter.</para>

      <screen>SQL&gt; show tables;

       COUNTRY                                CUSTOMER                       
       DEPARTMENT                             EMPLOYEE                       
       EMPLOYEE_PROJECT                       JOB                            
       PROJECT                                PROJ_DEPT_BUDGET               
       SALARY_HISTORY                         SALES                          


SQL&gt; show table country;

COUNTRY                         (COUNTRYNAME) VARCHAR(15) Not Null 
CURRENCY                        VARCHAR(10) Not Null 
CONSTRAINT INTEG_2:
  Primary key (COUNTRY)</screen>

      <para>You will note that if there are comments defined for a table, this
      command will <emphasis>not</emphasis> display them. You must use the
      show comments command but be aware that you will then be given all
      comments in the database. There doesn't appear to be a method of
      extracting the comments for a single object, unless you query the system
      tables directly.</para>

      <screen>SQL&gt; comment on table country is 'This table holds details about countries.';
SQL&gt; commit;


SQL&gt; show comments;
...
COMMENT ON TABLE COUNTRY IS This table holds details about countries.;
...

SQL&gt; show table country;
COUNTRY                         (COUNTRYNAME) VARCHAR(15) Not Null 
CURRENCY                        VARCHAR(10) Not Null 
CONSTRAINT INTEG_2:
  Primary key (COUNTRY)

SQL&gt; select rdb$description
CON&gt; from rdb$relations
CON&gt; where rdb$relation_name = 'COUNTRY';

  RDB$DESCRIPTION 
================= 
            6:1e7 
==============================================================================
RDB$DESCRIPTION:  
This is a table holding details about countries.
==============================================================================
</screen>

      <para>The output from the final query above is not ideal, but at least
      it's much less displayed information when there are lots of comments in
      your database.</para>
    </section>

    <section>
      <title>Show Triggers</title>

      <para><command>SQL&gt; SHOW {TRIGgers | TRIGger name};</command></para>

      <para>This command allows a list of all triggers created in the current
      database, to be displayed. The second form of the command allows the
      details and source code to be shown for a specific trigger. See also the
      <command>show procedures</command> and <command>show functions</command>
      commands.</para>

      <screen>SQL&gt; show triggers;

Table name                       Trigger name                     Invalid
================================ ================================ =======
CUSTOMER                         SET_CUST_NO                             
EMPLOYEE                         SAVE_SALARY_CHANGE                      
EMPLOYEE                         SET_EMP_NO                              
SALES                            POST_NEW_ORDER


SQL&gt; show trigger set_cust_no;

Triggers on Table CUSTOMER:
SET_CUST_NO, Sequence: 0, Type: BEFORE INSERT, Active
AS
BEGIN
    if (new.cust_no is null) then
    new.cust_no = gen_id(cust_no_gen, 1);
END
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
</screen>
    </section>

    <section>
      <title>Show Version</title>

      <para><command>SQL&gt; SHOW VERsion;</command></para>

      <para>This command displays details about the Firebird software, your
      database and the on disc structure (ODS) in use.</para>

      <screen>SQL&gt; show version;

ISQL Version: LI-V2.5.1.26351 Firebird 2.5
Server version:
Firebird/linux AMD64 (access method), 
version "LI-V2.5.1.26351 Firebird 2.5"
Firebird/linux AMD64 (remote server), 
version "LI-V2.5.1.26351 Firebird 2.5/tcp (hubble)/P12"
Firebird/linux AMD64 (remote interface), 
version "LI-V2.5.1.26351 Firebird 2.5/tcp (hubble)/P12"
on disk structure version 11.2</screen>

      <para>The above output has been adjusted to fit on the page. Each pair
      of lines beginning with 'Firebird' and 'version' are normally displayed
      as a single line. They are split over two lines here.</para>
    </section>

    <section>
      <title>Show Users</title>

      <para><command>SQL&gt; SHOW USERS;</command></para>

      <para>This command shows a list of users who are currently connected to
      the database. If a user is logged in on more than one session, all
      sessions will be displayed separately.</para>

      <screen>SQL&gt; show users;

Users in the database
# SYSDBA                               # SYSDBA
# NORMAN</screen>
    </section>

    <section>
      <title>Show Views</title>

      <para><command>SQL&gt; SHOW {VIEWs | VIEW name};</command></para>

      <para>The first form of this command displays a list of all views in the
      current database. Drilling down using the second form of the command
      will display the columns and source code for a specific view.</para>

      <screen>SQL&gt; show views;

       PHONE_LIST                      


SQL&gt; show view phone_list;

EMP_NO                          (EMPNO) SMALLINT Not Null 
FIRST_NAME                      (FIRSTNAME) VARCHAR(15) Not Null 
LAST_NAME                       (LASTNAME) VARCHAR(20) Not Null 
PHONE_EXT                       VARCHAR(4) Nullable 
LOCATION                        VARCHAR(15) Nullable 
PHONE_NO                        (PHONENUMBER) VARCHAR(20) Nullable 
View Source:
==== ======
 SELECT
    emp_no, first_name, last_name, phone_ext, location, phone_no
    FROM employee, department
    WHERE employee.dept_no = department.dept_no</screen>
    </section>
  </section>

  <appendix id="isql-dochist">
    <title>Document History</title>

    <para>The exact file history is recorded in the <filename
    class="directory">manual</filename> module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink>.
    The full URL of the CVS log for this file can be found at <ulink
    url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_isql.xml?view=log">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_isql.xml?view=log</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>December 2006</date>

          <authorinitials>KV</authorinitials>

          <revdescription>
            <para>First version by Kamala Vadlamani.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>5 July 2008</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Changed title to <citetitle><application>Isql</application>
            - Firebird Interactive SQL Utility</citetitle> to bring it in line
            with the other manuals. Added <sgmltag
            class="element">titleabbrev</sgmltag> and edition info. Moved
            <citetitle>Audience</citetitle> and <citetitle>Version</citetitle>
            sections into <citetitle>Introduction</citetitle>. Removed
            <citetitle>Related Documentation</citetitle> section. Fixed typos,
            interpunction (still more to do here). Replaced most <sgmltag
            class="element">emphasis</sgmltag>es and all <sgmltag
            class="element">citetitle</sgmltag>s with more appropriate tags.
            Gave IDs to manual and all (sub)sections. Added manual History and
            License Notice.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.3</revnumber>

          <date>20 October 2009</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Converted from a chapter in the <citetitle>Command Line
            Utilities</citetitle> manual to stand alone manual in its own
            right.</para>

            <para>Changed title to <citetitle>Firebird Interactive SQL
            Utility</citetitle> to bring it in line with the other utility
            manuals.</para>

            <para>Many other updates to bring this manual into line with the
            others and to incorporate Firebird 2 changes etc.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.4</revnumber>

          <date>15 February 2012</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>General tidy up. Changes to formatting. Corrected some
            Docbook "misuse". Spelling &amp; punctuation corrections. Lists
            compacted. Corrected &lt;screen&gt; overflow in pdf rendering.
            Etc.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.5</revnumber>

          <date>10 April 2012</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>More tidying up. Plus:</para>

            <itemizedlist spacing="compact">
              <listitem>
                <para><command>Show</command> commands removed to a <link
                linkend="isql-show">separate section</link>.</para>
              </listitem>

              <listitem>
                <para><command>Set</command> commands moved to a <link
                linkend="isql-set">separate section</link>.</para>
              </listitem>

              <listitem>
                <para>The <link linkend="isql-switches">Command Line
                Switches</link> section relocated to a better place.</para>
              </listitem>

              <listitem>
                <para>The section <link linkend="isql-end-session">Ending an
                Isql Session</link> was relocated to a better place.</para>
              </listitem>
            </itemizedlist>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="isql-license">
    <title>License Notice</title>

    <para>The contents of this Documentation are subject to the Public
    Documentation License Version 1.0 (the <quote>License</quote>); you may
    only use this Documentation if you comply with the terms of this License.
    Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>The Original Documentation is titled <citetitle>Firebird Interactive
    SQL Utility</citetitle>.</para>

    <para>The Initial Writer of the Original Documentation is: Kamala
    Vadlamani.</para>

    <para>Copyright (C) 2006. All Rights Reserved. Initial Writer contact:
    kamala dot vadlamani at gmail dot com.</para>

    <para>Contributor: Paul Vinkenoog - see <link
    linkend="isql-dochist">Document history</link>.</para>

    <para>Portions created by Paul Vinkenoog are Copyright (C) 2008. All
    Rights Reserved. Contributor contact: paul at vinkenoog dot nl.</para>

    <para>Contributor: Norman Dunbar - see <link
    linkend="isql-dochist">Document history</link>.</para>

    <para>Portions created by Norman Dunbar are Copyright (C) 2009, 2011-2013.
    All Rights Reserved. Contributor contact: NormanDunbar at users dot
    sourceforge dot net.</para>
  </appendix>
</article>
