<?xml version="1.0" encoding="UTF-8"?>
<!-- For standalone validation, uncomment the following DOCTYPE declaration. -->
<!-- DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"> "file:../docs/docbookx/docbookx.dtd" -->
<article id="qsg2">
  <articleinfo>
    <title>The ISQL Commandline Utility</title>

    <author>
      <surname>Kamala Vadlamani</surname>
    </author>

    <date>December 2006</date>
  </articleinfo>

  <section id="qsg2-about">
    <title>Introduction</title>

    <para>This chapter provides reference material for the Firebird <application>Interactive SQL
    Utility (<citetitle>ISQL</citetitle>) ,</application>and instructions on how to use it to
    perform tasks within the database.</para>
  </section>

  <section>
    <title>Audience</title>

    <para>This chapter assumes prior knowledge of basic database concepts.</para>
  </section>

  <section>
    <title>Version</title>

    <para>This chapter describes the <citetitle>ISQL</citetitle> utility in Firebird version 1.5 and
    higher.</para>
  </section>

  <section>
    <title>Related Documentation</title>

    <para>This chapter provides information on functions and statements specific to
    <citetitle>ISQL.</citetitle> See the table below for references to documentation on SQL
    statements that can be issued in other environments.</para>

    <table>
      <title>Related Documentation</title>

      <tgroup cols="2">
        <colspec align="center" />

        <tbody>
          <row>
            <entry>Using Firebird</entry>

            <entry>Comes on a CD along with your Firebird installation CDs</entry>
          </row>

          <row>
            <entry>Firebird Reference Book</entry>

            <entry>Comes on a CD along with your Firebird installation CD</entry>
          </row>

          <row>
            <entry>Firebird Quick Start Guide</entry>

            <entry>Available from <ulink url="???">http://www.firebirdsql.org</ulink></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section>
    <title>Overview</title>

    <para>The <citetitle>ISQL</citetitle> utility , is a text-mode client tool located in the /bin
    directory of the Firebird installation.It provides a commandline interface for interactive
    access to a Firebird database. It accepts DSQL statements along with a group of SET and SHOW
    commands to query and interact with the Firebird database.Some SET commands can be incorporated
    in DDL scripts to perform batch executions within <citetitle>ISQL.</citetitle>It also accepts
    DDL , DML and console commands.</para>

    <para>The<citetitle> ISQL</citetitle> utility can be used in three modes:as an interactive
    session;directly from the commandline; and as a non-interative session, using a shell script or
    batch file. Different tasks may be performed in each of the modes, as illustrated below:</para>

    <itemizedlist>
      <listitem>
        <para>An interactive session can be invoked from the command-line of the operating system
        shell, and lasts until the session is terminated,using a QUIT or EXIT command.
        <emphasis>ISQL</emphasis> can be used interactively to:</para>

        <itemizedlist>
          <listitem>
            <para>Create, update, query, and drop data and metadata.</para>
          </listitem>

          <listitem>
            <para>Input a script file containing a batch of SQL statements in sequence without
            prompting.</para>
          </listitem>

          <listitem>
            <para>Add and modify data.</para>
          </listitem>

          <listitem>
            <para>Grant user permissions.</para>
          </listitem>

          <listitem>
            <para>Perform database administrative functions.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Directly from the commandline,with individual options, without starting an interactive
        session.Commands execute, and upon completion, return control automatically to the operating
        system.</para>
      </listitem>

      <listitem>
        <para>In a non-interactive session, the user employs a shell script or batch file to perform
        database functions.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Always run the Firebird <application> utility</application> from its own directory ,or
      provide the absolute file path if you have another relational database, besides Firebird
      ,installed on your machine.</para>
    </note>
  </section>

  <section>
    <title>Invoking <emphasis>ISQL</emphasis></title>

    <para>Go to the <filename class="directory">bin</filename> subdirectory of your Firebird
    installation and type <command>isql</command> (Windows) or <command>./isql</command> (Linux) at
    the command prompt.</para>

    <para>Example:</para>

    <para><screen>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql 
Use CONNECT or CREATE DATABASE to specify a database
SQL&gt; CONNECT "C:\PROGRAM FILES\FIREBIRD\FIREBIRD_2_0\EXAMPLES\EMPBUILD\EMPLOYEE. FDB" 
CON&gt; user 'SYSDBA' password 'masterkey';</screen></para>
  </section>

  <section>
    <title>Starting an <emphasis>ISQL </emphasis>Session</title>

    <para>To begin an <application><emphasis>IS</emphasis></application><emphasis>QL</emphasis>
    session, enter the command-line options and the name of the database in the Linux /Unix shell or
    Windows command console. For example:</para>

    <para><userinput>isql [options] [database_name]</userinput></para>

    <note>
      <para>When invoking <application><emphasis>ISQL</emphasis></application>, you will need to
      include an appropriate <parameter>-user</parameter> and <parameter>-password</parameter> in
      your options,unless users have the <envar>ISC_USER</envar> and <envar>ISC_PASSWORD</envar>
      declared as operating system variables.For e.g. <command>isql -user SYSDBA -password
      masterkey</command></para>
    </note>

    <para><emphasis>ISQL</emphasis> starts an interactive session if no options are specified.If no
    database is specified, users must connect to an existing database or create a new one after
    starting <emphasis>ISQL</emphasis>. It starts the interactive session by connecting to the named
    database, provided the login options are accurate and valid for the specified database.Depending
    on the options specified, <emphasis>I</emphasis><emphasis>SQL</emphasis> starts an interactive
    or noninteractive session.</para>

    <para>Reading an input file and writing to an output file are not considered interactive tasks,
    therefore the <parameter>-input</parameter> or <parameter>-output</parameter> command-line
    options do not initiate an interactive session. Options used to extract DDL statements, such as
    <parameter>-a</parameter> and <parameter>-x</parameter> also only initiate a non-interactive
    session.</para>

    <para><emphasis>ISQL</emphasis> can be run from either a local or remote client:</para>

    <itemizedlist>
      <listitem>
        <para>When connecting using a local client, make sure to set the environmental variables
        ISC_USER and ISC_PASSWORD. For more information on these, see below.</para>
      </listitem>

      <listitem>
        <para>When connecting from a remote client, you will need a valid name and password.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Connecting to a database</title>

    <para>A sample database named <filename>employee.fdb</filename> is located in the <filename
    class="directory">examples/empbuild</filename> subdirectory of your Firebird installation. Users
    can use this database to experiment with Firebird.</para>

    <para>It is possible to connect to a database using
    <emphasis>I</emphasis><emphasis>SQL</emphasis>in two ways:locally and remotely.</para>

    <itemizedlist>
      <listitem>
        <para>On Windows XP, use the CONNECT statement with the full file path:</para>

        <para><userinput>CONNECT "C:\PROGRAM FILES\FIREBIRD\FIREBIRD_2_0\EXAMPLES\EMPBUILD\EMPLOYEE.
        FDB"</userinput></para>
      </listitem>

      <listitem>
        <para>If connecting remotely ( using TCP/IP) , use the <database>CONNECT</database>
        statement with the server name and complete filepath of the database. Remember to make sure
        that the server host name is separated from the database path with a colon.</para>

        <para>To connect to a database on a Linux/UNIX server named cosmos:</para>

        <para><userinput>SQL&gt;
        CONNECT'cosmos:/usr/firebird/examples/employee.gdb';</userinput></para>

        <para>To connect to a database on a Windows server named cosmos:</para>

        <para><userinput>SQL&gt; CONNECT'cosmos:"C:\PROGRAM
        FILES\FIREBIRD\FIREBIRD_2_0\EXAMPLES\EMPBUILD\EMPLOYEE. FDB"</userinput></para>
      </listitem>
    </itemizedlist>

    <note>
      <para>Firebird is slash agnostic and automatically converts either type of slash to suit the
      relevant operating system.</para>
    </note>
  </section>

  <section>
    <title>Creating a database</title>

    <para>To create a database interactively using the
    <emphasis><application>ISQL</application></emphasis> command shell, get to a command prompt in
    Firebird's <filename class="directory">bin</filename> subdirectory and type
    <command>isql</command> (Windows) or <command>./isql</command> (Linux):</para>

    <para><userinput>C:\Program Files\Firebird\Firebird_2_0\bin&gt;isql↵ Use CONNECT or CREATE
    DATABASE to specify a database</userinput></para>

    <para>To create a database named <filename>monkey.fdb</filename> and store it in a directory
    named <filename class="directory">test</filename> on your <systemitem class="filesystem">C
    </systemitem>drive:</para>

    <para><userinput>SQL&gt;CREATE DATABASE 'C:\test\monkey.fdb' page_size 8192↵ CON&gt;user
    'SYSDBA' password 'masterkey';↵</userinput></para>

    <note>
      <para>In the <database>CREATE DATABASE</database> statement it is
      <emphasis>mandatory</emphasis> to place quote characters (single or double) around path,
      username and password.</para>

      <para>When running Classic Server on Linux , if the database is not started with a hostname,
      the database file will be created with the linux login name as the owner. This may cause
      access rights to others who may want to connect at a later stage. By prepending the
      <systemitem class="systemname">localhost:</systemitem> to the path, the server process ,with
      Firebird 2.0 running as user <systemitem class="username">firebird</systemitem>, will create
      and own the file.</para>
    </note>

    <para>To test the newly created database type:</para>

    <para><userinput>SQL&gt;SELECT * FROM RDB$monkey;↵</userinput></para>

    <para>To get back to the command prompt type <literal>QUIT</literal> or
    <literal>EXIT</literal>.</para>

    <note>
      <para>The above technique,as demonstrated, works, but ideally metadata objects should be
      created and maintained using data definition scripts.</para>
    </note>
  </section>

  <section>
    <title>Setting the ISC_USER and ISC_PASSWORD environment variables</title>

    <para>An environment variable is a named object that contains information used by one or more
    applications.They are global to their specific Operating Systems.The Firebird server recognizes
    and uses certain environment variables configured in Windows, Linux and many Unix
    systems.</para>

    <para>The ISC_USER and ISC_PASSWORD environment variables in Firebird are designed to give
    SYSDBA access to the database from the commandline utilities and client applications to anyone
    who has access to a host machine.</para>

    <caution>
      <para>When running command-line utilities like isql,gbak,gstat, and gfix, Firebird will search
      to see if the ISC_USER and ISC_PASSWORD environment variables are set. If you do not provide a
      username and password while connecting to a database locally,Firebird will let you log in
      without a password. So for security reasons make sure to configure the variables.</para>
    </caution>

    <para>The ISC_USER and ISC_PASSWORD environment variables need to be set in order to start
    <emphasis>ISQL</emphasis> locally. To set the environment variables:</para>

    <itemizedlist>
      <listitem>
        <para>In Windows 2000 / XP ,this is done in the Control Panel -&gt; System -&gt; Advance
        -&gt; Environment Variables.</para>
      </listitem>

      <listitem>
        <para>In Linux and Unix platforms, this depends on the type of shell being used and how the
        desktop is configured. Please refer to your Operating System documentation to set
        environmental variables.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Dialects</title>

    <para>Firebird supports three SQL dialects in each client and database server. These SQL
    dialects are differentiated in the context of the date-time format and the precision of a
    numerical data type. The dialects serve to instruct the Firebird server on how to process
    features implemented in legacy Borland Interbase databases, earlier than version 6.0. Dialects
    are set up at runtime and can be changed for the client at connection time or with a SET SQL
    dialect command. The following table illustrates the differences between the dialects.</para>

    <table>
      <title>SQL Dialects</title>

      <tgroup cols="4">
        <thead>
          <row>
            <entry>SQL</entry>

            <entry>Dialect 1</entry>

            <entry>Dialect 2</entry>

            <entry>Dialect 3</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Date</entry>

            <entry>Date &amp; Time (Timestamp)</entry>

            <entry>ERROR Message</entry>

            <entry>Date only</entry>
          </row>

          <row>
            <entry>Time Stamp</entry>

            <entry>Timestamp (v.6.x only)</entry>

            <entry>Timestamp</entry>

            <entry>Timestamp</entry>
          </row>

          <row>
            <entry>Time</entry>

            <entry>Error message</entry>

            <entry>Error message</entry>

            <entry>Time only</entry>
          </row>

          <row>
            <entry>&lt;"quoted item"&gt;</entry>

            <entry>String</entry>

            <entry>Error message</entry>

            <entry>Symbol only</entry>
          </row>

          <row>
            <entry>Precision: 1/3 =</entry>

            <entry>0.3333333... (double precision)</entry>

            <entry>0</entry>

            <entry>0</entry>
          </row>

          <row>
            <entry>Numeric 11</entry>

            <entry>double precision</entry>

            <entry>64 bit int</entry>

            <entry>64 bit int</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <note>
      <para>Currently it is possible to create databases in Dialect 1 and 3 only, however it is
      recommended that you use Dialect 3 exclusively,since Dialect 1 will eventually be deprecated.
      Dialect 2 cannot be used to create a database since it only serves to convert Dialect 1 to
      Dialect 3.</para>
    </note>

    <para>When connecting to a database using <emphasis>ISQL</emphasis>, the utility takes on the
    dialect of the database,unless you specify otherwise. Dialects cannot be set as a parameter of a
    CREATE DATABASE statement.So,when creating a database using <emphasis>ISQL</emphasis>, the
    database will be in the dialect that is current in <emphasis>ISQL</emphasis> at the time the
    CREATE DATABASE statement is issued. You may set the dialect using the <emphasis>ISQL</emphasis>
    utility in two ways:</para>

    <itemizedlist>
      <listitem>
        <para>When you start <emphasis>ISQL</emphasis> type:</para>

        <para><filename><userinput>bin] isql -s n</userinput>(where n refers to the dialect
        number)</filename></para>
      </listitem>
    </itemizedlist>

    <itemizedlist>
      <listitem>
        <para>Within a SQL script or <emphasis>ISQL</emphasis> session, type:</para>

        <para><userinput>SET SQL DIALECT n;</userinput>(where n refers to the dialect number)</para>

        <para>Before Firebird 2.0 when <emphasis>ISQL</emphasis> disconnected from a database,
        either by dropping it or by trying to connect to a non-existent database, it remembered the
        SQL dialect of the previous connection, which lead to some inappropriate warning messages.
        This has been fixed in 2.0</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Terminator Character</title>

    <para>The default terminator symbol for the Firebird database is the semicolon. Statements will
    only be executed if they end with a semicolon (;). However,you may use <emphasis>ISQL</emphasis>
    to change the symbol to any printable character from the first 127 characters of the ASCII
    subset,by using the SET TERM command.</para>

    <note>
      <para>The default terminator maybe changed in all instances except in the case of<emphasis>
      procedure language statements</emphasis> or PSQL. PSQL does not accept any terminator other
      than a semicolon.</para>
    </note>

    <para>To change the terminator character using <emphasis>ISQL</emphasis>, enter the following
    code:</para>

    <para><filename><code><userinput>SQL&gt;SET TERM
    &lt;string&gt;;</userinput></code></filename></para>

    <formalpara>
      <title>The Con prompt</title>

      <para>The CON&gt; or Continuation prompt is displayed if users press ENTER without ending a
      SQL statement with a terminator (;). For example:</para>
    </formalpara>

    <screen>SQL&gt; HELP
CON&gt;</screen>
  </section>

  <section>
    <title>Error Handling and Exception Support</title>

    <para>Exception handling is a programming construct designed to handle an occurence that
    disrupts the normal execution of a program. These are called errors. Exceptions are user-defined
    named error messages, written specifically for a database and stored in that database for use in
    stored procedures and triggers.</para>

    <para>For example, If it is ascertained in a trigger that the value in a table is incorrect, the
    exception is fired. This leads to a rollback of the total transaction that the client
    application is attempting to commit. Exceptions can be interleaved, and shared among the
    different modules of an application, and even among different applications sharing a database.
    They provide a simple way to standardize the handling of preprogrammed input errors.</para>

    <para>Exceptions are database objects, like Tables, Views and Domains,and are part of the
    database's metadata. They can be created, modified and dropped like all other Firebird objects
    using <emphasis>ISQL</emphasis>.</para>

    <para>In <emphasis>ISQL</emphasis> , error messages comprise the <database>SQLCODE</database>
    variable and the Firebird status array. The following table provides some examples:</para>

    <table frame="all">
      <title>ISQL error codes and messages</title>

      <tgroup cols="3">
        <colspec colname="col1" />

        <colspec colname="col2" colwidth="2*" />

        <colspec colname="col3" colwidth="5*" />

        <thead>
          <row>
            <entry><para>SQLCODE</para></entry>

            <entry><para>Message</para></entry>

            <entry><para>Meaning</para></entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><para>&lt;0</para></entry>

            <entry><para>SQLERROR</para></entry>

            <entry><para>Error occurred: statement did not execute</para></entry>
          </row>

          <row>
            <entry><para>0</para></entry>

            <entry><para>SUCCESS</para></entry>

            <entry><para>Successful execution</para></entry>
          </row>

          <row>
            <entry><para>+1--99</para></entry>

            <entry><para>SQLWARNING</para></entry>

            <entry><para>System warning or information message</para></entry>
          </row>

          <row>
            <entry><para>+100</para></entry>

            <entry><para>NOT FOUND</para></entry>

            <entry><para>No qualifying rows found, or end of current active set of rows
            reached</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section>
    <title>Transaction Handling</title>

    <para>The Firebird architecture allows high transaction concurrency. Transaction savepoints
    (nested transactions) are also supported. All Firebird transactions are ACID compliant. ACID is
    explained below:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Atomicity</emphasis> ensures that transactions either execute in their
        entirety or not execute at all, even if the system fails halfway through the process.</para>
      </listitem>

      <listitem>
        <para><emphasis>Consistency</emphasis> ensures that only valid data will be written to the
        database. If a transaction is executed that violates the database’s consistency rules, the
        entire transaction will be rolled back and the database will be restored to a state
        consistent with those rules. if a transaction successfully executes, it will take the
        database from one state that is consistent with the rules to another state that is also
        consistent with the rules, without necessarily preserving consistency at all intermediate
        levels.</para>
      </listitem>

      <listitem>
        <para><emphasis>Isolation</emphasis> ensures that transactions are isolated from one
        another, even if several transactions are running concurrently. Concurrency refers to a
        state within the database where two or more tasks are running simultaneously.This way, a
        transaction's updates are concealed from the rest until that transaction commits.
        Transactions in Firebird are isolated within separate contexts defined by client
        applications passing transaction parameters.</para>
      </listitem>

      <listitem>
        <para><emphasis>Durability</emphasis> ensures that once a transaction commits, its updates
        survive within the database, even if there is a subsequent system crash.</para>
      </listitem>
    </itemizedlist>

    <para>There are several parameters available to configure transactions in order to ensure
    consistency within the database. These parameters invoke the concept of concurrency. To ensure
    data integrity, there are four configurable parameters affecting concurrency: isolation level;
    lock resolution mode; access mode; and table reservation.</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Isolation Level:</emphasis> A transaction isolation level defines the
        interaction and visibility of work performed by simultaneously running transactions.There
        are four transaction isolation levels according to the SQL standard:<itemizedlist>
            <listitem>
              <para>READ COMMITTED: A transaction sees only data committed before the statement has
              been executed.</para>
            </listitem>

            <listitem>
              <para>READ UNCOMMITTED:A transaction sees changes done by uncommitted
              transactions.</para>
            </listitem>

            <listitem>
              <para>REPEATABLE READ:A transaction sees during its lifetime only data committed
              before the transaction has been started.</para>
            </listitem>

            <listitem>
              <para>SERIALIZABLE:This is the strictest isolation level, which enforces transaction
              serialization. Data accessed in the context of a serializable transaction cannot be
              accessed by any other transaction.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>

    <para>In <emphasis>ISQL</emphasis> ,a transaction is begun as soon as the utility is started
    .The transaction is begun in <emphasis>SNAPSHOT</emphasis> isolation,with a lock resolution set
    to <emphasis>WAIT</emphasis>.Since the Firebird <emphasis>ISQL</emphasis> utility accepts DDL,
    DML and other commands, transactions are handled accordingly,in the following ways:</para>

    <itemizedlist>
      <listitem>
        <para>DDL statements are committed automatically when issued at the SQL prompt in two
        ways:<itemizedlist>
            <listitem>
              <para>When <emphasis>COMMIT</emphasis> statements are included in the script.</para>
            </listitem>

            <listitem>
              <para>By ensuring the automatic commit of DDL in a <emphasis>ISQL</emphasis> script,by
              issuing a <filename>SET AUTODLL ON;</filename> statement. To turn it off, issue a
              <filename>SET AUTODLL OFF;</filename> statement at the <emphasis>ISQL</emphasis>
              prompt.</para>
            </listitem>
          </itemizedlist></para>
      </listitem>

      <listitem>
        <para>DML statements are not committed automatically. You must issue a
        <emphasis>COMMIT</emphasis>statement to commit any DML changes to the database.</para>
      </listitem>

      <listitem>
        <para>You can use <emphasis>SHOW</emphasis> commands in <emphasis>ISQL</emphasis> to query
        database metatdata. Metatdata is stored in system tables. When a <emphasis>SHOW</emphasis>
        command is issued, <emphasis>ISQL</emphasis> commits the current transaction and begins a
        new one, in <emphasis>READ COMMITTED</emphasis> isolation. This ensures that users will view
        the most current state of the database.</para>
      </listitem>
    </itemizedlist>

    <para>Users can specify the access mode and level of isolation for the next transaction ,and
    explicitly commit the current transaction by using the <emphasis>SET TRANSACTION</emphasis>
    statement. <emphasis>SET TRANSACTION</emphasis> can be executed only when there is no other
    transaction being processed. It does not by itself initiate a transaction.Here is the syntax
    :</para>

    <para><filename><userinput>SQL&gt; SET TRANSACTION;</userinput></filename></para>

    <para>In Firebird 2.0 the SET TRANSACTION statement has been enhanced to support all Transaction
    Parameter Buffer(TPB)options.These include:</para>

    <itemizedlist>
      <listitem>
        <para>NO AUTO UNDONE</para>
      </listitem>

      <listitem>
        <para>IGNORE LIMBO</para>
      </listitem>

      <listitem>
        <para>LOCK TIMEOUT &lt;number&gt;</para>
      </listitem>
    </itemizedlist>

    <para>Example:</para>

    <para><filename><userinput>SET TRANSACTION WAIT SNAPSHOT NO AUTO UNDONE LOCK TIMEOUT
    10;</userinput></filename></para>
  </section>

  <section>
    <title>Script Handling</title>

    <para>A batch of DDL or DML statements in a text file is known as a script. Scripts can be used
    to create and alter database objects. These are referred to as data definition files or DDL
    scripts. Scipts that manipulate data by inserting, updating or performing data conversions, are
    called DML scripts,because they use commands described in the Data Manipulation
    Language(DML).</para>

    <para>One of the most important tasks handled by <emphasis>ISQL</emphasis> is to process
    scripts. It can handle both DDL and DML Scripts,but they should be included in separate scripts
    to avoid data integrity problems.This script processing feature of <emphasis>ISQL</emphasis>
    allows the linking of one script to another using the <emphasis>ISQL</emphasis> INPUT
    &lt;filespec&gt;. Scripts statements are executed in order. The default setting in
    <emphasis>ISQL</emphasis> for the AUTODDL is set to ON.You may use the SET AUTODDL command to
    control where or when statements will be committed.</para>

    <para>The <emphasis>ISQL</emphasis> utility processes scripts in two ways: directly at the
    commandline, or through a tool that processes <emphasis>ISQL</emphasis> scripts. At the
    commandline you may create a script using the OUTPUT command or run scripts created in
    <emphasis>ISQL</emphasis> in another text editor using the INPUT command.</para>
  </section>

  <section>
    <title>Using <emphasis>ISQL</emphasis> interactively</title>

    <para>The Firebird <emphasis>ISQL</emphasis> utility can be used interactively to:</para>

    <itemizedlist>
      <listitem>
        <para>Create, update, query, and drop data and metadata.</para>
      </listitem>

      <listitem>
        <para>Add and modify data.</para>
      </listitem>

      <listitem>
        <para>Test queries.</para>
      </listitem>

      <listitem>
        <para>Perform database administrative functions.</para>
      </listitem>

      <listitem>
        <para>Input a script file containing a batch of SQL statements in sequence without
        prompting.</para>
      </listitem>
    </itemizedlist>

    <para>To perform these functions, <emphasis>ISQL</emphasis> accepts three kinds of commands at
    the prompt:</para>

    <itemizedlist>
      <listitem>
        <para>DDL statements: Data Definition Language statements are used to define database
        schema. DDL supports the definition or declaration of database objects. Examples of DDL
        commands include: CREATE, ALTER,RECREATE and DROP.</para>
      </listitem>

      <listitem>
        <para>DML statements: Data Manipulation Language statements allow the user to manipulate
        data objects and relationships between them,in the context of given database schemas. DML
        supports the manipulation and processing of database objects. Examples of DML statements
        are:INSERT, UPDATE AND DELETE.</para>
      </listitem>

      <listitem>
        <para><emphasis>ISQL</emphasis> commands:<itemizedlist>
            <listitem>
              <para>Commands that perform general tasks, such as processing scripts and executing
              shell commands. These commands are: INPUT, OUTPUT, QUIT, SHELL, BLOBDUMP, BLOBVIEW,
              HELP, EDIT, ADD, COPY and EXIT.<itemizedlist>
                  <listitem>
                    <formalpara>
                      <title>INPUT</title>

                      <para>reads and executes SQL scripts from a defined text file. These files can
                      have several embedded DDL scripts in them. Scripts, can be created using a
                      text editor or built interactively, using the OUTPUT or EDIT command.Here is
                      the code:</para>
                    </formalpara>

                    <para><userinput>SQL&gt; INPUT filename ;</userinput></para>

                    <table>
                      <title>INPUT arguments</title>

                      <tgroup cols="2">
                        <colspec align="center" />

                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTIONS</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>FILENAME</entry>

                            <entry>Name of a file containing SQL statements and commands.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>OUTPUT</title>

                      <para>redirects output to a disk file or to a monitor(output screen). To
                      output both data and commands, use SET ECHO ON. To output data only, use SET
                      ECHO OFF. Here is the code:</para>
                    </formalpara>

                    <para><userinput>SQL&gt; OUTPUT [filename] ;</userinput><table>
                        <title>OUTPUT arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>FILENAME</entry>

                              <entry>Name of the file where output is saved. If no file name is
                              given, results appear on the monitor.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example:</para>

                    <para><userinput> <code>SQL&gt; OUTPUT C:\data\managers.dta ; SQL&gt; SELECT
                    EMP_NO, EMP_NAME FROM MANAGER ; /* output goes to file */ SQL&gt; OUTPUT ; /*
                    toggles output back to the monitor */</code></userinput></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>SHELL</title>

                      <para>provides temporary access to the command line of the operating system
                      shell without committing or rolling back any transactions. Here is the
                      code:</para>
                    </formalpara>

                    <para><userinput>SQL&gt; SHELL [operating system command] ;</userinput><table>
                        <title>SHELL arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>Operating System command</entry>

                              <entry>A valid operating system command or call. After the command is
                              executed,control returns to <emphasis>ISQL</emphasis>. In cases where
                              no command is issued, <emphasis>ISQL</emphasis> opens an interactive
                              session in the OS shell. To return control to
                              <emphasis>ISQL</emphasis> :type exit.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <userinput>SQL&gt; SHELL dir /mydir ;</userinput></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>BLOBDUMP</title>

                      <para>stores BLOB(Binary Large Object) data in a defined file. Here is the
                      code:</para>
                    </formalpara>

                    <para><userinput>SQL&gt; BLOBDUMP blob_id filename ;</userinput><table>
                        <title>BLOBDUMP arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>BLOB ID</entry>

                              <entry>Identifier consisting of two hex numbers separated by a colon
                              (:). The first number is the ID of the table containing the BLOB
                              column, the second is a sequenced instance number. To get the blob_id,
                              issue any SELECT statement that selects a column of BLOB data. FThe
                              output will show the hex blob_id above or in place of the BLOB column
                              data, depending on whether SET BLOB[DISPLAY] is ON or OFF.</entry>
                            </row>

                            <row>
                              <entry>FILENAME</entry>

                              <entry>Fully qualified filesystem name of the file which is to receive
                              the data.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <userinput>SQL&gt; BLOBDUMP 32:d48 IMAGE.JPG
                    ;</userinput></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>BLOBVIEW</title>

                      <para>BLOBVIEW displays BLOB data in the default text editor. Here is the
                      code:</para>
                    </formalpara>

                    <para><userinput>BLOBVIEW blob_id ;</userinput><table>
                        <title>BLOBDVIEW arguments</title>

                        <tgroup cols="2">
                          <colspec align="center" />

                          <thead>
                            <row>
                              <entry>ARGUMENTS</entry>

                              <entry>DESCRIPTIONS</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>BLOB ID</entry>

                              <entry>Identifier consisting of two hex numbers separated by a colon
                              (:). See BLOBDUMP for instructions on how to determine the blob_id you
                              are looking for. In current versions, BLOBVIEW does not support online
                              editing of the BLOB. It may be introduced in a future release.</entry>
                            </row>

                            <row>
                              <entry>FILENAME</entry>

                              <entry>Fully qualified filesystem name of the file which is to receive
                              the data.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <userinput><code>SQL&gt; BLOBVIEW 85:7
                    ;</code></userinput><note>
                        <para>BLOBVIEW may return an “Invalid transaction handle” error after you
                        close the editor. This is a known bug.To correct the situation, start a
                        transaction manually, with :</para>

                        <para><userinput>SQL&gt; SET TRANSACTION;</userinput></para>
                      </note></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>HELP</title>

                      <para>displays a list of <emphasis>ISQL</emphasis> commands with descriptions.
                      You can combine it with OUTPUT to print the list to a file. Here is the
                      code:</para>
                    </formalpara>

                    <para><userinput>SQL&gt; HELP ;</userinput></para>

                    <para><userinput>Example:SQL&gt; OUTPUT HELPLIST.TXT ; SQL&gt; HELP ; SQL&gt;
                    OUTPUT ; /* toggles output back to the monitor */</userinput></para>

                    <para>No arguments.</para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>EDIT</title>

                      <para>allows editing and re-execution of the previous
                      <emphasis>ISQL</emphasis> command or of a batch of commands in a source file.
                      Here is the code:</para>
                    </formalpara>

                    <para><userinput>SQL&gt; EDIT [filename] ;</userinput><table>
                        <title>EDIT arguments</title>

                        <tgroup cols="2">
                          <thead>
                            <row>
                              <entry>ARGUMENT</entry>

                              <entry>DESCRIPTION</entry>
                            </row>
                          </thead>

                          <tbody>
                            <row>
                              <entry>FILENAME</entry>

                              <entry>Optional, fully qualifed filesystem name of file to
                              edit.</entry>
                            </row>
                          </tbody>
                        </tgroup>
                      </table>Example : <userinput>SQL&gt; EDIT
                    /usr/mystuff/batch.sql;</userinput></para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>ADD</title>

                      <para>adds rows interactively to a table, field after field.</para>
                    </formalpara>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>COPY</title>

                      <para>copies the structure of a table into a new table, either in the same
                      database or in another.</para>
                    </formalpara>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>EXIT</title>

                      <para>commits the current transaction without prompting, closes the database
                      and ends the <emphasis>ISQL</emphasis> session.</para>
                    </formalpara>

                    <note>
                      <para>If you need to commit the transaction instead of rolling it back, use
                      EXIT instead.</para>
                    </note>

                    <para>Example : <userinput>SQL&gt; EXIT ;</userinput></para>

                    <para>No arguments.</para>
                  </listitem>

                  <listitem>
                    <formalpara>
                      <title>QUIT</title>

                      <para>rolls back the current transaction without prompting, closes the
                      database and ends the <emphasis>ISQL</emphasis> session.</para>
                    </formalpara>

                    <note>
                      <para>If you need to commit the transaction instead of rolling it back, use
                      EXIT instead.</para>
                    </note>

                    <para>Example : <userinput>SQL&gt; QUIT ;</userinput></para>

                    <para>No arguments.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>

            <listitem>
              <formalpara>
                <title>SHOW COMMANDS</title>

                <para>are used to query the database to display metatdata.Metadata is stored in
                system tables.Metadata includes the definition of database objects such as domains,
                generators, tables, constraints, indices, views, triggers,stored procedures,
                user-defined functions(UDFs),and blob filters. SHOW commands run in READ COMMIT mode
                to ensure the return of the most up-to-date view of the database.Here is the list of
                SHOW commands:</para>
              </formalpara>

              <itemizedlist>
                <listitem>
                  <formalpara>
                    <title>SHOW DOMAIN[S]</title>

                    <para>displays domain information. A domain is a user-defined data type,global
                    to the database. It is used to define the format and range of columns, upon
                    which the actual column definitions in tables are based.</para>
                  </formalpara>

                  <para>Firebird tables are defined by the specification of columns, which store
                  appropriate information in each column using data types.</para>

                  <para>A data type is an elemental unit when defining data, which specifies the
                  type of data stored in tables, and which operations may be performed on this data.
                  It can also include permissible calculative operations and maximum data
                  size.Examples of data types include: numerical (numeric, decimal, integer);textual
                  (char, varchar, nchar, nvarchar); date (date, time, timestamp) and blobs(binary
                  large objects).</para>

                  <para>Here is the syntax to display domain information:</para>

                  <para><userinput>SQL&gt; SHOW { DOMAINS | DOMAIN name } ;</userinput><table>
                      <title>SHOW DOMAIN[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>DOMAIN[S]</entry>

                            <entry>Lists the names of all the domains declared in the
                            database</entry>
                          </row>

                          <row>
                            <entry>DOMAIN name</entry>

                            <entry>Displays definition of the named domain</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>Example :</para>

                  <para><screen>SQL&gt; SHOW DOMAIN;
       ADDRESSLINE                            BUDGET
       COUNTRYNAME                            CUSTNO
       DEPTNO                                 EMPNO
       FIRSTNAME                              JOBCODE
       JOBGRADE                               LASTNAME
       PHONENUMBER                            PONUMBER
       PRODTYPE                               PROJNO
       SALARY</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW GENERATOR[S}</title>

                    <para>displays information about generators.Generators are automatic sequential
                    counters, spanning the entire database. They are outside the purview of
                    transaction control. Here is the syntax to display generator information:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW { GENERATORS | GENERATOR name } ;</userinput><table>
                      <title>SHOW GENERATOR[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>GENERATORS</entry>

                            <entry>Lists the names of all generators declared in the database, along
                            with their next values</entry>
                          </row>

                          <row>
                            <entry>GENERATOR NAMES</entry>

                            <entry>Displays the declaration of the named generator, along with its
                            next value</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>Example :</para>

                  <para><screen>SQL&gt; SHOW GENERATORS;
Generator CUST_NO_GEN, current value is 1015
Generator EMP_NO_GEN, current value is 145</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW CHECK</title>

                    <para>displays all user-defined CHECK constraints defined for a table.Here is
                    the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW CHECK &lt;tablename&gt; ;</userinput><table>
                      <title>SHOW CHECK arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>Table Name</entry>

                            <entry>Name of a table that exists in the attached database,and if it
                            has any user-defined check constraints</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table>Example :</para>

                  <para><screen>SQL&gt; SHOW CHECK COUNTRY;
There are no check constraints on table COUNTRY in this database</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW DATABASE</title>

                    <para>displays information about the attached database (file name, page size and
                    allocation, sweep interval,transaction numbers and Forced Writes status) and
                    starting in Firebird 2.0, also reveals the On-Disk Structure or ODS
                    version.</para>
                  </formalpara>

                  <para>On-Disk structure or ODS identifies a database with the release version of
                  Firebird . The ODS of a databse affects its compatibility with server versions.
                  The ODS can be upgraded by using the gbak utility. In Firebird 2.0 ODS has been
                  changed to 11.</para>

                  <para>For version , see SHOW VERSION. Here is the syntax for the code:</para>

                  <para><userinput>SQL&gt; SHOW DATABASE | DB ;</userinput></para>

                  <para>No arguments.</para>

                  <para>Example :</para>

                  <para><screen>SQL&gt; SHOW DATABASE;
Database: C:\Program Files\Firebird\Firebird_2_0\examples\empbuild\employee.fdb
        Owner: SYSDBA
PAGE_SIZE 4096
Number of DB pages allocated = 259
Sweep interval = 20000
Forced Writes are ON
Transaction - oldest = 179
Transaction - oldest active = 180
Transaction - oldest snapshot = 180
Transaction - Next = 187
ODS = 11.0
Default Character set: NONE</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW EXCEPTION[S]</title>

                    <para>displays exception information.</para>
                  </formalpara>

                  <para>Exceptions are user-defined named error messages, written specifically for a
                  database and stored in that database for use in stored procedures and triggers. An
                  exception is triggered when the value in a table is acertained to be incorrect.
                  This leads to a rollback of the transaction that the client application is
                  attempting to commit. Exceptions can be interleaved.They can be shared among the
                  different modules of an application, and even among different applications sharing
                  a database. They provide a simple way to standardize the handling of preprogrammed
                  input errors.Here is the syntax for the code:</para>

                  <para><userinput>SQL&gt; SHOW { EXCEPTIONS | EXCEPTION name } ;</userinput><table>
                      <title>SHOW EXCEPTION[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>EXCEPTIONS</entry>

                            <entry>Lists the names and texts of all exceptions declared in the
                            database</entry>
                          </row>

                          <row>
                            <entry>EXCEPTION NAME</entry>

                            <entry>Displays text of the named single exception</entry>
                          </row>

                          <row>
                            <entry>TYPE</entry>

                            <entry>Stored Procedure</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Example :</para>

                  <para><screen>SQL&gt; SHOW EXCEPTIONS;
Exception Name                  Used by, Type
=============================== =================================
CUSTOMER_CHECK                  SHIP_ORDER, Stored procedure
Msg: Overdue balance -- can not ship.

CUSTOMER_ON_HOLD                SHIP_ORDER, Stored procedure
Msg: This customer is on hold.

ORDER_ALREADY_SHIPPED           SHIP_ORDER, Stored procedure
Msg: Order status is "shipped."

REASSIGN_SALES                  DELETE_EMPLOYEE, Stored procedure
Msg: Reassign the sales records before deleting this employee.

UNKNOWN_EMP_ID                  ADD_EMP_PROJ, Stored procedure
Msg: Invalid employee number or project id.</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW FUNCTION[S]</title>

                    <para>displays information about user-defined functions (UDFs) declared in the
                    attached database.</para>
                  </formalpara>

                  <para>A user-defined function (UDF) is used to perform tasks that Firebird
                  cannot.It can be described as an external database function written entirely in
                  another language, such as C++ or Pascal, to perform data manipulation tasks not
                  directly supported by Firebird.</para>

                  <para>UDFs can be called from Firebird and executed on the server. These functions
                  can exist on their own or be collected into libraries. UDFs offer the possibility
                  to create your own functions (such as SUBSTR) and integrate them in the database
                  itself. Each UDF is arranged as a function, belonging to a DLL (Linux: .SO). Thus
                  one dynamically loaded library consists of at least one function.</para>

                  <para>UDF definitions are database dependent and not server dependent, i.e. they
                  need to be registered for each database individually. Since in Firebird, the
                  libraries need to be stored in the Firebird UDF folder. Please refer to the
                  DECLARE EXTERNAL FUNCTION statement for details of incorporating UDFs in
                  Firebird.</para>

                  <note>
                    <para>It is important to note that the majority of UDFs, when used in a WHERE
                    condition, prevent indices from being used during execution.</para>
                  </note>

                  <para>Here is the syntax for the code:</para>

                  <para><userinput>SQL&gt; SHOW { FUNCTIONS | FUNCTION name } ;</userinput><table>
                      <title>SHOW FUNCTION[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>FUNCTION[S]</entry>

                            <entry>Lists the names of all UDFs declared in the database</entry>
                          </row>

                          <row>
                            <entry>FUNCTION NAME[S]</entry>

                            <entry>Displays the declaration of the named UDF</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW GRANT</title>

                    <para>displays privileges and ROLE ownership information about a named object in
                    the attached database; or displays user membership within roles.</para>
                  </formalpara>

                  <para>GRANT is the SQL statement, used to assign privileges to database users for
                  specified database objects. Here is the syntax for the code:</para>

                  <para><userinput>SQL&gt; SHOW GRANT { object | rolename } ;</userinput><table>
                      <title>SHOW GRANT arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>OBJECT</entry>

                            <entry>Name of an existing table, view or procedure in the current
                            database</entry>
                          </row>

                          <row>
                            <entry>ROLENAME</entry>

                            <entry>Name of an existing role in the current database. Use SHOW ROLES
                            to list all the roles defined for this database.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW GRANT;

/* Grant permissions for this database */
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON COUNTRY TO PUBLIC WITH GR
 OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON CUSTOMER TO PUBLIC WITH G
T OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON DEPARTMENT TO PUBLIC WITH
ANT OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON EMPLOYEE TO PUBLIC WITH G
T OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON EMPLOYEE_PROJECT TO PUBLI
ITH GRANT OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON JOB TO PUBLIC WITH GRANT
ION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON PHONE_LIST TO PUBLIC WITH
ANT OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON PROJECT TO PUBLIC WITH GR
 OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON PROJ_DEPT_BUDGET TO PUBLI
ITH GRANT OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON SALARY_HISTORY TO PUBLIC
H GRANT OPTION
GRANT DELETE, INSERT, SELECT, UPDATE, REFERENCES ON SALES TO PUBLIC WITH GRAN
PTION
GRANT EXECUTE ON PROCEDURE ADD_EMP_PROJ TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE ALL_LANGS TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE DELETE_EMPLOYEE TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE DEPT_BUDGET TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE GET_EMP_PROJ TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE MAIL_LABEL TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE ORG_CHART TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE SHIP_ORDER TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE SHOW_LANGS TO PUBLIC WITH GRANT OPTION
GRANT EXECUTE ON PROCEDURE SUB_TOT_BUDGET TO PUBLIC WITH GRANT OPTION</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW INDEX | INDICES</title>

                    <para>displays information about a named index, about indices for a specified
                    table or about indices for all tables in the attached database. Here is the
                    syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW {INDICES | INDEX { index | table } }
                  ;</userinput><table>
                      <title>SHOW INDEX| INDICES arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>INDEX</entry>

                            <entry>Name of an existing index in the current database</entry>
                          </row>

                          <row>
                            <entry>TABLE</entry>

                            <entry>Name of an existing table in the current database</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table><note>
                      <para>SHOW IND is an alias for either SHOW INDEX or SHOW INDICES.</para>
                    </note></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW INDEX;
RDB$PRIMARY1 UNIQUE INDEX ON COUNTRY(COUNTRY)
CUSTNAMEX INDEX ON CUSTOMER(CUSTOMER)
CUSTREGION INDEX ON CUSTOMER(COUNTRY, CITY)
RDB$FOREIGN23 INDEX ON CUSTOMER(COUNTRY)
RDB$PRIMARY22 UNIQUE INDEX ON CUSTOMER(CUST_NO)
BUDGETX DESCENDING INDEX ON DEPARTMENT(BUDGET)
RDB$4 UNIQUE INDEX ON DEPARTMENT(DEPARTMENT)
RDB$FOREIGN10 INDEX ON DEPARTMENT(MNGR_NO)
RDB$FOREIGN6 INDEX ON DEPARTMENT(HEAD_DEPT)
RDB$PRIMARY5 UNIQUE INDEX ON DEPARTMENT(DEPT_NO)
NAMEX INDEX ON EMPLOYEE(LAST_NAME, FIRST_NAME)
RDB$FOREIGN8 INDEX ON EMPLOYEE(DEPT_NO)
RDB$FOREIGN9 INDEX ON EMPLOYEE(JOB_CODE, JOB_GRADE, JOB_COUNTRY)
RDB$PRIMARY7 UNIQUE INDEX ON EMPLOYEE(EMP_NO)
RDB$FOREIGN15 INDEX ON EMPLOYEE_PROJECT(EMP_NO)
RDB$FOREIGN16 INDEX ON EMPLOYEE_PROJECT(PROJ_ID)
RDB$PRIMARY14 UNIQUE INDEX ON EMPLOYEE_PROJECT(EMP_NO, PROJ_ID)
MAXSALX DESCENDING INDEX ON JOB(JOB_COUNTRY, MAX_SALARY)
MINSALX INDEX ON JOB(JOB_COUNTRY, MIN_SALARY)
RDB$FOREIGN3 INDEX ON JOB(JOB_COUNTRY)
RDB$PRIMARY2 UNIQUE INDEX ON JOB(JOB_CODE, JOB_GRADE, JOB_COUNTRY)
PRODTYPEX UNIQUE INDEX ON PROJECT(PRODUCT, PROJ_NAME)
RDB$11 UNIQUE INDEX ON PROJECT(PROJ_NAME)
RDB$FOREIGN13 INDEX ON PROJECT(TEAM_LEADER)
RDB$PRIMARY12 UNIQUE INDEX ON PROJECT(PROJ_ID)
RDB$FOREIGN18 INDEX ON PROJ_DEPT_BUDGET(DEPT_NO)
RDB$FOREIGN19 INDEX ON PROJ_DEPT_BUDGET(PROJ_ID)
RDB$PRIMARY17 UNIQUE INDEX ON PROJ_DEPT_BUDGET(FISCAL_YEAR, PROJ_ID, DEPT_NO)
CHANGEX DESCENDING INDEX ON SALARY_HISTORY(CHANGE_DATE)
RDB$FOREIGN21 INDEX ON SALARY_HISTORY(EMP_NO)
RDB$PRIMARY20 UNIQUE INDEX ON SALARY_HISTORY(EMP_NO, CHANGE_DATE, UPDATER_ID)
UPDATERX INDEX ON SALARY_HISTORY(UPDATER_ID)
NEEDX INDEX ON SALES(DATE_NEEDED)
QTYX DESCENDING INDEX ON SALES(ITEM_TYPE, QTY_ORDERED)
RDB$FOREIGN25 INDEX ON SALES(CUST_NO)
RDB$FOREIGN26 INDEX ON SALES(SALES_REP)
RDB$PRIMARY24 UNIQUE INDEX ON SALES(PO_NUMBER)
SALESTATX INDEX ON SALES(ORDER_STATUS, PAID)</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW PROCEDURE[S]</title>

                    <para>lists all procedures in the attached database,with their dependencies; or
                    displays the text of the named procedure with the declarations and types
                    (input/output) of any parameters. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW {PROCEDURES | PROCEDURE name } ;</userinput><table>
                      <title>SHOW PROCEDURE[S] arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>NAME</entry>

                            <entry>Name of an existing stored procedure in the current
                            database.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table><note>
                      <para>SHOW PROC is an alias for either SHOW PROCEDURE or SHOW
                      PROCEDURES.</para>
                    </note></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW PROCEDURE;
Procedure Name                    Dependency, Type
================================= ======================================
ADD_EMP_PROJ                      EMPLOYEE_PROJECT, Table
                                  UNKNOWN_EMP_ID, Exception
ALL_LANGS                         JOB, Table
                                  SHOW_LANGS, Procedure
DELETE_EMPLOYEE                   DEPARTMENT, Table
                                  EMPLOYEE, Table
                                  EMPLOYEE_PROJECT, Table
                                  PROJECT, Table
                                  SALARY_HISTORY, Table
                                  SALES, Table
                                  REASSIGN_SALES, Exception
DEPT_BUDGET                       DEPARTMENT, Table
                                  DEPT_BUDGET, Procedure
GET_EMP_PROJ                      EMPLOYEE_PROJECT, Table
MAIL_LABEL                        CUSTOMER, Table
ORG_CHART                         DEPARTMENT, Table
                                  EMPLOYEE, Table
SHIP_ORDER                        CUSTOMER, Table
                                  SALES, Table
                                  CUSTOMER_CHECK, Exception
                                  CUSTOMER_ON_HOLD, Exception
                                  ORDER_ALREADY_SHIPPED, Exception
SHOW_LANGS                        JOB, Table
SUB_TOT_BUDGET                    DEPARTMENT, Table
</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW ROLE[S]</title>

                    <para>displays the names of SQL roles for the attached database. A role is a set
                    of privileges on a set of database objects such as tables and views. Roles are
                    assigned using a GRANT statement. To show user membership within roles, use SHOW
                    GRANT| ROLENAME.</para>
                  </formalpara>

                  <note>
                    <para>There can be a chain of roles;for example, in a bank, the role employee
                    may be granted to all tellers, and the role of teller, may be granted to all
                    managers., in addition to all privileges automatically granted to managers.Thus
                    all actions executed by a session have all the privileges granted directly to
                    the user, as well as all privileges granted to roles that are granted (directly
                    or indirectly via other roles) to that user.</para>
                  </note>

                  <para>Here is the syntax for the code:</para>

                  <para><userinput>SQL&gt; SHOW ROLES ;</userinput></para>

                  <para>No arguments.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW SQL DIALECT</title>

                    <para>displays the SQL dialects of the client and of the attached database, if
                    there is one.Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW SQL DIALECT;</userinput></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW SQL DIALECT;
        Client SQL dialect is set to: 3 and database SQL dialect is: 3</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW SYSTEM</title>

                    <para>displays the names of system tables and system views for the attached
                    database. Here is the syntax:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW SYS [ TABLES ] ;</userinput></para>

                  <para>No arguments.</para>

                  <para>TABLES is an optional keyword that does not affect the behavior of the
                  command in versions upto Firebird 1.5.3(?).This changes in version 2.0
                  onwards.</para>

                  <para>In Firebird Version 2.0, the SHOW SYSTEM command shows predefined UDFs. The
                  SHOW &lt; object_type&gt; command is designed to show user objects of that type.
                  In versions earlier than 2.0, the SHOW SYSTEM command showed only system
                  tables.Starting with 2.0, it also lists predefined system UDFs. In future releases
                  it could also display views.</para>

                  <para>Shorthand: SHOW SYS is equivalent.</para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW SYSTEM;
Tables:
       RDB$BACKUP_HISTORY                     RDB$CHARACTER_SETS
       RDB$CHECK_CONSTRAINTS                  RDB$COLLATIONS
       RDB$DATABASE                           RDB$DEPENDENCIES
       RDB$EXCEPTIONS                         RDB$FIELDS
       RDB$FIELD_DIMENSIONS                   RDB$FILES
       RDB$FILTERS                            RDB$FORMATS
       RDB$FUNCTIONS                          RDB$FUNCTION_ARGUMENTS
       RDB$GENERATORS                         RDB$INDEX_SEGMENTS
       RDB$INDICES                            RDB$LOG_FILES
       RDB$PAGES                              RDB$PROCEDURES
       RDB$PROCEDURE_PARAMETERS               RDB$REF_CONSTRAINTS
       RDB$RELATIONS                          RDB$RELATION_CONSTRAINTS
       RDB$RELATION_FIELDS                    RDB$ROLES
       RDB$SECURITY_CLASSES                   RDB$TRANSACTIONS
       RDB$TRIGGERS                           RDB$TRIGGER_MESSAGES
       RDB$TYPES                              RDB$USER_PRIVILEGES
       RDB$VIEW_RELATIONS
Functions:
       RDB$GET_CONTEXT                        RDB$SET_CONTEXT</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW TABLES</title>

                    <para>lists all tables or views in the database, and or displays information on
                    specific named table[s] or view[s].</para>
                  </formalpara>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW TABLES;
       COUNTRY                                CUSTOMER
       DEPARTMENT                             EMPLOYEE
       EMPLOYEE_PROJECT                       JOB
       PROJECT                                PROJ_DEPT_BUDGET
       SALARY_HISTORY                         SALES</screen></para>

                  <note>
                    <para>See also SHOW VIEW[s].</para>
                  </note>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW TRIGGERS</title>

                    <para>displays all the triggers defined in the database along with the
                    associated table name.A database trigger is procedural code, that is
                    automatically executed in response to specific events ,on a specified table, in
                    a database. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt;SHOW TRIGGERS;</userinput></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW TRIGGERS;
Table name                       Trigger name
===========                      ============
CUSTOMER                         SET_CUST_NO
EMPLOYEE                         SAVE_SALARY_CHANGE
EMPLOYEE                         SET_EMP_NO
SALES                            POST_NEW_ORDER</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW VERSION</title>

                    <para>displays information about the software versions of
                    <emphasis>ISQL</emphasis> and the Firebird server program, and the on-disk
                    structure of the attached database.However, in Firebird 2.0 onwards the ODS
                    version can also be returned using the SHOW DATABASE statement. Here is the
                    syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SHOW VERSION ;</userinput></para>

                  <para>No arguments.</para>

                  <para>Shorthand: SHOW VER is equivalent.</para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW VERSION;
ISQL Version: WI-V2.0.0.12745 Firebird 2.0 Release Candidate 5
Server version:
Firebird/x86/Windows NT (access method), version "WI-V2.0.0.12745 Firebird 2.0 R
elease Candidate 5"
Firebird/x86/Windows NT (remote server), version "WI-V2.0.0.12745 Firebird 2.0 R
elease Candidate 5/XNet (PLAYTHING)/P10"
Firebird/x86/Windows NT (remote interface), version "WI-V2.0.0.12745 Firebird 2.
0 Release Candidate 5/XNet (PLAYTHING)/P10"
on disk structure version 11.0</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SHOW VIEW[s]</title>

                    <para>lists all views, or displays information about the named view.</para>
                  </formalpara>

                  <para>Here is the syntax for the code:</para>

                  <para><userinput>SQL&gt; SHOW { VIEWS | VIEW name } ;</userinput><table>
                      <title>SHOW VIEW[S]</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>NAME</entry>

                            <entry>Name of an existing view in the current database. The output
                            contains column names and the SELECT statement that the view is based
                            on.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Example:</para>

                  <para><screen>SQL&gt; SHOW VIEW;
       PHONE_LIST</screen></para>

                  <note>
                    <para>See also SHOW TABLES.</para>
                  </note>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <formalpara>
                <title>SET COMMANDS</title>

                <para>enable users to view and change the <emphasis>ISQL</emphasis> environment. To
                view the current settings for the various set commands in the database, issue the
                following command:</para>
              </formalpara>

              <para><userinput>SET;</userinput></para>

              <para><screen>SQL&gt; SET;
Print statistics:        OFF
Echo commands:           OFF
List format:             OFF
Row Count:               OFF
Autocommit DDL:          ON
Access Plan:             OFF
Access Plan only:        OFF
Display BLOB type:       1
Column headings:         ON
Terminator:              ;
Time:                    OFF
Warnings:                ON
Bail on error:           OFF</screen></para>

              <itemizedlist>
                <listitem>
                  <formalpara>
                    <title>SET AUTODDL</title>

                    <para>specifies whether DDL statements are committed automatically after being
                    executed, or committed only after an explicit COMMIT. Here is the syntax for the
                    code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET AUTODDL [ON | OFF] ; /* default is ON
                  */</userinput><table>
                      <title>SET AUTODDL arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles automatic commit on.</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles automatic commit off.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shorthand : SET AUTO (with no argument) simply toggles AUTODDL on and
                  off.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET BLOBDISPLAY</title>

                    <para>specifies both sub_type of BLOB to display and whether BLOB data should be
                    displayed.Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET BLOBDISPLAY [ n | ALL | OFF ] ;</userinput><table>
                      <title>SET BLOBDISPLAY arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>n</entry>

                            <entry>BLOB SUB_TYPE to display. Default: n= 1 (text)</entry>
                          </row>

                          <row>
                            <entry>ON</entry>

                            <entry>Display BLOB data of any sub_type</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles display of BLOB data off. The output shows only the Blob
                            ID (two hex numbers separated by a colon (:). The first number is the ID
                            of the table containing the BLOB column. The second is a sequenced
                            instance number.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shorthand: SET BLOB is the same.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET COUNT</title>

                    <para>toggles off/on whether to display the number of rows retrieved by queries.
                    Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET COUNT [ON | OFF] ;</userinput><table>
                      <title>SET COUNT arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on display of "rows returned" message</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles off display of "rows returned" message (default)</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET ECHO</title>

                    <para>toggles off/on whether commands are displayed before being executed.
                    Default is ON but you might want to toggle it to OFF if sending your output to a
                    script file. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET ECHO [ON | OFF] ; /* default is ON
                  */</userinput><table>
                      <title>SET ECHO arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on command echoing (default)</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles off command echoing</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET NAME[s]</title>

                    <para>specifies the character set that is to be active in database
                    transactions.Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET NAMES charset ;</userinput><table>
                      <title>SET NAMES arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>CHARSET</entry>

                            <entry>Name of the active character set. Default: NONE</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET PLAN</title>

                    <para>specifies whether to display the optimizer's query plan.Here is the syntax
                    for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET PLAN [ ON | OFF ] ;</userinput><table>
                      <title>SET PLAN arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Turns on display of the query plan. Default.</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Turns off display of the query plan.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shortcut: omit ON | OFF and use just SET PLAN as a toggle.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET PLANONLY</title>

                    <para>specifies to use the optimizer's query plan and display just the plan,
                    without executing the actual query. (Available in Firebird 1 and higher). Here
                    is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET PLANONLY ON | OFF;</userinput></para>

                  <para>The command works as a toggle switch. The argument is optional.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET SQL DIALECT</title>

                    <para>specifies the Firebird SQL dialect to which the client session is to be
                    changed. If the session is currently attached to a database of a different
                    dialect to the one specified in the command, a warning is displayed. Here is the
                    syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET SQL DIALECT n ;</userinput><table>
                      <title>SET SQL DIALECT arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>n</entry>

                            <entry>n = 1 for Dialect 1, 2 for Dialect 2, 3 for Dialect 3</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET STATS</title>

                    <para>specifies whether to display performance statistics following the output
                    of a query. Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET STATS [ ON | OFF ] ;</userinput><table>
                      <title>SET STATS arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENT</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Turns on display of performance statistics. Displays: • Current
                            memory available (bytes)• Change in available memory (bytes) • Maximum
                            memory available (bytes) • Elapsed time for the operation (seconds) •
                            CPU time for the operation (seconds) • Number of cache buffers used •
                            Number of reads requested • Number of writes requested • Number of
                            fetches done</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Turns off display of performance statistics. Default.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shortcut: omit ON | OFF and use just SET STATS as a toggle.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET TERM</title>

                    <para>specifies the character which will be used as the command or statement
                    terminator, from the next statement forward.Here is the syntax for the
                    code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET TERM string ;</userinput><table>
                      <title>SET TERM arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>String</entry>

                            <entry>Character or characters which will be used as statement
                            terminator. Default: ;</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET TIME</title>

                    <para>specifies whether to display the time portion of a DATE value (Dialect 1
                    only). Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET TIME [ ON | OFF ] ;</userinput><table>
                      <title>SET TIME arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTION</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on time portion display in Dialect 1 DATE value</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles on time portion display in Dialect 1 DATE value.
                            Default.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET WARNINGS</title>

                    <para>specifies whether warnings are to be output. A few examples for which ISQL
                    issues warnings are: <itemizedlist>
                        <listitem>
                          <para>SQL statement that cause no effect.</para>
                        </listitem>

                        <listitem>
                          <para>Pending database shutdown.</para>
                        </listitem>

                        <listitem>
                          <para>API calls that may be replaced in future versions of
                          Firebird.</para>
                        </listitem>
                      </itemizedlist>Here is the syntax for the code:</para>
                  </formalpara>

                  <para><userinput>SQL&gt; SET WARNINGS [ ON | OFF ] ;</userinput><table>
                      <title>SET WARNINGS arguments</title>

                      <tgroup cols="2">
                        <thead>
                          <row>
                            <entry>ARGUMENTS</entry>

                            <entry>DESCRIPTIONS</entry>
                          </row>
                        </thead>

                        <tbody>
                          <row>
                            <entry>ON</entry>

                            <entry>Toggles on display of warnings if it was toggled off, or if the
                            session was started with the - nowarnings option.</entry>
                          </row>

                          <row>
                            <entry>OFF</entry>

                            <entry>Toggles off display of warnings if it is currently toggled
                            on.</entry>
                          </row>
                        </tbody>
                      </tgroup>
                    </table></para>

                  <para>Shorthand: SET WNG can be used as a substitute, as a simple on/off
                  toggle.</para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET HEADING[S]</title>

                    <para>This allows users to disable the printing of column headers, when doing a
                    SELECT inside <emphasis>ISQL</emphasis>, and having the output sent to a file,
                    for processing at a later stage. In versions before 2.0,
                    <emphasis>ISQL</emphasis> used to print all the column headers by default, and
                    sometimes the sheer number of columns made the display in ISQL impractical. This
                    has now been fixed with the SET HEADING[s] on | off toggle.</para>
                  </formalpara>

                  <note>
                    <para>This switch cannot be deactivated with a command line parameter. Using SET
                    will display the state of SET HEAD, along with other switches that can be
                    toggled on/off in the <emphasis>ISQL</emphasis> shell.</para>
                  </note>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET BAIL</title>

                    <para>will toggle the state between activated and deactivated. Using SET will
                    display the state of the switch among many others. Even if BAIL is activated, it
                    doesn't mean it will change <emphasis>ISQL</emphasis> Example isql -b -i
                    my_fb.sql -o results.log -m -m2behavior. An additional requirement should be
                    met: the session should be non-interactive. A non-interactive session happens
                    when the user calls <emphasis>ISQL</emphasis> in batch mode, giving it a script
                    as input.</para>
                  </formalpara>

                  <para><note>
                      <para>If the user loads <emphasis>ISQL </emphasis>interactively ,and later
                      executes a script with the input command; this is considered an interactive
                      session ,even though <emphasis>ISQL</emphasis> knows it is executing a
                      script.</para>
                    </note></para>

                  <para>Example:</para>

                  <para><screen>Use CONNECT or CREATE DATABASE to specify a database 
SQL&gt; set bail; 
SQL&gt; input my_fb.sql; SQL&gt; ^Z</screen></para>
                </listitem>

                <listitem>
                  <formalpara>
                    <title>SET SQLDA_DISPLAY ON | OFF</title>

                    <para>The SQLDA_DISPLAY command shows the input SQLDA parameters of INSERTS,
                    UPDATES AND DELETES. It reveals information on the raw SQLVARS. A SQLVAR
                    represents a field in XSQLDA , the main structure used by the Firebird API to
                    talk to clients, transferring data in and out of the server. This feature has
                    been introduced in Firebird 2.0. It was previously available only in DEBUG
                    builds.</para>
                  </formalpara>

                  <note>
                    <para>As of Firebird 2.0 this feature is not yet displayed by
                    <emphasis>ISQL</emphasis> when you type SET; to view the settings of
                    options.</para>
                  </note>
                </listitem>
              </itemizedlist>
            </listitem>
          </itemizedlist></para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Command-line Switches</title>

    <para>Command-line switches are command-line arguments that begin with a - character.The
    following table tabulates all the switches that can be employed from
    <emphasis>ISQL.</emphasis></para>

    <table>
      <title>ISQL COMMAND-LINE SWITCHES</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry>SWITCH</entry>

            <entry>VERSION</entry>

            <entry>DESCRIPTION</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>-a(ll)</entry>

            <entry>1.0 and higher</entry>

            <entry>extract metadata incl. legacy non-SQL tables</entry>
          </row>

          <row>
            <entry>-b</entry>

            <entry>1.5.3 and higher</entry>

            <entry>instructs ISQL to bail out on error when used in non-interactive mode, and
            returns an error code to the operating system.</entry>
          </row>

          <row>
            <entry>-c(ache) &lt;num&gt;</entry>

            <entry></entry>

            <entry>number of cache buffers</entry>
          </row>

          <row>
            <entry>ch(arset) &lt;charset&gt;</entry>

            <entry></entry>

            <entry>connection charset (set names)</entry>
          </row>

          <row>
            <entry>-d(atabase) &lt;database&gt;</entry>

            <entry></entry>

            <entry>database name to put in script creation</entry>
          </row>

          <row>
            <entry>-e(cho)</entry>

            <entry></entry>

            <entry>echoes commands to find out where a script has caused errors (set echo
            on)</entry>
          </row>

          <row>
            <entry>-ex(tract)</entry>

            <entry></entry>

            <entry>extract metadata</entry>
          </row>

          <row>
            <entry>-i(nput) &lt;file&gt;</entry>

            <entry></entry>

            <entry>input file (set input)</entry>
          </row>

          <row>
            <entry>-m</entry>

            <entry></entry>

            <entry>to merge standard error</entry>
          </row>

          <row>
            <entry>m2</entry>

            <entry>2.0 and higher</entry>

            <entry>merge diagnostic</entry>
          </row>

          <row>
            <entry>-n(noautocommit)</entry>

            <entry></entry>

            <entry>no autocommit DDL (set autoddl off)</entry>
          </row>

          <row>
            <entry>-now(arning)</entry>

            <entry></entry>

            <entry>do not show warnings</entry>
          </row>

          <row>
            <entry>-0[utput] <emphasis>file</emphasis></entry>

            <entry></entry>

            <entry>to send the output to a file(set output)</entry>
          </row>

          <row>
            <entry>p(assword) &lt;password&gt;</entry>

            <entry></entry>

            <entry>connection password</entry>
          </row>

          <row>
            <entry>-pag(elength) &lt;size&gt;</entry>

            <entry></entry>

            <entry>page length</entry>
          </row>

          <row>
            <entry>-q(uiet)</entry>

            <entry></entry>

            <entry>do not show the message "Use CONNECT..."</entry>
          </row>

          <row>
            <entry>-r(ole) &lt;role&gt;</entry>

            <entry></entry>

            <entry>role name</entry>
          </row>

          <row>
            <entry>-r2 &lt;role&gt;</entry>

            <entry></entry>

            <entry>role (uses quoted identifier)</entry>
          </row>

          <row>
            <entry>sqldialect &lt;dialect&gt;</entry>

            <entry>1.0 and higher</entry>

            <entry>SQL dialect (set sql dialect)</entry>
          </row>

          <row>
            <entry>-t(erminator) &lt;term&gt;</entry>

            <entry></entry>

            <entry>command terminator (set term)</entry>
          </row>

          <row>
            <entry>-u(ser) &lt;user&gt;</entry>

            <entry></entry>

            <entry>user name</entry>
          </row>

          <row>
            <entry>-x</entry>

            <entry></entry>

            <entry>extract metadata</entry>
          </row>

          <row>
            <entry>-z</entry>

            <entry></entry>

            <entry>shows program and server version</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Some of the switches are explained in greater depth below:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Using -b(ail)</emphasis>:</para>

        <para>The Command-line switch -b instructs the <emphasis>ISQL</emphasis> utility to bail on
        error, but only when used in a non-interactive mode. The switch returns an error code to the
        Operating System.</para>

        <para>This switch was added to prevent <emphasis>ISQL</emphasis> from executing scripts
        after an error has been detected. No further statements will be executed and
        <emphasis>ISQL</emphasis> will return an error code to the OS.</para>

        <para>Users still need to use the -e switch to echo commands to an output file, to isolate
        the exact statement that caused the error.</para>

        <para>When the server provides line and column information, users can see the exact line of
        the DML in the script that caused the problem. When the server only indicates failure, users
        can view the first line of the statement that caused the failure, in relation to the entire
        script.</para>

        <para>This feature is also supported in nested scripts. For example, Script A includes
        Script B and Script B causes a failure, the line number is related to Script B. When Script
        B is read completely, <emphasis>ISQL </emphasis>continues counting the lines related to
        Script A, since each file gets a separate line counter. Script A includes Script B when
        Script A uses the INPUT command to load Script B.</para>

        <para>Lines are counted according to what the underlying IO layer considers separate lines.
        For ports using EDITLINE, a line is what readline() provides in a single call. The line
        length limit of 32767 bytes remains uncharged.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using ex(tract): </emphasis></para>

        <para>The command-line switch -ex(tract) can be used to extract metadata from the database.
        It can be used in conjunction with the -0(utput) switch to extract the information to a
        specified output file.</para>

        <para>The resultant information:can be used to view all the changes made to the database
        since it's creation,before making any more changes;create a new database with identical
        schema definitions or new ones ;or create a new database source file.</para>
      </listitem>

      <listitem>
        <para><emphasis>Using ISQL -m2 and -m:</emphasis></para>

        <para>The a command-line switch m2, has been added in Firebird 2.0 and can be used to send
        the statistics and plans to the same output file that receives the input from the -o[utput]
        switch.</para>

        <para>In earlier versions of Firebird (before version 2.0) ,when a user specified that the
        output should be sent to a file, two options existed : the command line switch -o with a
        file name to store the output , or the command OUTput with a file name to store the output.
        Both these options could be employed either in a batch session or in the interactive
        <emphasis>ISQL </emphasis>shell. In both cases, simply passing the command OUTput would
        return the output to the console. While the console displayed error messages, these were not
        sent to the output file .</para>

        <para>The -m command line switch,can be used to incorporate the error messages into the
        output files.</para>

        <para>The -m2 commandline switch ensures that the stats and plan information derived from
        the SET STATS, SET PLAN and SET PLANONLY commands are also sent to the output file and not
        just returned to the console.</para>

        <note>
          <para>Neither -m nor -m2 has an interactive counterpart through a SET command. They are
          for use only as command-line ISQL options.</para>
        </note>
      </listitem>

      <listitem>
        <para><emphasis>Using ISQL -r:</emphasis></para>

        <para>This switch can be used to specify a case-sensitive role name. The default switch for
        this is -r. Roles provided in the command line are uppercased With -r2, and passed to the
        engine exactly as typed in the command line.</para>
      </listitem>

      <listitem>
        <para>Using <emphasis>ISQL</emphasis> -o:</para>

        <para>The OUTPUT switch allows users to store records of commands to a script file. The TMP
        setting on a client can be used to to control where these script files will be stored,if an
        absolute file path is not specified.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section>
    <title>Ending an <emphasis>ISQL </emphasis>Session</title>

    <para>There are two ways to exit <emphasis>ISQL</emphasis>.</para>

    <itemizedlist>
      <listitem>
        <para>If you wish to roll back all uncommitted work and exit <emphasis>ISQL</emphasis> type
        this command at the prompt:</para>

        <para><userinput>SQL&gt;QUIT;</userinput></para>
      </listitem>

      <listitem>
        <para>If you wish to commit all your work before exiting <emphasis>ISQL</emphasis>, then
        type in the following command:</para>

        <para><userinput>SQL&gt;EXIT;</userinput></para>
      </listitem>
    </itemizedlist>
  </section>
</article>