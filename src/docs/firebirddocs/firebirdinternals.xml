<?xml version="1.0" encoding="UTF-8"?>
<!--
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-->
<article id="fb-internals">
    <title>Firebird Internals</title>

    <titleabbrev>Inside a Firebird Database</titleabbrev>

    <articleinfo>
        <date>03 November 2009</date>

        <author>
            <firstname>Norman</firstname>

            <surname>Dunbar</surname>
        </author>

        <edition>03 November 2009 â€“ Document version 1.0</edition>
    </articleinfo>

    <section id="fbint-introduction">
        <title>Introduction</title>

        <para>The purpose of this document is to try and explain what goes on inside a
        Firebird Database. Much of the information in this manual has been extracted from
        the Firebird source code - mainly on the ODS related code and headers - and from
        some (partially out of date) documents on the Research part of the IBPhoenix web
        site (http://www.ibphoenix.com/).</para>

        <para>Much hex dumping of database files was undertaken in the creation of this
        document, but no Firebird databases were harmed during this process.</para>

        <para>All databases mentioned or described within this document are those with an
        ODS of 11.1 - in other words, Firebird 2.1, and a page size of 4,096 bytes. There
        may be differences between this ODS version and previous ones and wherever
        possible, this has been documented.</para>

        <para>Unless otherwise noted, the test database used for this document is empty of
        all user tables, indices, generators etc. It was created on a 32 bit Linux system
        running on Intel hardware. It is therefore little endian.</para>
    </section>

    <section id="fbint-structure">
        <title>Database Structure</title>

        <para>When you create a new database, be it single or multiple file, a number of
        things happen:</para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>The database file(s) are created;</para>
            </listitem>

            <listitem>
                <para>The header page is formatted and written;</para>
            </listitem>

            <listitem>
                <para>The various system tables - RDB$ and MON$ - and associated indices
                are created - and appropriate pages formatted and written to disc;</para>
            </listitem>

            <listitem>
                <para>Every page in the database is formatted with a defined page
                type.</para>
            </listitem>
        </itemizedlist>

        <para>The various page types are described elsewhere in this document.</para>

        <para>A database is created and the DBA can specify the page size, or leave it to
        default. This action creates a database file, or files, with enough space
        allocated to create all the system tables and indices. New pages will be added to
        the end of the database file(s) as and when the user creates new tables and/or
        indices. For example, a brand new database, created on a 32 bit Linux system, with
        a 4Kb page size allocates a total of 0xa1 pages (161 pages) for the system tables,
        indices and the various database overhead pages.</para>

        <section id="fbint-structure-single">
            <title>Single File Databases</title>

            <para>A single file Firebird database consists of a number of pages, each the
            same size, and all held within one file on the underlysing file system, be it
            NTFS, FAT32, EXT3 etc.</para>

            <para>The first page in the database is always a header page (page type 0x01 -
            see below) which holds details about the database itself, the page size and so
            on.</para>

            <para>The second page in the database is a Page Inventory Page or PIP (page
            type 0x02) which details which pages in the database are in use and which are
            free.</para>

            <para>Up until Firebird 3.0, the next page is a Write Ahead Log page (page
            type 0x0a) but this page is wasted space, if present, and will most likely be
            dropped from Firebird 3.0 onwards.</para>

            <para>The remaining pages consist of Index Root Pages (page type 0x06),
            Transaction Inventory Pages or TIP (page type 0x03), Pointer Pages (page type
            0x04), Index BTree Pages (page type 0x07), Data Pages (page type 0x05) and so
            on. There is a discussion of each page type below.</para>
        </section>

        <section id="fbint-structure-multi">
            <title>Multiple File Databases</title>

            <para>A multiple file Firebird database is almost identical to the single file
            database except it has more than one file on the underlying file system. Each
            file has the same page size as the initial file, and each file has a header
            page (page type 0x01) at the start of the file.</para>
        </section>

        <section id="fbint-structure-shadow">
            <title>Shadow Files</title>

            <para>Shadow files are additional files that can be used by single and
            multiple file databases to assist in recovery after a failure of some kind.
            They are not helpful in the case of a DROP DATABASE as the shadow file(s0,
            being part of the database, are also dropped!</para>

            <para>Shadow files are updated as the database main file(s) are updated and in
            this manner, the shadows are an identical copy of the database. In the event
            of a problem, the SYSDBA can manually activate a shadow, or have the Firebird
            engine activate one automatically.</para>

            <para>Unfortunately, if a database write stores corrupt data in the database,
            the shadow file(s) will be identically corrupted.</para>

            <para>Because shadow files are effectively identical copies of the database
            files, they will not be discussed further.</para>
        </section>
    </section>

    <section id="fbint-standard-header">
        <title>Standard Database Page Header</title>

        <para>Every page in a database has a 16 byte standard page header. Various page
        types have an additional header that follows on from the standard one. The C code
        representation of the standard header is:</para>

        <programlisting>struct pag
{
    SCHAR pag_type;
    UCHAR pag_flags;
    USHORT pag_checksum;
    ULONG pag_generation;
    ULONG pag_scn;
    ULONG reserved;
};</programlisting>

        <formalpara>
            <title>Pag_type</title>

            <para>One byte, signed. Byte 0x00 on the page. This byte defines the page type
            for the page. Valid page types are:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>0x00 - Undefined page. You should never see this in a
                database.</para>
            </listitem>

            <listitem>
                <para>0x01 - The database header page. Only ever seen on the very first
                page of the database, or, on the first page of each database file in a
                multi-file database.</para>
            </listitem>

            <listitem>
                <para>0x02 - The Page Inventory Page (PIP). This page keeps track of
                allocated and free pages using a bitmap where a 1 means the page is free
                and a zero shows a used page. There may be more than one PIP in a
                database, but the first PIP is always page 1.</para>
            </listitem>

            <listitem>
                <para>0x03 - Transaction Inventory Page (TIP). A page that keeps track of
                the stat of transactions. Each transaction is represented by a pair of
                bits in a bitmap. Valid values in these two bits are:</para>

                <itemizedlist spacing="compact">
                    <listitem>
                        <para>00 - this transaction is active.</para>
                    </listitem>

                    <listitem>
                        <para>01 - this transaction is in limbo.</para>
                    </listitem>

                    <listitem>
                        <para>10 - this transaction is dead.</para>
                    </listitem>

                    <listitem>
                        <para>11 - this transaction has committed.</para>
                    </listitem>
                </itemizedlist>
            </listitem>

            <listitem>
                <para>0x04 - Pointer Page. Each table has one or more of these and this
                page type keeps track of all the pages that make up the table. Pointer
                pages are owned by one and only one table, there is no sharing allowed.
                Each pointer in the array on these pages holds the page number for a type
                5 page holding data for the table.</para>
            </listitem>

            <listitem>
                <para>0x05 - Data Page. These pages store the actual data for a
                table.</para>
            </listitem>

            <listitem>
                <para>0x06 - Index Root Page. Similar to a type 4 Pointer Page, but
                applies to indexes only.</para>
            </listitem>

            <listitem>
                <para>0x07 - Index B-Tree Page. Similar to the type 5 Data Page, but
                applies to indexex only.</para>
            </listitem>

            <listitem>
                <para>0x08 - Blob Page. Blobs have their own storage within the database.
                Very large blobs will require a sequence of pages and the type 8 page
                holds blob data.</para>
            </listitem>

            <listitem>
                <para>0x09 - Generator Page. Holds an array of 64 bit generators.</para>
            </listitem>

            <listitem>
                <para>0x0a - Page 2 of any database is a Write Ahead Log page. These pages
                are no longer used. The page will remain blank (filled with binary zero)
                as it is never used. This page has a standard header like all
                others.</para>
            </listitem>
        </itemizedlist>

        <formalpara>
            <title>Pag_flags</title>

            <para>One byte, unsigned. Byte 0x01 on the page. This byte holds various flags
            for the page.</para>
        </formalpara>

        <formalpara>
            <title>Pag_checksum</title>

            <para>Two bytes, unsigned. Bytes 0x02 - 0x03. Checksum for the whole page. No
            longer used, always 12345, 0x3039. Databases using ODS8 on Windows NT do have
            a valid checksum here.</para>
        </formalpara>

        <note>
            <para>Discussions are underway on the development mailing list on reusing this
            field as a page number rather than a checksum. From Firebird 3.0, it is
            possible that this field in the page header will probably have a new name and
            function.</para>
        </note>

        <formalpara>
            <title>Pag_generation</title>

            <para>Four bytes, unsigned. Bytes 0x04 - 0x07. The page generation number.
            Increments each time the page is written back to disc.</para>
        </formalpara>

        <formalpara>
            <title>Pag_scn</title>

            <para>Four bytes, unsigned. Bytes 0x08 - 0x0b. Originally used as the sequence
            number in the Write Ahead Log, but WAL is no longer used. The field was
            converted to be the SCN number to avoid an ODS change and is now used by
            <application>nbackup</application>.</para>
        </formalpara>

        <formalpara>
            <title>Pag_reserved</title>

            <para>Four bytes, unsigned. Bytes 0x0c - 0x0f. Reserved for future use. It was
            originally used for the offset of a page's entry in the Write Ahead Log (WAL),
            but this is no longer in use.</para>
        </formalpara>
    </section>

    <section id="fbint-page-1">
        <title>Database Header Page - Type 0x01</title>

        <para>The first page of the first file of a Firebird database is a very important
        page. It holds data that describes the database, where its other files are to be
        found, shadow file names, database page size, ODS version and so on. On startup,
        the Firebird engine reads the first part (1,024 bytes) of the first page in the
        first file of the database and runs a number of checks to ensure that the file is
        actually a database and so on. If the database is multi-file, then each file will
        have a header page of its own.</para>

        <para>The C code representation of the database header page is:</para>

        <programlisting>struct header_page
{
    pag hdr_header;
    USHORT hdr_page_size;
    USHORT hdr_ods_version;
    SLONG hdr_PAGES;
    ULONG hdr_next_page;
    SLONG hdr_oldest_transaction;
    SLONG hdr_oldest_active;
    SLONG hdr_next_transaction;
    USHORT hdr_sequence;
    USHORT hdr_flags;
    SLONG hdr_creation_date[2];
    SLONG hdr_attachment_id;
    SLONG hdr_shadow_count;
    SSHORT hdr_implementation;
    USHORT hdr_ods_minor;
    USHORT hdr_ods_minor_original;
    USHORT hdr_end;
    ULONG hdr_page_buffers;
    SLONG hdr_bumped_transaction;
    SLONG hdr_oldest_snapshot;
    SLONG hdr_backup_pages;
    SLONG hdr_misc[3];
    UCHAR hdr_data[1];
};
</programlisting>

        <formalpara>
            <title>Hdr_header</title>

            <para>The database header page has a standard page header, as do all
            pages.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_page_size</title>

            <para>Two bytes, unsigned. Bytes 0x10 - 0x11 on the page. This is the page
            size, in bytes, for each and every page in the database.</para>
        </formalpara>

        <formalpara>
            <title>Hds_ods_version</title>

            <para>Two bytes, unsigned. Bytes 0x12 and 0x13 on the page. The ODS major
            version for the database. The format of this word is the ODS major version
            ANDed with the Firebird flag of 0x8000. In the example below, the value is
            0x800b for ODS version 11. The minor ODS version is held elsewhere in the
            header page - see hdr_ods_minor below.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_pages</title>

            <para>Four bytes, signed. Bytes 0x14 - 0x17 on the page. This is the page
            number of the first pointer page for the table named RDB$PAGES. When this
            location is known, the database engine uses it to determine the locations of
            all other matadata pages in the database. This field is only valid in the
            header page of the <emphasis>first</emphasis> file in a multi-file database.
            The remaining files in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_next_page</title>

            <para>Four bytes, unsigned. Bytes 0x18 - 0x1b on the page. The page number of
            the header page in the next file of the database - if this is a multi-file
            database. Zero otherwise.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_oldest_transaction</title>

            <para>Four bytes, signed. Bytes 0x1c - 0x1f on the page. The transaction id of
            the oldest active (ie, uncommitted - but may be in limbo or rolled back)
            transaction against this database. This field is only valid in the header page
            of the <emphasis>first</emphasis> file in a multi-file database. The remaining
            files in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_oldest_active</title>

            <para>Four bytes, signed. Bytes 0x20 - 0x23 on the page. The transaction id of
            the oldest active transaction against this database, when any active
            transaction started. This field is only valid in the header page of the
            <emphasis>first</emphasis> file in a multi-file database. The remaining files
            in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_next_transaction</title>

            <para>Four bytes, signed. Bytes 0x24 - 0x27 on the page. The transaction id
            that will be assigned to the next transaction against this database. This
            field is only valid in the header page of the <emphasis>first</emphasis> file
            in a multi-file database. The remaining files in the database have this field
            set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_sequence</title>

            <para>Two bytes, unsigned. Bytes 0x28 and 0x29 on the page. The sequence
            number of this file within the database.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_flags</title>

            <para>Two bytes, unsigned. Bytes 0x2a and 0x2b on the page. The database
            flags. The bits in the flag bytes are used as follows:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="3">
                <colspec colname="flag" colwidth="4*" />

                <colspec colname="value" colwidth="4*" />

                <colspec colname="description" colwidth="12*" />

                <thead>
                    <row>
                        <entry align="center">Flag Name</entry>

                        <entry align="center">Flag value</entry>

                        <entry>Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>hdr_active_shadow</entry>

                        <entry>0x01 (bit 0)</entry>

                        <entry>This file is an active shadow file.</entry>
                    </row>

                    <row>
                        <entry>hdr_force_write</entry>

                        <entry>0x02 (bit 1)</entry>

                        <entry>The database is in <emphasis>forced writes</emphasis>
                        mode.</entry>
                    </row>

                    <row>
                        <entry>Unused</entry>

                        <entry>0x04 (bit 2)</entry>

                        <entry>Was previously for short term journalling, no longer
                        used.</entry>
                    </row>

                    <row>
                        <entry>Unused</entry>

                        <entry>0x08 (bit 3)</entry>

                        <entry>Was previously for long term journalling, no longer
                        used.</entry>
                    </row>

                    <row>
                        <entry>hdr_no_checksums</entry>

                        <entry>0x10 (bit 4)</entry>

                        <entry>Don't calculate checksums.</entry>
                    </row>

                    <row>
                        <entry>hdr_no_reserve</entry>

                        <entry>0x20 (bit 5)</entry>

                        <entry>Don'r reserve space for record versions in pages.</entry>
                    </row>

                    <row>
                        <entry>Unused</entry>

                        <entry>0x40 (bit 6)</entry>

                        <entry>Was used to indicate that the shared cache file was
                        disabled.</entry>
                    </row>

                    <row>
                        <entry>hdr_shutdown_mask (bit one of two)</entry>

                        <entry>0x1080 (bits 7 and 12)</entry>

                        <entry>Used with bit 12 (see below) to indicate the database
                        shutdown mode.</entry>
                    </row>

                    <row>
                        <entry>hdr_sql_dialect_3</entry>

                        <entry>0x100 (bit 8)</entry>

                        <entry>If set, the database is using SQL dialect 3.</entry>
                    </row>

                    <row>
                        <entry>hdr_read_only</entry>

                        <entry>0x200 (bit 9)</entry>

                        <entry>Database is in read only mode.</entry>
                    </row>

                    <row>
                        <entry>hdr_backup_mask</entry>

                        <entry>0xC00 (bits 10 and 11)</entry>

                        <entry>Indicates the current backup mode.</entry>
                    </row>

                    <row>
                        <entry>hdr_shutdown_mask (bit two of two)</entry>

                        <entry>0x1080 (bits 7 and 12)</entry>

                        <entry>Used with bit 7 (see above) to indicate the database
                        shutdown mode.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <para>The final two database flags use a pair of bits to indicate various states
        of backup and shutdown.</para>

        <formalpara>
            <title>Hdr_backup_mask</title>

            <para>These two bits determine the current database backup mode, as
            follows:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="2">
                <colspec colname="flag" colwidth="4*" />

                <colspec colname="description" colwidth="16*" />

                <thead>
                    <row>
                        <entry align="center">Flag Value</entry>

                        <entry align="center">Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>0x00 (Both bits zero)</entry>

                        <entry>Database is not in backup mode. User changes are written
                        directly to the database files.</entry>
                    </row>

                    <row>
                        <entry>0x400</entry>

                        <entry>The database is running in backup mode so all changed made
                        by the users are written to the diff file.</entry>
                    </row>

                    <row>
                        <entry>0x800</entry>

                        <entry>The database is still in backup mode, but changes are being
                        merged from the diff file into the main pages.</entry>
                    </row>

                    <row>
                        <entry>0xC00</entry>

                        <entry>The current database state is unknown and changes need to
                        be read from disc.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <formalpara>
            <title>Hdr_shutdown_mask</title>

            <para>The shutdown mask uses two bits to indicate the current database
            shutdown status, as follows:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="2">
                <colspec colname="flag" colwidth="4*" />

                <colspec colname="description" colwidth="16*" />

                <thead>
                    <row>
                        <entry align="center">Flag Value</entry>

                        <entry align="center">Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>0x00 (Both bits 7 and 12 are zero)</entry>

                        <entry>Database is not shutdown. Any valid user can
                        connect.</entry>
                    </row>

                    <row>
                        <entry>0x80</entry>

                        <entry>The database has been shutdown to, or started up in
                        multi-user maintenance mode. The database can only be conncted to
                        by SYSDBA or the database owner.</entry>
                    </row>

                    <row>
                        <entry>0x1000</entry>

                        <entry>The database has been fully shutdown. No connections are
                        permitted.</entry>
                    </row>

                    <row>
                        <entry>0x1080</entry>

                        <entry>The database has been shutdown to, or started up in
                        single-user maintenance mode. Only one SYSDBA or database owner
                        connection is permitted.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <formalpara>
            <title>Hdr_creation_date</title>

            <para>Eight bytes, signed. Bytes 0x2c - 0x33 on the page. The data and time
            (in Firebird's own internal format) that the database was either originally
            created/rewritten or created from a backup.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_attachment_id</title>

            <para>Four bytes, signed. Bytes 0x34 - 0x37 on the page. The id number that
            will be assigned to the next connection to this database. As this is signed,
            the maximum value here is 2<superscript>32</superscript>-1 and any database
            which reaches this maximum value must be backed up and restored in order to
            allow new connections. This field is only valid in the header page of the
            <emphasis>first</emphasis> file in a multi-file database. The remaining files
            in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_shadow_count</title>

            <para>Four bytes, signed. Bytes 0x38 - 0x3c on the page. Holds the event count
            for shadow file synchronisation for this database. The remaining files in the
            database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_implementation</title>

            <para>Two bytes, signed. Bytes 0x3c and 0x3d on the page. This is a number
            which indicates the environment on which the database was originally created.
            It is used to determine if the database file can be used sucessfully on the
            current hardware. This avoids problems caused by little-endian numerical
            values as compared with big-endian, for example.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_ods_minor</title>

            <para>Two bytes, unsigned. Bytes 0x3e and 0x3f on the page. The current ODS
            minor version.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_ods_minor_original</title>

            <para>Two bytes, unsigned. Bytes 0x40 and 0x41 on the page. The ODS minor
            version when the database was originally created.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_end</title>

            <para>Two bytes, unsigned. Bytes 0x42 and 0x43 on the page. The offset on the
            page where the hdr_data finishes. In other words, where a new clumplet will be
            stored if required. This is effectively a pointer to the current location of
            HDR_end (see clumplet details below) on this page.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_page_buffers</title>

            <para>Four bytes, unsigned. Bytes 0x44 - 0x47 on the page. Holds the number of
            buffers to be used for the database cache, or zero to indicate that the
            default value should be used. This field is only valid in the header page of
            the <emphasis>first</emphasis> file in a multi-file database. The remaining
            files in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_bumped_transaction</title>

            <para>Four bytes, signed. Bytes 0x48 - 0x4b on the page. Used to be used for
            the bumped transaction id for log optimisation, but is currently always set to
            0x01. This field is only valid in the header page of the
            <emphasis>first</emphasis> file in a multi-file database. The remaining files
            in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_oldest_snapshot</title>

            <para>Four bytes, signed. Bytes 0x4c - 0x4f on the page. Holds the transaction
            number for the oldest snapshot of active transactions. This is also documented
            as the <emphasis>confusing and redundant variant of Oldest Active
            Transaction</emphasis>.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_backup_pages</title>

            <para>Four bytes, signed. Bytes 0x50 - 0x53 on the page. Holds the number of
            pages in the database currently locked for a backup using nbackup. This field
            is only valid in the header page of the <emphasis>first</emphasis> file in a
            multi-file database. The remaining files in the database have this field set
            to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_misc</title>

            <para>Twelve bytes. Bytes 0x54 - 0x5f on the page. Set to zero. These 12 bytes
            are currently unused.</para>
        </formalpara>

        <para>The following is an example of a header page from a multi-file database on a
        little-endian system:</para>

        <screen>00000000  01 00 39 30 08 00 00 00  00 00 00 00 00 00 00 00  Standard header
00000010  00 10                                             hdr_page_size
00000012  0b 80                                             hdr_ods_version
00000014  03 00 00 00                                       hdr_PAGES
00000018  00 00 00 00                                       hdr_next_page
0000001c  01 00 00 00                                       hdr_oldest_transaction
00000020  02 00 00 00                                       hdr_oldest_active
00000024  05 00 00 00                                       hdr_next_transaction
00000028  00 00                                             hdr_sequence
0000002a  00 01                                             hdr_flags
0000002c  5e d7 00 00 f4 79 00 23                           hdr_creation_date
00000034  01 00 00 00                                       hdr_attachment_id
00000038  00 00 00 00                                       hdr_shadow_count
0000003c  13 00                                             hdr_implementation
0000003e  01 00                                             hdr_ods_minor
00000040  01 00                                             hdr_ods_minor_original
00000042  93 00                                             hdr_end
00000044  00 00 00 00                                       hdr_page_buffers
00000048  01 00 00 00                                       hdr_bumped_transaction
0000004c  02 00 00 00                                       hdr_oldest_snapshot
00000050  00 00 00 00                                       hdr_backup_pages
00000054  00 00 00 00 00 00 00 00 00 00 00 00               hdr_misc
00000060                                                    hdr_data[]
</screen>

        <note>
            <para>From Firebird 2.x onwards, there is a system table - MON$DATABASE which
            has a copy of all of the above data in an easy to obtain format:</para>

            <screen>tux&gt; isql employee
Database:  employee

SQL&gt; show table mon$database;
MON$DATABASE_NAME               (RDB$FILE_NAME) VARCHAR(253) Nullable
MON$PAGE_SIZE                   (RDB$PAGE_SIZE) SMALLINT Nullable
MON$ODS_MAJOR                   (RDB$ODS_NUMBER) SMALLINT Nullable
MON$ODS_MINOR                   (RDB$ODS_NUMBER) SMALLINT Nullable
MON$OLDEST_TRANSACTION          (RDB$TRANSACTION_ID) INTEGER Nullable
MON$OLDEST_ACTIVE               (RDB$TRANSACTION_ID) INTEGER Nullable
MON$OLDEST_SNAPSHOT             (RDB$TRANSACTION_ID) INTEGER Nullable
MON$NEXT_TRANSACTION            (RDB$TRANSACTION_ID) INTEGER Nullable
MON$PAGE_BUFFERS                (RDB$PAGE_BUFFERS) INTEGER Nullable
MON$SQL_DIALECT                 (RDB$SQL_DIALECT) SMALLINT Nullable
MON$SHUTDOWN_MODE               (RDB$SHUTDOWN_MODE) SMALLINT Nullable
MON$SWEEP_INTERVAL              (RDB$SWEEP_INTERVAL) INTEGER Nullable
MON$READ_ONLY                   (RDB$SYSTEM_FLAG) SMALLINT Nullable
MON$FORCED_WRITES               (RDB$SYSTEM_FLAG) SMALLINT Nullable
MON$RESERVE_SPACE               (RDB$SYSTEM_FLAG) SMALLINT Nullable
MON$CREATION_DATE               (RDB$TIMESTAMP) TIMESTAMP Nullable
MON$PAGES                       (RDB$COUNTER) BIGINT Nullable
MON$STAT_ID                     (RDB$STAT_ID) INTEGER Nullable
MON$BACKUP_STATE                (RDB$BACKUP_STATE) SMALLINT Nullable

SQL&gt; commit;
SQL&gt; quit;</screen>
        </note>

        <formalpara>
            <title>Hdr_data</title>

            <para>The variable data area on the header page begins at offset 0x60. Data
            stored here is held in clumplets and there are a number of different clumplet
            types, see below. This area is used to store filenames for the next file and
            other miscellaneous pieces of data relating to the database.</para>
        </formalpara>

        <para>The format of each clumplet is as follows:</para>

        <formalpara>
            <title>Type_byte</title>

            <para>The first byte - unsigned - in each clumplet determines the type of data
            stored within the clumplet. There are a number of different clumplet
            types:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="3">
                <colspec colname="name" colwidth="5*" />

                <colspec colname="value" colwidth="2*" />

                <colspec colname="description" colwidth="13*" />

                <thead>
                    <row>
                        <entry align="center">Type Name</entry>

                        <entry align="center">Value</entry>

                        <entry>Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>HDR_end</entry>

                        <entry>0x00</entry>

                        <entry>End of clumplets.</entry>
                    </row>

                    <row>
                        <entry>HDR_root_file_name</entry>

                        <entry>0x01</entry>

                        <entry>Original name of the root file for this database.</entry>
                    </row>

                    <row>
                        <entry>HDR_journal_server</entry>

                        <entry>0x02</entry>

                        <entry>Name of the journal server.</entry>
                    </row>

                    <row>
                        <entry>HDR_file</entry>

                        <entry>0x03</entry>

                        <entry>Secondary file name.</entry>
                    </row>

                    <row>
                        <entry>HDR_last_page</entry>

                        <entry>0x04</entry>

                        <entry>Last logical page of the current file.</entry>
                    </row>

                    <row>
                        <entry>HDR_unlicemsed</entry>

                        <entry>0x05</entry>

                        <entry>Count of unlicensed activity. No longer used.</entry>
                    </row>

                    <row>
                        <entry>HDR_sewwp_interval</entry>

                        <entry>0x06</entry>

                        <entry>Number of transactions between sweep.</entry>
                    </row>

                    <row>
                        <entry>HDR_log_name</entry>

                        <entry>0x07</entry>

                        <entry>Replay log name.</entry>
                    </row>

                    <row>
                        <entry>HDR_journal_file</entry>

                        <entry>0x08</entry>

                        <entry>Intermediate journal filename.</entry>
                    </row>

                    <row>
                        <entry>HDR_password_file_key</entry>

                        <entry>0x09</entry>

                        <entry>Key to compare with the password database.</entry>
                    </row>

                    <row>
                        <entry>HDR_backup_info</entry>

                        <entry>0x0a</entry>

                        <entry>Write Ahead Log (WAL) backup information. No longer
                        used.</entry>
                    </row>

                    <row>
                        <entry>HDR_cache_file</entry>

                        <entry>0x0b</entry>

                        <entry>Shared cache file. No longer used.</entry>
                    </row>

                    <row>
                        <entry>HDR_difference_file</entry>

                        <entry>0x0c</entry>

                        <entry>Diff file used during the times when the database is in
                        backup mode.</entry>
                    </row>

                    <row>
                        <entry>HDR_backup_guid</entry>

                        <entry>0x0d</entry>

                        <entry>UID generated when database is in backup mode. Overwritten
                        on subsequent backups.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <formalpara>
            <title>Length_byte</title>

            <para>The sceond byte - again unsigned - in each clumplet specifies the size
            of the data that follows.</para>
        </formalpara>

        <formalpara>
            <title>Data</title>

            <para>The next 'n' bytes are the actual clumplet data. The miscellaneous data
            stored in the header from the above database, at hdr_data, is shown
            below.</para>
        </formalpara>

        <screen>00000060  03                                                Type = HDR_file
00000061  2b                                                Length = 43 bytes
00000062  2f 75 30 30 2f 66 69 72  65 62 69 72 64 2f        Data '/u00/firebird/'
00000070  64 61 74 61 62 61 73 65  73 2f 6d 75 6c 74 69 5f      'databases/multi_'
00000080  65 6d 70 6c 6f 79 65 65  2e 66 64 62 31               'employee.fdb1'

0000008d  04                                                Type = HDR_last_page
0000008e  04                                                Length = 4 bytes
0000008f  a2 00 00 00                                       Data 0xa2 = 162

00000093  00                                                Type = HDR_end.</screen>

        <para>From the above we can see that in our multi-file database:</para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>The <emphasis>next</emphasis> file (after this one) is named
                '<filename>/u00/firebird/databases/multi_employee.fdb1</filename>'</para>
            </listitem>

            <listitem>
                <para>The <emphasis>current</emphasis> file has 162 pages only - and with
                a 4Kb page size this means that the current file should be 663,552 bytes
                in size, which a quick run of <command>ls -l</command> will
                confirm.</para>
            </listitem>

            <listitem>
                <para>HDR_end is located at offset 0x93 in the page, exactly as the header
                field hdr_end told us. (See above).</para>
            </listitem>
        </itemizedlist>
    </section>

    <section id="fbint-page-2">
        <title>Page Inventory Page - Type 0x02</title>

        <para>Every database has at least one Page Inventory Page (PIP) with the first one
        <emphasis>always</emphasis> being page 1, just after the database header page. If
        more are required, the current PIP points to the next PIP by way of the very last
        bit on the page itself. The C code representation of the PIP page is:</para>

        <programlisting>struct page_inv_page
{
    pag pip_header;
    SLONG pip_min;
    UCHAR pip_bits[1];
}; </programlisting>

        <formalpara>
            <title>Pip_header</title>

            <para>The PIP starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Pip_min</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13 on the page. This is the bit
            number of the first page, on this PIP, which is currently free for use.</para>
        </formalpara>

        <formalpara>
            <title>Pip_bits</title>

            <para>Bytes 0x14 onwards. The remainder of the page, is an array of single
            bits where each bit represents a page in the database. If the bit is set (1)
            then that page is free for use. If the bit is unset (0) then the page has been
            used.</para>
        </formalpara>

        <para>If the database is large, and requires another PIP elsewhere in the
        database, then the last bit on this PIP represents the page number for the next
        PIP. For example, on a 4,096 byte page we have a total of 4,076 bytes to represent
        different pages in the database. As each byte has 8 bits, we have a total of
        32,608 pages before we need a new PIP.</para>

        <para>In a brand new database, a hex dump of the first few bytes of page 1, the
        first PIP, looks like the following:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
00001000  02 00 39 30 31 00 00 00  00 00 00 00 a1 00 00 00  Standard Header
00001010  a1 00 00 00                                       pip_min (low endian)
00001014  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  pip_bits[]
00001024  00 00 00 00 fe ff ff ff  ff ff ff ff ff ff ff ff
</screen>

        <para>In the above, we see that pip_min has the value 0x000000a1 and the following
        20 bytes, the first part of the pip_bits array, are all zero. From this, it would
        appear that page 0xa1 is the first available page in the database for user tables
        etc and that all the pages up to that one have already been used for the system
        tables and indices etc.</para>

        <para>Looking at the bitmap again, page 0xa1 will be represented by byte 0x14, bit
        0x01 of the bitmap. This is byte 0x00001028 bit 1. We can see that this byte
        currently has the value 0xfe and bit 0x00 is already in use. So, our array is
        correct and so is our pip_min value - the next available page is indeed
        0xa1.</para>

        <para>If we look at the hexdump of that particular page, at address 0x000a1000, we
        see that it is actually the first byte past the current end of file, so our brand
        new blank database has been created with just enough space to hold all the system
        tables and indexes and nothing else.</para>
    </section>

    <section id="fbint-page-3">
        <title>Transaction Inventory Page - Type 0x03</title>

        <para>Every database has at least one Transaction Inventory Page (TIP). If more
        are required, the current PIP points to the next PIP by way of the very last bit
        on the page itself.</para>

        <para>The highest possible transaction number is 2,147,483,647 or 0x7fffffff in a
        32 bit system. Once you hit this transaction, no more can be created and the
        database needs to be shutdown, backed up and then restored to reset the
        transaction numbers back to zero. The reason it has this maximum value is simply
        because the code for</para>

        <para>The C code representation of the TIP page is:</para>

        <programlisting>struct tx_inv_page
{
    pag tip_header;
    SLONG tip_next;
    UCHAR tip_transactions[1];
};</programlisting>

        <formalpara>
            <title>Tip_header</title>

            <para>The TIP starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Tip_next</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13 on the page. This is the page
            number of the next TIP page, if one exists, within the database. Zero here
            indicates that the current TIP page is the last TIP page.</para>
        </formalpara>

        <formalpara>
            <title>Tip_transactions</title>

            <para>Bytes 0x14 onwards. The remainder of the page, is an array of two bit
            values where each pair of bits represents a transaction and its status. Each
            transaction can have one of 4 status values:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>0x00 - this transaction is active, or has not yet started.</para>
            </listitem>

            <listitem>
                <para>0x01 - this transaction is in limbo. A two phase transaction has
                committed the first phase but the second phase has not committed.</para>
            </listitem>

            <listitem>
                <para>0x02 - this transaction is dead (was rolled back).</para>
            </listitem>

            <listitem>
                <para>0x03 - this transaction was committed.</para>
            </listitem>
        </itemizedlist>

        <para>Looking at a hex dump of the first few bytes of a new database, which has
        had a few transactions run against it, we see the following:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
000a0014  fc ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  tip_transactions[]
000a0024  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
000a0034  ff ff ff ff ff ff ff ff  ff ff ff ff ff 00 00 00
</screen>

        <para>Now, if a new transaction starts we won't see any changes because a live
        transaction and one that has not started yet, shows up as two zero bits in the
        tip_transactions array. However, if it commits, limbo's or rollsback, we should
        see a change. The following is the above database after a session connected using
        isql and immediately exited without doing anything:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
000a0014  fc ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  tip_transactions[]
000a0024  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
000a0034  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff 00 00
</screen>

        <para>You can see that it looks remarkably like loading up a connection to
        <application>isql</application> and then exiting actually executes 4 separate
        transactions. We can see at the end of the last line that one byte has changed
        from 0x00 to 0xff and with 2 bits per transaction, that equates to 4 separate
        transactions, all of which committed.</para>

        <para>Other tools may run fewer or indeed, more, transaction just to connect to a
        database and do whatever it is that they have to do to initialise
        themselves.</para>
    </section>

    <section id="fbint-page-4">
        <title>Pointer Page - Type 0x04</title>

        <para>A pointer page is used internally to hold a list of all - or as may will fit
        on one pointer page - data pages (see below) that make up a single table. Large
        tables may have more than one pointer page but every table, system or user, will
        have a minimum of one pointer page. The RDB$PAGES table is where the Firebird
        engin looks to find out where a table is located within the physical database,
        however, RDB$PAGES is itself a table, and when the database is running, how
        exactly can it find the start page for RDB$PAGES in order to look it up?</para>

        <para>The database header page contains the page number for RDB$PAGES at bytes
        0x14 - 0x17 on the page. From experimentation, it appears as if this is always
        page 0x03, however, this cannot be relied upon and if you need to do this, you
        should always check the database header page to determine where RDB$PAGES is to be
        found.</para>

        <para>The C code representation of a pointer page is:</para>

        <programlisting>struct pointer_page
{
    pag ppg_header;
    SLONG ppg_sequence;
    SLONG ppg_next;
    USHORT ppg_count;
    USHORT ppg_relation;
    USHORT ppg_min_space;
    USHORT ppg_max_space;
    SLONG ppg_page[1];
};
</programlisting>

        <formalpara>
            <title>Ppg_header</title>

            <para>A pointer page starts with a standard page header. In the header, the
            pag_flags field is used and is set to the value 1 if this is the final pointer
            page for the relation.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_sequence</title>

            <para>Four bytes, signed. Offset 0x10 to 0x13 on the page. The sequence number
            of this pointer page in the list of pointer pages for the table. Starts at
            zero.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_next</title>

            <para>Four bytes, signed. Offset 0x14 to 0x17 on the page. The page number of
            the next pointer page for this table. Zero indicates that this is the final
            pointer page.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_count</title>

            <para>Two bytes, unsigned. Offset 0x18 and 0x19 on the page. This field holds
            the count of active slots (in the ppg_page[] array) on this pointer page, that
            are in use. As the array starts at zero, this is also the index of the first
            free slot on this pointer page.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_relation</title>

            <para>Two bytes, unsigned. Offset 0x1a and 0x1b on the page. This field holds
            the RDB$RELATIONS.RDB$REALTION_ID for the table that this pointer page
            represents.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_min_space</title>

            <para>Two bytes, unsigned. Offset 0x1c and 0x1d on the page. This indicates
            the first entry in the ppg_page array holding a page number which has free
            space in the page.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_max_space</title>

            <para>Two bytes, unsigned. Offset 0x1e and 0x1f on the page. This was intended
            to indicate the last entry in the ppg_page array holding a page number which
            has free space in the page, but it has never been used. These two bytes are
            invariably set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_page</title>

            <para>An array of four byte signed values, starting at offset 0x20. Each value
            in this array represents a page number where a part of the current table is to
            be found. A value of zero in a slot indicates that the slot is not in use.
            Deleteing all the data from a table will result in all slots being set to
            zero.</para>
        </formalpara>

        <formalpara>
            <title>Page fill bitmaps</title>

            <para>At the end of each pointer page is a bitmap array of two bit entries
            which is indexed by the same index as the ppg_page array. These bitmaps
            indicate that the page is available for use in storing records (or record
            versions) or not. The two bits in the bitmap indicate whether a large object
            (BLOB?) is on this page and the other bit indicates that the page is full. If
            either bit is set (page has a large object or page is full, then the page is
            not used for new records or record versions.</para>
        </formalpara>

        <para>The location of the bitmaps on each page is dependent on the page size. The
        bigger the page, the more slots in the ppg_page array it can hold and so the
        bitmap is bigger. A bigger bitmap starts at a lower address in the page and so on.
        From lookiing inside a few databases with a 4Kb page size, the bitmaps begin at
        offset 0x0f10 on the page.</para>

        <para>You can find the pointer page for any table by running something like the
        following query in <application>isql</application>:</para>

        <screen>SQL&gt; SELECT P.RDB$PAGE_NUMBER, P.RDB$PAGE_SEQUENCE, P.RDB$RELATION_ID
CON&gt; FROM RDB$PAGES P
CON&gt; JOIN RDB$RELATIONS R ON (R.RDB$RELATION_ID = P.RDB$RELATION_ID)
CON&gt; WHERE R.RDB$RELATION_NAME = 'EMPLOYEE'
CON&gt; AND P.RDB$PAGE_TYPE = 4;

RDB$PAGE_NUMBER RDB$PAGE_SEQUENCE RDB$RELATION_ID
=============== ================= ===============
            180                 0             131
</screen>

        <para>The page number which has RDB$PAGE_SEQUENCE holding the value zero is the
        top level pointer page for this table. In the above example, there is only one
        pointer page for the EMPLOYEE table. If we now hexdump the pointer page for the
        employee table, we see the following:</para>

        <screen>000b4000  04 01 39 30 02 00 00 00  00 00 00 00 00 00 00 00  Standard header
000b4010  00 00 00 00                                       Ppg_sequence
000b4014  00 00 00 00                                       Ppg_next
000b4018  02 00                                             Ppg_count
000b401a  83 00                                             Ppg_relation
000b401c  01 00                                             Ppg_min_space
000b401e  00 00                                             Ppg_max_space
000b4020  ca 00 00 00                                       Ppg_page[0]
000b4024  cb 00 00 00                                       Ppg_page[1]
000b4028  00 00 00 00                                       Ppg_page[2]
000b402c  00 00 00 00                                       Ppg_page[3]
...
000b4f10  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000b4f20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</screen>

        <para>Looking at the above, we can see at address 0x0b4f10 on the page, that the
        byte there has the value of 0x01. This is an indicator that the page in
        ppg_page[0] - page 0xca - is full to capacity (bit 0 set) and does not have any
        large objects on the page (bit 1 unset). The page at ppg_page[1] - page 0xcb - is,
        on the other hand, not full up yet (bit 2 is unset) and doesn't have a large
        object on the page either. This means that this page is avilable for us.</para>

        <para>This is confirmed by checking the value in ppg_min_space which has the value
        0x0001 and does indeed correspond to the first page with free space. The value in
        ppg_min_space is the index into the ppg_array and not the page number
        itself.</para>
    </section>

    <section id="fbint-page-5">
        <title>Data Page - Type 0x05 - YOU ARE HERE</title>

        <para>A data page belongs exclusively to a single table. The page starts off, as
        usual, with the standard page header and is followed by an array of pairs of
        unsigned two byte values representing the 'table of contents' for this page. This
        array fills from the top of the page (lowest address, increasing) while the actual
        data it points to is stored on the page and fills from the bottom of the page
        (highest address, descending).</para>

        <para>The C code representation of a data page is:</para>

        <programlisting>struct data_page
{
    pag dpg_header;
    SLONG dpg_sequence;
    USHORT dpg_relation;
    USHORT dpg_count;
    struct dpg_repeat {
        USHORT dpg_offset;
        USHORT dpg_length;
    } dpg_rpt[1];
};
</programlisting>

        <formalpara>
            <title>Dpg_header</title>

            <para>The page starts with a standard page header. In this page type, the
            pag_flags byte is used as follows:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>Bit 0 - dpg_orphan. Setting this bit indicates that this page is an
                orphan - it has no entry in the pointer page for this relation. This may
                indicate a possible database corruption.</para>
            </listitem>

            <listitem>
                <para>Bit 1 - dpg_full. Setting this bit indicates that the page is full
                up. This will be also seen in the bitmap array on the corresponding
                pointer page for this table.</para>
            </listitem>

            <listitem>
                <para>Bit 2 - dpg_large. Setting this bit indicates that a large object is
                stored on this page. This will be also seen in the bitmap array on the
                corresponding pointer page for this table.</para>
            </listitem>
        </itemizedlist>

        <formalpara>
            <title>Dpg_sequence</title>

            <para>Four bytes, signed. Offset 0x10 on the page. This field holds the
            sequence number for this page in the list of pages assigned to this table
            within the database. The first page of any table has sequence zero.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_relation</title>

            <para>Two bytes, unsigned. Offset 0x12 on the page. The relation number for
            this table. This corresponds to RDB$RELATIONS.RDB$RELATION_ID.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_count</title>

            <para>Two bytes, unsigned. Offset 0x14 on the page. The number of records (or
            record fragments) on this page. In other words, the number of entries in the
            dpg_rpt array.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_rpt</title>

            <para>This is an array of two byte unsigned values. The array begins at offset
            0x18 on the page and counts upwards from the low address to the higher address
            as each new record fragment is added.</para>
        </formalpara>

        <para>The two fields in this array are:</para>

        <formalpara>
            <title>Dpg_offset</title>

            <para>Two bytes, unsigned. The offset on the page where the record fragment
            starts. If the value here is zero and the length is zero, then this is an
            unused array entry. The offset is from the start address of the page. For
            example, if the offset is 0x0fc8 and this is a database with a 4Kb page size,
            and the page in question is page 0xcd (205 decimal) then we have the offset of
            0xcdfc8 because 0xcd000 is the actual address (in the database file) of the
            start of the page.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_length</title>

            <para>Two bytes, unsigned. The length of this record fragment in bytes.</para>
        </formalpara>

        <para>The raw record data is structured into a header and the data.</para>

        <section>
            <title>Record Header</title>

            <para>Each record's data is preceeded by a record header. The format of the
            header is shown below. Note that there are two different record headers, one
            for fragmented records and the other for unfragmented records.</para>

            <screen>// Record header for unfragmented records.
struct rhd {
    SLONG rhd_transaction;
    SLONG rhd_b_page;
    USHORT rhd_b_line;
    USHORT rhd_flags;
    UCHAR rhd_format;
    UCHAR rhd_data[1];
};

/* Record header for fragmented record */
struct rhdf {
    SLONG rhdf_transaction;
    SLONG rhdf_b_page;
    USHORT rhdf_b_line;
    USHORT rhdf_flags;
    UCHAR rhdf_format;
    SLONG rhdf_f_page;
    USHORT rhdf_f_line;
    UCHAR rhdf_data[1];
};
</screen>

            <para>Both headers are identical up to the rhd_format field. In the case of an
            unfragmented record there are no more fields in the header while the header
            for a fragmented record has a few more fields. How to tell the difference? See
            the details of the rdf_flags field below.</para>

            <formalpara>
                <title>Rhd_transaction</title>

                <para>Four bytes, signed. Offset 0x00 in the header. This is the id of the
                transaction that created this record.</para>
            </formalpara>

            <formalpara>
                <title>Rhd_b_page</title>

                <para>Four bytes, signed. Offset 0x04 in the header. This is the record's
                back pointer page.</para>
            </formalpara>

            <formalpara>
                <title>Rhd_b_line</title>

                <para>Two bytes, unsigned. Offset 0x08 in the header. This is the record's
                back line pointer.</para>
            </formalpara>

            <formalpara>
                <title>Rhd_flags</title>

                <para>Two bytes, unsigned. Offset 0x0a in the header. The flags for this
                record or record fragment. The flags are discussed below.</para>
            </formalpara>

            <formalpara>
                <title>Rhd_format</title>

                <para>One byte, unsigned. Offset 0x0c in the header. The record format
                version.</para>
            </formalpara>

            <formalpara>
                <title>Rhd_data</title>

                <para>Unsigned byte data. Offset 0x0d in the header. This is the start of
                the compressed data. For a fragmented record header, this field is not
                applicable.</para>
            </formalpara>

            <para>The following only apply to the fragmented record header. For an
            unfragmented record, the data begins at offset 0x0d. Fragmented records store
            their data at offset 0x16.</para>

            <formalpara>
                <title>Rhdf_f_page</title>

                <para>Four bytes, signed. Offset 0x10 (Padding bytes inserted). The page
                number on which the next fragment of this record can be found.</para>
            </formalpara>

            <formalpara>
                <title>Rhdf_f_line</title>

                <para>Two bytes, unsigned. Offset 0x14. The line number on which the next
                fragment for this record can be found.</para>
            </formalpara>

            <formalpara>
                <title>Rhdf_data</title>

                <para>Unsigned byte data. Offset 0x16 in the header. This is the start of
                the compressed data for this record fragment.</para>
            </formalpara>

            <screen>const USHORT rhd_deleted        = 1;        /* record is logically deleted */
const USHORT rhd_chain            = 2;        /* record is an old version */
const USHORT rhd_fragment        = 4;        /* record is a fragment */
const USHORT rhd_incomplete        = 8;        /* record is incomplete */
const USHORT rhd_blob            = 16;        /* isn't a record but a blob */
const USHORT rhd_stream_blob    = 32;        /* blob is a stream mode blob */
const USHORT rhd_delta            = 32;        /* prior version is differences only */
const USHORT rhd_large            = 64;        /* object is large */
const USHORT rhd_damaged        = 128;        /* object is known to be damaged */
const USHORT rhd_gc_active        = 256;        /* garbage collecting dead record version */
</screen>
        </section>

        <section>
            <title>Record Data</title>

            <para>Record data is always compressed, even if it cannot actually be
            compressed. The compression is a type know as Run Length Encoding (RLE) where
            a sequence of repeating characters is reduced to a control character that
            determines the repeat count followed by the actual character to be repeated.
            Where data cannot be compressed, the control character indicates that "the
            next 'n' characters are to be output unchanged'.</para>

            <para>The control character is a negative value where it indicates a repeating
            character and is a positive byte where the following data must be copied
            exactly. The actual value of the control character tells the expansion code
            how many times to repeat the next byte or how many of the following bytes are
            output unchanged.</para>

            <para>The data in a record is not compressed based on data found in a
            previously inserted record - it cannot be. If you have the word 'Firebird' in
            two records, it will be stored in full in both.</para>

            <para>Repeating short strings sich as 'abcabcabc' are also not compressed.
            (Maybe an enhancement for the future?)</para>

            <para>Once the compression of the data in a column has been expanded, the data
            consists of three parts - a field header, the actual data and, if necessary,
            some padding bytes.</para>

            <para>The following section shows a worked example of an examination of a
            table and it's data.</para>
        </section>

        <section>
            <title>A Worked Example</title>

            <para>The shows an internal examination of a Firebird Data Page. For this very
            simple example, the following code was executed to create a test table and
            load it with some character data:</para>

            <screen>SQL&gt; CREATE TABLE NORMAN(A VARCHAR(100));
SQL&gt; COMMIT;

SQL&gt; INSERT INTO NORMAN VALUES ('Firebird');
SQL&gt; INSERT INTO NORMAN VALUES ('Firebird Book');
SQL&gt; INSERT INTO NORMAN VALUES ('666');
SQL&gt; INSERT INTO NORMAN VALUES ('abcabcabcabcabcabcabcabcd');
SQL&gt; INSERT INTO NORMAN VALUES ('AaaaaBbbbbbbbbbCccccccccccccccDD');
SQL&gt; COMMIT;

SQL&gt; INSERT INTO NORMAN VALUES (NULL);
SQL&gt; COMMIT;
</screen>

            <para>We now have a table and some data inserted by a pair of different
            transactions, where is the table (and data) stored in the database? First of
            all we need the relation id for the new table. We get this from
            <database>RDB$RELATIONS</database> as follows:</para>

            <screen>SQL&gt; SELECT RDB$RELATION_ID FROM RDB$RELATIONS
CON&gt; WHERE RDB$RELATION_NAME = 'NORMAN';

RDB$RELATION_ID
===============
            129</screen>

            <para>Given the relation id, we can interrogate <database>RDB$PAGES</database>
            to find out where out pointer page (page type 0x04) lives in the
            database:</para>

            <screen>SQL&gt; SELECT * FROM RDB$PAGES 
CON&gt; WHERE RDB$RELATION_ID = 129
CON&gt; AND RDB$PAGE_TYPE = 4;

RDB$PAGE_NUMBER RDB$RELATION_ID RDB$PAGE_SEQUENCE RDB$PAGE_TYPE
=============== =============== ================= =============
            162             129                 0             4
</screen>

            <para>From the above query, we see that page number 162 in the database is
            where the pointer page for this table is to be found. As described above, the
            pointer page holds the list of all the page numbers that belong to this table.
            If we look at the pointer page for our table, we see the following:</para>

            <screen>tux&gt; ./fbdump ../blank.fdb -p 162

Page Buffer allocated. 4096 bytes at address 0x804b008
Page Offset = 663552l

DATABASE PAGE DETAILS
=====================
        Page Type:          4
        Sequence:           0
        Next:               0
        Count:              1
        Relation:           129
        Min Space:          0
        Max Space:          0

        Page[0000]:         166

Page Buffer freed from address 0x804b008
</screen>

            <para>We can see from the above that this is indeed the pointer page (type
            0x04) for our table (relation is 129) . The count value shows that there is a
            single data page for this table and that page is page 166. If we now dump page
            166 we can see the following:</para>

            <screen>tux&gt; ./fbdump ../blank.fdb -p 166
Page Buffer allocated. 4096 bytes at address 0x804b008
Page Offset = 679936l


DATABASE PAGE DETAILS
=====================
        Page Type:          5
        Sequence:           0
        Relation:           130
        Count:              6
        Page Flags:         0: Not an Orphan Page:Page has space:No Large Objects

        Data[0000].offset:  4064
        Data[0000].length:  30

        Data[0000].header
        Data[0000].header.transaction:  343
        Data[0000].header.back_page:    0
        Data[0000].header.back_line:    0
        Data[0000].header.flags:     0000:No Flags Set
        Data[0000].header.format:
        Data[0000].hex:     01 fe fd 00 0a 08 00 46 69 72 65 62 69 72 64 a4
                            00
        Data[0000].ASCII:    .  .  .  .  .  .  .  F  i  r  e  b  i  r  d  .
                             .

        Data[0001].offset:  4028
        Data[0001].length:  35

        Data[0001].header
        Data[0001].header.transaction:  343
        Data[0001].header.back_page:    0
        Data[0001].header.back_line:    0
        Data[0001].header.flags:     0000:No Flags Set
        Data[0001].header.format:
        Data[0001].hex:     01 fe fd 00 0f 0d 00 46 69 72 65 62 69 72 64 20
                            42 6f 6f 6b a9 00
        Data[0001].ASCII:    .  .  .  .  .  .  .  F  i  r  e  b  i  r  d
                             B  o  o  k  .  .

        Data[0002].offset:  4004
        Data[0002].length:  24

        Data[0002].header
        Data[0002].header.transaction:  343
        Data[0002].header.back_page:    0
        Data[0002].header.back_line:    0
        Data[0002].header.flags:     0000:No Flags Set
        Data[0002].header.format:
        Data[0002].hex:     01 fe fd 00 02 03 00 fd 36 9f 00
        Data[0002].ASCII:    .  .  .  .  .  .  .  .  6  .  .

        Data[0003].offset:  3956
        Data[0003].length:  47

        Data[0003].header
        Data[0003].header.transaction:  343
        Data[0003].header.back_page:    0
        Data[0003].header.back_line:    0
        Data[0003].header.flags:     0000:No Flags Set
        Data[0003].header.format:
        Data[0003].hex:     01 fe fd 00 1b 19 00 61 62 63 61 62 63 61 62 63
                            61 62 63 61 62 63 61 62 63 61 62 63 61 62 63 64
                            b5 00
        Data[0003].ASCII:    .  .  .  .  .  .  .  a  b  c  a  b  c  a  b  c
                             a  b  c  a  b  c  a  b  c  a  b  c  a  b  c  d
                             .  .

        Data[0004].offset:  3920
        Data[0004].length:  36

        Data[0004].header
        Data[0004].header.transaction:  343
        Data[0004].header.back_page:    0
        Data[0004].header.back_line:    0
        Data[0004].header.flags:     0000:No Flags Set
        Data[0004].header.format:
        Data[0004].hex:     01 fe fd 00 03 20 00 41 fc 61 01 42 f7 62 01 43
                            f2 63 02 44 44 bc 00
        Data[0004].ASCII:    .  .  .  .  .     .  A  .  a  .  B  .  b  .  C
                             .  c  .  D  D  .  .

        Data[0005].offset:  3896
        Data[0005].length:  22

        Data[0005].header
        Data[0005].header.transaction:  345
        Data[0005].header.back_page:    0
        Data[0005].header.back_line:    0
        Data[0005].header.flags:     0000:No Flags Set
        Data[0005].header.format:
        Data[0005].hex:     01 ff 97 00 00 00 00 00 00
        Data[0005].ASCII:    .  .  .  .  .  .  .  .  .
Page Buffer freed from address 0x804b008

</screen>

            <para>We can see from the above, the records appear in the order we inserted
            them. Do not be misled - if I was to delete one or more records and then
            insert new ones, Firebird could reuse some or all of the newly deleted space,
            so record 1, for example, might appear in the "wrong" place in a dump as
            above.</para>

            <note>
                <para>This is a rule of relational databases, you can never know the order
                that data will be returned by a SELECT statement unless you specifically
                use an ORDER BY.</para>
            </note>

            <para>We can see from the above that Firebird doesn't attempt to compress data
            based on the contents of previous records. The word 'Firebird' appears in full
            each and every time it is used.</para>

            <para>We can see, however, that data that has repeating characters - for
            example '666' and 'AaaaaBbbbbbbbbbCccccccccccccccDD' - do get compressed - but
            records with repeating consecutive strings of characters do not get
            compressed.</para>
        </section>

        <section>
            <title>Examining The Data</title>

            <para>Looking into how the compression works for the above example is the next
            step.</para>

            <section>
                <title>Uncompressed Data</title>

                <para>The first record we inserted is 'uncompressed' in that it has no
                repeating characters. It is represented internally as follows:</para>

                <screen>        Data[0000].offset:  4064
        Data[0000].length:  30

        Data[0000].header
        Data[0000].header.transaction:  343
        Data[0000].header.back_page:    0
        Data[0000].header.back_line:    0
        Data[0000].header.flags:     0000:No Flags Set
        Data[0000].header.format:
        Data[0000].hex:     01 fe fd 00 0a 08 00 46 69 72 65 62 69 72 64 a4
                            00
        Data[0000].ASCII:    .  .  .  .  .  .  .  F  i  r  e  b  i  r  d  .
                             .
</screen>

                <para>The offset indicates where on the page this piece of data is to be
                found. This value is relative to the the start of the page and is the
                location of the first byte of the record header.</para>

                <para>The length is the size of the compressed data piece and includes the
                size of the header as well as the data itself.</para>

                <para>In the above, the record header details have been translated into
                meaningful comments. The data itself starts at the location labelled
                'Data[0000].hex:'.</para>
            </section>

            <section>
                <title>Compressed Data</title>

                <para>Record number 4 has quite a lot of compression applied to it. The
                stored format of the record's data is as follows:</para>

                <screen>        Data[0004].offset:  3920
        Data[0004].length:  36

        Data[0004].header
        Data[0004].header.transaction:  343
        Data[0004].header.back_page:    0
        Data[0004].header.back_line:    0
        Data[0004].header.flags:     0000:No Flags Set
        Data[0004].header.format:
        Data[0004].hex:     01 fe fd 00 03 20 00 41 fc 61 01 42 f7 62 01 43
                            f2 63 02 44 44 bc 00
        Data[0004].ASCII:    .  .  .  .  .     .  A  .  a  .  B  .  b  .  C
                             .  c  .  D  D  .  .</screen>

                <para>If we ignore the translated header details and concentrate on the
                data only, we see that it starts with a control byte. The first byte in
                the data is always a control byte.</para>

                <para>In this case, the byte is positive and has the value 0x01, so the
                following one byte is to be copied to the output. The output appears as
                follws at this point with ASCII characters below hex values, unprintable
                characters are shows as a dot:</para>

                <screen>        fe
         .</screen>

                <para>After the unchanged byte, we have another control byte with value
                0xfd which is negative and represents minus 3. This means that we must
                repeat the byte following the control byte abs(-3) times. The data now
                looks like this:</para>

                <screen>        fe 00 00 00
         .  .  .  .</screen>

                <para>Again, we have a control byte of 0x03. As this is positive the next
                0x03 bytes are copied to the output unchanged giving us the
                following:</para>

                <screen>        fe 00 00 00 20 00 41
         .  .  .  .     .  A</screen>

                <para>The next byte is another control byte and as it is negative (0xfc or
                -4) we repeat the next character 4 times. The data is now:</para>

                <screen>        fe 00 00 00 20 00 41 61 61 61 61
         .  .  .  .     .  A  a  a  a  a</screen>

                <para>Repeat the above process of reading a control byte and outputting
                the appropriate characters accordingly until we get the following:</para>

                <screen>        fe 00 00 00 20 00 41 61 61 61 61 42 62 62 62 62 62 62 62 62 62 43  
         .  .  .  .     .  A  a  a  a  a  B  b  b  b  b  b  b  b  b  b  C

        63 63 63 63 63 63 63 63 63 63 63 63 63 63 44 44
         c  c  c  c  c  c  c  c  c  c  c  c  c  c  D  D</screen>

                <note>
                    <para>I've had to split the above over a couple of lines to prevent it
                    wandering off the page when rendered as a PDF file.</para>
                </note>

                <para>We then have another control byte of 0xbc which is -68 and indicates
                that we need 68 copies of the following byte (0x00). This is the 'padding'
                at the end of our actual data (32 bytes in total) to make up the full 100
                bytes of the VARCHAR(100) data type.</para>
            </section>

            <section>
                <title>Null</title>

                <para>The final record inserted into the table is the one with no data, it
                is NULL. The internal storage is as follows:</para>

                <screen>        Data[0005].offset:  3896
        Data[0005].length:  22

        Data[0005].header
        Data[0005].header.transaction:  345
        Data[0005].header.back_page:    0
        Data[0005].header.back_line:    0
        Data[0005].header.flags:     0000:No Flags Set
        Data[0005].header.format:
        Data[0005].hex:     01 ff 97 00 00 00 00 00 00
        Data[0005].ASCII:    .  .  .  .  .  .  .  .  .</screen>

                <para>We can see that in the record header, the transaction id is
                different to the other records we inserted. This is because we added a
                COMMIT before we inserted this row.</para>
            </section>
        </section>
    </section>

    <section id="fbint-page-6">
        <title>Index Root Page - Type 0x06</title>

        <para>Every table in the database has an Index Root Page which holds data that
        describes the indexes for that table. Even tables that have no indices defined
        have an index root page.</para>

        <para>The C code representation of an index root page is:</para>

        <programlisting>struct index_root_page
{
    pag irt_header;
    USHORT irt_relation;
    USHORT irt_count;
    struct irt_repeat {
        SLONG irt_root;
        union {
            float irt_selectivity;
            SLONG irt_transaction;
        } irt_stuff;
        USHORT irt_desc;
        UCHAR irt_keys;
        UCHAR irt_flags;
    } irt_rpt[1];
};
</programlisting>

        <formalpara>
            <title>Irt_header</title>

            <para>The page starts with a standard page header. The flags byte - pag_flags
            - is not used on this page type.</para>
        </formalpara>

        <formalpara>
            <title>Irt_relation</title>

            <para>Two bytes, unsigned. Offset 0x10 on the page. The relation id. This is
            the value of RDB$RELATIONS.RDB$RELATION_ID.</para>
        </formalpara>

        <formalpara>
            <title>Irt_count</title>

            <para>Two bytes, unsigned. Offset 0x12 on the page. The number of indices
            defined for this table. If there are no indices defined this counter will show
            the value zero. (Every table in the database has an Index Root Page regardless
            of whether or not it has any indices defined.)</para>
        </formalpara>

        <formalpara>
            <title>Irt_rpt</title>

            <para>This is an array of index descriptors. The array begins at offset 0x14
            on the page with the descriptor for the first index defined for the table.
            Descriptors are added to the 'top' of the array so the next index defined will
            have its descriptor at a higher page address than the previous descriptor. The
            descriptor entries consist of the following 6 fields (irt_root through
            irt_flags). Each descriptor is 0x0b bytes long.</para>
        </formalpara>

        <formalpara>
            <title>Irt_root</title>

            <para>Four bytes, signed. Offset 0x00 in each descriptor array entry. This
            field is the page number where the root page for the individual index (page
            type 0x07) is located.</para>
        </formalpara>

        <formalpara>
            <title>Irt_selectivity</title>

            <para>From ODS version 11.0, this field is no longer used as selectivity has
            been moved to the index field descriptors (see below). Offset 0x04 in each
            descriptor array entry. This is the same offset as for irt_transaction below.
            In ODS versions below 11.0 this field holds the index selectivity in floating
            point format.</para>
        </formalpara>

        <formalpara>
            <title>Irt_transaction</title>

            <para>Four bytes, signed. Offset 0x04 in each descriptor array entry - the
            same offset as irt_selectivity above. Normally this field will be zero but if
            an index is in the process of being created, the transaction id will be found
            here.</para>
        </formalpara>

        <formalpara>
            <title>Irt_desc</title>

            <para>Two bytes, unsigned. Offset 0x08 in each descriptor array entry. This
            field holds the offset, from the start of the page, to the index field
            descriptors which are located at the bottom end (ie, highest addresses) of the
            page. To calculate the starting address, add the value in this field to the
            address of the start of the page.</para>
        </formalpara>

        <formalpara>
            <title>Irt_keys</title>

            <para>One byte, unsigned. Offset 0x0a in each descriptor array entry. This
            defines the number of keys (columns) in this index.</para>
        </formalpara>

        <formalpara>
            <title>Irt_flags</title>

            <para>One byte, unsigned. Offset 0x0b in each descriptor array entry. The
            flags define various attributes for this index, these are encoded into various
            bits in the field, as follows:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>Bit 0 : Index is unique (set) or not (unset).</para>
            </listitem>

            <listitem>
                <para>Bit 1 : Index is descending (set) or ascending (unset).</para>
            </listitem>

            <listitem>
                <para>Bit 2 : Index [creation?] is in progress (set) or not
                (unset).</para>
            </listitem>

            <listitem>
                <para>Bit 3 : Index is a foreign key index (set) or not (unset).</para>
            </listitem>

            <listitem>
                <para>Bit 4 : Index is a primary key index (set) or not (unset).</para>
            </listitem>

            <listitem>
                <para>Bit 5 : Index is expression based (set) or not (unset).</para>
            </listitem>
        </itemizedlist>

        <para>Each descriptor entry in the array holds an offset to a list of key
        descriptors. These start at the highest address on the page and extend towards the
        lowest address. (The array of index descriptors (irt_rpt) starts at a low address
        on the page and increases upwards. At some point, they will meet and the page will
        be full.</para>

        <para>The index field descriptors are defined as follows:</para>

        <formalpara>
            <title>Irtd_field</title>

            <para>Two bytes, unsigned. Offset 0x00 in each field descriptor. This field
            defines the field number of the table that makes up 'this' field in the index.
            This number is equivalent to
            <database>RDB$RELATION_FIELDS.RDB$FIELD_ID</database>.</para>
        </formalpara>

        <formalpara>
            <title>Irtd_itype</title>

            <para>Two bytes, unsigned. Offset 0x02 in each field descriptor. This
            determines the data type of the appropriate field in the index. The allowed
            values in this field are:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>0 : field is numeric, but does not include 64 bit integers.</para>
            </listitem>

            <listitem>
                <para>1 : field is string data.</para>
            </listitem>

            <listitem>
                <para>3 : Field is a byte array.</para>
            </listitem>

            <listitem>
                <para>4 : Field is metadata.</para>
            </listitem>

            <listitem>
                <para>5 : Field is a date.</para>
            </listitem>

            <listitem>
                <para>6 : Field is a time.</para>
            </listitem>

            <listitem>
                <para>7 : Field is a timestamp.</para>
            </listitem>

            <listitem>
                <para>8 : field is numeric - added for 64 bit integer support.</para>
            </listitem>
        </itemizedlist>

        <para>You may note from the above that an irtd_itype with value 2 is not
        permitted.</para>

        <formalpara>
            <title>Irtd_selectivity</title>

            <para>Four bytes, floating point format. Offset 0x04 in each field descriptor.
            This field holds the selectivity of this particular column in the index. This
            applies to ODS 11.0 onwards. In pre ODS 11.0 databases, this field is not part
            of the index filed descriptors and selectivity is applied to the index as a
            whole. See irt_selectivity above.</para>
        </formalpara>

        <para>The following commands have been executed to create a table and a pair of
        indices (via constraints):</para>

        <screen>tux&gt; isql test_database
Database:  test_database

SQL&gt; CREATE TABLE CONFIGREVISIONSTORE (
CON&gt;    CONFIGTABLENAME     VARCHAR(64) NOT NULL,
CON&gt;    CONFIGTYPEID        VARCHAR(64) NOT NULL,
CON&gt;    CFG_VERSION         VARCHAR(64) NOT NULL,
CON&gt;    REVISIONID          VARCHAR(64) NOT NULL,
CON&gt;    CREATIONTIME        TIMESTAMP NOT NULL,
CON&gt;    LOCALAVAILABLETIME  TIMESTAMP NOT NULL
CON&gt; );

SQL&gt; ALTER TABLE CONFIGREVISIONSTORE 
CON&gt; ADD CONSTRAINT PK_CONFIGREVISIONSTORE 
CON&gt; PRIMARY KEY (CONFIGTABLENAME, CONFIGTYPEID, REVISIONID);

SQL&gt; ALTER TABLE CONFIGREVISIONSTORE 
CON&gt; ADD CONSTRAINT FK_CONFIGREVISIONS 
CON&gt; FOREIGN KEY (REVISIONID) REFERENCES CONFIGREVISIONS (REVISIONID);
</screen>

        <para>The Index Root Page for the above table shows the following when dumped in
        hex:</para>

        <screen>0023d000  06 00 39 30 06 00 00 00  00 00 00 00 00 00 00 00  Standard header
0023d010  d5 00                                             Irt_relation
0023d012  02 00                                             Irt_count

0023d014  eb 13 05 00                                       Irt_root[0]
0023d018  00 00 00 00                                       Irt_transaction[0]
0023d01c  e8 0f                                             Irt_desc[0]
0023d01e  03                                                Irt_keys[0]
0023d01f  11                                                Irt_flags[0]

0023d020  2e 10 05 00                                       Irt_root[1]
0023d024  00 00 00 00                                       Irt_transaction[1]
0023d028  e0 0f                                             Irt_desc[1]
0023d02a  01                                                Irt_keys[1]
0023d02b  08                                                Irt_flags[1]
</screen>

        <para>We can see that the table has two defined indices (irt_count = 0x02) and the
        first of these has three columns (irt_keys[0] = 0x03) while the second only has
        one column (irt_keys[1] = 0x01).</para>

        <para>Looking at irt_flags[0] we can see the value 0x11. In binary, this is 0001
        0001 and shows bits 0 and 4 are both set. Consulting the description of irt_flags
        above, we see that this index is a unique (bit 0 set) primary key (bit 4 set)
        index. Similarly, for irt_flags[1] we see that only bit 3 is set to indicate that
        this index is a foreign key index.</para>

        <para>This matches with the definitions used to create the two indices as shows
        above - one is a primary key while the other is a foreign key.</para>

        <para>Also visible in the above dump is the fact that the first index has its list
        of field descriptors stored at a higher address on the page than the second index.
        Offset 0x0fe8 as opposed to 0x0fe0.</para>

        <para>Adding these two offsets to the page start address (0x0023d000) gives the
        physical addresses on the page where the descriptor lists begin - 0x0023dfe8 for
        index 0, and 0x0023dfe0 for index 1.</para>

        <para>Looking at the data stored for the primary key index address 0x0023dfe8, we
        see the following:</para>

        <screen>0023dfe8  00 00                                             irtd_field[0]
0023dfea  01 00                                             irtd_itype[0]
0023dfec  00 00 00 00                                       irtd_selectivity[0]

0023dff0  01 00                                             irtd_field[1]
0023dff2  01 00                                             irtd_itype[1]
0023dff4  00 00 00 00                                       irtd_selectivity[1]

0023dff8  03 00                                             irtd_field[2]
0023dffa  01 00                                             irtd_itype[2]
0023dffc  00 00 00 00                                       irtd_selectivity[2]</screen>

        <para>As we can see from the above, there are three separate entries - one for
        each field in the index - all have irtd_itype set to 0x01 which indicates VARCHAR
        data types. Similar details exists at address 0x0023dfe0 for the remaining index,
        as shown below.</para>

        <screen>0023dfe0  03 00                                             irtd_field[0]
0023dfe2  01 00                                             irtd_itype[0]
0023dfe4  00 00 00 00                                       itrd_selectivity[0]
</screen>
    </section>

    <section id="fbint-page-7">
        <title>Index B-Tree Page - Type 0x07 - TODO</title>

        <para>As described above for the Index Root Page (type 0x06) each index defined
        for a table has a root page from which the index data can be read etc. The Index
        Root Page field irt_root points to the first page (the root page - just to confuse
        matters slightly) in the index. That page will be a type 0x07 Index B-Tree Page,
        as will all the other pages that make up this index.</para>

        <!--Ok, I have a feeling that each level of an index b tree page is different. We might need to explain all of them. Root - branch - leaf.
We also need a lot more investigation into prefix compression and the decoding of the data in a btr_nodes[] array.-->

        <para>Indices do not share pages. Each index has its own range of dedicated pages
        in the database.</para>

        <para>The C code representation of a index b-tree page is:</para>

        <programlisting>struct btree_page
{
    pag btr_header;
    SLONG btr_sibling;
    SLONG btr_left_sibling;
    SLONG btr_prefix_total;
    USHORT btr_relation;
    USHORT btr_length;
    UCHAR btr_id;
    UCHAR btr_level;
    btree_nod btr_nodes[1];
};
</programlisting>

        <formalpara>
            <title>Btr_header</title>

            <para>The page starts off with a standard page header. The pag_flags byte is
            used on these pages. The bits used and why are:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>Bit 0 : set means do not garbage collect this page.</para>
            </listitem>

            <listitem>
                <para>Bit 1 : set means this page is not propogated upwards.</para>
            </listitem>

            <listitem>
                <para>Bit 3 : set means that this page/bucket is part of a descending
                index.</para>
            </listitem>

            <listitem>
                <para>Bit 4 : set means that non-leaf nodes will contain record number
                information.</para>
            </listitem>

            <listitem>
                <para>Bit 5 : set means that large keys are permitted/used.</para>
            </listitem>

            <listitem>
                <para>Bit 6 : set means that the page contains index jiump nodes.</para>
            </listitem>
        </itemizedlist>

        <formalpara>
            <title>Btr_sibling</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13 on the page. This is the page
            number of the next page of this index. The values on the next page are
            <emphasis>higher</emphasis> than all of those on this page. A value of zero
            here indicates that this is the final page in the index.</para>
        </formalpara>

        <formalpara>
            <title>Btr_left_sibling</title>

            <para>Four bytes, signed. Bytes 0x14 - 0x17 on the page. This is the page
            number of the previous page of this index. The values on the previous page are
            <emphasis>lower</emphasis> than all of those on this page. A value of zero
            here indicates that this is the first page in the index.</para>
        </formalpara>

        <formalpara>
            <title>Btr_prefix_total</title>

            <para>Four bytes, signed. Bytes 0x18 - 0x1b on the page. The sum of all the
            bytes saved on this page by using prefix compression.</para>
        </formalpara>

        <formalpara>
            <title>Btr_relation</title>

            <para>Two bytes, unsigned. Bytes 0x1c and 0x1d on the page. The relation id
            (RDB$RELATION_ID in RDB$RELATIONS) for the table that this index applies
            to.</para>
        </formalpara>

        <formalpara>
            <title>Btr_length</title>

            <para>Two bytes, unsigned. Bytes 0x1e and 0x1f on the page. The number of
            bytes used, for data, on this page.</para>
        </formalpara>

        <formalpara>
            <title>Btr_id</title>

            <para>One byte, unsigned. Byte 0x20 on the page. The index id (RDB$INDEX_ID in
            RDB$INDICES) for this index.</para>
        </formalpara>

        <formalpara>
            <title>Btr_level</title>

            <para>One byte, unsigned. Byte 0x21 on the page. The index level. Level zero
            indicates a leaf node.</para>
        </formalpara>

        <formalpara>
            <title>Btr_nodes</title>

            <para>Starting at byte 0x22 on the page, this is an array of index nodes.
            Index nodes are described below and are used to hold the data for one entry in
            this index. The C code representation of an entry in the array is:</para>
        </formalpara>

        <programlisting>struct btree_nod
{
    UCHAR btn_prefix;
    UCHAR btn_length;
    UCHAR btn_number[4];
    UCHAR btn_data[1];
};
</programlisting>

        <formalpara>
            <title>Btn_prefix</title>

            <para>One byte, unsigned. Byte 0x00 in the node. This is the size of the
            compressed prefix.</para>
        </formalpara>

        <formalpara>
            <title>Btn_length</title>

            <para>One byte, unsigned. Byte 0x01 in the node. This is the size of the data
            in the index entry.</para>
        </formalpara>

        <formalpara>
            <title>Btn_number</title>

            <para>Four bytes, unsigned. Bytes 0x02 - 0x05 in the node. The page number (or
            record number) where the data that this index entry represents, is to be
            found.</para>
        </formalpara>

        <formalpara>
            <title>Btn_data</title>

            <para>The data that makes up the index entry is found at bytes 0x06 onwards in
            the node.</para>
        </formalpara>

        <!--This section needs a lot of expansion!-->

        <para>Following the Index Root Page example, we can now hexdump and inspect the
        Primary Key index for our example table. We see from the Index Root page that the
        actual root of the index is on page 0x0513eb in the database. A dump of that page
        results in the following:</para>

        <screen>513eb000  07 70 39 30 02 00 00 00  00 00 00 00 00 00 00 00  Standard header
513eb010  00 00 00 00                                       Btr_sibling
513eb014  00 00 00 00                                       Btr_left_sibling
513eb018  1f 00 00 00                                       Btr_prefix_total
513eb01c  d5 00                                             Btr_relation
513eb01e  a6 00                                             Btr_length
513eb020  00                                                Btr_id
513eb021  02                                                Btr_level
</screen>

        <para>This looks like it is the final page in this particular index as it has no
        siblings, left or right. There also doesn't appear to be much space used on the
        page as btr_length is showing that only 0xa6 bytes have been used on this page,
        however, btr_level is 2 so we are not looking at a leaf node. (And we know that
        this is actually the root node for the entire index since the page we dumped is
        the root page for the index.)</para>

        <para>Following on from the above, we have the various index nodes, starting at
        offset 0x22, as follows:</para>

        <screen></screen>
    </section>

    <section id="fbint-page-8">
        <title>Blob Data Page - Type 0x08 - TODO</title>

        <para></para>

        <para>The C code representation of a blob data page is:</para>

        <programlisting>struct blob_page
{
    pag blp_header;
    SLONG blp_lead_page;
    SLONG blp_sequence;
    USHORT blp_length;
    USHORT blp_pad;
    SLONG blp_page[1];
};</programlisting>

        <formalpara>
            <title>Blp_header</title>

            <para>The blob page starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Blp_lead_page</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13. This field holds the page number
            for the first page for this blob.</para>
        </formalpara>

        <formalpara>
            <title>Blp_sequence</title>

            <para>Four bytes, signed. Bytes 0x14 - 0x17. The sequence number of this page
            within the page range for this blob.</para>
        </formalpara>

        <formalpara>
            <title>Blp_length</title>

            <para>Two bytes, unsigned. Bytes 0x18 and 0x19. The length of the blob data on
            this page, in bytes.</para>
        </formalpara>

        <formalpara>
            <title>Blp_pad</title>

            <para>Two bytes, unsigned. Bytes 0x1a and 0x1b. Not used for any data, used as
            padding.</para>
        </formalpara>

        <formalpara>
            <title>Blp_page</title>

            <para>This location in the page is at byte 0x1c. It has two purposes:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>An array of four byte, signed page numbers representing all the
                pages in this blob; or</para>
            </listitem>

            <listitem>
                <para>An array of bytes making up the blob data on this page.</para>
            </listitem>
        </itemizedlist>

        <para>If the flag byte in the standard page header (pag_flags) is set to 1, this
        blob page contains no data but acts as a pointer page to all the other blob pages
        for this particular blob.</para>

        <!--You are here - trying to find a BLOB TRAIL in a database where we can see a flags 1 page followed by a lot of flags 0 pages.-->
    </section>

    <section id="fbint-page-9">
        <title>Generator Page - Type 0x09</title>

        <para>Every database has at least one Generator Page, even if no generators (also
        known as sequences in Firebird 2.x) have been defined. A blank database consiting
        only of system tables and indices has a number of generators created for use in
        naming constraints, indices, etc.</para>

        <para>The C code representation of the generator page is:</para>

        <programlisting>struct generator_page
{
    pag gpg_header;
    SLONG gpg_sequence;
    SLONG gpg_waste1;
    USHORT gpg_waste2;
    USHORT gpg_waste3;
    USHORT gpg_waste4;
    USHORT gpg_waste5;
    SINT64 gpg_values[1];
};</programlisting>

        <formalpara>
            <title>Gpg_header</title>

            <para>The generator page starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Gpg_sequence</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13. The sequence number of this
            generator page, starting from zero. If so many generators have been created
            that new generator pages are required, the sequence number will be incremented
            for each one.</para>
        </formalpara>

        <formalpara>
            <title>Gpg_waste</title>

            <para>Twelve bytes. Bytes 0x14 to 0x1f. To quote the source code, these values
            are <emphasis>overhead carried forward for backward compatibility</emphasis>.
            In other words, most likely unused.</para>
        </formalpara>

        <formalpara>
            <title>Gpg_values</title>

            <para>An array of 64 bit values, one for each generator in the
            database.</para>
        </formalpara>

        <para>The hexdump of a brand new database looks as follows:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
00094000  09 00 39 30 02 00 00 00  00 00 00 00 00 00 00 00  Standard Header
00094010  00 00 00 00                                       gpg_sequence
00094014  00 00 00 00                                       gpg_waste1
00094018  00 00                                             gpg_waste2 
0009401a  00 00                                             gpg_waste3 
0009401c  00 00                                             gpg_waste4
0009401e  00 00                                             gpg_waste5
00094020  09 00 00 00 00 00 00 00                           gpg_values[0]
00094028  00 00 00 00 00 00 00 00                           gpg_values[1]  
00094030  03 00 00 00 00 00 00 00                           gpg_values[2]  
00094038  00 00 00 00 00 00 00 00                           gpg_values[3]  
....
00094070  00 00 00 00 00 00 00 00                           gpg_values[10]
00094078  00 00 00 00 00 00 00 00                           gpg_values[11]
</screen>

        <note>
            <para>GENERATOR is a non standard term that originated in Interbase. The Ansi
            SQL standard requires the term SEQUENCE instead.</para>
        </note>

        <para>The system table RDB$GENERATORS holds the defined sequence details but no
        values for each one. It does have an RDB$GENERATOR_ID column and this starts from
        1. And increments by 1 for each new sequence. Where does this number come
        from?</para>

        <para>Looking in the blank database we created, we can see that there are 9
        sequences created for system use:</para>

        <screen>SQL&gt; SELECT RDB$GENERATOR_ID, RDB$GENERATOR_NAME
CON&gt; FROM RDB$GENERATORS
CON&gt; ORDER BY RDB$GENERATOR_ID;

RDB$GENERATOR_ID RDB$GENERATOR_NAME
================ ==================
               1 RDB$SECURITY_CLASS
               2 SQL$DEFAULT
               3 RDB$PROCEDURES
               4 RDB$EXCEPTIONS
               5 RDB$CONSTRAINT_NAME
               6 RDB$FIELD_NAME
               7 RDB$INDEX_NAME
               8 RDB$TRIGGER_NAME
               9 RDB$BACKUP_HISTORY
</screen>

        <para>This is a clue, take a look at gpg_values[0] and see that it contains a 64
        bit representation of the value 9. I suspect therefore, that the very first
        sequence is used to generate the RDB$GENERATOR_ID value when a new sequence is
        created. One way to find out is to create a new sequence.</para>

        <screen>SQL&gt; CREATE SEQUENCE NEW_GENERATOR;
SQL&gt; SET SEQUENCE NEW_GENERATOR TO 666;
SQL&gt; COMMIT;

SQL&gt; SELECT RDB$GENERATOR_ID, RDB$GENERATOR_NAME
CON&gt; FROM RDB$GENERATORS
CON&gt; WHERE RDB$GENERATOR_ID &gt; 9;

RDB$GENERATOR_ID RDB$GENERATOR_NAME
================ ==================
              10 NEW_GENERATOR
</screen>

        <para>So far, so good, we see a new sequence. Time to hexdump the database file's
        generator page again:</para>

        <screen>00094020  0a 00 00 00 00 00 00 00                           gpg_values[0]
00094028  00 00 00 00 00 00 00 00                           gpg_values[1]
00094030  03 00 00 00 00 00 00 00                           gpg_values[2]
....
00094070  9a 02 00 00 00 00 00 00                           gpg_values[10]
00094078  00 00 00 00 00 00 00 00                           gpg_values[11]
....
</screen>

        <para>We can see at offset 0x00094070, which corresponds to gpg_values[10], that a
        new sequence has been created. The value in this sequence is 0x029a which happens
        to equal 666 in decimal. This offset into gpg_values also happens to match the
        RDB$GENERATOR_ID for the new sequence plus, we can see at offset 0x00094020 that
        the value in gpg_values[0] has increased to 0x0a. So it looks remarkably like the
        RDB$GENERATOR_ID is itself obtained from a sequence that
        <emphasis>never</emphasis> appears in RDB$GENERATORS.</para>

        <para>The value, stored in gpg_values[n], appears to be the <emphasis>last
        value</emphasis> that was used and not the <emphasis>next value</emphasis> to be
        issued.</para>

        <para>I wonder what happens when we drop a sequence?</para>

        <screen>SQL&gt; DROP SEQUENCE NEW_GENERATOR;
SQL&gt; COMMIT;

SQL&gt; SELECT RDB$GENERATOR_ID, RDB$GENERATOR_NAME
CON&gt; FROM RDB$GENERATORS
CON&gt; WHERE RDB$GENERATOR_ID &gt; 9;

SQL&gt; </screen>

        <para>We can see that the sequence is dropped from the RDB$GENERATORS table, what
        about in the generator page in the database?</para>

        <screen>00094020  0a 00 00 00 00 00 00 00                           gpg_values[0]
00094028  00 00 00 00 00 00 00 00                           gpg_values[1]
00094030  03 00 00 00 00 00 00 00                           gpg_values[2]
....
00094070  9a 02 00 00 00 00 00 00                           gpg_values[10]
00094078  00 00 00 00 00 00 00 00                           gpg_values[11]
....
</screen>

        <para>The generator page has not changed. Gpg_values[10] still remains at it's
        previous value - 0x029a - but this 64 bits of database page representing our
        recently dropped sequence can never be used again. It has ceased to be a sequence
        and has become wasted space.</para>

        <para>Given that RDB$GENERATOR_ID is itself generated from gpg_values[0] and
        cannot therefore reuse any allocated RDB$GENERATOR_ID, it is not surprising that
        the simplest way of handling a dropped sequence is simply to ignore it.</para>

        <para>Bearing in mind that in ODS 11 onwards, a sequence is a 64 bit value, how
        many sequences can we store on a page? The answer will be (page size - 32 bytes)/8
        and as we are allowed a maximum of 32,767 sequences in any one database.</para>

        <para>Because there is no apparent next and previous page numbers on a generator
        page, how does the database know where to find the actual page that the generator
        values are stored on? RDB$PAGES is a system table that the main database header
        page holds the page number for. This allows the system, on startup, to determine
        where it's internal data can be found. For because sequences live, as it were, in
        RDB$GENERATORS we can look in RDB$PAGES as follows, to find the actual page
        number(s):</para>

        <screen>SQL&gt; SELECT * 
CON&gt; FROM RDB$PAGES
CON&gt; WHERE RDB$PAGE_TYPE = 9;

RDB$PAGE_NUMBER RDB$RELATION_ID RDB$PAGE_SEQUENCE RDB$PAGE_TYPE
=============== =============== ================= =============
            148               0                 0             9
</screen>

        <para>The RDB$RELATION_ID is zero because this is not actually the location of a
        relation (table) in the database itself, but the location of a specific page that
        we are after. Given that RDB$PAGE_SEQUENCE = 0 and RDB$PAGE_TYPE = 9 we see that
        the first generator page is located on page 148 of the database.</para>

        <para>Page 148 in a database with a 4,096 byte page size would be address
        0x00094000 and surprisingly enough, that is exactly the page we have been looking
        at. If we create numerous sequences, then the second page with RDB$PAGE_SEQUENCE =
        1 would tell us where to go to find that page in the database</para>
    </section>

    <section id="fbint-page-10">
        <title>Write Ahead Log Page - Type 0x0a</title>

        <para>Every database has one Write Ahead Log page (WAL) which is always located at
        page 2.</para>

        <note>
            <para>Once again, discussions are taking place on the Firebird development
            mailing list on removing this page altogether as it is not used and simply
            wastes space that could be better used elsewhere. From Firebird 3.0 it is
            likely that there will not be a WAL page in any new databases.</para>
        </note>

        <para>The C code representation of the WAL page is:</para>

        <programlisting>struct log_info_page
{
    pag log_header;
    SLONG log_flags;
    ctrl_pt log_cp_1;
    ctrl_pt log_cp_2;
    ctrl_pt log_file;
    SLONG log_next_page;
    SLONG log_mod_tip;
    SLONG log_mod_tid;
    SLONG log_creation_date[2];
    SLONG log_free[4];
    USHORT log_end;
    UCHAR log_data[1];
};</programlisting>

        <para>As this structure is no longer in use within the database, it is
        effectively, a wasted page. Looking at a hexdump of the WAL page in a new
        database, we see the following:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
00002000  0a 00 39 30 01 00 00 00  00 00 00 00 00 00 00 00  Standard Header
00002010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  Wasted bytes
</screen>

        <para>The remainder of the page is filled with binary zeros.</para>

        <para>Because the WAL is no longer in use, and may even be dropped completely from
        Firebird 3.0 onwards, it will not be discussed further.</para>
    </section>

    <appendix id="fbint-dochist">
        <title>Document history</title>

        <para>The exact file history is recorded in the <filename
        class="directory">manual</filename> module in our CVS tree; see <ulink
        url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028
        </ulink>. The full URL of the CVS log for this file can be found at <ulink
        url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/firebirdinternals.xml?view=log"
        userlevel="">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/firebirdinternals.xml?view=log</ulink></para>

        <para><revhistory>
                <revision>
                    <revnumber>1.0</revnumber>

                    <date>03 November 2009</date>

                    <authorinitials>ND</authorinitials>

                    <revdescription>
                        <para>Created a new manual.</para>
                    </revdescription>
                </revision>
            </revhistory></para>
    </appendix>

    <appendix id="fbint-license">
        <title>License notice</title>

        <para>The contents of this Documentation are subject to the Public Documentation
        License Version 1.0 (the <quote>License</quote>); you may only use this
        Documentation if you comply with the terms of this License. Copies of the License
        are available at <ulink
        url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
        (PDF) and <ulink
        url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
        (HTML).</para>

        <para>The Original Documentation is titled <citetitle>Firebird
        Internals</citetitle>.</para>

        <para>The Initial Writer of the Original Documentation is: Norman Dunbar.</para>

        <para>Copyright (C) 2009. All Rights Reserved. Initial Writer contact:
        NormanDunbar at users dot sourceforge dot net.</para>
    </appendix>
</article>
