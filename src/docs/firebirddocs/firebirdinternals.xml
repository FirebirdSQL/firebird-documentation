<?xml version="1.0" encoding="UTF-8"?>
<!--
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
-->
<article id="fb-internals">
    <title>Firebird Internals</title>

    <titleabbrev>Inside a Firebird Database</titleabbrev>

    <articleinfo>
        <date>03 November 2009</date>

        <author>
            <firstname>Norman</firstname>

            <surname>Dunbar</surname>
        </author>

        <edition>03 November 2009 â€“ Document version 1.0</edition>
    </articleinfo>

    <section id="fbint-introduction">
        <title>Introduction</title>

        <para>The purpose of this document is to try and explain what goes on inside a
        Firebird Database. Much of the information in this manual has been extracted from
        the Firebird source code - mainly on the ODS related code and headers - and from
        some (partially out of date) documents on the Research part of the IBPhoenix web
        site (http://www.ibphoenix.com/).</para>

        <para>Much hex dumping of database files was undertaken in the creation of this
        document, but no Firebird databases were harmed during this process.</para>

        <para>All databases mentioned or described within this document are those with an
        ODS of 11.1 - in other words, Firebird 2.1, and a page size of 4,096 bytes. There
        may be differences between this ODS version and previous ones and wherever
        possible, this has been documented.</para>

        <para>Unless otherwise noted, the test database used for this document is empty of
        all user tables, indices, generators etc. It was created on a 32 bit Linux system
        running on Intel hardware. It is therefore little endian.</para>
    </section>

    <section id="fbint-structure">
        <title>Database Structure</title>

        <para>When you create a new database, be it single or multiple file, a number of
        things happen:</para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>The database file(s) are created;</para>
            </listitem>

            <listitem>
                <para>The header page is formatted and written;</para>
            </listitem>

            <listitem>
                <para>The various system tables - RDB$ and MON$ - and associated indices
                are created - and appropriate pages formatted and written to disc;</para>
            </listitem>

            <listitem>
                <para>Every page in the database is formatted with a defined page
                type.</para>
            </listitem>
        </itemizedlist>

        <para>The various page types are described elsewhere in this document.</para>

        <para>A database is created and the DBA can specify the page size, or leave it to
        default. This action creates a database file, or files, with enough space
        allocated to create all the system tables and indices. New pages will be added to
        the end of the database file(s) as and when the user creates new tables and/or
        indices. For example, a brand new database, created on a 32 bit Linux system, with
        a 4Kb page size allocates a total of 0xa1 pages (161 pages) for the system tables,
        indices and the various database overhead pages.</para>

        <section>
            <title>Single File Databases</title>

            <para>A single file Firebird database consists of a number of pages, each the
            same size, and all held within one file on the underlysing file system, be it
            NTFS, FAT32, EXT3 etc.</para>

            <para>The first page in the database is always a header page (page type 0x01 -
            see below) which holds details about the database itself, the page size and so
            on.</para>

            <para>The second page in the database is a Page Inventory Page or PIP (page
            type 0x02) which details which pages in the database are in use and which are
            free.</para>

            <para>Up until Firebird 3.0, the next page is a Write Ahead Log page (page
            type 0x0a) but this page is wasted space, if present, and will most likely be
            dropped from Firebird 3.0 onwards.</para>

            <para>The remaining pages consist of Index Root Pages (page type 0x06),
            Transaction Inventory Pages or TIP (page type 0x03), Pointer Pages (page type
            0x04), Index BTree Pages (page type 0x07), Data Pages (page type 0x05) and so
            on. There is a discussion of each page type below.</para>
        </section>

        <section>
            <title>Multiple File Databases</title>

            <para>A multiple file Firebird database is almost identical to the single file
            database except it has more than one file on the underlying file system. Each
            file has the same page size as the initial file, and each file has a header
            page (page type 0x01) at the start of the file.</para>
        </section>

        <section>
            <title>Shadow Files</title>

            <para>Shadow files are additional files that can be used by single and
            multiple file databases to assist in recovery after a failure of some kind.
            They are not helpful in the case of a DROP DATABASE as the shadow file(s0,
            being part of the database, are also dropped!</para>

            <para>Shadow files are updated as the database main file(s) are updated and in
            this manner, the shadows are an identical copy of the database. In the event
            of a problem, the SYSDBA can manually activate a shadow, or have the Firebird
            engine activate one automatically.</para>

            <para>Unfortunately, if a database write stores corrupt data in the database,
            the shadow file(s) will be identically corrupted.</para>

            <para>Because shadow files are effectively identical copies of the database
            files, they will not be discussed further.</para>
        </section>
    </section>

    <section id="fbint-standard-header">
        <title>Standard Database Page Header</title>

        <para>Every page in a database has a 16 byte standard page header. Various page
        types have an additional header that follows on from the standard one. The C code
        representation of the standard header is:</para>

        <programlisting>struct pag
{
    SCHAR pag_type;
    UCHAR pag_flags;
    USHORT pag_checksum;
    ULONG pag_generation;
    ULONG pag_scn;
    ULONG reserved;
};</programlisting>

        <formalpara>
            <title>Pag_type</title>

            <para>One byte, signed. Byte 0x00 on the page. This byte defines the page type
            for the page. Valid page types are:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>0x00 - Undefined page. You should never see this in a
                database.</para>
            </listitem>

            <listitem>
                <para>0x01 - The database header page. Only ever seen on the very first
                page of the database, or, on the first page of each database file in a
                multi-file database.</para>
            </listitem>

            <listitem>
                <para>0x02 - The Page Inventory Page (PIP). This page keeps track of
                allocated and free pages using a bitmap where a 1 means the page is free
                and a zero shows a used page. There may be more than one PIP in a
                database, but the first PIP is always page 1.</para>
            </listitem>

            <listitem>
                <para>0x03 - Transaction Inventory Page (TIP). A page that keeps track of
                the stat of transactions. Each transaction is represented by a pair of
                bits in a bitmap. Valid values in these two bits are:</para>

                <itemizedlist spacing="compact">
                    <listitem>
                        <para>00 - this transaction is active.</para>
                    </listitem>

                    <listitem>
                        <para>01 - this transaction is in limbo.</para>
                    </listitem>

                    <listitem>
                        <para>10 - this transaction is dead.</para>
                    </listitem>

                    <listitem>
                        <para>11 - this transaction has committed.</para>
                    </listitem>
                </itemizedlist>
            </listitem>

            <listitem>
                <para>0x04 - Pointer Page. Each table has one or more of these and this
                page type keeps track of all the pages that make up the table. Pointer
                pages are owned by one and only one table, there is no sharing allowed.
                Each pointer in the array on these pages holds the page number for a type
                5 page holding data for the table.</para>
            </listitem>

            <listitem>
                <para>0x05 - Data Page. These pages store the actual data for a
                table.</para>
            </listitem>

            <listitem>
                <para>0x06 - Index Root Page. Similar to a type 4 Pointer Page, but
                applies to indexes only.</para>
            </listitem>

            <listitem>
                <para>0x07 - Index B-Tree Page. Similar to the type 5 Data Page, but
                applies to indexex only.</para>
            </listitem>

            <listitem>
                <para>0x08 - Blob Page. Blobs have their own storage within the database.
                Very large blobs will require a sequence of pages and the type 8 page
                holds blob data.</para>
            </listitem>

            <listitem>
                <para>0x09 - Generator Page. Holds an array of 64 bit generators.</para>
            </listitem>

            <listitem>
                <para>0x0a - Page 2 of any database is a Write Ahead Log page. These pages
                are no longer used. The page will remain blank (filled with binary zero)
                as it is never used. This page has a standard header like all
                others.</para>
            </listitem>
        </itemizedlist>

        <formalpara>
            <title>Pag_flags</title>

            <para>One byte, unsigned. Byte 0x01 on the page. This byte holds various flags
            for the page.</para>
        </formalpara>

        <formalpara>
            <title>Pag_checksum</title>

            <para>Two bytes, unsigned. Bytes 0x02 - 0x03. Checksum for the whole page. No
            longer used, always 12345, 0x3039. Databases using ODS8 on Windows NT do have
            a valid checksum here.</para>
        </formalpara>

        <note>
            <para>Discussions are underway on the development mailing list on reusing this
            field as a page number rather than a checksum. From Firebird 3.0, it is
            possible that this field in the page header will probably have a new name and
            function.</para>
        </note>

        <formalpara>
            <title>Pag_generation</title>

            <para>Four bytes, unsigned. Bytes 0x04 - 0x07. The page generation number.
            Increments each time the page is written back to disc.</para>
        </formalpara>

        <formalpara>
            <title>Pag_scn</title>

            <para>Four bytes, unsigned. Bytes 0x08 - 0x0b. Originally used as the sequence
            number in the Write Ahead Log, but WAL is no longer used. The field was
            converted to be the SCN number to avoid an ODS change and is now used by
            <application>nbackup</application>.</para>
        </formalpara>

        <formalpara>
            <title>Pag_reserved</title>

            <para>Four bytes, unsigned. Bytes 0x0c - 0x0f. Reserved for future use. It was
            originally used for the offset of a page's entry in the Write Ahead Log (WAL),
            but this is no longer in use.</para>
        </formalpara>
    </section>

    <section id="fbint-page-1">
        <title>Database Header Page - Type 0x01</title>

        <para>The first page of the first file of a Firebird database is a very important
        page. It holds data that describes the database, where its other files are to be
        found, shadow file names, database page size, ODS version and so on. On startup,
        the Firebird engine reads the first part (1,024 bytes) of the first page in the
        first file of the database and runs a number of checks to ensure that the file is
        actually a database and so on. If the database is multi-file, then each file will
        have a header page of its own.</para>

        <para>The C code representation of the database header page is:</para>

        <programlisting>struct header_page
{
    pag hdr_header;
    USHORT hdr_page_size;
    USHORT hdr_ods_version;
    SLONG hdr_PAGES;
    ULONG hdr_next_page;
    SLONG hdr_oldest_transaction;
    SLONG hdr_oldest_active;
    SLONG hdr_next_transaction;
    USHORT hdr_sequence;
    USHORT hdr_flags;
    SLONG hdr_creation_date[2];
    SLONG hdr_attachment_id;
    SLONG hdr_shadow_count;
    SSHORT hdr_implementation;
    USHORT hdr_ods_minor;
    USHORT hdr_ods_minor_original;
    USHORT hdr_end;
    ULONG hdr_page_buffers;
    SLONG hdr_bumped_transaction;
    SLONG hdr_oldest_snapshot;
    SLONG hdr_backup_pages;
    SLONG hdr_misc[3];
    UCHAR hdr_data[1];
};
</programlisting>

        <formalpara>
            <title>Hdr_header</title>

            <para>The database header page has a standard page header, as do all
            pages.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_page_size</title>

            <para>Two bytes, unsigned. Bytes 0x10 - 0x11 on the page. This is the page
            size, in bytes, for each and every page in the database.</para>
        </formalpara>

        <formalpara>
            <title>Hds_ods_version</title>

            <para>Two bytes, unsigned. Bytes 0x12 and 0x13 on the page. The ODS major
            version for the database. The format of this word is the ODS major version
            ANDed with the Firebird flag of 0x8000. In the example below, the value is
            0x800b for ODS version 11. The minor ODS version is held elsewhere in the
            header page - see hdr_ods_minor below.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_pages</title>

            <para>Four bytes, signed. Bytes 0x14 - 0x17 on the page. This is the page
            number of the first pointer page for the table named RDB$PAGES. When this
            location is known, the database engine uses it to determine the locations of
            all other matadata pages in the database. This field is only valid in the
            header page of the <emphasis>first</emphasis> file in a multi-file database.
            The remaining files in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_next_page</title>

            <para>Four bytes, unsigned. Bytes 0x18 - 0x1b on the page. The page number of
            the header page in the next file of the database - if this is a multi-file
            database. Zero otherwise.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_oldest_transaction</title>

            <para>Four bytes, signed. Bytes 0x1c - 0x1f on the page. The transaction id of
            the oldest active (ie, uncommitted - but may be in limbo or rolled back)
            transaction against this database. This field is only valid in the header page
            of the <emphasis>first</emphasis> file in a multi-file database. The remaining
            files in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_oldest_active</title>

            <para>Four bytes, signed. Bytes 0x20 - 0x23 on the page. The transaction id of
            the oldest active transaction against this database, when any active
            transaction started. This field is only valid in the header page of the
            <emphasis>first</emphasis> file in a multi-file database. The remaining files
            in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_next_transaction</title>

            <para>Four bytes, signed. Bytes 0x24 - 0x27 on the page. The transaction id
            that will be assigned to the next transaction against this database. This
            field is only valid in the header page of the <emphasis>first</emphasis> file
            in a multi-file database. The remaining files in the database have this field
            set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_sequence</title>

            <para>Two bytes, unsigned. Bytes 0x28 and 0x29 on the page. The sequence
            number of this file within the database.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_flags</title>

            <para>Two bytes, unsigned. Bytes 0x2a and 0x2b on the page. The database
            flags. The bits in the flag bytes are used as follows:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="3">
                <colspec colname="flag" colwidth="4*" />

                <colspec colname="value" colwidth="4*" />

                <colspec colname="description" colwidth="12*" />

                <thead>
                    <row>
                        <entry align="center">Flag Name</entry>

                        <entry align="center">Flag value</entry>

                        <entry>Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>hdr_active_shadow</entry>

                        <entry>0x01 (bit 0)</entry>

                        <entry>This file is an active shadow file.</entry>
                    </row>

                    <row>
                        <entry>hdr_force_write</entry>

                        <entry>0x02 (bit 1)</entry>

                        <entry>The database is in <emphasis>forced writes</emphasis>
                        mode.</entry>
                    </row>

                    <row>
                        <entry>Unused</entry>

                        <entry>0x04 (bit 2)</entry>

                        <entry>Was previously for short term journalling, no longer
                        used.</entry>
                    </row>

                    <row>
                        <entry>Unused</entry>

                        <entry>0x08 (bit 3)</entry>

                        <entry>Was previously for long term journalling, no longer
                        used.</entry>
                    </row>

                    <row>
                        <entry>hdr_no_checksums</entry>

                        <entry>0x10 (bit 4)</entry>

                        <entry>Don't calculate checksums.</entry>
                    </row>

                    <row>
                        <entry>hdr_no_reserve</entry>

                        <entry>0x20 (bit 5)</entry>

                        <entry>Don'r reserve space for record versions in pages.</entry>
                    </row>

                    <row>
                        <entry>Unused</entry>

                        <entry>0x40 (bit 6)</entry>

                        <entry>Was used to indicate that the shared cache file was
                        disabled.</entry>
                    </row>

                    <row>
                        <entry>hdr_shutdown_mask (bit one of two)</entry>

                        <entry>0x1080 (bits 7 and 12)</entry>

                        <entry>Used with bit 12 (see below) to indicate the database
                        shutdown mode.</entry>
                    </row>

                    <row>
                        <entry>hdr_sql_dialect_3</entry>

                        <entry>0x100 (bit 8)</entry>

                        <entry>If set, the database is using SQL dialect 3.</entry>
                    </row>

                    <row>
                        <entry>hdr_read_only</entry>

                        <entry>0x200 (bit 9)</entry>

                        <entry>Database is in read only mode.</entry>
                    </row>

                    <row>
                        <entry>hdr_backup_mask</entry>

                        <entry>0xC00 (bits 10 and 11)</entry>

                        <entry>Indicates the current backup mode.</entry>
                    </row>

                    <row>
                        <entry>hdr_shutdown_mask (bit two of two)</entry>

                        <entry>0x1080 (bits 7 and 12)</entry>

                        <entry>Used with bit 7 (see above) to indicate the database
                        shutdown mode.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <para>The final two database flags use a pair of bits to indicate various states
        of backup and shutdown.</para>

        <formalpara>
            <title>Hdr_backup_mask</title>

            <para>These two bits determine the current database backup mode, as
            follows:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="2">
                <colspec colname="flag" colwidth="4*" />

                <colspec colname="description" colwidth="16*" />

                <thead>
                    <row>
                        <entry align="center">Flag Value</entry>

                        <entry align="center">Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>0x00 (Both bits zero)</entry>

                        <entry>Database is not in backup mode. User changes are written
                        directly to the database files.</entry>
                    </row>

                    <row>
                        <entry>0x400</entry>

                        <entry>The database is running in backup mode so all changed made
                        by the users are written to the diff file.</entry>
                    </row>

                    <row>
                        <entry>0x800</entry>

                        <entry>The database is still in backup mode, but changes are being
                        merged from the diff file into the main pages.</entry>
                    </row>

                    <row>
                        <entry>0xC00</entry>

                        <entry>The current database state is unknown and changes need to
                        be read from disc.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <formalpara>
            <title>Hdr_shutdown_mask</title>

            <para>The shutdown mask uses two bits to indicate the current database
            shutdown status, as follows:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="2">
                <colspec colname="flag" colwidth="4*" />

                <colspec colname="description" colwidth="16*" />

                <thead>
                    <row>
                        <entry align="center">Flag Value</entry>

                        <entry align="center">Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>0x00 (Both bits 7 and 12 are zero)</entry>

                        <entry>Database is not shutdown. Any valid user can
                        connect.</entry>
                    </row>

                    <row>
                        <entry>0x80</entry>

                        <entry>The database has been shutdown to, or started up in
                        multi-user maintenance mode. The database can only be conncted to
                        by SYSDBA or the database owner.</entry>
                    </row>

                    <row>
                        <entry>0x1000</entry>

                        <entry>The database has been fully shutdown. No connections are
                        permitted.</entry>
                    </row>

                    <row>
                        <entry>0x1080</entry>

                        <entry>The database has been shutdown to, or started up in
                        single-user maintenance mode. Only one SYSDBA or database owner
                        connection is permitted.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <formalpara>
            <title>Hdr_creation_date</title>

            <para>Eight bytes, signed. Bytes 0x2c - 0x33 on the page. The data and time
            (in Firebird's own internal format) that the database was either originally
            created/rewritten or created from a backup.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_attachment_id</title>

            <para>Four bytes, signed. Bytes 0x34 - 0x37 on the page. The id number that
            will be assigned to the next connection to this database. As this is signed,
            the maximum value here is 2<superscript>32</superscript>-1 and any database
            which reaches this maximum value must be backed up and restored in order to
            allow new connections. This field is only valid in the header page of the
            <emphasis>first</emphasis> file in a multi-file database. The remaining files
            in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_shadow_count</title>

            <para>Four bytes, signed. Bytes 0x38 - 0x3c on the page. Holds the event count
            for shadow file synchronisation for this database. The remaining files in the
            database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_implementation</title>

            <para>Two bytes, signed. Bytes 0x3c and 0x3d on the page. This is a number
            which indicates the environment on which the database was originally created.
            It is used to determine if the database file can be used sucessfully on the
            current hardware. This avoids problems caused by little-endian numerical
            values as compared with big-endian, for example.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_ods_minor</title>

            <para>Two bytes, unsigned. Bytes 0x3e and 0x3f on the page. The current ODS
            minor version.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_ods_minor_original</title>

            <para>Two bytes, unsigned. Bytes 0x40 and 0x41 on the page. The ODS minor
            version when the database was originally created.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_end</title>

            <para>Two bytes, unsigned. Bytes 0x42 and 0x43 on the page. The offset on the
            page where the hdr_data finishes. In other words, where a new clumplet will be
            stored if required. This is effectively a pointer to the current location of
            HDR_end (see clumplet details below) on this page.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_page_buffers</title>

            <para>Four bytes, unsigned. Bytes 0x44 - 0x47 on the page. Holds the number of
            buffers to be used for the database cache, or zero to indicate that the
            default value should be used. This field is only valid in the header page of
            the <emphasis>first</emphasis> file in a multi-file database. The remaining
            files in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_bumped_transaction</title>

            <para>Four bytes, signed. Bytes 0x48 - 0x4b on the page. Used to be used for
            the bumped transaction id for log optimisation, but is currently always set to
            0x01. This field is only valid in the header page of the
            <emphasis>first</emphasis> file in a multi-file database. The remaining files
            in the database have this field set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_oldest_snapshot</title>

            <para>Four bytes, signed. Bytes 0x4c - 0x4f on the page. Holds the transaction
            number for the oldest snapshot of active transactions. This is also documented
            as the <emphasis>confusing and redundant variant of Oldest Active
            Transaction</emphasis>.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_backup_pages</title>

            <para>Four bytes, signed. Bytes 0x50 - 0x53 on the page. Holds the number of
            pages in the database currently locked for a backup using nbackup. This field
            is only valid in the header page of the <emphasis>first</emphasis> file in a
            multi-file database. The remaining files in the database have this field set
            to zero.</para>
        </formalpara>

        <formalpara>
            <title>Hdr_misc</title>

            <para>Twelve bytes. Bytes 0x54 - 0x5f on the page. Set to zero. These 12 bytes
            are currently unused.</para>
        </formalpara>

        <para>The following is an example of a header page from a multi-file database on a
        little-endian system:</para>

        <screen>00000000  01 00 39 30 08 00 00 00  00 00 00 00 00 00 00 00  Standard header
00000010  00 10                                             hdr_page_size
00000012  0b 80                                             hdr_ods_version
00000014  03 00 00 00                                       hdr_PAGES
00000018  00 00 00 00                                       hdr_next_page
0000001c  01 00 00 00                                       hdr_oldest_transaction
00000020  02 00 00 00                                       hdr_oldest_active
00000024  05 00 00 00                                       hdr_next_transaction
00000028  00 00                                             hdr_sequence
0000002a  00 01                                             hdr_flags
0000002c  5e d7 00 00 f4 79 00 23                           hdr_creation_date
00000034  01 00 00 00                                       hdr_attachment_id
00000038  00 00 00 00                                       hdr_shadow_count
0000003c  13 00                                             hdr_implementation
0000003e  01 00                                             hdr_ods_minor
00000040  01 00                                             hdr_ods_minor_original
00000042  93 00                                             hdr_end
00000044  00 00 00 00                                       hdr_page_buffers
00000048  01 00 00 00                                       hdr_bumped_transaction
0000004c  02 00 00 00                                       hdr_oldest_snapshot
00000050  00 00 00 00                                       hdr_backup_pages
00000054  00 00 00 00 00 00 00 00 00 00 00 00               hdr_misc
00000060                                                    hdr_data[]
</screen>

        <note>
            <para>From Firebird 2.x onwards, there is a system table - MON$DATABASE which
            has a copy of all of the above data in an easy to obtain format:</para>

            <screen>tux&gt; isql employee
Database:  employee

SQL&gt; show table mon$database;
MON$DATABASE_NAME               (RDB$FILE_NAME) VARCHAR(253) Nullable
MON$PAGE_SIZE                   (RDB$PAGE_SIZE) SMALLINT Nullable
MON$ODS_MAJOR                   (RDB$ODS_NUMBER) SMALLINT Nullable
MON$ODS_MINOR                   (RDB$ODS_NUMBER) SMALLINT Nullable
MON$OLDEST_TRANSACTION          (RDB$TRANSACTION_ID) INTEGER Nullable
MON$OLDEST_ACTIVE               (RDB$TRANSACTION_ID) INTEGER Nullable
MON$OLDEST_SNAPSHOT             (RDB$TRANSACTION_ID) INTEGER Nullable
MON$NEXT_TRANSACTION            (RDB$TRANSACTION_ID) INTEGER Nullable
MON$PAGE_BUFFERS                (RDB$PAGE_BUFFERS) INTEGER Nullable
MON$SQL_DIALECT                 (RDB$SQL_DIALECT) SMALLINT Nullable
MON$SHUTDOWN_MODE               (RDB$SHUTDOWN_MODE) SMALLINT Nullable
MON$SWEEP_INTERVAL              (RDB$SWEEP_INTERVAL) INTEGER Nullable
MON$READ_ONLY                   (RDB$SYSTEM_FLAG) SMALLINT Nullable
MON$FORCED_WRITES               (RDB$SYSTEM_FLAG) SMALLINT Nullable
MON$RESERVE_SPACE               (RDB$SYSTEM_FLAG) SMALLINT Nullable
MON$CREATION_DATE               (RDB$TIMESTAMP) TIMESTAMP Nullable
MON$PAGES                       (RDB$COUNTER) BIGINT Nullable
MON$STAT_ID                     (RDB$STAT_ID) INTEGER Nullable
MON$BACKUP_STATE                (RDB$BACKUP_STATE) SMALLINT Nullable

SQL&gt; commit;
SQL&gt; quit;</screen>
        </note>

        <formalpara>
            <title>Hdr_data</title>

            <para>The variable data area on the header page begins at offset 0x60. Data
            stored here is held in clumplets and there are a number of different clumplet
            types, see below. This area is used to store filenames for the next file and
            other miscellaneous pieces of data relating to the database.</para>
        </formalpara>

        <para>The format of each clumplet is as follows:</para>

        <formalpara>
            <title>Type_byte</title>

            <para>The first byte - unsigned - in each clumplet determines the type of data
            stored within the clumplet. There are a number of different clumplet
            types:</para>
        </formalpara>

        <informaltable>
            <tgroup cols="3">
                <colspec colname="name" colwidth="5*" />

                <colspec colname="value" colwidth="2*" />

                <colspec colname="description" colwidth="13*" />

                <thead>
                    <row>
                        <entry align="center">Type Name</entry>

                        <entry align="center">Value</entry>

                        <entry>Description</entry>
                    </row>
                </thead>

                <tbody>
                    <row>
                        <entry>HDR_end</entry>

                        <entry>0x00</entry>

                        <entry>End of clumplets.</entry>
                    </row>

                    <row>
                        <entry>HDR_root_file_name</entry>

                        <entry>0x01</entry>

                        <entry>Original name of the root file for this database.</entry>
                    </row>

                    <row>
                        <entry>HDR_journal_server</entry>

                        <entry>0x02</entry>

                        <entry>Name of the journal server.</entry>
                    </row>

                    <row>
                        <entry>HDR_file</entry>

                        <entry>0x03</entry>

                        <entry>Secondary file name.</entry>
                    </row>

                    <row>
                        <entry>HDR_last_page</entry>

                        <entry>0x04</entry>

                        <entry>Last logical page of the current file.</entry>
                    </row>

                    <row>
                        <entry>HDR_unlicemsed</entry>

                        <entry>0x05</entry>

                        <entry>Count of unlicensed activity. No longer used.</entry>
                    </row>

                    <row>
                        <entry>HDR_sewwp_interval</entry>

                        <entry>0x06</entry>

                        <entry>Number of transactions between sweep.</entry>
                    </row>

                    <row>
                        <entry>HDR_log_name</entry>

                        <entry>0x07</entry>

                        <entry>Replay log name.</entry>
                    </row>

                    <row>
                        <entry>HDR_journal_file</entry>

                        <entry>0x08</entry>

                        <entry>Intermediate journal filename.</entry>
                    </row>

                    <row>
                        <entry>HDR_password_file_key</entry>

                        <entry>0x09</entry>

                        <entry>Key to compare with the password database.</entry>
                    </row>

                    <row>
                        <entry>HDR_backup_info</entry>

                        <entry>0x0a</entry>

                        <entry>Write Ahead Log (WAL) backup information. No longer
                        used.</entry>
                    </row>

                    <row>
                        <entry>HDR_cache_file</entry>

                        <entry>0x0b</entry>

                        <entry>Shared cache file. No longer used.</entry>
                    </row>

                    <row>
                        <entry>HDR_difference_file</entry>

                        <entry>0x0c</entry>

                        <entry>Diff file used during the times when the database is in
                        backup mode.</entry>
                    </row>

                    <row>
                        <entry>HDR_backup_guid</entry>

                        <entry>0x0d</entry>

                        <entry>UID generated when database is in backup mode. Overwritten
                        on subsequent backups.</entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <formalpara>
            <title>Length_byte</title>

            <para>The sceond byte - again unsigned - in each clumplet specifies the size
            of the data that follows.</para>
        </formalpara>

        <formalpara>
            <title>Data</title>

            <para>The next 'n' bytes are the actual clumplet data. The miscellaneous data
            stored in the header from the above database, at hdr_data, is shown
            below.</para>
        </formalpara>

        <screen>00000060  03                                                Type = HDR_file
00000061  2b                                                Length = 43 bytes
00000062  2f 75 30 30 2f 66 69 72  65 62 69 72 64 2f        Data '/u00/firebird/'
00000070  64 61 74 61 62 61 73 65  73 2f 6d 75 6c 74 69 5f      'databases/multi_'
00000080  65 6d 70 6c 6f 79 65 65  2e 66 64 62 31               'employee.fdb1'

0000008d  04                                                Type = HDR_last_page
0000008e  04                                                Length = 4 bytes
0000008f  a2 00 00 00                                       Data 0xa2 = 162

00000093  00                                                Type = HDR_end.</screen>

        <para>From the above we can see that in our multi-file database:</para>

        <itemizedlist spacing="compact">
            <listitem>
                <para>The <emphasis>next</emphasis> file (after this one) is named
                '<filename>/u00/firebird/databases/multi_employee.fdb1</filename>'</para>
            </listitem>

            <listitem>
                <para>The <emphasis>current</emphasis> file has 162 pages only - and with
                a 4Kb page size this means that the current file should be 663,552 bytes
                in size, which a quick run of <command>ls -l</command> will
                confirm.</para>
            </listitem>

            <listitem>
                <para>HDR_end is located at offset 0x93 in the page, exactly as the header
                field hdr_end told us. (See above).</para>
            </listitem>
        </itemizedlist>
    </section>

    <section id="fbint-page-2">
        <title>Page Inventory Page - Type 0x02</title>

        <para>Every database has at least one Page Inventory Page (PIP) with the first one
        <emphasis>always</emphasis> being page 1, just after the database header page. If
        more are required, the current PIP points to the next PIP by way of the very last
        bit on the page itself. The C code representation of the PIP page is:</para>

        <programlisting>struct page_inv_page
{
    pag pip_header;
    SLONG pip_min;
    UCHAR pip_bits[1];
}; </programlisting>

        <formalpara>
            <title>Pip_header</title>

            <para>The PIP starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Pip_min</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13 on the page. This is the bit
            number of the first page, on this PIP, which is currently free for use.</para>
        </formalpara>

        <formalpara>
            <title>Pip_bits</title>

            <para>Bytes 0x14 onwards. The remainder of the page, is an array of single
            bits where each bit represents a page in the database. If the bit is set (1)
            then that page is free for use. If the bit is unset (0) then the page has been
            used.</para>
        </formalpara>

        <para>If the database is large, and requires another PIP elsewhere in the
        database, then the last bit on this PIP represents the page number for the next
        PIP. For example, on a 4,096 byte page we have a total of 4,076 bytes to represent
        different pages in the database. As each byte has 8 bits, we have a total of
        32,608 pages before we need a new PIP.</para>

        <para>In a brand new database, a hex dump of the first few bytes of page 1, the
        first PIP, looks like the following:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
00001000  02 00 39 30 31 00 00 00  00 00 00 00 a1 00 00 00  Standard Header
00001010  a1 00 00 00                                       pip_min (low endian)
00001014  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  pip_bits[]
00001024  00 00 00 00  fe ff ff ff ff ff ff ff ff ff ff ff
</screen>

        <para>In the above, we see that pip_min has the value 0x000000a1 and the following
        20 bytes, the first part of the pip_bits array, are all zero. From this, it would
        appear that page 0xa1 is the first available page in the database for user tables
        etc and that all the pages up to that one have already been used for the system
        tables and indices etc.</para>

        <para>Looking at the bitmap again, page 0xa1 will be represented by byte 0x14, bit
        0x01 of the bitmap. This is byte 0x00001028 bit 1. We can see that this byte
        currently has the value 0xfe and bit 0x00 is already in use. So, our array is
        correct and so is our pip_min value - the next available page is indeed
        0xa1.</para>

        <para>If we look at the hexdump of that particular page, at address 0x000a1000, we
        see that it is actually the first byte past the current end of file, so our brand
        new blank database has been created with just enough space to hold all the system
        tables and indexes and nothing else.</para>
    </section>

    <section id="fbint-page-3">
        <title>Transaction Inventory Page - Type 0x03</title>

        <para>Every database has at least one Transaction Inventory Page (TIP) with the
        first one always being page 1, just after the database header page. If more are
        required, the current PIP points to the next PIP by way of the very last bit on
        the page itself.</para>

        <para>The highest possible transaction number is 2,147,483,647 or 0x7fffffff in a
        32 bit system. Once you hit this transaction, no more can be created and the
        database needs to be shutdown, backed up and then restored to reset the
        transaction numbers back to zero. The reason it has this maximum value is simply
        because the code for</para>

        <para>The C code representation of the TIP page is:</para>

        <programlisting>struct tx_inv_page
{
    pag tip_header;
    SLONG tip_next;
    UCHAR tip_transactions[1];
};</programlisting>

        <formalpara>
            <title>Tip_header</title>

            <para>The TIP starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Tip_next</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13 on the page. This is the page
            number of the next TIP page, if one exists, within the database. Zero here
            indicates that the current TIP page is the last TIP page.</para>
        </formalpara>

        <formalpara>
            <title>Tip_transactions</title>

            <para>Bytes 0x14 onwards. The remainder of the page, is an array of two bit
            values where each pair of bits represents a transaction and its status. Each
            transaction can have one of 4 status values:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>0x00 - this transaction is active, or has not yet started.</para>
            </listitem>

            <listitem>
                <para>0x01 - this transaction is in limbo. A two phase transaction has
                committed the first phase but the second phase has not committed.</para>
            </listitem>

            <listitem>
                <para>0x02 - this transaction is dead (was rolled back).</para>
            </listitem>

            <listitem>
                <para>0x03 - this transaction was committed.</para>
            </listitem>
        </itemizedlist>

        <para>Looking at a hex dump of the first few bytes of a new database, which has
        had a few transactions run against it, we see the following:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
000a0014  fc ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  tip_transactions[]
000a0024  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
000a0034  ff ff ff ff ff ff ff ff  ff ff ff ff ff 00 00 00
</screen>

        <para>Now, if a new transaction starts we won't see any changes because a live
        transaction and one that has not started yet, shows up as two zero bits in the
        tip_transactions array. However, if it commits, limbo's or rollsback, we should
        see a change. The following is the above database after a session connected using
        isql and immediately exited without doing anything:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
000a0014  fc ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff  tip_transactions[]
000a0024  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff
000a0034  ff ff ff ff ff ff ff ff  ff ff ff ff ff ff 00 00
</screen>

        <para>You can see that it looks remarkably like loading up a connection to
        <application>isql</application> and then exiting actually executes 4 separate
        transactions. We can see at the end of the last line that one byte has changed
        from 0x00 to 0xff and with 2 bits per transaction, that equates to 4 separate
        transactions, all of which committed.</para>

        <para>Other tools may run fewer or indeed, more, transaction just to connect to a
        database and do whatever it is that they have to do to initialise
        themselves.</para>
    </section>

    <section id="fbint-page-4">
        <title>Pointer Page - Type 0x04</title>

        <para>A pointer page is used internally to hold a list of all - or as may will fit
        on one pointer page - data pages (see below) that make up a single table. Large
        tables may have more than one pointer page but every table, system or user, will
        have a minimum of one pointer page. The RDB$PAGES table is where the Firebird
        engin looks to find out where a table is located within the physical database,
        however, RDB$PAGES is itself a table, and when the database is running, how
        exactly can it find the start page for RDB$PAGES in order to look it up?</para>

        <para>The database header page contains the page number for RDB$PAGES at bytes
        0x14 - 0x17 on the page. From experimentation, it appears as if this is always
        page 0x03, however, this cannot be relied upon and if you need to do this, you
        should always check the database header page to determine where RDB$PAGES is to be
        found.</para>

        <para>The C code representation of a pointer page is:</para>

        <programlisting>struct pointer_page
{
    pag ppg_header;
    SLONG ppg_sequence;
    SLONG ppg_next;
    USHORT ppg_count;
    USHORT ppg_relation;
    USHORT ppg_min_space;
    USHORT ppg_max_space;
    SLONG ppg_page[1];
};
</programlisting>

        <formalpara>
            <title>Ppg_header</title>

            <para>A pointer page starts with a standard page header. In the header, the
            pag_flags field is used and is set to the value 1 if this is the final pointer
            page for the relation.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_sequence</title>

            <para>Four bytes, signed. Offset 0x10 to 0x13 on the page. The sequence number
            of this pointer page in the list of pointer pages for the table. Starts at
            zero.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_next</title>

            <para>Four bytes, signed. Offset 0x14 to 0x17 on the page. The page number of
            the next pointer page for this table. Zero indicates that this is the final
            pointer page.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_count</title>

            <para>Two bytes, unsigned. Offset 0x18 and 0x19 on the page. This field holds
            the count of active slots (in the ppg_page[] array) on this pointer page, that
            are in use. As the array starts at zero, this is also the index of the first
            free slot on this pointer page.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_relation</title>

            <para>Two bytes, unsigned. Offset 0x1a and 0x1b on the page. This field holds
            the RDB$RELATIONS.RDB$REALTION_ID for the table that this pointer page
            represents.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_min_space</title>

            <para>Two bytes, unsigned. Offset 0x1c and 0x1d on the page. This indicates
            the first entry in the ppg_page array holding a page number which has free
            space in the page.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_max_space</title>

            <para>Two bytes, unsigned. Offset 0x1e and 0x1f on the page. This was intended
            to indicate the last entry in the ppg_page array holding a page number which
            has free space in the page, but it has never been used. These two bytes are
            invariably set to zero.</para>
        </formalpara>

        <formalpara>
            <title>Ppg_page</title>

            <para>An array of four byte signed values, starting at offset 0x20. Each value
            in this array represents a page number where a part of the current table is to
            be found. A value of zero in a slot indicates that the slot is not in use.
            Deleteing all the data from a table will result in all slots being set to
            zero.</para>
        </formalpara>

        <formalpara>
            <title>Page fill bitmaps</title>

            <para>At the end of each pointer page is a bitmap array of two bit entries
            which is indexed by the same index as the ppg_page array. These bitmaps
            indicate that the page is available for use in storing records (or record
            versions) or not. The two bits in the bitmap indicate whether a large object
            (BLOB?) is on this page and the other bit indicates that the page is full. If
            either bit is set (page has a large object or page is full, then the page is
            not used for new records or record versions.</para>
        </formalpara>

        <para>The location of the bitmaps on each page is dependent on the page size. The
        bigger the page, the more slots in the ppg_page array it can hold and so the
        bitmap is bigger. A bigger bitmap starts at a lower address in the page and so on.
        From lookiing inside a few databases with a 4Kb page size, the bitmaps begin at
        offset 0x0f10 on the page.</para>

        <para>You can find the pointer page for any table by running something like the
        following query in <application>isql</application>:</para>

        <screen>SQL&gt; SELECT P.RDB$PAGE_NUMBER, P.RDB$PAGE_SEQUENCE, P.RDB$RELATION_ID
CON&gt; FROM RDB$PAGES P
CON&gt; JOIN RDB$RELATIONS R ON (R.RDB$RELATION_ID = P.RDB$RELATION_ID)
CON&gt; WHERE R.RDB$RELATION_NAME = 'EMPLOYEE'
CON&gt; AND P.RDB$PAGE_TYPE = 4;

RDB$PAGE_NUMBER RDB$PAGE_SEQUENCE RDB$RELATION_ID
=============== ================= ===============
            180                 0             131
</screen>

        <para>The page number which has RDB$PAGE_SEQUENCE holding the value zero is the
        top level pointer page for this table. In the above example, there is only one
        pointer page for the EMPLOYEE table. If we now hexdump the pointer page for the
        employee table, we see the following:</para>

        <screen>000b4000  04 01 39 30 02 00 00 00  00 00 00 00 00 00 00 00  Standard header
000b4010  00 00 00 00                                       Ppg_sequence
000b4014  00 00 00 00                                       Ppg_next
000b4018  02 00                                             Ppg_count
000b401a  83 00                                             Ppg_relation
000b401c  01 00                                             Ppg_min_space
000b401e  00 00                                             Ppg_max_space
000b4020  ca 00 00 00                                       Ppg_page[0]
000b4024  cb 00 00 00                                       Ppg_page[1]
000b4028  00 00 00 00                                       Ppg_page[2]
000b402c  00 00 00 00                                       Ppg_page[3]
...
000b4f10  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000b4f20  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|</screen>

        <para>Looking at the above, we can see at address 0x0b4f10 on the page, that the
        byte there has the value of 0x01. This is an indicator that the page in
        ppg_page[0] - page 0xca - is full to capacity (bit 0 set) and does not have any
        large objects on the page (bit 1 unset). The page at ppg_page[1] - page 0xcb - is,
        on the other hand, not full up yet (bit 2 is unset) and doesn't have a large
        object on the page either. This means that this page is avilable for us.</para>

        <para>This is confirmed by checking the value in ppg_min_space which has the value
        0x0001 and does indeed correspond to the first page with free space. The value in
        ppg_min_space is the index into the ppg_array and not the page number
        itself.</para>
    </section>

    <section id="fbint-page-5">
        <title>Data Page - Type 0x05 - TODO</title>

        <para>A data page belongs exclusively to a single table. The page starts opff, as
        usual, with the standard page header and is followed by an array of pairs of
        unsigned two byte values representing the 'table of contents' for this page. This
        array fills from the top of the page (lowest address, increasing) while the actual
        data it points to is stored on the page and fills from the bottom of the page
        (highest address, descending).</para>

        <para>The C code representation of a data page is:</para>

        <programlisting>struct data_page
{
    pag dpg_header;
    SLONG dpg_sequence;
    USHORT dpg_relation;
    USHORT dpg_count;
    struct dpg_repeat {
        USHORT dpg_offset;
        USHORT dpg_length;
    } dpg_rpt[1];
};

#define DPG_SIZE    (sizeof (Ods::data_page) - sizeof (Ods::data_page::dpg_repeat))
</programlisting>

        <formalpara>
            <title>Dpg_header</title>

            <para>The page starts with a standard page header. In this page type, the
            pag_flags byte is used as follows:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>Bit 0 - dpg_orphan. Setting this bit indicates that this page is an
                orphan - it has no entry in the pointer page for this relation. This may
                indicate a possible database corruption.</para>
            </listitem>

            <listitem>
                <para>Bit 1 - dpg_full. Setting this bit indicates that the page is full
                up. This will be also seen in the bitmap array on the corresponding
                pointer page for this table.</para>
            </listitem>

            <listitem>
                <para>Bit 2 - dpg_large. Setting this bit indicates that a large object is
                stored on this page. This will be also seen in the bitmap array on the
                corresponding pointer page for this table.</para>
            </listitem>
        </itemizedlist>

        <formalpara>
            <title>Dpg_sequence</title>

            <para>Four bytes, signed. Offset 0x10 on the page. This field holds the
            sequence number for this page in the list of pages assigned to this table
            within the database. The first page of any table has sequence zero.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_relation</title>

            <para>Two bytes, unsigned. Offset 0x12 on the page. The relation number for
            this table. This corresponds to RDB$RELATIONS.RDB$RELATION_ID.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_count</title>

            <para>Two bytes, unsigned. Offset 0x14 on the page. The number of record
            fragments on this page. In other words, the number of entries in the dpg_rpt
            array.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_rpt</title>

            <para>This is an array of two byte unsigned values. The array begins at offset
            0x18 on the page and counts upwards from the low address to the higher address
            as each new record fragment is added.</para>
        </formalpara>

        <para>The two fields in this array are:</para>

        <formalpara>
            <title>Dpg_offset</title>

            <para>Two bytes, unsigned. The offset on the page where the record fragment
            starts. If the value here is zero and the length is zero, then this is an
            unused array entry. The offset is from the start address of the page. For
            example, if the offset is 0x0fc8 and this is a database with a 4Kb page size,
            and the page in question is page 0xcd (205 decimal) then we have the offset of
            0xcdfc8 because 0xcd000 is the actual address (in the database file) of the
            start of the page.</para>
        </formalpara>

        <formalpara>
            <title>Dpg_length</title>

            <para>Two bytes, unsigned. The length of this record fragment in bytes.</para>
        </formalpara>
    </section>

    <section id="fbint-page-6">
        <title>Index Root Page - Type 0x06 - TODO</title>

        <para></para>

        <para>The C code representation of an index root page is:</para>

        <programlisting>struct index_root_page
{
    pag irt_header;
    USHORT irt_relation;        /* relation id (for consistency) */
    USHORT irt_count;            /* Number of indices */
    struct irt_repeat {
        SLONG irt_root;            /* page number of index root */
        union {
            float irt_selectivity;    /* selectivity of index - NOT USED since ODS11 */
            SLONG irt_transaction;    /* transaction in progress */
        } irt_stuff;
        USHORT irt_desc;        /* offset to key descriptions */
        UCHAR irt_keys;            /* number of keys in index */
        UCHAR irt_flags;
    } irt_rpt[1];
};

/* key descriptor */

struct irtd_ods10 {
    USHORT irtd_field;
    USHORT irtd_itype;
};

struct irtd : public irtd_ods10 {
    float irtd_selectivity;
};

// irtd_itype
const USHORT irt_unique        = 1;
const USHORT irt_descending    = 2;
const USHORT irt_in_progress= 4;
const USHORT irt_foreign    = 8;
const USHORT irt_primary    = 16;
const USHORT irt_expression    = 32;

const int STUFF_COUNT        = 4;
const SLONG END_LEVEL        = -1;
const SLONG END_BUCKET        = -2;
</programlisting>
    </section>

    <section id="fbint-page-7">
        <title>Index B-Tree Page - Type 0x07 - TODO</title>

        <para></para>

        <para>The C code representation of a index b-tree page is:</para>

        <programlisting>// B-tree page ("bucket")
struct btree_page
{
    pag btr_header;
    SLONG btr_sibling;
    SLONG btr_left_sibling;
    SLONG btr_prefix_total;
    USHORT btr_relation;
    USHORT btr_length;
    UCHAR btr_id;
    UCHAR btr_level;
    btree_nod btr_nodes[1];
};
</programlisting>

        <formalpara>
            <title>Btr_header</title>

            <para>The page starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Btr_sibling</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13 on the page. This is the page
            number of the next page of this index. The values on the next page are higher
            than all of those on this page. A value of zero here indicates that this is
            the final page in the index.</para>
        </formalpara>

        <formalpara>
            <title>Btr_left_sibling</title>

            <para>Four bytes, signed. Bytes 0x14 - 0x17 on the page. This is the page
            number of the previous page of this index. The values on the previous page are
            lower than all of those on this page. A value of zero here indicates that this
            is the first page in the index.</para>
        </formalpara>

        <formalpara>
            <title>Btr_prefix_total</title>

            <para>Four bytes, signed. Bytes 0x18 - 0x1b on the page. The sum of all the
            bytes saved on this page by using prefix compression.</para>
        </formalpara>

        <formalpara>
            <title>Btr_relation</title>

            <para>Two bytes, unsigned. Bytes 0x1c and 0x1d on the page. The relation id
            (RDB$RELATION_ID in RDB$RELATIONS) for the table that this index applies
            to.</para>
        </formalpara>

        <formalpara>
            <title>Btr_length</title>

            <para>Two bytes, unsigned. Bytes 0x1e and 0x1f on the page. The number of
            bytes used, for data, on this page.</para>
        </formalpara>

        <formalpara>
            <title>Btr_id</title>

            <para>One byte, unsigned. Byte 0x20 on the page. The index id (RDB$INDEX_ID in
            RDB$INDICES) for this index.</para>
        </formalpara>

        <formalpara>
            <title>Btr_level</title>

            <para>One byte, unsigned. Byte 0x21 on the page. The index level. Level 0
            indicates that this is a leaf node</para>
        </formalpara>

        <formalpara>
            <title>Btr_nodes</title>

            <para>Starting at byte 0x22 on the page, this is an array of index nodes.
            Index nodes are described below and are used to hold the data for one entry in
            this index. The C code representation of an entry in the array is:</para>
        </formalpara>

        <programlisting>struct btree_nod
{
    UCHAR btn_prefix;
    UCHAR btn_length;
    UCHAR btn_number[4];
    UCHAR btn_data[1];
};
</programlisting>

        <formalpara>
            <title>Btn_prefix</title>

            <para>One byte, unsigned. Byte 0x00 in the node. This is the size of the
            compressed prefix.</para>
        </formalpara>

        <formalpara>
            <title>Btn_length</title>

            <para>One byte, unsigned. Byte 0x01 in the node. This is the size of the data
            in the index entry.</para>
        </formalpara>

        <formalpara>
            <title>Btn_number</title>

            <para>Four bytes, unsigned. Bytes 0x02 - 0x05 in the node. The page number (or
            record number) where the data that this index entry represents, is to be
            found.</para>
        </formalpara>

        <formalpara>
            <title>Btn_data</title>

            <para>The data that makes up the index entry is found at bytes 0x06 onwards in
            the node.</para>
        </formalpara>

        <!--This section needs a lot of expansion!-->

        <para></para>
    </section>

    <section id="fbint-page-8">
        <title>Blob Data Page - Type 0x08 - TODO</title>

        <para></para>

        <para>The C code representation of a blob data page is:</para>

        <programlisting>struct blob_page
{
    pag blp_header;
    SLONG blp_lead_page;
    SLONG blp_sequence;
    USHORT blp_length;
    USHORT blp_pad;
    SLONG blp_page[1];
};</programlisting>

        <formalpara>
            <title>Blp_header</title>

            <para>The blob page starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Blp_lead_page</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13. This field holds the page number
            for the first page for this blob.</para>
        </formalpara>

        <formalpara>
            <title>Blp_sequence</title>

            <para>Four bytes, signed. Bytes 0x14 - 0x17. The sequence number of this page
            within the page range for this blob.</para>
        </formalpara>

        <formalpara>
            <title>Blp_length</title>

            <para>Two bytes, unsigned. Bytes 0x18 and 0x19. The length of the blob data on
            this page, in bytes.</para>
        </formalpara>

        <formalpara>
            <title>Blp_pad</title>

            <para>Two bytes, unsigned. Bytes 0x1a and 0x1b. Not used for any data, used as
            padding.</para>
        </formalpara>

        <formalpara>
            <title>Blp_page</title>

            <para>This location in the page is at byte 0x1c. It has two purposes:</para>
        </formalpara>

        <itemizedlist spacing="compact">
            <listitem>
                <para>An array of four byte, signed page numbers representing all the
                pages in this blob; or</para>
            </listitem>

            <listitem>
                <para>An array of bytes making up the blob data on this page.</para>
            </listitem>
        </itemizedlist>

        <para>If the flag byte in the standard page header (pag_flags) is set to 1, this
        blob page contains no data but acts as a pointer page to all the other blob pages
        for this particular blob.</para>

        <!--You are here - trying to find a BLOB TRAIL in a database where we can see a flags 1 page followed by a lot of flags 0 pages.-->
    </section>

    <section id="fbint-page-9">
        <title>Generator Page - Type 0x09</title>

        <para>Every database has at least one Generator Page, even if no generators (also
        known as sequences in Firebird 2.x) have been defined. A blank database consiting
        only of system tables and indices has a number of generators created for use in
        naming constraints, indices, etc.</para>

        <para>The C code representation of the generator page is:</para>

        <programlisting>struct generator_page
{
    pag gpg_header;
    SLONG gpg_sequence;
    SLONG gpg_waste1;
    USHORT gpg_waste2;
    USHORT gpg_waste3;
    USHORT gpg_waste4;
    USHORT gpg_waste5;
    SINT64 gpg_values[1];
};</programlisting>

        <formalpara>
            <title>Gpg_header</title>

            <para>The generator page starts off with a standard page header.</para>
        </formalpara>

        <formalpara>
            <title>Gpg_sequence</title>

            <para>Four bytes, signed. Bytes 0x10 - 0x13. The sequence number of this
            generator page, starting from zero. If so many generators have been created
            that new generator pages are required, the sequence number will be incremented
            for each one.</para>
        </formalpara>

        <formalpara>
            <title>Gpg_waste</title>

            <para>Twelve bytes. Bytes 0x14 to 0x1f. To quote the source code, these values
            are <emphasis>overhead carried forward for backward compatibility</emphasis>.
            In other words, most likely unused.</para>
        </formalpara>

        <formalpara>
            <title>Gpg_values</title>

            <para>An array of 64 bit values, one for each generator in the
            database.</para>
        </formalpara>

        <para>The hexdump of a brand new database looks as follows:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
00094000  09 00 39 30 02 00 00 00  00 00 00 00 00 00 00 00  Standard Header
00094010  00 00 00 00                                       gpg_sequence
00094014  00 00 00 00                                       gpg_waste1
00094018  00 00                                             gpg_waste2 
0009401a  00 00                                             gpg_waste3 
0009401c  00 00                                             gpg_waste4
0009401e  00 00                                             gpg_waste5
00094020  09 00 00 00 00 00 00 00                           gpg_values[0]
00094028  00 00 00 00 00 00 00 00                           gpg_values[1]  
00094030  03 00 00 00 00 00 00 00                           gpg_values[2]  
00094038  00 00 00 00 00 00 00 00                           gpg_values[3]  
....
00094070  00 00 00 00 00 00 00 00                           gpg_values[10]
00094078  00 00 00 00 00 00 00 00                           gpg_values[11]
</screen>

        <note>
            <para>GENERATOR is a non standard term that originated in Interbase. The Ansi
            SQL standard requires the term SEQUENCE instead.</para>
        </note>

        <para>The system table RDB$GENERATORS holds the defined sequence details but no
        values for each one. It does have an RDB$GENERATOR_ID column and this starts from
        1. And increments by 1 for each new sequence. Where does this number come
        from?</para>

        <para>Looking in the blank database we created, we can see that there are 9
        sequences created for system use:</para>

        <screen>SQL&gt; SELECT RDB$GENERATOR_ID, RDB$GENERATOR_NAME
CON&gt; FROM RDB$GENERATORS
CON&gt; ORDER BY RDB$GENERATOR_ID;

RDB$GENERATOR_ID RDB$GENERATOR_NAME
================ ==================
               1 RDB$SECURITY_CLASS
               2 SQL$DEFAULT
               3 RDB$PROCEDURES
               4 RDB$EXCEPTIONS
               5 RDB$CONSTRAINT_NAME
               6 RDB$FIELD_NAME
               7 RDB$INDEX_NAME
               8 RDB$TRIGGER_NAME
               9 RDB$BACKUP_HISTORY
</screen>

        <para>This is a clue, take a look at gpg_values[0] and see that it contains a 64
        bit representation of the value 9. I suspect therefore, that the very first
        sequence is used to generate the RDB$GENERATOR_ID value when a new sequence is
        created. One way to find out is to create a new sequence.</para>

        <screen>SQL&gt; CREATE SEQUENCE NEW_GENERATOR;
SQL&gt; SET SEQUENCE NEW_GENERATOR TO 666;
SQL&gt; COMMIT;

SQL&gt; SELECT RDB$GENERATOR_ID, RDB$GENERATOR_NAME
CON&gt; FROM RDB$GENERATORS
CON&gt; WHERE RDB$GENERATOR_ID &gt; 9;

RDB$GENERATOR_ID RDB$GENERATOR_NAME
================ ==================
              10 NEW_GENERATOR
</screen>

        <para>So far, so good, we see a new sequence. Time to hexdump the database file's
        generator page again:</para>

        <screen>00094020  0a 00 00 00 00 00 00 00                           gpg_values[0]
00094028  00 00 00 00 00 00 00 00                           gpg_values[1]
00094030  03 00 00 00 00 00 00 00                           gpg_values[2]
....
00094070  9a 02 00 00 00 00 00 00                           gpg_values[10]
00094078  00 00 00 00 00 00 00 00                           gpg_values[11]
....
</screen>

        <para>We can see at offset 0x00094070, which corresponds to gpg_values[10], that a
        new sequence has been created. The value in this sequence is 0x029a which happens
        to equal 666 in decimal. This offset into gpg_values also happens to match the
        RDB$GENERATOR_ID for the new sequence plus, we can see at offset 0x00094020 that
        the value in gpg_values[0] has increased to 0x0a. So it looks remarkably like the
        RDB$GENERATOR_ID is itself obtained from a sequence that
        <emphasis>never</emphasis> appears in RDB$GENERATORS.</para>

        <para>The value, stored in gpg_values[n], appears to be the <emphasis>last
        value</emphasis> that was used and not the <emphasis>next value</emphasis> to be
        issued.</para>

        <para>I wonder what happens when we drop a sequence?</para>

        <screen>SQL&gt; DROP SEQUENCE NEW_GENERATOR;
SQL&gt; COMMIT;

SQL&gt; SELECT RDB$GENERATOR_ID, RDB$GENERATOR_NAME
CON&gt; FROM RDB$GENERATORS
CON&gt; WHERE RDB$GENERATOR_ID &gt; 9;

SQL&gt; </screen>

        <para>We can see that the sequence is dropped from the RDB$GENERATORS table, what
        about in the generator page in the database?</para>

        <screen>00094020  0a 00 00 00 00 00 00 00                           gpg_values[0]
00094028  00 00 00 00 00 00 00 00                           gpg_values[1]
00094030  03 00 00 00 00 00 00 00                           gpg_values[2]
....
00094070  9a 02 00 00 00 00 00 00                           gpg_values[10]
00094078  00 00 00 00 00 00 00 00                           gpg_values[11]
....
</screen>

        <para>The generator page has not changed. Gpg_values[10] still remains at it's
        previous value - 0x029a - but this 64 bits of database page representing our
        recently dropped sequence can never be used again. It has ceased to be a sequence
        and has become wasted space.</para>

        <para>Given that RDB$GENERATOR_ID is itself generated from gpg_values[0] and
        cannot therefore reuse any allocated RDB$GENERATOR_ID, it is not surprising that
        the simplest way of handling a dropped sequence is simply to ignore it.</para>

        <para>Bearing in mind that in ODS 11 onwards, a sequence is a 64 bit value, how
        many sequences can we store on a page? The answer will be (page size - 32 bytes)/8
        and as we are allowed a maximum of 32,767 sequences in any one database.</para>

        <para>Because there is no apparent next and previous page numbers on a generator
        page, how does the database know where to find the actual page that the generator
        values are stored on? RDB$PAGES is a system table that the main database header
        page holds the page number for. This allows the system, on startup, to determine
        where it's internal data can be found. For because sequences live, as it were, in
        RDB$GENERATORS we can look in RDB$PAGES as follows, to find the actual page
        number(s):</para>

        <screen>SQL&gt; SELECT * 
CON&gt; FROM RDB$PAGES
CON&gt; WHERE RDB$PAGE_TYPE = 9;

RDB$PAGE_NUMBER RDB$RELATION_ID RDB$PAGE_SEQUENCE RDB$PAGE_TYPE
=============== =============== ================= =============
            148               0                 0             9
</screen>

        <para>The RDB$RELATION_ID is zero because this is not actually the location of a
        relation (table) in the database itself, but the location of a specific page that
        we are after. Given that RDB$PAGE_SEQUENCE = 0 and RDB$PAGE_TYPE = 9 we see that
        the first generator page is located on page 148 of the database.</para>

        <para>Page 148 in a database with a 4,096 byte page size would be address
        0x00094000 and surprisingly enough, that is exactly the page we have been looking
        at. If we create numerous sequences, then the second page with RDB$PAGE_SEQUENCE =
        1 would tell us where to go to find that page in the database</para>
    </section>

    <section id="fbint-page-10">
        <title>Write Ahead Log Page - Type 0x0a</title>

        <para>Every database has one Write Ahead Log page (WAL) which is always located at
        page 2.</para>

        <note>
            <para>Once again, discussions are taking place on the Firebird development
            mailing list on removing this page altogether as it is not used and simply
            wastes space that could be better used elsewhere. From Firebird 3.0 it is
            likely that there will not be a WAL page in any new databases.</para>
        </note>

        <para>The C code representation of the WAL page is:</para>

        <programlisting>struct log_info_page
{
    pag log_header;
    SLONG log_flags;
    ctrl_pt log_cp_1;
    ctrl_pt log_cp_2;
    ctrl_pt log_file;
    SLONG log_next_page;
    SLONG log_mod_tip;
    SLONG log_mod_tid;
    SLONG log_creation_date[2];
    SLONG log_free[4];
    USHORT log_end;
    UCHAR log_data[1];
};</programlisting>

        <para>As this structure is no longer in use within the database, it is
        effectively, a wasted page. Looking at a hexdump of the WAL page in a new
        database, we see the following:</para>

        <screen>Offset    Data                                              Description
----------------------------------------------------------------------------------
00002000  0a 00 39 30 01 00 00 00  00 00 00 00 00 00 00 00  Standard Header
00002010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  Wasted bytes
</screen>

        <para>The remainder of the page is filled with binary zeros.</para>

        <para>Because the WAL is no longer in use, and may even be dropped completely from
        Firebird 3.0 onwards, it will not be discussed further.</para>
    </section>

    <appendix id="fbint-dochist">
        <title>Document history</title>

        <para>The exact file history is recorded in the <filename
        class="directory">manual</filename> module in our CVS tree; see <ulink
        url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028
        </ulink>. The full URL of the CVS log for this file can be found at <ulink
        url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/firebirdinternals.xml?view=log"
        userlevel="">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/firebirdinternals.xml?view=log</ulink></para>

        <para><revhistory>
                <revision>
                    <revnumber>1.0</revnumber>

                    <date>03 November 2009</date>

                    <authorinitials>ND</authorinitials>

                    <revdescription>
                        <para>Created a new manual.</para>
                    </revdescription>
                </revision>
            </revhistory></para>
    </appendix>

    <appendix id="fbint-license">
        <title>License notice</title>

        <para>The contents of this Documentation are subject to the Public Documentation
        License Version 1.0 (the <quote>License</quote>); you may only use this
        Documentation if you comply with the terms of this License. Copies of the License
        are available at <ulink
        url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
        (PDF) and <ulink
        url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
        (HTML).</para>

        <para>The Original Documentation is titled <citetitle>Firebird
        Internals</citetitle>.</para>

        <para>The Initial Writer of the Original Documentation is: Norman Dunbar.</para>

        <para>Copyright (C) 2009. All Rights Reserved. Initial Writer contact:
        NormanDunbar at users dot sourceforge dot net.</para>
    </appendix>
</article>
