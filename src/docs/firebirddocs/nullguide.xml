<?xml version="1.0" encoding="UTF-8"?>
<!-- For standalone validation, uncomment the following DOCTYPE declaration. -->
<!--
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
-->
<article id="nullguide">
  <articleinfo>
    <title>Firebird Null Guide</title>
    <subtitle><constant>NULL</constant> behaviour and pitfalls in Firebird SQL</subtitle>
    <author>
      <firstname>Paul</firstname>
      <surname>Vinkenoog</surname>
    </author>
    <edition>26 January 2007 – Document version 1.0.1</edition>
  </articleinfo>
  <section id="nullguide-whatisnull">
    <title><indexterm>
        <primary>NULL</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>What is it?</secondary>
      </indexterm>What is <constant>NULL</constant>?</title>
    <para>Time and again, support questions pop up on the Firebird mailing lists about
    <quote>strange things</quote> happening with <constant>NULL</constant>s. The concept seems
    difficult to grasp – perhaps partly because of the name, which suggests a kind of
    <quote>nothing</quote> that won't do any harm if you add it to a number or stick it to the back
    of a string. In reality, performing such operations will render the entire expression
    <constant>NULL</constant>.</para>
    <para>This guide explores the behaviour of <constant>NULL</constant> in Firebird SQL, points out
    common pitfalls and shows you how to deal safely with expressions that contain
    <constant>NULL</constant> or may resolve to <constant>NULL</constant>.</para>
    <para>If you only need a quick reference to refresh your memory, go to the <link
    linkend="nullguide-summary">summary</link> at the end of the guide.</para>
    <bridgehead renderas="sect3">So – what is it?</bridgehead>
    <para>In SQL, <constant>NULL</constant> is not a value. It is a <emphasis>state</emphasis>
    indicating that an item's value is unknown or nonexistent. It is not zero or blank or an
    <quote>empty string</quote> and it does not behave like any of these values. Few things in SQL
    lead to more confusion than <constant>NULL</constant>, and yet its workings shouldn't be hard to
    understand as long as you stick to the following simple definition: <constant>NULL</constant>
    means <emphasis>unknown</emphasis>.</para>
    <para>Let me repeat that:</para>
    <blockquote>
      <para>
        <emphasis role="bold"><constant>NULL</constant> means UNKNOWN</emphasis>
      </para>
    </blockquote>
    <para>Keep this line in mind as you read through the rest of the guide, and most of the
    seemingly illogical results you can get with <constant>NULL</constant> will practically explain
    themselves.</para>
    <note>
      <para>A few sentences and examples in this guide were taken from the <citetitle>Firebird Quick
      Start Guide</citetitle>, first published by IBPhoenix, now part of the Firebird
      Project.</para>
    </note>
  </section>
  <section id="nullguide-langelem">
    <title><constant>NULL</constant> support in Firebird SQL</title>
    <para>Only a few language elements are purposely designed to give an unambiguous result with
    <constant>NULL</constant> (unambiguous in the sense that some specific action is taken and/or a
    non-<constant>NULL</constant> result is returned). They are discussed in the following
    paragraphs.</para>
    <section id="nullguide-langelem-notnull">
      <title><indexterm>
          <primary>NOT NULL</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>disallow</secondary>
        </indexterm>Disallowing <constant>NULL</constant></title>
      <para>In a column or domain definition, you can specify that only
      non-<constant>NULL</constant> values may be entered by adding <database>NOT NULL</database> to
      the definition:</para>
      <blockquote>
        <programlisting>create table MyTable ( i int <emphasis role="bold">not null</emphasis>
        )</programlisting>
        <programlisting>create domain DTown as varchar( 32 ) <emphasis role="bold">not
        null</emphasis></programlisting>
      </blockquote>
      <para>Special care should be taken when adding a <database>NOT NULL</database> field to an
      existing table that already contains records. This operation will be discussed in detail in
      the section <link linkend="nullguide-alter-pop-tables">
          <citetitle>Altering populated tables</citetitle>
        </link>.</para>
    </section>
    <section id="nullguide-langelem-isnull">
      <title><indexterm>
          <primary>IS [NOT] NULL</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>test for</secondary>
        </indexterm><indexterm>
          <primary>Testing for NULL</primary>
        </indexterm>Testing for <constant>NULL</constant></title>
      <para>If you want to know whether a variable, field or other expression is
      <constant>NULL</constant>, use the following syntax:</para>
      <blockquote>
        <para>
          <replaceable>&lt;expression&gt;</replaceable>
          <database>IS [NOT] NULL</database>
        </para>
      </blockquote>
      <para>Examples:</para>
      <blockquote>
        <programlisting>if ( MyField <emphasis role="bold">is null</emphasis> ) then YourString =
        'Dunno'</programlisting>
        <programlisting>select * from Pupils where PhoneNumber <emphasis role="bold">is not
        null</emphasis></programlisting>
        <programlisting>select * from Pupils where not ( PhoneNumber <emphasis role="bold">is
        null</emphasis> ) /* does the same as the previous example */</programlisting>
        <programlisting>update Numbers set Total = A + B + C where A + B + C <emphasis
        role="bold">is not null</emphasis></programlisting>
        <programlisting>delete from Phonebook where PhoneNum <emphasis role="bold">is
        null</emphasis></programlisting>
      </blockquote>
      <para>Do <emphasis role="bold">not</emphasis> use <quote>... =
      <constant>NULL</constant></quote> to test for nullness. This syntax is illegal in Firebird
      versions up to 1.5.n, and gives the wrong result in Firebird 2 and up: it returns
      <constant>NULL</constant> no matter what you compare. This is by design, incidentally, and in
      that sense it's not <emphasis>really</emphasis> wrong – it just doesn't give you what you
      want. The same goes for <quote>... &lt;&gt; <constant>NULL</constant></quote>, so don't use
      that either; use <database>IS NOT NULL</database> instead.</para>
      <para><database>IS NULL</database> and <database>IS NOT NULL</database> always return
      <constant>true</constant> or <constant>false</constant>; they never return
      <constant>NULL</constant>.</para>
    </section>
    <section id="nullguide-langelem-assign">
      <title><indexterm>
          <primary>NULL</primary>
          <secondary>assign</secondary>
        </indexterm><indexterm>
          <primary>Assigning NULL</primary>
        </indexterm>Assigning <constant>NULL</constant></title>
      <para>Setting a field or variable to <constant>NULL</constant> is done with the
      <quote>=</quote> operator, just like assigning values. You can also include
      <constant>NULL</constant> in an insert list:</para>
      <blockquote>
        <programlisting>if ( YourString = 'Dunno' ) then MyField = null</programlisting>
        <programlisting>update Potatoes set Amount = null where Amount &lt; 0</programlisting>
        <programlisting>insert into MyTable values ( 3, '8-May-2004', NULL, 'What?'
        )</programlisting>
      </blockquote>
      <para>Remember:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>You cannot – and should not – use the <emphasis>comparison operator</emphasis>
          <quote>=</quote> to <emphasis>test</emphasis> if something <emphasis>is</emphasis>
          <constant>NULL</constant>...</para>
        </listitem>
        <listitem>
          <para>...but you can – and often must – use the <emphasis>assignment operator</emphasis>
          <quote>=</quote> to <emphasis>set</emphasis> something <emphasis>to</emphasis>
          <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="nullguide-langelem-distinct">
      <title><indexterm>
          <primary>DISTINCT</primary>
          <secondary>testing distinctness</secondary>
        </indexterm><indexterm>
          <primary>IS [NOT] DISTINCT FROM</primary>
        </indexterm>Testing DISTINCTness (Firebird 2+)</title>
      <para>In Firebird 2 and higher only, you can test for the null-encompassing equality of two
      expressions with <quote>
          <database>IS [NOT] DISTINCT FROM</database>
        </quote>:</para>
      <blockquote>
        <para>
          <programlisting>if ( A <emphasis role="bold">is distinct from</emphasis> B )
          then...</programlisting>
          <programlisting>if ( Buyer1 <emphasis role="bold">is not distinct from</emphasis> Buyer2 )
          then...</programlisting>
        </para>
      </blockquote>
      <para>Fields, variables and other expressions are considered:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><database>DISTINCT</database> if they have different values or if one of them is
          <constant>NULL</constant> and the other isn't;</para>
        </listitem>
        <listitem>
          <para><database>NOT DISTINCT</database> if they have the same value or if both of them are
          <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>
      <para><database>[NOT] DISTINCT</database> always returns <constant>true</constant> or
      <constant>false</constant>, never <constant>NULL</constant> or something else.</para>
      <para>With earlier Firebird versions, you have to write special code to obtain the same
      information. This will be discussed later.</para>
    </section>
    <section id="nullguide-langelem-literal">
      <title><indexterm>
          <primary>NULL</primary>
          <secondary>literal</secondary>
        </indexterm>The <constant>NULL</constant> literal</title>
      <para>The ability to use <literal>NULL</literal> literals depends on your Firebird
      version.</para>
      <section>
        <title>Firebird 1.5 and below</title>
        <para>In Firebird 1.5 and below you can only use the literal word <quote>
            <literal>NULL</literal>
          </quote> in a few situations, namely the ones described in the previous paragraphs plus a
        few others such as <quote>cast( <constant>NULL</constant> as
        <replaceable>&lt;datatype&gt;</replaceable> )</quote> and <quote>select
        <constant>NULL</constant> from MyTable</quote>.</para>
        <para>In all other circumstances, Firebird will complain that <literal>NULL</literal> is an
        unknown token. If you really <emphasis>must</emphasis> use <constant>NULL</constant> in such
        a context, you have to resort to tricks like <quote>cast( <constant>NULL</constant> as int
        )</quote>, or using a field or variable that you know is <constant>NULL</constant>,
        etc.</para>
      </section>
      <section>
        <title>Firebird 2.0 and up</title>
        <para>Firebird 2 allows the use of <constant>NULL</constant> literals in every context where
        a normal value can also be entered. You can e.g. include <constant>NULL</constant> in an
        <database>IN()</database> list, write expressions like <quote>if ( MyField =
        <constant>NULL</constant> ) then...</quote>, and so on. However, as a general rule you
        should <emphasis role="bold">not</emphasis> make use of these new possibilities! In almost
        every thinkable situation, such use of <constant>NULL</constant> literals is a sign of poor
        SQL design and will lead to <constant>NULL</constant> results where you meant to get
        <constant>true</constant> or <constant>false</constant>. In that sense the earlier, more
        restrictive policy was safer, although you could always bypass it with casts etc. – but at
        least you had to take deliberate steps to bypass it.</para>
      </section>
    </section>
  </section>
  <section id="nullguide-oper">
    <title><indexterm>
        <primary>NULL</primary>
        <secondary>in operations</secondary>
      </indexterm><constant>NULL</constant> in operations</title>
    <para>As many of us have found out to our chagrin, <constant>NULL</constant> is contagious: use
    it in a numerical, string or date/time operation, and the result will invariably be
    <constant>NULL</constant>. With boolean operators, the outcome depends on the type of operation
    and the value of the other operand.</para>
    <para>Please remember that in Firebird versions prior to 2.0 it is mostly illegal to use the
    constant <constant>NULL</constant> directly in operations or comparisons. Wherever you see
    <constant>NULL</constant> in the expressions below, read it as <quote>a field, variable or other
    expression that resolves to <constant>NULL</constant></quote>. In Firebird 2 and above this
    expression may also be a <constant>NULL</constant> literal.</para>
    <section id="nullguide-oper-returning-null">
      <title><indexterm>
          <primary>Mathematical operations</primary>
        </indexterm><indexterm>
          <primary>String operations</primary>
        </indexterm><indexterm>
          <primary>Comparison operations</primary>
        </indexterm>Mathematical and string operations</title>
      <para>The operations in this list <emphasis>always</emphasis> return
      <constant>NULL</constant>:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>1 + 2 + 3 + <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>5 * <constant>NULL</constant> - 7</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>'Home ' || 'sweet ' || <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>MyField = <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal>MyField &lt;&gt; <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> = <constant>NULL</constant></literal>
          </para>
        </listitem>
      </itemizedlist>
      <para>If you have difficulty understanding why, remember that <constant>NULL</constant> means
      <quote>unknown</quote>. You can also look at the following table where per-case explanations
      are provided. In the table we don't write <constant>NULL</constant> in the expressions (as
      said, this is often illegal); instead, we use two entities A and B that are both
      <constant>NULL</constant>. A and B may be fields, variables, or even composite subexpressions
      – as long as they're <constant>NULL</constant>, they'll all behave the same in the enclosing
      expressions.</para>
      <table>
        <title>Operations on null entities A and B</title>
        <tgroup cols="3">
          <colspec colname="colExpr" colnum="1" colwidth="4*" />
          <colspec colname="colResult" colnum="2" colwidth="*" />
          <colspec align="left" colname="colReason" colnum="3" colwidth="6*" />
          <thead>
            <row>
              <entry align="center">If A and B are NULL, then:</entry>
              <entry align="center">Is:</entry>
              <entry align="center">Because:</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>1 + 2 + 3 + A</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>If A is unknown, then 6 + A is also unknown.</entry>
            </row>
            <row>
              <entry>
                <literal>5 * A - 7</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>If A is unknown, then 5 * A is also unknown. Subtract 7 and you end up with
              another unknown.</entry>
            </row>
            <row>
              <entry>
                <literal>'Home ' || 'sweet ' || A </literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>If A is unknown, 'Home sweet ' || A is unknown.</entry>
            </row>
            <row>
              <entry>
                <literal>MyField = A</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>If A is unknown, you can't tell if MyField has the same value...</entry>
            </row>
            <row>
              <entry>
                <literal>MyField &lt;&gt; A</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>...but you also can't tell if MyField has a <emphasis>different</emphasis>
              value!</entry>
            </row>
            <row>
              <entry>
                <literal>A = B</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>With A and B unknown, it's impossible to know if they are equal.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <indexterm>
        <primary>BETWEEN</primary>
      </indexterm>
      <indexterm>
        <primary>STARTING WITH</primary>
      </indexterm>
      <indexterm>
        <primary>LIKE</primary>
      </indexterm>
      <indexterm>
        <primary>CONTAINING</primary>
      </indexterm>
      <para>Here is the complete list of math and string operators that return
      <constant>NULL</constant> if at least one operand is <constant>NULL</constant>:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><literal>+</literal>, <literal /><literal>-</literal>, <literal> *</literal>,
          <literal> /</literal>, <literal />and <literal /><literal>%</literal></para>
        </listitem>
        <listitem>
          <para><literal>!=</literal>, <literal /><literal>~=</literal>, <literal />and <literal> ^=
          </literal>(synonyms of<literal> &lt;&gt;</literal>)</para>
        </listitem>
        <listitem>
          <para><literal>&lt;</literal>, <literal /><literal>&lt;=</literal>,
          <literal /><literal>&gt;</literal>, <literal />and
          <literal /><literal>&gt;=</literal></para>
        </listitem>
        <listitem>
          <para><literal>!&lt;</literal>, <literal /><literal>~&lt;</literal>, <literal />and
          <literal> ^&lt; </literal>(low-precedence synonyms of<literal> &gt;=</literal>)</para>
        </listitem>
        <listitem>
          <para><literal>!&gt;</literal>, <literal /><literal>~&gt;</literal>, <literal />and
          <literal> ^&gt; </literal>(low-precedence synonyms of<literal> &lt;=</literal>)</para>
        </listitem>
        <listitem>
          <para>
            <literal>||</literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>[NOT] BETWEEN</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>[NOT] STARTING WITH</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>[NOT] LIKE</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>[NOT] CONTAINING</database>
          </para>
        </listitem>
      </itemizedlist>
      <!--'==' is not supported in practice, although EmbedSQL says it is. Maybe in IB6?-->
      <para>The explanations all follow the same pattern: if A is unknown, you can't tell if it's
      greater than B; if string S1 is unknown, you can't tell if it contains S2; etcetera.</para>
      <para>Using <database>LIKE</database> with a <constant>NULL</constant> escape character would
      crash the server in Firebird versions up to and including 1.5. This bug was fixed in v. 1.5.1.
      From that version onward, such a statement will yield an empty result set.</para>
    </section>
    <section id="nullguide-boolean-oper">
      <title><indexterm>
          <primary>NULL</primary>
          <secondary>in boolean operations</secondary>
        </indexterm><indexterm>
          <primary>Boolean operations</primary>
        </indexterm><indexterm>
          <primary>True</primary>
        </indexterm><indexterm>
          <primary>False</primary>
        </indexterm><indexterm>
          <primary>NOT operator</primary>
        </indexterm><indexterm>
          <primary>AND operator</primary>
        </indexterm><indexterm>
          <primary>OR operator</primary>
        </indexterm>Boolean operations</title>
      <para>All the operators examined so far return <constant>NULL</constant> if any operand is
      <constant>NULL</constant>. With boolean operators, things are a bit more complex:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>not <constant>NULL</constant> = <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> or <constant>false</constant> =
            <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> or <constant>true</constant> =
            <constant>true</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> or <constant>NULL</constant> =
            <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> and <constant>false</constant> =
            <constant>false</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> and <constant>true</constant> =
            <constant>NULL</constant></literal>
          </para>
        </listitem>
        <listitem>
          <para>
            <literal><constant>NULL</constant> and <constant>NULL</constant> =
            <constant>NULL</constant></literal>
          </para>
        </listitem>
      </itemizedlist>
      <para>In reality, Firebird SQL doesn't have a boolean data type; nor are
      <constant>true</constant> and <constant>false</constant> existing constants. In the leftmost
      column of the explanatory table below, <quote>
          <literal>true</literal>
        </quote> and <quote>
          <literal>false</literal>
        </quote> represent expressions (fields, variables, composites...) that evaluate to
      <constant>true</constant>/<constant>false</constant>.</para>
      <table>
        <title>Boolean operations on null entity A</title>
        <tgroup cols="3">
          <colspec colname="colExpr" colnum="1" colwidth="2*" />
          <colspec colname="colResult" colnum="2" colwidth="*" />
          <colspec align="left" colname="colReason" colnum="3" colwidth="8*" />
          <thead>
            <row>
              <entry align="center">If A is <constant>NULL</constant>, then:</entry>
              <entry align="center">Is:</entry>
              <entry align="center">Because:</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <literal>not A</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry>If A is unknown, its inverse is also unknown.</entry>
            </row>
            <row>
              <entry>
                <literal>A or false</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry><quote>
                  <literal>A or <constant>false</constant></literal>
                </quote> always has the same value as A – which is unknown.</entry>
            </row>
            <row>
              <entry>
                <literal>A or true</literal>
              </entry>
              <entry>
                <literal>
                  <constant>true</constant>
                </literal>
              </entry>
              <entry><quote>
                  <literal>A or <constant>true</constant></literal>
                </quote> is always <constant>true</constant> – A's value doesn't matter.</entry>
            </row>
            <row>
              <entry>
                <literal>A or A</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry><quote>
                  <literal>A or A</literal>
                </quote> always equals A – which is <constant>NULL</constant>.</entry>
            </row>
            <row>
              <entry>
                <literal>A and false</literal>
              </entry>
              <entry>
                <literal>
                  <constant>false</constant>
                </literal>
              </entry>
              <entry><quote>
                  <literal>A and <constant>false</constant></literal>
                </quote> is always <constant>false</constant> – A's value doesn't matter.</entry>
            </row>
            <row>
              <entry>
                <literal>A and true</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry><quote>
                  <literal>A and <constant>true</constant></literal>
                </quote> always has the same value as A – which is unknown.</entry>
            </row>
            <row>
              <entry>
                <literal>A and A</literal>
              </entry>
              <entry>
                <literal>
                  <constant>NULL</constant>
                </literal>
              </entry>
              <entry><quote>
                  <literal>A and A</literal>
                </quote> always equals A – which is <constant>NULL</constant>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>All these results are in accordance with boolean logic. The fact that you don't need to
      know X's value to compute <quote>X or <constant>true</constant></quote> and <quote>X and
      <constant>false</constant></quote> is also the basis of a feature found in various programming
      languages: short-circuit boolean evaluation.</para>
      <para>The above results can be generalised as follows for expressions with one type of binary
      boolean operator (<literal>and</literal> | <literal>or</literal>) and any number of
      operands:</para>
      <variablelist spacing="compact">
        <varlistentry>
          <term><indexterm>
              <primary>Disjunctions</primary>
            </indexterm><indexterm>
              <primary>NULL</primary>
              <secondary>in disjunctions</secondary>
            </indexterm>Disjunctions (<quote>A or B or C or D or ...</quote>)</term>
          <listitem>
            <orderedlist spacing="compact">
              <listitem>
                <para>If at least one operand is <constant>true</constant>, the result is
                <constant>true</constant>.</para>
              </listitem>
              <listitem>
                <para>Else, if at least one operand is <constant>NULL</constant>, the result is
                <constant>NULL</constant>.</para>
              </listitem>
              <listitem>
                <para>Else (i.e. if all operands are <constant>false</constant>) the result is
                <constant>false</constant>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term><indexterm>
              <primary>Conjunctions</primary>
            </indexterm><indexterm>
              <primary>NULL</primary>
              <secondary>in conjunctions</secondary>
            </indexterm>Conjunctions (<quote>A and B and C and D and ...</quote>)</term>
          <listitem>
            <orderedlist spacing="compact">
              <listitem>
                <para>If at least one operand is <constant>false</constant>, the result is
                <constant>false</constant>.</para>
              </listitem>
              <listitem>
                <para>Else, if at least one operand is <constant>NULL</constant>, the result is
                <constant>NULL</constant>.</para>
              </listitem>
              <listitem>
                <para>Else (i.e. if all operands are <constant>true</constant>) the result is
                <constant>true</constant>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>
      </variablelist>
      <indexterm>
        <primary>True</primary>
        <secondary>beating NULL</secondary>
      </indexterm>
      <indexterm>
        <primary>False</primary>
        <secondary>beating NULL</secondary>
      </indexterm>
      <para>Or, shorter:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para><constant>TRUE</constant> beats <constant>NULL</constant> in a disjunction
          (OR-operation);</para>
        </listitem>
        <listitem>
          <para><constant>FALSE</constant> beats <constant>NULL</constant> in a conjunction
          (AND-operation);</para>
        </listitem>
        <listitem>
          <para>In all other cases, <constant>NULL</constant> wins.</para>
        </listitem>
      </itemizedlist>
      <para>If you have trouble remembering which constant rules which operation, look at the second
      letter: t<emphasis role="bold">R</emphasis>ue prevails with o<emphasis
      role="bold">R</emphasis> — f<emphasis role="bold">A</emphasis>lse with <emphasis
      role="bold">A</emphasis>nd.</para>
    </section>
    <section id="nullguide-oper-morelogic">
      <title>More logic (or not)</title>
      <para>The short-circuit results obtained above may lead you to the following ideas:</para>
      <itemizedlist>
        <listitem>
          <para>0 times <varname>x</varname> equals 0 for every <varname>x</varname>. Hence, even if
          <varname>x</varname>'s value is unknown, <literal>0 * x</literal> is 0. (Note: this only
          holds if <varname>x</varname>'s datatype only contains numbers, not
          <constant>NaN</constant> or infinities.)</para>
        </listitem>
        <listitem>
          <para>The empty string is ordered lexicographically before every other string. Therefore,
          <literal>S &gt;= ''</literal> is true whatever the value of S.</para>
        </listitem>
        <listitem>
          <para>Every value equals itself, whether it's unknown or not. So, although <literal>A =
          B</literal> justifiably returns <constant>NULL</constant> if A and B are different
          <constant>NULL</constant> entities, <literal>A = A</literal> should always return
          <constant>true</constant>, even if A is <constant>NULL</constant>. The same goes for
          <literal>A &lt;= A</literal> and <literal>A &gt;= A</literal>.</para>
          <para>By analogous logic, <literal>A &lt;&gt; A</literal> should always be
          <constant>false</constant>, as well as <literal>A &lt; A</literal> and <literal>A &gt;
          A</literal>.</para>
        </listitem>
        <listitem>
          <para>Every string <emphasis>contains</emphasis> itself, <emphasis>starts with</emphasis>
          itself and is <emphasis>like</emphasis> itself. So, <quote>
              <literal>S CONTAINING S</literal>
            </quote>, <quote>
              <literal>S STARTING WITH S</literal>
            </quote> and <quote>
              <literal>S LIKE S</literal>
            </quote> should always return <constant>true</constant>.</para>
        </listitem>
      </itemizedlist>
      <para>How is this reflected in Firebird SQL? Well, I'm sorry I have to inform you that despite
      this compelling logic – and the analogy with the boolean results discussed above – the
      following expressions all resolve to <constant>NULL</constant>:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <literal>
              <constant>0 * NULL</constant>
            </literal>
          </para>
        </listitem>
        <listitem>
          <para><literal><constant>NULL</constant> &gt;= ''</literal><literal /> and
          <literal /><literal>'' &lt;= <constant>NULL</constant></literal></para>
        </listitem>
        <listitem>
          <para><literal>A = A</literal>, <literal /><literal>A &lt;= A</literal><literal /> and
          <literal /><literal>A &gt;= A</literal></para>
        </listitem>
        <listitem>
          <para><literal>A &lt;&gt; A</literal>, <literal /><literal>A &lt; A</literal><literal />
          and <literal /><literal>A &gt; A</literal></para>
        </listitem>
        <listitem>
          <para><literal>S CONTAINING S</literal>, <literal /><literal>S STARTING WITH
          S</literal><literal /> and <literal /><literal>S LIKE S</literal></para>
        </listitem>
      </itemizedlist>
      <para>So much for consistency.</para>
    </section>
  </section>
  <section id="nullguide-intfunc-direct">
    <title>Internal functions and directives</title>
    <section id="nullguide-expr-internfuncs">
      <title><indexterm>
          <primary>Internal functions</primary>
        </indexterm><indexterm>
          <primary>Functions</primary>
          <secondary>internal</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>in internal functions</secondary>
        </indexterm>Internal functions</title>
      <para>The following built-in functions return <constant>NULL</constant> if at least one
      argument is <constant>NULL</constant>:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <database>CAST()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>EXTRACT()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>GEN_ID()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>SUBSTRING()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>UPPER()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>LOWER()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>BIT_LENGTH()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>CHAR[ACTER]_LENGTH()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>OCTET_LENGTH()</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>TRIM()</database>
          </para>
        </listitem>
      </itemizedlist>
      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>In 1.0.0, <database>EXTRACT</database> from a <constant>NULL</constant> date would
            crash the server. Fixed in 1.0.2.</para>
          </listitem>
          <listitem>
            <para>If the first argument to <database>GEN_ID</database> is a valid generator name and
            the second argument is <constant>NULL</constant>, the named generator keeps its current
            value.</para>
          </listitem>
          <listitem>
            <para>In versions up to and including 2.0, <database>SUBSTRING</database> results are
            sometimes returned as <quote>false emptystrings</quote>. These strings are in fact
            <constant>NULL</constant>, but are described by the server as non-nullable. Therefore,
            most clients show them as empty strings. See the <link
            linkend="nullguide-bugs-substring">bugs list</link> for a detailed description.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>
    <section id="nullguide-expr-first-skip-rows">
      <title><indexterm>
          <primary>Directives</primary>
        </indexterm><indexterm>
          <primary>FIRST</primary>
        </indexterm><indexterm>
          <primary>SKIP</primary>
        </indexterm><indexterm>
          <primary>ROWS</primary>
        </indexterm><database>FIRST</database>, <database>SKIP</database> and
      <database>ROWS</database></title>
      <para>The following two directives <emphasis role="bold">crash</emphasis> a Firebird 1.5.n or
      lower server if given a <constant>NULL</constant> argument. In Firebird 2, they treat
      <constant>NULL</constant> as the value 0:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <database>FIRST</database>
          </para>
        </listitem>
        <listitem>
          <para>
            <database>SKIP</database>
          </para>
        </listitem>
      </itemizedlist>
      <para>This new Firebird 2 directive returns an empty set if any argument is
      <constant>NULL</constant>:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <database>ROWS</database>
          </para>
        </listitem>
      </itemizedlist>
      <para>Side note: <database>ROWS</database> complies with the SQL standard. In new code, use
      <database>ROWS</database>, not <database>FIRST</database> and
      <database>SKIP</database>.</para>
    </section>
  </section>
  <section id="nullguide-predicates">
    <title><indexterm>
        <primary>Predicates</primary>
      </indexterm>Predicates</title>
    <para>Predicates are statements about objects that return a boolean result:
    <constant>true</constant>, <constant>false</constant> or <constant>unknown</constant> (=
    <constant>NULL</constant>). In computer code you typically find predicates in places where as
    yes/no type of decision has to be taken. For Firebird SQL, that means in
    <database>WHERE</database>, <database>HAVING</database>, <database>CHECK</database>,
    <database>CASE WHEN</database>, <database>IF</database> and <database>WHILE</database>
    clauses.</para>
    <para>Comparisons such as <quote>x &gt; y</quote> also return boolean results, but they are
    generally not called predicates, although this is mainly a matter of form. An expression like
    Greater( x, y ) that does exactly the same would immediately qualify as a predicate.
    (Mathematicians like predicates to have a <emphasis>name</emphasis> – such as
    <quote>Greater</quote> or just plain <quote>G</quote> – and a pair of
    <emphasis>parentheses</emphasis> to hold the arguments.)</para>
    <para>Firebird supports the following SQL predicates: <database>IN</database>,
    <database>ANY</database>, <database>SOME</database>, <database>ALL</database>,
    <database>EXISTS</database> and <database>SINGULAR</database>.</para>
    <note>
      <para>It is also perfectly defensible to call <quote>
          <database>IS [NOT] NULL</database>
        </quote> and <quote>
          <database>IS [NOT] DISTINCT FROM</database>
        </quote> predicates, despite the absence of parentheses. But, predicates or not, they have
      already been introduced and won't be discussed in this section.</para>
    </note>
    <section id="nullguide-pred-in">
      <title><indexterm>
          <primary>Predicates</primary>
          <secondary>IN</secondary>
        </indexterm><indexterm>
          <primary>IN predicate</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>with IN()</secondary>
        </indexterm>The <database>IN</database> predicate</title>
      <para>The <database>IN</database> predicate compares the expression on its left-hand side to a
      number of expressions passed in the argument list and returns <constant>true</constant> if a
      match is found. <database>NOT IN</database> always returns the opposite of
      <database>IN</database>. Some examples of its use are:</para>
      <blockquote>
        <programlisting>select RoomNo, Floor from Classrooms where Floor in (3, 4,
        5)</programlisting>
        <programlisting>delete from Customers where upper(Name) in ('UNKNOWN', 'NN',
        '')</programlisting>
        <programlisting>if ( A not in (MyVar, MyVar + 1, YourVar, HisVar) ) then
        ...</programlisting>
      </blockquote>
      <para>The list can also be generated by a one-column subquery:</para>
      <blockquote>
        <programlisting>select ID, Name, Class from Students where ID in (select distinct LentTo
        from LibraryBooks)</programlisting>
      </blockquote>
      <section>
        <title>With an empty list</title>
        <para>If the list is empty (this is only possible with a subquery), <database>IN</database>
        always returns <constant>false</constant> and <database>NOT IN</database> always returns
        <constant>true</constant>, even if the test expression is <constant>NULL</constant>. This
        makes sense: even if a value is unknown, it's certain not to occur in an empty list.</para>
      </section>
      <section>
        <title>With a <constant>NULL</constant> test expression</title>
        <para>If the list is not empty and the test expression – called <quote>A</quote> in the
        examples below – is <constant>NULL</constant>, the following predicates will always return
        <constant>NULL</constant>, regardless of the expressions in the list:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>A <database>IN</database> ( Expr1, Expr2, ..., Expr<replaceable>N</replaceable>
            )</para>
          </listitem>
          <listitem>
            <para>A <database>NOT IN</database> ( Expr1, Expr2, ...,
            Expr<replaceable>N</replaceable> )</para>
          </listitem>
        </itemizedlist>
        <para>The first result can be understood by writing out the entire expression as a
        disjunction (<database>OR</database>-chain) of equality tests:</para>
        <blockquote>
          <para>A=Expr1 or A=Expr2 or ... or A=Expr<replaceable>N</replaceable></para>
        </blockquote>
        <para>which, if A is <constant>NULL</constant>, boils down to</para>
        <blockquote>
          <para><constant>NULL</constant> or <constant>NULL</constant> or ... or
          <constant>NULL</constant></para>
        </blockquote>
        <para>which is <constant>NULL</constant>.</para>
        <para>The nullness of the second predicate follows from the fact that <quote>not
        (<constant>NULL</constant>)</quote> equals <constant>NULL</constant>.</para>
      </section>
      <section>
        <title>With <constant>NULL</constant>s in the list</title>
        <para>If A has a proper value but the list contains one or more <constant>NULL</constant>
        expressions, things become a little more complicated:</para>
        <itemizedlist>
          <listitem>
            <para>If at least one of the expressions in the list has the same value as A:</para>
            <itemizedlist spacing="compact">
              <listitem>
                <para><quote>A <database>IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> returns <constant>true</constant></para>
              </listitem>
              <listitem>
                <para><quote>A <database>NOT IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> returns <constant>false</constant></para>
              </listitem>
            </itemizedlist>
            <para>This is due to the fact that <quote><constant>true</constant> or
            <constant>NULL</constant></quote> returns <constant>true</constant> (see above). Or,
            more general: a disjunction where at least one of the elements is
            <constant>true</constant>, returns <constant>true</constant> even if some other elements
            are <constant>NULL</constant>. (Any <constant>false</constant>s, if present, are not in
            the way. In a disjunction, <constant>true</constant> rules.)</para>
          </listitem>
          <listitem>
            <para>If none of the expressions in the list have the same value as A:</para>
            <itemizedlist spacing="compact">
              <listitem>
                <para><quote>A <database>IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> returns <constant>NULL</constant></para>
              </listitem>
              <listitem>
                <para><quote>A <database>NOT IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> returns <constant>NULL</constant></para>
              </listitem>
            </itemizedlist>
            <para>This is because <quote><constant>false</constant> or
            <constant>NULL</constant></quote> returns <constant>NULL</constant>. In generalised
            form: a disjunction that has only <constant>false</constant> and
            <constant>NULL</constant> elements, returns <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>
        <para>Needless to say, if neither A nor any list expression is <constant>NULL</constant>,
        the result is always as expected and can only be <constant>true</constant> or
        <constant>false</constant>.</para>
      </section>
      <section>
        <title><database><indexterm>
            <primary>Predicates</primary>
            <secondary>IN</secondary>
            <tertiary>results</tertiary>
          </indexterm><indexterm>
            <primary>IN predicate</primary>
            <secondary>results</secondary>
          </indexterm>IN()</database> results</title>
        <para>The table below shows all the possible results for <database>IN</database> and
        <database>NOT IN.</database> To use it properly, start with the first question in the left
        column. If the answer is No, move on to the next line. As soon as an answer is Yes, read the
        results from the second and third columns and you're done.</para>
        <table id="nullguide-tbl-in-results">
          <title>Results for <quote>A [NOT] IN (&lt;list&gt;)</quote></title>
          <tgroup cols="3">
            <colspec colname="colConditions" colwidth="4*" />
            <colspec colname="colResultIn" colwidth="1*" />
            <colspec colname="colResultNotIn" colwidth="1*" />
            <thead>
              <row valign="top">
                <entry align="center" morerows="1">Conditions</entry>
                <entry align="center" nameend="colResultNotIn" namest="colResultIn">Results</entry>
              </row>
              <row>
                <entry align="center">IN()</entry>
                <entry align="center">NOT IN()</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Is the list empty?</entry>
                <entry align="center">
                  <constant>false</constant>
                </entry>
                <entry align="center">
                  <constant>true</constant>
                </entry>
              </row>
              <row>
                <entry>Else, is A <constant>NULL</constant>?</entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
              </row>
              <row>
                <entry>Else, is at least one list element equal to A?</entry>
                <entry align="center">
                  <constant>true</constant>
                </entry>
                <entry align="center">
                  <constant>false</constant>
                </entry>
              </row>
              <row>
                <entry>Else, is at least one list element <constant>NULL</constant>?</entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
              </row>
              <row>
                <entry>Else (i.e. all list elements are non-<constant>NULL</constant> and unequal to
                A )</entry>
                <entry align="center">
                  <constant>false</constant>
                </entry>
                <entry align="center">
                  <constant>true</constant>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>In many contexts (e.g. within <database>IF</database> and <database>WHERE</database>
        clauses), a <constant>NULL</constant> result behalves like <constant>false</constant> in
        that the condition is not satisfied when the test expression is <constant>NULL</constant>.
        On the one hand this is convenient for cases where you might expect
        <constant>false</constant> but <constant>NULL</constant> is returned: you simply won't
        notice the difference. On the other hand, this may also lead you to expect
        <constant>true</constant> when the expression is inverted (using <database>NOT</database>)
        and this is where you'll run into trouble. In that sense, the most <quote>dangerous</quote>
        case in the above table is when you use an expression of the type <quote>A <database>NOT
        IN</database> (&lt;list&gt;)</quote>, with A indeed not present in the list (so you'd expect
        a clear <constant>true</constant> result) but the list happens to contain one or more
        <constant>NULL</constant>s.</para>
        <caution>
          <para>Be especially careful if you use <database>NOT IN</database> with a subselect
          instead of an explicit list, e.g.</para>
          <blockquote>
            <programlisting>A not in ( select Number from MyTable )</programlisting>
          </blockquote>
          <para>If A is not present in the Number column, the result is <constant>true</constant> if
          no Number is <constant>NULL</constant>, but <constant>NULL</constant> if the column does
          contain a <constant>NULL</constant> entry. Please be aware that even in a situation where
          A is constant and its value is never contained in the Number column, the result of the
          expression (and therefore your program flow) may still vary over time according to the
          absence or presence of <constant>NULL</constant>s in the column. Hours of debugging fun!
          Of course you can avoid this particular problem simply by adding <quote>where Number is
          not <constant>NULL</constant></quote> to the subselect.</para>
        </caution>
        <warning id="nullguide-pred-in-bug">
          <title>Bug alert</title>
          <para>All Firebird versions before 2.0 contain a bug that causes <database>[NOT]
          IN</database> to return the wrong result if an index is active on the subselect and one of
          the following conditions is true:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>A is <constant>NULL</constant> and the subselect doesn't return any
              <constant>NULL</constant>s, or</para>
            </listitem>
            <listitem>
              <para>A is not <constant>NULL</constant> and the subselect result set doesn't contain
              A but does contain <constant>NULL</constant>(s).</para>
            </listitem>
          </itemizedlist>
          <para>Please realise that an index may be active even if it has not been created
          explicitly, namely if a key is defined on A.</para>
          <para>Example: Table TA has a column A with values { 3, 8 }. Table TB has a column B
          containing { 2, 8, 1, <constant>NULL</constant> }. The expressions:</para>
          <blockquote>
            <programlisting>A [not] in ( select B from TB )</programlisting>
          </blockquote>
          <para>should both return <constant>NULL</constant> for A = 3, because of the
          <constant>NULL</constant> in B. But if B is indexed, <database>IN</database> returns
          <constant>false</constant> and <database>NOT IN</database> returns
          <constant>true</constant>. As a result, the query</para>
          <blockquote>
            <programlisting>select A from TA where A not in ( select B from TB )</programlisting>
          </blockquote>
          <para>returns a dataset with one record – containing the field with value 3 – while it
          should have returned an empty set. Other errors may also occur, e.g. if you use <quote>
              <database>NOT IN</database>
            </quote> in an <database>IF</database>, <database>CASE</database> or
          <database>WHILE</database> statement.</para>
          <para>As an alternative to <database>
              <database>NOT IN</database>
            </database>, you can use <quote>
              <literal>&lt;&gt;</literal>
              <database>ALL</database>
            </quote>. The <database>ALL</database> predicate will be introduced shortly.</para>
        </warning>
      </section>
      <section>
        <title><database><indexterm>
            <primary>IN predicate</primary>
            <secondary>in CHECK constraints</secondary>
          </indexterm><indexterm>
            <primary>CHECK constraints</primary>
          </indexterm>IN()</database> in <database>CHECK</database> constraints</title>
        <para>The <database>IN()</database> predicate is often used in <database>CHECK</database>
        constraints. In that context, <constant>NULL</constant> expressions have a surprisingly
        different effect in Firebird versions 2.0 and up. This will be discussed in the section
        <link linkend="nullguide-check-constraints">
            <citetitle><database>CHECK</database> constraints</citetitle>
          </link>.</para>
      </section>
    </section>
    <section id="nullguide-pred-any-some-all">
      <title><indexterm>
          <primary>Predicates</primary>
          <secondary>ANY, SOME and ALL</secondary>
        </indexterm><indexterm>
          <primary>ANY</primary>
        </indexterm><indexterm>
          <primary>SOME</primary>
        </indexterm><indexterm>
          <primary>ALL</primary>
        </indexterm>The <database>ANY</database>, <database>SOME</database> and
      <database>ALL</database> quantifiers</title>
      <para>Firebird has two quantifiers that allow you to compare a value to the results of a
      subselect:</para>
      <itemizedlist>
        <listitem>
          <para><database>ALL</database> returns <constant>true</constant> if the comparison is true
          for <emphasis>every</emphasis> element in the subselect.</para>
        </listitem>
        <listitem>
          <para><database>ANY</database> and <database>SOME</database> (full synonyms) return
          <constant>true</constant> if the comparison is true for <emphasis>at least one</emphasis>
          element in the subselect.</para>
        </listitem>
      </itemizedlist>
      <para>With <database>ANY</database>, <database>SOME</database> and <database>ALL</database>
      you provide the comparison operator yourself. This makes it more flexible than
      <database>IN</database>, which only supports the (implicit) <quote>=</quote> operator. On the
      other hand, <database>ANY</database>, <database>SOME</database> and <database>ALL</database>
      only accept a subselect as an argument; you can't provide an explicit list, as with
      <database>IN</database>.</para>
      <para>Valid operators
      are<literal /><literal>=</literal>,<literal /><literal>!=</literal>,<literal /><literal>&lt;</literal>,<literal /><literal>&gt;</literal>,<literal /><literal>=&lt;</literal>,<literal /><literal>=&gt;</literal><literal />and
      all their synonyms. You can't use <database>LIKE</database>, <database>CONTAINING</database>,
      <database>IS DISTINCT FROM</database>, or any other operators.</para>
      <para>Some usage examples:</para>
      <blockquote>
        <programlisting>select name, income from blacksmiths where income &gt; any( select income
        from goldsmiths )</programlisting>
        <para>(returns blacksmiths who earn more than at least one goldsmith)</para>
        <programlisting>select name, town from blacksmiths where town != all( select distinct town
        from goldsmiths )</programlisting>
        <para>(returns blacksmiths who live in a goldsmithless town)</para>
        <programlisting>if ( GSIncome !&gt; some( select income from blacksmiths ) ) then
        PoorGoldsmith = 1; else PoorGoldsmith = 0;</programlisting>
        <para>(sets PoorGoldsmith to 1 if at least one blacksmith's income is not less than the
        value of GSIncome)</para>
      </blockquote>
      <section>
        <title><indexterm>
            <primary>Predicates</primary>
            <secondary>ANY, SOME and ALL</secondary>
            <tertiary>results</tertiary>
          </indexterm>Result values</title>
        <para>If the subselect returns an empty set, <database>ALL</database> returns
        <constant>true</constant> and <database>ANY</database>|<database>SOME</database> return
        <constant>false</constant>, even if the left-hand side expression is
        <constant>NULL</constant>. This follows from the definitions and the rules of formal logic.
        (Math-heads will already have noticed that <database>ALL</database> is equivalent to the
        universal (<quote>A</quote>) quantifier and
        <database>ANY</database>|<database>SOME</database> to the existential (<quote>E</quote>)
        quantifier.)</para>
        <para>For non-empty sets, you can write out <quote>A <replaceable>&lt;op&gt;</replaceable>
        <database>ANY</database>|<database>SOME</database>
        (<replaceable>&lt;subselect&gt;</replaceable>)</quote> as</para>
        <blockquote>
          <para>A <replaceable>&lt;op&gt;</replaceable> E1<literal /> <emphasis
          role="bold">or</emphasis> <literal />A <replaceable>&lt;op&gt;</replaceable> E2<literal />
          <emphasis role="bold">or</emphasis> <literal />...<literal /> <emphasis
          role="bold">or</emphasis> <literal />A <replaceable>&lt;op&gt;</replaceable>
          E<replaceable>n</replaceable></para>
        </blockquote>
        <para>with <replaceable>&lt;op&gt;</replaceable> the operator used and E1, E2 etc. the items
        returned by the subquery.</para>
        <para>Likewise, <quote>A <replaceable>&lt;op&gt;</replaceable> <database>ALL</database>
        (<replaceable>&lt;subselect&gt;</replaceable>)</quote> is the same as</para>
        <blockquote>
          <para>A <replaceable>&lt;op&gt;</replaceable> E1<literal /> <emphasis
          role="bold">and</emphasis> <literal />A <replaceable>&lt;op&gt;</replaceable>
          E2<literal /> <emphasis role="bold">and</emphasis> <literal />...<literal /> <emphasis
          role="bold">and</emphasis> <literal />A <replaceable>&lt;op&gt;</replaceable>
          E<replaceable>n</replaceable></para>
        </blockquote>
        <para>This should look familiar. The first writeout is equal to that of the
        <database>IN</database> predicate, except that the operator may now be something other than
        <quote>
            <literal>=</literal>
          </quote>. The second is different but has the same general form. We can now work out how
        nullness of A and/or nullness of subselect results affect the outcome of
        <database>ANY</database>|<database>SOME</database> and <database>ALL</database>. This is
        done in the same way as earlier with <database>IN</database>, so instead of including all
        the steps here we will just present the result tables. Again, read the questions in the left
        column from top to bottom. As soon as you answer a question with <quote>Yes</quote>, read
        the result from the second column and you're done.</para>
        <indexterm>
          <primary>ANY</primary>
          <secondary>results</secondary>
        </indexterm>
        <indexterm>
          <primary>SOME</primary>
          <secondary>results</secondary>
        </indexterm>
        <table id="nullguide-tbl-any-some-results">
          <title>Results for <quote>A &lt;op&gt; ANY|SOME (&lt;subselect&gt;)</quote></title>
          <tgroup cols="2">
            <colspec colname="colConditions" colwidth="4*" />
            <colspec colname="colResult" colwidth="1*" />
            <thead>
              <row valign="top">
                <entry align="center" morerows="1">Conditions</entry>
                <entry align="center">Result</entry>
              </row>
              <row>
                <entry align="center"><database>ANY</database> | <database>SOME</database></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Does the subselect return an empty set?</entry>
                <entry align="center">
                  <constant>false</constant>
                </entry>
              </row>
              <row>
                <entry>Else, is A <constant>NULL</constant>?</entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
              </row>
              <row>
                <entry>Else, does at least one comparison return <constant>true</constant>?</entry>
                <entry align="center">
                  <constant>true</constant>
                </entry>
              </row>
              <row>
                <entry>Else, does at least one comparison return <constant>NULL</constant>?</entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
              </row>
              <row>
                <entry>Else (i.e. all comparisons return <constant>false</constant>)</entry>
                <entry align="center">
                  <constant>false</constant>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>If you think these results look a lot like what we saw with <database>IN()</database>,
        you're right: with the <quote>
            <literal>=</literal>
          </quote> operator, <database>ANY</database> is the same as <database>IN</database>. In the
        same way, <quote>
            <literal>&lt;&gt;</literal>
            <database>ALL</database>
          </quote> is equivalent to <database>NOT IN</database>.</para>
        <warning id="nullguide-pred-any-bug">
          <title>Bug alert (revisited)</title>
          <para>In versions before 2.0, <quote>
              <literal>=</literal>
              <database>ANY</database>
            </quote> suffers from the same bug as <database>IN</database>. Under the
          <quote>right</quote> circumstances, this can lead to wrong results with expressions of the
          type <quote><database>NOT</database> A = <database>ANY</database>( ... )</quote>.</para>
          <para>On the bright side, <quote>
              <literal>&lt;&gt;</literal>
              <database>ALL</database>
            </quote> is not affected and will always return the right result.</para>
        </warning>
        <indexterm>
          <primary>ALL</primary>
          <secondary>results</secondary>
        </indexterm>
        <table id="nullguide-tbl-all-results">
          <title>Results for <quote>A &lt;op&gt; ALL (&lt;subselect&gt;)</quote></title>
          <tgroup cols="2">
            <colspec colname="colConditions" colwidth="4*" />
            <colspec colname="colResult" colwidth="1*" />
            <thead>
              <row valign="top">
                <entry align="center" morerows="1">Conditions</entry>
                <entry align="center">Result</entry>
              </row>
              <row>
                <entry align="center">
                  <database>ALL</database>
                </entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Does the subselect return an empty set?</entry>
                <entry align="center">
                  <constant>true</constant>
                </entry>
              </row>
              <row>
                <entry>Else, is A <constant>NULL</constant>?</entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
              </row>
              <row>
                <entry>Else, does at least one comparison return <constant>false</constant>?</entry>
                <entry align="center">
                  <constant>false</constant>
                </entry>
              </row>
              <row>
                <entry>Else, does at least one comparison return <constant>NULL</constant>?</entry>
                <entry align="center">
                  <constant>NULL</constant>
                </entry>
              </row>
              <row>
                <entry>Else (i.e. all comparisons return <constant>true</constant>)</entry>
                <entry align="center">
                  <constant>true</constant>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <warning id="nullguide-pred-all-bug">
          <title><database>ALL</database> bug</title>
          <para>Although <quote>
              <literal>&lt;&gt;</literal>
              <database>ALL</database>
            </quote> always works as it should, <database>ALL</database> should nevertheless be
          considered broken in all pre-2.0 versions of Firebird: with every operator other than
          <quote>
              <literal>&lt;&gt;</literal>
            </quote>, wrong results may be returned if an index is active on the subselect – with or
          without <constant>NULL</constant>s around.</para>
        </warning>
        <note>
          <para>Strictly speaking, the second question in both tables (<quote>is A
          <constant>NULL</constant>?</quote>) is redundant and can be dropped. If A is
          <constant>NULL</constant>, all the comparisons return <constant>NULL</constant>, so that
          situation will be caught a little later. And while we're at it, we could drop the first
          question too: the <quote>empty set</quote> situation is just a special case of the final
          <quote>else</quote>. The whole thing then once again boils down to
          <quote><constant>true</constant> beats <constant>NULL</constant> beats
          <constant>false</constant></quote> in disjunctions
          (<database>ANY</database>|<database>SOME</database>) and <quote><constant>false</constant>
          beats <constant>NULL</constant> beats <constant>true</constant></quote> in conjunctions
          (<database>ALL</database>).</para>
          <para>The reason we included those questions is convenience: you can see if a set is empty
          at a glance, and it's also easier to check if the left-hand side expression is
          <constant>NULL</constant> than to evaluate each and every comparison result. But do feel
          free to skip them, or to skip just the second. Do <emphasis>not</emphasis>, however, skip
          the first question and start with the second: this will lead to a wrong conclusion if the
          set is empty!</para>
        </note>
      </section>
    </section>
    <section id="nullguide-pred-exists-singular">
      <title><database>EXISTS</database> and <database>SINGULAR</database></title>
      <para>The <database>EXISTS</database> and <database>SINGULAR</database> predicates return
      information about a subquery, usually a correlated subquery. You can use them in
      <database>WHERE</database>, <database>HAVING</database>, <database>CHECK</database>,
      <database>CASE</database>, <database>IF</database> and <database>WHILE</database> clauses (the
      latter two are only available in PSQL, Firebird's stored procedure and trigger
      language).</para>
      <section id="nullguide-pred-exists">
        <title>
          <indexterm>
            <primary>EXISTS</primary>
          </indexterm>
          <indexterm>
            <primary>Predicates</primary>
            <secondary>EXISTS</secondary>
          </indexterm>
          <database>EXISTS</database>
        </title>
        <para><database>EXISTS</database> tells you whether a subquery returns at least one row of
        data. Suppose you want a list of farmers who are also landowners. You could get one like
        this:</para>
        <blockquote>
          <programlisting>SELECT Farmer FROM Farms WHERE EXISTS (SELECT * FROM Landowners WHERE
          Landowners.Name = Farms.Farmer)</programlisting>
        </blockquote>
        <para>This query returns the names of all farmers who also figure in the Landowners table.
        The <database>EXISTS</database> predicate returns <constant>true</constant> if the result
        set of the subselect contains at least one row. If it is empty, <database>EXISTS</database>
        returns <constant>false</constant>. <database>EXISTS</database> never returns
        <constant>NULL</constant>, because a result set always either has rows, or hasn't. Of course
        the subselect's search condition may evolve to <constant>NULL</constant> for certain rows,
        but that doesn't cause any uncertainty: such a row won't be included in the subresult
        set.</para>
        <note>
          <para>In reality, the subselect doesn't return a result set at all. The engine simply
          steps through the Landowners records one by one and applies the search condition. If it
          evolves to <constant>true</constant>, <database>EXISTS</database> returns
          <constant>true</constant> immediately and the remaining records aren't checked. If it
          evolves to <constant>false</constant> or <constant>NULL</constant>, the search continues.
          If all the records have been searched and there hasn't been a single
          <constant>true</constant> result, <database>EXISTS</database> returns
          <constant>false</constant>.</para>
        </note>
        <para><database>NOT EXISTS</database> always returns the opposite of
        <database>EXISTS</database>: <constant>false</constant> or <constant>true</constant>, never
        <constant>NULL</constant>. <database>NOT EXISTS</database> returns
        <constant>false</constant> immediately if it gets a <constant>true</constant> result on the
        subquery's search condition. Before returning <constant>true</constant> it must step through
        the entire set.</para>
      </section>
      <section id="nullguide-pred-singular">
        <title>
          <indexterm>
            <primary>SINGULAR</primary>
          </indexterm>
          <indexterm>
            <primary>Predicates</primary>
            <secondary>SINGULAR</secondary>
          </indexterm>
          <database>SINGULAR</database>
        </title>
        <para><database>SINGULAR</database> is an InterBase/Firebird extension to the SQL standard.
        It is often described as returning <constant>true</constant> if exactly one row in the
        subquery meets the search condition. By analogy with <database>EXISTS</database> this would
        make you expect that <database>SINGULAR</database> too will only ever return
        <constant>true</constant> or <constant>false</constant>. After all, a result set has either
        exactly 1 row or a different number of rows. Unfortunately, all versions of Firebird up to
        and including 2.0 have a bug that causes <constant>NULL</constant> results in a number of
        cases. The behaviour is pretty inconsistent, but at the same time fully reproducible. For
        instance, on a column <database>A</database> containing (1, <constant>NULL</constant>, 1), a
        <database>SINGULAR</database> test with subselect <quote>
            <code>A=1</code>
          </quote> returns <constant>NULL</constant>, but the same test on a column with (1, 1,
        <constant>NULL</constant>) returns <constant>false</constant>. Notice that only the
        insertion order is different here!</para>
        <para>To make matters worse, all versions prior to 2.0 sometimes return
        <constant>NULL</constant> for <database>NOT SINGULAR</database> where
        <constant>false</constant> or <constant>true</constant> is returned for
        <database>SINGULAR</database>. In 2.0, this at least doesn't happen anymore: it's either
        <constant>false</constant> vs. <constant>true</constant> or twice
        <constant>NULL</constant>.</para>
        <para>The code has been fixed for Firebird 2.1; from that version onward
        <database>SINGULAR</database> will return:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><constant>false</constant> if the search condition is never
            <constant>true</constant> (this includes the empty-set case);</para>
          </listitem>
          <listitem>
            <para><constant>true</constant> if the search condition is <constant>true</constant> for
            exactly 1 row;</para>
          </listitem>
          <listitem>
            <para><constant>false</constant> if the search condition is <constant>true</constant>
            for more than 1 row.</para>
          </listitem>
        </itemizedlist>
        <para>Whether the other rows yield <constant>false</constant>, <constant>NULL</constant> or
        a combination thereof, is irrelevant.</para>
        <para><database>NOT SINGULAR</database> will always return the opposite of
        <database>SINGULAR</database> (as is already the case in 2.0).</para>
        <para>In the meantime, if there's <emphasis>any</emphasis> chance that the search condition
        may evolve to <constant>NULL</constant> for one or more rows, you should always add an
        <database>IS NOT NULL</database> condition to your <database>[NOT] SINGULAR</database>
        clauses, e.g. like this:</para>
        <blockquote>
          <programlisting>... SINGULAR( SELECT * from MyTable WHERE MyField &gt; 38 AND MyField IS
          NOT NULL )</programlisting>
        </blockquote>
      </section>
    </section>
  </section>
  <section id="nullguide-searches">
    <title><indexterm>
        <primary>Searches</primary>
      </indexterm><indexterm>
        <primary>WHERE</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in searches</secondary>
      </indexterm>Searches</title>
    <para>If the search condition of a <database>SELECT</database>, <database>UPDATE</database> or
    <database>DELETE</database> statement resolves to <constant>NULL</constant> for a certain row,
    the effect is the same as if it had been <constant>false</constant>. Put another way: if the
    search expression is <constant>NULL</constant>, the condition is not met, and consequently the
    row is not included in the output set (or is not updated/deleted).</para>
    <note>
      <para>The <firstterm>search condition</firstterm> or <firstterm>search expression</firstterm>
      is the <database>WHERE</database> clause minus the <database>WHERE</database> keyword
      itself.</para>
    </note>
    <para>Some examples (with the search condition in boldface):</para>
    <blockquote>
      <programlisting>SELECT Farmer, Cows FROM Farms WHERE <emphasis role="bold">Cows &gt;
      0</emphasis> ORDER BY Cows</programlisting>
    </blockquote>
    <para>The above statement will return the rows for farmers that are known to possess at least
    one cow. Farmers with an unknown (<constant>NULL</constant>) number of cows will not be
    included, because the expression <quote>
        <literal>NULL &gt; 0</literal>
      </quote> returns <constant>NULL</constant>.</para>
    <blockquote>
      <programlisting>SELECT Farmer, Cows FROM Farms WHERE <emphasis role="bold">NOT (Cows &gt;
      0)</emphasis> ORDER BY Cows</programlisting>
    </blockquote>
    <para>Now, it's tempting to think that this will return <quote>all the other records</quote>
    from the Farms table, right? But it won't – not if the Cows column contains any
    <constant>NULL</constant>s. Remember that <literal>not(NULL)</literal> is itself
    <constant>NULL</constant>. So for any row where Cows is <constant>NULL</constant>, <quote>
        <literal>Cows &gt; 0</literal>
      </quote> will be <constant>NULL</constant>, and <quote>
        <literal>NOT (Cows &gt; 0)</literal>
      </quote> will be <constant>NULL</constant> as well.</para>
    <blockquote>
      <programlisting>SELECT Farmer, Cows, Sheep FROM Farms WHERE <emphasis role="bold">Cows + Sheep
      &gt; 0</emphasis></programlisting>
    </blockquote>
    <para>On the surface, this looks like a query returning all the farms that have at least one cow
    and/or sheep (assuming that neither Cows nor Sheep can be a negative number). However, if farmer
    Fred has 30 cows and an unknown number of sheep, the sum <literal>Cows + Sheep</literal> becomes
    <constant>NULL</constant>, and the entire search expression boils down to <quote>
        <literal>NULL &gt; 0</literal>
      </quote>, which is... you got it. So despite his 30 cows, our friend Fred won't make it into
    the result set.</para>
    <para>As a last example, we shall rewrite the previous statement so that it
    <emphasis>will</emphasis> return any farm which has at least one animal of a known kind, even if
    the other number is <constant>NULL</constant>. To do that, we exploit the fact that <quote>
        <literal>NULL or true</literal>
      </quote> returns <constant>true</constant> – one of the rare occasions where a
    <constant>NULL</constant> operand doesn't render the entire expression
    <constant>NULL</constant>:</para>
    <blockquote>
      <programlisting>SELECT Farmer, Cows, Sheep FROM Farms WHERE <emphasis role="bold">Cows &gt; 0
      OR Sheep &gt; 0</emphasis></programlisting>
    </blockquote>
    <para>This time, Fred's thirty cows will make the first comparison <constant>true</constant>,
    while the sheep bit is still <constant>NULL</constant>. So we have <quote>
        <literal>true or NULL</literal>
      </quote>, which is <constant>true</constant>, and the row will be included in the output
    set.</para>
    <caution>
      <para>If your search condition contains one or more <database>IN</database> predicates, there
      is the additional complication that some of the list elements (or subselect results) may be
      <constant>NULL</constant>. The implications of this are discussed in <link
          linkend="nullguide-pred-in">
          <citetitle>The IN() predicate</citetitle>
        </link>.</para>
    </caution>
  </section>
  <section id="nullguide-sorts">
    <title><indexterm>
        <primary>Sorting</primary>
      </indexterm><indexterm>
        <primary>Ordering</primary>
      </indexterm><indexterm>
        <primary>NULLS FIRST</primary>
      </indexterm><indexterm>
        <primary>NULLS LAST</primary>
      </indexterm><indexterm>
        <primary>ORDER BY</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in sorts</secondary>
      </indexterm>Sorts</title>
    <para>In Firebird 2, <constant>NULL</constant>s are considered <quote>smaller</quote> than
    anything else when it comes to sorting. Consequently, they come first in ascending sorts and
    last in descending sorts. You can override this default placement by adding a <database>NULLS
    FIRST</database> or <database>NULLS LAST</database> directive to the <database>ORDER
    BY</database> clause.</para>
    <para>In earlier versions, <constant>NULL</constant>s were always placed at the end of a sorted
    set, no matter whether the order was ascending or descending. For Firebird 1.0, that was the end
    of the story: <constant>NULL</constant>s would always come last in any sorted set, period.
    Firebird 1.5 introduced the <database>NULLS FIRST/LAST</database> syntax, so you could force
    them to the top or bottom.</para>
    <para>To sum it all up:</para>
    <table>
      <title><constant>NULL</constant> placement in ordered sets</title>
      <tgroup cols="4">
        <colspec colname="colStatement" colwidth="2*" />
        <colspec colname="colPlac10" colwidth="1*" />
        <colspec colname="colPlac15" colwidth="1*" />
        <colspec colname="colPlac2" colwidth="1*" />
        <thead>
          <row>
            <entry morerows="1">Ordering</entry>
            <entry align="center" nameend="colPlac2" namest="colPlac10"><constant>NULL</constant>s
            placement</entry>
          </row>
          <row>
            <entry align="center">Firebird 1</entry>
            <entry align="center">Firebird 1.5</entry>
            <entry align="center">Firebird 2</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>order by Field [asc]</entry>
            <entry>bottom</entry>
            <entry>bottom</entry>
            <entry>top</entry>
          </row>
          <row>
            <entry>order by Field desc</entry>
            <entry>bottom</entry>
            <entry>bottom</entry>
            <entry>bottom</entry>
          </row>
          <row>
            <entry>order by Field [asc | desc] nulls first</entry>
            <entry>—</entry>
            <entry>top</entry>
            <entry>top</entry>
          </row>
          <row>
            <entry>order by Field [asc | desc] nulls last</entry>
            <entry>—</entry>
            <entry>bottom</entry>
            <entry>bottom</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <para>Specifying <database>NULLS FIRST</database> on an ascending or <database>NULLS
    LAST</database> on a descending sort in Firebird 2 is of course rather pointless, but perfectly
    legal. The same is true for <database>NULLS LAST</database> on any sort in Firebird 1.5.</para>
    <note>
      <title>Notes</title>
      <itemizedlist>
        <listitem>
          <para>If you override the default <constant>NULL</constant>s placement, no index will be
          used for sorting. In Firebird 1.5, that is the case with <database>NULLS FIRST</database>.
          In 2.0 and higher, with <database>NULLS LAST</database> on ascending and <database>NULLS
          FIRST</database> on descending sorts.</para>
        </listitem>
        <listitem>
          <para>If you open a pre-2.0 database with Firebird 2, it will show the
          <emphasis>old</emphasis> <constant>NULL</constant> ordering behaviour (that is: at the
          bottom, unless overridden by <database>NULLS FIRST</database>). A backup-restore cycle
          will fix this, provided that at least the restore is executed with Firebird 2's
          gbak!</para>
        </listitem>
        <listitem>
          <para><indexterm>
              <primary>DISTINCT</primary>
              <secondary>SELECT DISTINCT</secondary>
            </indexterm><indexterm>
              <primary>SELECT DISTINCT</primary>
            </indexterm>Firebird 2.0 has a bug that causes the <database>NULLS FIRST|LAST</database>
          directive to fail under certain circumstances with <database>SELECT DISTINCT. See the
          <link linkend="nullguide-bugs-select-distinct">bugs list</link> for more
          details.</database></para>
        </listitem>
      </itemizedlist>
    </note>
    <warning>
      <para>Don't be tempted into thinking that, because <constant>NULL</constant> is the
      <quote>smallest thing</quote> in sorts since Firebird 2, an expression like
      <quote><constant>NULL</constant> &lt; 3</quote> will now also return
      <constant>true</constant>. It won't. Using <constant>NULL</constant> in this kind of
      expression will always give a <constant>NULL</constant> outcome.</para>
    </warning>
  </section>
  <section id="nullguide-aggrfunc">
    <title><indexterm>
        <primary>Aggregate functions</primary>
      </indexterm><indexterm>
        <primary>Functions</primary>
        <secondary>aggregate</secondary>
      </indexterm><indexterm>
        <primary>COUNT</primary>
      </indexterm><indexterm>
        <primary>SUM</primary>
      </indexterm><indexterm>
        <primary>AVG</primary>
      </indexterm><indexterm>
        <primary>MAX</primary>
      </indexterm><indexterm>
        <primary>MIN</primary>
      </indexterm><indexterm>
        <primary>LIST</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in aggregate functions</secondary>
      </indexterm>Aggregate functions</title>
    <para>The aggregate functions – <function>COUNT</function>, <function>SUM</function>,
    <function>AVG</function>, <function>MAX</function>, <function>MIN</function> and
    <function>LIST</function> – don't handle <constant>NULL</constant> in the same way as ordinary
    functions and operators. Instead of returning <constant>NULL</constant> as soon as a
    <constant>NULL</constant> operand is encountered, they only take non-<constant>NULL</constant>
    fields into consideration while computing the outcome. That is, if you have this table:</para>
    <informaltable>
      <tgroup cols="3">
        <colspec align="center" colname="colID" colwidth="1*" />
        <colspec colname="colName" colwidth="2*" />
        <colspec align="center" colname="colAmount" colwidth="2*" />
        <thead>
          <row>
            <entry align="center" nameend="colAmount" namest="colID">MyTable</entry>
          </row>
          <row>
            <entry>ID</entry>
            <entry>Name</entry>
            <entry>Amount</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry>1</entry>
            <entry>John</entry>
            <entry>37</entry>
          </row>
          <row>
            <entry>2</entry>
            <entry>Jack</entry>
            <entry>
              <constant>NULL</constant>
            </entry>
          </row>
          <row>
            <entry>3</entry>
            <entry>Jim</entry>
            <entry>5</entry>
          </row>
          <row>
            <entry>4</entry>
            <entry>Joe</entry>
            <entry>12</entry>
          </row>
          <row>
            <entry>5</entry>
            <entry>Josh</entry>
            <entry>
              <constant>NULL</constant>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
    <para>...the statement <userinput>select sum(Amount) from MyTable</userinput> returns 54, which
    is 37 + 5 + 12. Had all five fields been summed, the result would have been
    <constant>NULL</constant>. For <function>AVG</function>, the non-<constant>NULL</constant>
    fields are summed and the sum divided by the number of non-<constant>NULL</constant>
    fields.</para>
    <para>There is one exception to this rule: <function>COUNT(*)</function> returns the count of
    all rows, even rows whose fields are all <constant>NULL</constant>. But
    <function>COUNT</function>(<parameter>FieldName</parameter>) behaves like the other aggregate
    functions in that it only counts rows where the specified field is not
    <constant>NULL</constant>.</para>
    <para>Another thing worth knowing is that <function>COUNT(*)</function> and
    <function>COUNT(<parameter>FieldName</parameter>)</function> never return
    <constant>NULL</constant>: if there are no rows in the set, both functions return 0.
    <function>COUNT(<parameter>FieldName</parameter>)</function> also returns 0 if all
    <parameter>FieldName</parameter> fields in the set are <constant>NULL</constant>. The other
    aggregate functions return <constant>NULL</constant> in such cases. Be warned that
    <function>SUM</function> even returns <constant>NULL</constant> if used on an empty set, which
    is contrary to common logic (if there are no rows, the average, maximum and minimum are
    undefined, but the sum is <emphasis>known</emphasis> to be zero).</para>
    <para>Now let's put all that knowledge in a table for your easy reference:</para>
    <table id="nullguide-tbl-aggr-funcs">
      <title>Aggregate function results with different column states</title>
      <tgroup cols="4">
        <colspec colname="colAggFunc" />
        <colspec colname="colSetEmpty" />
        <colspec colname="colSetAllNulls" />
        <colspec colname="colSetHavingValues" colwidth="3*" />
        <spanspec nameend="colSetHavingValues" namest="colSetEmpty" spanname="spanAllSets" />
        <thead>
          <row>
            <entry morerows="1">Function</entry>
            <entry align="center" spanname="spanAllSets">Results</entry>
          </row>
          <row>
            <entry>Empty set</entry>
            <entry>All-null set or column</entry>
            <entry>Other sets or columns</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><database>COUNT</database>(*)</entry>
            <entry>0</entry>
            <entry>Total number of rows</entry>
            <entry>Total number of rows</entry>
          </row>
          <row>
            <entry><database>COUNT</database>(Field)</entry>
            <entry>0</entry>
            <entry>0</entry>
            <entry>Number of rows where Field is not <constant>NULL</constant></entry>
          </row>
          <row>
            <entry><database>MAX</database>, <database>MIN</database></entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>Max or min value found in the column</entry>
          </row>
          <row>
            <entry>
              <database>SUM</database>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>Sum of non-<constant>NULL</constant> values in the column</entry>
          </row>
          <row>
            <entry>
              <database>AVG</database>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>Average of non-<constant>NULL</constant> values in the column. This equals
            <database>SUM</database>(Field) / <database>COUNT</database>(Field).<footnote>
                <para>If Field is of an integer type, <database>AVG</database> is always rounded
                towards 0. For instance, 6 non-null <database>INT</database> records with a sum of
                -11 yield an average of -1, not -2.</para>
              </footnote></entry>
          </row>
          <row>
            <entry>
              <database>LIST</database>
              <footnote>
                <para><database>LIST</database> was added in Firebird 2.1</para>
              </footnote>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>
              <constant>NULL</constant>
            </entry>
            <entry>Comma-separated string concatenation of non-<constant>NULL</constant> values in
            the column</entry>
          </row>
        </tbody>
      </tgroup>
    </table>
    <section id="nullguide-aggrfunc-groupby">
      <title><indexterm>
          <primary>GROUP BY</primary>
        </indexterm><indexterm>
          <primary>Aggregate functions</primary>
          <secondary>GROUP BY</secondary>
        </indexterm><indexterm>
          <primary>Functions</primary>
          <secondary>aggregate</secondary>
          <tertiary>GROUP BY</tertiary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>and GROUP BY</secondary>
        </indexterm>The <database>GROUP BY</database> clause</title>
      <para>A <database>GROUP BY</database> clause doesn't change the aggregate function logic
      described above, except that it is now applied to each group individually rather than to the
      result set as a whole. Suppose you have a table Employee, with fields Dept and Salary which
      both allow <constant>NULL</constant>s, and you run this query:</para>
      <blockquote id="nullguide-groupby-example-qry">
        <programlisting>SELECT Dept, SUM(Salary) FROM Employee GROUP BY Dept</programlisting>
      </blockquote>
      <para>The result may look like this (the row where Dept is <literal>&lt;null&gt;</literal> may
      be at the top or bottom, depending on your Firebird version):</para>
      <blockquote>
        <screen>DEPT SUM ====== ===================== &lt;null&gt; 219465.19 000 266643.00 100
        155262.50 110 130442.81 115 13480000.00 120 &lt;null&gt; 121 110000.00 123
        390500.00</screen>
      </blockquote>
      <para>First notice that the people whose department is unknown (<constant>NULL</constant>) are
      grouped together, although you can't say that they have the same <emphasis>value</emphasis> in
      the Dept field. But the alternative would have been to give each of those records a
      <quote>group</quote> of their own. Not only would this possibly add a huge number of lines to
      the output, but it would also defeat the purpose of <emphasis>group</emphasis>ing: those lines
      wouldn't be aggregates, but simple <quote><database>SELECT</database> Dept, Salary</quote>
      rows. So it makes sense to group the <constant>NULL</constant> depts by their state and the
      rest by their value.</para>
      <para>Anyway, the Dept field is not what interests us most. What does the aggregate
      <database>SUM</database> column tell us? That all salaries are non-<constant>NULL</constant>,
      except in department 120? No. All we can say is that in every department except 120, there is
      at least one employee with a known salary in the database. Each department
      <emphasis>may</emphasis> contain <constant>NULL</constant> salaries; in dept. 120
      <emphasis>all</emphasis> the salaries are <constant>NULL</constant>.</para>
      <para>You can find out more by throwing in one or more <database>COUNT</database>() columns.
      For instance, if you want to know the number of <constant>NULL</constant> salaries in each
      group, add a column <quote><database>COUNT</database>(*) –
      <database>COUNT</database>(Salary)</quote>.</para>
      <section id="nullguide-aggrfunc-freq">
        <title>Counting frequencies</title>
        <para>A <database>GROUP BY</database> clause can be used to report the frequencies with
        which values occur in a table. In that case you use the same field name several times in the
        query statement. Let's say you have a table <database>TT</database> with a column
        <database>A</database> whose contents are { 3, 8, <constant>NULL</constant>, 6, 8, -1,
        <constant>NULL</constant>, 3, 1 }. To get a frequencies report, you could use:</para>
        <blockquote>
          <programlisting>SELECT A, COUNT(A) FROM TT GROUP BY A</programlisting>
        </blockquote>
        <para>which would give you this result:</para>
        <blockquote>
          <screen> A COUNT ============ ============ -1 1 1 1 3 2 6 1 8 2 &lt;null&gt; 0</screen>
        </blockquote>
        <para>Oops – something went wrong with the <constant>NULL</constant> count, but what?
        Remember that <function>COUNT(<parameter>FieldName</parameter>)</function> skips all
        <constant>NULL</constant> fields, so with
        <function>COUNT(<parameter>A</parameter>)</function> the count of the
        <literal>&lt;null&gt;</literal> group can only ever be 0. Reformulate your query like
        this:</para>
        <blockquote>
          <programlisting>SELECT A, COUNT(*) FROM TT GROUP BY A</programlisting>
        </blockquote>
        <para>and the correct value will be returned (in casu 2).</para>
      </section>
    </section>
    <section id="nullguide-aggrfunc-having">
      <title><indexterm>
          <primary>HAVING</primary>
        </indexterm><indexterm>
          <primary>Aggregate functions</primary>
          <secondary>HAVING</secondary>
        </indexterm>The <database>HAVING</database> clause</title>
      <para><database>HAVING</database> clauses can place extra restrictions on the output rows of
      an aggregate query – just like <database>WHERE</database> clauses do in record-by-record
      queries. A <database>HAVING</database> clause can impose conditions on any output column or
      combination of columns, aggregate or not.</para>
      <para>As far as <constant>NULL</constant> is concerned, the following two facts are worth
      knowing (and hardly surprising, I would guess):</para>
      <itemizedlist>
        <listitem>
          <para>Rows for which the <database>HAVING</database> condition evaluates to
          <constant>NULL</constant> won't be included in the result set. (<quote>Only
          <constant>true</constant> is good enough.</quote>)</para>
        </listitem>
        <listitem>
          <para><quote>
              <database>HAVING</database>
              <replaceable>&lt;col&gt;</replaceable>
              <database>IS [NOT] NULL</database>
            </quote> is a legal and often useful condition, whether
          <replaceable>&lt;col&gt;</replaceable> is aggregate or not. (But if
          <replaceable>&lt;col&gt;</replaceable> is non-aggregate, you may save the engine some work
          by changing <database>HAVING</database> to <database>WHERE</database> and placing the
          condition before the <quote>
              <database>GROUP BY</database>
            </quote> clause. This goes for any condition on non-aggregate columns.)</para>
        </listitem>
      </itemizedlist>
      <para>For instance, adding the following clause to the <link
      linkend="nullguide-groupby-example-qry">example query</link> from the <quote>
          <database>GROUP BY</database>
        </quote> paragraph:</para>
      <blockquote>
        <programlisting>...HAVING Dept IS NOT NULL</programlisting>
      </blockquote>
      <para>will prevent the first row from being output, whereas this one:</para>
      <blockquote>
        <programlisting>...HAVING SUM(Salary) IS NOT NULL</programlisting>
      </blockquote>
      <para>suppresses the sixth row (the one with Dept = 120).</para>
    </section>
  </section>
  <section id="nullguide-conditionals-loops">
    <title>Conditional statements and loops</title>
    <section id="nullguide-if">
      <title><indexterm>
          <primary>IF statements</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>in IF statements</secondary>
        </indexterm><database>IF</database> statements</title>
      <para>If the test expression of an <database>IF</database> statement resolves to
      <constant>NULL</constant>, the <database>THEN</database> clause is skipped and the
      <database>ELSE</database> clause – if present – executed. In other words,
      <constant>NULL</constant> and <constant>false</constant> have the same effect in this context.
      So in situations where you would logically expect <constant>false</constant> but
      <constant>NULL</constant> is returned, no harm will be done. However, we've already seen
      examples of <constant>NULL</constant> being returned where you would expect
      <constant>true</constant>, and that <emphasis>does</emphasis> affect the flow of the
      code!</para>
      <para>Below are some examples of the seemingly paradoxical (but perfectly correct) results you
      can get if <constant>NULL</constant>s creep into your <database>IF</database>
      statements.</para>
      <tip>
        <para>If you use Firebird 2 or higher, you can avoid all the pitfalls discussed here, simply
        by using <database>[NOT] DISTINCT</database> instead of the <quote>
            <literal>=</literal>
          </quote> and <quote>
            <literal>&lt;&gt;</literal>
          </quote> operators!</para>
      </tip>
      <itemizedlist>
        <listitem>
          <para>
            <programlisting>if (a = b) then MyVariable = 'Equal'; else MyVariable = 'Not
            equal';</programlisting>
          </para>
          <para>If <varname>a</varname> and <varname>b</varname> are both <constant>NULL</constant>,
          <varname>MyVariable</varname> will yet be <quote>
              <literal>Not equal</literal>
            </quote> after executing this code. The reason is that the expression <quote>
              <literal>a = b</literal>
            </quote> yields <constant>NULL</constant> if at least one of them is
          <constant>NULL</constant>. With a <constant>NULL</constant> test expression, the
          <database>THEN</database> block is skipped and the <database>ELSE</database> block
          executed.</para>
        </listitem>
        <listitem>
          <para>
            <programlisting>if (a &lt;&gt; b) then MyVariable = 'Not equal'; else MyVariable =
            'Equal';</programlisting>
          </para>
          <para>Here, <varname>MyVariable</varname> will be <quote>
              <literal>Equal</literal>
            </quote> if <varname>a</varname> is <constant>NULL</constant> and <varname>b</varname>
          isn't, or vice versa. The explanation is analogous to that of the previous example.</para>
        </listitem>
      </itemizedlist>
      <para>So how should you set up equality tests that <emphasis>do</emphasis> give the logical
      result under all circumstances, even with <constant>NULL</constant> operands? In Firebird 2
      you can use <database>DISTINCT</database>, as already shown (see <link
          linkend="nullguide-langelem-distinct">
          <citetitle>Testing DISTINCTness</citetitle>
        </link>). With earlier versions, you'll have to write some more code. This is discussed in
      the section <link linkend="nullguide-testing-equality">
          <citetitle>Equality tests</citetitle>
        </link>, later on in this guide. For now, just remember that you have to be very careful
      with <database>IF</database> conditions that may resolve to <constant>NULL</constant>.</para>
      <para>Another aspect you shouldn't forget is the following: a <constant>NULL</constant> test
      expression may <emphasis>behave</emphasis> like <constant>false</constant> in an
      <database>IF</database> condition, but it doesn't have the <emphasis>value</emphasis>
      <constant>false</constant>. It's still <constant>NULL</constant>, and that means that its
      inverse will also be <constant>NULL</constant> – not <quote>
          <constant>true</constant>
        </quote>. As a consequence, inverting the test expression and swapping the
      <database>THEN</database> and <database>ELSE</database> blocks may change the behaviour of the
      <database>IF</database> statement. In binary logic, where only <constant>true</constant> and
      <constant>false</constant> can occur, such a thing could never happen.</para>
      <para>To illustrate this, let's refactor the last example:</para>
      <itemizedlist>
        <listitem>
          <para>
            <programlisting>if (not (a &lt;&gt; b)) then MyVariable = 'Equal'; else MyVariable =
            'Not equal';</programlisting>
          </para>
          <para>In the original version, if one operand was <constant>NULL</constant> and the other
          wasn't (so they were intuitively unequal), the result was <quote>
              <literal>Equal</literal>
            </quote>. Here, it's <quote>
              <literal>Not equal</literal>
            </quote>. The explanation: one operand is <constant>NULL</constant>, therefore <quote>
              <literal>a &lt;&gt; b</literal>
            </quote> is <constant>NULL</constant>, therefore <quote>
              <literal>not(a &lt;&gt; b)</literal>
            </quote> is <constant>NULL</constant>, therefore <database>ELSE</database> is executed.
          While this result is correct where the original had it wrong, there's no reason to
          rejoice: in the refactored version, the result is also <quote>
              <literal>Not equal</literal>
            </quote> if both operands are <constant>NULL</constant> – something that the original
          version <quote>got right</quote>.</para>
        </listitem>
      </itemizedlist>
      <para>Of course, as long as no operand in the test expression can ever be
      <constant>NULL</constant>, you can happily formulate your <database>IF</database> statements
      like above. Also, refactoring by inverting the test expression and swapping the
      <database>THEN</database> and <database>ELSE</database> blocks will always preserve the
      functionality, regardless of the complexity of the expressions – as long as they aren't
      <constant>NULL</constant>. What's especially treacherous is when the operands are
      <emphasis>almost always</emphasis> non-<constant>NULL</constant>, so in the vast majority of
      cases the results will be correct. In such a situation those rare <constant>NULL</constant>
      cases may go unnoticed for a long time, silently corrupting your data.</para>
    </section>
    <section id="nullguide-case">
      <title><indexterm>
          <primary>CASE</primary>
        </indexterm><database>CASE</database> statements</title>
      <para>Firebird introduced the <database>CASE</database> construct in version 1.5, with two
      syntactic variants. The first one is called the <firstterm>simple syntax</firstterm>:</para>
      <blockquote>
        <programlisting>case &lt;expression&gt; when &lt;exp1&gt; then &lt;result1&gt; when
        &lt;exp2&gt; then &lt;result2&gt; ... [else &lt;defaultresult&gt;] end</programlisting>
      </blockquote>
      <para>This one works more or less like a Pascal <code>case</code> or a C <code>switch</code>
      construct: <replaceable>&lt;expression&gt;</replaceable> is compared to
      <replaceable>&lt;exp1&gt;</replaceable>, <replaceable>&lt;exp2&gt;</replaceable> etc., until a
      match is found, in which case the corresponding result is returned. If there is no match and
      there is an <database>ELSE</database> clause, <replaceable>&lt;defaultresult&gt;</replaceable>
      is returned. If there is no match and no <database>ELSE</database> clause,
      <constant>NULL</constant> is returned.</para>
      <para>It is important to know that the comparisons are done with the <quote>
          <literal>=</literal>
        </quote> operator, so a null <replaceable>&lt;expression&gt;</replaceable> will
      <emphasis>not</emphasis> match a null <replaceable>&lt;expN&gt;</replaceable>. If
      <replaceable>&lt;expression&gt;</replaceable> is <constant>NULL</constant>, the only way to
      get a non-<constant>NULL</constant> result is via the <database>ELSE</database> clause.</para>
      <para>It is OK to specify <constant>NULL</constant> (or any other valid
      <constant>NULL</constant> expression) as a result.</para>
      <para>The second, or <firstterm>searched syntax</firstterm> is:</para>
      <blockquote>
        <programlisting>case when &lt;condition1&gt; then &lt;result1&gt; when &lt;condition2&gt;
        then &lt;result2&gt; ... [else &lt;defaultresult&gt;] end</programlisting>
      </blockquote>
      <para>Here, the <replaceable>&lt;conditionN&gt;</replaceable>s are tests that give a ternary
      boolean result: <constant>true</constant>, <constant>false</constant>, or
      <constant>NULL</constant>. Once again, only <constant>true</constant> is good enough, so a
      condition like <quote>A = 3</quote> – or even <quote>A = null</quote> – is not satisfied when
      A is <constant>NULL</constant>. Remember though that <quote>
          <database>IS [NOT] NULL</database>
        </quote> never returns <constant>NULL</constant>: if A is <constant>NULL</constant>, the
      condition <quote>A is null</quote> returns <constant>true</constant> and the corresponding
      <replaceable>&lt;resultN&gt;</replaceable> will be returned. In Firebird 2+ you can also use
      <quote>
          <database>IS [NOT] DISTINCT FROM</database>
        </quote> in your conditions – this operator too will never return
      <constant>NULL</constant>.</para>
    </section>
    <section id="nullguide-while">
      <title><indexterm>
          <primary>WHILE loops</primary>
        </indexterm><database>WHILE</database> loops</title>
      <para>When evaluating the condition of a <database>WHILE</database> loop,
      <constant>NULL</constant> has the same effect as in an <database>IF</database> statement: if
      the condition resolves to <constant>NULL</constant>, the loop is not (re)entered – just as if
      it were <constant>false</constant>. Again, watch out with inversion using
      <database>NOT</database>: a condition like</para>
      <blockquote>
        <programlisting>while ( Counter &gt; 12 ) do</programlisting>
      </blockquote>
      <para>will skip the loop block if Counter is <constant>NULL</constant>, which is probably what
      you want. But</para>
      <blockquote>
        <programlisting>while ( not Counter &gt; 12 ) do</programlisting>
      </blockquote>
      <para>will also skip if Counter is <constant>NULL</constant>. Maybe this is also exactly what
      you want – just be aware that these seemingly complementary tests both exclude
      <constant>NULL</constant> counters.</para>
    </section>
    <section id="nullguide-for">
      <title><indexterm>
          <primary>FOR loops</primary>
        </indexterm><database>FOR</database> loops</title>
      <para>To avoid any possible confusion, let us emphasise here that <database>FOR</database>
      loops in Firebird PSQL have a totally different function than <database>WHILE</database>
      loops, or <emphasis role="bold">
          <code>for</code>
        </emphasis> loops in general programming languages. Firebird <database>FOR</database> loops
      have the form:</para>
      <blockquote>
        <programlisting>for <replaceable>&lt;select-statement&gt;</replaceable> into
        <replaceable>&lt;var-list&gt;</replaceable> do
        <replaceable>&lt;code-block&gt;</replaceable></programlisting>
      </blockquote>
      <para>and they will keep executing the code block until all the rows from the result set have
      been retrieved, unless an exception occurs or a <database>BREAK</database>,
      <database>LEAVE</database> or <database>EXIT</database> statement is encountered. Fetching a
      <constant>NULL</constant>, or even row after row filled with <constant>NULL</constant>s, does
      <emphasis>not</emphasis> terminate the loop!</para>
    </section>
  </section>
  <section id="nullguide-keys">
    <title><indexterm>
        <primary>Keys</primary>
      </indexterm><indexterm>
        <primary>Indices</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in keys</secondary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in indices</secondary>
      </indexterm>Keys and unique indices</title>
    <!--Later: Change to "Keys and indices" and add small subsection on indices in general?-->
    <section id="nullguide-keys-pk">
      <title><indexterm>
          <primary>Keys</primary>
          <secondary>primary</secondary>
        </indexterm><indexterm>
          <primary>Primary keys</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>in primary keys</secondary>
        </indexterm>Primary keys</title>
      <para><constant>NULL</constant>s are never allowed in primary keys. A column can only be (part
      of) a PK it has been defined as <database>NOT NULL</database>, either in the column definition
      or in a domain definition. Note that a <quote>
          <database>CHECK (XXX IS NOT NULL)</database>
        </quote> constraint won't do: you need a <database>NOT NULL</database> specifier right after
      the data type.</para>
      <warning>
        <para>Firebird 1.5 has a bug that allows primary keys to be defined on a <database>NOT
        NULL</database> column with <constant>NULL</constant> entries. How these
        <constant>NULL</constant>s can exist in such a column will be explained later.</para>
      </warning>
    </section>
    <section id="nullguide-keys-uk">
      <title><indexterm>
          <primary>Keys</primary>
          <secondary>unique</secondary>
        </indexterm><indexterm>
          <primary>Indices</primary>
          <secondary>unique</secondary>
        </indexterm><indexterm>
          <primary>Unique keys</primary>
        </indexterm><indexterm>
          <primary>Unique indices</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>in unique keys and indices</secondary>
        </indexterm>Unique keys and indices</title>
      <section>
        <title>Firebird 1.0</title>
        <para>In Firebird 1.0, unique <emphasis>keys</emphasis> are subject to the same restrictions
        as primary keys: the column(s) involved must be defined as <database>NOT NULL</database>.
        For unique <emphasis>indices</emphasis>, this is not necessary. However, when a unique index
        is created the table may not contain any <constant>NULL</constant>s or duplicate values, or
        the creation will fail. Once the index is in place, insertion of <constant>NULL</constant>s
        or duplicate values is no longer possible.</para>
      </section>
      <section>
        <title>Firebird 1.5 and higher</title>
        <para>In Firebird 1.5 and up, unique keys and unique indices allow
        <constant>NULL</constant>s, and what's more: they even allow multiple
        <constant>NULL</constant>s. With a single-column key or index, you can insert as many
        <constant>NULL</constant>s as you want in that column, but you can insert each
        non-<constant>NULL</constant> value only once.</para>
        <para>If the key or index is defined on multiple columns in Firebird 1.5 and higher:</para>
        <itemizedlist>
          <listitem>
            <para>You can insert multiple rows where all the key columns are
            <constant>NULL</constant>;</para>
          </listitem>
          <listitem>
            <para>But as soon as one or more key columns are non-<constant>NULL</constant>, each
            combination of non-<constant>NULL</constant> values must be unique in the table. Of
            course with the understanding that (1, <constant>NULL</constant>) is not the same as
            (<constant>NULL</constant>, 1).</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <section id="nullguide-keys-fk">
      <title><indexterm>
          <primary>Keys</primary>
        </indexterm><indexterm>
          <primary>Keys</primary>
          <secondary>foreign</secondary>
        </indexterm><indexterm>
          <primary>Foreign keys</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>in foreign keys</secondary>
        </indexterm>Foreign keys</title>
      <para>Foreign keys as such impose no restrictions with respect to <constant>NULL</constant>s.
      Foreign key columns must always reference a column (or set of columns) that is a primary key
      or a unique key. A unique index on the referenced column(s) is not enough.</para>
      <note>
        <para>In versions up to and including 2.0, if you try to create a foreign key referencing a
        target that is neither a primary nor a unique key, Firebird complains that no unique
        <emphasis>index</emphasis> can been found on the target – even if such an index does exist.
        In 2.1, the message correctly states that no unique or primary <emphasis>key</emphasis>
        could be found.</para>
      </note>
      <para>Even if <constant>NULL</constant>s are absolutely forbidden in the target key (for
      instance if the target is a PK), the foreign key column may still contain
      <constant>NULL</constant>s, unless this is prevented by additional constraints.</para>
    </section>
  </section>
  <section id="nullguide-check-constraints">
    <title><indexterm>
        <primary>CHECK constraints</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in CHECK constraints</secondary>
      </indexterm><database>CHECK</database> constraints</title>
    <para>It has been said several times in this guide that if test expressions return
    <constant>NULL</constant>, they have the same effect as <constant>false</constant>: the
    condition is not satisfied. Starting at Firebird 2, this is <emphasis role="bold">no longer
    true</emphasis> for the <database>CHECK</database> constraint. To comply with SQL standards, a
    <database>CHECK</database> is now <emphasis role="bold">passed</emphasis> if the condition
    resolves to <constant>NULL</constant>. Only an unambiguous <constant>false</constant> outcome
    will cause the input to be rejected.</para>
    <para>In practice, this means that checks like</para>
    <blockquote>
      <programlisting>check ( value &gt; 10000 )</programlisting>
      <programlisting>check ( upper( value ) in ( 'A', 'B', 'X' ) )</programlisting>
      <programlisting>check ( value between 30 and 36 )</programlisting>
      <programlisting>check ( ColA &lt;&gt; ColB )</programlisting>
      <programlisting>check ( Town not like 'Amst%' )</programlisting>
    </blockquote>
    <para>...will reject <constant>NULL</constant> input in Firebird 1.5, but let it pass in
    Firebird 2. Existing database creation scripts will have to be carefully examined before being
    used under Firebird 2. If a domain or column has no <database>NOT NULL</database> constraint,
    and a <database>CHECK</database> constraint may resolve to <constant>NULL</constant> (which
    usually – but not exclusively – happens because the input is <constant>NULL</constant>), the
    script has to be adapted. You can extend your check constraints like this:</para>
    <blockquote>
      <programlisting>check ( value &gt; 10000 <emphasis role="bold">and value is not
      null</emphasis> )</programlisting>
      <programlisting>check ( Town not like 'Amst%' <emphasis role="bold">and Town is not
      null</emphasis> )</programlisting>
    </blockquote>
    <para>However, it's easier and clearer to add <database>NOT NULL</database> to the domain or
    column definition:</para>
    <blockquote>
      <programlisting>create domain DCENSUS int <emphasis role="bold">not null</emphasis> check (
      value &gt; 10000 )</programlisting>
      <programlisting>create table MyPlaces ( Town varchar(24) <emphasis role="bold">not
      null</emphasis> check ( Town not like 'Amst%' ), ... )</programlisting>
    </blockquote>
    <para>If your scripts and/or databases should function consistently under both old and new
    Firebird versions, make sure that no <database>CHECK</database> constraint can ever resolve to
    <constant>NULL</constant>. Add <quote>
        <code>or ... is null</code>
      </quote> if you want to allow <constant>NULL</constant> input in older versions. Add
    <database>NOT NULL</database> constraints or <quote>
        <code>and ... is not null</code>
      </quote> restrictions to disallow it explicitly in newer Firebird versions.</para>
  </section>
  <section id="nullguide-select-distinct">
    <title>
      <database><indexterm>
          <primary>DISTINCT</primary>
          <secondary>SELECT DISTINCT</secondary>
        </indexterm><indexterm>
          <primary>SELECT DISTINCT</primary>
        </indexterm>SELECT DISTINCT</database>
    </title>
    <para>A <database>SELECT DISTINCT</database> statement considers all <constant>NULL</constant>s
    to be equal (<database>NOT DISTINCT FROM</database> each other), so if the select is on a single
    column it will return at most one <constant>NULL</constant>.</para>
    <para>As mentioned earlier, Firebird 2.0 has a bug that causes the <database>NULLS
    FIRST|LAST</database> directive to fail under certain circumstances with <database>SELECT
    DISTINCT</database>. For more details, see the <link
    linkend="nullguide-bugs-select-distinct">bugs list</link>.</para>
  </section>
  <section id="nullguide-udfs">
    <title><indexterm>
        <primary>UDFs</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in UDFs</secondary>
      </indexterm>User-Defined Functions (UDFs)</title>
    <para><firstterm>UDF</firstterm>s (<firstterm>User-Defined Functions</firstterm>) are functions
    that are not internal to the engine, but defined in separate modules. Firebird ships with two
    UDF libraries: <systemitem class="library">ib_udf</systemitem> (a widely used
    <application>InterBase library</application>) and <systemitem
    class="library">fbudf</systemitem>. You can add more libraries, e.g. by buying or downloading
    them, or by writing them yourself. UDFs can't be used out of the box; they have to be
    <quote>declared</quote> to the database first. This also applies to the UDFs that come with
    Firebird itself.</para>
    <section id="nullguide-udfs-conversions">
      <title><indexterm>
          <primary>UDFs</primary>
          <secondary>unwanted conversions</secondary>
        </indexterm><indexterm>
          <primary>Conversions</primary>
          <secondary>unwanted</secondary>
        </indexterm><constant>NULL</constant> <literal>&lt;–&gt;</literal>
      non-<constant>NULL</constant> conversions you didn't ask for</title>
      <para>Teaching you how to declare, use, and write UDFs is outside the scope of this guide.
      However, we must warn you that UDFs can occasionally perform unexpected
      <constant>NULL</constant> conversions. This will sometimes result in <constant>NULL</constant>
      input being converted to a regular value, and other times in the nullification of valid input
      like <literal>''</literal> (an empty string).</para>
      <para>The main cause of this problem is that with <quote>old style</quote> UDF calling
      (inherited from InterBase), it is not possible to pass <constant>NULL</constant> as input to
      the function. When a UDF like <function>LTRIM</function> (left trim) is called with a
      <constant>NULL</constant> argument, the argument is passed to the function as an empty string.
      (Note: in Firebird 2 and up, it <emphasis>can</emphasis> also be passed as a null pointer.
      We'll get to that later.) From inside the function there is <emphasis>no way</emphasis> of
      telling if this argument represents a real empty string or a <constant>NULL</constant>. So
      what does the function implementor do? He has to make a choice: either take the argument at
      face value, or assume it was originally a <constant>NULL</constant> and treat it
      accordingly.</para>
      <para>If the function result type is a pointer, returning <constant>NULL</constant> is
      possible even if receiving <constant>NULL</constant> isn't. Thus, the following unexpected
      things can happen:</para>
      <itemizedlist>
        <listitem>
          <para>You call a UDF with a <constant>NULL</constant> argument. It is passed as a value,
          e.g. 0 or <literal>''</literal>. Within the function, this argument is not changed back to
          <constant>NULL</constant>; a non-<constant>NULL</constant> result is returned.</para>
        </listitem>
        <listitem>
          <para>You call a UDF with a valid argument like 0 or <literal>''</literal>. It is passed
          as-is (obviously). But the function code supposes that this value really represents a
          <constant>NULL</constant>, treats it as a black hole, and returns
          <constant>NULL</constant> to the caller.</para>
        </listitem>
      </itemizedlist>
      <para>Both conversions are usually unwanted, but the second probably more so than the first
      (better validate something <constant>NULL</constant> than wreck something valid). To get back
      to our <function>LTRIM</function> example: in Firebird 1.0, this function returns
      <constant>NULL</constant> if you feed it an empty string. This is wrong. In 1.5 it never
      returns <constant>NULL</constant>: even <constant>NULL</constant> strings (passed by the
      engine as <literal>''</literal>) are <quote>trimmed</quote> to empty strings. This is also
      wrong, but it's considered the lesser of two evils. Firebird 2 has finally got it right: a
      <constant>NULL</constant> string gives a <constant>NULL</constant> result, an empty string is
      trimmed to an empty string – at least if you declare the function in the right way.</para>
    </section>
    <section id="nullguide-udfs-descriptors">
      <title><indexterm>
          <primary>UDFs</primary>
          <secondary>by descriptor</secondary>
        </indexterm><indexterm>
          <primary>Descriptors</primary>
        </indexterm>Descriptors</title>
      <para>As early as in Firebird 1.0, a new method of passing UDF arguments and results was
      introduced: <quote>by descriptor</quote>. Descriptors allow <constant>NULL</constant>
      signalling no matter the type of data. The <systemitem class="library">fbudf</systemitem>
      library makes ample use of this technique. Unfortunately, using descriptors is rather
      cumbersome; it's more work and less fun for the UDF implementor. But they do solve all the
      traditional <constant>NULL</constant> problems, and for the caller they're just as easy to use
      as old-style UDFs.</para>
    </section>
    <section id="nullguide-udfs-fb2-impr">
      <title><indexterm>
          <primary>UDFs</primary>
          <secondary>with NULL keyword</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>NULL keyword in UDFs</secondary>
        </indexterm><indexterm>
          <primary>NULL keyword in UDFs</primary>
        </indexterm>Improvements in Firebird 2</title>
      <para>Firebird 2 comes with a somewhat improved calling mechanism for old-style UDFs. The
      engine will now pass <constant>NULL</constant> input as a null pointer to the function,
      <emphasis role="bold">if</emphasis> the function has been declared to the database with a
      <database>NULL</database> keyword after the argument(s) in question:</para>
      <blockquote>
        <programlisting>declare external function ltrim cstring(255) <emphasis
        role="bold">null</emphasis> returns cstring(255) free_it entry_point 'IB_UDF_ltrim'
        module_name 'ib_udf';</programlisting>
      </blockquote>
      <para>This requirement ensures that existing databases and their applications can continue to
      function like before. Leave out the <database>NULL</database> keyword and the function will
      behave like it did under Firebird 1.5.</para>
      <para>Please note that you can't just add <database>NULL</database> keywords to your
      declarations and then expect every function to handle <constant>NULL</constant> input
      correctly. Each function has to be (re)written in such a way that <constant>NULL</constant>s
      are dealt with correctly. Always look at the declarations provided by the function
      implementor. For the functions in the <systemitem class="library">ib_udf</systemitem> library,
      consult <filename>ib_udf2.sql</filename> in the Firebird <filename
      class="directory">UDF</filename> directory. Notice the <literal>2</literal> in the file name;
      the old-style declarations are in <filename>ib_udf.sql</filename>.</para>
      <para>These are the <systemitem class="library">ib_udf</systemitem> functions that have been
      updated to recognise <constant>NULL</constant> input and handle it properly:</para>
      <itemizedlist spacing="compact">
        <listitem>
          <para>
            <function>ascii_char</function>
          </para>
        </listitem>
        <listitem>
          <para>
            <function>lower</function>
          </para>
        </listitem>
        <listitem>
          <para><function>lpad</function> and <function>rpad</function></para>
        </listitem>
        <listitem>
          <para><function>ltrim</function> and <function>rtrim</function></para>
        </listitem>
        <listitem>
          <para><function>substr</function> and <function>substrlen</function></para>
        </listitem>
      </itemizedlist>
      <para>Most <systemitem class="library">ib_udf</systemitem> functions remain as they were; in
      any case, passing <constant>NULL</constant> to an old-style UDF is never possible if the
      argument isn't of a referenced type.</para>
      <para>On a side note: don't use <function>lower</function>, <function>.trim</function> and
      <function>substr*</function> in new code; use the internal functions
      <database>LOWER</database>, <database>TRIM</database> and <database>SUBSTRING</database>
      instead.</para>
      <section>
        <title><quote>Upgrading</quote> <systemitem class="library">ib_udf</systemitem> functions in
        an existing database</title>
        <para>If you are using an existing database with one or more of the functions listed above
        under Firebird 2, and you want to benefit from the improved <constant>NULL</constant>
        handling, run the script <filename>ib_udf_upgrade.sql</filename> against your database. It
        is located in the Firebird <filename class="directory">misc\upgrade\ib_udf</filename>
        directory.</para>
      </section>
    </section>
    <section id="nullguide-udfs-conversions-prepare">
      <title><indexterm>
          <primary>UDFs</primary>
          <secondary>unwanted conversions</secondary>
          <tertiary>prepare for</tertiary>
        </indexterm><indexterm>
          <primary>Conversions</primary>
          <secondary>unwanted</secondary>
          <tertiary>prepare for</tertiary>
        </indexterm>Being prepared for undesired conversions</title>
      <para>The unsolicited <constant>NULL</constant> <literal>&lt;–&gt;</literal>
      non-<constant>NULL</constant> conversions described earlier usually only happen with legacy
      UDFs, but there are a lot of them around (most notably in <systemitem
      class="library">ib_udf</systemitem>). Also, nothing will stop a careless implementor from
      doing the same in a descriptor-style function. So the bottom line is: if you use a UDF and you
      don't know how it behaves with respect to <constant>NULL</constant>:</para>
      <procedure>
        <step>
          <para>Look at its declaration to see how values are passed and returned. If it says
          <quote>by descriptor</quote>, it should be safe (though it never hurts to make sure).
          Ditto if arguments are followed by a <database>NULL</database> keyword. In all other
          cases, walk through the rest of the steps.</para>
        </step>
        <step>
          <para>If you have the source and you understand the language it's written in, inspect the
          function code.</para>
        </step>
        <step>
          <para>Test the function both with <constant>NULL</constant> input and with input like 0
          (for numerical arguments) and/or <literal>''</literal> (for string arguments).</para>
        </step>
        <step>
          <para>If the function performs an undesired <constant>NULL</constant>
          <literal>&lt;–&gt;</literal> non-<constant>NULL</constant> conversion, you'll have to
          anticipate it in your code before calling the UDF (see also <link
              linkend="nullguide-test-if-matters">
              <citetitle>Testing for <constant>NULL</constant> – if it matters</citetitle>
            </link>, elsewhere in this guide).</para>
        </step>
      </procedure>
      <para>The declarations for the shipped UDF libraries can be found in the Firebird subdirectory
      <filename class="directory">examples</filename> (v. 1.0) or <filename
      class="directory">UDF</filename> (v. 1.5 and up). Look at the files with extension <filename
      class="extension">.sql</filename></para>
    </section>
    <section id="nullguide-udfs-links">
      <title><indexterm>
          <primary>UDFs</primary>
          <secondary>links</secondary>
        </indexterm>More on UDFs</title>
      <para>To learn more about UDFs, consult the <citetitle>InterBase 6.0 Developer's
      Guide</citetitle> (free at <ulink
      url="http://www.ibphoenix.com/downloads/60DevGuide.zip">http://www.ibphoenix.com/downloads/60DevGuide.zip</ulink>),
      <citetitle>Using Firebird</citetitle> and the <citetitle>Firebird Reference Guide</citetitle>
      (both on CD), or the <citetitle>Firebird Book</citetitle>. CD and book can be purchased via
      <ulink url="http://www.ibphoenix.com">http://www.ibphoenix.com</ulink>.</para>
    </section>
  </section>
  <section id="nullguide-conversions">
    <title><indexterm>
        <primary>Conversions</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>conversions to/from</secondary>
      </indexterm>Converting to and from <constant>NULL</constant></title>
    <section id="nullguide-subst-with-value">
      <title><indexterm>
          <primary>Conversions</primary>
          <secondary>from NULL to a value</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>conversions from</secondary>
        </indexterm>Substituting <constant>NULL</constant> with a value</title>
      <section id="nullguide-coalesce">
        <title><indexterm>
            <primary>Conversions</primary>
            <secondary>from NULL to a value</secondary>
            <tertiary>COALESCE</tertiary>
          </indexterm><indexterm>
            <primary>COALESCE</primary>
          </indexterm>The <function>COALESCE</function> function</title>
        <para>The <function>COALESCE</function> function in Firebird 1.5 and higher can convert
        <constant>NULL</constant> to most anything else. This enables you to perform an on-the-fly
        conversion and use the result in your further processing, without the need for <quote>
            <literal>if (MyExpression is null) then</literal>
          </quote> or similar constructions. The function signature is:</para>
        <blockquote>
          <para>
            <literal>COALESCE( Expr1, Expr2, Expr3, ... )</literal>
          </para>
        </blockquote>
        <para><function>COALESCE</function> returns the value of the first
        non-<constant>NULL</constant> expression in the argument list. If all the expressions are
        <constant>NULL</constant>, it returns <constant>NULL</constant>.</para>
        <para>This is how you would use <function>COALESCE</function> to construct a person's full
        name from the first, middle and last names, assuming that some middle name fields may be
        <constant>NULL</constant>:</para>
        <blockquote>
          <para>
            <programlisting>select FirstName || coalesce( ' ' || MiddleName, '' ) || ' ' || LastName
            from Persons</programlisting>
          </para>
        </blockquote>
        <para>Or, to create an as-informal-as-possible name from a table that also includes
        nicknames, and assuming that both nickname and first name may be
        <constant>NULL</constant>:</para>
        <blockquote>
          <para>
            <programlisting>select coalesce ( Nickname, FirstName, 'Mr./Mrs.' ) || ' ' || LastName
            from OtherPersons</programlisting>
          </para>
        </blockquote>
        <para><function>COALESCE</function> will only help you out in situations where
        <constant>NULL</constant> can be treated in the same way as some allowed value for the
        datatype. If <constant>NULL</constant> needs special handling, different from any other
        value, your only option is to use an <database>IF</database> or <database>CASE</database>
        construct after all.</para>
      </section>
      <section id="nullguide-nvl">
        <title><indexterm>
            <primary>Conversions</primary>
            <secondary>from NULL to a value</secondary>
            <tertiary>NVL functions</tertiary>
          </indexterm><indexterm>
            <primary>NVL functions</primary>
          </indexterm><indexterm>
            <primary>UDFs</primary>
            <secondary>NVL functions</secondary>
          </indexterm>Firebird 1.0: the <function>*NVL</function> functions</title>
        <para>Firebird 1.0 doesn't have <function>COALESCE</function>. However, you can use four
        UDFs that provide a good part of its functionality. These UDFs reside in the <filename
        class="libraryfile">fbudf</filename> lib and they are:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><function>iNVL</function>, for integer arguments</para>
          </listitem>
          <listitem>
            <para><function>i64NVL</function>, for bigint arguments</para>
          </listitem>
          <listitem>
            <para><function>dNVL</function>, for double precision arguments</para>
          </listitem>
          <listitem>
            <para><function>sNVL</function>, for strings</para>
          </listitem>
        </itemizedlist>
        <para>The <function>
            <function>*NVL</function>
          </function> functions take exactly two arguments. Like <function>COALESCE</function>, they
        return the first argument if it's not <constant>NULL</constant>; otherwise, they return the
        second. Please note that the Firebird 1.0 <filename class="libraryfile">fbudf</filename> lib
        – and therefore, the <function>*NVL</function> function set – is only available for
        Windows.</para>
      </section>
    </section>
    <section id="nullguide-conv-to-null">
      <title><indexterm>
          <primary>Conversions</primary>
          <secondary>from a value to NULL</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>
          <secondary>conversions to</secondary>
        </indexterm>Converting values to <constant>NULL</constant></title>
      <para>Sometimes you want certain values to show up as <constant>NULL</constant> in the output
      (or intermediate output). This doesn't happen often, but it may for instance be useful if you
      want to exclude certain values from summing or averaging. The <function>NULLIF</function>
      functions can do this for you, though only for one value at the time.</para>
      <section>
        <title><indexterm>
            <primary>Conversions</primary>
            <secondary>from a value to NULL</secondary>
            <tertiary>NULLIF internal function</tertiary>
          </indexterm><indexterm>
            <primary>NULLIF internal function</primary>
          </indexterm>Firebird 1.5 and up: the <function>NULLIF</function> function</title>
        <para>The NULLIF internal function takes two arguments. If their values are equal, the
        function returns <constant>NULL</constant>. Otherwise, it returns the value of the first
        argument.</para>
        <para>A typical use is e.g.</para>
        <blockquote>
          <programlisting>select avg( nullif( Weight, -1 ) ) from FatPeople</programlisting>
        </blockquote>
        <para>which will give you the average weight of the FatPeople population, without counting
        those with weight -1. (Remember that aggregate functions like <database>AVG</database>
        exclude all <constant>NULL</constant> fields from the computation.)</para>
        <para>Elaborating on this example, suppose that until now you have used the value -1 to
        indicate <quote>weight unknown</quote> because you weren't comfortable with
        <constant>NULL</constant>s. After reading this guide, you may feel brave enough to give the
        command:</para>
        <blockquote>
          <programlisting>update FatPeople set Weight = nullif( Weight, -1 )</programlisting>
        </blockquote>
        <para>Now unknown weights will <emphasis>really</emphasis> be unknown.</para>
      </section>
      <section>
        <title><indexterm>
            <primary>Conversions</primary>
            <secondary>from a value to NULL</secondary>
            <tertiary>NULLIF UDFs</tertiary>
          </indexterm><indexterm>
            <primary>NULLIF UDFs</primary>
          </indexterm><indexterm>
            <primary>UDFs</primary>
            <secondary>NULLIF functions</secondary>
          </indexterm>Firebird 1.0: the <function>*nullif</function> UDFs</title>
        <para>Firebird 1.0.x doesn't have the <function>NULLIF</function> internal function.
        Instead, it has four user-defined functions in the <filename
        class="libraryfile">fbudf</filename> lib that serve the same purpose:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><function>inullif</function>, for integer arguments</para>
          </listitem>
          <listitem>
            <para><function>i64nullif</function>, for bigint arguments</para>
          </listitem>
          <listitem>
            <para><function>dnullif</function>, for double precision arguments</para>
          </listitem>
          <listitem>
            <para><function>snullif</function>, for strings</para>
          </listitem>
        </itemizedlist>
        <para>Please note that the Firebird 1.0 <filename class="libraryfile">fbudf</filename> lib –
        and therefore, the <function>*nullif</function> function set – is only available for
        Windows.</para>
        <warning>
          <para>The Firebird 1 Release Notes state that, because of an engine limitation, these UDFs
          return a zero-equivalent if the arguments are equal. This is incorrect: if the arguments
          have the same value, the functions all return a true <constant>NULL</constant>.</para>
          <para>However – they also return <constant>NULL</constant> if the first argument is a real
          value and the second argument is <constant>NULL</constant>. This is a wrong result. The
          Firebird 1.5 internal <function>NULLIF</function> function correctly returns the first
          argument in such a case.</para>
        </warning>
      </section>
    </section>
  </section>
  <section id="nullguide-alter-pop-tables">
    <title><indexterm>
        <primary>Altering tables</primary>
      </indexterm><indexterm>
        <primary>Tables</primary>
        <secondary>altering</secondary>
      </indexterm>Altering populated tables</title>
    <para>If your table already contains data, and you want to add a non-nullable column or change
    the nullability of an existing column, there are some consequences that you should know about.
    We'll discuss the various possibilities in the sections below.</para>
    <section id="nullguide-add-non-nullable-field">
      <title><indexterm>
          <primary>Adding non-nullable columns</primary>
        </indexterm><indexterm>
          <primary>Tables</primary>
          <secondary>add non-nullable columns</secondary>
        </indexterm>Adding a non-nullable field to a populated table</title>
      <para>Suppose you have this table:</para>
      <table id="nullguide-tbl-adventures">
        <title>Adventures table</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Name</entry>
              <entry align="center">Bought</entry>
              <entry align="center">Price</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>Maniac Mansion</entry>
              <entry>12-Jun-1995</entry>
              <entry>$ 49,--</entry>
            </row>
            <row>
              <entry>Zak McKracken</entry>
              <entry>9-Oct-1995</entry>
              <entry>$ 54,95</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>You have already entered some adventure games in this table when you decide to add a
      non-nullable ID field. There are two ways to go about this, both with their own specific
      problems.</para>
      <section id="nullguide-add-not-null-field">
        <title><indexterm>
            <primary>Adding NOT NULL columns</primary>
          </indexterm><indexterm>
            <primary>Tables</primary>
            <secondary>add NOT NULL columns</secondary>
          </indexterm><indexterm>
            <primary>NOT NULL</primary>
            <secondary>direct</secondary>
          </indexterm>Adding a <database>NOT NULL</database> field</title>
        <para>This is by far the preferred method in general, but it causes some special problems if
        used on a populated table, as you will see in a moment. First, add the field with this
        statement:</para>
        <blockquote>
          <programlisting>alter table Adventures add id int not null</programlisting>
          <!--or: ...add id int constraint <name> not null-->
        </blockquote>
        <para><indexterm>
            <primary>NULL</primary>
            <secondary>in NOT NULL columns</secondary>
          </indexterm><indexterm>
            <primary>Backup</primary>
          </indexterm><indexterm>
            <primary>gbak</primary>
          </indexterm><indexterm>
            <primary>Restoring</primary>
            <secondary>problem with NULLs</secondary>
          </indexterm>After committing, the new ID fields that have been added to the existing rows
        will all be <constant>NULL</constant>. In this special case, Firebird allows invalid data to
        be present in a <database>NOT NULL</database> column. It will also back them up without
        complaining, but it will refuse to restore them, precisely because of this violation of the
        <database>NOT NULL</database> constraint.</para>
        <note>
          <para>Firebird 1.5 (but not 1.0 or 2.0) even allows you to make such a column the primary
          key!</para>
        </note>
        <section id="nullguide-nulls-reported-as-zeroes">
          <title><indexterm>
              <primary>NULL</primary>
              <secondary>falsely reported as 0</secondary>
            </indexterm>False reporting of <constant>NULL</constant>s as zeroes</title>
          <para>To make matters worse, Firebird lies to you when you retrieve data from the table.
          With <application>isql</application> and many other clients, <quote>
              <database>SELECT * FROM ADVENTURES</database>
            </quote> will return this dataset:</para>
          <table id="nullguide-tbl-adventures-0">
            <title>Result set after adding a <database>NOT NULL</database> column</title>
            <tgroup cols="4">
              <thead>
                <row>
                  <entry align="center">Name</entry>
                  <entry align="center">Bought</entry>
                  <entry align="center">Price</entry>
                  <entry align="center">ID</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry>Maniac Mansion</entry>
                  <entry>12-Jun-1995</entry>
                  <entry>$ 49,--</entry>
                  <entry>0</entry>
                </row>
                <row>
                  <entry>Zak McKracken</entry>
                  <entry>9-Oct-1995</entry>
                  <entry>$ 54,95</entry>
                  <entry>0</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          <para>Of course this will make most people think <quote>OK, cool: Firebird used a default
          value of 0 for the new fields – nothing to worry about</quote>. But you can verify that
          the ID fields are really <constant>NULL</constant> with these queries:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para><database>SELECT * FROM ADVENTURES WHERE ID = 0</database> (returns empty
              set)</para>
            </listitem>
            <listitem>
              <para><database>SELECT * FROM ADVENTURES WHERE ID IS NULL</database> (returns set
              shown above, with false 0's)</para>
            </listitem>
            <listitem>
              <para><database>SELECT * FROM ADVENTURES WHERE ID IS NOT NULL</database> (returns
              empty set)</para>
            </listitem>
          </itemizedlist>
          <para>Another type of query hinting that something fishy is going on is the
          following:</para>
          <itemizedlist spacing="compact">
            <listitem>
              <para>
                <database>SELECT NAME, ID, ID+3 FROM ADVENTURES</database>
              </para>
            </listitem>
          </itemizedlist>
          <para>Such a query will return 0 in the <quote>ID+3</quote> column. With a true 0 ID it
          should have been 3. The <emphasis>correct</emphasis> result would be
          <constant>NULL</constant>, of course!</para>
          <para>With a <database>(VAR)CHAR</database> column, you would have seen phoney
          emptystrings (''). With a <database>DATE</database> column, phoney <quote>zero
          dates</quote> of 17 November 1858 (epoch of the Modified Julian Day). In all cases, the
          true state of the data is <constant>NULL</constant>.</para>
          <section>
            <title>Explanation</title>
            <para>What's going on here?</para>
            <para>When a client application like <application>isql</application> queries the server,
            the conversation passes through several stages. During one of them – the
            <quote>describe</quote> phase – the engine reports type and nullability for each column
            that will appear in the result set. It does this in a data structure which is later also
            used to retrieve the actual row data. For columns flagged as <database>NOT
            NULL</database> by the server, there is no way to return <constant>NULL</constant>s to
            the client — unless the client flips back the flag before entering the data retrieval
            stage. Most client applications don't do this. After all, if the server assures you that
            a column can't contain <constant>NULL</constant>s, why would you think you know better,
            override the server's decision and check for <constant>NULL</constant>s anyway? And yet
            that's exactly what you should do if you want to avoid the risk of reporting false
            values to your users.</para>
          </section>
          <section>
            <title><indexterm>
                <primary>FSQL</primary>
              </indexterm>FSQL</title>
            <para>Firebird expert Ivan Prenosil has written a free command-line client that works
            almost the same as <application>isql</application>, but – among other enhancements –
            reports <constant>NULL</constant>s correctly, even in <database>NOT NULL</database>
            columns. It's called <application>FSQL</application> and you can download it
            here:</para>
            <blockquote>
              <para>
                <ulink
                url="http://www.volny.cz/iprenosil/interbase/fsql.htm">http://www.volny.cz/iprenosil/interbase/fsql.htm</ulink>
              </para>
            </blockquote>
          </section>
        </section>
        <section>
          <title>Ensuring the validity of your data</title>
          <para>This is what you should do to make sure that your data are valid when adding a
          <database>NOT NULL</database> column to a populated table:</para>
          <itemizedlist>
            <listitem>
              <para>To prevent the nulls-in-not-null-columns problem from occurring at all, provide
              a default value when you add the new column:</para>
              <blockquote>
                <programlisting>alter table Adventures add id int default -1 not
                null</programlisting>
              </blockquote>
              <para>Default values are normally not applied when adding fields to existing rows, but
              with <database>NOT NULL</database> fields they are.</para>
            </listitem>
            <listitem>
              <para>Else, explicitly set the new fields to the value(s) they should have, right
              after adding the column. Verify that they are all valid with a <quote>
                  <database>SELECT ... WHERE ... IS NULL</database>
                </quote> query, which should return an empty set.</para>
            </listitem>
            <listitem>
              <para><indexterm>
                  <primary>gbak</primary>
                  <secondary>-n switch</secondary>
                </indexterm><indexterm>
                  <primary>Restoring</primary>
                  <secondary>problem with NULLs</secondary>
                  <tertiary>solution</tertiary>
                </indexterm>If the damage has already been done and you find yourself with an
              unrestorable backup, use <application>gbak</application>'s <parameter>-n</parameter>
              switch to ignore validity constraints when restoring. Then fix the data and reinstate
              the constraints manually. Again, verify with a <quote>
                  <database>WHERE ... IS NULL</database>
                </quote> query.</para>
            </listitem>
          </itemizedlist>
          <important>
            <para>Firebird versions up to and including 1.5 have an additional bug that causes
            <application>gbak</application> to restore <database>NOT NULL</database> constraints
            even if you specify <parameter>-n</parameter>. With those versions, if you have backed
            up a database with <constant>NULL</constant> data in <database>NOT NULL</database>
            fields, you are really up the creek. Solution: install 1.5.1 or higher, restore with
            gbak <parameter>-n</parameter> and fix your data.</para>
          </important>
        </section>
      </section>
      <section id="nullguide-add-check-not-null-field">
        <title><indexterm>
            <primary>Adding CHECKed columns</primary>
          </indexterm><indexterm>
            <primary>Tables</primary>
            <secondary>add CHECKed columns</secondary>
          </indexterm>Adding a <database>CHECK</database>ed column</title>
        <para>Using a <database>CHECK</database> constraint is another way to disallow
        <constant>NULL</constant> entries in a column:</para>
        <blockquote>
          <programlisting>alter table Adventures add id int check (id is not null)</programlisting>
        </blockquote>
        <para>If you do it this way, a subsequent SELECT will return:</para>
        <table id="nullguide-tbl-adventures-null">
          <title>Result set after adding a <database>CHECK</database>ed field</title>
          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Name</entry>
                <entry align="center">Bought</entry>
                <entry align="center">Price</entry>
                <entry align="center">ID</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Maniac Mansion</entry>
                <entry>12-Jun-1995</entry>
                <entry>$ 49,--</entry>
                <entry>&lt;null&gt;</entry>
              </row>
              <row>
                <entry>Zak McKracken</entry>
                <entry>9-Oct-1995</entry>
                <entry>$ 54,95</entry>
                <entry>&lt;null&gt;</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Well, at least now you can <emphasis>see</emphasis> that the fields are
        <constant>NULL</constant>! Firebird does not enforce <database>CHECK</database> constraints
        on existing rows when you add new fields. The same is true if you add checks to existing
        fields with <database>ADD CONSTRAINT</database> or <database>ADD CHECK</database>.</para>
        <para>This time, Firebird not only tolerates the presence and the backing up of the
        <constant>NULL</constant> entries, but it will also restore them. Firebird's
        <application>gbak</application> tool does restore <database>CHECK</database> constraints,
        but doesn't apply them to the existing data in the backup.</para>
        <note>
          <para>Even with the <parameter>-n</parameter> switch, gbak restores
          <database>CHECK</database> constraints. But since they are not used to validate backed-up
          data, this will never lead to a failed restore.</para>
        </note>
        <para>This restorability of your <constant>NULL</constant> data despite the presence of the
        <database>CHECK</database> constraint is consistent with the fact that Firebird allows them
        to be present in the first place, and to be backed up as well. But from a pragmatical point
        of view, there's a downside: you can now go through cycle after cycle of backup and restore,
        and your <quote>illegal</quote> data will survive without you even receiving a warning. So
        again: make sure that your existing rows obey the new rule immediately after adding the
        constrained column. The <quote>default</quote> trick won't work here; you'll just have to
        remember to set the right value(s) yourself. If you forget it now, chances are that your
        outlawed <constant>NULL</constant>s will survive for a long time, as there won't be any
        wake-up calls later on.</para>
      </section>
      <section>
        <title><indexterm>
            <primary>Adding NOT NULL columns</primary>
            <secondary>using domains</secondary>
          </indexterm><indexterm>
            <primary>Tables</primary>
            <secondary>add NOT NULL columns</secondary>
            <tertiary>using domains</tertiary>
          </indexterm><indexterm>
            <primary>NOT NULL</primary>
            <secondary>via domain</secondary>
          </indexterm>Adding a non-nullable field using domains</title>
        <para>Instead of specifying data types and constraints directly, you can also use domains,
        e.g. like this:</para>
        <blockquote>
          <programlisting>create domain icnn as int check (value is not null); alter table
          Adventures add id icnn;</programlisting>
        </blockquote>
        <para>For the presence of <constant>NULL</constant> fields, returning of false 0's, effects
        of default values etc., it makes <emphasis>no difference at all</emphasis> whether you take
        the domain route or the direct approach. However, a <database>NOT NULL</database> constraint
        that came with a domain can later be removed; a direct <database>NOT NULL</database> on the
        column will stay forever.</para>
      </section>
    </section>
    <section id="nullguide-make-column-non-nullable">
      <title><indexterm>
          <primary>Tables</primary>
          <secondary>make columns non-nullable</secondary>
        </indexterm>Making existing columns non-nullable</title>
      <section id="nullguide-make-column-not-null">
        <title><indexterm>
            <primary>Tables</primary>
            <secondary>make columns NOT NULL</secondary>
          </indexterm><indexterm>
            <primary>NOT NULL</primary>
            <secondary>via domain</secondary>
            <tertiary>add</tertiary>
          </indexterm>Making an existing column <database>NOT NULL</database></title>
        <para>You cannot add <database>NOT NULL</database> to an existing column, but there's a
        simple workaround. Suppose the current type is int, then this:</para>
        <blockquote>
          <programlisting>create domain intnn as int not null; alter table MyTable alter MyColumn
          type intnn;</programlisting>
        </blockquote>
        <para>will change the column type to <quote>int not null</quote>.</para>
        <para>If the table already had records, any <constant>NULL</constant>s in the column will
        remain <constant>NULL</constant>, and again Firebird will report them as 0 to the user when
        queried. The situation is almost exactly the same as when you add a <database>NOT
        NULL</database> column (see <link linkend="nullguide-add-not-null-field">
            <citetitle>Adding a <database>NOT NULL</database> field</citetitle>
          </link>). The only difference is that if you give the domain (and therefore the column) a
        default value, this time you can't be sure that it will be applied to the existing
        <constant>NULL</constant> entries. Tests show that sometimes the default is applied to all
        <constant>NULL</constant>s, sometimes to none, and in a few cases to
        <emphasis>some</emphasis> of the existing entries but not to others! Bottom line: if you
        change a column's type and the new type includes a default, double-check the existing
        entries – especially if they <quote>seem to be</quote> 0 or zero-equivalents.</para>
      </section>
      <section id="nullguide-add-check-not-null">
        <title><indexterm>
            <primary>Tables</primary>
            <secondary>add CHECK to columns</secondary>
          </indexterm>Adding a <database>CHECK</database> constraint to an existing column</title>
        <para>There are two ways to add a <database>CHECK</database> constraint to a column:</para>
        <blockquote>
          <programlisting>alter table Stk add check (Amt is not null)</programlisting>
          <programlisting>alter table Stk add constraint AmtNotNull check (Amt is not
          null)</programlisting>
        </blockquote>
        <para>The second form is preferred because it gives you an easy handle to drop the check,
        but the constraints themselves function exactly the same. As you might have expected,
        existing <constant>NULL</constant>s in the column will remain, can be backed up and
        restored, etc. etc. – see <link linkend="nullguide-add-check-not-null-field">
            <citetitle>Adding a <database>CHECK</database>ed column</citetitle>
          </link>.</para>
      </section>
    </section>
    <section id="nullguide-make-column-nullable">
      <title><indexterm>
          <primary>Tables</primary>
          <secondary>make columns nullable</secondary>
        </indexterm>Making non-nullable columns nullable again</title>
      <para>If you used a <database>CHECK</database> constraint to make the column non-nullable, you
      can simply drop it again:</para>
      <blockquote>
        <programlisting>alter table Stk drop constraint AmtNotNull</programlisting>
      </blockquote>
      <para>If you haven't named the constraint yourself but added the <database>CHECK</database>
      directly to the column or table, you must first find out its name before you can drop it. This
      can be done with the <application>isql</application> <quote>
          <database>SHOW TABLE</database>
        </quote> command (in this case: <database>SHOW TABLE STK</database>).</para>
      <para><indexterm>
          <primary>NOT NULL</primary>
          <secondary>remove</secondary>
        </indexterm>In the case of a <database>NOT NULL</database> constraint, if you know its name
      you can just drop it:</para>
      <blockquote>
        <programlisting>alter table Stk drop constraint NN_Amt</programlisting>
      </blockquote>
      <para>If you don't know the name you can try <application>isql</application>'s <quote>
          <database>SHOW TABLE</database>
        </quote> again, but this time it will <emphasis>only</emphasis> show the constraint name if
      it is user-defined. If the name was generated by the engine, you have to use this SQL to dig
      it up:</para>
      <blockquote>
        <programlisting>select rc.rdb$constraint_name from rdb$relation_constraints rc join
        rdb$check_constraints cc on rc.rdb$constraint_name = cc.rdb$constraint_name where
        rc.rdb$constraint_type = 'NOT NULL' and rc.rdb$relation_name = '&lt;TableName&gt;' and
        cc.rdb$trigger_name = '&lt;FieldName&gt;'</programlisting>
      </blockquote>
      <para>Don't break your head over some of the table and field names in this statement; they are
      illogical but correct. Make sure to uppercase the names of your table and field if they were
      defined case-insensitively. Otherwise, match the case exactly.</para>
      <para><indexterm>
          <primary>NOT NULL</primary>
          <secondary>via domain</secondary>
          <tertiary>remove</tertiary>
        </indexterm>If the <database>NOT NULL</database> constraint came with a domain, you can also
      remove it by changing the column type to a nullable domain or built-in datatype:</para>
      <blockquote>
        <programlisting>alter table Stk alter Amt type int</programlisting>
      </blockquote>
      <para>Any concealed <constant>NULL</constant>s, if present, will now become visible
      again.</para>
      <para>No matter how you removed the <database>NOT NULL</database> constraint, commit your work
      and <emphasis>close all connections to the database</emphasis>. After that, you can reconnect
      and insert <constant>NULL</constant>s in the column.</para>
    </section>
  </section>
  <section id="nullguide-testing">
    <title><indexterm>
        <primary>NULL</primary>
        <secondary>test for</secondary>
        <tertiary>in practice</tertiary>
      </indexterm><indexterm>
        <primary>Testing for NULL</primary>
        <secondary>in practice</secondary>
      </indexterm>Testing for <constant>NULL</constant> and equality in practice</title>
    <para>This section contains some practical tips and examples that may be of use to you in your
    everyday dealings with <constant>NULL</constant>s. It concentrates on testing for
    <constant>NULL</constant> itself and testing the (in)equality of two things when
    <constant>NULL</constant>s may be involved.</para>
    <section id="nullguide-test-if-matters">
      <title>Testing for <constant>NULL</constant> – if it matters</title>
      <para>Quite often, you don't need to take special measures for fields or variables that may be
      <constant>NULL</constant>. For instance, if you do this:</para>
      <blockquote>
        <para>
          <programlisting>select * from Customers where Town = 'Ralston'</programlisting>
        </para>
      </blockquote>
      <para>you probably don't want to see the customers whose town is unspecified. Likewise:</para>
      <blockquote>
        <para>
          <programlisting>if (Age &gt;= 18) then CanVote = 'Yes'</programlisting>
        </para>
      </blockquote>
      <para>doesn't include people of unknown age, which is also defensible. But:</para>
      <blockquote>
        <para>
          <programlisting>if (Age &gt;= 18) then CanVote = 'Yes'; else CanVote =
          'No';</programlisting>
        </para>
      </blockquote>
      <para>seems less justified: if you don't know a person's age, you shouldn't explicitly deny
      her the right to vote. Worse, this:</para>
      <blockquote>
        <para>
          <programlisting>if (Age &lt; 18) then CanVote = 'No'; else CanVote =
          'Yes';</programlisting>
        </para>
      </blockquote>
      <para>won't have the same effect as the previous. If some of the <constant>NULL</constant>
      ages are in reality under 18, you're now letting minors vote!</para>
      <para>The right approach here is to test for <constant>NULL</constant> explicitly:</para>
      <blockquote>
        <para>
          <programlisting>if (Age is null) then CanVote = 'Unsure'; else if (Age &gt;= 18 ) then
          CanVote = 'Yes'; else CanVote = 'No';</programlisting>
        </para>
      </blockquote>
      <para>Since this code covers more than two possibilities, it's more elegant to use the
      <database>CASE</database> syntax (available in Firebird 1.5 and up):</para>
      <blockquote>
        <para>
          <programlisting>CanVote = case when Age is null then 'Unsure' when Age &gt;= 18 then 'Yes'
          else 'No' end;</programlisting>
        </para>
      </blockquote>
      <para>Or, prettier:</para>
      <blockquote>
        <para>
          <programlisting>CanVote = case when Age &gt;= 18 then 'Yes' when Age &lt; 18 then 'No'
          else 'Unsure' end;</programlisting>
        </para>
      </blockquote>
    </section>
    <section id="nullguide-testing-equality">
      <title><indexterm>
          <primary>Equality tests</primary>
        </indexterm>Equality tests</title>
      <para>Sometimes you want to find out if two fields or variables are the same and you want to
      consider them equal if they are both <constant>NULL</constant>. The way to do this depends on
      your Firebird version.</para>
      <section>
        <title><indexterm>
            <primary>Equality tests</primary>
            <secondary>in Firebird 2+</secondary>
          </indexterm><indexterm>
            <primary>DISTINCT</primary>
            <secondary>testing distinctness</secondary>
          </indexterm><indexterm>
            <primary>IS [NOT] DISTINCT FROM</primary>
          </indexterm>Firebird 2.0 and up</title>
        <para>In Firebird 2 and higher, you test for null-encompassing equality with
        <database>DISTINCT</database>. This has already been discussed, but here's a quick recap.
        Two expressions are considered:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><database>DISTINCT</database> if they have different values or if one of them is
            <constant>NULL</constant> and the other isn't;</para>
          </listitem>
          <listitem>
            <para><database>NOT DISTINCT</database> if they have the same value or if both of them
            are <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>
        <para><database>[NOT] DISTINCT</database> always returns <constant>true</constant> or
        <constant>false</constant>, never <constant>NULL</constant> or something else.
        Examples:</para>
        <blockquote>
          <para>
            <programlisting>if (A <emphasis role="bold">is distinct from</emphasis> B)
            then...</programlisting>
            <programlisting>if (Buyer1 <emphasis role="bold">is not distinct from</emphasis> Buyer2)
            then...</programlisting>
          </para>
        </blockquote>
        <para><link linkend="nullguide-testing-change">Skip the next section</link> if you're not
        interested in the pre-Firebird-2 stuff.</para>
      </section>
      <section>
        <title><indexterm>
            <primary>Equality tests</primary>
            <secondary>in Firebird 1.*</secondary>
          </indexterm>Earlier Firebird versions</title>
        <para>Pre-2.0 versions of Firebird don't support this use of <database>DISTINCT</database>.
        Consequently, the tests are a little more complicated and there are some pitfalls to
        avoid.</para>
        <para>The correct equality test for pre-2.0 Firebird versions is:</para>
        <blockquote>
          <para>
            <programlisting>if (A = B or A is null and B is null) then...</programlisting>
          </para>
        </blockquote>
        <para>or, if you want to make the precedence of the operations explicit:</para>
        <blockquote>
          <para>
            <programlisting>if ((A = B) or (A is null and B is null)) then...</programlisting>
          </para>
        </blockquote>
        <para>A word of warning though: if exactly one of A and B is <constant>NULL</constant>, the
        test expression becomes <constant>NULL</constant>, not <constant>false</constant>! This is
        OK in an <literal>if</literal> statement, and we can even add an <literal>else</literal>
        clause which will be executed if A and B are not equal (including when one is
        <constant>NULL</constant> and the other isn't):</para>
        <blockquote>
          <para>
            <programlisting>if (A = B or A is null and B is null) then ...stuff to be done if A
            equals B... else ...stuff to be done if A and B are different...</programlisting>
          </para>
        </blockquote>
        <para>But don't get the bright idea of inverting the expression and using it as an
        inequality test:</para>
        <blockquote>
          <para>
            <programlisting>/* Don't do this! */ if (not(A = B or A is null and B is null)) then
            ...stuff to be done if A differs from B...</programlisting>
          </para>
        </blockquote>
        <para>The above code will work correctly if A and B are both <constant>NULL</constant> or
        both non-<constant>NULL</constant>. But it will fail to execute the <literal>then</literal>
        clause if exactly one of them is <constant>NULL</constant>.</para>
        <para>If you only want something to be done if A and B are different, either use one of the
        correct expressions shown above and put a dummy statement in the <literal>then</literal>
        clause (starting at 1.5, an empty <code>begin..end</code> block is also allowed), or use
        this longer test expression:</para>
        <blockquote>
          <para>
            <programlisting>/* This is a correct inequality test for pre-2 Firebird: */ if (A
            &lt;&gt; B or A is null and B is not null or A is not null and B is null)
            then...</programlisting>
          </para>
        </blockquote>
        <para>Remember, all this is only necessary in pre-2.0 Firebird versions. From version 2
        onward, the inequality test is simply <quote>
            <code>if (A is distinct from B)</code>
          </quote>.</para>
      </section>
      <section>
        <title><indexterm>
            <primary>Equality tests</primary>
            <secondary>summary</secondary>
          </indexterm>Summary of (in)equality tests</title>
        <table id="nullguide-tbl-eqtests">
          <title>Testing (in)equality of A and B in different Firebird versions</title>
          <tgroup cols="3">
            <colspec colname="col-testtype" colwidth="7*" />
            <colspec colname="col15" colwidth="24*" />
            <colspec colname="col20" colwidth="18*" />
            <thead>
              <row>
                <entry morerows="1">Test type</entry>
                <entry align="center" nameend="col20" namest="col15">Firebird version</entry>
              </row>
              <row>
                <entry align="center">&lt;= 1.5.x</entry>
                <entry align="center">&gt;= 2.0</entry>
              </row>
            </thead>
            <tbody>
              <row valign="top">
                <entry>
                  <para>
                    <emphasis>Equality</emphasis>
                  </para>
                </entry>
                <entry>
                  <literallayout class="monospaced">A = B or A is null and B is null</literallayout>
                </entry>
                <entry>
                  <literallayout class="monospaced">A is not distinct from B</literallayout>
                </entry>
              </row>
              <row valign="top">
                <entry>
                  <para>
                    <emphasis>Inequality</emphasis>
                  </para>
                </entry>
                <entry>
                  <literallayout class="monospaced">A &lt;&gt; B or A is null and B is not null or A
                  is not null and B is null</literallayout>
                </entry>
                <entry>
                  <literallayout class="monospaced">A is distinct from B</literallayout>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Please keep in mind that with Firebird 1.5.x and earlier:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>the equality test returns <constant>NULL</constant> if exactly one operand is
            <constant>NULL</constant>;</para>
          </listitem>
          <listitem>
            <para>the inequality test returns <constant>NULL</constant> if both operands are
            <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>
        <para>In an <database>IF</database> or <database>WHERE</database> context, these
        <constant>NULL</constant> results act as <constant>false</constant> – which is fine for our
        purposes. But remember that an inversion with <database>NOT()</database> will also return
        <constant>NULL</constant> – not <quote>
            <constant>true</constant>
          </quote>. Also, if you use the 1.5-and-earlier tests within <database>CHECK</database>
        constraints in Firebird 2 or higher, be sure to read the section <link
            linkend="nullguide-check-constraints">
            <citetitle><database>CHECK</database> constraints</citetitle>
          </link>, if you haven't done so already.</para>
        <indexterm>
          <primary>JOIN</primary>
        </indexterm>
        <indexterm>
          <primary>NULL</primary>
          <secondary>in JOINs</secondary>
        </indexterm>
        <tip>
          <para>Most <database>JOIN</database>s are made on equality of fields in different tables,
          and use the <quote>
              <literal>=</literal>
            </quote> operator. This will leave out all
          <constant>NULL</constant>-<constant>NULL</constant> pairs. If you want
          <constant>NULL</constant> to match <constant>NULL</constant>, pick the equality test for
          your Firebird version from the table above.</para>
        </tip>
      </section>
    </section>
    <section id="nullguide-testing-change">
      <title>Finding out if a field has changed</title>
      <para>In triggers you often want to test if a certain field has changed (including: gone from
      <constant>NULL</constant> to non-<constant>NULL</constant> or vice versa) or stayed the same
      (including: kept its <constant>NULL</constant> state). This is nothing but a special case of
      testing the (in)equality of two fields, so here again our approach depends on the Firebird
      version.</para>
      <para>In Firebird 2 and higher we use this code:</para>
      <blockquote>
        <para>
          <programlisting>if (New.Job is not distinct from Old.Job) then ...Job field has stayed the
          same... else ...Job field has changed...</programlisting>
        </para>
      </blockquote>
      <para>And in older versions:</para>
      <blockquote>
        <para>
          <programlisting>if (New.Job = Old.Job or New.Job is null and Old.Job is null) then ...Job
          field has stayed the same... else ...Job field has changed...</programlisting>
        </para>
      </blockquote>
    </section>
  </section>
  <section id="nullguide-summary">
    <title><indexterm>
        <primary>Summary</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>in a nutshell</secondary>
      </indexterm>Summary</title>
    <!--Also publish this summary as a separate refsheet, titled "Null in a Nutshell"
(and link here <-> there)-->
    <para><constant>NULL</constant> in a nutshell:</para>
    <itemizedlist>
      <listitem>
        <para><constant>NULL</constant> means <emphasis>unknown</emphasis>.</para>
      </listitem>
      <listitem>
        <para>To exclude <constant>NULL</constant>s from a domain or column, add <quote>
            <database>NOT NULL</database>
          </quote> after the type name.</para>
      </listitem>
      <listitem>
        <para>To find out if A is <constant>NULL</constant>, use <quote>
            <database>A IS [NOT] NULL</database>
          </quote>.</para>
      </listitem>
      <listitem>
        <para>Assigning <constant>NULL</constant> is done like assigning values: with <quote>
            <database>A = NULL</database>
          </quote> or an insert list.</para>
      </listitem>
      <listitem>
        <para>To find out if A and B are the same, with the understanding that all
        <constant>NULL</constant>s are the same and different from anything else, use <quote>
            <database>A IS [NOT] DISTINCT FROM B</database>
          </quote> in Firebird 2 and up. In earlier versions the tests are:</para>
        <blockquote>
          <programlisting>// equality: A = B or A is null and B is null</programlisting>
          <programlisting>// inequality: A &lt;&gt; B or A is null and B is not null or A is not
          null and B is null</programlisting>
        </blockquote>
      </listitem>
      <listitem>
        <para>In Firebird 2 and up you can use <constant>NULL</constant> literals in just about
        every situation where a regular value is also allowed. In practice this mainly gives you a
        lot more rope to hang yourself.</para>
      </listitem>
      <listitem>
        <para>Most of the time, <constant>NULL</constant> operands make the entire operation return
        <constant>NULL</constant>. Noteworthy exceptions are:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><quote><constant>NULL</constant> or <constant>true</constant></quote> evaluates to
            <constant>true</constant>;</para>
          </listitem>
          <listitem>
            <para><quote><constant>NULL</constant> and <constant>false</constant></quote> evaluates
            to <constant>false</constant>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>The <database>IN</database>, <database>ANY</database>|<database>SOME</database> and
        <database>ALL</database> predicates may (but do not always) return <constant>NULL</constant>
        if either the left-hand side expression or a list/subresult element is
        <constant>NULL</constant>.</para>
      </listitem>
      <listitem>
        <para>The <database>[NOT] EXISTS</database> predicate never returns
        <constant>NULL</constant>. The <database>[NOT] SINGULAR</database> predicate never returns
        <constant>NULL</constant> in Firebird 2.1 and up. It is broken in all previous
        versions.</para>
      </listitem>
      <listitem>
        <para>In aggregate functions only non-<constant>NULL</constant> fields are involved in the
        computation. Exception: <database>COUNT(*)</database>.</para>
      </listitem>
      <listitem>
        <para>In ordered sets, <constant>NULL</constant>s are placed...</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>1.0: At the bottom;</para>
          </listitem>
          <listitem>
            <para>1.5: At the bottom, unless <database>NULLS FIRST</database> specified;</para>
          </listitem>
          <listitem>
            <para>2.0: At the <quote>small end</quote> (top if ascending, bottom if descending),
            unless overridden by <database>NULLS FIRST/LAST</database>.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>If a <database>WHERE</database> or <database>HAVING</database> clause evaluates to
        <constant>NULL</constant>, the row is not included in the result set.</para>
      </listitem>
      <listitem>
        <para>If the test expression of an <database>IF</database> statement is
        <constant>NULL</constant>, the <database>THEN</database> block is skipped and the
        <database>ELSE</database> block executed.</para>
      </listitem>
      <listitem>
        <para>A <database>CASE</database> statement returns <constant>NULL</constant>:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If the selected result is <constant>NULL</constant>.</para>
          </listitem>
          <listitem>
            <para>If no matches are found (simple <database>CASE</database>) or no conditions are
            <constant>true</constant> (searched <database>CASE</database>) and there is no
            <database>ELSE</database> clause.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>In a simple <database>CASE</database> statement, <quote>
            <database>CASE</database>
            <replaceable>&lt;null_expr&gt;</replaceable>
          </quote> does <emphasis>not</emphasis> match <quote><database>WHEN</database>
        <replaceable>&lt;null_expr</replaceable>&gt;</quote>.</para>
      </listitem>
      <listitem>
        <para>If the test expression of a <database>WHILE</database> statement evaluates to
        <constant>NULL</constant>, the loop is not (re)entered.</para>
      </listitem>
      <listitem>
        <para>A <database>FOR</database> statement is not exited when <constant>NULL</constant>s are
        received. It continues to loop until either all the rows have been processed or it is
        interrupted by an exception or a loop-breaking PSQL statement.</para>
      </listitem>
      <listitem>
        <para>In Primary Keys, <constant>NULL</constant>s are never allowed.</para>
      </listitem>
      <listitem>
        <para>In Unique Keys and Unique Indices, <constant>NULL</constant>s are</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><emphasis>not allowed</emphasis> in Firebird 1.0;</para>
          </listitem>
          <listitem>
            <para><emphasis>allowed</emphasis> (even multiple) in Firebird 1.5 and higher.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para>In Foreign Key columns, multiple <constant>NULL</constant>s are allowed.</para>
      </listitem>
      <listitem>
        <para>If a <database>CHECK</database> constraint evaluates to <constant>NULL</constant>, the
        input is</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><emphasis>rejected</emphasis> under Firebird 1.5 and earlier;</para>
          </listitem>
          <listitem>
            <para><emphasis>accepted</emphasis> under Firebird 2.0 and higher.</para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para><database>SELECT DISTINCT</database> considers all <constant>NULL</constant>s equal:
        in a single-column select, at most one is returned.</para>
      </listitem>
      <listitem>
        <para>UDFs sometimes convert <constant>NULL</constant> <literal>&lt;–&gt;</literal>
        non-<constant>NULL</constant> in a seemingly random manner.</para>
      </listitem>
      <listitem>
        <para>The <function>COALESCE</function> and <function>*NVL</function> functions can convert
        <constant>NULL</constant> to a value.</para>
      </listitem>
      <listitem>
        <para>The <function>NULLIF</function> family of functions can convert values to
        <constant>NULL</constant>.</para>
      </listitem>
      <listitem>
        <para>If you add a <database>NOT NULL</database> column without a default value to a
        populated table, all the entries in that column will be <constant>NULL</constant> upon
        creation. Most clients however – including Firebird's <application>isql</application> tool –
        will falsely report them as zeroes (<literal>0</literal> for numerical fields,
        <literal>''</literal> for string fields, etc.)</para>
      </listitem>
      <listitem>
        <para>If you change a column's datatype to a <database>NOT NULL</database> domain, any
        existing <constant>NULL</constant>s in the column will remain <constant>NULL</constant>.
        Again most clients – including <application>isql</application> – will show them as
        zeroes.</para>
      </listitem>
    </itemizedlist>
    <para>Remember, this is how <constant>NULL</constant> works <emphasis>in Firebird
    SQL</emphasis>. There may be (at times subtle) differences with other RDBMSes.</para>
  </section>
  <appendix id="nullguide-bugs">
    <title><indexterm>
        <primary>Bugs list</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>
        <secondary>bugs</secondary>
      </indexterm><constant>NULL</constant>-related bugs in Firebird</title>
    <para>Attention: both historic and current bugs are listed in the sections below. Always look if
    and when a bug has been fixed before assuming that it exists in your version of Firebird.</para>
    <section id="nullguide-bugs-servercrashes">
      <title><indexterm>
          <primary>Bugs list</primary>
          <secondary>server-crashers</secondary>
        </indexterm>Bugs that crash the server</title>
      <section id="nullguide-bugs-execute-statement">
        <title><database>EXECUTE STATEMENT</database> with <constant>NULL</constant>
        argument</title>
        <para>EXECUTE STATEMENT with a <constant>NULL</constant> argument crashed Firebird 1.5 and
        1.5.1 servers. Fixed in 1.5.2.</para>
      </section>
      <section id="nullguide-bugs-extract">
        <title><database>EXTRACT</database> from <constant>NULL</constant> date</title>
        <para>In 1.0.0, EXTRACT from a <constant>NULL</constant> date would crash the server. Fixed
        in 1.0.2.</para>
      </section>
      <section id="nullguide-bugs-first-skip">
        <title><database>FIRST</database> and <database>SKIP</database> with
        <constant>NULL</constant> argument</title>
        <para>FIRST and SKIP crash a Firebird 1.5.n or lower server if given a
        <constant>NULL</constant> argument. Fixed in 2.0.</para>
      </section>
      <section id="nullguide-bugs-like">
        <title><database>LIKE</database> with <constant>NULL</constant> escape</title>
        <para>Using <database>LIKE</database> with a <constant>NULL</constant> escape character
        would crash the server. Fixed in 1.5.1.</para>
      </section>
    </section>
    <section id="nullguide-bugs-other">
      <title><indexterm>
          <primary>Bugs list</primary>
          <secondary>other bugs</secondary>
        </indexterm>Other bugs</title>
      <section id="nullguide-bugs-illegal-nulls">
        <title><constant>NULL</constant>s in <database>NOT NULL</database> columns</title>
        <para><constant>NULL</constant>s can exist in <database>NOT NULL</database> columns in the
        following situations:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If you add a <database>NOT NULL</database> column to a populated table, the fields
            in the newly added column will all be <constant>NULL</constant>.</para>
          </listitem>
          <listitem>
            <para>If you make an existing column <database>NOT NULL</database>, any
            <constant>NULL</constant>s already present in the column will remain in that
            state.</para>
          </listitem>
        </itemizedlist>
        <para>Firebird allows these <constant>NULL</constant>s to stay, also backs them up, but
        refuses to restore them with <application>gbak</application>. See <link
            linkend="nullguide-add-not-null-field">
            <citetitle>Adding a <database>NOT NULL</database> field</citetitle>
          </link> and <link linkend="nullguide-make-column-not-null">
            <citetitle>Making an existing column <database>NOT NULL</database></citetitle>
          </link>.</para>
      </section>
      <section id="nullguide-bugs-null-as-0">
        <title>Illegal <constant>NULL</constant>s returned as <literal>0</literal>,
        <literal>''</literal>, etc.</title>
        <para>If a <database>NOT NULL</database> column contains <constant>NULL</constant>s (see
        previous bug), the server will still describe it as non-nullable to the client. Since most
        clients don't question this assurance from the server, they will present these
        <constant>NULL</constant>s as 0 (or equivalent) to the user. See <link
            linkend="nullguide-nulls-reported-as-zeroes">
            <citetitle>False reporting of NULLs as zeroes</citetitle>
          </link>.</para>
      </section>
      <section id="nullguide-bugs-pk-null">
        <title>Primary key with <constant>NULL</constant> entries</title>
        <para>The following bug appeared in Firebird 1.5: if you had a table with some rows and you
        added a <database>NOT NULL</database> column (which automatically creates
        <constant>NULL</constant> entries in the existing rows – see above), you could make that
        column the primary key even though it had <constant>NULL</constant> entries. In 1.0 this
        didn't work because of the stricter rules for <database>UNIQUE</database> indices. Fixed in
        2.0.</para>
      </section>
      <section id="nullguide-bugs-substring">
        <title><database>SUBSTRING</database> results described as non-nullable</title>
        <para>The engine describes <database>SUBSTRING</database> result columns as non-nullable in
        the following two cases:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>If the first argument is a string literal, as in
            <quote><database>SUBSTRING</database>( 'Ootchie-coo' <database>FROM</database> 5
            <database>FOR</database> 2 )</quote>.</para>
          </listitem>
          <listitem>
            <para>If the first argument is a <database>NOT NULL</database> column.</para>
          </listitem>
        </itemizedlist>
        <para>This is incorrect because even with a known string, substrings may be
        <constant>NULL</constant>, namely if the one of the other arguments is
        <constant>NULL</constant>. In versions 1.* this bug didn't bite: the
        <database>FROM</database> and <database>FOR</database> args had to be literal values, so
        they could never be <constant>NULL</constant>. But as from Firebird 2, any expression that
        resolves to the required data type is allowed. And although the engine correctly returns
        <constant>NULL</constant> whenever any argument is <constant>NULL</constant>, it
        <emphasis>describes</emphasis> the result column as non-nullable, so most clients show the
        result as an empty string.</para>
        <para>This bug seems to be fixed in 2.1.</para>
      </section>
      <section id="nullguide-bugs-restore-notnull">
        <title>Gbak -n restoring <database>NOT NULL</database></title>
        <para><application>Gbak</application> <parameter>-n[o_validity]</parameter> restored
        <database>NOT NULL</database> constraints in early Firebird versions. Fixed in 1.5.1.</para>
      </section>
      <section id="nullguide-bugs-pred-in-any">
        <title><indexterm>
            <primary>IN</primary>
            <secondary>bug with indexed subselect</secondary>
          </indexterm><indexterm>
            <primary>ANY</primary>
            <secondary>bug with indexed subselect</secondary>
          </indexterm><indexterm>
            <primary>SOME</primary>
            <secondary>bug with indexed subselect</secondary>
          </indexterm><database>IN</database>, <database>=ANY</database> and
        <database>=SOME</database> with indexed subselect</title>
        <para>Let <replaceable>A</replaceable> be the expression on the left-hand side and
        <replaceable>S</replaceable> the result set of the subselect. In versions prior to 2.0,
        <quote>
            <database>IN</database>
          </quote>, <quote>
            <database>=ANY</database>
          </quote> and <quote>
            <database>=SOME</database>
          </quote> return false instead of <constant>NULL</constant> if an index is active on the
        subselect column and:</para>
        <itemizedlist spacing="compact">
          <listitem>
            <para>either <replaceable>A</replaceable> is <constant>NULL</constant> and
            <replaceable>S</replaceable> doesn't contain any <constant>NULL</constant>s;</para>
          </listitem>
          <listitem>
            <para>or <replaceable>A</replaceable> is not <constant>NULL</constant>,
            <replaceable>A</replaceable> is not found in <replaceable>S</replaceable>, and
            <replaceable>S</replaceable> contains at least one <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>
        <para>See the warnings in the <link linkend="nullguide-pred-in-bug">
            <database>IN</database>
          </link> and <link linkend="nullguide-pred-any-bug">
            <database>ANY</database>
          </link> sections. Workaround: use <quote>
            <literal>&lt;&gt;</literal>
            <database>ALL</database>
          </quote> instead. Fixed in 2.0.</para>
      </section>
      <section id="nullguide-bugs-pred-all">
        <title><indexterm>
            <primary>ALL</primary>
            <secondary>bug with indexed subselect</secondary>
          </indexterm><database>ALL</database> with indexed subselect</title>
        <para>With every operator except <quote>
            <literal>&lt;&gt;</literal>
          </quote>, <database>ALL</database> may return wrong results if an index is active on the
        subselect column. This can happen with our without <constant>NULL</constant>s involved. See
        the <link linkend="nullguide-pred-all-bug"><database>ALL</database> bug warning</link>.
        Fixed in 2.0.</para>
      </section>
      <section id="nullguide-bugs-select-distinct">
        <title><indexterm>
            <primary>DISTINCT</primary>
            <secondary>SELECT DISTINCT</secondary>
          </indexterm><indexterm>
            <primary>SELECT DISTINCT</primary>
          </indexterm><database>SELECT DISTINCT</database> with wrong <database>NULLS
        FIRST|LAST</database> ordering</title>
        <para>Firebird 2.0 has the following bug: if a <database>SELECT DISTINCT</database> is
        combined with an <database>[ASC] NULLS LAST</database> or <database>DESC NULLS
        FIRST</database> ordering, and the ordering field(s) form(s) the beginning (but not the
        whole) of the select list, every field in the <database>ORDER BY</database> clause that is
        followed by a field with a different (or no) ordering gets the <constant>NULL</constant>s
        placed at the default relative location, ignoring the <database>NULLS XXX</database>
        directive. Fixed in 2.0.1 and 2.1.</para>
      </section>
      <section id="nullguide-bugs-udf-nulltoval">
        <title>UDFs returning values when they should return <constant>NULL</constant></title>
        <para>This should definitely be considered a bug. If an angle is unknown,
        <emphasis>don't</emphasis> tell me that its cosine is 1! Although the history of these
        functions is known and we can understand why they behave like they do (see <link
            linkend="nullguide-udfs">
            <citetitle>User-Defined Functions</citetitle>
          </link>), it's still wrong. Incorrect results are returned and this should not happen.
        Most of the math functions in <systemitem class="library">ib_udf</systemitem>, as well as
        some others, have this bug.</para>
      </section>
      <section id="nullguide-bugs-udf-valtonull">
        <title>UDFs returning <constant>NULL</constant> when they should return a value</title>
        <para>This is the complement of the previous bug. <function>LPAD</function> for instance
        returns <constant>NULL</constant> if you want to pad an empty string with 10 dots. This
        function and others are fixed in 2.0, with the annotation that you must explicitly declare
        them with the <database>NULL</database> keyword or they'll show the old – buggy – behaviour.
        <function>LTRIM</function> and <function>RTRIM</function> trim empty strings to
        <constant>NULL</constant> in Firebird 1.0.n. This is fixed in 1.5 at the expense of
        returning <literal>''</literal> when trimming a <constant>NULL</constant> string, and only
        fully fixed in 2.0 (if declared with the <database>NULL</database> keyword).</para>
      </section>
      <section id="nullguide-bugs.singular-inconsistency">
        <title><database>SINGULAR</database> inconsistent with <constant>NULL</constant>
        results</title>
        <para><database>NOT SINGULAR</database> sometimes returns <constant>NULL</constant> where
        <database>SINGULAR</database> returns <constant>true</constant> or
        <constant>false</constant>. Fixed in 2.0.</para>
        <para><database>SINGULAR</database> may wrongly return <constant>NULL</constant>, in an
        inconsistent but reproducible manner. Fixed in 2.1.</para>
        <para>See the section on <link linkend="nullguide-pred-singular">
            <database>SINGULAR</database>
          </link>.</para>
      </section>
    </section>
  </appendix>
  <appendix id="nullguide-dochist">
    <title>Document history</title>
    <para>The exact file history is recorded in the <filename class="directory">manual</filename>
    module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>
    <para>
      <revhistory>
        <revision>
          <revnumber>0.1</revnumber>
          <date>8 Apr 2005</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>First edition.</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>0.2</revnumber>
          <date>15 Apr 2005</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>Mentioned that Fb 2.0 legalises <quote>
                <database>A = NULL</database>
              </quote> comparisons.</para>
            <para>Changed text in <quote>Testing if something is
            <constant>NULL</constant></quote>.</para>
            <para>Slightly altered <quote>Dealing with <constant>NULL</constant>s</quote>
            section.</para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.0</revnumber>
          <date>24 Jan 2007</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para>This is a major update, with so much new material added that the document has
            grown to around 4 times its former size. In addition, much of the existing text has been
            reorganised and thoroughly reworked. It's not feasible to give a summary of all the
            changes here. Consider this a new guide with 15–25% old material. The most important
            additions are:<itemizedlist spacing="compact">
                <listitem>
                  <para><constant>NULL</constant> literals</para>
                </listitem>
                <listitem>
                  <para>
                    <database>IS [NOT] DISTINCT FROM</database>
                  </para>
                </listitem>
                <listitem>
                  <para>Internal functions and directives</para>
                </listitem>
                <listitem>
                  <para>Predicates: <database>IN</database>, <database>ANY</database>,
                  <database>SOME</database>, <database>ALL</database>, <database>EXISTS</database>,
                  <database>SINGULAR</database></para>
                </listitem>
                <listitem>
                  <para>Searches (<database>WHERE</database>)</para>
                </listitem>
                <listitem>
                  <para>Sorts (<database>ORDER BY</database>)</para>
                </listitem>
                <listitem>
                  <para><database>GROUP BY</database> and <database>HAVING</database></para>
                </listitem>
                <listitem>
                  <para><database>CASE</database>, <database>WHILE</database> and
                  <database>FOR</database></para>
                </listitem>
                <listitem>
                  <para>Keys and indices</para>
                </listitem>
                <listitem>
                  <para><database>CHECK</database> constraints</para>
                </listitem>
                <listitem>
                  <para>
                    <database>SELECT DISTINCT</database>
                  </para>
                </listitem>
                <listitem>
                  <para>Converting values to <constant>NULL</constant> with
                  <function>NULLIF</function></para>
                </listitem>
                <listitem>
                  <para>Altering populated tables</para>
                </listitem>
                <listitem>
                  <para>Bugs list</para>
                </listitem>
                <listitem>
                  <para>Alphabetical index</para>
                </listitem>
              </itemizedlist></para>
          </revdescription>
        </revision>
        <revision>
          <revnumber>1.0.1</revnumber>
          <date>26 Jan 2007</date>
          <authorinitials>PV</authorinitials>
          <revdescription>
            <para><citetitle>Making non-nullable columns nullable again</citetitle>: Provisory fix
            of error regarding removal of <database>NOT NULL</database> constraints.</para>
          </revdescription>
        </revision>
      </revhistory>
    </para>
  </appendix>
  <appendix id="nullguide-license">
    <title>License notice</title>
    <para>The contents of this Documentation are subject to the Public Documentation License Version
    1.0 (the <quote>License</quote>); you may only use this Documentation if you comply with the
    terms of this License. Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>
    <para>The Original Documentation is titled <citetitle>Firebird Null Guide</citetitle>.</para>
    <para>The Initial Writer of the Original Documentation is: Paul Vinkenoog.</para>
    <para>Copyright (C) 2005–2007. All Rights Reserved. Initial Writer contact: paulvink at users
    dot sourceforge dot net.</para>
  </appendix>
  <index id="nullguide-index">
    <title>Alphabetical index</title>
  </index>
</article>
