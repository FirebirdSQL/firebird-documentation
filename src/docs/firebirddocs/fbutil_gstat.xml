<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<article id="gstat">
  <title>Firebird Database Statistics Reporting Tool</title>

  <titleabbrev>Gstat - Firebird Database Statistics Reporting
  Tool</titleabbrev>

  <articleinfo>
    <date>29 October 2009</date>

    <author>
      <firstname>Norman</firstname>

      <surname>Dunbar</surname>
    </author>

    <edition>11 October 2011 â€“ Document version 1.5</edition>
  </articleinfo>

  <section id="gstat-intro">
    <title>Introduction</title>

    <para><application>Gstat</application> is one of the database utilities
    supplied with Firebird. It is used to display statistical details about
    the contents of a database. <application>Gstat</application> does not
    connect to the database as other utilities do, instead it opens the
    database file(s) directly and reads through the raw data. Because of this,
    <application>gstat</application> is not transactionally aware and some of
    the statistics it gathers may include data that have been deleted, for
    example, by normal database transactions.</para>

    <para>In this manual, we will discuss:</para>

    <itemizedlist spacing="compact">
      <listitem>
        <para>Command line options for
        <application>gstat</application>.</para>
      </listitem>

      <listitem>
        <para><application>gstat</application> commands and their
        parameters.</para>
      </listitem>

      <listitem>
        <para>Running <application>gstat and interpreting the
        results</application>.</para>
      </listitem>

      <listitem>
        <para>Some caveats, gotchas and foibles of
        <application>gstat</application>.</para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="gstat-cmdline">
    <title>Command-line Switches</title>

    <para>Gstat should be run as either root or the Firebird user. This is
    because the default operating system permissions when a new database is
    created, are such that only the owner - firebird - has access to the
    database file(s). Even members of the firebird group have no read access
    by default.</para>

    <para><application>Gstat</application> is normally called as
    follows:</para>

    <para><command>gstat database_name [switches]</command></para>

    <para>Some documentation advises that <application>gstat</application> can
    be called as follows:</para>

    <para><command>gstat [switches] database_name</command></para>

    <para>However, although it does work this way, problems arise when the
    <userinput>-t[able]</userinput> switch is used.</para>

    <para>The database name cannot be a remote database, it must be local, but
    it can be an alias for a local database. The reason that it must be local
    is because <application>gstat</application> works at the
    <emphasis>physical file</emphasis> level as opposed to making a database
    connection to the server - it reads the database file directly.</para>

    <para>If <application>gstat</application> is called with an invalid
    switch, or with the new <userinput>-?</userinput> switch from Firebird 2.5
    onwards, the following is displayed to remind you of the valid ones. Only
    the short form of the switches is displayed, unfortunately.</para>

    <screen> ./gstat -?
usage:   gstat [options] &lt;database&gt; or gstat &lt;database&gt; [options]
Available switches:
    -a      analyze data and index pages
    -d      analyze data pages
    -h      analyze header page ONLY
    -i      analyze index leaf pages
    -s      analyze system relations in addition to user tables
    -u      username
    -p      password
    -fetch  fetch password from file
    -r      analyze average record and version length
    -t      tablename &lt;tablename2...&gt; (case sensitive)
    -z      display version number
option -t accepts several table names only if used after &lt;database&gt;

</screen>

    <note>
      <para>In Firebird versions prior to 2.0, the
      <userinput>-l[og]</userinput> switch could also be used. This reported
      on the details of the logging page(s) within the database. The logging
      pages have not been used for some time and the switch has now been
      removed from <application>gstat</application>.</para>
    </note>

    <note>
      <para>The <userinput>-fetch</userinput> switch is only available from
      Firebird 2.5 onwards.</para>
    </note>

    <para>These switches are described below.</para>

    <itemizedlist spacing="normal">
      <listitem>
        <para><userinput>-a[ll]</userinput></para>

        <para>This is the default switch and is equivalent to
        <userinput>-h[eader] -d[ata] -i[ndex]</userinput>. In the absence of
        both <userinput>-d[ata]</userinput> and
        <userinput>-i[ndex]</userinput>, <application>gstat</application> will
        run as if both had been specified alongside
        <userinput>-h[eader]</userinput>.</para>
      </listitem>

      <listitem>
        <para><userinput>-d[ata]</userinput></para>

        <para>Specifying this switch causes <application>gstat</application>
        to analyse every user table within the specified database. User
        indices, system tables and system indices are not analysed.</para>
      </listitem>

      <listitem>
        <para><userinput>-h[eader]</userinput></para>

        <para>This switch displays statistics about the database itself, then
        exits. The header information is also displayed when any other switch
        is used - so you always get database header details in your
        output.</para>
      </listitem>

      <listitem>
        <para><userinput>-i[ndex]</userinput></para>

        <para>Specifying this switch causes <application>gstat</application>
        to analyse every user index within the specified database. User
        tables, system indices and system tables are not analysed.</para>
      </listitem>

      <listitem>
        <para><userinput>-s[ystem]</userinput></para>

        <para>This switch is a modifier and alters the output from the
        <userinput>-d[ata]</userinput> or <userinput>-i[ndex]</userinput>
        switches by including the system tables (or indices) in addition to
        the user defined tables (or indices). Using this switch on its own is
        equivalent to calling gstat with <userinput>-a[ll]
        -s[ystem]</userinput> specified.</para>

        <para>When run, this switch lists statistics for the various RDB$
        tables and indices, and if running against Firebird 2, for the various
        MON$ tables and indices too.</para>
      </listitem>

      <listitem>
        <para><userinput>-r[ecord]</userinput></para>

        <para>The <userinput>-r[ecord]</userinput> switch is a modifier for
        the <userinput>-d[ata]</userinput> and
        <userinput>-s[ystem]</userinput> switches. It adds data about the
        average record and version lengths for any data tables (user and/or
        system) analysed. This switch has no effect on the
        <userinput>-i[ndex]</userinput> switch.</para>
      </listitem>

      <listitem>
        <para><userinput>-t[able]</userinput></para>

        <para>This switch allows you to analyse a table, or list of tables,
        and any indices belonging to the specified tables. See the <link
        linkend="gstat-caveats">caveats section</link> below for some
        potential problems with this switch and an example of how it should be
        used.</para>

        <para>The -t[able] switch should be followed by a list of the table
        names you wish to analyse. The list must be all in upper case and each
        table is separated by a space. It is also possible to use double
        quotes to cause <application>gstat</application> to analyse a table
        that doesn't have its name in upper case.</para>

        <para>It is not necessary to specify the
        <userinput>-i[ndex]</userinput> switch as any indices on the specified
        tables will be analysed. The database header information is also
        displayed.</para>
      </listitem>

      <listitem>
        <para><userinput>-u[sername]</userinput></para>

        <para>Allows the user name of the SYSDBA or database owner user to be
        specified. This need not be supplied if the <envar>ISC_USER</envar>
        environment variable exists and has a correct value for the user name,
        or if you are logged on to the server as a privileged account.</para>

        <note>
          <para>A privileged account is one of the following:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>root</para>
            </listitem>

            <listitem>
              <para>firebird</para>
            </listitem>

            <listitem>
              <para>interbase</para>
            </listitem>

            <listitem>
              <para>interbas (without the final 'e')</para>
            </listitem>
          </itemizedlist>

          <para>If you log in to the server with one of these accounts, you
          will automatically receive SYSDBA privileges. If you use a different
          account, you may be required to supply a user name and password to
          run <application>gstat</application>.</para>
        </note>
      </listitem>

      <listitem>
        <para><userinput><userinput>-p[assword]
        &lt;password&gt;</userinput></userinput></para>

        <para>Supplies the password for the user name specified above. This
        need not be supplied if the <envar>ISC_PASSWORD</envar> environment
        variable exists and has the correct value, or if you are logged on to
        the server using a privileged account.</para>
      </listitem>

      <listitem>
        <para><userinput>-fetch &lt;password file name&gt; | stdin
        | /dev/tty</userinput></para>

        <para>This switch causes the password for the appropriate user to be
        read from a file as opposed to being specified on the command line.
        The file name supplied is <emphasis>not</emphasis> in quotes and must
        be readable by the user running <application>gstat</application>. If
        the file name is specified as <filename>stdin</filename>, then the
        user will be prompted for a password. On POSIX systems, the file name
        <filename class="devicefile">/dev/tty</filename> will also result in a
        prompt for the password.</para>

        <note>
          <para>Firebird 2.5 onwards.</para>
        </note>
      </listitem>

      <listitem>
        <para><userinput><userinput>-z</userinput></userinput></para>

        <para>This is a modifier switch. Using <userinput>-z</userinput>
        displays the version number of the <application>gstat</application>
        utility and of the Firebird installation. You must supply a valid
        database name and possibly another switch. This switch adds the
        <application>gstat</application> and Firebird version details to the
        output for the other switch you supply - or the default if you didn't
        supply one. The shortest output would be from a <userinput>-t
        non_existent_tablename</userinput> if all you need is the version
        details, as follows:</para>

        <screen>tux&gt; gstat -t non_existing_tablename -z employee
gstat version LI-V2.1.3.18185 Firebird 2.1

Database "/opt/firebird/examples/empbuild/employee.fdb"
Database header page information:
...

Database file sequence:
File /opt/firebird/examples/empbuild/employee.fdb is the only file
        Firebird/linux Intel (access method), version 
"LI-V2.1.3.18185 Firebird 2.1"
        Firebird/linux Intel (remote server), version 
"LI-V2.1.3.18185 Firebird 2.1/tcp (greenbird)/P11"
        Firebird/linux Intel (remote interface), version 
"LI-V2.1.3.18185 Firebird 2.1/tcp (greenbird)/P11"
        on disk structure version 11.1

Analyzing database pages ...
</screen>

        <note>
          <para>The output above has been slightly changed to allow it to fit
          the page width for a pdf.</para>
        </note>
      </listitem>
    </itemizedlist>

    <para>The output starts by displaying the <application>gstat</application>
    version, followed by the details of the database header. The database file
    &amp; Firebird details are displayed next and finally, the details for the
    supplied table name, which of course is not found.</para>
  </section>

  <section id="gstat-example-header">
    <title>Gstat Examples And Interpretation</title>

    <para>This section contains frequently executed statistics gatherings and
    explains the output.</para>

    <section>
      <title>Database Header</title>

      <para>This option produces the least amount of output - unless you
      specify a single nonexistent table name with the <userinput>-t[able]
      </userinput>switch - and is included with all other switches, so it is
      discussed first.</para>

      <screen>tux&gt; gstat employee -header

Database "/opt/firebird/examples/empbuild/employee.fdb"
Database header page information:
        Flags                   0
        Checksum                12345
        Generation              184
        Page size               4096
        ODS version             11.1
        Oldest transaction      166
        Oldest active           167
        Oldest snapshot         167
        Next transaction        170
        Bumped transaction      1
        Sequence number         0
        Next attachment ID      68
        Implementation ID       19
        Shadow count            0
        Page buffers            0
        Next header page        0
        Database dialect        3
        Creation date           Sep 25, 2009 12:50:24
        Attributes              multi-user maintenance

    Variable header data:
        Sweep interval:         20000
        *END*
</screen>

      <para>The first line of output displays the database filename(s) and
      path. This can be useful to resolve a database alias to find out exactly
      where the database is located. As the employee database is a single-file
      database, only one file is displayed. Had this been a multiple-file
      database, the end of the listing above would look like the
      following:</para>

      <screen>...
    Variable header data:
        Continuation file:       /u00/firebird/databases/multi_employee.fdb1
        Last logical page:       162
</screen>

      <para>The details of the various header fields are described
      below:</para>

      <formalpara>
        <title>Flags</title>

        <para>Flags are not used on a database header page.</para>
      </formalpara>

      <formalpara>
        <title>Checksum</title>

        <para>All checksums are 12345. Checksums on the various database pages
        are no longer used.</para>
      </formalpara>

      <formalpara>
        <title>Generation</title>

        <para>The generation number is incremented each and every time this
        page is rewritten in the database.</para>
      </formalpara>

      <formalpara>
        <title>Page size</title>

        <para>The page size of the entire database. As the database file has
        to be split into various pages, the SYSDBA can, at creation time,
        specify how big a page size he or she desires. Every page in the
        database will be the same size.</para>
      </formalpara>

      <formalpara>
        <title>ODS version</title>

        <para>The On-Disc Structure of a database defines, possibly along with
        the SQL dialect, which features of the Firebird database system are
        available to users of that database. These features may be present in
        the version of Firebird that you are running, but if the database ODS
        is older, some of the new features will not be available.</para>
      </formalpara>

      <para>Values you may currently see here are:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>5.0 for Interbase 3.3</para>
        </listitem>

        <listitem>
          <para>8.0 for Interbase 4.0</para>
        </listitem>

        <listitem>
          <para>9.0 for Interbase 4.5</para>
        </listitem>

        <listitem>
          <para>9.1 for Interbase 5.0</para>
        </listitem>

        <listitem>
          <para>10.0 for Firebird 1.0 and Interbase 6.0</para>
        </listitem>

        <listitem>
          <para>10.1 for Firebird 1.5</para>
        </listitem>

        <listitem>
          <para>11.0 for Firebird 2.0</para>
        </listitem>

        <listitem>
          <para>11.1 for Firebird 2.1</para>
        </listitem>

        <listitem>
          <para>11.2 for Firebird 2.5</para>
        </listitem>
      </itemizedlist>

      <formalpara>
        <title>Transaction details</title>

        <para>There are a number of different transaction details in the
        report; these are:</para>
      </formalpara>

      <itemizedlist spacing="compact">
        <listitem>
          <para><emphasis role="bold">Oldest transaction</emphasis> - the
          transaction ID of what is known as <emphasis>Oldest Interesting
          Transaction</emphasis> or OIT. This is simply the ID of the longest
          running transaction that has so far not been completed by way of a
          <emphasis>hard</emphasis> commit. It may have been rolled back, or
          be in limbo, but if it has been committed, it is no longer
          interesting. This value, along with the Oldest Snapshot Transaction,
          is used when determining if an automatic sweep of the database is
          required.</para>

          <note>
            <para>There are two commits - commit and commit retaining. Only
            the first of these is a hard commit, which, when executed renders
            the transaction as no longer interesting. Commit retaining leaves
            the transaction as still interesting. Some database utilities
            and/or tools that commit actually perform a commit retaining which
            can leave your database with a lot of still interesting
            transactions.</para>
          </note>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Oldest active</emphasis> - the ID of the
          oldest <emphasis>active</emphasis> transaction, or OAT. This value
          shows the transaction ID (TID) of the oldest transaction that is
          still running. A transaction is considered active if it has not been
          <emphasis>hard</emphasis> committed, is not in a state of limbo and
          has not been rolled back.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Oldest snapshot</emphasis> - the ID of
          the oldest transaction which is currently not eligible to be
          garbage-collected. Any transaction with this or a higher ID cannot,
          yet, have old record versions removed by a sweep, for example.
          Normally, this is the same as the OAT above. The difference between
          <emphasis>this</emphasis> value and the OIT, if greater than the
          database sweep interval - assuming that automatic sweeping is not
          disabled - determines if an automatic sweep takes place.</para>

          <note>
            <para>Many web sites, books, manuals (previously including this
            one) explain that the automatic sweep is activated when OAT - OIT
            is greater than the sweep interval. This is
            <emphasis>not</emphasis> the case as explained by Vlad Khorsun,
            one of the Firebird developers, who explained that it is when OST
            - OIT is greater than the threshold that the sweep is
            activated.</para>
          </note>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Next transaction</emphasis> - The next
          transaction started on the database will have this ID number.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">Bumped transaction</emphasis> - always
          1, no longer used.</para>
        </listitem>
      </itemizedlist>

      <para>If you discover that the difference between the OAT and the Next
      Transaction ID seems to be growing larger and larger, something in your
      database is not committing properly and as such, an increasing number of
      garbage records may be building up. Eventually, you will see that the
      database startup times take longer and longer and the performance
      becomes slower and slower. Check the figures and if a problem is
      detected, you may be wise to run <application>gfix</application> to
      manually run a database sweep to clear out the garbage and restore
      normal working to the database.</para>

      <para>You may wish to consult with the section entitled <emphasis>Limbo
      Transaction Management</emphasis> in the <application>gfix</application>
      manual for details on how to detect and treat transactions in limbo.
      These may well be affecting the ability of the database sweep process in
      clearing out old redundant data from older uninteresting transactions.
      Limbo transactions are caused when a two-phase commit across multiple
      databases, fails for some reason. Limbo transactions are still
      interesting to the database and need to be committed or rolled back
      using <application>gfix</application> as the sweep processing cannot
      tell whether or not it is safe to do so without human
      intervention.</para>

      <formalpara>
        <title>Sequence number</title>

        <para>Always zero. This was the sequence number of the database header
        page, but is no longer used.</para>
      </formalpara>

      <formalpara>
        <title>Next attachment ID</title>

        <para>The ID number of the next attachment to this database. Every
        time an application connects to the database, this number goes up by
        one. Starting up and shutting down the database increases this number
        too. <application>Gstat</application> connections do not alter the id
        as they do not connect in a normal manner.</para>
      </formalpara>

      <formalpara>
        <title>Implementation ID</title>

        <para>When the database was created, it may have been created on a
        different system - hardware, operating system etc - to the one on
        which it is now running. The implementation ID shows you which
        hardware architecture the database was <emphasis>originally</emphasis>
        created on.</para>
      </formalpara>

      <para>The implementation ID is used to determine if the database can
      actually be used on the hardware it is currently running on, or if there
      is some feature of the original hardware, where the database was
      created, that makes it incompatible with the current host system.</para>

      <formalpara>
        <title>Shadow count</title>

        <para>Displays the number of shadow files attached to this database,
        or available for use by this database. Sometimes this value is
        incorrect even when shadow files have been created and/or deleted
        recently.</para>
      </formalpara>

      <warning>
        <para>Because of the inconsistency between what
        <application>gstat</application> reports and reality, it is best to
        use <application>isql</application> and the SHOW DATABASE command to
        view correct details of the shadow files.</para>
      </warning>

      <formalpara>
        <title>Page buffers</title>

        <para>If this value shows as zero, the database is using the server's
        default value for the number of pages that can be cached in memory
        when the database is operating. The setting may be defined in the
        <filename>firebird.conf</filename> file. On Firebird Superserver 2.1,
        this setting is the <userinput>DefaultDbCachePages</userinput> in the
        configuration file and is set to 2048 pages. You may use
        <application>gfix</application> to change this without editing the
        configuration file.</para>
      </formalpara>

      <formalpara>
        <title>Database dialect</title>

        <para>The database's SQL dialect number. Normally 1 or 3. This setting
        can be changed using <application>gfix</application> and, alongside
        the ODS value, helps determine what features of Firebird are available
        for use when applications use the database.</para>
      </formalpara>

      <formalpara>
        <title>Creation date</title>

        <para>The date that this database was created originally. It may show
        the date that the database was last restored by
        <application>gbak</application>.</para>
      </formalpara>

      <formalpara>
        <title>Attributes</title>

        <para>This part of the report displays information about various
        attributes of the database. Examples of what you may see are:</para>
      </formalpara>

      <itemizedlist spacing="compact">
        <listitem>
          <para>no reserve - All pages will be filled to 100% and will be most
          useful on read-only databases. No space is reserved in each page for
          updates and/or deletions.</para>
        </listitem>

        <listitem>
          <para>force write - Disc writes are not cached. They are written out
          to the hardware at the time of the write request. This is used
          mainly on Windows databases where the cache management system can
          lead to lost writes and database corruption.</para>
        </listitem>

        <listitem>
          <para>shutdown - The database has been closed and cannot be
          used.</para>
        </listitem>

        <listitem>
          <para>read only - The database is running in read-only mode.</para>
        </listitem>

        <listitem>
          <para>multi-user maintenance - The database is closed for
          maintenance. Multiple connections are allowed by SYSDBA or the
          database owner only.</para>
        </listitem>

        <listitem>
          <para>single-user maintenance - The database is closed for
          maintenance. Only one SYSDBA or database owner connection is
          allowed.</para>
        </listitem>
      </itemizedlist>

      <para>Other values may appear here, depending on the version of Firebird
      in use and, of course, future releases.</para>

      <formalpara>
        <title>Variable header data</title>

        <para>This part of the report covers information that is not in the
        fixed part of the database header. For example, the sweep interval is
        displayed here and information applicable to secondary files, if any,
        that are attached. If you have backed up the database using the
        <application>nbackup</application> tool, for example, details of the
        backup GUID will be displayed here - but only for the most recent
        backup.</para>
      </formalpara>
    </section>

    <section id="gstat-example-database">
      <title>Analyse Entire Database</title>

      <para>The analysis of the entire database is the default for
      <application>gstat</application>. When used, all user tables and indices
      will be analysed and the gathered statistics reported. As the output
      will most likely be very large, it is advisable to pipe the output to a
      file:</para>

      <para><command>gstat employee &gt;employee.gst</command></para>

      <para>The output will consist of an analysis of each and every user
      table and all associated user indices. Interpretation of these results
      is covered below in the sections on analysis of data and index
      pages.</para>
    </section>

    <section id="gstat-example-datapages">
      <title>Analyse Data Pages Only</title>

      <para>The command to analyse only user tables in the database is:</para>

      <para><command>gstat employee -data &gt;employee.gst</command></para>

      <para>And the results output from this command will list the user tables
      in alphabetical order. No indices will be analysed or listed regardless
      of how many may exist within the database.</para>

      <para>Once the report has been completed, the results can be analysed as
      follows, looking at one table in particular.</para>

      <screen>CONFIGREVISIONSTORE (213)
    Primary pointer page: 572, Index root page: 573
    Data pages: 2122, data page slots: 2122, average fill: 82%
    Fill distribution:
         0 - 19% = 1
        20 - 39% = 0
        40 - 59% = 0
        60 - 79% = 79
        80 - 99% = 2042
</screen>

      <para>The extract, above, from the report begins by displaying the table
      name - CONFIGREVISIONSTORE - and the table id - 213. The table's id is
      actually the column <database>RDB$RELATION_ID</database> in the system
      table <database>RDB$RELATIONS</database>, as the following
      <application>isql</application> session shows:</para>

      <screen>SQL&gt; select rdb$relation_name 
CON&gt; from rdb$relations
CON&gt; where rdb$relation_id = 213;

RDB$RELATION_NAME
===================================
CONFIGREVISIONSTORE</screen>

      <formalpara>
        <title>Primary pointer page</title>

        <para>This is the page number, within the database, of the first page
        with pointers to the data pages of this table. The structure of the
        database is such that each table has exclusive data pages and a list
        of those pages is required to be kept somewhere. This statistic gives
        you the page number for that location.</para>
      </formalpara>

      <formalpara>
        <title>Index root page</title>

        <para>This is the page number where the first page of pointers to the
        table's indices can be found within the database. Every table in the
        database has one page, the index root page, that holds pointers to the
        apex pages for each individual index.</para>
      </formalpara>

      <formalpara>
        <title>Data pages</title>

        <para>The total number of pages allocated to this table. Because gstat
        doesn't connect to the database in a transaction-aware manner, it
        cannot determine whether any of these pages are old record versions
        (garbage) or deleted records in currently uncommitted transactions, so
        the number may be higher than it needs to be as these additional pages
        are included in the total.</para>
      </formalpara>

      <formalpara>
        <title>Data page slots</title>

        <para>This value should be the same as the number of data pages. It
        reports on the number of pointers to pages in this table, that are
        stored in various pointer pages internal to the database. If the
        numbers differ, it may be down to the garbage that remains
        uncollected.</para>
      </formalpara>

      <formalpara>
        <title>Average fill</title>

        <para>The calculated space used in each page of the table, on average.
        The figure includes space utilised by back versions of records in the
        table. The fill distribution (below) gives more details.</para>
      </formalpara>

      <formalpara>
        <title>Fill distribution</title>

        <para>This section of the report displays a 5-band histogram where
        each band represents 20% of the space filled in each page. In the
        example above, we see that this table has a single page that is filled
        less than 20%, 79 pages are filled to between 60% and 79% while the
        vast majority, 2042, are filled to between 80% and 99%.</para>
      </formalpara>
    </section>

    <section>
      <title id="gstat-example-indexpages">Analyse Index Pages Only</title>

      <para>The command to analyse only user indices in the database
      is:</para>

      <para><command>gstat employee -index &gt;employee.gst</command></para>

      <para>And the results output from this command will list the user tables
      in alphabetical order. No tables will be analysed; however, the report
      will list the table names in alphabetical order and will list all
      applicable indices beneath the appropriate table name.</para>

      <para>Once the analysis has been completed, the results can be
      interpreted as follows. The following example shows the output from a
      single index in a database.</para>

      <screen>CONFIGREVISIONSTORE (213)
    Index PK_CONFIGREVISIONSTORE (0)
        Depth: 3, leaf buckets: 174, nodes: 62372
        Average data length: 2.58, total dup: 0, max dup: 0
        Fill distribution:
             0 - 19% = 15
            20 - 39% = 0
            40 - 59% = 55
            60 - 79% = 68
            80 - 99% = 36
</screen>

      <para>The above extract from the report begins by displaying the table
      name - CONFIGREVISIONSTORE - and the table id - 213 as described
      above.</para>

      <para>Following the table's details - and only the name and id are
      displayed - the index details are shown. As above, the index name and
      its id are displayed. This time, the id refers to the index's position
      in the list of all indices created on the table. Id zero is the first
      index created, id 1 is the next and so on. The output from
      <application>gstat</application> may not list the indices in id order
      and if any indices were created but subsequently dropped, there may be
      gaps in the id sequence.</para>

      <para>The next two lines, after the index name and id, show the overall
      statistics for this index.</para>

      <formalpara>
        <title>Depth</title>

        <para>This statistic displays the number of pages that have to be
        accessed in order to get at an index entry. In this example we have to
        read three separate pages into the buffer cache before we can use the
        index details to access the row we want in the table. This is often
        referred to as index indirection.</para>
      </formalpara>

      <screen>        Depth: 3
</screen>

      <para>On disc, there is a top level <emphasis>Index Root Page</emphasis>
      which is created at the same time as the database. This page holds a
      list of pointers to the top (apex) page for each index - one page per
      index. For any given index, this page holds a list of pointers to
      either:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>another level's apex pages if depth is greater than 1,
          or,</para>
        </listitem>

        <listitem>
          <para>to the leaf pages for the actual index data if depth =
          1.</para>
        </listitem>
      </itemizedlist>

      <para>The leaf pages store the location of the data that have been
      indexed. The index depth is the number of levels you have to step down
      from the index's apex page, to get to the leaf pages. Neither the Index
      Root Page nor the index's apex page are counted in the depth.</para>

      <para>On average, a depth of 2 or less indicates an index that is
      efficient. If the depth is 3 or more, the index will most likely not be
      operating at its best. The solution in this situation is to use
      <application>gbak</application> to increase the database page size by
      taking a backup and restoring it, as follows:</para>

      <screen>tux&gt; # Shutdown the database
tux&gt; gfix -shut -tran 60 employee

tux&gt; # Backup the database
tux&gt; gbak -backup employee /backups/employee.fbk

tux&gt; # Find current page size
tux&gt; gstat employee -header | grep -i "page size"
     page size             4096

tux&gt; # Restore database with a bigger page size
tux&gt; gbak -replace overwrite -page 8192 /backups/employee.fbk employee

tux&gt; # Check new page size
tux gstat employee -header | grep -i "page size"
     page size             8192

tux&gt; #Open the database
tux&gt; gfix -online normal employee
</screen>

      <para>Once the above has been carried out, you should find that the
      depth of the index is 2 or less. If this is not the case, simply repeat
      the process above using an even bigger page size.</para>

      <warning>
        <para>The above command to restore the backup
        <emphasis>overwrites</emphasis> the original database file. This works
        by deleting the original file and recreating it, so you really need to
        be sure that your database backup actually works and that the backup
        file produced is usable <emphasis>before</emphasis> attempting to
        overwrite a database. See the <application>gbak</application> manual
        for more details.</para>
      </warning>

      <formalpara>
        <title>Leaf buckets</title>

        <para>This statistic informs us of the number of leaf pages that this
        particular index uses. A page and a bucket are synonymous but page
        tends to be the more modern term in wide use.</para>
      </formalpara>

      <screen>        leaf buckets: 174
</screen>

      <para>In our example index, we see that there are 174 pages in the
      database holding the details of the indexed values for this table - all
      of these pages contain pointers to the data.</para>

      <para>The number of leaf pages should match up to the sum of the total
      number of pages in each histogram bar in the fill distribution, shown
      below.</para>

      <formalpara>
        <title>Nodes</title>

        <para>This is the total number of records in the table that have been
        indexed. However, it is possible - because
        <application>gstat</application> doesn't work in a transaction-aware
        manner - that this figure will possibly include rows that have been
        deleted (and not garbage-collected) and/or it may count records more
        than once if they have been modified in such a way that the indexed
        column(s) have been changed.</para>
      </formalpara>

      <screen>        nodes: 62372
</screen>

      <para>Because of the above, it is advisable to carry out a sweep, or a
      database backup &amp; restore, prior to running
      <application>gstat</application> to ensure that the statistics gathered
      are accurate and reflect the true position of the database.</para>

      <formalpara>
        <title>Average data length</title>

        <para>This statistic indicates the average length of the key column(s)
        in bytes.</para>
      </formalpara>

      <screen>        Average data length: 2.58
</screen>

      <para>This is most likely less that the actual sum of the column sizes
      as Firebird uses index compression to reduce the amount of data held in
      an index leaf page.</para>

      <formalpara>
        <title>Duplicates</title>

        <para>Duplicates are not permitted in a primary key or unique index.
        Other indexes do permit duplicates and these statistics report on the
        number of duplicates the index holds. The following
        <application>isql</application> query shows the details of duplicates
        for an indexed column in a different table to the one being used so
        far - which has no duplicates.</para>
      </formalpara>

      <programlisting>SQL&gt; SELECT IDX, COUNT(*)
CON&gt; FROM NORMAN_TEST
CON&gt; GROUP BY IDX;

         IDX        COUNT
============ ============
           1           10
           2            4
           3            1
</programlisting>

      <para>From the above we see a total of 15 rows, of which there are 14
      duplicated values (all those with a 1 or 2 in the IDX column). The
      following is the extract for the duplicates for this table:</para>

      <screen>    Index NORMANX (0)
        Depth: 1, leaf buckets: 1, nodes: 15
        Average data length: 0.27, total dup: 12, max dup: 9
</screen>

      <para>Total dup is the total number of duplicates in the index. Note
      from the above that only 12 duplicates are listed but we already know
      that there are 14 duplicates rows in the index. How is this
      possible?</para>

      <para>The first occurrence of a 1 and the first occurrence of a 2 are
      not counted, by <application>gstat</application>, as duplicates. Only
      the second and subsequent copies are considered duplicates.</para>

      <note>
        <para>In <emphasis>my</emphasis> opinion this is not quite correct
        behaviour. In the table above there are 15 rows and only three unique
        values in the IDX column, which is indexed. My index therefore holds
        14 duplicate values rather than just 12.</para>
      </note>

      <para>You can, however, use the total dup value to extract the number of
      unique values in the index by subtracting it from the nodes
      value.</para>

      <para>Max dup reports on the number of index entries which share the
      longest chain of duplicates. In other words - for the above index -
      there are 9 index entries that share the <emphasis>same</emphasis> value
      in the indexed column. We can see this to be true as the rows where IDX
      is 1 has 9 duplicate entries.</para>

      <para>If max dup is getting close to total dup, then it is a reasonable
      assumption to conclude that it may be that the index is so poor in
      selectivity that it may never be used in queries.</para>

      <formalpara>
        <title>Fill distribution</title>

        <para>The remainder of the report for our original example index shows
        how the pages are used within the index.</para>
      </formalpara>

      <screen>        Fill distribution:
             0 - 19% = 15
            20 - 39% = 0
            40 - 59% = 55
            60 - 79% = 68
            80 - 99% = 36
</screen>

      <para>The figures represent a graph (or histogram) of how the space in
      the index's pages are being utilised. Each value of the histogram
      represents the number of pages in the whole index, which have been
      filled to a certain percentage. Each bar of the histogram represents the
      percentage filled for the page.</para>

      <para>The example index's fill distribution is shown above and from
      these figures we see that the vast majority of the pages are filled to
      between 40 and 99%. The individual numbers at the end of each line above
      show the number of pages in this band. The example shows that:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>15 pages have been filled to less than 20%; and</para>
        </listitem>

        <listitem>
          <para>0 pages have been filled to between 20% and 39%; and</para>
        </listitem>

        <listitem>
          <para>55 pages have been filled to between 40% and 59%; and</para>
        </listitem>

        <listitem>
          <para>68 pages have been filled to between 60% and 79%; and</para>
        </listitem>

        <listitem>
          <para>36 pages are filled to between 80% and 99%.</para>
        </listitem>
      </itemizedlist>

      <para>The sum of all these pages should add up to the same figure shown
      above for leaf nodes.</para>

      <para>This index shows reasonably good space usage as the majority of
      pages are well filled. Ideally, you would like to see all the pages
      being filled to between 80 and 99%. If, on the other hand, the report
      showed that the pages were all lightly filled - say less than 60% - the
      index would be a good candidate for a rebuild exercise.</para>

      <para>Be sure to consider the total number of nodes before starting a
      rebuild - if there are only a small number of nodes in the index, then
      rebuilding will not help the space usage as there may not be enough
      records to actually fill the index pages.</para>
    </section>

    <section id="gstat-example-tables">
      <title>Selecting Tables To Analyse</title>

      <para>If you wish to include a specific list of tables in the analysis,
      rather than all user tables, then you can use the
      <userinput>-table</userinput> switch to specify the ones you wish to
      include. Note that specifying table names in this manner also analyses
      all indices associated with those tables.</para>

      <para><command>gstat employee -t EMPLOYEE JOB COUNTRY
      &gt;employee.gst</command></para>

      <para>The resulting output is interpreted as described above.</para>

      <para>If you have a table name that has been created by a user wishing
      to preserve the letter case of the table name, rather than having it
      converted to uppercase, for example:</para>

      <screen>tux&gt; isql myMusic
Database:  mymusic

SQL&gt; CREATE TABLE "MyMusic_Artists" (
CON&gt; art_id integer,
CON&gt; art_name ....);

SQL&gt; COMMIT;
</screen>

      <para>... then you must supply the table names in double quotes and in
      <emphasis>exactly</emphasis> the same letter case as the name of the
      table within the database:</para>

      <para><command>gstat mymusic -t "MyMusic_Titles" "MyMusic_Artists" &gt;
      MyMusic.gst</command></para>

      <para>If you supply a non-existing table name, or get the name in the
      wrong case etc, <application>gstat</application> simply ignores
      it.</para>
    </section>

    <section id="gstat-example-systemtables">
      <title>Including The System Tables &amp; Indices</title>

      <para>Normal use of <application>gstat</application> doesn't include the
      system tables and indices in the output. Calling
      <application>gstat</application> with the <userinput>-system</userinput>
      switch causes these tables to be included in the analysis.</para>

      <para><command>gstat employee -system &gt;employee.gst</command></para>

      <para>The interpretation of the results for the various system tables
      and indices is exactly as described above for user tables and
      indices.</para>
    </section>

    <section id="gstat-example-recordversion">
      <title>Record &amp; Version Details</title>

      <para>When you run <application>gstat</application> with either the
      default switches, or <userinput>-d[ata]</userinput> or
      <userinput>-t[able]</userinput> and add the
      <userinput>-r[record]</userinput> switch, you get additional information
      in the report that shows the average record length and average version
      details for the table(s) in question:</para>

      <screen>    Average record length: 96.55, total records: 62372
    Average version length: 0.00, total versions: 0, max versions: 0
</screen>

      <formalpara>
        <title>Average record length</title>

        <para>Simply the average record length, in bytes, of all the records
        in the table. If this figure is 0.00 then you can be reasonably sure
        that all your records have been deleted, or that you have no records
        in the table.</para>
      </formalpara>

      <formalpara>
        <title>Total records</title>

        <para>The total number of records in the table. The value may include
        records in currently active transactions and may include records which
        have been deleted.</para>
      </formalpara>

      <screen>tux&gt; # In session 1.
tux&gt; gstat test -r -t NORMAN

...
Analyzing database pages ...
NORMAN (142)
    Primary pointer page: 268, Index root page: 269
    Average record length: 9.00, total records: 15
    Average version length: 0.00, total versions: 0, max versions: 0
    Data pages: 1, data page slots: 1, average fill: 10%

tux&gt; isql tset -user norman -password secret
Database:  employee

SQL&gt; SELECT COUNT(*) FROM NORMAN;

       COUNT
============
          15
</screen>

      <para>At this point, we can see that there are 15 records in the NORMAN
      table and that the average length of these 15 records is 9.00 bytes.
      Next, we start another <application>isql</application> session and
      delete all the records from the NORMAN table.</para>

      <screen>tux&gt; # In session 2.
tux&gt; isql test -user norman -password secret
Database:  employee

SQL&gt; DELETE FROM NORMAN;
SQL&gt; COMMIT;
SQL&gt; shell;
</screen>

      <para>Still in the second session, we execute
      <application>gstat</application> to fetch statistics for the NORMAN
      table, the results are shown below.</para>

      <screen>tux&gt; gstat test -r -t NORMAN

...
Analyzing database pages ...
NORMAN (142)
    Primary pointer page: 268, Index root page: 269
    Average record length: 0.00, total records: 15
    Average version length: 9.00, total versions: 15, max versions: 1
    Data pages: 1, data page slots: 1, average fill: 16%
...

tux&gt; # Return to isql.
tux&gt; exit
</screen>

      <para>Comparing the report above with the one taken before we deleted
      the records, we can see straight away that:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>The average record length indicates that there are no records
          in the table, but the total record count shows that there are
          (still) 15. This is a good indicator that a session has deleted all
          the records but garbage collection has yet to run.</para>
        </listitem>

        <listitem>
          <para>The versioning details have all changed, there are now
          statistics for average version length, total versions and max
          versions.</para>
        </listitem>
      </itemizedlist>

      <itemizedlist>
        <listitem>
          <para>The average fill for the page(s) in this table has risen from
          10% to 16% even though everything has been deleted. The extra space
          is being used by the back versions of the deleted records.</para>
        </listitem>
      </itemizedlist>

      <para>Continuing in the second session, if we execute a full table scan
      of the NORMAN table we will not see any results, but we will garbage
      collect the back versions.</para>

      <screen>SQL&gt; SELECT * FROM NORMAN;

SQL&gt; shell;

tux&gt; gstat test -r -t NORMAN

...
Analyzing database pages ...
NORMAN (142)
    Primary pointer page: 268, Index root page: 269
    Average record length: 0.00, total records: 0
    Average version length: 0.00, total versions: 0, max versions: 0
    Data pages: 0, data page slots: 0, average fill: 0%
</screen>

      <para>Everything has now returned to zero. There are no back versions,
      no current versions and the page is no longer filled.</para>

      <formalpara>
        <title>Average version length</title>

        <para>This is similar to the average record length, but for the back
        versions of the record. For example, if you have deleted a number of
        records and updated others, the old - back - versions of these records
        will be reported here. If the figure is 0.00 then garbage collection
        has taken place and removed the back versions - see above for an
        example.</para>
      </formalpara>

      <formalpara>
        <title>Total versions</title>

        <para>The same as total records above, but includes only the back
        versions. If the figure is 0 then garbage collection has taken place
        and removed the back versions - see above for an example.</para>
      </formalpara>

      <formalpara>
        <title>Max versions</title>

        <para>If a record has been updated many times, the max versions
        statistic shows you the number of back versions of the record (or
        records) in question. In a table where all the rows have been updated
        7 times, but one has been updated 20 times, this statistic will report
        a value of 20. If the figure is 0.00 then garbage collection has taken
        place and removed the back versions - see above for an example.</para>
      </formalpara>
    </section>

    <section id="gstat-example-corruption">
      <title>If You Have Database Corruption</title>

      <para>In the unlikely event of a database corruption, your
      <application>gstat</application> output may have the following within
      the report:</para>

      <screen>Database file sequence:
File /opt/firebird/examples/empbuild/corrupt.fdb is the only file

Analyzing database pages ...
    Expected b-tree bucket on page 337334 from 146314
</screen>

      <para>If you do ever see a message like the above, displayed just after
      the header information, you are advised to immediately shut down all
      connections to the database, make an operating system level copy of the
      database file(s) and attempt to run <application>gbak</application>
      against the database to take a full backup. Using
      <application>nbackup</application> may copy the database happily, but
      not report any errors. <application>Gbak</application>, on the other
      hand, will flag up errors.</para>
    </section>
  </section>

  <section id="gstat-caveats">
    <title>Gstat Caveats</title>

    <para>The following is a brief list of gotchas and funnies that I have
    detected in my own use of <application>gstat</application>. Some of these
    are mentioned above, others may not be. By collecting them all here in one
    place, you should be able to find out what's happening if you have
    problems.</para>

    <section id="gstat-caveats-tableswitch">
      <title>The -t[able] Switch Can Cause Problems</title>

      <para>The <userinput>-t[able]</userinput> switch expects a list of table
      names (in upper case) to be supplied. Unfortunately, if you supply the
      database name <emphasis>after</emphasis> a table name, it is assumed to
      be a table name and you are prompted for a database name.</para>

      <screen>tux&gt; gstat -t EMPLOYEE JOB employee
please retry, giving a database name
</screen>

      <para>For this reason, always call <application>gstat</application> with
      the database name as the very <emphasis>first</emphasis>
      parameter:</para>

      <screen>tux&gt; gstat employee -t EMPLOYEE JOB

Database "/opt/firebird/examples/empbuild/employee.fdb"
Database header page information:
...

Database file sequence:
File /opt/firebird/examples/empbuild/employee.fdb is the only file

Analyzing database pages ...
...
</screen>

      <para>Alternatively, supply an additional switch
      <emphasis>after</emphasis> the last table name and
      <emphasis>before</emphasis> the database name:</para>

      <screen>tux&gt; gstat -t EMPLOYEE JOB -z employee
gstat version LI-V2.1.3.18185 Firebird 2.1

Database "/opt/firebird/examples/empbuild/employee.fdb"
Database header page information:
...

Database file sequence:
File /opt/firebird/examples/empbuild/employee.fdb is the only file
        Firebird/linux Intel (access method), version 
"LI-V2.1.3.18185 Firebird 2.1"
        Firebird/linux Intel (remote server), version 
"LI-V2.1.3.18185 Firebird 2.1/tcp (greenbird)/P11"
        Firebird/linux Intel (remote interface), version 
"LI-V2.1.3.18185 Firebird 2.1/tcp (greenbird)/P11"
        on disk structure version 11.1

Analyzing database pages ...
</screen>
    </section>

    <section id="gstat-caveats-shadows">
      <title>The Shadow Count Seems Wrong</title>

      <para>It appears that adding and/or dropping shadow files from a
      database is not always reported by <application>gstat</application> when
      it produces a database report.</para>

      <screen>tux&gt; # Use gstat to display shadow details
tux&gt; gstat employee -h|grep -i sh[a]dow
        Shadow count            0

tux&gt; isql employee
Database: employee

SQL&gt; SHOW DATABASE;
Database: employee
        Owner: SYSDBA
 Shadow 1: "/u00/firebird/databases/employee.shd1" auto
...
</screen>

      <para>Straight away, it is obvious that the report from
      <application>gstat</application> is incorrect as the employee database
      has one shadow file. If we use <application>isql</application> to add a
      new shadow file to this database, as shown below,
      <application>gstat</application> still insists that there are no
      shadows.</para>

      <screen>SQL&gt; CREATE SHADOW 7 AUTO '/u00/firebird/databases/employee.shd7';

SQL&gt; SHOW DATABASE;
Database: employee
        Owner: SYSDBA
 Shadow 1: "/u00/firebird/databases/employee.shd1" auto
 Shadow 7: "/u00/firebird/databases/employee.shd7" auto
...

SQL&gt; shell;

tux&gt; gstat employee -h | grep -i sh[a]dow
        Shadow count            0
</screen>
    </section>
  </section>

  <appendix id="gstat-dochist">
    <title>Document history</title>

    <para>The exact file history is recorded in the <filename
    class="directory">manual</filename> module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028
    </ulink>. The full URL of the CVS log for this file can be found at <ulink
    url="http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/ fbutil_gstat.xml?view=log"
    userlevel="">http://firebird.cvs.sourceforge.net/viewvc/firebird/manual/src/docs/firebirddocs/fbutil_gstat.xml?view=log</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>1.0</revnumber>

          <date>29 October 2009</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Created a new gstat manual.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.1</revnumber>

          <date>30 November 2009</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Many corrections suggested by Paul Vinkenhoog plus a general
            tidy up and a few more examples added.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.2</revnumber>

          <date>14 December 2009</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>A couple more minor corrections and spelling mistakes
            corrected.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.3</revnumber>

          <date>17 February 2010</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Formatting errors in the command line switches
            corrected.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.4</revnumber>

          <date>23 March 2011</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Added ODS 9.1 for Interbase 5.0 to the list of known ODS
            values.</para>

            <para>Added reference to Managing Limbo Transactions in the gfix
            manual.</para>

            <para>Corrected explanation of when an automatic database sweep is
            carried out, based on OIT and OST as opposed to OIT and OAT. As
            advised by Vlad Khorsun.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.5</revnumber>

          <date>11 October 2011</date>

          <authorinitials>ND</authorinitials>

          <revdescription>
            <para>Updated for Firebird 2.5.</para>

            <para>Spelling errors corrected.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="gstat-license">
    <title>License notice</title>

    <para>The contents of this Documentation are subject to the Public
    Documentation License Version 1.0 (the <quote>License</quote>); you may
    only use this Documentation if you comply with the terms of this License.
    Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/
    pdl.pdf</ulink> (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.
    html</ulink> (HTML).</para>

    <para>The Original Documentation is titled <citetitle>Firebird Database
    Statistics Reporting Tool</citetitle>.</para>

    <para>The Initial Writer of the Original Documentation is: Norman
    Dunbar.</para>

    <para>Copyright (C) 2009. All Rights Reserved. Initial Writer contact:
    NormanDunbar at users dot sourceforge dot net.</para>
  </appendix>
</article>
