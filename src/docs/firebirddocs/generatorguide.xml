<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"../../../tools/docbook-dtd/docbookx.dtd">
<article id="generatorguide">
  <articleinfo>
    <title>Firebird Generator Guide</title>

    <subtitle>A guide on how and when to use generators in Firebird</subtitle>

    <author>
      <firstname>Frank</firstname>

      <surname>Ingermann</surname>
    </author>

    <edition>7 May 2006 – Document version 0.2</edition>
  </articleinfo>

  <section id="generatorguide-intro">
    <title>Introduction</title>

    <section id="generatorguide-intro-about">
      <title>What is this article about?</title>

      <para>This article explains what Firebird generators are, and how and
      why you should use them. It is an attempt to collect all relevant
      information about generators in a single document.</para>
    </section>

    <section id="generatorguide-intro-forwhom">
      <title>Who should read it?</title>

      <para>Read this article if you...</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>are not familiar with the concept of generators;</para>
        </listitem>

        <listitem>
          <para>have questions on using them;</para>
        </listitem>

        <listitem>
          <para>want to make an Integer column behave like an
          <quote>AutoInc</quote> field as found in other RDBMSs;</para>
        </listitem>

        <listitem>
          <para>are looking for examples on how to use generators for IDs or
          other tasks;</para>
        </listitem>

        <listitem>
          <para>want to know the Firebird word for a <quote>sequence</quote>
          in Oracle.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="generatorguide-basics">
    <title>Generator Basics</title>

    <section id="generatorguide-basics-whatis">
      <title>What is a generator?</title>

      <para>Think of a generator as a <quote>thread-safe</quote> integer
      counter that lives inside a Firebird database. You can create one by
      giving it a name:</para>

      <programlisting>CREATE GENERATOR GenTest;</programlisting>

      <para>Then you can get its current value and increase or decrease it
      just like a <quote>var i:integer</quote> in Delphi, but it is not always
      easy to <quote>predictably</quote> set it directly to a certain value
      and then obtain that same value – it's inside the database, but
      <emphasis>outside of transaction control</emphasis>.</para>
    </section>

    <section id="generatorguide-basics-sequence">
      <title>What is a sequence?</title>

      <para><quote>Sequence</quote> is the official SQL term for what Firebird
      calls a generator. Because Firebird is constantly striving for better
      SQL compliance, the term <database>SEQUENCE</database> can be used as a
      synonym for <database>GENERATOR</database> in Firebird 2 and up. In fact
      it is recommended that you use the <database>SEQUENCE</database> syntax
      in new code.</para>

      <para>Although the word <quote>sequence</quote> puts the emphasis on the
      series of values generated whereas <quote>generator</quote> seems to
      refer primarily to the factory that produces these values, there is
      <emphasis>no difference at all</emphasis> between a Firebird generator
      and a sequence. They are just two words for the same database object.
      You can create a generator and access it using the sequence syntax, and
      vice versa.</para>

      <para>This is the preferred syntax for creating a generator/sequence in
      Firebird 2:</para>

      <programlisting>CREATE SEQUENCE SeqTest;</programlisting>
    </section>

    <section id="generatorguide-basics-storage">
      <title>Where are generators stored?</title>

      <para>Generator <emphasis>declarations</emphasis> are stored in the
      <database>RDB$GENERATORS</database> system table. Their
      <emphasis>values</emphasis> however are stored in special reserved pages
      inside the database. You never touch those values directly; you access
      them by means of built-in functions and statements which will be
      discussed later on in this guide.</para>

      <warning>
        <para>The information provided in this section is for educational
        purposes only. As a general rule, you should leave system tables
        alone. Don't attempt to create or alter generators by writing to
        <database>RDB$GENERATORS</database>. (A <database>SELECT</database>
        won't hurt though.)</para>
      </warning>

      <para>The structure of the <database>RDB$GENERATORS</database> system
      table is as follows:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>RDB$GENERATOR_NAME</database>
          <database>CHAR(31)</database></para>
        </listitem>

        <listitem>
          <para><database>RDB$GENERATOR_ID</database>
          <database>SMALLINT</database></para>
        </listitem>

        <listitem>
          <para><database>RDB$SYSTEM_FLAG</database>
          <database>SMALLINT</database></para>
        </listitem>
      </itemizedlist>

      <para>And, as from Firebird 2.0:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>RDB$DESCRIPTION</database> <database>BLOB subtype
          TEXT</database></para>
        </listitem>
      </itemizedlist>

      <para>Note that the <database>GENERATOR_ID</database> is – as the name
      says – an IDentifier for each generator, <emphasis>not</emphasis> its
      value. Also, don't let your applications store the ID for later use as a
      handle to the generator. Apart from this making no sense (the
      <emphasis>name</emphasis> is the handle), the ID may be changed after a
      backup-restore cycle. The <database>SYSTEM_FLAG</database> is 1 for
      generators used internally by the engine, and <constant>NULL</constant>
      or 0 for all those you created.</para>

      <para>Now let's have a look at the <database>RDB$GENERATORS</database>
      table, here with a single self-defined generator:</para>

      <informaltable>
        <tgroup cols="3">
          <colspec colname="colGenName" colwidth="5*" />

          <colspec align="center" colname="colGenID" colwidth="4*" />

          <colspec align="center" colname="colSysFlag" colwidth="4*" />

          <thead>
            <row>
              <entry align="center">RDB$GENERATOR_NAME</entry>

              <entry align="center">RDB$GENERATOR_ID</entry>

              <entry align="center">RDB$SYSTEM_FLAG</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>RDB$SECURITY_CLASS</entry>

              <entry>1</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>SQL$DEFAULT</entry>

              <entry>2</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$PROCEDURES</entry>

              <entry>3</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$EXCEPTIONS</entry>

              <entry>4</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$CONSTRAINT_NAME</entry>

              <entry>5</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$FIELD_NAME</entry>

              <entry>6</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$INDEX_NAME</entry>

              <entry>7</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$TRIGGER_NAME</entry>

              <entry>8</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>MY_OWN_GENERATOR</entry>

              <entry>9</entry>

              <entry><constant>NULL</constant></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <note>
        <title>Firebird 2 notes</title>

        <itemizedlist>
          <listitem>
            <para>Firebird 2 saw the introduction of an additional system
            generator, called <database>RDB$BACKUP_HISTORY</database>. It is
            used for the new NBackup facility.</para>
          </listitem>

          <listitem>
            <para>Even though the <database>SEQUENCE</database> syntax is
            preferred, the <database>RDB$GENERATORS</database> system table
            and its columns have not been renamed in Firebird 2.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>

    <section id="generatorguide-basics-maxval">
      <title>What is the maximum value of a generator?</title>

      <para>Generators store and return 64-bit values in all versions of
      Firebird. This gives us a value range of:</para>

      <blockquote>
        <para>-2<superscript>63</superscript> ..
        2<superscript>63</superscript>-1 or -9,223,372,036,854,775,808 ..
        9,223,372,036,854,775,807</para>
      </blockquote>

      <para>So if you use a generator with starting value 0 to feed a
      <database>NUMERIC(18) or BIGINT</database> column (both types represent
      64-bit integers), and you would insert 1000 rows per second, it would
      take around 300 million years (!) before it rolls over. As it is pretty
      unlikely mankind will still walk on this planet by then (and still use
      Firebird databases), that's nothing to be really worried about.</para>

      <para>A word of warning though. Firebird speaks two SQL
      <quote>dialects</quote>: dialect 1 and dialect 3. New databases should
      always be created with dialect 3, which is more powerful in a number of
      respects. Dialect 1 is a compatibility dialect, to be used only for
      legacy databases that were first created under InterBase 5.6 or
      earlier.</para>

      <para>One of the differences between the two is that dialect 1 has no
      native 64-bit integer type available. <database>NUMERIC(18)</database>
      columns for instance are stored internally as <database>DOUBLE
      PRECISION</database>, which is a floating point type. The biggest
      integer type in dialect 1 is the 32-bit
      <database>INTEGER</database>.</para>

      <para>In dialect 1 as in dialect 3, generators are 64-bit. But if you
      assign the generated values to an INTEGER column in a dialect 1
      database, they are truncated to the lower 32 bits, giving an effective
      range of:</para>

      <blockquote>
        <para>-2<superscript>31</superscript> ..
        2<superscript>31</superscript>-1 or -2,147,483,648 ..
        2,147,483,647</para>
      </blockquote>

      <para>Although the generator itself would go on from 2,147,483,647 to
      2,147,483,648 and beyond, the truncated value would wrap around at this
      point, giving the <emphasis>impression</emphasis> of a 32-bit
      generator.</para>

      <para>In the situation described above, with 1000 inserts per second,
      the generator-fed column would now roll over after 25
      <emphasis>days</emphasis> (!!!) and that is indeed something to have an
      eye on. 2<superscript>31</superscript> is a lot, but then again not that
      much depending on the situation.</para>

      <note>
        <para>In dialect 3, if you assign generator values to an
        <database>INTEGER</database> field, all goes well as long as the
        values lie within the 32-bit range. But as soon as that range is
        exceeded, you get a numeric overflow error: dialect 3 is much stricter
        on range checking than dialect 1!</para>
      </note>

      <section>
        <title>Client dialects and generator values</title>

        <para>Clients talking to a Firebird server can set their dialect to 1
        or 3, regardless of the database they are connected to. It is the
        client dialect, <emphasis>not</emphasis> the database dialect, that
        determines how Firebird passes generator values to the client:</para>

        <itemizedlist>
          <listitem>
            <para>If the client dialect is 1, the server returns generator
            values as truncated 32-bit integers to the client. But inside the
            database they remain 64-bit values and they do not wrap after
            reaching 2<superscript>31</superscript>-1 (even though it may look
            that way to the client). This is true both for dialect 1 and
            dialect 3 databases.</para>
          </listitem>

          <listitem>
            <para>If the client dialect is 3, the server passes the full
            64-bit value to the client. Again, this holds whether the database
            dialect is 1 or 3.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="generatorguide-basics-howmany">
      <title>How many generators are available in one database?</title>

      <para>Since Firebird version 1.0, the number of generators you can have
      in a single database is limited only by the maximum assignable ID in the
      <database>RDB$GENERATORS</database> system table. Being a
      <database>SMALLINT</database>, this maximum is
      2<superscript>15</superscript>-1 or 32767. The first ID is always 1, so
      the total number of generators cannot exceed 32767. As discussed before,
      there are 8 or 9 system generators in the database, leaving room for at
      least 32758 of your own. This should be amply enough for any practical
      application. And since the number of generators you declare has no
      effect on performance, you can feel free to use as many generators as
      you like.</para>

      <section>
        <title>Older InterBase and Firebird versions</title>

        <para>In the earliest pre-1.0 Firebird versions, as well as in
        InterBase, only one database page was used to store the generator
        values. Therefore, the number of available generators was limited by
        the page size of the database. The following table lists how many
        generators – including system generators – you can have in various
        InterBase and Firebird versions (thanks to Paul Reeves for providing
        the initial information):</para>

        <informaltable>
          <tgroup cols="5">
            <colspec colname="colVersion" colwidth="2*" />

            <colspec align="center" colname="col1k" />

            <colspec align="center" colname="col2k" />

            <colspec align="center" colname="col4k" />

            <colspec align="center" colname="col8k" />

            <spanspec nameend="col8k" namest="col1k" spanname="spanpagesize" />

            <thead>
              <row>
                <entry align="center">Version</entry>

                <entry align="center" spanname="spanpagesize">Page
                size</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry></entry>

                <entry align="center"><emphasis>1K</emphasis></entry>

                <entry align="center"><emphasis>2K</emphasis></entry>

                <entry align="center"><emphasis>4K</emphasis></entry>

                <entry align="center"><emphasis>8K</emphasis></entry>
              </row>

              <row>
                <entry><emphasis>InterBase &lt; v.6</emphasis></entry>

                <entry>247</entry>

                <entry>503</entry>

                <entry>1015</entry>

                <entry>2039</entry>
              </row>

              <row>
                <entry><emphasis>IB 6 and early pre-1.0
                Firebird</emphasis></entry>

                <entry>123</entry>

                <entry>251</entry>

                <entry>507</entry>

                <entry>1019</entry>
              </row>

              <row>
                <entry><emphasis>All later Firebird
                versions</emphasis></entry>

                <entry align="center" spanname="spanpagesize">32767</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>In InterBase versions prior to 6, generators were only 32 bits
        wide. This explains why these older versions could store roughly twice
        the number of generators on the same page size.</para>

        <warning>
          <para>InterBase, at least up to and including version 6.01, would
          happily let you <quote>create</quote> generators until the total
          number reached 32767. What happened if you accessed generators with
          an ID higher than the number given in the table above depended on
          the version:</para>

          <itemizedlist>
            <listitem>
              <para>InterBase 6 would generate an <quote>invalid block
              type</quote> error because the calculated location lay outside
              the one page that was allocated to generators.</para>
            </listitem>

            <listitem>
              <para>In earlier versions, if the calculated location lay
              outside the database, an error would be returned. Otherwise, if
              the generator was only <emphasis>read</emphasis> (without
              increment), the value that just <quote>happened to be</quote> on
              the calculated spot was returned. If it was <emphasis>written
              to</emphasis>, it would overwrite data. This could sometimes
              lead to an immediate error, but most of the time it would just
              silently corrupt your database.</para>
            </listitem>
          </itemizedlist>
        </warning>
      </section>
    </section>

    <section id="generatorguide-basics-transactions">
      <title>Generators and transactions</title>

      <para>As said, generators live outside of transaction control. This
      simply means you cannot safely <quote>rollback</quote> generators inside
      a transaction. There may be other transactions executing at the same
      time that change the value while your transaction runs. So once you have
      requested a generator value, consider it as <quote>gone
      forever</quote>.</para>

      <para>When you start a transaction and then call a generator and get a
      value of – let's say – 5, it will remain at that value <emphasis
      role="bold">even if you roll back the transaction (!)</emphasis>. Don't
      even <emphasis>think</emphasis> of something like <quote>OK, when I
      rollback, I can just do <database>GEN_ID</database>(mygen,-1) afterwards
      to set it back to 4</quote>. This may work most of the time, but is
      <emphasis>unsafe</emphasis> because other concurrent transactions may
      have changed the value in between. For the same reason it doesn't make
      sense to get the current value with <database>GEN_ID</database>(mygen,0)
      and then increment the value on the client side.</para>
    </section>
  </section>

  <section id="generatorguide-sqlsyntax">
    <title>SQL statements for generators</title>

    <section id="generatorguide-sqlsyntax-overview">
      <title>Statement overview</title>

      <para>The name of a generator must be a usual DB meta-identifier: 31
      chars maximum, no special characters except the underscore
      <quote>_</quote> (unless you use quoted identifiers). The SQL commands
      and statements that apply to generators are listed below. Their use will
      be discussed in some detail in the section <citetitle><link
      linkend="generatorguide-sqlsyntax-use">Use of generator
      statements</link></citetitle>.</para>

      <para>DDL (Data Definition Language) statements:</para>

      <programlisting>CREATE GENERATOR &lt;name&gt;;
SET GENERATOR &lt;name&gt; TO &lt;value&gt;;
DROP GENERATOR &lt;name&gt;;</programlisting>

      <para>DML (Data Manipulation Language) statements in client SQL:</para>

      <programlisting>SELECT GEN_ID( &lt;GeneratorName&gt;, &lt;increment&gt; ) FROM RDB$DATABASE;</programlisting>

      <para>DML statements in PSQL (Procedural SQL, available in stored
      procedures and triggers):</para>

      <programlisting>&lt;intvar&gt; = GEN_ID( &lt;GeneratorName&gt;, &lt;increment&gt; );</programlisting>

      <section>
        <title>Firebird 2 recommended sytax</title>

        <para>Although the traditional syntax is still fully supported in
        Firebird 2, these are the recommended DDL equivalents:</para>

        <programlisting>CREATE SEQUENCE &lt;name&gt;;
ALTER SEQUENCE &lt;name&gt; RESTART WITH &lt;value&gt;;
DROP SEQUENCE &lt;name&gt;;</programlisting>

        <para>And for the DML statements:</para>

        <programlisting>SELECT NEXT VALUE FOR &lt;SequenceName&gt; FROM RDB$DATABASE;</programlisting>

        <programlisting>&lt;intvar&gt; = NEXT VALUE FOR &lt;SequenceName&gt;;</programlisting>

        <para>Currently the new syntax does not support an increment other
        than 1. This limitation will be lifted in a future version. In the
        meantime, use <database>GEN_ID</database> if you need to apply another
        increment value.</para>
      </section>
    </section>

    <section id="generatorguide-sqlsyntax-use">
      <title>Use of generator statements</title>

      <para>The availability of statements and functions depends on whether
      you use them in:</para>

      <itemizedlist>
        <listitem>
          <para>Client SQL – The language you use when you, as a client, talk
          to a Firebird server.</para>
        </listitem>

        <listitem>
          <para>PSQL – The server-side programming language used in Firebird
          stored procedures and triggers.</para>
        </listitem>
      </itemizedlist>

      <section id="generatorguide-sqlsyntax-create">
        <title>Creating a generator (<quote>Insert</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>CREATE GENERATOR &lt;GeneratorName&gt;;</programlisting>

              <para>Preferred for Firebird 2 and up:</para>

              <programlisting>CREATE SEQUENCE &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <para>Not possible. Since you cannot change database metadata
              inside SPs or triggers, you cannot create generators there
              either.</para>

              <note>
                <para>In FB 1.5 and up, you can circumvent this limitation
                with the <database>EXECUTE STATEMENT</database>
                feature.</para>
              </note>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-getvalue">
        <title>Getting the current value (<quote>Select</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>SELECT GEN_ID( &lt;GeneratorName&gt;, 0 ) FROM RDB$DATABASE;</programlisting>

              <para>This syntax is still the only option in Firebird 2.</para>

              <note>
                <para>In Firebird's command-line tool
                <emphasis>isql</emphasis> there are two additional commands
                for retrieving current generator values:</para>

                <blockquote>
                  <programlisting>SHOW GENERATOR &lt;GeneratorName&gt;;
SHOW GENERATORS;</programlisting>
                </blockquote>

                <para>The first reports the current value of the named
                generator. The second does the same for all non-system
                generators in the database.</para>

                <para>The preferred Firebird 2 equivalents are, as you could
                guess:</para>

                <blockquote>
                  <programlisting>SHOW SEQUENCE &lt;SequenceName&gt;;
SHOW SEQUENCES;</programlisting>
                </blockquote>

                <para>Please notice again that these
                <database>SHOW...</database> commands are only available in
                the Firebird isql tool. Unlike <database>GEN_ID</database>,
                you can't use them from within other clients (unless these
                clients are isql frontends).</para>
              </note>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>&lt;intvar&gt; = GEN_ID( &lt;GeneratorName&gt;, 0 );</programlisting>

              <para>Firebird 2: same syntax.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-genvalue">
        <title>Generating the next value (<quote>Update</quote> +
        <quote>Select</quote>)</title>

        <para>Just like getting the current value, this is done with
        <database>GEN_ID</database>, but now you use an increment value of 1.
        Firebird will:</para>

        <orderedlist spacing="compact">
          <listitem>
            <para>get the current generator value;</para>
          </listitem>

          <listitem>
            <para>increment it by 1;</para>
          </listitem>

          <listitem>
            <para>return the incremented value.</para>
          </listitem>
        </orderedlist>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>SELECT GEN_ID( &lt;GeneratorName&gt;, 1 ) FROM RDB$DATABASE;</programlisting>

              <para>The new syntax, which is preferred for Firebird 2, is
              entirely different:</para>

              <programlisting>SELECT NEXT VALUE FOR &lt;SequenceName&gt; FROM RDB$DATABASE;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>&lt;intvar&gt; = GEN_ID( &lt;GeneratorName&gt;, 1 );</programlisting>

              <para>Preferred for Firebird 2 and up:</para>

              <programlisting>&lt;intvar&gt; = NEXT VALUE FOR &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-setvalue">
        <title>Setting a generator directly to a certain value
        (<quote>Update</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>SET GENERATOR &lt;GeneratorName&gt; TO &lt;NewValue&gt;;</programlisting>

              <para>This is useful to preset generators to a value other than
              0 (which is the default value after you created it) in e.g. a
              script to create the database. Just like <database>CREATE
              GENERATOR</database>, this is a DDL (not DML) statement.</para>

              <para>Preferred syntax for Firebird 2 and up:</para>

              <programlisting>ALTER SEQUENCE &lt;SequenceName&gt; RESTART WITH &lt;NewValue&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>GEN_ID( &lt;GeneratorName&gt;, &lt;NewValue&gt; - GEN_ID( &lt;GeneratorName&gt;, 0 ) );</programlisting>

              <warning>
                <para>This is more of a dirty little trick to do what you
                normally cannot and should not do in SPs and triggers:
                <emphasis>setting</emphasis> generators. They are for
                <emphasis>getting</emphasis>, not <emphasis>setting</emphasis>
                values.</para>

                <!--It also seems unsafe to me, unless the entire operation is atomic!
What if another thread/client changes the generator after the first GEN_ID call?-->
              </warning>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-drop">
        <title>Dropping a generator (<quote>Delete</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>DROP GENERATOR &lt;GeneratorName&gt;;</programlisting>

              <para>Preferred for Firebird 2 and up:</para>

              <programlisting>DROP SEQUENCE &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <para>Not possible, unless... (Same explanation as with Create:
              you can't – or rather, shouldn't – change metadata in
              PSQL.)</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Dropping a generator does not free the space it occupied for use
        by a new generator. In practice this rarely hurts, because most
        databases don't have the tens of thousands of generators that Firebird
        allows, so there's bound to be room for more anyway. But if your
        database <emphasis>does</emphasis> risk to hit the 32767 ceiling, you
        can free up dead generator space by performing a backup-restore cycle.
        This will neatly pack the <database>RDB$GENERATORS</database> table,
        re-assigning a contiguous series of IDs. Depending on the situation,
        the restored database may also need less pages for the generator
        values.</para>

        <section>
          <title>Dropping generators in old IB and Firebird versions</title>

          <para>InterBase 6 and earlier, as well as early pre-1.0 Firebird
          versions, do not have a <database>DROP GENERATOR</database> command.
          The only way to drop a generator in these versions is:</para>

          <programlisting>DELETE FROM RDB$GENERATORS WHERE RDB$GENERATOR_NAME = '&lt;GeneratorName&gt;';</programlisting>

          <para>...followed by a backup and restore.</para>

          <para>In these versions, with the maximum number of generators
          typically a couple of hundred, it is much more likely that the need
          will arise to reuse space from deleted generators.</para>
        </section>
      </section>
    </section>
  </section>

  <section id="generatorguide-rowids">
    <title>Using generators to create unique row IDs</title>

    <titleabbrev>Creating unique row IDs</titleabbrev>

    <section id="generatorguide-rowids-why">
      <title>Why row IDs at all?</title>

      <para>The answer to this question would go far beyond the scope of this
      article. If you see no need to have a generic, unique
      <quote>handle</quote> for every row inside a table, or don't like the
      idea of <quote>meaningless</quote> or <quote>surrogate</quote> keys in
      general, you should probably skip this section...</para>
    </section>

    <section id="generatorguide-rowids-howmanygens">
      <title>One for all or one for each?</title>

      <para>OK, so you want row IDs. { author's note: congratulations! :-)
      }</para>

      <para>A major, basic decision to take is whether we'll use one single
      generator for all the tables, or one generator for each table. This is
      up to you – but take the following considerations into account.</para>

      <para>With the <quote>one for all</quote> approach, you: <itemizedlist
          spacing="compact">
          <listitem>
            <para>+ need only a single generator for all your IDs;</para>
          </listitem>

          <listitem>
            <para>+ have one integer number that does not only identify your
            row within its <emphasis>table</emphasis>, but within the
            <emphasis>entire database</emphasis>;</para>
          </listitem>

          <listitem>
            <para>- have less possible ID values per table (this shouldn't
            really be a problem with 64bit generators...);</para>
          </listitem>

          <listitem>
            <para>- will soon have to deal with large ID values even in e.g.
            lookup tables with only a handful of records;</para>
          </listitem>

          <listitem>
            <para>- will likely see gaps in a per-table ID sequence, since
            generator values are spread throughout all tables.</para>
          </listitem>
        </itemizedlist></para>

      <para>With the <quote>one for each</quote> approach you:<itemizedlist
          spacing="compact">
          <listitem>
            <para>- have to create a generator for every single
            <quote>ID'd</quote> table in your database;</para>
          </listitem>

          <listitem>
            <para>- always need the combination of ID and table name to
            uniquely identify any row in any table;</para>
          </listitem>

          <listitem>
            <para>+ have a simple and robust <quote>insert counter</quote> per
            table;</para>
          </listitem>

          <listitem>
            <para>+ have a chronological sequence per table: if you find a gap
            in the ID sequence of a table, then it's caused either by a
            <database>DELETE</database> or by a failed
            <database>INSERT</database>.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section id="generatorguide-rowids-reusevals">
      <title>Can you re-use generator values?</title>

      <para>Well – yes, technically you <emphasis>can</emphasis>. But – NO,
      you shouldn't. Never. Never ever. Not only that this would destroy the
      nice chronological sequence (you can't judge a row's <quote>age</quote>
      by just looking at the ID any more), the more you think about it the
      more headaches it'll give you. Moreover it is an absolute contradiction
      to the entire concept of unique row identifiers.</para>

      <para>So unless you have good reasons to re-use generator values, and a
      well-thought-out mechanism to make this work safely in
      multi-user/multi-transaction environments, JUST DON'T DO IT!</para>
    </section>

    <section id="generatorguide-rowids-autoinc">
      <title>Generators for IDs or auto-increment fields</title>

      <para>Giving a newly inserted record an ID (in the sense of a unique
      <quote>serial number</quote>) is easily done with generators and Before
      Insert triggers, as we'll see in the following subsections. We start
      with the assumption that we have a table called
      <database>TTEST</database> with a column ID declared as Integer. Our
      generator's name is <database>GIDTEST</database>.</para>

      <section>
        <title>Before Insert trigger, version 1</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V1 for TTEST
active before insert position 0
as
begin
  new.id = gen_id( gidTest, 1 );
end</programlisting>

        <para>Problems with trigger version 1:</para>

        <para>This one does the job all right – but it also
        <quote>wastes</quote> a generator value in cases where there is
        already an ID supplied in the <database>INSERT</database> statement.
        So it would be more efficient to only assign a value when there was
        none in the <database>INSERT</database>:</para>
      </section>

      <section>
        <title>Before Insert trigger, version 2</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V2 for TTEST
active before insert position 0
as
begin
  if (new.id is null) then
  begin
    new.id = gen_id( gidTest, 1 );
  end
end</programlisting>

        <para>Problems with trigger version 2:</para>

        <para>Some access components have the <quote>bad habit</quote> to
        auto-fill all the columns in an <database>INSERT</database>. Those not
        explicitly set by you get default values – usually 0 for integer
        columns. In that case, the above trigger would not work: it would find
        that the ID column does not have the <emphasis>state</emphasis>
        <constant>NULL</constant>, but the <emphasis>value</emphasis> 0, so it
        would not generate a new ID. You could post the record, though – but
        only one... the second one would fail. It is anyway a good idea to
        <quote>ban</quote> 0 as a normal ID value, to avoid any confusion with
        <constant>NULL</constant> and 0. You could e.g. use a special row with
        an ID of 0 to store a default record in each table.</para>
      </section>

      <section>
        <title>Before Insert trigger, version 3</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V3 for TTEST
active before insert position 0
as
begin
  if ((new.id is null) or (new.id = 0)) then
  begin
    new.id = gen_id( gidTest, 1 );
  end
end</programlisting>

        <para>Well, now that we have a robust, working ID trigger, the
        following paragraphs will explain to you why mostly you won't need it
        at all:</para>

        <para>The basic problem with IDs assigned in Before Insert triggers is
        that they are generated on the server side, <emphasis>after</emphasis>
        you send the Insert statement from the client. This plainly means
        there is no safe way to know from the client side which ID was
        generated for the row you just inserted.</para>

        <para>You could grab the generator value from the client side after
        the Insert, but in multi-user environments you cannot be really sure
        that what you get is your own row's ID (because of the transaction
        issue).</para>

        <para>But if you get a new value from the generator
        <emphasis>before</emphasis>, and post the Insert with that value, you
        can simply fetch the row back with a <quote>Select ... where
        ID=&lt;genvalue&gt;</quote> to see what defaults were applied or
        whether columns were affected by Insert triggers. This works
        especially well because you usually have a unique Primary Key index on
        the ID column, and those are about the fastest indexes you can have –
        they're unbeatable in selectivity, and mostly smaller than indexes on
        <database>CHAR(n)</database> cols (for n&gt;8, depending on character
        set and collation).</para>

        <para>The bottom line to this is:</para>

        <para>You should create a Before Insert trigger to make absolutely
        sure every row gets a unique ID, even if no ID value was supplied from
        the client side in the Insert statement.</para>

        <para>If you have an <quote>SQL-closed</quote> database (that is, your
        own application code is the only source for newly inserted records),
        then you can leave out the trigger, but then you should
        <emphasis>always</emphasis> obtain a new generator value from the
        database before issuing the Insert statement and include it there. The
        same, of course, goes for inserts from within triggers and stored
        procedures.</para>
      </section>
    </section>
  </section>

  <section id="generatorguide-misc">
    <title>What else to do with generators</title>

    <para>Here you can find some ideas for usages of generators other than
    generating unique row IDs.</para>

    <section id="generatorguide-misc-uniquenums">
      <title>Using generators to give e.g. transfer files unique
      numbers</title>

      <para>A <quote>classic</quote> usage of generators is to ensure unique,
      sequential numbers for – well, anything in your application other than
      the row IDs discussed above. When you have an application that is
      transferring data to some other system, you can use generators to safely
      identify a single transfer by labeling it with a generated value. This
      greatly helps tracking down problems with interfaces between two systems
      (and, unlike most of the following, this does work safely and
      exactly).</para>
    </section>

    <section id="generatorguide-misc-usagecount">
      <title>Generators as <quote>usage counters</quote> for SPs to provide
      basic statistics</title>

      <para>Imagine you just built a fantastic new feature into your database
      with a stored procedure. Now you update your customer's systems and some
      time later you'd like to know if the users really
      <emphasis>use</emphasis> this feature and how often. Simple: make a
      special generator that only gets incremented in that SP and you're
      there... with the restriction that you can't know the number of
      transactions that were rolled back after or while your SP executed. So
      in this case you at least know how often users
      <emphasis>tried</emphasis> to use your SP :-)</para>

      <para>You could further refine this method by using two generators: One
      gets incremented at the very start of the SP, another at the very end
      just before the <database>EXIT</database>. This way you can count how
      many attempts to use the SP were succesful: if both generators have the
      same value, then none of the calls to the SP failed etc. Of course you
      then still don't know how many times the transaction(s) invoking your SP
      were actually committed.</para>
    </section>

    <section id="generatorguide-misc-rowcount">
      <title>Generators to simulate <quote>Select count(*)
      from...</quote></title>

      <para>There is the known problem with InterBase and Firebird that a
      <database>SELECT COUNT(*)</database> (with no Where clause) from a
      really large table can take quite a while to execute, since the server
      must count "by hand" how many rows there are in the table at the time of
      the request. In theory, you could easily solve this problem with
      generators:<itemizedlist spacing="compact">
          <listitem>
            <para>Create a special <quote>row counter</quote>
            generator;</para>
          </listitem>

          <listitem>
            <para>Make a Before Insert trigger that increments it;</para>
          </listitem>

          <listitem>
            <para>Make an After Delete trigger that decrements it.</para>
          </listitem>
        </itemizedlist></para>

      <para>This works beautifully and makes a <quote>full</quote> record
      count needless – just get the current generator value. I stressed the
      <quote><emphasis>in theory</emphasis></quote> here because the whole
      thing goes down the drain when any Insert statements fail, because as
      said those generators are <emphasis>beyond transaction
      control</emphasis>. Inserts can fail because of constraints (Unique Key
      violations, <database>NOT NULL</database> fields being
      <constant>NULL,</constant> etc.) or other metadata restrictions, or
      simply because the transaction that issued the Insert gets rolled back.
      You have no rows in the table and still your Insert counter
      climbs.</para>

      <para>So it depends – when you know the rough percentage of Inserts that
      fail (you can kinda get a <quote>feeling</quote> for this), and you're
      only interested in an <emphasis>estimation</emphasis> of the record
      count, then this method can be useful even though it's not exact. From
      time to time you can do a <quote>normal</quote> record count and set the
      generator to the exact value (<quote>re-synchronize</quote> the
      generator), so the error can be kept rather small.</para>

      <para>There are situations when customers can happily live with an info
      like <quote>there are <emphasis>about</emphasis> 2.3 million
      records</quote> instantly at a mouseclick, but would shoot you if they
      have to wait 10 minutes or more to see that there are precisely
      2.313.498.229 rows...</para>
    </section>

    <section id="generatorguide-misc-progresscount">
      <title>Generators to monitor and/or control long-running Stored
      Procedures</title>

      <para>When you have SPs that e.g. generate report outputs on large
      tables and/or complex joins, they can take quite a while to execute.
      Generators can be helpful here in two ways: they can provide you with a
      <quote>progress counter</quote> which you can poll periodically from the
      client side while the SP runs, and they can be used to stop it:</para>

      <programlisting>CREATE GENERATOR gen_spTestProgress;
CREATE GENERATOR gen_spTestStop;

set term ^;

CREATE PROCEDURE spTest (...)
AS
BEGIN
  (...)
  for select &lt;lots of data taking lots of time&gt;
  do begin
    GEN_ID(gen_spTestProgress,1);

    IF (GEN_ID(gen_spTestStop,0)&gt;0) THEN Exit;

    (...normal processing here...)
  end
END^</programlisting>

      <para>Just a rough sketch, but you should get the idea. From the client,
      you can do a GEN_ID(gen_spTestProgress,0) asynchronously to the actual
      row fetching (e.g. in a different thread), to see how many rows were
      processed, and display the value in some sort of progress window. And
      you can do a GEN_ID(gen_spTestStop,1) to cancel the SP at any time from
      the <quote>outside</quote>.</para>

      <para>Although this can be very handy, it has a strong limitation:
      <emphasis>it's not multi-user safe</emphasis>. If the SP would run
      simultaneously in two transactions, they would mess up the progress
      generator – they would both increment the same counter at the same time
      so the result would be useless. Even worse, incrementing the stop
      generator would immediately stop the SP in <emphasis>both</emphasis>
      transactions. But for e.g. monthly reports that are generated by a
      single module run in batch mode, this can be acceptable – as usual, it
      depends on your needs.</para>

      <para>If you want to use this technique and allow
      <emphasis>users</emphasis> to trigger the SP at any time, you must make
      sure by other means that the SP can not be run twice. Thinking about
      this, I had the idea to use another generator for that: let's call this
      one gen_spTestLocked (assuming the initial value of 0 of course):</para>

      <programlisting>CREATE GENERATOR gen_spTestProgress;
CREATE GENERATOR gen_spTestStop;
CREATE GENERATOR gen_spTestLocked;

set term ^;

CREATE PROCEDURE spTest (...)
AS
DECLARE VARIABLE lockcount INTEGER;
BEGIN
  lockcount = GEN_ID(gen_spTestLocked,1); 
    /* very first step: increment the locking generator */

  if (lockcount=1) then /* _we_ got the lock, continue */
  begin
    (..."normal" procedure body here...)
  end

  lockcount = GEN_ID(gen_spTestLocked,-1); /* undo the increment */

  /* make sure the gen is reset at the very end even when an exception
     happens inside the <quote>normal</quote> procedure body: */
     
  WHEN ANY DO
    lockcount = GEN_ID(spTestLocked,-1); /* undo the increment */
  exit;
END^</programlisting>

      <para><emphasis role="bold">Note:</emphasis> I'm not yet 100% sure this
      is absolutely multi-user safe, but it looks rock solid – as long as no
      <database>EXIT</database> occurs in the <database>normal</database>
      procedure body, for then the SP would stop and quit, leaving the
      generator incremented. The <database>WHEN ANY</database> clause handles
      exceptions, but not normal <database>EXIT</database>s. Then you'd have
      to decrement it by hand – but you could decrement the generator just
      before the <database>EXIT</database> to avoid this. Given the right
      precautions, I can't make up any situation where this mechanism could
      fail... If you can – let us know!</para>
    </section>
  </section>

  <appendix id="generatorguide-dochist">
    <title>Document history</title>

    <para>The exact file history is recorded in the <filename
    class="directory">manual</filename> module in our CVS tree; see <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>4 Apr 2006</date>

          <authorinitials>FI</authorinitials>

          <revdescription>
            <para>First edition.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>7 May 2006</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Added SEQUENCE syntax and other Firebird 2 info.</para>

            <para>Added information on: the importance of client dialects; the
            SHOW GENERATOR statement and friends; dropping generators and
            packing generator space.</para>

            <para>Edited and extended the following sections more or less
            heavily: <citetitle>Where are generators stored?</citetitle>,
            <citetitle>What is the maximum value of a generator?</citetitle>,
            <citetitle>How many generators...?</citetitle>, <citetitle>Use of
            generator statements</citetitle>.</para>

            <para>Further editing, additions and corrections to various
            sections, mainly in the first half of the document. Light editing
            in second half (starting at <citetitle>Using generators to create
            unique row IDs</citetitle>).</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="generatorguide-license">
    <title>License notice</title>

    <para>The contents of this Documentation are subject to the Public
    Documentation License Version 1.0 (the <quote>License</quote>); you may
    only use this Documentation if you comply with the terms of this License.
    Copies of the License are available at <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) and <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>The Original Documentation is titled <citetitle>Firebird Generator
    Guide</citetitle>.</para>

    <para>The Initial Writer of the Original Documentation is: Frank
    Ingermann.</para>

    <para>Copyright (C) 2006. All Rights Reserved. Initial Writer contact:
    frank at fingerman dot de.</para>

    <para>Contributor: Paul Vinkenoog – see <link
    linkend="generatorguide-dochist">document history</link>.</para>

    <para>Portions created by Paul Vinkenoog are Copyright (C) 2006. All
    Rights Reserved. Contributor contact: paul at vinkenoog dot nl.</para>
  </appendix>
</article>