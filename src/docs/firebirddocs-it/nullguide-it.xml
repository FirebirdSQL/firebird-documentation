<?xml version="1.0" encoding="UTF-8"?>
<!-- For standalone validation, uncomment the following DOCTYPE declaration. -->
<!--
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
-->
<article id="nullguide-it">
  <articleinfo>
    <title>Guida sull'uso di NULL nel linguaggio SQL di Firebird</title>

    <subtitle>Uso e malintesi su <constant>NULL</constant> in
    Firebird</subtitle>

    <author>
      <firstname>Paul</firstname>

      <surname>Vinkenoog</surname>
    </author>

    <edition>31 marzo 2007 - Versione italiana 1.0.1-it</edition>

    <othercredit class="translator">
      <firstname>Umberto</firstname>

      <surname>Masotti</surname>

      <contrib>Traduzione in italiano</contrib>
    </othercredit>
  </articleinfo>

  <section id="nullguide-intro-it">
    <title><indexterm>
        <primary>NULL</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>Che cosa è?</secondary>
      </indexterm>Che cosa è NULL?</title>

    <para>Un giorno sì e l'altro pure, nella mailing list di supporto di
    Firebird, vengono fatte domande relative a <quote>strane cose</quote> che
    succedono con i NULL in Firebird SQL. Il concetto sembra difficile da
    comprendere, in parte a causa del nome che suggerisce <quote>nulla</quote>
    o <quote>niente</quote>, e che quindi apparentemente non dovrebbe creare
    problemi se aggiunto ad un numero o concatenato ad una stringa. In realtà,
    fare quelle cose da' come risultato dell'espressione
    <constant>NULL</constant>.</para>

    <para>Questo articolo approfondisce il funzionamento di
    <constant>NULL</constant> in Firebird SQL, evidenziando alcuni errori
    comuni e mostra come si possono gestire correttamente le espressioni che
    contengono <constant>NULL</constant> o che possono valere
    <constant>NULL</constant>.</para>

    <para>Per avere un riferimento veloce, giusto per rinfrescarsi la memoria,
    si può saltare a piè pari direttamente al <link
    linkend="nullguide-summary-it">riassunto</link> (che è davvero sintetico e
    stringato).</para>

    <bridgehead renderas="sect3">Allora, che cosa è?</bridgehead>

    <para>In SQL, NULL non è un valore. È uno <emphasis>stato</emphasis> che
    indica che il valore di un oggetto è sconosciuto o inesistente. Non è
    zero, nè il carattere spazio e neppure una stringa vuota e, sopratutto,
    non si comporta come nessuno dei tre. Poche cose creano altrettanta
    confusione in SQL come il <constant>NULL</constant>, eppure il suo
    funzionamento non dovrebbe essere così difficile da capire dal momento che
    basta fissarsi su questa semplice definizione: <constant>NULL</constant>
    significa <emphasis>sconosciuto</emphasis>.</para>

    <para>Lo ripeto:</para>

    <blockquote>
      <para><emphasis role="bold"><constant>NULL</constant> significa
      SCONOSCIUTO</emphasis></para>
    </blockquote>

    <para>Questo fatto va tenuto bene in mente leggendo il resto
    dell'articolo, così molti dei comportamenti apparentemente illogici che si
    hanno con <constant>NULL</constant> immediatamente si spiegheranno in modo
    automatico.</para>

    <para><note>
        <para>Alcune parti ed esempi di questa guida sono state prese dalla
        <citetitle>Firebird Quick Start Guide</citetitle>, pubblicata
        originariamente dalla IBPhoenix, ora parte del progetto
        Firebird.</para>
      </note></para>
  </section>

  <section id="nullguide-langelem-it">
    <title>Come Firebird supporta il NULL nel linguaggio SQL</title>

    <para>Solo pochi elementi del linguaggio sono stati appositamente
    progettati per determinare un risultato non ambiguo con il NULL; si
    intende <quote>non ambiguo</quote> nel senso che vengono prese particolari
    azioni specifiche o risulta un valore che non è NULL. Questi casi sono
    mostrati nei seguenti paragrafi.</para>

    <section id="nullguide-langelem-notnull">
      <title><indexterm>
          <primary>NOT NULL</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>impedire</secondary>
        </indexterm>Impedire il <constant>NULL</constant></title>

      <para>Nella definizione di una colonna o di un dominio, si può
      specificare che possono essere ammessi solo valori diversi dal NULL,
      aggiungendo la clausola <database>NOT NULL</database> alla
      definizione:</para>

      <blockquote>
        <programlisting>create table Tabella ( i int <emphasis role="bold">not null</emphasis> )</programlisting>

        <programlisting>create domain DComune as varchar( 32 ) <emphasis
            role="bold">not null</emphasis></programlisting>
      </blockquote>

      <para>Particlare attenzione andrebbe presa aggiungendo <database>un
      campo NOT NULL</database> ad una tabella già esistente che contiene
      delle registrazioni. Questa operazione verrà discussa in dettaglio nella
      sezione <link linkend="nullguide-alter-pop-tables"><citetitle>Modificare
      le tabelle piene</citetitle></link>.</para>
    </section>

    <section>
      <title><indexterm>
          <primary>IS [NOT] NULL</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>test per</secondary>
        </indexterm><indexterm>
          <primary>Testare per NULL</primary>
        </indexterm>Controllare un campo per <constant>NULL</constant></title>

      <para>Per sapere se una variabile, un campo, o un'ntera espressione è
      NULL, è necessario usare la sintassi seguente:</para>

      <blockquote>
        <para><replaceable>&lt;expression&gt;</replaceable> <database>IS [NOT]
        NULL</database></para>
      </blockquote>

      <para>Esempi:</para>

      <blockquote>
        <programlisting>if ( QuestoCampo <emphasis role="bold">is null</emphasis> ) then QuestaStringa = 'Nonso'</programlisting>

        <programlisting>select * from Alunni where NumeroTelefono <emphasis
            role="bold">is not null</emphasis></programlisting>

        <programlisting>select * from Alunni where not ( NumeroTelefono <emphasis
            role="bold">is null</emphasis> )
/* fa la stessa cosa dell'esempio precedente */</programlisting>

        <programlisting>update NumeriVari set Totale = A + B + C where A + B + C <emphasis
            role="bold">is not null</emphasis></programlisting>

        <programlisting>delete from Agendina where NumTelefono <emphasis
            role="bold">is null</emphasis></programlisting>
      </blockquote>

      <para><emphasis role="bold">NON</emphasis> usare assolutamente
      <quote>... = <constant>NULL</constant></quote> per verificare se
      l'espressione è NULL. Questa sintassi è illegale nelle versioni di
      Firebird fino alla 1.5.n, e dà risultato sbagliato (o meglio inatteso)
      in Firebird 2 e successivi: riporta NULL qualsiasi sia l'espressione da
      confrontare. Questo è per progetto ed in tal senso non è
      <emphasis>proprio</emphasis> sbagliato – non dà semplicemente il
      risultato sperato. Ovviamente lo stesso vale per <quote>... &lt;&gt;
      <constant>NULL</constant></quote>, pertanto è meglio non usare neanche
      questa espressione: v<database>a usato invece IS NOT
      NULL</database>.</para>

      <para><database>IS NULL</database> e <database>IS NOT NULL</database>
      riportano sempre <constant>true</constant> oppure
      <constant>false</constant>; non riportano mai
      <constant>NULL</constant>.</para>
    </section>

    <section id="nullguide-langelem-assign">
      <title><indexterm>
          <primary>NULL</primary>

          <secondary>assegnare</secondary>
        </indexterm><indexterm>
          <primary>Assegnare NULL</primary>
        </indexterm>Assegnare <constant>NULL</constant></title>

      <para>Per assegnare ad un campo o ad una variabile i<constant>l
      NULL</constant> si usa l'operatore <quote>=</quote>, come per tutti gli
      altri valori. Si può utilizzare il <constant>NULL</constant> anche nelle
      liste della clausola <database>INSERT</database>:</para>

      <blockquote>
        <programlisting>if ( Stringaccia = 'Nonso' ) then Campo = null</programlisting>

        <programlisting>update Patate set Tuberi = null where Importo &lt; 0</programlisting>

        <programlisting>insert into TabellaX values ( 3, '8-5-2004', NULL, 'Che cosa?' )</programlisting>
      </blockquote>

      <para>Ricordarsi:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>Non si può e non si deve usare <emphasis>l'operatore di
          comparazione</emphasis> <quote>=</quote> per
          <emphasis>controllare</emphasis> se qualcosa <emphasis>è</emphasis>
          <constant>NULL</constant>...</para>
        </listitem>

        <listitem>
          <para>...ma si può – e spesso si deve – usare <emphasis>l'operatore
          di assegnazione</emphasis> <quote>=</quote> per
          <emphasis>impostare</emphasis> qualcosa <emphasis>a</emphasis>
          <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="nullguide-langelem-distinct">
      <title><indexterm>
          <primary>DISTINCT</primary>

          <secondary>testare la diversità</secondary>
        </indexterm><indexterm>
          <primary>IS [NOT] DISTINCT FROM</primary>
        </indexterm>Controllare la diversità (Firebird 2+)</title>

      <para>Solo da Firebird 2 e successivi, su può paragonare la diversità
      anche nulla di due espressioni qualsiasi con <quote><database>IS [NOT]
      DISTINCT FROM</database></quote>:</para>

      <blockquote>
        <para><programlisting>if ( A <emphasis role="bold">is distinct from</emphasis> B ) then...</programlisting><programlisting>if ( Cliente1 <emphasis
              role="bold">is not distinct from</emphasis> Cliente2 ) then...</programlisting></para>
      </blockquote>

      <para>I campi, le variabili ed altre espressioni sono
      considerate:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>distinte, usando DISTINCT</database>, se hanno
          valori diversi o uno dei valori è <constant>NULL</constant> ma non
          l'altro;</para>
        </listitem>

        <listitem>
          <para><database>uguali, usando NOT DISTINCT</database>, se hanno lo
          stesso valore oppure se sono entrambe
          <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>

      <para><database>[NOT] DISTINCT</database> riporta sempre
      <constant>true</constant> oppure <constant>false</constant>, mai NULL o
      qualsiasi altra cosa.</para>

      <para>Con le versioni precedenti di Firebird bisognava scrivere codice
      più complesso per ottenere lo stesso risultato. Lo vedremo in
      seguito.</para>
    </section>

    <section id="nullguide-langelem-literal">
      <title><indexterm>
          <primary>NULL</primary>

          <secondary>costante letterale</secondary>
        </indexterm>La costante letterale <constant>NULL</constant></title>

      <para>La possibilità di usare costanti letterali <literal>NULL</literal>
      dipende dalla versione di Firebird utilizzata.</para>

      <section>
        <title>Fino a Firebird 1.5 compreso</title>

        <para>In Firebird 1.5 e precedenti si può usare la parola letterale
        <quote><literal>NULL</literal></quote> solo in alcune situazioni, in
        particolare quelle descritte nei precedenti paragrafi più poche altre
        come <quote>cast( <constant>NULL</constant> as
        <replaceable>&lt;datatype&gt;</replaceable> )</quote> e <quote>select
        <constant>NULL</constant> from Tabella</quote>.</para>

        <para>In tutte le altre circostanze, Firebird dirà che
        <literal>NULL</literal> è un oggetto sconosciuto (<literal>unknown
        token</literal>). Se si <emphasis>deve</emphasis> usare
        <constant>NULL</constant> in tali contesti, bisogna ricorrere a
        trucchetti del tipo <quote>cast( <constant>NULL</constant> as int
        )</quote>, oppure usare un campo o una variabile che è notoriamente
        <constant>NULL</constant>.</para>
      </section>

      <section>
        <title>Firebird 2.0 and up</title>

        <para>Firebird 2 permette l'uso di costanti letterali
        <constant>NULL</constant> in ogni contesto in cui può essere ammesso
        un normale valore. Si può, ad esempio, incledere
        <constant>NULL</constant> in una lista della clausola
        <database>IN()</database>, scrivere espressioni come <quote>if ( Campo
        = <constant>NULL</constant> ) then...</quote>, e così via. Tuttavia,
        come regola generale <emphasis role="bold">non si dovrebbe</emphasis>
        fare uso di queste nuove possibilità! In quasi tutte le situazioni
        pensabili, un tale uso del <constant>NULL</constant> è segno di una
        progettazione SQL qualitativamente scarsa literals e porta a risultati
        <constant>NULL</constant> dove invece si desidererebbe
        <constant>true</constant> oppure <constant>false</constant>. In questo
        senso la precedente condotta, più restrittiva, è migliore, sebbene si
        possa sempre aggirarla con forzature tipo <code>cast</code> ecc. ma
        questo almeno comporta che sia necessario fare certi passi
        deliberatamente.</para>
      </section>
    </section>
  </section>

  <section id="nullguide-null-in-exps-it">
    <title><indexterm>
        <primary>NULL</primary>

        <secondary>in operations</secondary>
      </indexterm><constant>NULL</constant> nelle espressioni</title>

    <para>Come molti di noi hanno scoperto con sconforto,
    <constant>NULL</constant> è contagioso: usato in una espressione numerica,
    di stringhe, o data/ora, il risultato sarà sempre e comunque
    <constant>NULL</constant>. Usandolo invece in una operazione logica, il
    risultato dipende dal tipo dell'operazione e degli altri valori
    coinvolti.</para>

    <para>Notare, inoltre, che nelle versioni di Firebird precedenti alla 2.0
    è abbastanza illegale utilizzare <constant>NULL</constant> direttamente
    nelle operazioni o nei confronti. Dovunque si vede
    <constant>NULL</constant> nelle seguenti espressioni, va letto come
    <quote>un campo, una variabile o altra espressione che vale
    <constant>NULL</constant></quote>. In Firebird 2 e successivi questa
    espressione può anche essere un <constant>NULL</constant>
    letterale.</para>

    <section id="nullguide-expr-returning-null-it">
      <title><indexterm>
          <primary>Operazioni matematiche</primary>
        </indexterm><indexterm>
          <primary>Operazioni su stringhe</primary>
        </indexterm><indexterm>
          <primary>Operazioni di confronto</primary>
        </indexterm>Operazioni matematiche e con stringhe</title>

      <para>Le espressioni nella seguente lista riportano <emphasis>sempre e
      comunque</emphasis> tutte <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal>1 + 2 + 3 +
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>5 * <constant>NULL</constant> - 7</literal></para>
        </listitem>

        <listitem>
          <para><literal>'Casa ' || 'dolce ' ||
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>IlMioCampo =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>IlMioCampo &lt;&gt;
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>
      </itemizedlist>

      <para>Se si ha proprio difficoltà a capire perchè, basta rammentare che
      <constant>NULL</constant> significa <quote>sconosciuto</quote>.
      Guardiamo ora nella seguente tabella, dove sono spiegate caso per caso
      tutte le precedenti espressioni. In questa tabella non usiamo
      <constant>NULL</constant> nelle espressioni (come già accennato, questo
      è spesso illegale); invece usiamo due entità, diciamo A e B, che sono
      entrambe <constant>NULL</constant>. A e B possono essere campi,
      variabili, od intere sottoespressioni, le quali, fintantochè sono di
      valore <constant>NULL</constant>, si comportano sempre allo stesso modo
      nelle espressioni mostrate.</para>

      <table>
        <title>Operazioni sulle entità null A and B</title>

        <tgroup cols="3">
          <colspec colname="colExpr" colnum="1" colwidth="4*" />

          <colspec colname="colResult" colnum="2" colwidth="*" />

          <colspec align="left" colname="colReason" colnum="3" colwidth="6*" />

          <thead>
            <row>
              <entry align="center">Se A e B sono NULL, allora:</entry>

              <entry align="center">vale</entry>

              <entry align="center">per questo motivo</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>1 + 2 + 3 + A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Se A è sconosciuto, allora anche 6 + A è
              sconosciuto.</entry>
            </row>

            <row>
              <entry><literal>5 * A - 7</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Se A è sconosciuto, allora lo è anche 5 * A. Sottrargli 7
              finisce per dare un altra quantità sconosciuta.</entry>
            </row>

            <row>
              <entry><literal>'Casa ' || 'dolce ' || A </literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Se A è sconosciuto, 'Casa dolce ' || A è
              sconosciuto.</entry>
            </row>

            <row>
              <entry><literal>MioCampo = A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Se A è sconosciuto, non si può dire se MioCampo ha lo
              stesso valore...</entry>
            </row>

            <row>
              <entry><literal>MioCampo &lt;&gt; A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>...ma non si può neanche dire se MioCampo ha un
              valore<emphasis> differente</emphasis>!</entry>
            </row>

            <row>
              <entry><literal>A = B</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Se A e B sono sconosciuti, è impossibile sapere se sono
              uguali.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <indexterm>
        <primary>BETWEEN</primary>
      </indexterm>

      <indexterm>
        <primary>STARTING WITH</primary>
      </indexterm>

      <indexterm>
        <primary>LIKE</primary>
      </indexterm>

      <indexterm>
        <primary>CONTAINING</primary>
      </indexterm>

      <para>Questa è la lista completa degli operatori matematici e su
      stringhe che riportano <constant>NULL</constant> se almeno uno degli
      operandi è <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal>+</literal>, <literal>
          </literal><literal>-</literal>, <literal> *</literal>, <literal>
          /</literal>, <literal> </literal>e <literal>
          </literal><literal>%</literal></para>
        </listitem>

        <listitem>
          <para><literal>!=</literal>, <literal>
          </literal><literal>~=</literal>, <literal> </literal>e<literal> ^=
          </literal>(sinonimo di<literal> &lt;&gt;</literal>)</para>
        </listitem>

        <listitem>
          <para><literal>&lt;</literal>, <literal>
          </literal><literal>&lt;=</literal>, <literal>
          </literal><literal>&gt;</literal>, <literal> </literal>e <literal>
          </literal><literal>&gt;=</literal></para>
        </listitem>

        <listitem>
          <para><literal>!&lt;</literal>, <literal>
          </literal><literal>~&lt;</literal>, <literal> </literal>e <literal>
          ^&lt; </literal>(bassa precedenza, sinonimo di<literal>
          &gt;=</literal>)</para>
        </listitem>

        <listitem>
          <para><literal>!&gt;</literal>, <literal>
          </literal><literal>~&gt;</literal>, <literal> </literal>e <literal>
          ^&gt; </literal>(bassa precedenza, sinonimo di<literal>
          &lt;=</literal>)</para>
        </listitem>

        <listitem>
          <para><literal>||</literal></para>
        </listitem>

        <listitem>
          <para><database>[NOT] BETWEEN</database></para>
        </listitem>

        <listitem>
          <para><database>[NOT] STARTING WITH</database></para>
        </listitem>

        <listitem>
          <para><database>[NOT] LIKE</database></para>
        </listitem>

        <listitem>
          <para><database>[NOT] CONTAINING</database></para>
        </listitem>
      </itemizedlist>

      <!--'==' non è supportato in pratica, sebbene il manuale EmbedSQL dica diversamente. Forse lo è stato in IB6?-->

      <para>Ogni spiegazione segue lo stesso schema: se A è sconosciuto, non
      si può dire che sia maggiore di B; se la stringa S1 è sconosciuta, non
      si può dire che contiene la stringa S2; e così via.</para>

      <para>Usare <database>LIKE</database> con carattere di escape
      <constant>NULL</constant> fa in modo da mandare in crash il server nelle
      versioni Firebird fino alla 1.5 inclusa. Questo problema è stato risolto
      nella versione 1.5.1. Da quella versione in poi un tale comando riporta
      un insieme di record vuoto.</para>
    </section>

    <section id="nullguide-boolean-expressions-it">
      <title><indexterm>
          <primary>NULL</primary>

          <secondary>nelle operazioni booleane</secondary>
        </indexterm><indexterm>
          <primary>Operazioni booleane</primary>
        </indexterm><indexterm>
          <primary>True</primary>
        </indexterm><indexterm>
          <primary>False</primary>
        </indexterm><indexterm>
          <primary>operatore NOT</primary>
        </indexterm><indexterm>
          <primary>operatore AND</primary>
        </indexterm><indexterm>
          <primary>operatore OR</primary>
        </indexterm><constant>NULL</constant> nelle operazioni logiche</title>

      <note>
        <para>Nel seguito indicheremo spesso con la coppia di termini inglesi
        <constant>true</constant> e <constant>false</constant>, usate
        abitualmente in informatica, le relativa coppia di condizioni logiche
        <quote>vero</quote> e <quote>falso</quote>.</para>
      </note>

      <para>Tutti gli operatori fin qui visti riportano
      <constant>NULL</constant> se qualche operando è
      <constant>NULL</constant>. Con gli operatori logici booleani, le cose
      sono un po' più complicate:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal>not <constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> or
          <constant>false</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> or
          <constant>true</constant> =
          <constant>true</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> or
          <constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> and
          <constant>false</constant> =
          <constant>false</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> and
          <constant>true</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> and
          <constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>
      </itemizedlist>

      <para>Firebird SQL non ha un tipo di dato boolean; nè
      <constant>true</constant> o <constant>false</constant> sono costanti
      definite. Nella colonna a sinistra della tabella successiva,
      <quote><literal>true</literal></quote> e
      <quote><literal>false</literal></quote> rappresentano delle espressioni
      con campi, variabili, ecc.., che valgono <constant>true</constant>
      oppure <constant>false</constant> (ad esempio: 1=1 è sempre
      <quote>vero</quote>, 1=0 è sempre <quote>falso</quote>).</para>

      <table>
        <title>Operazioni logiche sull'entità di valore null A</title>

        <tgroup cols="3">
          <colspec colname="colExpr" colnum="1" colwidth="4*" />

          <colspec colname="colResult" colnum="2" colwidth="*" />

          <colspec align="left" colname="colReason" colnum="3" colwidth="6*" />

          <thead>
            <row>
              <entry align="center">Se A è <constant>NULL</constant>,
              allora</entry>

              <entry align="center">vale</entry>

              <entry align="center">per questo motivo</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>not (A)</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Se A è sconosciuto, è sconosciuto anche il suo inverso (o
              la sua negazione).</entry>
            </row>

            <row>
              <entry><literal>A or (false)</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A or
              <constant>false</constant></literal></quote> ha sempre il valore
              di A - che è sconosciuto.</entry>
            </row>

            <row>
              <entry><literal>A or (true)</literal></entry>

              <entry><literal><constant>true</constant></literal></entry>

              <entry><quote><literal>A or
              <constant>true</constant></literal></quote> è sempre
              <constant>true</constant>, perchè il valore di A non ha
              importanza.</entry>
            </row>

            <row>
              <entry><literal>A or A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A or A</literal></quote> è sempre A, che
              è sconosciuto, cioè <constant>NULL</constant>.</entry>
            </row>

            <row>
              <entry><literal>A and (false)</literal></entry>

              <entry><literal><constant>false</constant></literal></entry>

              <entry><quote><literal>A and
              <constant>false</constant></literal></quote> è sempre falso,
              perchè il valore di A non conta.</entry>
            </row>

            <row>
              <entry><literal>A and (true)</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A and
              <constant>true</constant></literal></quote> ha sempre il valore
              di A - che è sconosciuto.</entry>
            </row>

            <row>
              <entry><literal>A and A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A and A</literal></quote> è sempre A, che
              è sconosciuto, cioè <constant>NULL</constant>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Tutti questi risultati sono in accordo con la logica booleana. Il
      fatto che non si ha la necessità di conoscere il valore di X per
      calcolare <quote><literal>X or
      <constant>true</constant></literal></quote> e <quote><literal>X and
      <constant>false</constant></literal></quote> è alla base di una
      caratteristica nota in molti linguaggi di programmazione col nome di
      <literal>short-circuit boolean evaluation</literal> (valutazione logica
      cortocircuitata).</para>

      <para>I risultati precedenti possono essere generalizzati come segue per
      le espressioni con un tipo di operatore binario booleano
      (<literal>and</literal> | <literal>or</literal>) e qualsiasi numero di
      operandi:</para>

      <variablelist spacing="compact">
        <varlistentry>
          <term><indexterm>
              <primary>Disgiunzioni</primary>
            </indexterm><indexterm>
              <primary>NULL</primary>

              <secondary>nelle disgiunzioni</secondary>
            </indexterm>Disgiunzioni (<quote>A or B or C or D or
          ...</quote>)</term>

          <listitem>
            <orderedlist spacing="compact">
              <listitem>
                <para>Se almeno un operando è <constant>true</constant>, il
                risultato è <constant>true</constant>.</para>
              </listitem>

              <listitem>
                <para>Altrimenti, se almeno un operando è
                <constant>NULL</constant>, il risultato è
                <constant>NULL</constant>.</para>
              </listitem>

              <listitem>
                <para>Altrimenti (cioè se tutti gli operandi sono
                <constant>false</constant>) il risultato è
                <constant>false</constant>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><indexterm>
              <primary>Congiunzioni</primary>
            </indexterm><indexterm>
              <primary>NULL</primary>

              <secondary>nelle congiunzioni</secondary>
            </indexterm>Congiunzioni (<quote>A and B and C and D and
          ...</quote>)</term>

          <listitem>
            <orderedlist spacing="compact">
              <listitem>
                <para>Se almeno un operando è <constant>false</constant>, il
                risultato è <constant>false</constant>.</para>
              </listitem>

              <listitem>
                <para>Altrimenti, se almeno un operando è
                <constant>NULL</constant>, il resto è
                <constant>NULL</constant>.</para>
              </listitem>

              <listitem>
                <para>Altrimenti (cioè se tutti gli operandi sono
                <constant>true</constant>) il risultato è
                <constant>true</constant>.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </varlistentry>
      </variablelist>

      <indexterm>
        <primary>True</primary>

        <secondary>sovrasta NULL</secondary>
      </indexterm>

      <indexterm>
        <primary>False</primary>

        <secondary>sovrasta NULL</secondary>
      </indexterm>

      <para>O, più brevemente:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><constant>TRUE</constant> sovrasta <constant>NULL</constant>
          nelle disgiunzioni (operazioni OR);</para>
        </listitem>

        <listitem>
          <para><constant>FALSE</constant> sovrasta <constant>NULL</constant>
          nelle congiunzioni (operazioni AND);</para>
        </listitem>

        <listitem>
          <para>In tutti gli altri casi, vince
          <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>

      <para>Se si fatica nel ricordare chi sovrasta che cosa in che
      operazione, meglio memorizzare la regoletta della seconda lettera:
      t<emphasis role="bold">R</emphasis>ue vince con o<emphasis
      role="bold">R</emphasis> — f<emphasis role="bold">A</emphasis>lse con
      <emphasis role="bold">A</emphasis>nd.</para>
    </section>

    <section id="nullguide-more-logic-it">
      <title>Ancora logica (anche se non sembra)</title>

      <para>I risultati determinati dai cortocircuiti logici booleani di cui
      sopra possono suggerire le seguenti idee:</para>

      <itemizedlist>
        <listitem>
          <para>0 per <varname>x</varname> è uguale a 0 per qualsiasi
          <varname>x</varname>. Pertanto, anche se <varname>x</varname> è
          sconosciuto, <literal>0 * x</literal> vale 0. (N.B.: questo solo se
          il tipo di dato di <varname>x</varname> può contenere solo numeri,
          non <constant>NaN</constant> o infiniti.)</para>
        </listitem>

        <listitem>
          <para>La stringa vuota è in ordine lessicografico prima di ogni
          altra stringa. Pertanto, <literal>S &gt;= ''</literal> è vero per
          qualsiasi valore di S.</para>
        </listitem>

        <listitem>
          <para>Ogni valore è uguale a sé stesso, sia conosciuto che
          incognito. Così, sebbene sia giustificato che <literal>A =
          B</literal> sia <constant>NULL</constant> quando A e B sono entità
          diverse di valore <constant>NULL</constant>, invece <literal>A =
          A</literal> dovrebbe sempre riportare <constant>true</constant>,
          anche quando A è <constant>NULL</constant>. Lo stesso vale per
          <literal>A &lt;= A</literal> e <literal>A &gt;= A</literal>.</para>

          <para>Analogicamente, <literal>A &lt;&gt; A</literal> dovrebbe
          sempre essere <constant>false</constant> così come <literal>A &lt;
          A</literal> e <literal>A &gt; A</literal>.</para>
        </listitem>

        <listitem>
          <para>Ogni stringa <emphasis>contiene</emphasis> sé stessa,
          <emphasis>comincia con</emphasis> sé stessa ed è
          <emphasis>come</emphasis> sé stessa. Così, <quote><literal>S
          CONTAINING S</literal></quote>, <quote><literal>S STARTING WITH
          S</literal></quote> e <quote><literal>S LIKE S</literal></quote>
          dovrebbero sempre essere, o meglio valere,
          <constant>true</constant>.</para>
        </listitem>
      </itemizedlist>

      <para>Ebbene, come viene implementato questo in Firebird SQL? È mio
      dovere informare che, contrariamente al buon senso e all'analogia con i
      risultati dell'algebra booleana mostrati sopra, tutte le seguenti
      espressioni valgono <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal><constant>0 * NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> &gt;= ''</literal><literal>
          </literal> e <literal> </literal><literal>'' &lt;=
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>A = A</literal>, <literal> </literal><literal>A &lt;=
          A</literal><literal> </literal> e <literal> </literal><literal>A
          &gt;= A</literal></para>
        </listitem>

        <listitem>
          <para><literal>A &lt;&gt; A</literal>, <literal>
          </literal><literal>A &lt; A</literal><literal> </literal> e
          <literal> </literal><literal>A &gt; A</literal></para>
        </listitem>

        <listitem>
          <para><literal>S CONTAINING S</literal>, <literal>
          </literal><literal>S STARTING WITH S</literal><literal> </literal> e
          <literal> </literal><literal>S LIKE S</literal></para>
        </listitem>
      </itemizedlist>

      <para>Il fatto è che non vanno confusi gli operatori logici (quali
      <literal>OR</literal> e <literal>AND</literal>) con gli operatori quali
      la moltiplicazione ed il confronto che sono operatori aritmetici che
      hanno risultati rispettivamente numerici o booleani.</para>
    </section>
  </section>

  <section id="nullguide-intfunc-direct">
    <title>Funzioni interne ed altre direttive</title>

    <section id="nullguide-expr-internfuncs">
      <title><indexterm>
          <primary>Funzioni</primary>

          <secondary>interne</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle funzioni interne</secondary>
        </indexterm>Funzioni interne</title>

      <para>Le seguenti funzioni integrate riportano <constant>NULL</constant>
      se almeno uno degli argomenti è <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>CAST()</database></para>
        </listitem>

        <listitem>
          <para><database>EXTRACT()</database></para>
        </listitem>

        <listitem>
          <para><database>GEN_ID()</database></para>
        </listitem>

        <listitem>
          <para><database>SUBSTRING()</database></para>
        </listitem>

        <listitem>
          <para><database>UPPER()</database></para>
        </listitem>

        <listitem>
          <para><database>LOWER()</database></para>
        </listitem>

        <listitem>
          <para><database>BIT_LENGTH()</database></para>
        </listitem>

        <listitem>
          <para><database>CHAR[ACTER]_LENGTH()</database></para>
        </listitem>

        <listitem>
          <para><database>OCTET_LENGTH()</database></para>
        </listitem>

        <listitem>
          <para><database>TRIM()</database></para>
        </listitem>
      </itemizedlist>

      <note>
        <title>Nota bene</title>

        <itemizedlist>
          <listitem>
            <para>In Firebird 1.0.0, <database>EXTRACT</database> da un dato
            <constant>NULL</constant> fa crollare il server the server.
            Risolto nella 1.0.2.</para>
          </listitem>

          <listitem>
            <para>Se il primo argomento di <database>GEN_ID</database> è un
            nome valido di generatore ed il secondo argomento è
            <constant>NULL</constant>, il generatore mantiene il valore
            corrente.</para>
          </listitem>

          <listitem>
            <para>In versioni fino alla 2.0 inclusa, <database>i risultati di
            SUBSTRING</database> sono talvolta riportati come <quote>false
            stringhe vuote</quote>. Queste stringhe di fatto sono
            <constant>NULL</constant>, ma sono descritte dal server come non
            annullabili. Pertanto molti programmi le mostrano come stringhe
            vuote. Vedere la <link linkend="nullguide-bugs-substring">lista
            dei problemi</link> per una descrizione più approfondita.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>

    <section id="nullguide-expr-first-skip-rows">
      <title><indexterm>
          <primary>Direttive</primary>
        </indexterm><indexterm>
          <primary>FIRST</primary>
        </indexterm><indexterm>
          <primary>SKIP</primary>
        </indexterm><indexterm>
          <primary>ROWS</primary>
        </indexterm><database>FIRST</database>, <database>SKIP</database> e
      <database>ROWS</database></title>

      <para>Le due direttive seguent <emphasis role="bold"><quote>mandano in
      crash</quote></emphasis> un server Firebird 1.5.n o precedente se gli
      viene passato un argomento a <constant>NULL</constant>. In Firebird 2,
      invece, trattano il <constant>NULL</constant> come se fosse il valore
      0:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>FIRST</database></para>
        </listitem>

        <listitem>
          <para><database>SKIP</database></para>
        </listitem>
      </itemizedlist>

      <para>Questa nuova direttiva di Firebird 2 non riporta righe (cioè il
      result set è vuoto) se un qualsiasi argomento è
      <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>ROWS</database></para>
        </listitem>
      </itemizedlist>

      <para>Nota a latere: <database>ROWS</database> è conforme allo standard
      SQL. Nel codice è consigliato usare <database>ROWS</database>, e non
      <database>FIRST</database> e <database>SKIP</database>.</para>
    </section>
  </section>

  <section id="nullguide-predicates">
    <title><indexterm>
        <primary>Predicati</primary>
      </indexterm>I predicati</title>

    <para>I predicati sono frasi con oggetti che riportano un valore booleano:
    <constant>true</constant>, <constant>false</constant> oppure
    <constant>sconosciuto</constant> (= <constant>NULL</constant>). Nella
    programmazione si possono trovare i predicati nelle posizioni in cui
    bisogna prendere delle decisioni o fare delle scelte. Nel SQL di Firebird,
    ciò significa nelle frasi contenenti le clausole
    <database>WHERE</database>, <database>HAVING</database>,
    <database>CHECK</database>, <database>CASE WHEN</database>,
    <database>IF</database> e <database>WHILE</database>.</para>

    <para>Anche i confronti come <quote>x &gt; y</quote> danno come risultato
    valori booleani, ma non sono generalmente chiamati predicati, sebbene sia
    questione di forma. Un'espressione come Maggiore(x, y) che esprime la
    stessa cosa verrebbe immediatamente riconosciuta come predicato. I
    matematici preferiscono dare un <emphasis>nome</emphasis> ai predicati –
    come <quote>Maggiore</quote> o solo <quote>M</quote> – ed una coppia di
    <emphasis>parentesi</emphasis> per raccogliere gli argomenti.</para>

    <para>Firebird supporta i seguenti predicati SQL: <database>IN</database>,
    <database>ANY</database>, <database>SOME</database>,
    <database>ALL</database>, <database>EXISTS</database> e
    <database>SINGULAR</database>.</para>

    <note>
      <para>È accettabile dire che <quote><database>IS [NOT]
      NULL</database></quote> e <quote><database>IS [NOT] DISTINCT
      FROM</database></quote> sono predicati, nonostante l'assenza di
      parentesi. Ma che siano predicati o no, ne abbiamo già parlato e non ne
      parleremo ancora in questa sezione.</para>
    </note>

    <section id="nullguide-pred-in">
      <title><indexterm>
          <primary>Predicati</primary>

          <secondary>IN</secondary>
        </indexterm><indexterm>
          <primary>IN</primary>

          <secondary>Predicato</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>con IN()</secondary>
        </indexterm>Il predicato <database>IN</database></title>

      <para>Il predicato <database>IN</database> confronta l'espressione alla
      sua sinistra con le espressioni passate in una lista come argomenti e
      riporta <constant>true</constant> se trova una corrispondenza.
      <database>NOT IN</database> riporta sempre l'opposto di
      <database>IN</database>. Alcuni esempi del suo uso sono:</para>

      <blockquote>
        <programlisting>select NumAula, Piano from Classi where Piano in (3, 4, 5)</programlisting>

        <programlisting>delete from Clienti where upper(NomeCliente) in ('IGNOTO', 'NN', 'BOH', '' )</programlisting>

        <programlisting>if ( A not in (Var1, Var1 + 1, Var2, Var3 )) then ...</programlisting>
      </blockquote>

      <para>La lista può essere anche generata da una subquery ad un solo
      campo:</para>

      <blockquote>
        <programlisting>select Num, Nome, Classe from Studenti
  where Num in (select distinct Assegnatario from PrestitoLibri)</programlisting>
      </blockquote>

      <section>
        <title>Con una lista vuota</title>

        <para>Se la lista è vuota (ciò è possibile solo con una subquery),
        <database>IN</database> riporta sempre <constant>false</constant> e
        <database>NOT IN</database> sempre <constant>true</constant>, anche se
        l'espressione da valutare è <constant>NULL</constant>. Il senso è
        questo: anche se un valore è ignoto, sicuramente non c'è in una lista
        vuota.</para>
      </section>

      <section>
        <title>Quando è <constant>NULL</constant> l'espressione di
        confronto</title>

        <para>Se la lista non è vuota e l'espressione di test, che chiameremo
        <quote>A</quote> nei successivi esempi, è invece
        <constant>NULL</constant>, i predicati seguenti riporteranno sempre
        <constant>NULL</constant>, indipendentemente dalle espressioni nella
        lista:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>A <database>IN</database> ( Expr1, Expr2, ...,
            Expr<replaceable>N</replaceable> )</para>
          </listitem>

          <listitem>
            <para>A <database>NOT IN</database> ( Expr1, Expr2, ...,
            Expr<replaceable>N</replaceable> )</para>
          </listitem>
        </itemizedlist>

        <para>Il primo esempio può essere compreso pensando l'intera
        espressione come una catena di disgiunzioni (funzioni OR) di test
        sull'uguaglianza:</para>

        <blockquote>
          <para>A=Expr1 or A=Expr2 or ... or
          A=Expr<replaceable>N</replaceable></para>
        </blockquote>

        <para>che pertanto, se A è <constant>NULL</constant>, diventa</para>

        <blockquote>
          <para><constant>NULL</constant> or <constant>NULL</constant> or ...
          or <constant>NULL</constant></para>
        </blockquote>

        <para>cioè <constant>NULL</constant>.</para>

        <para>Il secondo predicato viene determinato dal fatto che <quote>not
        (<constant>NULL</constant>)</quote> è uguale a
        <constant>NULL</constant>.</para>
      </section>

      <section>
        <title>Quando <constant>NULL</constant> è nella lista</title>

        <para>Se A ha un valore proprio ma la lista contiene una o più
        espressioni <constant>NULL</constant>, le cose diventano un po' più
        complicate:</para>

        <itemizedlist>
          <listitem>
            <para>Se almeno una delle espressioni della lista ha lo stesso
            valore di A:</para>

            <itemizedlist spacing="compact">
              <listitem>
                <para><quote>A <database>IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> vale
                <constant>true</constant></para>
              </listitem>

              <listitem>
                <para><quote>A <database>NOT IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> vale
                <constant>false</constant></para>
              </listitem>
            </itemizedlist>

            <para>Questo lo si deve al fatto che
            <quote><constant>true</constant> or
            <constant>NULL</constant></quote> vale <constant>true</constant>
            (vedi sopra). Più in generale: una disgiunzione dove almeno uno
            degli elementi è <constant>true</constant>, riporta
            <constant>true</constant> perfino se altri elementi sono
            <constant>NULL</constant>. Ovviamente tutti i
            <constant>false</constant> eventualmente presenti non interessano.
            In una disgiunzione interessa se c'è almeno un
            <constant>true</constant></para>
          </listitem>

          <listitem>
            <para>Se nessuna delle espressioni in lista ha lo stesso valore di
            A:</para>

            <itemizedlist spacing="compact">
              <listitem>
                <para><quote>A <database>IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> vale
                <constant>NULL</constant></para>
              </listitem>

              <listitem>
                <para><quote>A <database>NOT IN</database>( Expr1, Expr2, ...,
                Expr<replaceable>N</replaceable> )</quote> vale
                <constant>NULL</constant></para>
              </listitem>
            </itemizedlist>

            <para>Questo perchè <quote><constant>false</constant> or
            <constant>NULL</constant></quote> riporta
            <constant>NULL</constant>. Generalizzando si può dire che una
            disgiunzione che ha solo elementi <constant>false</constant> e
            <constant>NULL</constant>, vale <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>

        <para>Inutile dire che se né A né ciascuna espressione in lista è
        <constant>NULL</constant>, il risultato è quello atteso e può essere
        solo o <constant>true</constant> o <constant>false</constant>.</para>
      </section>

      <section>
        <title><database><indexterm>
            <primary>Predicati</primary>

            <secondary>IN</secondary>

            <tertiary>risultati</tertiary>
          </indexterm><indexterm>
            <primary>IN</primary>

            <secondary>Predicato</secondary>

            <tertiary>risultati</tertiary>
          </indexterm>I risultati di IN()</database></title>

        <para>La tabella seguente mostra tutti i possibilirisultati per
        <database>IN</database> e <database>NOT IN.</database> Per usarla nel
        modo giusto, si parte dalla prima domanda a sinistra. Se la risposta è
        No, passare alla linea successiva. Se la risposta è Si, leggere il
        risultato dalla seconda o terza colonna, come appropriato, ed è
        tutto.</para>

        <table id="nullguide-tbl-in-results">
          <title>Results for <quote>A [NOT] IN (&lt;list&gt;)</quote></title>

          <tgroup cols="3">
            <colspec colname="colConditions" colwidth="4*" />

            <colspec colname="colResultIn" colwidth="1*" />

            <colspec colname="colResultNotIn" colwidth="1*" />

            <thead>
              <row valign="top">
                <entry align="center" morerows="1">Conditions</entry>

                <entry align="center" nameend="colResultNotIn"
                namest="colResultIn">Results</entry>
              </row>

              <row>
                <entry align="center">IN()</entry>

                <entry align="center">NOT IN()</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>La lista è vuota?</entry>

                <entry align="center"><constant>false</constant></entry>

                <entry align="center"><constant>true</constant></entry>
              </row>

              <row>
                <entry>Altrimenti, A è <constant>NULL</constant>?</entry>

                <entry align="center"><constant>NULL</constant></entry>

                <entry align="center"><constant>NULL</constant></entry>
              </row>

              <row>
                <entry>Altrimenti, esiste almeno un elemento della lista
                uguale ad A?</entry>

                <entry align="center"><constant>true</constant></entry>

                <entry align="center"><constant>false</constant></entry>
              </row>

              <row>
                <entry>Altrimenti, almeno un elemento della lista è
                <constant>NULL</constant>?</entry>

                <entry align="center"><constant>NULL</constant></entry>

                <entry align="center"><constant>NULL</constant></entry>
              </row>

              <row>
                <entry>Altrimenti tutti gli elementi della lista sono diversi
                da A e non <constant>NULL, quindi</constant></entry>

                <entry align="center"><constant>false</constant></entry>

                <entry align="center"><constant>true</constant></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>In alcuni contesti (ad esempio nelle clausole
        <database>IF</database> e <database>WHERE</database>), un risultato
        <constant>NULL</constant> si comporta come se ci fosse<constant>
        false</constant> nel senso che la condizione non è soddisfatta quando
        l'espressione di controllo è <constant>NULL</constant>. Ciò conviene
        nei casi dove ci si aspetterebbe <constant>false</constant> ma invece
        c'è <constant>NULL</constant>: semplicemente non si nota la
        differenza. Il rovescio della medaglia è che ci si aspetterebbe
        <constant>true</constant> quando l'espressione viene invertita (usando
        <database>NOT</database>) ed invece si casca dall'asino nel senso che
        l'espressione più <quote>pericolosa</quote> fra i casi elencati nella
        tabella qui sopra è del tipo <quote>A <database>NOT IN</database>
        (&lt;lista&gt;)</quote>, dove A non è presente nella lista (cioè ci si
        aspetterebbe <constant>true</constant>) ma nella lista succede che ci
        siano uno o più <constant>NULL</constant>.</para>

        <caution>
          <para>Bisogna stare particolarmente attenti ad usare <database>NOT
          IN</database> in una subselect invece che in una lista esplicita,
          cioè:</para>

          <blockquote>
            <programlisting>A not in ( select Numeri from Tabella )</programlisting>
          </blockquote>

          <para>Se A non è presente nella colonna <literal>Numeri</literal>,
          il risultato è <constant>true</constant> se nessuno dei
          <literal>Numeri</literal> è <constant>NULL</constant>, ma è
          <constant>NULL</constant> se c'è un <constant>NULL</constant> fra i
          <literal>Numeri</literal>. Attenzione inoltre che perfino in
          situazioni dove A è costante ed il suo valore non è mai contenuto
          nella colonna <literal>Numeri</literal>, il risultato
          dell'espressione (e di conseguenza il flusso del programma) può
          cambiare nel tempo con la presenza o l'assenza di
          <constant>NULL</constant> nella colonna. Divertitevi a beccare
          l'errore in debug! Naturalmente il problema si evita facilmente con
          l'aggiunta di <quote>where Numeri is not
          <constant>NULL</constant></quote> alla subselect.</para>
        </caution>

        <warning id="nullguide-pred-in-bug">
          <title>Problema</title>

          <para>Tutte le versioni precedenti alla 2.0 contengono un problema
          per cui <database>[NOT] IN</database> riporta il risultato errato se
          è attivo un indice nella subselect e risulta vera una delle seguenti
          condizioni:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para>A è <constant>NULL</constant> e la subselect non riporta
              nessun <constant>NULL</constant></para>
            </listitem>

            <listitem>
              <para>A non è <constant>NULL</constant> e la subselect non
              contiene A ma contiene dei <constant>NULL</constant>.</para>
            </listitem>
          </itemizedlist>

          <para>Notare che un indice può essere attivo anche se non è stato
          creato esplicitamente, ad esempio se è stata definita una chiave con
          il campo A.</para>

          <para>Esempio: la tabella TA ha una colonna A con valori { 3, 8 }.
          La tabella TB ha una colonna B con i valori { 2, 8, 1,
          <constant>NULL</constant> }. Entrambe le espressioni</para>

          <blockquote>
            <programlisting>A [not] in ( select B from TB )</programlisting>
          </blockquote>

          <para>dovrebbero riportare <constant>NULL</constant> quando A = 3, a
          causa del <constant>NULL</constant> in B. Ma se B è indicizzato,
          <database>IN</database> riporta <constant>false</constant> e
          <database>NOT IN</database> riporta <constant>true</constant>. Come
          conseguenza, la query</para>

          <blockquote>
            <programlisting>select A from TA where A not in ( select B from TB )</programlisting>
          </blockquote>

          <para>riporta un dataset con un record di un campo contenente il
          valore 3, mentre avrebbe dovuto riportare un dataset vuoto (nessun
          record). Altri errori possono esser dietro l'angolo, cioè usando
          <quote><database>NOT IN</database></quote> in una frase o una
          clausola tipo <database>IF</database>, <database>CASE</database> o
          <database>WHILE</database>.</para>

          <para>Come alternativa a <database><database>NOT
          IN</database></database>, si può usare
          <quote><literal>&lt;&gt;</literal> <database>ALL</database></quote>.
          Il predicato <database>ALL</database> lo vedremo tra breve.</para>
        </warning>
      </section>

      <section>
        <title><database><indexterm>
            <primary>IN</primary>

            <secondary>nei controlli di CHECK</secondary>
          </indexterm><indexterm>
            <primary>CHECK</primary>
          </indexterm>IN()</database> nei controlli di
        <database>CHECK</database></title>

        <para>Il predicato <database>IN()</database> è usato spesso nei
        controlli di <database>CHECK</database>. In tali contesti, le
        espressioni <constant>NULL</constant> hanno un effetto
        sorprendentemente differente nelle versioni di Firebird 2.0 e
        successive. Questo verrà dettagliato nella sezione dedicata ai <link
        linkend="nullguide-check-constraints-it"><citetitle><database>controlli
        di CHECK</database></citetitle></link>.</para>
      </section>
    </section>

    <section id="nullguide-pred-any-some-all">
      <title><indexterm>
          <primary>Predicati</primary>

          <secondary>ANY, SOME e ALL</secondary>
        </indexterm><indexterm>
          <primary>ANY</primary>
        </indexterm><indexterm>
          <primary>SOME</primary>
        </indexterm><indexterm>
          <primary>ALL</primary>
        </indexterm>I quantificatori <database>ANY</database>,
      <database>SOME</database> e <database>ALL</database></title>

      <para>Firebird ha due quantificatori che permettono di comparare un
      valore al risultato di una subselect:</para>

      <itemizedlist>
        <listitem>
          <para><database>ALL</database> riporta <constant>true</constant> se
          il confronto è vero (cioè <constant>true</constant>) per
          <emphasis>ogni</emphasis> elemento della subselect.</para>
        </listitem>

        <listitem>
          <para><database>ANY</database> e <database>SOME</database>
          (completamente sinonimi) sono veri se il confronto è
          <constant>true</constant> per <emphasis>almeno uno</emphasis> degli
          elementi della subselect.</para>
        </listitem>
      </itemizedlist>

      <para>Con <database>ANY</database>, <database>SOME</database> e
      <database>ALL</database> si può gestire meglio l'operatore di confronto.
      Questo rende il tutto più flessibile che con <database>IN</database>,
      che supporta solo l'operatore (implicito ) <quote>=</quote>. D'altra
      parte, <database>ANY</database>, <database>SOME</database> e
      <database>ALL</database> accettano solo subselect come argomento e non è
      possibile dare una lista di elementi esplicita come per
      <database>IN</database>.</para>

      <para>Gli operatori validi sono<literal>
      </literal><literal>=</literal>,<literal>
      </literal><literal>!=</literal>,<literal>
      </literal><literal>&lt;</literal>,<literal>
      </literal><literal>&gt;</literal>,<literal>
      </literal><literal>=&lt;</literal>,<literal>
      </literal><literal>=&gt;</literal><literal> </literal>e tutti i loro
      sinonimi. Non si possono usare <database>LIKE</database>,
      <database>CONTAINING</database>, <database>IS DISTINCT FROM</database>,
      ed altri operatorior.</para>

      <para>Alcuni esempi d'uso tipico:</para>

      <blockquote>
        <programlisting>select nome, stipendio from operai
  where stipendio &gt; any( select stipendio from dirigenti )</programlisting>

        <para>(riporta la lista degli operai che guadagnano più di almeno un
        dirigente)</para>

        <programlisting>select nome, provincia from operai
  where provincia != all( select distinct provincia from dirigenti )</programlisting>

        <para>(riporta la lista degli operai che non vivono in nessuna città
        in cui vive un dirigente)</para>

        <programlisting>if ( StipendioDirigente !&gt; some( select stipendio from operai ) )
  then Dirigentaccio = 1;
  else Dirigentaccio = 0;</programlisting>

        <para>(mette Dirigentaccio a 1 se lo stipendio di almeno un operaio è
        non minore del valore di StipendioDirigente)</para>
      </blockquote>

      <section>
        <title><indexterm>
            <primary>Predicati</primary>

            <secondary>ANY, SOME e ALL</secondary>

            <tertiary>risultati</tertiary>
          </indexterm>I risultati di <database>ANY</database>,
        <database>SOME</database> e <database>ALL</database></title>

        <para>Se la subselect non riporta record, <database>ALL</database>
        vale <constant>true</constant> e
        <database>ANY</database>|<database>SOME</database> valgono
        <constant>false</constant>, anche se la parte sinistra
        dell'espressione è <constant>NULL</constant>. Questo segue
        naturalmente dalle definizioni e dalle regole della logica formale. Le
        menti matematiche avranno già notato che <database>ALL</database> è
        equivalente al quantificatore universale <quote>∀</quote> e che
        <database>ANY</database>|<database>SOME</database> lo sono a quello
        esistenziale <quote>∃</quote>.</para>

        <para>Per gli insiemi non vuoti, si può scrivere <quote>A
        <replaceable>&lt;op&gt;</replaceable>
        <database>ANY</database>|<database>SOME</database>
        (<replaceable>&lt;subselect&gt;</replaceable>)</quote> come</para>

        <blockquote>
          <para>A <replaceable>&lt;op&gt;</replaceable> E1<literal> </literal>
          <emphasis role="bold">or</emphasis> <literal> </literal>A
          <replaceable>&lt;op&gt;</replaceable> E2<literal> </literal>
          <emphasis role="bold">or</emphasis> <literal> </literal>...<literal>
          </literal> <emphasis role="bold">or</emphasis> <literal> </literal>A
          <replaceable>&lt;op&gt;</replaceable>
          E<replaceable>n</replaceable></para>
        </blockquote>

        <para>dove <replaceable>&lt;op&gt;</replaceable> è l'operatore usato e
        E1, E2 ecc. sono i valori riportati dalla subquery.</para>

        <para>Allo stesso modo, <quote>A <replaceable>&lt;op&gt;</replaceable>
        <database>ALL</database>
        (<replaceable>&lt;subselect&gt;</replaceable>)</quote> è lo stesso
        di</para>

        <blockquote>
          <para>A <replaceable>&lt;op&gt;</replaceable> E1<literal> </literal>
          <emphasis role="bold">and</emphasis> <literal> </literal>A
          <replaceable>&lt;op&gt;</replaceable> E2<literal> </literal>
          <emphasis role="bold">and</emphasis> <literal>
          </literal>...<literal> </literal> <emphasis
          role="bold">and</emphasis> <literal> </literal>A
          <replaceable>&lt;op&gt;</replaceable>
          E<replaceable>n</replaceable></para>
        </blockquote>

        <para>Tutto questo ha l'aria familiare: la prima riscrittura è uguale
        a quella del predicato <database>IN</database>, cambia l'operatore che
        può essere ora diverso dal solito <quote><literal>=</literal></quote>.
        La seconda è diversa ma ne mantiene la forma generale. Adesso si può
        determinare come in A e/o nel risultato della subselect, il
        <constant>NULL</constant> modifica il comportamento di
        <database>ANY</database>|<database>SOME</database> e
        <database>ALL</database>. Questo verrà mostrato allo stesso moso di
        come abbiamo visto prima per <database>IN</database>, solo che adesso
        invece di mostrare il procedimento passo passo, andiamo direttamente a
        presentare la tabella dei risultati. Al solito, leggere le domande
        nella colonna di sinistra dall'alto inbasso e, non appena la risposta
        è <quote>si</quote>, ricavare il risultato dalla colonna di
        destra.</para>

        <indexterm>
          <primary>ANY</primary>

          <secondary>risultati</secondary>
        </indexterm>

        <indexterm>
          <primary>SOME</primary>

          <secondary>risultati</secondary>
        </indexterm>

        <table id="nullguide-tbl-any-some-results">
          <title>Risultati per <quote>A &lt;op&gt; ANY|SOME
          (&lt;subselect&gt;)</quote></title>

          <tgroup cols="2">
            <colspec colname="colConditions" colwidth="4*" />

            <colspec colname="colResult" colwidth="1*" />

            <thead>
              <row valign="top">
                <entry align="center" morerows="1">Conditizioni</entry>

                <entry align="center">Risultati</entry>
              </row>

              <row>
                <entry align="center"><database>ANY</database> |
                <database>SOME</database></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>La subselect non ha riportato niente (cioè nessuna
                riga)?</entry>
              </row>

              <row>
                <entry>altrimenti, A è <constant>NULL</constant>?</entry>

                <entry align="center"><constant>NULL</constant></entry>
              </row>

              <row>
                <entry>altrimenti, uno dei confronti almento è vero, cioè
                riporta <constant>true</constant>?</entry>

                <entry align="center"><constant>true</constant></entry>
              </row>

              <row>
                <entry>altrimenti, uno dei confronti almeno riporta
                <constant>NULL</constant>?</entry>

                <entry align="center"><constant>NULL</constant></entry>
              </row>

              <row>
                <entry>altrimenti ( tutti i confronti sono falsi, e riportano
                <constant>false</constant>)</entry>

                <entry align="center"><constant>false</constant></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>A pensare che questi risultati siano proprio simili a quelli
        visti con <database>IN()</database>, non ci si sbaglia molto: con
        l'operatore <quote><literal>=</literal></quote>,
        <database>ANY</database> è si comporta come <database>IN</database>.
        Allo stesso modo, <quote><literal>&lt;&gt;</literal>
        <database>ALL</database></quote> è equivalente a <database>NOT
        IN</database>.</para>

        <warning id="nullguide-pred-any-bug">
          <title>Problemi rivisitati</title>

          <para>Nelle versioni precedenti alla 2.0,
          <quote><literal>=</literal> <database>ANY</database></quote> aveva
          lo stesso problema di <database>IN</database>: in
          <quote>certe</quote> circostanze, si hanno risultati sbagliati con
          espressioni del tipo <quote><database>NOT</database> A =
          <database>ANY</database>( ... )</quote>.</para>

          <para>Il lato buono è che , <quote><literal>&lt;&gt;</literal>
          <database>ALL</database></quote> non ha quel problema e da' sempre i
          risultati giusti.</para>
        </warning>

        <indexterm>
          <primary>ALL</primary>

          <secondary>risultati</secondary>
        </indexterm>

        <table id="nullguide-tbl-all-results">
          <title>Risultati per <quote>A &lt;op&gt; ALL
          (&lt;subselect&gt;)</quote></title>

          <tgroup cols="2">
            <colspec colname="colConditions" colwidth="4*" />

            <colspec colname="colResult" colwidth="1*" />

            <thead>
              <row valign="top">
                <entry align="center" morerows="1">Condizioni</entry>

                <entry align="center">Risultati</entry>
              </row>

              <row>
                <entry align="center"><database>ALL</database></entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>La subselect non ha riportato niente (cioè nessuna
                riga)?</entry>

                <entry align="center"><constant>true</constant></entry>
              </row>

              <row>
                <entry>altrimenti, A è <constant>NULL</constant>?</entry>

                <entry align="center"><constant>NULL</constant></entry>
              </row>

              <row>
                <entry>altrimenti, uno dei confronti almento è falso, cioè
                riporta <constant>false</constant>?</entry>

                <entry align="center"><constant>false</constant></entry>
              </row>

              <row>
                <entry>altrimenti, uno dei confronti almeno riporta
                <constant>NULL</constant>?</entry>

                <entry align="center"><constant>NULL</constant></entry>
              </row>

              <row>
                <entry>altrimenti ( tutti i confronti sono veri, e riportano
                <constant>true</constant>)</entry>

                <entry align="center"><constant>true</constant></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <warning id="nullguide-pred-all-bug-it">
          <title><database>Problemi di ALL</database></title>

          <para>Per quanto <quote><literal>&lt;&gt;</literal>
          <database>ALL</database></quote> faccia sempre il suo dovere,
          nondimeno <database>ALL</database>, in tutte le versioni di Firebird
          precedenti alla 2.0, non è scevro da problemi: qualsiasi altro
          operatore che non sia <quote><literal>&lt;&gt;</literal></quote>,
          può dare risultati errati se è attivo un indice nella subselect,
          indipendentemente dalla presenza di
          <constant>NULL</constant>.</para>
        </warning>

        <note>
          <para>Parlando papale papale, il secondo punto in entrambe le
          tabelle (<quote>A è <constant>NULL</constant>?</quote>) è
          rindondante e potrebbe essere eliminato. Se A è
          <constant>NULL</constant>, tutti i confronti riportano
          <constant>NULL</constant>, pertanto la situazione potrebbe essere
          rinviata alle domande successive. E già che ci siamo, si potrebbe
          eliminare pure la prima domanda: il caso "senza righe" è un caso
          particolare dell'ultima. Il tutto ancora una volta diventa
          <quote><constant>true</constant> batte il <constant>NULL</constant>
          che batte il <constant>false</constant></quote> nelle disgiunzioni
          (<database>ANY</database>|<database>SOME</database>) e
          <quote><constant>false</constant> batte il <constant>NULL</constant>
          che batte il <constant>true</constant></quote> nelle congiunzioni
          (<database>ALL</database>).</para>

          <para>La ragione per includere tutti i dettagli è la praticità: si
          riesce a vedere a colpo d'occhio se non ci sono record, ed è ancor
          più facile verificare che la parte sinistra di un'espressione sia
          <constant>NULL</constant> piuttosto che valutare ogni singolo
          confronto dei risultati. Si può fare come si crede, saltare entrambi
          i punti o solo il secondo. Ad ogni modo, <emphasis>non</emphasis> va
          ignorata la prima domanda iniziando con la seconda: questo porta a
          conclusioni errate se la subselect è vuota!</para>
        </note>
      </section>
    </section>

    <section id="nullguide-pred-exists-singular">
      <title><database>EXISTS</database> e
      <database>SINGULAR</database></title>

      <para>I predicati <database>EXISTS</database> e
      <database>SINGULAR</database> danno informazioni su una subquery, di
      solito correlata. Si possono usare nelle clausole
      <database>WHERE</database>, <database>HAVING</database>,
      <database>CHECK</database>, <database>CASE</database>,
      <database>IF</database> e <database>WHILE</database> (le ultime due sono
      disponibili solo in PSQL, il linguaggio di Firebird dedicato alle stored
      procedure ed ai trigger).</para>

      <section id="nullguide-pred-exists">
        <title><indexterm>
            <primary>EXISTS</primary>
          </indexterm><indexterm>
            <primary>Predicati</primary>

            <secondary>EXISTS</secondary>
          </indexterm><database>EXISTS</database></title>

        <para><database>EXISTS</database> dice se una subquery riporta almeno
        una riga di dati. Per ottenere ad esempio una lista di lavoratori che
        sono anche proprietari, si potrebbe avere una cosa del genere:</para>

        <blockquote>
          <programlisting>SELECT Lavoratore FROM Aziende WHERE EXISTS
  (SELECT * FROM Proprietari
   WHERE Proprietari.Nome = Aziende.Lavoratore)</programlisting>
        </blockquote>

        <para>Questa query riporta i nomi di tutti i lavoratori che sono anche
        nella tabella proprietari. Il predicato <database>EXISTS</database>
        r<constant>iporta true</constant> se l'insieme di righe risultanti
        dalla subselect ne contiene almento una, se invece è vuoto,
        <database>EXISTS</database> riporta <constant>false</constant>.
        <database>EXISTS</database> non riporta mai <constant>NULL</constant>,
        in quanto un result set o c'ha righe o non ce n'ha. Può succedere che
        le condizioni di ricerca della subselect possano dare tutto a
        <constant>NULL</constant> per certe righe, ma non crea incertezze
        perchè tali righe non vengono incluse nel risultato.</para>

        <note>
          <para>La subselect in realtà non riporta nessun result set. Il
          sistema semplicemente scorre la subselect (la tabella Proprietari
          dell'esempio) record per record applicando la condizione di ricerca.
          Se trova che vale <constant>true</constant>,
          <database>EXISTS</database> riporta <constant>true</constant>
          immediatamente e i record rimanenti non vengono guardati. Se è
          <constant>false</constant> o <constant>NULL</constant>, prosegue con
          il successivo record. Se sono stati controllati tutti i record e non
          è stato trovato neanche l'ultimo controllo ha dato
          <constant>true</constant>, <database>EXISTS</database> riporta
          <constant>false</constant>.</para>
        </note>

        <para><database>NOT EXISTS</database> da' sempre l'opposto di
        <database>EXISTS</database>: <constant>false</constant> oppure
        <constant>true</constant>, mai <constant>NULL</constant>.
        <database>NOT EXISTS</database> riporta <constant>false</constant>
        immediatamente non appena ha un risultato <constant>true</constant>
        nella condizione di ricerca. Per riportare <constant>true</constant>
        deve scorrersi tutti i record.</para>
      </section>

      <section id="nullguide-pred-singular-it">
        <title><indexterm>
            <primary>SINGULAR</primary>
          </indexterm><indexterm>
            <primary>Predicati</primary>

            <secondary>SINGULAR</secondary>
          </indexterm><database>SINGULAR</database></title>

        <para><database>SINGULAR</database> è una estensione allo standard SQL
        di InterBase/Firebird. Si può dire che riporta
        <constant>true</constant> se nella subquery esattamente un record
        soddisfa la condizione. Per analogia con <database>EXISTS</database>
        ci si aspetterebbe che anche <database>SINGULAR</database> possa
        riportare solo o <constant>true</constant> o
        <constant>false</constant>. Dopo tutto un result set o ha esattamente
        un record oppure ne ha un numero differente. Purtroppo tutte le
        versioni di Firebird fino alla 2.0 compresa hanno un problema che
        provoca dei risultati <constant>NULL</constant> in un certo numero di
        casi anomali. Il comportamento è abbastanza inconsistente, ma allo
        stesso tempo perfettamente riproducibile: per esempio, in una colonna
        contenente (1, <constant>NULL</constant>, 1), un test per
        <database>SINGULAR</database> con la condizione
        <quote><code>A=1</code></quote> riporta <constant>NULL</constant>, ma
        lo stesso test con i dati (1, 1, <constant>NULL</constant>) riporta
        <constant>false</constant>. Notare che cambia solo l'ordine di
        inserimento dei dati!</para>

        <para>A render le cose peggiori, in tutte le versioni precedenti la
        2.0 talvolta viene riportato <constant>NULL</constant> da
        <database>NOT SINGULAR</database> quando invece
        <database>SINGULAR</database> da' <constant>false</constant> o
        <constant>true</constant>. Nella 2.0, almeno questo non succede più: o
        è <constant>false</constant> invece di <constant>true</constant> o
        entrambi <constant>NULL</constant>.</para>

        <para>Il codice è stato corretto nella versione 2.1 di Firebird; da
        quella versione in poi <database>SINGULAR</database> riporterà:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><constant>false</constant> se la condizione di ricerca non è
            mai <constant>true</constant> (includendo il caso dell'insieme
            vuoto, cioè nessun record);</para>
          </listitem>

          <listitem>
            <para><constant>true</constant> se la condizione di ricerca è vera
            per esattamente 1 record;</para>
          </listitem>

          <listitem>
            <para><constant>false</constant> se la condizione di ricerca è
            vera per più di 1 record.</para>
          </listitem>
        </itemizedlist>

        <para>Se altri record sono <constant>false</constant>,
        <constant>NULL</constant> o una combinazione di questi, non ha più
        importanza.</para>

        <para><database>NOT SINGULAR</database> riporterà sempre l'esatto
        opposto di <database>SINGULAR</database> (come già succede nella 2.0,
        solo che il valore NULL è adesso impossibile).</para>

        <para>Nel frattempo che la 2.1 diventi definitiva, se c'è anche una
        <emphasis>qualsiasi</emphasis> piccola possibilità che la ricerca
        possa riportare <constant>NULL</constant> per una o più righe, bisogna
        sempre aggiungere una condiziione di <database>IS NOT NULL</database>
        a<database>lla clausola [NOT] SINGULAR</database> come, ad
        esempio</para>

        <blockquote>
          <programlisting>... SINGULAR( SELECT * from Tabella
              WHERE Campo &gt; 38
              AND Campo IS NOT NULL )</programlisting>
        </blockquote>
      </section>
    </section>
  </section>

  <section id="nullguide-searches">
    <title><indexterm>
        <primary>Ricerche</primary>
      </indexterm><indexterm>
        <primary>WHERE</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>nelle ricerche</secondary>
      </indexterm>Ricerche</title>

    <para>Se la condizione di ricerca di una <database>SELECT</database>,
    <database>UPDATE</database> o <database>DELETE</database> risolve a
    <constant>NULL</constant> per certe righe, l'effetto è come se fosse
    <constant>false</constant>. Mettendola in altro modo, se l'espressione è
    <constant>NULL</constant>, la condizione non è raggiunta, e di conseguenza
    la riga non è inclusa fra quelle selezionate per la ricerca ( o
    l'aggiornamento o la cancellazione).</para>

    <note>
      <para>Si dice <firstterm>condizione di ricerca</firstterm> (o
      <firstterm>search condition</firstterm> o <firstterm>search
      expression</firstterm>) la clausola <database>WHERE</database> senza la
      parola <database>iniziale WHERE</database>.</para>
    </note>

    <para>Alcuni esempi, con la condizione di ricerca evidenziata in
    grassetto:</para>

    <blockquote>
      <programlisting>SELECT Fattori, Mucche FROM Fattorie WHERE <emphasis
          role="bold">Mucche &gt; 0</emphasis> ORDER BY Mucche</programlisting>
    </blockquote>

    <para>La frase sopra riporta i Fattori che hanno registrata almeno una
    mucca. Quelli con un numero sconosciuto (<constant>NULL</constant>) non
    vengono inclusi, perche l'espressione <quote><literal>NULL &gt;
    0</literal></quote> riporta <constant>NULL</constant>.</para>

    <blockquote>
      <programlisting>SELECT Fattori, Micche FROM Fattorie WHERE <emphasis
          role="bold">NOT (Mucche &gt; 0)</emphasis> ORDER BY Mucche</programlisting>
    </blockquote>

    <para>Adesso si sarebbe tentati di dire che questa riporti <quote>tutti
    gli altri record</quote> della tabella Fattorie, giusto? No, sbagliato.
    Almeno se la colonna Mucche contiene qualche <constant>NULL</constant>. Ci
    siamo scordati che <literal>not(NULL)</literal> è ancora
    <constant>NULL</constant>? Pertanto per ogni reiga per la quale Mucche è
    <constant>NULL</constant>, <quote><literal>Cows &gt; 0</literal></quote>
    sarà <constant>NULL</constant>, e <quote><literal>NOT (Cows &gt;
    0)</literal></quote> sarà pure <constant>NULL</constant> e quindi non sarà
    nel record set risultante.</para>

    <blockquote>
      <programlisting>SELECT Fattori, Mucche, Pecore FROM Fattorie WHERE <emphasis
          role="bold">Mucche + Pecore &gt; 0</emphasis></programlisting>
    </blockquote>

    <para>A prima vista sembra che questa sia una query che genera l'elenco di
    tutti i fattori che hanno almeno una nucca o una pecora (assumendo di non
    avere mucche o pecore negative...). Tuttavia se il fattore Antonio ha 30
    mucche ed un numero sconosciuto di pecore, la somma <literal>Mucche +
    Pecore</literal> è <constant>NULL</constant>, e quindi l'tera condizione
    di ricerca risolve a <quote><literal>NULL &gt; 0</literal></quote>, che
    è... capito? Così, nonostante le sue 30 mucche, il caro amico Antonio non
    sarà mai nell'elenco risultante perchè non soddisfa la condizione di
    ricerca.</para>

    <para>Per ultimo, riscriviamo l'esempio precedente in modo che riporti
    comunque tutti i fattori che hanno <emphasis>almeno</emphasis> un animale
    di un qualsiasi tipo, anche se la quantità dell'altro tipo è ignota, cioè
    <constant>NULL</constant>. Per farlo, approfittiamo del fatto che
    <quote><literal>NULL or true</literal></quote> riporta
    <constant>true</constant> – uno dei rari casi in cui un operando
    <constant>NULL</constant> non trasforma l'intera espressione in
    <constant>NULL</constant>:</para>

    <blockquote>
      <programlisting>SELECT Fattori, Mucche, Pecore FROM Fattorie WHERE <emphasis
          role="bold">Mucche &gt; 0 OR Pecore &gt; 0</emphasis></programlisting>
    </blockquote>

    <para>In questo caso, le 30 mucche di Antonio rendono il primo confronto
    <constant>true</constant>, mentre quello con le pecore rimane a
    <constant>NULL</constant>. Così c'è <quote><literal>true or
    NULL</literal></quote>, che è <constant>true</constant>, e la riga verrà
    inclusa nell'insieme risultante.</para>

    <caution>
      <para>Se la condizione di ricerca contiene uno o più predicati
      <database>IN</database>, c'è la complicazione che alcuni degli elementi
      in lista (o risultati di una subselect) potrebbe essere
      <constant>NULL</constant>. Le imlicazioni di questo le abbiamo viste ne
      <link linkend="nullguide-pred-in"><citetitle>Il predicato
      IN()</citetitle></link>.</para>
    </caution>
  </section>

  <section id="nullguide-sorts">
    <title><indexterm>
        <primary>Ordinamenti</primary>
      </indexterm><indexterm>
        <primary>Ordinare</primary>
      </indexterm><indexterm>
        <primary>NULLS FIRST</primary>
      </indexterm><indexterm>
        <primary>NULLS LAST</primary>
      </indexterm><indexterm>
        <primary>ORDER BY</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>negli ordinamenti</secondary>
      </indexterm>Gli ordinamenti</title>

    <para>In Firebird 2.0, i <constant>NULL</constant> sono considerati
    <quote>precedenti</quote> a qualsiasi altra cosa nell'ordinamento. Di
    conseguenza vengono prima negli ordinamente ascendenti e ultimi negli
    ordinamenti discendenti. Questo può essere modificato aggiungendo
    <database>la direttiva NULLS FIRST</database> oppure <database>NULLS
    LAST</database> a<database>lla clausola ORDER BY</database>.</para>

    <para>Nelle versioni precedenti, i <constant>NULL</constant> erano sempre
    messi alla fine dell'insieme ordinato, indipendentemente dal fatto che
    fosse ascendente o discendente. In Firebird 1.0 la storia finiva qui: i
    <constant>NULL</constant> sono ultimi in qualsiasi ordinamento, punto. In
    Firebird 1.5 è stata introdotta la sintassi <database>NULLS
    FIRST/LAST</database>, per forzarli all'inizio o alla fine.</para>

    <para>Per riassumere il tutto:</para>

    <table>
      <title>Posizionamento dei <constant>NULL</constant> negli
      ordinamenti</title>

      <tgroup cols="4">
        <colspec colname="colStatement" colwidth="2*" />

        <colspec colname="colPlac10" colwidth="1*" />

        <colspec colname="colPlac15" colwidth="1*" />

        <colspec colname="colPlac2" colwidth="1*" />

        <thead>
          <row>
            <entry morerows="1">Ordinamento</entry>

            <entry align="center" nameend="colPlac2"
            namest="colPlac10">Posizione dei <constant>NULL</constant></entry>
          </row>

          <row>
            <entry align="center">Firebird 1</entry>

            <entry align="center">Firebird 1.5</entry>

            <entry align="center">Firebird 2</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>order by ... [asc]</entry>

            <entry>alla fine</entry>

            <entry>alla fine</entry>

            <entry>all'inizio</entry>
          </row>

          <row>
            <entry>order by ... desc</entry>

            <entry>alla fine</entry>

            <entry>alla fine</entry>

            <entry>alla fine</entry>
          </row>

          <row>
            <entry>order by ... [asc | desc] nulls first</entry>

            <entry>—</entry>

            <entry>all'inizio</entry>

            <entry>all'inizio</entry>
          </row>

          <row>
            <entry>order by ... [asc | desc] nulls last</entry>

            <entry>—</entry>

            <entry>alla fine</entry>

            <entry>alla fine</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>Naturalmente è inutile, per quanto corretto, specificare
    <database>NULLS FIRST</database> nel caso ascendente oppure
    <database>NULLS LAST</database> in quello discendente con Firebird 2. Lo
    stesso dicasi per <database>NULLS LAST</database> in qualsiasi ordinamento
    in Firebird 1.5.</para>

    <note>
      <title>Note</title>

      <itemizedlist>
        <listitem>
          <para>Se si richiede un ordinamento dei <constant>NULL</constant>
          non default, non verrà utillizzato nessun indice. In Firebird 1.5,
          questo è il caso dei <database>NULLS FIRST</database>. In 2.0 e
          successivi, succede con <database>NULLS LAST</database> negli
          ordinamenti ascendenti e con <database>NULLS FIRST</database> in
          quelli discendenti.</para>
        </listitem>

        <listitem>
          <para>Aprendo un database pre-2.0 con Firebird 2, mostrerà il
          <emphasis>vecchio</emphasis> comportamento sull'ordinamento dei
          <constant>NULL</constant>, cioè alla fine, a meno di esplicito
          <database>NULLS FIRST</database>. Un ciclo di backup/restore rimette
          le cose a posto, se la restore viene effettuata con la gbak di
          Firebird!</para>
        </listitem>

        <listitem>
          <para><indexterm>
              <primary>DISTINCT</primary>

              <secondary>SELECT DISTINCT</secondary>
            </indexterm><indexterm>
              <primary>SELECT DISTINCT</primary>
            </indexterm>Firebird 2.0 ha un problema che provoca il fallimento
          della direttiva <database>NULLS FIRST|LAST</database> in certe
          circostanze insieme a <database>SELECT DISTINCT. Vedere la <link
          linkend="nullguide-bugs-select-distinct-it">lista dei
          problemi</link> per maggiori dettagli.</database></para>
        </listitem>
      </itemizedlist>
    </note>

    <warning>
      <para>Non si deve essere tentati dal fatto che siccome
      <constant>NULL</constant> è la <quote>cosa più piccola</quote> negli
      ordinamenti prima di Firebird 2, si possa pensare che espressioni come
      <quote><constant>NULL</constant> &lt; 3</quote> possano ora riportare
      <constant>true</constant>. No! Usare <constant>NULL</constant> in questo
      tipo di espressioni darà sempre risultato
      <constant>NULL</constant>.</para>
    </warning>
  </section>

  <section id="nullguide-aggrfunc">
    <title><indexterm>
        <primary>Funzioni</primary>
      </indexterm><indexterm>
        <primary>Funzioni</primary>

        <secondary>di aggregazione</secondary>
      </indexterm><indexterm>
        <primary>COUNT</primary>
      </indexterm><indexterm>
        <primary>SUM</primary>
      </indexterm><indexterm>
        <primary>AVG</primary>
      </indexterm><indexterm>
        <primary>MAX</primary>
      </indexterm><indexterm>
        <primary>MIN</primary>
      </indexterm><indexterm>
        <primary>LIST</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>nelle funzioni di aggregazione</secondary>
      </indexterm>Le funzioni di aggregazione</title>

    <para>Le funzioni di aggregazione – <function>COUNT</function>,
    <function>SUM</function>, <function>AVG</function>,
    <function>MAX</function>, <function>MIN</function> e
    <function>LIST</function> – non gestiscono <constant>NULL</constant> allo
    stesso modo delle funzioni ordinarie e degli operatori. Invece di
    riportare <constant>NULL</constant> non appena viene trovato un operando a
    <constant>NULL</constant>, queste considerano solo i campi non
    <constant>NULL</constant> per calcolare il risultato. Cioè se avete questa
    tabella:</para>

    <informaltable>
      <tgroup cols="3">
        <colspec align="center" colname="colID" colwidth="1*" />

        <colspec colname="colName" colwidth="2*" />

        <colspec align="center" colname="colAmount" colwidth="2*" />

        <thead>
          <row>
            <entry align="center" nameend="colAmount"
            namest="colID">Tabella</entry>
          </row>

          <row>
            <entry>ID</entry>

            <entry>Nome</entry>

            <entry>Importo</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>1</entry>

            <entry>John</entry>

            <entry>37</entry>
          </row>

          <row>
            <entry>2</entry>

            <entry>Jack</entry>

            <entry><constant>NULL</constant></entry>
          </row>

          <row>
            <entry>3</entry>

            <entry>Jim</entry>

            <entry>5</entry>
          </row>

          <row>
            <entry>4</entry>

            <entry>Joe</entry>

            <entry>12</entry>
          </row>

          <row>
            <entry>5</entry>

            <entry>Josh</entry>

            <entry><constant>NULL</constant></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>

    <para>...eseguendo <userinput>select sum(Importo) from Tabella</userinput>
    riporta 54, che è appunto 37 + 5 + 12. Se fossero stati sommati tutti i
    cinque campi, il risultato sarebbe stato <constant>NULL</constant>. Per la
    funzione <function>AVG</function>, i campi non-<constant>NULL</constant>
    sono sommati tra loro, e la somma divisa per il numero dei campi
    non-<constant>NULL</constant>.</para>

    <para>C'è una eccezione a questa regola: <function>COUNT(*)</function>
    riporta il numero di tutte le righe, perfino di quelle in cui tutti i
    campi sono <constant>NULL</constant>. Ma
    <function>COUNT</function>(<parameter>NomeCampo</parameter>) si comporta
    come le altre funzioni aggregate, nel senso che conta solo le righe in cui
    quello specifico campo non è <constant>NULL</constant>.</para>

    <para>Un'altra cosa che vale la pena di sapere è che sia
    <function>COUNT(*)</function> sia
    <function>COUNT(<parameter>FieldName</parameter>)</function> non riportano
    mai <constant>NULL</constant>: se non ci sono righe nell'insieme risultato
    della <userinput>SELECT...</userinput>, entrambe valgono 0. Inoltre, anche
    <function>COUNT(<parameter>NomeCampo</parameter>)</function> vale 0 se
    tutti i campi <parameter>NomeCampo</parameter> nel risultato sono
    <constant>NULL</constant>. In questi casi tutte le altre funzioni di
    aggregazione riportano <constant>NULL</constant>. Bisogna avvertire che
    anche <function>SUM</function> riporta <constant>NULL</constant> se
    utilizzata su un insieme risultato vuoto, che è contrario alla logica
    comune: se non ci sono righe la media, il minimo ed il massimo non sono
    definiti, ma la somma è zero.</para>

    <para>Ora mettiamo il tutto insieme in una tabella riassuntiva:</para>

    <table id="nullguide-tbl-aggr-funcs">
      <title>I risultati delle funzioni aggregate in diverse
      situazioni</title>

      <tgroup cols="4">
        <colspec colname="colAggFunc" />

        <colspec colname="colSetEmpty" />

        <colspec colname="colSetAllNulls" />

        <colspec colname="colSetHavingValues" colwidth="3*" />

        <spanspec nameend="colSetHavingValues" namest="colSetEmpty"
                  spanname="spanAllSets" />

        <thead>
          <row>
            <entry morerows="1">Funzione</entry>

            <entry align="center" spanname="spanAllSets">Risultati</entry>
          </row>

          <row>
            <entry>Insieme vuoto</entry>

            <entry>Insieme o colonna tutta a null</entry>

            <entry>Altri casi</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry><database>COUNT</database>(*)</entry>

            <entry>0</entry>

            <entry>Numero totale delle righe</entry>

            <entry>Numero totale delle righe</entry>
          </row>

          <row>
            <entry><database>COUNT</database>(Campo)</entry>

            <entry>0</entry>

            <entry>0</entry>

            <entry>Numero di righe dove Campo non è
            <constant>NULL</constant></entry>
          </row>

          <row>
            <entry><database>MAX</database>, <database>MIN</database></entry>

            <entry><constant>NULL</constant></entry>

            <entry><constant>NULL</constant></entry>

            <entry>Il valore minimo o massimo trovato nella colonna</entry>
          </row>

          <row>
            <entry><database>SUM</database></entry>

            <entry><constant>NULL</constant></entry>

            <entry><constant>NULL</constant></entry>

            <entry>Somma dei valori non <constant>NULL</constant> della
            colonna</entry>
          </row>

          <row>
            <entry><database>AVG</database></entry>

            <entry><constant>NULL</constant></entry>

            <entry><constant>NULL</constant></entry>

            <entry>Media dei valori non <constant>NULL</constant> della
            colonna. Questo vale <database>SUM</database>(Campo) /
            <database>COUNT</database>(Campo).<footnote>
                <para>Se Campo è un campo di tipo intero,
                <database>AVG</database> è sempre arrotondato verso 0.
                Esempio: 6 <database>INT</database> con somma -11 danno media
                -1, non -2.</para>
              </footnote></entry>
          </row>

          <row>
            <entry><database>LIST</database><footnote>
                <para><database>LIST</database> è stata aggiunta in Firebird
                2.1</para>
              </footnote></entry>

            <entry><constant>NULL</constant></entry>

            <entry><constant>NULL</constant></entry>

            <entry>Stringa ottenuta concatenando i valori non
            <constant>NULL</constant> della colonna separati da
            virgola</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <section id="nullguide-aggrfunc-groupby">
      <title><indexterm>
          <primary>GROUP BY</primary>
        </indexterm><indexterm>
          <primary>Funzioni</primary>

          <secondary>GROUP BY</secondary>
        </indexterm><indexterm>
          <primary>Funzioni</primary>

          <secondary>di aggregazione</secondary>

          <tertiary>GROUP BY</tertiary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>insieme a GROUP BY</secondary>
        </indexterm>La clausola <database>GROUP BY</database></title>

      <para>Una clausola <database>GROUP BY</database> non cambia la logica
      delle funzioni di aggregazione descritta sopra, eccetto che adesso è
      applicata a ciascun gruppo individualmente invece che all'insieme di
      righe risultante nel suo insieme. Supponiamo d'avere una tabella
      Dipendenti con dei campi Dipartimento e Salario che permettono entrambi
      <constant>NULL</constant>, e di lanciare questa query:</para>

      <blockquote id="nullguide-groupby-example-qry">
        <programlisting>SELECT Dipartimento AS DIP, SUM(Salario) AS SOMMA FROM Dipendenti GROUP BY Dipartimento</programlisting>
      </blockquote>

      <para>Il risultato potrebbe essere una cosa del genere (Dipartimento a
      <literal>&lt;null&gt;</literal> può essere in cima o in fondo, dipende
      dalla versione di Firebird):</para>

      <blockquote>
        <screen>DIP                     SOMMA
====== =====================
&lt;null&gt;             219465.19
000                266643.00
100                155262.50
110                130442.81
115              13480000.00
120                   &lt;null&gt;
121                110000.00
123                390500.00</screen>
      </blockquote>

      <para>Notare che chi ha il dipartimento sconosciuto
      (<constant>NULL</constant>) è raggruppata inscieme, sebbene non si possa
      dire che abbiamo davvero lo <emphasis>stesso valore</emphasis> del campo
      Dipartimento. L'alternativa sarebbe stata dare a ciascuno di essi un
      <quote>gruppo</quote> a sé. Non solo questo avrebbe generato un
      grandissimo numero di linee al risultato, ma avrebbe degenerato lo scopo
      del <emphasis>raggruppare</emphasis>: quelle linee non sarebbero un
      raggruppamento, ma semplicemente <quote><database>SELECT</database>
      Dipartimento, Salario</quote>. Pertanto ha senso raggruppare i
      dipartimenti a <constant>NULL</constant> secondo il loro stato e gli
      altri secondo il loro valore.</para>

      <para>Comunque, non è questo che interessa maggiormente. Che cosa ci
      dice la colonna <database>SUM</database>? Forse che tutti i salari sono
      diversi da <constant>NULL</constant>, eccetto nel dipartimento 120? No.
      Quel che si può dire è che tranne nel dipartimento 120, c'è nel database
      almeno un dipendente con salario noto. Ogni dipartimento
      <emphasis>può</emphasis> avere salari a <constant>NULL</constant>; nel
      120 <emphasis>tutti</emphasis> i salari sono
      <constant>NULL</constant>.</para>

      <para>Per saperne di più, aggiungendo una o più colonne
      <database>COUNT</database>(). Per sapere ad esempio il numero dei salari
      a <constant>NULL</constant> in ciascun gruppo si aggiunge una colonna
      <quote>COUNT(*)</quote> oppure <quote>COUNT(Salary)</quote>.</para>

      <section id="nullguide-aggrfunc-freq">
        <title>Countare le frequenze</title>

        <para>Una clausola <database>GROUP BY</database> può essere usata per
        trovare le frequenze con cui i valori ricorrono in una tabella. In
        questo caso si usa lo stesso nome campo più volte nella query. Con una
        tabella <database>TT</database> che ha una colonna
        <database>A</database> i cui valori sono { 3, 8,
        <constant>NULL</constant>, 6, 8, -1, <constant>NULL</constant>, 3, 1
        }. Per avere la lista delle frequenze, si può fare:</para>

        <blockquote>
          <programlisting>SELECT A, COUNT(A) FROM TT GROUP BY A</programlisting>
        </blockquote>

        <para>che dà il seguente risultato:</para>

        <blockquote>
          <screen>           A        COUNT
============ ============
          -1            1
           1            1
           3            2
           6            1
           8            2
      &lt;null&gt;            0</screen>
        </blockquote>

        <para>Oh! Qualcosa non va col conteggio dei <constant>NULL</constant>,
        ma perchè? Rivediamo:
        <function>COUNT(<parameter>Nomecampo</parameter>)</function> salta
        tutti i campi a <constant>NULL</constant>, pertanto con
        <function>COUNT(<parameter>A</parameter>)</function> il conteggio del
        gruppo <literal>&lt;null&gt;</literal> può essere solo 0! Riformulando
        la query in questo modo:</para>

        <blockquote>
          <programlisting>SELECT A, COUNT(*) FROM TT GROUP BY A</programlisting>
        </blockquote>

        <para>e si otterrà il valore corretto (nel caso 2).</para>
      </section>
    </section>

    <section id="nullguide-aggrfunc-having">
      <title><indexterm>
          <primary>HAVING</primary>
        </indexterm><indexterm>
          <primary>Funzioni</primary>

          <secondary>HAVING</secondary>
        </indexterm><indexterm>
          <primary>Funzioni</primary>

          <secondary>di aggregazione</secondary>

          <tertiary>HAVING</tertiary>
        </indexterm>La clausola <database>HAVING</database></title>

      <para>La clausola <database>HAVING</database> può aggiungere restrizioni
      ad una query con aggregati, così come la <database>WHERE</database> fa
      nelle query record per record. La clausola <database>HAVING</database>
      impone condizioni su ogni colonna del risultato o combinazioni di
      colonne, che siano aggregate o meno.</para>

      <para>Per quanto riguarda i <constant>NULL</constant>, vanno tenuti ben
      presenti i seguenti due fatti (e credo di non meravigliare nessuno
      ormai):</para>

      <itemizedlist>
        <listitem>
          <para>Le righe per le quali la condizione di
          <database>HAVING</database> risolve a <constant>NULL</constant> non
          sono incluse nel risultato finale. (<quote>Va bene solo il
          <constant>true</constant>.</quote>)</para>
        </listitem>

        <listitem>
          <para><quote><database>HAVING</database>
          <replaceable>&lt;col&gt;</replaceable> <database>IS [NOT]
          NULL</database></quote> è una condizione lecita e spesso utile,
          indipendentemente dal fatto che
          <replaceable>&lt;col&gt;</replaceable> sia raggruppata o meno. (Se
          <replaceable>&lt;col&gt;</replaceable> non è aggregata, si può
          risparmiare un po' di lavoro al server c<database>ambiando
          HAVING</database> in <database>WHERE</database> e mettendolo nelle
          condizioni prima del <quote><database>GROUP BY</database></quote>.
          Questo vale per tutte le condizioni su colonne non di
          aggregazione.)</para>
        </listitem>
      </itemizedlist>

      <para>Aggiungendo ad esempio la seguente clausola alla <link
      linkend="nullguide-groupby-example-qry">query d'esempio</link> del
      paragrafo <quote><database>GROUP BY</database></quote>:</para>

      <blockquote>
        <programlisting>...HAVING Dipartimento IS NOT NULL</programlisting>
      </blockquote>

      <para>si impedisce alla prima riga di essere stampata, mentre con
      quest'altra:</para>

      <blockquote>
        <programlisting>...HAVING SUM(Salario) IS NOT NULL</programlisting>
      </blockquote>

      <para>sopprima la sesta riga (quella del Dipartimento = 120).</para>
    </section>
  </section>

  <section id="nullguide-conditionals-loops">
    <title>Frasi condizionali e cicliche</title>

    <section id="nullguide-if">
      <title><indexterm>
          <primary>IF</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle frasi IF</secondary>
        </indexterm><constant>NULL</constant> negli statement di
      <database>IF</database></title>

      <para>Se l'espressione di test di uno statement <database>IF</database>
      risolve a <constant>NULL</constant>, la clausola
      <database>THEN</database> viene saltata e la parte
      <database>ELSE</database> (se presente) viene eseguita. In altre parole,
      <constant>NULL</constant> e <constant>false</constant> di comportano
      allo stesso modo in questo contesto, pertanto nelle situazioni in cui si
      attende <constant>false</constant> ma arriva <constant>NULL</constant>,
      non ci sono problemi. Però abbiamo già visto esempi di
      <constant>NULL</constant> arrivati al posto di <constant>true</constant>
      e quindi possono succedere cose strane perchè questo modificherebbe
      <emphasis>completamente</emphasis> il funzionamento del
      programma!</para>

      <para>Gli esempi seguenti mostrano alcuni fra i diabolici (e quindi
      perfettamente logici) effetti del <constant>NULL</constant> negli
      statement di <database>IF</database>.</para>

      <tip>
        <para>Usando Firebird 2 o successivi, si possono raggirare tutte le
        trappole di cui qui stiamo parlando, semplicemente usando l'opratore
        <database>[NOT] DISTINCT</database> invece di
        <quote><literal>=</literal></quote> e
        <quote><literal>&lt;&gt;</literal></quote> !</para>
      </tip>

      <itemizedlist>
        <listitem>
          <para><programlisting>if (a = b) then
  Variabile = 'uguali';
else
  Variabile = 'diversi';</programlisting></para>

          <para>Se <varname>a</varname> e <varname>b</varname> sono entrambi
          <constant>NULL</constant>, la <varname>Variabile</varname> sarà
          <quote><literal>diversi</literal></quote> dopo aver eseguito il
          codice. La ragione è che l'espressione <quote><literal>a =
          b</literal></quote>, come abbiamo visto precedentemente, vale
          <constant>NULL</constant> se almeno uno dei termini è
          <constant>NULL</constant>. Con l'espressione di test che vale
          <constant>NULL</constant>, il blocco <literal>then</literal> non
          viene eseguito, ed invece viene eseguito il blocco
          <literal>else</literal>.</para>
        </listitem>

        <listitem>
          <para><programlisting>if (a &lt;&gt; b) then
  Variabile = 'diversi';
else
  Variabile = 'uguali';</programlisting></para>

          <para>In questo caso, <varname>Variabile</varname> diventerà
          <quote><literal>uguali</literal></quote> se <varname>a</varname>
          vale <constant>NULL</constant> ed invece <varname>b</varname> no,
          oppure viceversa. La spiegazione è analoga a quella dell'esempio
          precedente.</para>
        </listitem>
      </itemizedlist>

      <para>Allora come si può mettere in piedi un test di egualglianza che
      dia <emphasis>effettivamente</emphasis> il risultato aspettato in tutti
      i casi, anche con operandi a <constant>NULL</constant>? In Firebird 2
      abbiamo già visto che si può usare <database>DISTINCT</database> (in
      <link linkend="nullguide-langelem-distinct"><citetitle>Controllare la
      diversità (Firebird 2+)</citetitle></link>). Nelle precedenti versioni
      bisogna scrivere un po' di codice. Questo è mostrato nella sezione <link
      linkend="nullguide-testing-equality"><citetitle>Controlli di
      eguaglianza</citetitle></link>, più avanti. Per ora è sufficiente
      ricordare che bisogna andare con i piedi di piombo con gli
      <database>IF</database> nei condizionali se possono trasformarsi in
      <constant>NULL</constant>.</para>

      <para>Altro aspetto da non scordare: un'espressione di controllo a
      <constant>NULL</constant> può <emphasis>comportarsi</emphasis> come un
      <constant>false</constant> in una <database>IF</database>, ma
      <emphasis>non vale</emphasis> <constant>false</constant>. È sempre ed
      ancora <constant>NULL</constant>, ciò significa che la sua negazione è
      ancora (oibò!) <constant>NULL</constant> e non
      <quote><constant>true</constant></quote>. Come conseguenza, negare
      l'espressione di controllo e contemporaneamente scambiare le parti
      <database>THEN</database> ed <database>ELSE</database> fra loro può
      cambiare il comportamento dello statement <database>IF</database>. Nella
      logica binaria, dove esistono solo <constant>true</constant> e
      <constant>false</constant>, una cosa del genere non potrebbe mai
      accadere.</para>

      <para>Per mostrare questo fatto, riformuliamo l'ultimo esempio in questo
      modo:</para>

      <itemizedlist>
        <listitem>
          <para><programlisting>if (not (a &lt;&gt; b)) then
  Variabile = 'uguali';
else
  Variabile = 'diversi';</programlisting></para>

          <para>Nella versione originale, se un operando fosse stato
          <constant>NULL</constant> e l'altro no (quindi intuitivamente
          diversi) il risultato sarebbe stato
          <quote><literal>uguali</literal></quote>. Qui invece è
          <quote><literal>diversi</literal></quote>. Spiegazione: un operando
          è <constant>NULL</constant>, pertanto <quote><literal>a &lt;&gt;
          b</literal></quote> è <constant>NULL</constant>, pertanto
          <quote><literal>not(a &lt;&gt; b)</literal></quote> è ancora
          <constant>NULL</constant>, e quindi viene eseguito
          l'<database>ELSE</database>. Ma non c'è modo di gioire del fatto che
          questo risultato è corretto mentre il precedente non lo era: in
          questa versione riformulata, il risultato è
          <quote><literal>diversi</literal></quote> se sono entrambi
          <constant>NULL</constant>, mentre la versione originale almeno
          questo lo <quote>imbroccava</quote> giusto.</para>
        </listitem>
      </itemizedlist>

      <para>Naturalmente, finchè nessuno dei due operandi nell'espressione di
      test rischia di essere <constant>NULL</constant>, si possono fare gli
      <database>IF</database> come sopra. Inoltre, negando il test e
      contemporaneamente scambiando <database>le parti THEN</database> e
      <database>ELSE</database> continua a funzionare giusto, per quanto
      complessa sia la frase, finchè restano diversi da
      <constant>NULL</constant> gli operandi. È tremendamente perfido quel che
      succede quando gli operandi sono <emphasis>quasi sempre</emphasis>
      diversi da <constant>NULL</constant>, cosicchè nella stragran
      maggioranza dei casi fila tutto liscio, In queste situazioni, qualche
      raro <constant>NULL</constant> vagante può rimanere nascosto per molto
      tempo, rovinando i dati silenziosamente.</para>
    </section>

    <section id="nullguide-case">
      <title><indexterm>
          <primary>CASE</primary>
        </indexterm><database>Le frasi con CASE</database></title>

      <para>Firebird ha introdotto il costrutto <database>CASE</database>
      nella versione 1.5, con due varianti sintattiche. La prima, detta
      <firstterm>sintassi semplice</firstterm>;</para>

      <blockquote>
        <programlisting>case &lt;espressione&gt;
  when &lt;espr1&gt; then &lt;valore1&gt;
  when &lt;espr2&gt; then &lt;valore2&gt;
  ...
  [else &lt;valoredefault&gt;]
end</programlisting>
      </blockquote>

      <para>Questa funziona più o meno come il <code>case</code> del Pascal o
      lo <code>switch</code> del C:
      l'<replaceable>&lt;espressione&gt;</replaceable> viene confrontata con
      <replaceable>&lt;espr1&gt;</replaceable>,
      <replaceable>&lt;espr2&gt;</replaceable> ecc., finchè non viene trovata
      una corrispondenza, nel qual caso viene riportato il valore associato.
      Se non c'è corrispondenza e c'è la clausola <database>ELSE</database>,
      si riporta il <replaceable>&lt;valoredefault&gt;</replaceable>. Se manca
      anche la clausola <database>ELSE</database>, il valore è un bel
      <constant>NULL</constant>.</para>

      <para>Importante è sapere che i confronti sono fatti proprio con
      l'operatore <quote><literal>=</literal></quote>, per cui se
      <replaceable>&lt;espressione&gt;</replaceable> è
      <constant>NULL</constant>, ignora tutte le
      <replaceable>&lt;esprN&gt;</replaceable>. In questo caso, per avere un
      risultato non nullo, bisogna adoperare la clausola
      <database>ELSE</database>.</para>

      <para>Ad ogni modo, è corretto specificare <constant>NULL</constant> (o
      una qualsiasi espressione valida che possa valere
      <constant>NULL</constant>) per il valore risultante.</para>

      <para>La seconda sintassi, o <firstterm>sintassi
      analitica</firstterm>:</para>

      <blockquote>
        <programlisting>case
  when &lt;condizione1&gt; then &lt;valore1&gt;
  when &lt;condizione2&gt; then &lt;valore2&gt;
  ...
  [else &lt;valoredefault&gt;]
end</programlisting>
      </blockquote>

      <para>Qui, le varie <replaceable>&lt;condizioneN&gt;</replaceable> sono
      confronti che possono dare uno dei tre possibili risultati:
      <constant>true</constant>, <constant>false</constant>, oppure
      <constant>NULL</constant>. Ancora una volta, solo
      <constant>true</constant> va bene, per cui una condizione come <quote>A
      = 3</quote> o perfino <quote>A = null</quote> non viene soddisfatta
      quando A è <constant>NULL</constant>. Ricordando che <quote><database>IS
      [NOT] NULL</database></quote> non riporta mai <constant>NULL</constant>,
      se A è <constant>NULL</constant>, la condizione <quote>A is null</quote>
      riporta <constant>true</constant> ed il corrispondente
      <replaceable>&lt;valoreN&gt;</replaceable> viene riportato. In Firebird
      2+ si può usare anche <quote><database>IS [NOT] DISTINCT
      FROM</database></quote> nelle condizioni, in quanto anche questo
      operatore non riporta mai <constant>NULL</constant>.</para>
    </section>

    <section id="nullguide-while">
      <title><indexterm>
          <primary>WHILE</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle frasi cicliche WHILE</secondary>
        </indexterm>Le cicliche <database>WHILE</database></title>

      <para>Quando si valuta la condizione di una ciclica
      <database>WHILE</database>, <constant>NULL</constant> si comporta come
      in una frase <database>IF</database>: se la condizione risolve a
      <constant>NULL</constant>, non si rientra nel ciclo, come se fosse
      <constant>false</constant>. Ancora una volta, vediamo cosa succede con
      l'inverso, cioè usando <database>NOT</database>. In una condizione
      come</para>

      <blockquote>
        <programlisting>while ( Contatore &gt; 12 ) do</programlisting>
      </blockquote>

      <para>che salterebbe tutto il blocco del ciclo se Contatore è
      <constant>NULL</constant>, negandola con</para>

      <blockquote>
        <programlisting>while ( not Contatore &gt; 12 ) do</programlisting>
      </blockquote>

      <para>farà lo stesso. Può essere che entrambe le situazioni vadano nel
      verso desiderato, solo che è neccessario essere informati del fatto che
      questi controlli apparentemente complementari in realtà si comportano
      allo stesso modo.</para>
    </section>

    <section id="nullguide-for">
      <title><indexterm>
          <primary>FOR</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle frasi cicliche FOR</secondary>
        </indexterm>Le cicliche <database>FOR</database></title>

      <para>Per evitare ogni possibile confusione, bisogna evidenziare che i
      cicli di <database>FOR</database> nel PSQL di Firebird hanno una
      funzione completamente diversa dai cicli di <database>WHILE</database>,
      o dai cicli di <emphasis role="bold"><code>for</code></emphasis> nei
      linguaggi di programmazione in generale. Il ciclo di
      <database>FOR</database> in Firebird ha la forma:</para>

      <blockquote>
        <programlisting>for <replaceable>&lt;select-statement&gt;</replaceable> into <replaceable>&lt;var-list&gt;</replaceable> do <replaceable>&lt;code-block&gt;</replaceable></programlisting>
      </blockquote>

      <para>ed esegue il blocco di codice tante volte quante sono le righe
      lette attraverso la SELECT. Continua finchè non vengono lette tutte le
      righe, a meno che non intervenga una eccezione oppure uno statement tipo
      <database>BREAK</database>, <database>LEAVE</database> or
      <database>EXIT</database>. Leggere un <constant>NULL</constant>, o una
      riga di campi tutti a <constant>NULL</constant>,
      <emphasis>non</emphasis> ferma il ciclo!</para>
    </section>
  </section>

  <section id="nullguide-keys">
    <title><indexterm>
        <primary>Chiavi</primary>
      </indexterm><indexterm>
        <primary>Indici</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>nelle chiavi</secondary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>negli indici</secondary>
      </indexterm>Chiavi ed indici univoci</title>

    <!--Da fare in seguito: cambiare in "Chiavi ed indici" aggiungendo una sottosezione sugli indici in generale?-->

    <section id="nullguide-keys-pk">
      <title><indexterm>
          <primary>Primarie</primary>

          <secondary>chiavi</secondary>
        </indexterm><indexterm>
          <primary>Chiavi</primary>

          <secondary>primarie</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle chiavi primarie</secondary>
        </indexterm>Le chiavi primarie</title>

      <para>I <constant>NULL</constant> non sono mai permessi nelle chiavi
      primarie. Una colonna che sia (parte di) una chiave primaria
      (<firstterm>primary key</firstterm> o PK) deve essere definita come
      <database>NOT NULL</database> o nella colonna stessa o nella definizione
      del dominio. Notare che un vincolo <quote><database>CHECK (XXX IS NOT
      NULL)</database></quote> non funziona: è proprio necessaria la specifica
      <database>NOT NULL</database> subito dopo il tipo di dato.</para>

      <warning>
        <para>Firebird 1.5 ha un problema che permette la definizione di
        chiavi primarie su colonne <database>NOT NULL</database> che possono
        contenere valori <constant>NULL</constant>. Come questo possa
        succedere, e ci possano essere <constant>NULL</constant> in colonne
        del genere lo spieghiamo più avanti.</para>
      </warning>
    </section>

    <section id="nullguide-keys-uk">
      <title><indexterm>
          <primary>Chiavi</primary>

          <secondary>univoche</secondary>
        </indexterm><indexterm>
          <primary>Univoche</primary>

          <secondary>chiavi</secondary>
        </indexterm><indexterm>
          <primary>Indici</primary>

          <secondary>univoci</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle chiavi e negli indici univoci</secondary>
        </indexterm>Chiavi ed indici univoci</title>

      <section>
        <title>Firebird 1.0</title>

        <para>In Firebird 1.0, le <emphasis>chiavi</emphasis> univoche sono
        soggette alle stesse restrizioni delle chiavi primarie: la colonna o
        le colonne che ne fanno parte devono essere definite come
        <database>NOT NULL</database>. Per gli <emphasis>indici</emphasis>
        univoci, questo non è necessario. Tuttavia, quando viene creato un
        indice univoco, la tabella non deve contenere nè
        <constant>NULL</constant> o valori duplicati nei campi coinvolti,
        altrimenti la creazione dell'indice fallisce. Una volta creato,
        risulta impossibile inserire <constant>NULL</constant> o valori
        duplicati.</para>
      </section>

      <section>
        <title>Firebird 1.5 e successivi</title>

        <para>Da Firebird 1.5, lke chiavi univoche e gli indici univoci non
        solo permettono i <constant>NULL</constant>, ma perfino permettono
        <constant>NULL</constant> molteplici. Con una chiave o un indice di
        una sola colonna, si possono iserire quanti <constant>NULL</constant>
        si vuole in quella colonna, ovviamente ogni valore non
        <constant>NULL</constant> si può inserirer solo una volta.</para>

        <para>Se la chiave o l'indice risulta definita su più di una colonna
        in Firebird 1.5 e successivi:</para>

        <itemizedlist>
          <listitem>
            <para>Si possono inserire più righe dove tutte le colonne della
            chiave o indice sono <constant>NULL</constant>;</para>
          </listitem>

          <listitem>
            <para>Non appena uno o più colonne della chiave non sono
            <constant>NULL</constant>, ogni combinazioni di valori diversi da
            <constant>NULL</constant> deve essere univoca nella tabella.
            Ovviamente va compreso che (1, <constant>NULL</constant>) non è la
            stessa cosa di (<constant>NULL</constant>, 1).</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="nullguide-keys-fk">
      <title><indexterm>
          <primary>Chiavi</primary>
        </indexterm><indexterm>
          <primary>Chiavi</primary>

          <secondary>esterne</secondary>
        </indexterm><indexterm>
          <primary>Chiavi esterne</primary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>nelle chiavi esterne</secondary>
        </indexterm>Le chiavi esterne</title>

      <para>Le chiavi esterne in quanto tali non impongono restrizioni ai
      <constant>NULL</constant>. Le colonne delle chiavi esterne devono sempre
      riferirsi a colonne (o insiemi di colonne) che sono chiavi primarie o
      univoche. Un indice univoco con la colonna o le colonne riferite non è
      sufficiente.</para>

      <note>
        <para>Nelle versioni fino alla 2.0 inclusa, cercando di creare una
        chiave esterna su una destinazione che non è chiave primaria nè una
        chiave univoca, Firebird lamenta il fatto che non ci riesce a trovare
        nessun <emphasis>indice</emphasis> univoco anche se un tale indice
        esiste. In Firebird 2.1, il messaggio correttamente informa che non vi
        esiste nessuna <emphasis>chiave</emphasis> univoca o primaria.</para>
      </note>

      <para>Ad ogni modo, anche se i <constant>NULL</constant> sono
      assolutamente proibiti nella chiave di destinazione (per esempio quando
      sono verso chiavi primarie), una qualsiasi colonna appartenente ad una
      chiave esterna può acora contenere <constant>NULL</constant>, a meno che
      non sia impedito da vincoli addizionali.</para>
    </section>
  </section>

  <section id="nullguide-check-constraints-it">
    <title><indexterm>
        <primary>CHECK</primary>

        <secondary>vincoli di controllo</secondary>
      </indexterm><indexterm>
        <primary>vincoli di controllo</primary>
      </indexterm><indexterm>
        <primary>vincoli di CHECK</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>nei vincoli di CHECK</secondary>
      </indexterm><database>Vincoli di controllo (CHECK</database>
    constraints)</title>

    <para>È stato spesso detto in questa guida che quando un'espressione di
    confronto riporta <constant>NULL</constant>, ha lo stesso effetto di
    <constant>false</constant>: la condizione non è cioè soddisfatta. A
    partire da Firebird 2, questo <emphasis role="bold">noè più
    vero</emphasis> per i vincoli di controllo, cioè i
    <quote><database>CHECK</database> constraint</quote>. Per conformità allo
    standard SQL, un vincolo di <database>CHECK</database> adesso <emphasis
    role="bold">è soddisfatto</emphasis> se la condizione vale
    <constant>NULL</constant>. Solo un vero e proprio
    <constant>false</constant> provoca un rigetto del dato immesso.</para>

    <para>In pratica, questo signica che controlli come</para>

    <blockquote>
      <programlisting>check ( value &gt; 10000 )</programlisting>

      <programlisting>check ( upper( value ) in ( 'A', 'B', 'X' ) )</programlisting>

      <programlisting>check ( value between 30 and 36 )</programlisting>

      <programlisting>check ( ColA &lt;&gt; ColB )</programlisting>

      <programlisting>check ( Comune not like 'Mila%' )</programlisting>
    </blockquote>

    <para>...non accettano un dato <constant>NULL</constant> in Firebird 1.5,
    ma lo fanno passare in Firebird 2. Gli script di creazione per database
    già esistenti hanno bisogno di essere attentamente riesaminati prima di
    riusarli in Firebird 2. Bisogna riadattarli nel caso in cui un dominio o
    una colonna non ha un vincolo <database>NOT NULL</database>, e il relativo
    c<database>ontrollo di CHECK</database> può diventare
    <constant>NULL</constant>, il che succede spesso ma non esclusivamente
    quando il dato in ingresso è <constant>NULL</constant>. Il vincolo di
    controllo può essere ad esempio esteso così:</para>

    <blockquote>
      <programlisting>check ( value &gt; 10000 <emphasis role="bold">and value is not null</emphasis> )</programlisting>

      <programlisting>check ( Comune not like 'Mila%' <emphasis role="bold">and Comune is not null</emphasis> )</programlisting>
    </blockquote>

    <para>Tuttavia, è più semplice e più chiaro aggiungere un <database>NOT
    NULL</database> alla definizione del dominio o della colonna:</para>

    <blockquote>
      <programlisting>create domain DSTIPENDIO int <emphasis role="bold">not null</emphasis> check ( value &gt; 10000 )</programlisting>

      <programlisting>create table Luoghi
(
  Comune varchar(24) <emphasis role="bold">not null</emphasis> check ( Comune not like 'Mila%' ),
  ...
)</programlisting>
    </blockquote>

    <para>Se gli script o i database devono funzionare in modo consistente in
    tutti i server vecchi e nuovi, bisogna fare in modo da evitare che
    qualsiasi <database>vincolo di CHECK</database> possa trasformarsi in
    <constant>NULL</constant>. Si può aggiungere <quote><code>or ... is
    null</code></quote> per permettere un <constant>NULL</constant> in input
    nelle versioni più vecchie. Si può aggiungere un vincolo di <database>NOT
    NULL</database> oppure restrizioni come <quote><code>and ... is not
    null</code></quote> per impedirne l'accettazione esplicitamente nelle
    versioni di Firebird più recenti.</para>
  </section>

  <section id="nullguide-select-distinct">
    <title><database><indexterm>
        <primary>DISTINCT</primary>

        <secondary>SELECT DISTINCT</secondary>
      </indexterm><indexterm>
        <primary>SELECT DISTINCT</primary>
      </indexterm>SELECT DISTINCT</database></title>

    <para>Una frase del tipo <database>SELECT DISTINCT</database> considera
    tutti i <constant>NULL</constant> uguali fra loro (<database>vale a dire
    che sono NOT DISTINCT FROM</database> l'uno dall'altro), cosicchè se la
    selezione è su una sola colonna, al massimo può riportare solo un
    <constant>NULL</constant>.</para>

    <para>Come già detto, Firebird 2.0 ha un problema legato alla direttiva
    <database>NULLS FIRST|LAST</database> che non funziona in certi casi con
    il <database>SELECT DISTINCT</database>. Per maggiori dettagli si può
    vedere nella <link linkend="nullguide-bugs-select-distinct-it">lista dei
    problemi</link>.</para>
  </section>

  <section id="nullguide-udfs-it">
    <title><indexterm>
        <primary>UDF</primary>
      </indexterm><indexterm>
        <primary>Funzioni definite dall'utente</primary>

        <secondary>UDF</secondary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>nelle UDF</secondary>
      </indexterm>Funzioni definite dall'utente (UDF)</title>

    <para>Le <firstterm>funzioni definite dell'utente</firstterm>, o
    <firstterm>UDF</firstterm> (<firstterm>User Defined Functions</firstterm>)
    sono funzioni che non sono interne al motore, ma definite in moduli
    separati. Firebird arriva con due librerie UDF: <systemitem
    class="library">ib_udf</systemitem> (ampiamente usata dai tempi di
    InterBase) e <systemitem class="library">fbudf</systemitem>. Si possono
    aggiungere altre librerie, comprandole o scaricandole da internet, oppure
    scrivendosele in un qualche linguaggio di programmazione idoneo. Le UDF
    non possono essere usate così come sono; devono essere prima
    <quote>dichiarate</quote> al database. Questo è vero anche per le UDF che
    vengono con Firebird.</para>

    <section id="nullguide-udfs-conversions">
      <title><indexterm>
          <primary>UDF</primary>

          <secondary>conversioni indesiderate</secondary>
        </indexterm><indexterm>
          <primary>Conversioni</primary>

          <secondary>indesiderate</secondary>
        </indexterm>Conversioni <constant>NULL</constant>
      <literal>&lt;–&gt;</literal> non-<constant>NULL</constant> non
      richieste</title>

      <para>Non fa parte degli scopi di questa guida insegnare, usare o
      scrivere le UDF. Tuttavia è necessario avvertire che le UDF possono
      occasionalmente effettuare inaspettatamente delle conversioni da e verso
      <constant>NULL</constant>. Questo comporta che alle volte un
      <constant>NULL</constant> in input possa essere convertito in un valore
      regolare particolare, ed altre volte che un valore valido come una
      stringa vuota venga <constant>null</constant>ificato.</para>

      <para>La causa principale di questo problema è che il modo di chiamare
      le UDF di <quote>vecchio tipo</quote> (ereditata da Interbase) non è in
      grado di passare un <constant>NULL</constant> in input ad una funzione.
      Quando una funzione UDF quale ad esempio <function>LTRIM</function>
      (elimina gli spazi eccedenti a sinistra) viene chiamata con un argomento
      <constant>NULL</constant>, l'argomento viene passato alla funzione come
      una stringa vuota. (Nota: in Firebird 2 e successivi,
      <emphasis>può</emphasis> essere passata come un puntatore nullo; ma ci
      ritorniamo più oltre). Dall'interno della funzione <emphasis>non esiste
      nessun modo</emphasis> per determinare se l'argomento è veramente una
      stringa vuota oppure un <constant>NULL</constant>. Pertanto che dovrebe
      fare chi scrive la routine? Deve fare una scelta: o prendere il valore
      come gli arriva o assumere che fosse originariamente un
      <constant>NULL</constant> e trattarlo di conseguenza.</para>

      <para>Se il tipo risultato di una funzione è un puntatore, è possibile
      ottenere <constant>NULL</constant> da una funzione anche se non è
      possibile passarglielo. A tal punto che potrebbero accadere i seguenti
      fenomeni inattesi:</para>

      <itemizedlist>
        <listitem>
          <para>Si chiama una UDF con un argomento a
          <constant>NULL</constant>. Viene passato alla funzione con un
          valore, cioè 0 oppure <literal>''</literal>. All'interno della
          funzione questo valore non è ricambiato in
          <constant>NULL</constant>; pertanto viene riportato un risultato
          non-<constant>NULL</constant>.</para>
        </listitem>

        <listitem>
          <para>Si chiama una UDF con un argomento valido come 0 oppure
          <literal>''</literal>, questo viene passato come è, ovviamente. Ma
          il codice della funzione suppone che sia invece la rappresentazione
          di un <constant>NULL</constant>, lo tratta come un buco nero, e
          riporta al chiamante un <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>

      <para>Entrambe le conversioni sono normalmente indesiderate, ma la
      seconda probabilmente lo è di più della prima (è meglio validare
      qualcosa che è NULL piuttosto che NULLificare qualcosa di valido). Per
      tornare al nostro esempio della <function>LTRIM</function>: in Firebird
      1.0 questa funzione riporta <constant>NULL</constant> per una stringa
      vuota, che è sbagliato; nella versione 1.5, non riporta mai
      <constant>NULL</constant>: in questa versione, anche le stringhe
      <constant>NULL</constant> sono cambiate in stringhe vuote. Intediamoci,
      pure questo è sbagliato, ma è considerato il minore dei due mali. In
      Firebird 2 finalmente funziona bene: una stringa NULL dà un risultato
      NULL, una stringa vuota viene ridotta ad una stringa vuota, semprechè si
      dichiari la funzione nella giusta maniera.</para>
    </section>

    <section id="nullguide-udfs-descriptors">
      <title><indexterm>
          <primary>UDF</primary>

          <secondary>per descrittore</secondary>
        </indexterm><indexterm>
          <primary>Descrittori</primary>
        </indexterm>Descrittori</title>

      <para>Fin da Firebird 1.0, è stato introdotto un nuovo metodo di passare
      gli argomenti ed i risultati con le UDF: <quote>per descrittore</quote>.
      I descrittori permettono di segnalare la presenza di un
      <constant>NULL</constant> indipendentemente dal tipo di dato. La
      libreria <systemitem class="library">fbudf</systemitem> fa ampio uso di
      questa tecnica. Sfortunatamente, usare i descrittori è un po'
      complicato; è necessario più lavoro ed è men o piacevole per lo
      sviluppatore dell'UDF. D'altra parte si è in grado di risolvere tutti i
      tradizionali problemi legati al <constant>NULL</constant>, e per il
      chiamante è semplice come per le UDF standard di vecchio stile.</para>
    </section>

    <section id="nullguide-udfs-fb2-impr">
      <title><indexterm>
          <primary>UDF</primary>

          <secondary>con parola chiave NULL</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>parola chiave NULL nelle UDF</secondary>
        </indexterm><indexterm>
          <primary>NULL come parola chiave nelle UDF</primary>
        </indexterm>Miglioramenti di Firebird 2</title>

      <para>Firebird 2 ha migliorato il sistema di chiamare le UDF di vecchio
      tipo. Il sistema adesso passa un <constant>NULL</constant> di input alla
      funzione come un puntatore nullo, <emphasis role="bold">se</emphasis> la
      funzione è stata dichiarata al database con una parola chiave
      <database>NULL</database> dopo l'argomento in questione:</para>

      <blockquote>
        <programlisting>declare external function ltrim
  cstring(255) <emphasis role="bold">null</emphasis>
  returns cstring(255) free_it
  entry_point 'IB_UDF_ltrim' module_name 'ib_udf';</programlisting>
      </blockquote>

      <para>Questa richiesta assicura che i database esistenti e le loro
      relative applicazioni continuino a funzionare come prima. Omettendo la
      parola chiave <database>NULL</database> la funzione si comporterà
      esattamente come avrebbe fatto in Firebird 1.5.</para>

      <para>Notare che non è sufficiente aggiungere il
      <database>NULL</database> alla dichiarazione e pensare che una qualsiasi
      funzione gestisca correttamente il <constant>NULL</constant> in
      ingresso. Ogni funzione deve essere anche riscritta in modo tale da
      gestire correttamente il <constant>NULL</constant> nel nuovo modo.
      Bisogna sempre osservare le dichiarazioni date dallo sviluppatore della
      funzione. Per le funzioni della libreria <systemitem
      class="library">ib_udf</systemitem>, consultare il file
      <filename>ib_udf2.sql</filename> che è nel sottodirettorio <filename
      class="directory">UDF</filename> di Firebird. Notare il
      <literal>2</literal> nel nome del file; le dichiarazioni vecchio stile
      sono in <filename>ib_udf.sql</filename>.</para>

      <para>Le seguenti funzioni della libreria <systemitem
      class="library">ib_udf</systemitem> sono state aggiornate per
      riconoscere il <constant>NULL</constant> in input e gestirlo in modo
      proprio:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><function>ascii_char</function></para>
        </listitem>

        <listitem>
          <para><function>lower</function></para>
        </listitem>

        <listitem>
          <para><function>lpad</function> e <function>rpad</function></para>
        </listitem>

        <listitem>
          <para><function>ltrim</function> e <function>rtrim</function></para>
        </listitem>

        <listitem>
          <para><function>substr</function> e
          <function>substrlen</function></para>
        </listitem>
      </itemizedlist>

      <para>Molte funzioni <systemitem class="library">ib_udf</systemitem>
      rimangono tali e quali; in ogni caso, passare <constant>NULL</constant>
      ad una UDF di vecchio stile è impossibile se l'argomento non è di tipo
      per riferimento.</para>

      <para>Una nota a latere: è sconsigliato usare le funzioni UDF
      <function>lower</function>, <function>.trim</function> e
      <function>substr*</function> nel nuovo codice; è preferibile invece
      usare le funzioni interne <database>LOWER</database>,
      <database>TRIM</database> e <database>SUBSTRING</database>.</para>

      <section>
        <title><quote>Aggiornare</quote> le funzioni della libreria
        <systemitem class="library">ib_udf</systemitem> in un database
        esistente</title>

        <para>Usando sotto Filrebird 2 una o più funzioni listate sopra con un
        database preesistente, e volendo beneficiare della nuova gestione dei
        <constant>NULL</constant>, bisogna eseguire nel proprio database i
        comandi preparati in <filename>ib_udf_upgrade.sql</filename>. Lo si
        può trovare nella directory di Firebird<filename class="directory">
        misc\upgrade\ib_udf</filename>.</para>
      </section>
    </section>

    <section id="nullguide-udfs-conversions-prepare">
      <title><indexterm>
          <primary>UDF</primary>

          <secondary>conversioni indesiderate</secondary>

          <tertiary>prepararsi a</tertiary>
        </indexterm><indexterm>
          <primary>Conversioni</primary>

          <secondary>indesiderate</secondary>

          <tertiary>prepararsi a</tertiary>
        </indexterm>Prepararsi alle conversioni non desiderate</title>

      <para>Le conversioni non richieste <constant>NULL</constant>
      <literal>&lt;–&gt;</literal> non-<constant>NULL</constant> descritte
      precedentemente normalmente accadono con le UDF compatibili, ma ce ne
      sono molte in giro (sopratutto nella <systemitem
      class="library">ib_udf</systemitem>). Inoltre nulla può fermare un
      programmatore superficiale dal ricadere nello stesso errore in una
      funzione nel nuovo stile. Pertanto il comportamento più sicuro da tenere
      se si usa una UDF e non si conosce come si comporta nei confronti del
      <constant>NULL</constant>:</para>

      <procedure>
        <step>
          <para>guardare alla sua dichiarazione per controllare come sono
          passati e riportati i suoi valori. Se dice <quote>by
          descriptor</quote>, si comporta in modo corretto (sebbene non fa mai
          male assicurarsene). Idem se sono seguiti dalla parola chiave
          <database>NULL</database>. In tutti gli altri casi, verificate i
          passi seguenti.</para>
        </step>

        <step>
          <para>Avendone i sorgenti, e sapendo leggere il linguaggio in cui è
          scritto (C, C++, Delphi,...) controllare cosa fa il codice della
          funzione.</para>
        </step>

        <step>
          <para>Valutare la funzione con valori <constant>NULL</constant> e
          con valori come 0 (per argomenti numerici) e/o <literal>''</literal>
          (per stringhe).</para>
        </step>

        <step>
          <para>Se la funzione effettua una conversione indesiderata
          <constant>NULL</constant> &lt;-&gt; non-<constant>NULL</constant>,
          bisogna girarci intorno nel proprio codice prima di chiamare la UDF
          (vedere anche <citetitle><link
          linkend="nullguide-testing-for-null-it">Come controllare se ci sono
          <constant>NULL</constant></link></citetitle> , altrove in questa
          guida).</para>
        </step>
      </procedure>

      <para>Le dichiarazioni per le UDF rilasciate possono essere trovate nel
      sottodirettorio di Firebird <filename
      class="directory">examples</filename> (per la versione 1.0) oppure
      <filename class="directory">UDF</filename> (dalla versione 1.5 in poi):
      si trovano nei files con estensione <filename
      class="extension">.sql</filename></para>
    </section>

    <section id="nullguide-udfs-links-it">
      <title><indexterm>
          <primary>UDF</primary>

          <secondary>altre informazioni</secondary>
        </indexterm>Altre informazioni sulle UDF</title>

      <para>Per ottenere informazioni più approfondite sulle UDF, si possono
      consultare i documenti (al momento tutti in inglese)
      <citetitle>InterBase 6.0 Developer's Guide</citetitle> (gratuito,
      scaricabile da <ulink
      url="http://www.ibphoenix.com/downloads/60DevGuide.zip">http://www.ibphoenix.com/downloads/60DevGuide.zip</ulink>),
      <citetitle>Using Firebird</citetitle> e la <citetitle>Firebird Reference
      Guide</citetitle> (entrambi su CD), oppure il <citetitle>Firebird
      Book</citetitle>. I CD ed il libro possono essere acquistati attraverso
      <ulink
      url="http://www.ibphoenix.com">http://www.ibphoenix.com</ulink>.</para>
    </section>
  </section>

  <section id="nullguide-conversions">
    <title><indexterm>
        <primary>Conversioni</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>conversioni da e verso</secondary>
      </indexterm>Convertire da e verso <constant>NULL</constant></title>

    <section id="nullguide-subst-with-value">
      <title><indexterm>
          <primary>Conversioni</primary>

          <secondary>da NULL ad un valore</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>conversioni da</secondary>
        </indexterm>Sostituire <constant>NULL</constant> con un valore</title>

      <section id="nullguide-coalesce">
        <title><indexterm>
            <primary>Conversioni</primary>

            <secondary>da NULL ad un valore</secondary>

            <tertiary>COALESCE</tertiary>
          </indexterm><indexterm>
            <primary>COALESCE</primary>
          </indexterm>La funzione <function>COALESCE</function></title>

        <para>In Firebird 1.5 e successivi c'è una funzione che è in grado di
        convertire <constant>NULL</constant> a quasi qualsiasi altra cosa.
        Questo permette di fare una conversione al volo e di usare il
        risultato per ulteriori elaborazioni, senza l'uso del costrutto
        <quote><literal>if (Espressione is null) then</literal></quote>.
        Questa particolare funzione è la <function>COALESCE</function> e si
        usa in questo modo:</para>

        <blockquote>
          <para><literal>COALESCE( Espr1, Espr2, Espr3, ... )</literal></para>
        </blockquote>

        <para><function>COALESCE</function> riporta il valore della prima
        espressione diversa da <constant>NULL</constant> della lista degli
        argomenti. Se tutte le espressioni sono <constant>NULL</constant>, la
        <function>COALESCE</function> riporta
        <constant>NULL</constant>.</para>

        <para>Questo è il modo in cui per esempio si può usare
        <function>COALESCE</function> per ricostruire il nome completo di una
        persona a partire da nome, cognome e titolo, assumendo che talvolta il
        campo Titolo possa essere <constant>NULL</constant>:</para>

        <blockquote>
          <para><programlisting>select coalesce ( Titolo || ' ', '' )
       || Cognome 
       || ' ' || Nome
from Persone</programlisting></para>
        </blockquote>

        <para>Oppure, per creare un nominativo il più informale possibile a
        partire da una tabella che contenga anche i soprannomi, e assumendo
        che possano essere <constant>NULL</constant> sia i soprannomi che i
        nomi:</para>

        <blockquote>
          <para><programlisting>select coalesce (Soprannome, Nome, 'Sig./Sig.ra')
       || ' ' || Cognome
from AltrePersone</programlisting></para>
        </blockquote>

        <para><function>COALESCE</function> può venire in aiuto solo in quelle
        situazioni in cui il valore <constant>NULL</constant> può essere
        gestito allo stesso modo degli altri valori permessi per il tipo di
        dato. Se <constant>NULL</constant> necessità di una gestione
        particolare, diversa da ogni altro valore, l'unica opzione è usare un
        costrutto con <database>IF</database> o con
        <database>CASE</database>.</para>
      </section>

      <section id="nullguide-nvl-it">
        <title><indexterm>
            <primary>Conversioni</primary>

            <secondary>da NULL ad un valore</secondary>

            <tertiary>le funzioni NVL</tertiary>
          </indexterm><indexterm>
            <primary>Funzioni</primary>

            <secondary>NVL</secondary>
          </indexterm>Firebird 1.0: le funzioni
        <function>*NVL</function></title>

        <para>In Firebird 1.0 non c'è la funzione
        <function>COALESCE</function>. Tuttavia si possono usare quattro
        funzioni UDF che permettono una buona parte della sua funzionalità.
        Queste UDF risiedono nella libreria <filename
        class="libraryfile">fbudf</filename> e sono precisamente:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><function>iNVL</function>, per argomenti interi</para>
          </listitem>

          <listitem>
            <para><function>i64NVL</function>, per argomenti bigint</para>
          </listitem>

          <listitem>
            <para><function>dNVL</function>, per argomenti in duplice
            precisione</para>
          </listitem>

          <listitem>
            <para><function>sNVL</function>, per le stringhe</para>
          </listitem>
        </itemizedlist>

        <para>Le funzioni <function><function>*NVL</function></function> hanno
        esattamente due argomenti. Come <function>COALESCE</function>,
        riportano il primo argomento se non è <constant>NULL</constant>;
        altrimenti, riportano il secondo. Notare che in Firebird 1.0 la
        libreria <filename class="libraryfile">fbudf</filename> e pertanto le
        funzioni <function>*NVL</function> sono solo disponibili in ambiente
        Windows.</para>
      </section>
    </section>

    <section id="nullguide-conv-to-null">
      <title><indexterm>
          <primary>Conversioni</primary>

          <secondary>da un valore verso NULL</secondary>
        </indexterm><indexterm>
          <primary>NULL</primary>

          <secondary>conversioni verso</secondary>
        </indexterm>Convertire valori a <constant>NULL</constant></title>

      <para>Talvolta è utile avere certi valori a <constant>NULL</constant> in
      uscita, o cime valori intermedi. Non capita spesso, ma potrebe essere
      utile, per esempio, per escludere certi valori da una sommatoria o da
      una media. Le funzioni <function>NULLIF</function> possono fare questo,
      anche se per un valore alla volta.</para>

      <section>
        <title><indexterm>
            <primary>Conversioni</primary>

            <secondary>da un valore verso NULL</secondary>

            <tertiary>NULLIF funzioni interna</tertiary>
          </indexterm><indexterm>
            <primary>la funzione interna NULLIF</primary>
          </indexterm>Firebird 1.5 e successivi: la funzione
        <function>NULLIF</function></title>

        <para>La funzione interna NULLIF ha due argomenti: se sono uguali, la
        funzione riporta <constant>NULL</constant>. Altrimenti riporta il
        valore del primo argomento.</para>

        <para>Un tipico esempio è</para>

        <blockquote>
          <programlisting>select avg( nullif( Peso, -1 ) ) from Ciccioni</programlisting>
        </blockquote>

        <para>che darà il peso medio della popolazione dei Ciccioni, senza
        contare quelli con peso -1, ricordando che le funzioni di aggregazione
        come <database>AVG</database> escludono dal conteggio tutti i campi a
        <constant>NULL.</constant></para>

        <para>Lavorando un po' su questo esempio, supponiamo che finora si
        fosse usato -1 per indicare <quote>peso sconosciuto</quote> perchè non
        sicuri sull'uso di <constant>NULL</constant>. Dopo aver letto questa
        guida, si sarà pratici abbastanza da dare il comando:</para>

        <blockquote>
          <programlisting>update Ciccioni set Peso = nullif( Peso, -1 )</programlisting>
        </blockquote>

        <para>A questo punto, finalmente i pesi sconosciuti saranno realmente
        <emphasis>sconosciuti</emphasis>.</para>
      </section>

      <section>
        <title><indexterm>
            <primary>Conversioni</primary>

            <secondary>da un valore verso NULL</secondary>

            <tertiary>NULLIF UDF</tertiary>
          </indexterm><indexterm>
            <primary>NULLIF UDF</primary>
          </indexterm><indexterm>
            <primary>UDF</primary>

            <secondary>funzioni NULLIF</secondary>
          </indexterm>Firebird 1.0: Le UDF <function>*nullif</function>
        UDF</title>

        <para>Firebird 1.0.x non ha la funzione interna
        <function>NULLIF</function>. Al suo posto ha quattro funzioni UDF
        nella libreria <filename class="libraryfile">fbudf</filename> per
        ottenere il medesimo obiettivo:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><function>inullif</function>, per argomenti interi</para>
          </listitem>

          <listitem>
            <para><function>i64nullif</function>, per argomenti bigint</para>
          </listitem>

          <listitem>
            <para><function>dnullif</function>, per argomenti in duplice
            precisione (double precision)</para>
          </listitem>

          <listitem>
            <para><function>snullif</function>, per argomenti stringhe</para>
          </listitem>
        </itemizedlist>

        <para>Notare che la libreria di Firebird 1.0 <filename
        class="libraryfile">fbudf</filename> e quindi anche l'insieme di
        funzioni<function>*nullif</function> è disponibile solo in
        Windows.</para>

        <warning>
          <para>Le note di rilascio di Firebird 1 dicono che, a causa di una
          limitazione del sistema, queste UDF riportano un valore equivalente
          a zero se gli argomenti sono identici. Ciò è sbagliato: se gli
          argomenti hanno lo stesso valore, le funzioni riportano un vero e
          proprio <constant>NULL</constant>.</para>

          <para>Notare che riportano <constant>NULL</constant> anche quando il
          primo valore è un valore vero e proprio ed il secondo argomento è
          <constant>NULL</constant>. Questo è un risoltato sbagliato: invece
          le funzioni interne <function>NULLIF</function> di Firebird 1.5
          correttamente riportano il primo argomento.</para>
        </warning>
      </section>
    </section>
  </section>

  <section id="nullguide-alter-pop-tables">
    <title><indexterm>
        <primary>Modifica delle tabelle</primary>
      </indexterm><indexterm>
        <primary>Tabelle</primary>

        <secondary>modifica</secondary>
      </indexterm>Modifica delle tabelle piene di dati</title>

    <para>Se le tabelle contengono già dati, e si desidera aggiungere una
    colonna non null o modificare la annullabilità di una colonna
    preesistente, ci sono alcune conseguenze di cui bisogna tenere conto.
    Nelle prossime sezioni vedremo le varie possibilità in dettaglio.</para>

    <section id="nullguide-add-non-nullable-field">
      <title><indexterm>
          <primary>Aggiungere colonne NOT NULL</primary>
        </indexterm><indexterm>
          <primary>Tabelle</primary>

          <secondary>aggiungere colonne NOT NULL</secondary>
        </indexterm>Aggiungere un campo NOT NULL ad una tabella con dati
      preesistenti</title>

      <para>Supponendo di avere questa tabella:</para>

      <table id="nullguide-tbl-adventures">
        <title>Tabella avventure</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Nome</entry>

              <entry align="center">Data_acquisto</entry>

              <entry align="center">Prezzo</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>Goffredo di Buglione</entry>

              <entry>12-06-1995</entry>

              <entry>€ 49,00</entry>
            </row>

            <row>
              <entry>Giuseppe Garibaldi</entry>

              <entry>19-10-1995</entry>

              <entry>€ 54,95</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In questa tabella di improbabili giochi ci sono già alcune
      registrazioni quando si decide di dover aggiungere un campo ID sempre
      diverso da <constant>NULL</constant>. Ci sono due diverse soluzioni, ma
      ciascuna si porta problemi specifici da valutare.</para>

      <section id="nullguide-add-not-null-field-it">
        <title><indexterm>
            <primary>Aggiungere campi NOT NULL</primary>
          </indexterm><indexterm>
            <primary>Tabelle</primary>

            <secondary>aggiungere campi NOT NULL</secondary>
          </indexterm><indexterm>
            <primary>NOT NULL</primary>

            <secondary>diretto</secondary>
          </indexterm>Aggiungere un campo <database>NOT
        NULL</database></title>

        <para>Questo è il metodo preferito, forse perchè più immediato, ma
        provoca tutta una serie di problemi se usato in una tabella con dati
        già presenti come vedremo. Innazitutto, si supponga di aggiungere un
        campo con il seguente comando:</para>

        <blockquote>
          <programlisting>alter table Avventure add id int not null</programlisting>

          <!--or: ...add id int constraint <name> not null-->
        </blockquote>

        <para><indexterm>
            <primary>NULL</primary>

            <secondary>in campi NOT NULL</secondary>
          </indexterm><indexterm>
            <primary>Backup</primary>
          </indexterm><indexterm>
            <primary>gbak</primary>
          </indexterm><indexterm>
            <primary>Restore</primary>

            <secondary>problemi con i NULL</secondary>
          </indexterm>Dopo la conferma (<database>commit</database>), il nuovo
        campo ID in tutte le righe già esistenti, avrà valore
        <constant>NULL</constant>. In questo caso speciale, Firebird permette
        pertanto la presenza di dati non validi in una colonna <database>NOT
        NULL</database>. Non solo, è in grado di farne il backup senza
        problemi apparenti, ma si rifiuterà di recuperare i dati salvati,
        precisamente perchè essi violano il vincolo <database>NOT
        NULL</database>.</para>

        <note>
          <para>Firebird 1.5 (ma non 1.0 o 2.0) permettono perfino di rendere
          tale colonna una chiave primaria!</para>
        </note>

        <section id="nullguide-nulls-reported-as-zeroes">
          <title><indexterm>
              <primary>NULL</primary>

              <secondary>valorizzato erroneamente come 0</secondary>
            </indexterm>Valorizzazione errata di <constant>NULL</constant>
          come se fosse zero</title>

          <para>A rendere le cose anche peggiori, Firebird mente quando si
          leggono i dati dalla tabella. Con <application>isql</application> e
          molti altri programmi, <quote><database>SELECT * FROM
          AVVENTURE</database></quote> riporta questo insieme di dati:</para>

          <table id="nullguide-tbl-adventures-0">
            <title>Dati riportati dopo aver aggiunto una colonna <database>NOT
            NULL</database></title>

            <tgroup cols="4">
              <thead>
                <row>
                  <entry align="center">Nome</entry>

                  <entry align="center">Data_acquisto</entry>

                  <entry align="center">Prezzo</entry>

                  <entry align="center">ID</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>Goffredo di Buglione</entry>

                  <entry>12-06-1995</entry>

                  <entry>€ 49,00</entry>

                  <entry>0</entry>
                </row>

                <row>
                  <entry>Giuseppe Garibaldi</entry>

                  <entry>19-10-1995</entry>

                  <entry>€ 54,95</entry>

                  <entry>0</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Naturalmente questo farà pensare a molta gente <quote>Ma che
          bello! Firebird usa un default valore di 0 per i nuovi campi: non
          c'è problema allora</quote>. Ma si riesce a verificare che il campo
          ID è veramente tutto a <constant>NULL</constant> con queste
          query:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para><database>SELECT * FROM AVVENTURE WHERE ID = 0</database>
              (non riporta nulla)</para>
            </listitem>

            <listitem>
              <para><database>SELECT * FROM AVVENTURE WHERE ID IS
              NULL</database> (riporta il set visto qui sopra con tutti gli 0
              fasulli)</para>
            </listitem>

            <listitem>
              <para><database>SELECT * FROM AVVENTURE WHERE ID IS NOT
              NULL</database> (non riporta nulla)</para>
            </listitem>
          </itemizedlist>

          <para>Un altro tipo di query che dimostra che qualcosa di strano
          sta' succedendo è la seguente:</para>

          <itemizedlist spacing="compact">
            <listitem>
              <para><database>SELECT NOME, ID, ID+3 FROM
              AVVENTURE</database></para>
            </listitem>
          </itemizedlist>

          <para>Questa query riporta 0 nella colonna <quote>ID+3</quote>. Se
          ci fosse stato un vero e proprio 0 in ID avrebbe dovuto esserci 3.
          Il risultato <emphasis>corretto</emphasis> dovrebbe essere
          <constant>NULL</constant>, naturalmente!</para>

          <para>Con un campo di tipo <database>(VAR)CHAR</database>, si
          avrebbero delle stringhe vuote fasulle (''). Con colonne di tipo
          <database>DATE</database>, ci sarebbero delle <quote>date
          zero</quote> fasulle pure quelle, che indicano il giorno 17 Novembre
          1858. In tutti i casi, il vero valore della data è
          <constant>NULL</constant>.</para>

          <section>
            <title>Spiegazione</title>

            <para>Che cosa succede?</para>

            <para>Quando una applicazione come isql interroga il server, la
            conversazione avviene attraverso un certo numero di passi. Durante
            una di queste, la fase di descrizione – <quote>describe</quote> –
            il sistema informa del tipo e della annullabilità per ogni colonna
            che appare nell'insieme del risultato. Fa questo in una struttura
            che viene succesivamente utilizzata per recuperare il valore
            attuale del dato. Per le colonne che sono marchiate con
            <database>NOT NULL</database> dal server, non c'è alcun modo per
            riportare il <constant>NULL</constant> al client — a meno che il
            client reimposti l'informazione prima di iniziare la fase di
            recupero dei dati. Molte applicazioni client non lo fanno. D'altra
            parte, se il server assicura che una colonna non può contenere
            <constant>NULL</constant>, per quale motivo si dovrebbe pensare di
            saperne di più, e soprassedere alla sua decisione controllando
            comunque i <constant>NULL</constant>? Ma purtroppo è esattamente
            quello che andrebbe fatto se si vuole evitare il rischio di
            riportare valori fasulli agli utenti.</para>
          </section>

          <section>
            <title><indexterm>
                <primary>FSQL</primary>
              </indexterm>FSQL</title>

            <para>L'esperto di Firebird Ivan Prenosil ha scritto un programma
            libero a linea di comando che funziona più o meno come
            <application>isql</application>, che, tra gli altri
            perfezionamenti, riporta i <constant>NULL</constant> correttamente
            anche nelle colonne <database>NOT NULL</database>. Si chiama
            <application>FSQL</application> e lo si può scaricare da:</para>

            <blockquote>
              <para><ulink
              url="http://www.volny.cz/iprenosil/interbase/fsql.htm">http://www.volny.cz/iprenosil/interbase/fsql.htm</ulink></para>
            </blockquote>
          </section>
        </section>

        <section>
          <title>Assicurarsi della validità dei dati</title>

          <para>Per essere sicuri di avere dei dati validi quando si aggiunge
          una colonna <database>NOT NULL</database> ad una tabella con dati
          preesistenti bisogna fare una delle operazioni seguenti:</para>

          <itemizedlist>
            <listitem>
              <para>per impedire il problema delle colonne non null invece che
              null, si può aggiungere un valore di default aggiungendo la
              nuova colonna:</para>

              <blockquote>
                <programlisting>alter table Avventure add id int default -1 not null</programlisting>
              </blockquote>

              <para>I valori di default non sono applicati di solito quando si
              aggiungono campi a righe esistenti, ma lo sono con campi
              <database>NOT NULL</database>.</para>
            </listitem>

            <listitem>
              <para>Altrimenti, si possono assegnare ai nuovi campi i valori
              che dovrebbero avere in modo esplicito, subito dopo aver
              aggiunto la relativa colonna. Si può verificare che sono tutti
              validi con una query <quote><database>SELECT ... WHERE ... IS
              NULL</database></quote>, che dovrebbe riportare un insieme di
              righe vuoto.</para>
            </listitem>

            <listitem>
              <para><indexterm>
                  <primary>gbak</primary>

                  <secondary>switch -n</secondary>
                </indexterm><indexterm>
                  <primary>Restore</primary>

                  <secondary>problemi con i NULL</secondary>

                  <tertiary>soluzione</tertiary>
                </indexterm>Se il danno è stato fatto e ci si ritrova con una
              copia di backup impossibile da recuperare, si può usare la
              variante <parameter>-n</parameter> del programma
              <application>gbak</application> per ignorare i vincoli di
              validità nel restore. Dopodichè è meglio aggiustare i dati ed i
              vincoli manualmente. Di nuovo, si verifica il tutto con una
              query <quote><database>WHERE ... IS
              NULL</database></quote>.</para>
            </listitem>
          </itemizedlist>

          <important>
            <para>Le versioni di Firebird fino alla 1.5.0 inclusa hanno un
            problema che fa rimettere alla <application>gbak</application> i
            vincoli <database>NOT NULL</database> anche specificando il
            <parameter>-n</parameter>. Con tali versioni, se si è fatto un
            backup del database con dati <constant>NULL</constant> in campi
            <database>NOT NULL</database>, si è veramente nei guai. Soluzione:
            installare la versione 1.5.1 o successiva, recuperare i dati con
            gbak <parameter>-n</parameter> e poi aggiustarli.</para>
          </important>
        </section>
      </section>

      <section id="nullguide-add-check-not-null-field-it">
        <title><indexterm>
            <primary>Aggiungere campi CHECK</primary>
          </indexterm><indexterm>
            <primary>Tabelle</primary>

            <secondary>aggiungere campi CHECK</secondary>
          </indexterm>Aggiungere un campo <database>CHECK</database></title>

        <para>Usare un vincolo <database>CHECK</database> è un modo diverso
        per impedire valori <constant>NULL</constant> in una colonna:</para>

        <blockquote>
          <programlisting>alter table Avventure add id int check (id is not null)</programlisting>
        </blockquote>

        <para>Se lo fai in questo modo, una successiva SELECT darà:</para>

        <table id="nullguide-tbl-adventures-null">
          <title>Result set dopo aver aggiunto un campo
          <database>CHECK</database></title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry align="center">Nome</entry>

                <entry align="center">Data_acquisto</entry>

                <entry align="center">Prezzo</entry>

                <entry align="center">ID</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>Goffredo di Buglione</entry>

                <entry>12-06-1995</entry>

                <entry>€ 49,00</entry>

                <entry>&lt;null&gt;</entry>
              </row>

              <row>
                <entry>Giuseppe Garibaldi</entry>

                <entry>19-10-1995</entry>

                <entry>€ 54,95</entry>

                <entry>&lt;null&gt;</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Be', almeno adesso si riesce a vedere che i campi sono
        <constant>NULL</constant>! Firebird non attua i vincoli di
        <database>CHECK</database> sulle righe preesistenti aggiungendo nuovi
        campi. Questo è vero anche aggiungendo controlli a campi esistenti con
        <database>ADD CONSTRAINT</database> o con <database>ADD
        CHECK</database>.</para>

        <para>In questo caso, Firebird non solo tollera la presenza ed il
        backup dei valori <constant>NULL</constant>, ma ne permette pure il
        recupero. Lo strumento <application>gbak</application> di Firebird
        recupera i vincoli di <database>CHECK</database>, ma non li applica ai
        dati esistenti nel backup.</para>

        <note>
          <para>La gbak rimette i vincoli di <database>CHECK</database> anche
          con lo switch <parameter>-n</parameter>. Ma siccome non vengono
          utilizzati ver convalidare i dati di backup, questo non comporterà
          mai errori in fase di recupero.</para>
        </note>

        <para>La recuperabilità dei dati <constant>NULL</constant> nonostante
        la presenza di vincoli <database>CHECK</database> è consistente col
        fatto che Firebird permette loro di essere presenti inizialmente e di
        farne il backup. Da un punto di vista pratico, c'è il rovescio della
        medaglia: si può fare tutto un ciclo di backup e restore con i dati
        <quote>illegali</quote> che sopravvivono senza che neanche se abbia la
        minima notizia o avvertimento. Pertanto: bisogna essere sempre sicuri
        che i dati esistenti siano consistenti con le regole aggiornate subito
        dopo aver aggiunto la nuova colonna con vincoli. Notare che il trucco
        del <quote>default</quote> in questo caso non funzionerebbe; bisogna
        ricordarsi di mettere i valori giusti subito. Se ce lo si scorda, ci
        sono serie possibilità che sopravvivano per lungo tempo dei
        <constant>NULL</constant> fuorilegge, in quanto non ci saranno poi più
        sveglie inserite.</para>
      </section>

      <section>
        <title><indexterm>
            <primary>Aggiungere campi NOT NULL</primary>

            <secondary>usare i domini</secondary>
          </indexterm><indexterm>
            <primary>Tabelle</primary>

            <secondary>aggiungere campi NOT NULL</secondary>

            <tertiary>usare i domini</tertiary>
          </indexterm><indexterm>
            <primary>NOT NULL</primary>

            <secondary>attraverso un dominio</secondary>
          </indexterm>Aggiungere un campo non annullabile usando i
        domini</title>

        <para>Al posto di specificare il tipo di dato ed il vincolo
        direttamente, si possono usare anche i domini, ad esempio così:</para>

        <blockquote>
          <programlisting>create domain icnn as int check (value is not null);
alter table Avventure add id icnn;</programlisting>
        </blockquote>

        <para>Per quanto riguarda la presenza di campi
        <constant>NULL</constant>, il riportare valori fasulli a 0, l'effetto
        dei valori default, ecc., <emphasis>non fa alcuna
        differenza</emphasis> fra scegliere il metodo dei domini o l'approccio
        diretto. Tuttavia, un vincolo <database>NOT NULL</database> che viene
        posto attraverso un dominio può essere sempre rimosso, un vincolo
        <database>NOT NULL</database> diretto su una colonna ci starà per
        sempre.</para>
      </section>
    </section>

    <section id="nullguide-make-column-non-nullable">
      <title><indexterm>
          <primary>Tabelle</primary>

          <secondary>rendere le colonne non annullabili</secondary>
        </indexterm>Rendere le colonne esistenti non annullabili</title>

      <section id="nullguide-make-column-not-null">
        <title><indexterm>
            <primary>Tabelle</primary>

            <secondary>rendere le colonne NOT NULL</secondary>
          </indexterm><indexterm>
            <primary>NOT NULL</primary>

            <secondary>attraverso un dominio</secondary>

            <tertiary>aggiungere</tertiary>
          </indexterm>Rendere una colonna esistente <database>NOT
        NULL</database></title>

        <para>Non si può aggiungere il vincolo <database>NOT NULL</database>
        ad una colonna esistente, ma si può aggirare il problema
        semplicemente; supponendo che il tipo sia intero, allora con</para>

        <blockquote>
          <programlisting>create domain intnn as int not null;
alter table Tabella alter Colonna type intnn;</programlisting>
        </blockquote>

        <para>cambierà il tipo della colonna in <quote>int not
        null</quote>.</para>

        <para>Se la tabella ha già delle registrazioni, ogni
        <constant>NULL</constant>s già presente nella colonna rimarrà
        <constant>NULL</constant>, e come sopra Firebird lo riporterà come 0
        all'utente nelle interrogazioni. La situazione è abbastanza simile a
        (vedi) <link
        linkend="nullguide-add-not-null-field-it"><citetitle>aggiungere un
        campo <database>NOT NULL</database></citetitle></link>. La sola
        differenza è che dando ad un dominio (e pertanto alla colonna) un
        valore default, in questo caso non si può essere sicuri che esso verrà
        applicato ai preesistenti valori <constant>NULL</constant>. Le prove
        mostrano che talvolta il default viene applicato a tutti i
        <constant>NULL</constant>s, qialche volta a nessuno, ed in qualche
        raro caso ad <emphasis>alcuni</emphasis> dei valori esistenti ma non a
        tutti! Ultima cosa: cambiando il tipo di dato della colonna, qualora
        il nuovo tipo includa un default, bisogna controllare tutti i valori
        già esistenti, specialmente se <quote>sembrano contenere</quote> 0 o
        valori equivalenti a zero.</para>
      </section>

      <section id="nullguide-add-check-not-null">
        <title><indexterm>
            <primary>Tabelle</primary>

            <secondary>aggiungere un CHECK ad una colonna</secondary>
          </indexterm>Aggiungere un vincolo di <database>CHECK</database> ad
        una colonna esistente</title>

        <para>Ci sono due modi per aggiungere un vincolo di
        <database>CHECK</database> ad una colonna:</para>

        <blockquote>
          <programlisting>alter table Articoli add check (Valore is not null)</programlisting>

          <programlisting>alter table Articoli add constraint ValoreNonNull check (Valore is not null)</programlisting>
        </blockquote>

        <para>La seconda forma è la preferita, in quanto permette in modo
        semplice di eliminare il controllo, per quanto funzionino esattamente
        allo stesso modo. Come ci si può facilmente aspettare, i campi con
        <constant>NULL</constant> già esistenti nella colonna rimangonon, può
        esserne fatto il backup ed il restore, ecc. ecc. Vedi <link
        linkend="nullguide-add-check-not-null-field-it"><citetitle>aggiungere
        un campo <database>CHECK</database></citetitle></link>.</para>
      </section>
    </section>

    <section id="nullguide-make-column-nullable">
      <title><indexterm>
          <primary>Tabelle</primary>

          <secondary>rendere le colonne annullabili</secondary>
        </indexterm>Rendere le colonne non annullabili di nuovo
      annullabili</title>

      <para>Se una colonna era stata resa non annullabile con un vincolo
      <database>CHECK</database>, quest'ultimo può essere eliminato:</para>

      <blockquote>
        <programlisting>alter table Articoli drop constraint ValoreNonNull</programlisting>
      </blockquote>

      <para>Avendo dato un nome al vincolo ma con il
      <database>CHECK</database> aggiunto direttamente alla colonna o alla
      tabella, bisogna trovare il suo nome prima di poterlo rimuovere. Questo
      si può fare con il comando <application>isql</application>
      <quote><database>SHOW TABLE</database></quote> (in questo caso:
      <database>SHOW TABLE ARTICOLI</database>).</para>

      <para><indexterm>
          <primary>NOT NULL</primary>

          <secondary>rimuovere</secondary>
        </indexterm>In caso di un vincolo <database>NOT NULL</database>,
      conoscendo il suo nome si può semplicemente rimuoverlo:</para>

      <blockquote>
        <programlisting>alter table Articoli drop constraint NN_Valore</programlisting>
      </blockquote>

      <para>Se non si conosce il nome si può provare con
      <application>isql</application> ed usare al solito <quote><database>SHOW
      TABLE</database></quote>, ma questa volta mostrerà il nome del vincolo
      <emphasis>solo</emphasis> se è stato ridefinito dall'utente. Il nome
      esatto si ha in ogni caso con:</para>

      <blockquote>
        <programlisting>select rc.rdb$constraint_name
from   rdb$relation_constraints rc
       join rdb$check_constraints cc
       on rc.rdb$constraint_name = cc.rdb$constraint_name
where  rc.rdb$constraint_type   = 'NOT NULL'
       and rc.rdb$relation_name = '&lt;TableName&gt;'
       and cc.rdb$trigger_name  = '&lt;FieldName&gt;'</programlisting>
      </blockquote>

      <para>Non c'è da spaccarsi la testa sui nomi dei campi e delle tabelle
      di questa query: non c'è dubbio che siano abbastanza strani, ma sono
      corretti. Basta solo assicurarsi che il nome della tabella e del campo
      siano in maiuscolo se sono stati definiti in modo indipendente dal caso.
      Altrimenti devono essere scritti in modo esatto.</para>

      <para><indexterm>
          <primary>NOT NULL</primary>

          <secondary>attraverso un dominio</secondary>

          <tertiary>rimuovere</tertiary>
        </indexterm>Se il vincolo <database>NOT NULL</database> arriva
      attraverso un dominio, si può rimuovere modificando il tipo di colonna
      ad un dominio annullabile o ad un tipo di dato predefinito:</para>

      <blockquote>
        <programlisting>alter table Articoli alter Importo type int</programlisting>
      </blockquote>

      <para>Ogni <constant>NULL</constant> nascosto, se presente, sarà di
      nuovo visibile.</para>

      <para>In qualsiasi modo si rimuova il vincolo <database>NOT
      NULL</database>, bisogna confermare il lavoro
      (<command>commit</command>) e <emphasis>chiudere tutte le connessioni al
      database</emphasis>. Dopodichè ci si può riconnettere ed inserire
      <constant>NULL</constant> nelle colonne.</para>
    </section>
  </section>

  <section id="nullguide-testing">
    <title><indexterm>
        <primary>NULL</primary>

        <secondary>controllo</secondary>

        <tertiary>in pratica</tertiary>
      </indexterm><indexterm>
        <primary>Controllare per NULL</primary>

        <secondary>in pratica</secondary>
      </indexterm>Controllare per <constant>NULL</constant> e per
    l'eguaglianza nella pratica</title>

    <para>Questa sezione contiene alcuni suggerimenti pratici ed esempi che
    possono essere utili avendo a che fare con i <constant>NULL</constant>.
    Riguarda i casi in cui si vuol verificare lo stato di
    <constant>NULL</constant> di un campo o l'(in)uguaglianza fra due cose
    qualora possano essere implicati dei <constant>NULL</constant>.</para>

    <section id="nullguide-testing-for-null-it">
      <title>Come controllare se ci sono <constant>NULL</constant></title>

      <para>Frequentemente non si ha bisogno di prendere misure particolari
      per i campi o le variabili che potrebbero essere
      <constant>NULL</constant>. Ad esempio, facendo come segue:</para>

      <blockquote>
        <para><programlisting>select * from Clienti where Comune = 'Verona'</programlisting></para>
      </blockquote>

      <para>molto probabilmente non si vogliono elencati i clienti per i quali
      la città non risulta specificata. Allo stesso modo:</para>

      <blockquote>
        <para><programlisting>if (Eta &gt;= 18) then PotestVotare = 'Si'</programlisting></para>
      </blockquote>

      <para>non include le persone di età sconosciuta, quindi è difendibile,
      ed include le persone di età sconosciuta, ed è pure questo difendibile.
      Ma:</para>

      <blockquote>
        <para><programlisting>if (Eta &gt;= 18) then PotestVotare = 'Si';
else PotestVotare = 'No';</programlisting></para>
      </blockquote>

      <para>sembra meno giustificabile: se non si conosce l'età di una
      persona, non si può esplicitamente negargli il diritto di voto. Ancora
      peggio, è far questo:</para>

      <blockquote>
        <para><programlisting>if (Eta &lt; 18) then PotestVotare = 'No';
else PotestVotare = 'Si';</programlisting></para>
      </blockquote>

      <para>che non può avere lo stesso effetto del precedente esempio. Se
      alcuni di cui non si sa l'età sono in realtà minorenni (Eta &lt; 18),
      gli si permette di votare!</para>

      <para>Il miglior metodo in questo caso è controllare esplicitamente se
      vale <constant>NULL</constant>:</para>

      <blockquote>
        <para><programlisting>if (Eta is null) then PotestVotare = '??';
else 
  if (Eta &gt;= 18) then PotestVotare = 'Si';
  else PotestVotare = 'No';</programlisting></para>
      </blockquote>

      <para>Poichè si hanno più di due possibilità, è più elegante usare la
      sintassi dello statement <database>CASE</database>, che è disponibile a
      partire da Firebird 1.5 e successivi:</para>

      <blockquote>
        <para><programlisting>PotestVotare = case
            when Eta is null then '??'
            when Eta &gt;= 18   then 'Si'
            else 'No'
          end;</programlisting></para>
      </blockquote>

      <para>O, ancora meglio:</para>

      <blockquote>
        <para><programlisting>PotestVotare = case
            when Eta &gt;= 18 then 'Si'
            when Eta &lt;  18 then 'No'
            else '??'
          end;</programlisting></para>
      </blockquote>
    </section>

    <section id="nullguide-testing-equality">
      <title><indexterm>
          <primary>Uguaglianza</primary>
        </indexterm><indexterm>
          <primary>Confronti</primary>
        </indexterm>Test di uguaglianza e confronti</title>

      <para>Quando si vuole verificare se due campi o variabili sono identici
      e li si vuol considerare uguali anche se sono entrambi
      <constant>NULL</constant>, il modo per farlo dipende dalla versione di
      Firebird che si sta' usando.</para>

      <section>
        <title><indexterm>
            <primary>Uguaglianza</primary>

            <secondary>in Firebird 2+</secondary>
          </indexterm><indexterm>
            <primary>Confronti</primary>

            <secondary>in Firebird 2+</secondary>
          </indexterm><indexterm>
            <primary>DISTINCT</primary>

            <secondary>verificare la distinzione</secondary>
          </indexterm><indexterm>
            <primary>IS [NOT] DISTINCT FROM</primary>
          </indexterm>Firebird 2.0 e successivi</title>

        <para>In Firebird 2 e succesivi, si confronta per la non uguaglianza
        dei valori <database>con DISTINCT</database>. Questo è già stato visto
        in precedenza, ma qui lo rivediamo brevemente. Due espressioni sono
        considerate:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><database>DISTINCT</database> se hanno valori diversi oppure
            una delle due è <constant>NULL</constant> e l'altra no;</para>
          </listitem>

          <listitem>
            <para><database>NOT DISTINCT</database> se hanno lo stesso valore
            oppure se entrambe sono <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>

        <para><database>[NOT] DISTINCT</database> riporta sempre o
        <constant>true</constant> o <constant>false</constant>, mai
        <constant>NULL</constant> o altri valori. Examples:</para>

        <blockquote>
          <para><programlisting>if (A <emphasis role="bold">is distinct from</emphasis> B) then...</programlisting><programlisting>if (Cliente1 <emphasis
                role="bold">is not distinct from</emphasis> Cliente2) then...</programlisting></para>
        </blockquote>

        <para>Chi non è interessato ai metodi pre-Firebird 2, può <link
        linkend="nullguide-testing-change-it">saltare le seguenti
        sezioni</link>.</para>
      </section>

      <section>
        <title><indexterm>
            <primary>Uguaglianza</primary>

            <secondary>in Firebird 1.*</secondary>
          </indexterm><indexterm>
            <primary>Confronti</primary>

            <secondary>in Firebird 1.*</secondary>
          </indexterm>Versioni precedenti alla 2</title>

        <para>Queste versioni non supportano l'uso di
        <database>DISTINCT</database>. Di conseguenza i test sono un po' più
        complicati e ci sono alcuni trabocchetti da evitare.</para>

        <para>Il test di uguaglianza corretto per le versioni in esame
        è:</para>

        <blockquote>
          <para><programlisting>if (A = B or A is null and B is null) then...</programlisting></para>
        </blockquote>

        <para>oppure, esplicitando le precedenze degli operatori:</para>

        <blockquote>
          <para><programlisting>if ((A = B) or (A is null and B is null)) then...</programlisting></para>
        </blockquote>

        <para>È necessario avvertire di una cosa: se esattamente uno solo fra
        A e B è proprio <constant>NULL</constant>, l'espressione diventa
        <constant>NULL</constant>, non falsa! Questo è giusto, per quanto
        abbiamo visto prima, in uno statement di <literal>if</literal>, e si
        potrebbe anche aggiungere perfino un clausola <literal>else</literal>
        che può essere eseguita nel caso in cui A e B non sono uguali (incluso
        il caso in cui uno dei due è <constant>NULL</constant> e l'altro
        no):</para>

        <blockquote>
          <para><programlisting>if (A = B or A is null and B is null) 
  then ...cose da fare se A è uguale a B...
  else ...cose da fare se A è diverso da B...</programlisting></para>
        </blockquote>

        <para>Ma bisogna evitare come la peste la brillante idea di invertire
        le espressioni e di usarle come un test di ineguaglianza:</para>

        <blockquote>
          <para><programlisting>/* Da evitare! */
if (not(A = B or A is null and B is null))
  then ...cose da fare se A non è uguale a B...</programlisting></para>
        </blockquote>

        <para>Il codice qui sopra funziona correttamente se A e B sono
        entrambi <constant>NULL</constant> o entrambi diversi da
        <constant>NULL</constant>. Ma nel caso in cui uno solo dei due sia
        <constant>NULL</constant> non entra nella parte
        <literal>then</literal> perchè il test vale NULL, invece che essere
        valutato a vero come si potrebbe essere indotti erroneamente a
        pensare.</para>

        <para>Volendo eseguire un codice se e solo se A e B sono differenti,
        si può usare una delle espressioni corrette viste sopra mettendo uno
        statement innocuo nella clausola <literal>then</literal>. A partire
        dalla 1.5 si possono usare anche blocchi <code>begin..end</code>
        vuoti. In alternativa si può usare una espressione più lunga come
        questa:</para>

        <blockquote>
          <para><programlisting>/* Questo è un corretto test per diseguaglianza: */
if (A &lt;&gt; B
    or A is null and B is not null
    or A is not null and B is null) then...</programlisting></para>
        </blockquote>

        <para>Ricordare che questo è necessario dsolo nelle versioni
        precedenti alla 2.0 di Firebird. A partire dalla 2 in poi, il test di
        disuguaglianza si fa semplicemente con <quote><code>if (A is distinct
        from B)</code></quote>.</para>
      </section>

      <section>
        <title><indexterm>
            <primary>Confronti</primary>

            <secondary>riassunto</secondary>
          </indexterm>Riassunto sui controlli di (dis)uguaglianza</title>

        <table id="nullguide-tbl-eqtests">
          <title>Verificare la (dis)uguaglianza di A e B in versioni
          differenti di Firebird</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry morerows="1">Tipo di controllo</entry>

                <entry align="center" nameend="col20" namest="col15">Versione
                di Firebird</entry>
              </row>

              <row>
                <entry align="center">&lt;= 1.5.x</entry>

                <entry align="center">&gt;= 2.0</entry>
              </row>
            </thead>

            <tbody>
              <row valign="top">
                <entry><para><emphasis>Uguaglianza</emphasis></para></entry>

                <entry><literallayout class="monospaced">A = B or A is null and B is null</literallayout></entry>

                <entry><literallayout class="monospaced">A is not distinct from B</literallayout></entry>
              </row>

              <row valign="top">
                <entry><para><emphasis>Disuguaglianza</emphasis></para></entry>

                <entry><literallayout class="monospaced">A &lt;&gt; B
or A is null and B is not null
or A is not null and B is null</literallayout></entry>

                <entry><literallayout class="monospaced">A is distinct from B</literallayout></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Tenere ben presente che in Firebird 1.5.x e precedenti:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>il test d'uguaglianza riporta <constant>NULL</constant> se
            uno solo degli operandi è <constant>NULL</constant>;</para>
          </listitem>

          <listitem>
            <para>il test di disuguaglianza riporta <constant>NULL</constant>
            se entrambi gli operandi sono <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>

        <para>In un contesto di tipo <database>IF</database> o
        <database>WHERE</database>, questi risultati <constant>NULL</constant>
        si comprtano come <constant>false</constant> – che andrebbe bene in
        generale. Ma bisogna fare attenzione che invertendo con
        <database>NOT()</database> da' ilmedesimo risultato
        <constant>NULL</constant>, e non
        <quote><constant>true</constant></quote>. Inoltre se si usano i
        confronti della versione 1.5 e precedenti con un vincolo di
        <database>CHECK</database> in Firebird 2 o successivi, leggere
        attentamente la sezione <link
        linkend="nullguide-check-constraints-it"><citetitle><database>Vincoli
        di controllo (CHECK</database> constraints)</citetitle></link>, se non
        l'avete già fatto.</para>

        <indexterm>
          <primary>JOIN</primary>
        </indexterm>

        <indexterm>
          <primary>NULL</primary>

          <secondary>nelle JOIN</secondary>
        </indexterm>

        <tip>
          <para>Molte operazioni di <database>JOIN</database> sono costituite
          da uguaglianze su campi di diverse tabelle, ed usano l'operatore
          <quote><literal>=</literal></quote>. Questo elimina tutte le coppie
          <constant>NULL</constant>-<constant>NULL</constant>. Per far
          corrispondere fra loro due <constant>NULL</constant>, selezionare il
          test di uguaglianza adatto per la versione di Firebird usata dalla
          tabella sopra.</para>
        </tip>
      </section>
    </section>

    <section id="nullguide-testing-change-it">
      <title>Determinare se un campo è cambiato</title>

      <para>Nei trigger è spesso utile sapere se un certo campo è stato
      modificato (compresa la trasformazione da <constant>NULL</constant> a
      non-<constant>NULL</constant> o viceversa) oppure è rimasto identico
      (compreso il mantenere lo stato di <constant>NULL</constant>). Questo
      non è altro che un caso speciale del controllo di (dis)uguaglianza di
      due campi.</para>

      <para>In Firebird 2 e successivi si usa questo codice:</para>

      <blockquote>
        <programlisting>if (New.Valore is not distinct from Old.Valore)
  then ...il Valore non è cambiato...
  else ...il Valore è cambiato...</programlisting>
      </blockquote>

      <para>E nelle precedenti versioni:</para>

      <blockquote>
        <programlisting>if (New.Valore = Old.Valore 
    or New.Valore is null and Old.Valore is null)
  then ...il campo Valore è rimasto uguale...
  else ...il campo Valore è cambiato...</programlisting>
      </blockquote>
    </section>
  </section>

  <section id="nullguide-summary-it">
    <title><indexterm>
        <primary>Sommario</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>in sintesi</secondary>
      </indexterm>Sommario</title>

    <!--Da pubblicare come documento di sintesi separato, intitolato "Null in sintesi"
(e farne un doppio link tra qui <-> là)-->

    <para><constant>NULL</constant> in sintesi:</para>

    <itemizedlist>
      <listitem>
        <para><constant>NULL</constant> significa
        <emphasis>sconosciuto</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Per escludere <constant>NULL</constant> da un dominio o da una
        colonna, aggiungere <quote><database>NOT NULL</database></quote> dopo
        il nome del tipo.</para>
      </listitem>

      <listitem>
        <para>Per determinare se A è <constant>NULL</constant>, si usa
        <quote><database>A IS [NOT] NULL</database></quote>.</para>
      </listitem>

      <listitem>
        <para>Assegnare <constant>NULL</constant> è come assegnare un
        qualsiasi altro valore: con <quote><database>A =
        NULL</database></quote> o con una lista di insert.</para>
      </listitem>

      <listitem>
        <para>Per determinare se A e B sono identici, sapendo che
        t<constant>utti i NULL</constant> sono identici fra loro e differenti
        da qualsiasi altra cosa, si usa <quote><database>A IS [NOT] DISTINCT
        FROM B</database></quote> in Firebird 2 e successivi. Nelle versioni
        precedenti i controlli sono:</para>

        <blockquote>
          <programlisting>// uguaglianza:
A = B or A is null and B is null</programlisting>

          <programlisting>// disuguaglianza:
A &lt;&gt; B
or A is null and B is not null
or A is not null and B is null</programlisting>
        </blockquote>
      </listitem>

      <listitem>
        <para>In Firebird 2 e succesivi si può usare il valore letterale
        <constant>NULL</constant> in quasi tutte le situazioni dove sarebbe
        permesso un qualsiasi altro valore normale. In pratica questo dà però
        solo più spago con cui appendersi.</para>
      </listitem>

      <listitem>
        <para>Quasi sempre, gli operandi <constant>NULL</constant> fanno sì
        che l'intera operazione riporti <constant>NULL</constant>. Le
        eccezioni degne di nota sono:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><quote><constant>NULL</constant> or
            <constant>true</constant></quote> vale
            <constant>true</constant>;</para>
          </listitem>

          <listitem>
            <para><quote><constant>NULL</constant> and
            <constant>false</constant></quote> vale
            <constant>false</constant>.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>I predicati <database>IN</database>,
        <database>ANY</database>|<database>SOME</database> ed
        <database>ALL</database> possono (ma non sempre) riportare
        <constant>NULL</constant> o quando l'espressione a sinistra o quando
        un elemento della lista/subselect è <constant>NULL</constant>.</para>
      </listitem>

      <listitem>
        <para>Il predicato <database>[NOT] EXISTS</database> nonriporta mai
        <constant>NULL</constant>. Il predicato <database>[NOT]
        SINGULAR</database> non riporta mai <constant>NULL</constant> in
        Firebird 2.1 e successivi, è invece bucato in tutte le versioni
        precedenti.</para>
      </listitem>

      <listitem>
        <para>Nelle funzioni di aggregazione, solo i campi
        non-<constant>NULL</constant> sono utilizzati per il calcolo.
        L'eccezzione è <database>COUNT(*)</database>.</para>
      </listitem>

      <listitem>
        <para>Nei risultati ordinati, i <constant>NULL</constant>s sono
        messi...</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>1.0: alla fine;</para>
          </listitem>

          <listitem>
            <para>1.5: alla fine, a meno che non sia specificato
            <database>NULLS FIRST</database>;</para>
          </listitem>

          <listitem>
            <para>2.0: all'inizio del risultato (inizio se ascendente, alla
            fine se discendente), a meno che non venga specificato
            esplicitamente <database>NULLS FIRST/LAST</database>.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Se una clausola <database>WHERE</database> o
        <database>HAVING</database> vale <constant>NULL</constant>, la riga
        non è inclusa nel risultato.</para>
      </listitem>

      <listitem>
        <para>Se l'espressione di test di una frase <database>IF</database> è
        <constant>NULL</constant>, allora si salta il blocco
        <database>THEN</database> e viene eseguito il blocco
        <database>ELSE</database>.</para>
      </listitem>

      <listitem>
        <para>Una frase <database>CASE</database> riporta
        <constant>NULL</constant>:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>se il risultato selezionato è
            <constant>NULL</constant>.</para>
          </listitem>

          <listitem>
            <para>se non sono trovati abbinamenti validi
            (<database>CASE</database> semplice) o nessuna delle condizioni è
            <constant>true</constant> (<database>CASE</database> complesso) e
            non c'è la clausola <database>ELSE</database>.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>In una frase <database>CASE</database> semplice,
        <quote><database>CASE</database>
        <replaceable>&lt;null_expr&gt;</replaceable></quote>
        <emphasis>non</emphasis> si abbina ad un
        <quote><database>WHEN</database>
        <replaceable>&lt;null_expr</replaceable>&gt;</quote>.</para>
      </listitem>

      <listitem>
        <para>Le l'espressione di controllo di una ciclica
        <database>WHILE</database> vale <constant>NULL</constant>, non si
        (ri)entra nel ciclo.</para>
      </listitem>

      <listitem>
        <para>Una frase <database>FOR</database> continua anche se si ricevono
        <constant>NULL</constant>. Essa continuerà a ciclare finchè non
        verranno processate tutte le righe, o finchè non sarà interrotta da
        un'eccezione o da una direttiva PSQL di interruzione del ciclo.</para>
      </listitem>

      <listitem>
        <para>Nelle chiavi primarie, i <constant>NULL</constant> non sono
        permessi.</para>
      </listitem>

      <listitem>
        <para>Nelle chiavi univoche e negli indici univoci, i
        <constant>NULL</constant> sono</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><emphasis>non permessi</emphasis> in Firebird 1.0;</para>
          </listitem>

          <listitem>
            <para><emphasis>permessi</emphasis> (anche multipli) in Firebird
            1.5 e successivi.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>Nelle colonne delle chiavi esterne, sono permessi
        <constant>NULL</constant> multipli.</para>
      </listitem>

      <listitem>
        <para>Se un vincolo di <database>CHECK</database> vale
        <constant>NULL</constant>, allora il valore viene</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><emphasis>rifiutato</emphasis> sotto Firebird 1.5 e
            precedenti;</para>
          </listitem>

          <listitem>
            <para><emphasis>accettato</emphasis> sotto Firebird 2.0 e
            successivi.</para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para><database>SELECT DISTINCT</database> considera eguali tutti i
        <constant>NULL</constant>, pertanto ne riporta al massimo uno.</para>
      </listitem>

      <listitem>
        <para>Le UDF talvolta convertono <constant>NULL</constant>
        <literal>&lt;–&gt;</literal> non-<constant>NULL</constant> in un modo
        apparentemente casuale.</para>
      </listitem>

      <listitem>
        <para>Le funzioni <function>COALESCE</function> e
        <function>*NVL</function> possono convertire un
        <constant>NULL</constant> in un valore.</para>
      </listitem>

      <listitem>
        <para>La famiglia di funzioni <function>NULLIF</function> è in grado
        di convertire valori in<constant> NULL</constant>.</para>
      </listitem>

      <listitem>
        <para>Aggiungendo una colonna <database>NOT NULL</database> senza
        valore di default ad una tabella con dati preeesistenti, tutti i
        valori in quella colonna saranno <constant>NULL</constant> dopo la
        creazione. Molti programmi tuttavia - incluso lo strumnento
        <application>isql</application> di Firebird – riportano erroneamente
        come zeri (0 per i campi numerici, '' per i campi stringa,
        ecc.)</para>
      </listitem>

      <listitem>
        <para>Cambiando il tipo di dato di una colonna ad un dominio
        <database>NOT NULL</database>, tutti gli eventuali
        <constant>NULL</constant> esistenti nella colonna rimarranno tali. Di
        nuovo molti programmi, inclusa <application>isql</application>, li
        mostreranno come zeri.</para>
      </listitem>
    </itemizedlist>

    <para>Ricordare: così funziona il <constant>NULL</constant> <emphasis>in
    Firebird SQL</emphasis>. Ci possono essere più o meno sottili differenze
    con altri RDBMS.</para>
  </section>

  <appendix id="nullguide-bugs">
    <title><indexterm>
        <primary>Bug list</primary>
      </indexterm><indexterm>
        <primary>Problemi</primary>
      </indexterm><indexterm>
        <primary>NULL</primary>

        <secondary>problemi</secondary>
      </indexterm>Problemi relativi a <constant>NULL</constant> in
    Firebird</title>

    <para>Attenzione: nelle sezioni seguenti sono elencati sia i problemi
    attuali sia quelli superati. Controllare se e quando un particolare
    problema è stato risolto prima di determinare se esiste nella vostra
    particolare versione di Firebird.</para>

    <section id="nullguide-bugs-servercrashes">
      <title><indexterm>
          <primary>Bug list</primary>

          <secondary>server crash</secondary>
        </indexterm><indexterm>
          <primary>Problemi</primary>

          <secondary>server crash</secondary>
        </indexterm>Problemi che fanno cadere il server</title>

      <section id="nullguide-bugs-execute-statement">
        <title><database>EXECUTE STATEMENT</database> con argomento
        <constant>NULL</constant></title>

        <para>EXECUTE STATEMENT con un argomento a <constant>NULL</constant>
        fanno cadere i server Firebird 1.5 e 1.5.1. Risolto nella versione
        1.5.2.</para>
      </section>

      <section id="nullguide-bugs-extract">
        <title><database>EXTRACT</database> da una data
        <constant>NULL</constant></title>

        <para>In 1.0.0, EXTRACT da una data <constant>NULL</constant> potrebbe
        far cadere il server. Risolto nella versione 1.0.2.</para>
      </section>

      <section id="nullguide-bugs-first-skip">
        <title><database>FIRST</database> e <database>SKIP</database> con
        argomento <constant>NULL</constant></title>

        <para>FIRST e SKIP fanno cadere i server Firebird 1.5.n o precedenti
        se gli viene passato un argomento <constant>NULL</constant>. Risolto
        nella versione 2.0.</para>
      </section>

      <section id="nullguide-bugs-like">
        <title><database>LIKE</database> con carattere escape
        <constant>NULL</constant></title>

        <para>Usare <database>LIKE</database> con un carattere di escape a
        <constant>NULL</constant> potrebbe far cadere il server. Risolto nella
        versione 1.5.1.</para>
      </section>
    </section>

    <section id="nullguide-bugs-other">
      <title><indexterm>
          <primary>Bug list</primary>

          <secondary>altri problemi</secondary>
        </indexterm><indexterm>
          <primary>Problemi</primary>

          <secondary>altri problemi</secondary>
        </indexterm>Altri problemi</title>

      <section id="nullguide-bugs-illegal-nulls">
        <title><constant>NULL</constant> in colonne <database>NOT
        NULL</database></title>

        <para>I <constant>NULL</constant> possono esistere nelle colonne
        <database>NOT NULL</database> nelle seguenti situazioni:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Se si aggiunge una colonna <database>NOT NULL</database> ad
            una tabella già piena, i campi della colonna aggiunta saranno
            tutti <constant>NULL</constant>.</para>
          </listitem>

          <listitem>
            <para>Se si rende una colonna esistente <database>NOT
            NULL</database>, ogni <constant>NULL</constant> già presente nella
            colonna rimane in quello stato.</para>
          </listitem>
        </itemizedlist>

        <para>Firebird permette a quei <constant>NULL</constant> di restare, e
        ne permette il backup, ma si rifiuta di recuperare la copia con
        <application>gbak</application>. Vedere <link
        linkend="nullguide-add-not-null-field-it"><citetitle>Aggiungere una
        colonna <database>NOT NULL</database></citetitle></link> and <link
        linkend="nullguide-make-column-not-null"><citetitle>Rendere una
        colonna esistente <database>NOT
        NULL</database></citetitle></link>.</para>
      </section>

      <section id="nullguide-bugs-null-as-0">
        <title><constant>NULL</constant> illegali riportati come
        <literal>0</literal>, <literal>''</literal>, ecc.</title>

        <para>Se una colonna <database>NOT NULL</database> contiene
        <constant>NULL</constant> (vedere il problema precedente), il server
        lo descrive come non annullabile al programma client. Poichè molti
        programmi si fidano ciecamente del server, interpretano quei
        <constant>NULL</constant> come se fossero 0 (o equivalente) e come
        tale lo presentano all'utente. Vedere <link
        linkend="nullguide-nulls-reported-as-zeroes"><citetitle>Valorizzazione
        errata di <constant>NULL</constant> come se fosse
        zero</citetitle></link>.</para>
      </section>

      <section id="nullguide-bugs-pk-null">
        <title>Chiavi primarie con valori a <constant>NULL</constant></title>

        <para>Il problema seguente è comparso in Firebird 1.5: avendo una
        tabella con dati, ed aggiungendo una colonna <database>NOT
        NULL</database> (che automaticamente crea dei
        <constant>NULL</constant> nelle righe esistenti– vedi sopra), è
        possibile rendere quella colonna la chiave primaria anche se ha già
        dei valori <constant>NULL</constant>. In 1.0 questo non sarebbe potuto
        funzionare a causa delle regole più restrittive per gli indici
        <database>UNIQUE</database>. Risolto nella versione 2.0.</para>
      </section>

      <section id="nullguide-bugs-substring">
        <title><database>SUBSTRING</database> descritta come non
        annullabile</title>

        <para>Il sistema descrive le colonne risultato di una
        <database>SUBSTRING</database> come non annullabili nei seguenti due
        casi:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>Se il primo argomento è una costante stringa, come in
            <quote><database>SUBSTRING</database>( 'Paperino'
            <database>FROM</database> 5 <database>FOR</database> 2
            )</quote>.</para>
          </listitem>

          <listitem>
            <para>Se il primo argomento è una colonna <database>NOT
            NULL</database></para>
          </listitem>
        </itemizedlist>

        <para>Questo è sbagliato perchè perfino di una stringa nota, la
        sottostringa può essere <constant>NULL</constant> quando il primo
        degli altri argomenti è <constant>NULL</constant>. Nella versione 1.*
        qusto non era un problema: gli argomenti del <database>FROM</database>
        e del <database>FOR</database> dovevano essere per forza costanti,
        pertanto non avrebbero mai potuto essere <constant>NULL</constant>. Ma
        a partire da Firebird 2, è permessa ogni espressione idonea a
        rappresentare il tipo di dato richiesto. E sebbene il sistema
        correttamente riporti <constant>NULL</constant> se un argomento è
        <constant>NULL</constant>, <emphasis>descrive</emphasis> la colonna
        risultato come non annullabile, cosicchè molti programmi mostrano il
        risultato come stringa vuota.</para>

        <para>Questo problema sembra risolto a partire dalla versione
        2.1.</para>
      </section>

      <section id="nullguide-bugs-restore-notnull">
        <title>Gbak -n recupera i <database>NOT NULL</database></title>

        <para><application>Gbak</application>
        <parameter>-n[o_validity]</parameter> recuperava i vincoli
        <database>NOT NULL</database> nelle prime versioni di Firebird.
        Risolto nella versione 1.5.1.</para>
      </section>

      <section id="nullguide-bugs-pred-in-any">
        <title><indexterm>
            <primary>IN</primary>

            <secondary>problemi con subselect indicizzate</secondary>
          </indexterm><indexterm>
            <primary>ANY</primary>

            <secondary>problemi con subselect indicizzate</secondary>
          </indexterm><indexterm>
            <primary>SOME</primary>

            <secondary>problemi con subselect indicizzate</secondary>
          </indexterm><database>IN</database>, <database>=ANY</database> e
        <database>=SOME</database> con subselect indicizzate</title>

        <para>Sia <replaceable>A</replaceable> be l'espressione sinistra e
        <replaceable>S</replaceable> il risultato di una subselect. Nelle
        versioni precedenti la 2.0, <quote><database>IN</database></quote>,
        <quote><database>=ANY</database></quote> e
        <quote><database>=SOME</database></quote> riportavano
        <constant>false</constant> invece di <constant>NULL</constant> se un
        indice era attivo nella colonna della subselect e:</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>o <replaceable>A</replaceable> è <constant>NULL</constant> e
            <replaceable>S</replaceable> non contiene
            <constant>NULL</constant>;</para>
          </listitem>

          <listitem>
            <para>o <replaceable>A</replaceable> non è
            <constant>NULL</constant>, <replaceable>A</replaceable> non esiste
            in <replaceable>S</replaceable>, e <replaceable>S</replaceable>
            contiene almeno un <constant>NULL</constant>.</para>
          </listitem>
        </itemizedlist>

        <para>Vedere gli avvertimenti nelle sezioni <link
        linkend="nullguide-pred-in-bug"><database>IN</database></link> e <link
        linkend="nullguide-pred-any-bug"><database>ANY</database></link>.
        Alternativa: usare invece <quote><literal>&lt;&gt;</literal>
        <database>ALL</database></quote> . Risolta nella versione 2.0.</para>
      </section>

      <section id="nullguide-bugs-pred-all">
        <title><indexterm>
            <primary>ALL</primary>

            <secondary>problemi con subselect indicizzate</secondary>
          </indexterm><database>ALL</database> con subselect
        indicizzate</title>

        <para>Con qualsiasi operatore, eccetto
        <quote><literal>&lt;&gt;</literal></quote>, <database>ALL</database>
        può dare risultati sbagliati se un indice è attivo sulla colonna della
        subselect. Questo può capitare con o senza <constant>NULL</constant>.
        Vedere <link linkend="nullguide-pred-all-bug-it">Problemi di
        <database>ALL</database></link>. Risolto nella versione 2.0.</para>
      </section>

      <section id="nullguide-bugs-select-distinct-it">
        <title><indexterm>
            <primary>DISTINCT</primary>

            <secondary>SELECT DISTINCT</secondary>
          </indexterm><indexterm>
            <primary>SELECT DISTINCT</primary>
          </indexterm><database>SELECT DISTINCT</database> con l'ordinamento
        sbagliato di <database>NULLS FIRST|LAST</database></title>

        <para>Firebird 2.0 ha il seguente problema (difficile da spiegare
        senza esempi): se una <database>SELECT DISTINCT</database> è ordinata
        con <database>[ASC] NULLS LAST</database> o <database>DESC NULLS
        FIRST</database>, ed i campi di ordinamento (nella <database>ORDER
        BY</database>) formano solo l'inizio ma non sono tutti i campi della
        lista nella <database>SELECT</database>, ogni campo nella clausola
        <database>ORDER BY</database> che è seguito nella
        <database>SELECT</database> da un campo con un ordinamento differente
        (o nessun ordinamento) si ritrova i <constant>NULL</constant>
        posizionati in modo default, ignorando la direttiva <database>NULLS
        XXX</database>. Risolto nella versione 2.0.1 e 2.1.</para>
      </section>

      <section id="nullguide-bugs-udf-nulltoval">
        <title>UDF che riportano valori invece di riportare
        <constant>NULL</constant></title>

        <para>Questo dev'essere certamente considerato un problema. Se
        un'angolo è sconosciuto, <emphasis>non si può</emphasis> affermare che
        il suo coseno è 1! Sebbene tutta la storia di queste funzioni sia ben
        nota ed è comprensibile il perchè si comportino così (vedere <link
        linkend="nullguide-udfs-it"><citetitle>Funzioni definite dall'utente
        (UDF)</citetitle></link>), è comunque sbagliato. Sono riportati valori
        errati e questo non dovrebbe accadere. La maggior parte delle funzioni
        matematiche nella <systemitem class="library">ib_udf</systemitem>,
        oltre a qualche altra, hanno questo problema.</para>
      </section>

      <section id="nullguide-bugs-udf-valtonull">
        <title>UDF che riportano <constant>NULL</constant> quando invece
        dovrebbero riportare un valore</title>

        <para>Questo è un problema complementare al precedente.
        <function>LPAD</function> ad esempio riporta <constant>NULL</constant>
        se si vuol riempire una stringa vuota con, ad esempio, 10 punti.
        Questa ed altre funzioni sono state corrette nella versione 2.0, con
        l'avvertenza che bisogna esplicitamente dichiararle con la parola
        chiave <database>NULL</database>, altrimenti si comporteranno nel modo
        sbagliato di una volta. <function>LTRIM</function> e
        <function>RTRIM</function> trasformano stringhe vuote in
        <constant>NULL</constant> in Firebird 1.0.n. Questo è stato risolto
        nella versione 1.5 al prezzo di riportare <literal>stringa vuota (cioè
        '')</literal> se l'argomento è una stringa <constant>NULL</constant>,
        e completamente risolto solo nella versione 2.0 (se dichiarata con la
        parola chiave <database>NULL</database>).</para>
      </section>

      <section id="nullguide-bugs.singular-inconsistency">
        <title><database>SINGULAR</database> inconsistente con risultati a
        <constant>NULL</constant></title>

        <para><database>NOT SINGULAR</database> talvolta riporta
        <constant>NULL</constant> quando <database>SINGULAR</database> riporta
        <constant>true</constant> o <constant>false</constant>. Risolto nella
        versione 2.0.</para>

        <para><database>SINGULAR</database> può erroneamente riportare
        <constant>NULL</constant>, in un modo riproducibile ma inconsistente.
        Risolto nella versione 2.1.</para>

        <para>Vedere la sezione su <link
        linkend="nullguide-pred-singular-it"><database>SINGULAR</database></link>.</para>
      </section>
    </section>
  </appendix>

  <appendix id="nullguide-dochist-it">
    <title>Cronologia</title>

    <para>La cronologia completa è registrata nel modulo del manuale
    (<filename class="directory">manual</filename> module) nell'albero del
    CVS; vedi <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>8 Aprile 2005</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Prima edizione.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>15 April 2005</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Menzionato il fatto che Fb 2.0 ha legalizzato i confronti
            del tipo <quote><literal>A = NULL</literal></quote>.</para>

            <para>Cambiato il testo in <quote>Come controllare se ci sono
            <constant>NULL</constant></quote>.</para>

            <para>Riaggiustato il testo nella sezione <quote>Lavorare con i
            <constant>NULL</constant></quote>.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2-it</revnumber>

          <date>6 dicembre 2006</date>

          <authorinitials>UM</authorinitials>

          <revdescription>
            <para>Prima versione in italiano.</para>

            <para>Piccoli aggiustamenti al testo e aggiunta una tabella
            riassuntiva degli esempi con le funzioni di aggregazione</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.0</revnumber>

          <date>24 Jan 2007</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Questo è un grosso aggiornamento, con molto materiale
            aggiunto ex-novo per cui il documento è quattro volte la versione
            precedente. Inoltre molta parte del testo esistente è stato
            riorganizzato e rifatto in toto. Difficile dare un riassunto di
            tutto il lavoro fatto: meglio considerarla una guida completamente
            nuova con un 15%-25% di vecchio materiale. Le aggiunte principali
            sono:<itemizedlist spacing="compact">
                <listitem>
                  <para><constant>NULL</constant> come costanti</para>
                </listitem>

                <listitem>
                  <para><database>IS [NOT] DISTINCT FROM</database></para>
                </listitem>

                <listitem>
                  <para>funzioni interne e direttive</para>
                </listitem>

                <listitem>
                  <para>Predicati: <database>IN</database>,
                  <database>ANY</database>, <database>SOME</database>,
                  <database>ALL</database>, <database>EXISTS</database>,
                  <database>SINGULAR</database></para>
                </listitem>

                <listitem>
                  <para>Filtri o ricerche (<database>WHERE</database>)</para>
                </listitem>

                <listitem>
                  <para>Ordinamenti (<database>ORDER BY</database>)</para>
                </listitem>

                <listitem>
                  <para><database>GROUP BY</database> e
                  <database>HAVING</database></para>
                </listitem>

                <listitem>
                  <para><database>CASE</database>, <database>WHILE</database>
                  e <database>FOR</database></para>
                </listitem>

                <listitem>
                  <para>Chiavi ed indici</para>
                </listitem>

                <listitem>
                  <para>vincoli <database>CHECK</database></para>
                </listitem>

                <listitem>
                  <para><database>SELECT DISTINCT</database></para>
                </listitem>

                <listitem>
                  <para>Convertire valori a <constant>NULL</constant> con
                  <function>NULLIF</function></para>
                </listitem>

                <listitem>
                  <para>Modificare tabelle piene</para>
                </listitem>

                <listitem>
                  <para>Liste dei problemi</para>
                </listitem>

                <listitem>
                  <para>Indice alfabetico</para>
                </listitem>
              </itemizedlist></para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.0.1</revnumber>

          <date>26 Jan 2007</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para><citetitle>Rendere le colonne <database>NOT NULL</database>
            di nuovo annullabili</citetitle>: correzione provvisoria di un
            errore riguardante la rimozione di vincolo <database>NOT
            NULL</database>.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>1.0.1-it</revnumber>

          <date>Mar 2007</date>

          <authorinitials>UM</authorinitials>

          <revdescription>
            <para>Versione italiana della 1.0.1</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="nullguide-license-it">
    <title>Licenza d'uso</title>

    <para>Il contenuto di questo documento è soggetto alla Public
    Documentation License Version 1.0 (la <quote>Licenza</quote>); si può
    utilizzare questa documentazione solo se si accettano i termini della
    Licenza. Copie della Licenza si trovano in <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) e <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>Il titolo del documento originale è <citetitle>Firebird Null
    Guide</citetitle>.</para>

    <para>L'autore iniziale del documento originale è: Paul Vinkenoog.</para>

    <para>Copyright © 2003–2006. Tutti i diritti riservati. Per contattare
    l'autore: paul at vinkenoog dot nl.</para>

    <para>L'autore della versione italiana del documento è: Umberto
    Masotti.</para>

    <para>La traduzione italiana è soggetta a Copyryght ©2006-2007. Tutti i
    diritti riservati. Per contattare l'autore della versione italiana:
    umasotti at users dot sourceforge dot net.</para>
  </appendix>

  <index id="nullguide-index-it">
    <title>Indice alfabetico</title>
  </index>
</article>