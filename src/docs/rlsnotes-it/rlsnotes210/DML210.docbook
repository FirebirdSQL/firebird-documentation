<?xml version="1.0" encoding="UTF-8"?>
<chapter id="rnfb210-dml">
  <chapterinfo>
    <title>Novità nel Data Manipulation Language (DML)</title>
  </chapterinfo>

  <para>In questa parte si tratta delle novità e dei miglioramenti aggiunti a
  quella parte del linguaggio SQL dedicato alla manipolazione dei dati durante
  lo sviluppo di Firebird 2. Quelli identificati come introdotti nella
  versione 2.1 sono disponibili solo con database in ODS 11.1 e
  superiori.</para>

  <important>
    <para>Un nuovo parametro di configurazione,
    <firstterm>RelaxedAliasChecking</firstterm>, è stato aggiunto a
    <command>firebird.conf</command> in Firebird 2.1 al fine di permettere una
    certa compatibilità con le versioni precedenti, rilassando le restrizioni
    di Firebird 2.0.x quando ci sono nomi di tabelle ed alias multipli nelle
    query (vedere <xref linkend="rnfb20x-dml-parsing" />, più oltre).</para>

    <para>Questo parametro non sarà una caratteristica permanente di Firebird
    ma ha lo scopo di permettere la migrazione per coloro che hanno necessitÍ
    di sistemare il codice esistente. Altre informazioni sono in <xref
    linkend="rnfb210-fbconf-relax" /> nel capitolo relativo ai <quote>Nuovi
    parametri di configurazione</quote>.</para>
  </important>

  <section id="rnfb210-dml-links">
    <title>Ricerca rapida</title>

    <itemizedlist spacing="compact">
      <listitem>
        <para>
          <xref linkend="rnfb210-cte" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-list" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-rtrng" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-updorinsrt" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-merge" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-joins" />
        </para>

        <itemizedlist spacing="compact">
          <listitem>
            <para>
              <xref linkend="rnfb210-joins-sntx" />
            </para>
          </listitem>

          <listitem>
            <para>
              <xref linkend="rnfb20x-dml-cross-join" />
            </para>
          </listitem>
        </itemizedlist>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-dml-insrt" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-blbvchar" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-blob-compare" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-dsqlchanges-blobsort" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-dml-dbkey" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-builtin-new" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb210-builtin-enh" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-iif" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-cast" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-substring" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-parsing" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-execute-block" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-derived-tables" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-rb-retain" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-rows" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-union-distinct" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-union-coercion" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-union-subqueries" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-nulls-distinct" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-nulls-equivalence" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-nulls-ordering" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-complex-dml" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-extensions" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-context" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-plans" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-sorting-both" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-sorting-groupby-expr" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-sorting-orderby" />
        </para>

        <para>
          <xref linkend="rnfb20x-dml-sorting-gotcha" />
        </para>
      </listitem>

      <listitem>
        <para>
          <xref linkend="rnfb20x-dml-nextvalue" />
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis role="bold">Articoli</emphasis>
        </para>

        <orderedlist spacing="compact">
          <listitem>
            <para>
              <xref linkend="rnfb20x-dml-select-syntax" />
            </para>
          </listitem>

          <listitem>
            <para>
              <xref linkend="rnfb210-dataresult" />
            </para>
          </listitem>

          <listitem>
            <para>
              <xref linkend="rnfb20x-dml-datetimetyping" />
            </para>
          </listitem>
        </orderedlist>
      </listitem>
    </itemizedlist>

    <section id="rnfb210-cte" xreflabel="Common Table Expressions">
      <sectioninfo>
        <authorgroup>
          <author>
            <firstname>Vlad</firstname>

            <surname>Khorsun</surname>
          </author>

          <author>
            <firstname>Basato sul lavoro di</firstname>

            <surname>Paul Ruizendaal per il progetto Fyracle</surname>
          </author>
        </authorgroup>
      </sectioninfo>

      <title>Common Table Expressions</title>

      <para><emphasis role="bold">(v.2.1)</emphasis> Una
      <firstterm>espressione di tabella comune</firstterm>, in inglese
      <firstterm>common table expression</firstterm> o più brevemente
      <literal>CTE</literal> è come una vista definita localmente all'interno
      di una query principale. Il motore tratta una CTE come una tabella
      derivata e non viene effettuata nessuna materializzazione intermedia dei
      dati.</para>

      <section id="rnfb210-cte-benefits">
        <title>Benefici delle CTE</title>

        <para>L'uso delle CTEs permette di specificare query dinamioche che
        possono essere anche recursive:</para>

        <itemizedlist>
          <listitem>
            <para>Il motore inizia l'esecuzione a partire da un elemento non
            recursivo.</para>
          </listitem>

          <listitem>
            <para>Per ogni riga valutata, esegue ciascun membro recursivo uno
            alla volta, usando i valori attuali della riga esterna come
            parametri.</para>
          </listitem>

          <listitem>
            <para>Se l'istanza attualmente in esecuzione di un membro
            recursivo non produce righe, l'esecuzione risale di un livello e
            recupera la riga successiva dalle righe dell'elemento
            esterno.</para>
          </listitem>
        </itemizedlist>

        <para>Nel caso di una CTE recursiva il carico di lavoro per la memoria
        e la CPU è molto inferiore di quello di una equivalente STORED
        PROCEDURE recursiva.</para>
      </section>

      <section id="rnfb210-cte-limit">
        <title>Limiti nella recursione</title>

        <para>Attualmente la profondità massima della recursione è fissato nel
        codice a 1024 livelli.</para>
      </section>

      <section id="rnfb210-cte-rules">
        <title>Sintassi e regole per le CTE</title>

        <programlisting>
select :
  select_expr for_update_clause lock_clause
select_expr :
  with_clause select_expr_body order_clause rows_clause
            | select_expr_body order_clause rows_clause
with_clause :
  WITH RECURSIVE with_list | WITH with_list
with_list :
  with_item | with_item ',' with_list
with_item :
  symbol_table_alias_name derived_column_list
    AS '(' select_expr ')'
select_expr_body :
  query_term
  | select_expr_body UNION distinct_noise query_term
             | select_expr_body UNION ALL query_term
        </programlisting>

        <para>E con una rappresentazione meno formale:</para>

        <programlisting>
WITH [RECURSIVE]
	CTE_A [(a1, a2, …)]
	AS ( SELECT … ),

	CTE_B [(b1, b2, …)]
	AS ( SELECT … ),
...
SELECT ...
  FROM CTE_A, CTE_B, TAB1, TAB2 ...
 WHERE ...
        </programlisting>

        <section id="rnfb210-cte-rules-nonr">
          <title>Regole per le CTE non recursive</title>

          <itemizedlist>
            <listitem>
              <para>Si possono definire in una unica query più di una
              espressione</para>
            </listitem>

            <listitem>
              <para>Qualsiasi clausola legale in una SELECT è legale in una
              CTE</para>
            </listitem>

            <listitem>
              <para>Una CTE può fare riferimento ad altre CTE</para>
            </listitem>

            <listitem>
              <para>I riferimenti fra varie CTE non possono contenere
              circolarità</para>
            </listitem>

            <listitem>
              <para>Le CTE possono essere usate in ogni parte della query
              principale o di un'altra CTE</para>
            </listitem>

            <listitem>
              <para>Una stessa CTE può essere usata più di una volta nella
              query principale</para>
            </listitem>

            <listitem>
              <para>Le CTE possono essere usate nelle frasi tipo INSERT,
              UPDATE o DELETE come subquery</para>
            </listitem>

            <listitem>
              <para>Le CTE sono legali nelle STORED PROCEDURE e nei TRIGGER
              (in generale nel PSQL)</para>
            </listitem>

            <listitem>
              <para>Una clausola WITH non può essere interna ad un'altra
              clausola WITH (cioè non possono essere innestate)</para>
            </listitem>
          </itemizedlist>

          <para>
            <emphasis role="bold">Esempio di una CTE non recursiva</emphasis>
          </para>

          <programlisting>
WITH
  DEPT_YEAR_BUDGET AS (
    SELECT FISCAL_YEAR, DEPT_NO,
        SUM(PROJECTED_BUDGET) AS BUDGET
      FROM PROJ_DEPT_BUDGET
    GROUP BY FISCAL_YEAR, DEPT_NO
  )
SELECT D.DEPT_NO, D.DEPARTMENT,
  B_1993.BUDGET AS B_1993, B_1994.BUDGET AS B_1994,
       B_1995.BUDGET AS B_1995, B_1996.BUDGET AS B_1996
  FROM DEPARTMENT D
    LEFT JOIN DEPT_YEAR_BUDGET B_1993
      ON D.DEPT_NO = B_1993.DEPT_NO
      AND B_1993.FISCAL_YEAR = 1993
    LEFT JOIN DEPT_YEAR_BUDGET B_1994
      ON D.DEPT_NO = B_1994.DEPT_NO
      AND B_1994.FISCAL_YEAR = 1994
    LEFT JOIN DEPT_YEAR_BUDGET B_1995
      ON D.DEPT_NO = B_1995.DEPT_NO
      AND B_1995.FISCAL_YEAR = 1995
    LEFT JOIN DEPT_YEAR_BUDGET B_1996
      ON D.DEPT_NO = B_1996.DEPT_NO
      AND B_1996.FISCAL_YEAR = 1996

  WHERE EXISTS (
    SELECT * FROM PROJ_DEPT_BUDGET B
    WHERE D.DEPT_NO = B.DEPT_NO)
          </programlisting>
        </section>

        <section id="rnfb210-cte-rules-recrsv">
          <title>Regole per le CTE recursive</title>

          <itemizedlist>
            <listitem>
              <para>Una CTE recursiva è autoreferenziante (ha un riferimento a
              sé stessa)</para>
            </listitem>

            <listitem>
              <para>Una CTE recursiva è una UNION di membri recursivi e non
              recursivi.</para>

              <itemizedlist>
                <listitem>
                  <para>Deve essere presente almeno un elemento non recursivo
                  (ancoraggio o elemento fisso)</para>
                </listitem>

                <listitem>
                  <para>I membri non recursivi devono essere messi prima nella
                  UNION</para>
                </listitem>

                <listitem>
                  <para>I membri recursivi sono separati dagli elementi di
                  ancoraggio fissi e gli uni dagli altri con una clausola
                  UNION ALL, cioè,</para>

                  <literallayout>   membro non recursivo (àncora)
   UNION [ALL | DISTINCT]
   membro non recursivo (àncora)
   UNION [ALL | DISTINCT]
   membro non recursivo (àncora)
   UNION ALL
   membro recursivo
   UNION ALL
   membro recursivo
                  </literallayout>
                </listitem>
              </itemizedlist>
            </listitem>

            <listitem>
              <para>I riferimenti fra le varie CTE non devono avere
              circolarità</para>
            </listitem>

            <listitem>
              <para>Le aggregazioni (DISTINCT, GROUP BY, HAVING) e le funzioni
              di aggregazione (SUM, COUNT, MAX ecc) non sono permesse nei
              membri recursivi</para>
            </listitem>

            <listitem>
              <para>Un membro recursivo può avere uno ed un solo un
              riferimento a sé stessa e solo nella sua clausola FROM</para>
            </listitem>

            <listitem>
              <para>Un riferimento recursivo non può partecipare ad una OUTER
              JOIN</para>
            </listitem>
          </itemizedlist>

          <para>
            <emphasis role="bold">Esempio di una CTE recursiva</emphasis>
          </para>

          <programlisting>
WITH RECURSIVE
  DEPT_YEAR_BUDGET AS
  (
    SELECT FISCAL_YEAR, DEPT_NO,
        SUM(PROJECTED_BUDGET) AS BUDGET
      FROM PROJ_DEPT_BUDGET
    GROUP BY FISCAL_YEAR, DEPT_NO
  ),

  DEPT_TREE AS
  (
    SELECT DEPT_NO, HEAD_DEPT, DEPARTMENT,
        CAST('' AS VARCHAR(255)) AS INDENT
      FROM DEPARTMENT
     WHERE HEAD_DEPT IS NULL

    UNION ALL

    SELECT D.DEPT_NO, D.HEAD_DEPT, D.DEPARTMENT,
    H.INDENT || '  '
      FROM DEPARTMENT D
      JOIN DEPT_TREE H
        ON D.HEAD_DEPT = H.DEPT_NO
  )

  SELECT D.DEPT_NO,
	D.INDENT || D.DEPARTMENT AS DEPARTMENT,
	B_1993.BUDGET AS B_1993,
	B_1994.BUDGET AS B_1994,
	B_1995.BUDGET AS B_1995,
	B_1996.BUDGET AS B_1996

  FROM DEPT_TREE D
    LEFT JOIN DEPT_YEAR_BUDGET B_1993
      ON D.DEPT_NO = B_1993.DEPT_NO
      AND B_1993.FISCAL_YEAR = 1993

    LEFT JOIN DEPT_YEAR_BUDGET B_1994
      ON D.DEPT_NO = B_1994.DEPT_NO
      AND B_1994.FISCAL_YEAR = 1994

    LEFT JOIN DEPT_YEAR_BUDGET B_1995
      ON D.DEPT_NO = B_1995.DEPT_NO
      AND B_1995.FISCAL_YEAR = 1995

    LEFT JOIN DEPT_YEAR_BUDGET B_1996
      ON D.DEPT_NO = B_1996.DEPT_NO
      AND B_1996.FISCAL_YEAR = 1996
          </programlisting>
        </section>
      </section>
    </section>

    <section id="rnfb210-list" xreflabel="La funzione LIST">
      <sectioninfo>
        <title>La funzione LIST</title>

        <authorgroup>
          <author>
            <firstname>Oleg</firstname>

            <surname>Loa</surname>
          </author>

          <author>
            <firstname>Dmitry</firstname>

            <surname>Yemanov</surname>
          </author>
        </authorgroup>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> Questa funzione riporta
      una stringa che è il concatenamento di tutti i valori non NULL di un
      raggruppamento. Riporta NULL se non ci sono valori non-NULL.</para>

      <para>
        <emphasis role="bold">Formato</emphasis>
      </para>

      <programlisting>
&lt;list function&gt; ::=
  LIST '(' [ {ALL | DISTINCT} ] &lt;espressione&gt; [',' &lt;delimitatore&gt;
   ] ')'

&lt;delimitatore&gt; ::=
      { &lt;stringa&gt; | &lt;parametro&gt; | &lt;variabile&gt; }
    </programlisting>

      <para>
        <emphasis role="bold">Regole sintattiche</emphasis>
      </para>

      <orderedlist>
        <listitem>
          <para>Se non si specifica né ALL e neppure DISTINCT, si intende
          implicitamente ALL.</para>
        </listitem>

        <listitem>
          <para>Se è omesso il &lt;delimitatore&gt;, si adopera una virgola
          per separare i valori concatenati.</para>
        </listitem>
      </orderedlist>

      <para>
        <emphasis role="bold">Altre note</emphasis>
      </para>

      <orderedlist>
        <listitem>
          <para>I valori numerici e data/ora sono implicitamente convertiti in
          stringhe nella valutazione delle espressioni.</para>
        </listitem>

        <listitem>
          <para>Il risultato è di tipo BLOB con SUB_TYPE TEXT in ogni caso,
          eccetto una lista esplicita di BLOB con sottotipi diversi.</para>
        </listitem>

        <listitem>
          <para>L'ordine dei valori nel gruppo è dipendente
          dall'implementazione (quindi non fateci affidamento, perchè può
          cambiare!).</para>
        </listitem>
      </orderedlist>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <programlisting>
/* A */
  SELECT LIST(ID, ':')
  FROM MY_TABLE

/* B */
  SELECT TAG_TYPE, LIST(TAG_VALUE)
  FROM TAGS
  GROUP BY TAG_TYPE
      </programlisting>
    </section>

    <section id="rnfb210-rtrng" xreflabel="La clausola RETURNING">
      <sectioninfo>
        <title>La clausola <filename>RETURNING</filename></title>

        <authorgroup>
          <author>
            <firstname>Dmitry</firstname>

            <surname>Yemanov</surname>
          </author>

          <author>
            <firstname>Adriano</firstname>

            <surname>dos Santos Fernandes</surname>
          </author>
        </authorgroup>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> Lo scopo di questa
      clausola è quella di permettere al client di avere di ritorno dalle
      frasi di <filename>INSERT</filename>, <filename>UPDATE</filename>,
      <filename>UPDATE OR INSERT</filename> e <filename>DELETE</filename> i
      valori inseriti (o eliminati) in una tabella.</para>

      <para>L'uso tipico è recuperare il valore generato per una chiave
      primaria dall'esecuaione di un trigger <filename>BEFORE</filename>. La
      clausola <filename>RETURNING</filename> è opzionale ed è disponibile sia
      in DSQL che in PSQL, sebbene ci siano leggere differenze nella
      sintassi.</para>

      <para>In DSQL, l'esecuzione dell'operazione stessa ed il riporto dei
      valori avvengono una unico ciclo di esecuzione.</para>

      <para>Poichè la clausola <filename>
          <filename>RETURNING</filename>
        </filename> è stata progettata per riportare un solo record di dati
      (singleton) in risposta all'esecuzione di una operazione su una singola
      registrazione, non è consentito specificare tale clausola nelle frasi
      che inseriscono, aggiornano o cancellano più di un record.</para>

      <note>
        <para>In DSQL, si riporta comunque una riga, anche se nessun record ha
        soddisfatto le condizioni per l'operazione, e quindi nessun record è
        stato toccato. Pertanto, a questo stadio dell'implementazione, c'è la
        possibilità di riportare un record <quote>vuoto</quote>, cioè
        contenente tutti NULL. Questo potrebbe essere modificato in una futura
        release.</para>

        <para>In PSQL, invece, se il comando non influisce su nessuna
        registrazione, non riporta valori e pertanto nessuna delle variabili
        di ritorno, specificate nella clausola INTO, viene modificata.</para>
      </note>

      <para>
        <emphasis role="bold">Regole sintattiche generali</emphasis>
      </para>

      <programlisting>
INSERT INTO ... VALUES (...)
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

INSERT INTO ... SELECT ...
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

UPDATE OR INSERT INTO ... VALUES (...) ...
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

UPDATE ... [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

DELETE FROM ...
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]
      </programlisting>

      <section id="rnfb210-rtrng-rules">
        <title>Regole nell'uso della clausola
        <filename>RETURNING</filename></title>

        <orderedlist>
          <listitem>
            <para>La parte della clausola INTO (cioè la lista delle variabili)
            è permessa solo in PSQL, per assegnare il record di risultati in
            uscita direttamente alle variabili locali. Ovviamente non è
            accettata in DSQL.</para>
          </listitem>

          <listitem>
            <para>La della clausola RETURNING fa sì che un INSERT venga
            descritto dall'API come una
            <filename>isc_info_sql_stmt_exec_procedure</filename> e non come
            una <filename>isc_info_sql_stmt_insert</filename>. Gli attuali
            driver di interfaccia dovrfebbero essere in grado di gestire
            questa caratteristica senza particolari modifiche.</para>
          </listitem>

          <listitem>
            <para>La clausola RETURNING ignora ogni esplicita modifica o
            cancellazione che possa risultare dall'esecuzione di un AFTER
            trigger.</para>
          </listitem>

          <listitem>
            <para>Le variabili di contesto OLD e NEW possono essere utilizzate
            nella clausola RETURNING di una frase UPDATE o INSERT OR
            UPDATE.</para>
          </listitem>

          <listitem>
            <para>Nelle frasi UPDATE o INSERT OR UPDATE, ai riferimenti di
            campi non qualificati o qualificati dal nome di una tabella o di
            un alias vengono attribuiti i valori delle corrispondenti
            variabili di contesto NEW.</para>
          </listitem>
        </orderedlist>

        <para>
          <emphasis role="bold">Esempi</emphasis>
        </para>

        <orderedlist>
          <listitem>
            <programlisting>
INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2)
      RETURNING F1, F2 INTO :V1, :V2;
            </programlisting>

            <para />
          </listitem>

          <listitem>
            <programlisting>
INSERT INTO T2 (F1, F2)
    VALUES (1, 2)
      RETURNING ID INTO :PK;
            </programlisting>

            <para />
          </listitem>

          <listitem>
            <programlisting>
DELETE FROM T1
  WHERE F1 = 1
    RETURNING F2;
            </programlisting>

            <para />
          </listitem>

          <listitem>
            <programlisting>
UPDATE T1
    SET F2 = F2 * 10
      RETURNING OLD.F2, NEW.F2;
            </programlisting>

            <para />
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section id="rnfb210-updorinsrt" xreflabel="La frase UPDATE OR INSERT">
      <sectioninfo>
        <title>La frase <filename>UPDATE OR INSERT</filename></title>

        <author>
          <firstname>Adriano</firstname>

          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> Questa sintassi è stata
      introdotto per poter inserire o aggiornare un record in funzione della
      sua effettiva esistenza (verificata con <filename>IS NOT
      DISTINCT</filename>). La frase è disponibili sia in DSQL che in
      PSQL.</para>

      <para>
        <emphasis role="bold">Sintassi</emphasis>
      </para>

      <programlisting>
UPDATE OR INSERT INTO &lt;table or view&gt; [(&lt;column_list&gt;)]
    VALUES (&lt;value_list&gt;)
    [MATCHING (&lt;column_list&gt;)]
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]
      </programlisting>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <orderedlist>
        <listitem>
          <para />

          <programlisting>
UPDATE OR INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2);
          </programlisting>
        </listitem>

        <listitem>
          <para />

          <programlisting>
UPDATE OR INSERT INTO EMPLOYEE (ID, NAME)
    VALUES (:ID, :NAME)
    RETURNING ID;
          </programlisting>
        </listitem>

        <listitem>
          <para />

          <programlisting>
UPDATE OR INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2)
    MATCHING (F1);
          </programlisting>
        </listitem>

        <listitem>
          <para />

          <programlisting>
UPDATE OR INSERT INTO EMPLOYEE (ID, NAME)
    VALUES (:ID, :NAME)
    RETURNING OLD.NAME;
          </programlisting>
        </listitem>
      </orderedlist>

      <section id="rnfb210-updorinsrt-notes">
        <title>Note sull'uso</title>

        <orderedlist>
          <listitem>
            <para>Quando si omette la clausola <filename>MATCHING</filename> è
            richiesta l'esistenza di una chiave primaria.</para>
          </listitem>

          <listitem>
            <para>Sono necessari irelativi permessi di
            <filename>INSERT</filename> e <filename>UPDATE</filename> sulla
            &lt;table or view&gt;.</para>
          </listitem>

          <listitem>
            <para>Se è presente la clausola <filename>RETURNING</filename>,
            allora la frase è descritta dall'API con una
            <filename>isc_info_sql_stmt_exec_procedure</filename>;  altrimenti
            è descritta come una
            <filename>isc_info_sql_stmt_insert</filename>.</para>
          </listitem>
        </orderedlist>

        <note>
          <para>Un errore di <quote>multiple rows in singleton select</quote>
          (righe multiple in una select che richiede un risultato a riga
          singola) viene lanciato se la clausola
          <filename>RETURNING</filename> è presente e più di un record
          soddisfa le condizioni di ricerca.</para>
        </note>
      </section>
    </section>

    <section id="rnfb210-merge" xreflabel="La frase MERGE" xml:base="">
      <sectioninfo>
        <title>La frase <filename>MERGE</filename></title>

        <author>
          <firstname>Adriano</firstname>

          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> Questa sintassi è stata
      aggiunta per permettere di modificare o inserire un record se viene
      soddisfatta una certa condizione data. La frase è disponibile sia in
      DSQL che in PSQL.</para>

      <para>
        <emphasis role="bold">Sintassi</emphasis>
      </para>

      <programlisting>
&lt;merge&gt; ::=
MERGE
  INTO &lt;tabella o vista&gt; [ [AS] &lt;nome di correlazione&gt; ]
  USING &lt;tabella o vista o tabella derivata&gt; [ [AS] &lt;nome di correlazione&gt; ]
    ON &lt;condizione&gt;
    [ &lt;merge quando soddisfatto&gt; ]
    [ &lt;merge quando non soddisfatto&gt; ]

&lt;merge quando soddisfatto&gt; ::=
  WHEN MATCHED THEN
    UPDATE SET &lt;lista assegnazioni&gt;

&lt;merge quando non soddisfatto&gt; ::=
  WHEN NOT MATCHED THEN
    INSERT [ &lt;parentesi aperta&gt; &lt;lista di colonne&gt; &lt;parentesi chiusa&gt; ]
    VALUES &lt;parentesi aperta&gt; &lt;lista di valori&gt; &lt;parentesi chiusa&gt;
      </programlisting>

      <section id="rnfb210-merge-rules">
        <title>Regole per il <filename>MERGE</filename></title>

        <orderedlist>
          <listitem>
            <para>Deve essere sempre specificata almeno una delle due fra le
            condizione &lt;merge quando soddisfatto&gt; e &lt;merge quando non
            soddisfatto&gt;.</para>
          </listitem>

          <listitem>
            <para>Nessuna delle due condizioni può essere specificata più di
            una volta.</para>
          </listitem>
        </orderedlist>
      </section>

      <note>
        <para>Per l'esecuzione viene effettuata una <filename>RIGHT
        JOIN</filename> tra le tabelle specificate nelle parti
        <filename>INTO</filename> e <filename>USING</filename>, facendo uso
        della condizione specificata. L'<filename>UPDATE</filename> viene
        eseguita quando esiste un record che soddisfa la condizione, nella
        tabella a sinistra (INTO), altrimenti si effettua l'operazione di
        <filename>INSERT</filename>.</para>

        <para>Se la join non riporta nessun record, non viene effettuata
        nessuna operazione e pertanto neanche la INSERT.</para>
      </note>

      <para>
        <emphasis role="bold">Esempio</emphasis>
      </para>

      <programlisting>
MERGE INTO customers c
  USING (SELECT * FROM customers_delta WHERE id &gt; 10) cd
  ON (c.id = cd.id)
    WHEN MATCHED THEN
      UPDATE SET
        name = cd.name
    WHEN NOT MATCHED THEN
      INSERT (id, name)
      VALUES (cd.id, cd.name)
      </programlisting>
    </section>

    <section id="rnfb210-joins" xreflabel="Nuovi tipi di JOIN">
      <sectioninfo>
        <title>Nuovi tipi di JOIN</title>

        <author>
          <firstname>Adriano</firstname>

          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> Sono stati introdotti due
      nuovi tipi di <filename>JOIN</filename>: la join <firstterm>NAMED
      COLUMNS</firstterm> (colonne in comune) e la join
      <filename>NATURAL</filename>.</para>

      <section id="rnfb210-joins-sntx"
               xreflabel="NAMED COLUMNS &amp; NATURAL JOIN">
        <title>Sintassi e regole</title>

        <programlisting>
&lt;named columns join&gt; ::=
  &lt;table reference&gt; &lt;join type&gt; JOIN &lt;table reference&gt;
    USING ( &lt;column list&gt; )

&lt;natural join&gt; ::=
 &lt;table reference&gt; NATURAL &lt;join type&gt; JOIN &lt;table primary&gt;
        </programlisting>

        <section id="rnfb210-joins-ncolms">
          <title>Named columns join (colonne in comune)</title>

          <orderedlist>
            <listitem>
              <para>Tutte le colonne specificate nella lista di colonne
              &lt;column list&gt; devono esistere da entrambe le parti, cioè
              nelle tabelle destra e sinistra.</para>
            </listitem>

            <listitem>
              <para>Viene automaticamente creata una equi-join (&lt;tabella
              sinistra&gt;.&lt;colonna&gt; = &lt;tabella
              desta&gt;.&lt;colonna&gt;) per ogni colonna elencata e, se ce
              n'è più di una, vengono fra di loro tutte collegate da
              <filename>AND</filename>.</para>
            </listitem>

            <listitem>
              <para>Nella lista di campi specificati per l'output della
              <filename>SELECT</filename>, le colonne specificate in <filename>
                  <filename>USING</filename>
                </filename> possono essere riportate senza qualificatori. In
              tal caso, il risultato è equivalente a COALESCE(&lt;tabella
              sinistra&gt;.&lt;colonna&gt;, &lt;tabella
              destra&gt;.&lt;colonna&gt;).</para>
            </listitem>

            <listitem>
              <para>In caso di <quote>SELECT *</quote>, le colonne di
              <filename>USING</filename> sono espanse una sola volta, usando
              la regola sopra specificata.</para>
            </listitem>
          </orderedlist>
        </section>

        <section id="rnfb210-joins-ntrl">
          <title>Natural join</title>

          <orderedlist>
            <listitem>
              <para>Viene creata automaticamente una <quote>named columns
              join</quote> con tutte le colonne comuni tra le due tabelle
              coinvolte.</para>
            </listitem>

            <listitem>
              <para>Se non ci sono colonne comuni si effettua una
              <filename>CROSS JOIN</filename>.</para>
            </listitem>
          </orderedlist>
        </section>

        <para>
          <emphasis role="bold">Esempi</emphasis>
        </para>

        <programlisting>
/* 1 */
select * from employee
  join department
  using (dept_no);

/* 2 */
select * from employee_project
  natural join employee
  natural join project;
        </programlisting>
      </section>

      <section id="rnfb20x-dml-cross-join" xreflabel="CROSS JOIN">
        <sectioninfo>
          <title>CROSS JOIN</title>

          <author>
            <firstname>D.</firstname>

            <surname>Yemanov</surname>
          </author>
        </sectioninfo>

        <para><emphasis role="bold">(V.2.0.x)</emphasis> La sintassi CROSS
        JOIN è adesso supportata. Dal punto di vista logico, la
        sintassi:</para>

        <programlisting>
   A CROSS JOIN B
        </programlisting>

        <para>è equivalente alla seguente:</para>

        <programlisting>
   A INNER JOIN B ON 1 = 1
        </programlisting>

        <para>oppure, più semplicemente a:</para>

        <programlisting>
  FROM A, B
        </programlisting>

        <section id="rnfb212-dml-cross-join">
          <sectioninfo>
            <title>Prestazioni migliorate nella V.2.1.2</title>

            <author>
              <firstname>D.</firstname>

              <surname>Yemanov</surname>
            </author>
          </sectioninfo>

          <para>Nel raro caso in cui in una cross join con tre o più tabelle
          coinvolte, una o più di queste fossero vuote si è registrato un
          brusco calo nelle prestazioni <ulink
              url="http://tracker.firebirdsql.org/browse/CORE-2200">
              <emphasis>(CORE-2200)</emphasis>
            </ulink>. Un miglioramento delle prestazioni è stato ottenuto
          istruendo l'ottimizzatore a non sprecare tempo ed energie nello
          scorrere le tabelle piene nel tentativo di trovare impossibili
          riscontri con tabelle vuote.</para>
        </section>
      </section>
    </section>

    <section id="rnfb210-dml-insrt" xreflabel="I default per l'INSERT">
      <sectioninfo>
        <title>I default per l'INSERT</title>

        <author>
          <firstname>D.</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para>
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-863">Richiesta
        di nuova specifica</ulink>
      </para>

      <para><emphasis role="bold">(v.2.1)</emphasis> Adesso è possibile
      effettuare inserimenti senza specificare valori, se ci sono trigger
      BEFORE INSERT e/o defaults disponibili per ogni colonna necessaria e
      nessuno di questi dipende da un valore di campo NEW fornito dal comando
      standard. In soldoni, niente deve dipendere dalla parte VALUES(&lt;lista
      di valori&gt;).</para>

      <para>
        <emphasis role="bold">Esempio</emphasis>
      </para>

      <programlisting>
INSERT INTO &lt;table&gt;
  DEFAULT VALUES
  [RETURNING &lt;values&gt;]
      </programlisting>
    </section>

    <section id="rnfb210-blbvchar" xreflabel="Compatibilità fra testo e BLOB">
      <sectioninfo>
        <title>Compatibilità fra testo VARCHAR e BLOB</title>

        <author>
          <firstname>A.</firstname>

          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> A vari livelli di
      gestione, il motore adesso tratta i BLOB di testo che contengono
      stringhe più corte di 32766 byte come se fossero di tipo VARCHAR. La
      lunghezza massima per questa conversione implicita è pertanto 32765
      bytes (non caratteri!).</para>

      <para>Le operazioni che permettono ai BLOB di testo di comportarsi come
      stringhe VARCHAR sono le assegnazioni, conversioni e concatenazioni
      (fino al limite sopra specificato per il risultato della
      concatenzaione), così come le funzioni CAST, LOWER, UPPER, TRIM e
      SUBSTRING.</para>

      <warning>
        <title>Attenzione!</title>

        <para>La funzione SUBSTRING(), se applicata ad un BLOB di testo,
        adesso ha per risultato un BLOB di testo, e non più un VARCHAR come
        nelle versioni precedenti. Questa modifica potrebbe influenzare il
        risultato nel codice esistente sia client che PSQL.</para>
      </warning>
    </section>

    <section id="rnfb20x-blob-compare" xreflabel="Comparare BLOB di testo">
      <title>Comparazione sul contenuto completo dei BLOB di testo</title>

      <para><emphasis role="bold">(v.2.0.x)</emphasis> Si possono effettuare
      comparazioni sull'intero contenuto di un BLOB di testo.</para>
    </section>

    <section id="rnfb210-dml-dbkey"
             xreflabel="RDB$DB_KEY riporta NULL nelle OUTER JOIN">
      <sectioninfo>
        <title>RDB$DB_KEY riporta NULL nelle OUTER JOIN</title>

        <author>
          <firstname>A.</firstname>

          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>

      <para>
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-979">Richiesta
        CORE-979</ulink>
      </para>

      <para><emphasis role="bold">(v.2.1)</emphasis> Per qualche anomalia, la
      RDB$DB_KEY fisica ha sempre riportato un valore in ogni riga quando si
      specifica una OUTER JOIN, pertanto effetuando un test su quei valori
      dove ci si aspetterebbe un NULL per mancanza di corrispondenza, nelle
      versioni precedenti il test avrebbe riportato un risultato errato
      (rovesciato: falso al posto di vero). Ora, RDB$DB_KEY riporta
      correttamente NULL quando dovrebbe.</para>
    </section>

    <section id="rnfb210-dsqlchanges-blobsort"
             xreflabel="Ordinare i BLOB e gli Array">
      <sectioninfo>
        <title>Riammesso l'ordinamento nelle colonne BLOB e ARRAY</title>

        <author>
          <firstname>Dmitry</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para><emphasis role="bold">(v.2.1)</emphasis> Nelle prime pre-release
      di Firebird 2.1, sono stati introdotti controlli per rifiutare gli
      ordinamenti (nelle operazioni di ORDER BY, GROUP BY e SELECT DISTINCT)
      al momento della preparazione se la clausola di ordinamento
      implicitamente o esplicitamente implicava il sort su una colonna di tipo
      BLOB o ARRAY.</para>

      <para>Questa modifica è stata eliminata nella pre-release RC2, non
      perchè sbagliata ma perchè molti utenti si sono lamentati che le loro
      applicazioni non funzionavano più.</para>

      <important>
        <para>Questo ritorno al <quote>passato</quote> non implica in nessun
        modo che tali query possano magicamente riportare risultati corretti.
        Un BLOB generico non può essere automaticamente convertito ad un tipo
        di dato ordinabile, e pertanto, come un tempo, gli ordinamenti
        DISTINCT e gli argomenti di ORDER BY che includono BLOB, usano il
        BLOB_ID. Come succedeva prima, le query dove gli argomenti di GROUP BY
        sono tipi BLOB, si possono prepare, ma provocano eccezioni durante
        l'esecuzione.</para>
      </important>
    </section>

    <section id="rnfb210-builtin" xreflabel="Funzioni integrate">
      <title>Funzioni integrate</title>

      <para><emphasis role="bold">(v.2.1)</emphasis> Sono state migliorate
      alcune delle funzioni integrate esistenti, e ne sono state aggiunte un
      bel po'.</para>

      <section id="rnfb210-builtin-new" xreflabel="Nuove funzioni integrate">
        <sectioninfo>
          <title>Nuove funzioni integrate</title>

          <authorgroup>
            <author>
              <firstname>Adriano</firstname>

              <surname>dos Santos Fernandes</surname>
            </author>

            <author>
              <firstname>Oleg</firstname>

              <surname>Loa</surname>
            </author>

            <author>
              <firstname>Alexey</firstname>

              <surname>Karyakin</surname>
            </author>
          </authorgroup>
        </sectioninfo>

        <para>Un certo numero di funzioni sono state integrate direttamente
        nel motore di Firebird 2.1 per sostituire analoghe funzioni presenti
        nelle UDF con lo stesso nome. Le funzioni integrate non vengono usate
        se nel database sono dichiarate con lo stesso nome le funzioni delle
        UDF.</para>

        <note>
          <para>La scelta tra UDF e funzione integrata viene decisa al momento
          della compilazione dello statement. Questo implica che tutto il
          codice PSQL compilato mentre sono definite le UDF nel database
          continuerà a richiedere che le dichiarazioni delle UDF siano
          presenti fino a che non viene ricompilato.</para>

          <para>La nuova funzione integrata <emphasis>DECODE()</emphasis> non
          ha un'equivalente nelle librerie UDF distribuite con
          Firebird.</para>
        </note>

        <para>L'elenco di tali funzioni è esposto in dettagli in <xref
        linkend="rnfb210-appx-A" />.</para>

        <note>
          <para>Molte di queste funzioni integrate erano già disponibili in
          Firebird 2/ODS 11, ad esempio LOWER(), TRIM(), BIT_LENGTH(),
          CHAR_LENGTH() and OCTET_LENGTH().</para>
        </note>
      </section>

      <section id="rnfb210-builtin-enh"
               xreflabel="Miglioramenti alle funzioni integrate">
        <sectioninfo>
          <title>Miglioramenti alle funzioni integrate</title>

          <author>
            <firstname>A.</firstname>

            <surname>dos Santos Fernandes</surname>
          </author>
        </sectioninfo>

        <variablelist>
          <varlistentry>
            <term>EXTRACT(WEEK FROM DATE)</term>

            <listitem>
              <para>Richiesta in <ulink
              url="http://tracker.firebirdsql.org/browse/CORE-663">CORE-663</ulink></para>

              <para>La funzione EXTRACT() è stata estesa per supportare i
              numeri di settimana dell'anno secondo lo standard ISO-8601. Per
              esempio:</para>

              <programlisting>
EXTRACT (WEEK FROM date '30.09.2007')
               </programlisting>

              <para>riporta 39. Altro esempio:</para>
            </listitem>

            <listitem>
              <programlisting>
ALTER TABLE XYZ
ADD WeekOfTheYear
COMPUTED BY (
  CASE
    WHEN (EXTRACT(MONTH FROM DataEsempio) = 12)
    AND (EXTRACT(WEEK FROM DataEsempio) = 1)
    THEN
      'Settimana '|| EXTRACT (WEEK FROM DataEsempio)||' dell''anno '
      || (1 + (EXTRACT( YEAR FROM DataEsempio)))
    else 'Settimana '||EXTRACT (WEEK FROM DataEsempio)||' dell''anno '
      ||EXTRACT( YEAR FROM DataEsempio)
  end )
               </programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Specificare la scala in TRUNC()</term>

            <listitem>
              <para>Richiesta in <ulink
              url="http://tracker.firebirdsql.org/browse/CORE-1340">CORE-1340</ulink></para>

              <para>Fino alla versione Beta 1 la funzione integrata TRUNC()
              aveva un solo argomento, il valore da troncare. A partire dalla
              Beta 2 può essere specificato un secondo argomento opzionale per
              indicare la scala del troncamento. Ad esempio:</para>

              <programlisting>
select
  trunc(987.65, 1),
  trunc(987.65, -1)
  from rdb$database;
               </programlisting>

              <para>riporta i due valori 987.60 e 980.00</para>

              <para>Per altri esempi d'uso della TRUNC() con o senza
              l'argomento di scala opzionale, vedere all'elenco alfabetico
              delle funzioni nell'Appendice A.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Gestione dei millisecondi in EXTRACT(), DATEADD() e
            DATEDIFF()</term>

            <listitem>
              <para>Richiesta in <ulink
              url="http://tracker.firebirdsql.org/browse/CORE-1387">CORE-1387</ulink></para>

              <para>A partire da Firebird 2.1 Beta 2, le funzioni integrate
              EXTRACT(), DATEADD() e DATEDIFF() possono gestire i millisecondi
              rappresentati da un numero intero di 4 cifre. Ad esempio:</para>

              <programlisting>
EXTRACT ( MILLISECOND FROM timestamp '01.01.2000 01:00:00.1234' )
               </programlisting>

              <para>riporta 123</para>

              <programlisting>
DATEADD ( MILLISECOND, 100, timestamp '01.01.2000 01:00:00.0000' )
DATEDIFF ( MILLISECOND, timestamp '01.01.2000 02:00:00.0000', timestamp '01.01.2000 01:00:00.0000' )
               </programlisting>

              <para>Per esempi più particolareggiati sull'uso di DATEADD() e
              DATEDIFF(), fare riferimento all'elenco delle funzioni integrate
              in Appendice A.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section id="rnfb20x-dml-enhfunc">
      <title>Funzioni migliorate già dalla versione 2.0.x</title>

      <para>Alcune migliorie alle funzioni integrate erano già disponibili
      nelle versioni 2.0.x di Firebird:</para>

      <section id="rnfb20x-dml-iif" xreflabel="IIF()">
        <sectioninfo>
          <title>IIF()</title>

          <author>
            <firstname>O.</firstname>

            <surname>Loa</surname>
          </author>
        </sectioninfo>

        <para><emphasis role="bold">(V.2.0.x)</emphasis> Per testare una
        condizione ed avere esattamente due soli valori in alternativa, si può
        usare la funzione IIF() al posto della più prolissa espressione CASE.
        IIF() riporta il valore della prima di due espressioni se la
        condizione di test è vera, altrimenti riportaq il valore della seconda
        espressione. Il test è per la precisione una condizione di ricerca, ed
        ammette la stessa sintassi della parte WHERE di una SELECT.</para>

        <programlisting>
   IIF (&lt;condizione_di_ricerca&gt;, &lt;valore_se_vero&gt;, &lt;valore_altrimenti&gt;)
        </programlisting>

        <para>viene implementato come un'abbreviazione di:</para>

        <programlisting>
   CASE
     WHEN &lt;condizione_di_ricerca&gt; THEN &lt;valore_se_vero&gt;
     ELSE &lt;valore_altrimenti&gt;
   END
        </programlisting>

        <para>
          <emphasis role="bold">Esempio</emphasis>
        </para>

        <programlisting>
    SELECT IIF(VAL &gt; 0, VAL, -VAL) FROM OPERATION
        </programlisting>
      </section>

      <section id="rnfb20x-dml-cast"
               xreflabel="Miglioramenti nel comportamento di CAST()">
        <sectioninfo>
          <title>Miglioramenti nel comportamento di CAST()</title>

          <author>
            <firstname>D.</firstname>

            <surname>Yemanov</surname>
          </author>
        </sectioninfo>

        <para><emphasis role="bold">(V.2.0.x)</emphasis> L'errore
        <quote>Datatype unknown</quote> (SF Bug #1371274) che compariva
        tentando certi CAST è stato eliminato. Ora è possibile usare CAST()
        per avvisare il motore del tipo di dato di certi parametri.</para>

        <para>
          <emphasis>Esempio</emphasis>
        </para>

        <programlisting>
  SELECT CAST(? AS INT) FROM RDB$DATABASE
        </programlisting>
      </section>

      <section id="rnfb20x-dml-substring-changes">
        <section id="rnfb20x-dml-substring"
                 xreflabel="Argomenti espressione per SUBSTRING()">
          <sectioninfo>
            <title>Argomenti espressione per SUBSTRING()</title>

            <author>
              <firstname>O.</firstname>

              <surname>Loa, D. Yemanov</surname>
            </author>
          </sectioninfo>

          <para><emphasis role="bold">(V.2.0.x)</emphasis> La funzione
          integrata SUBSTRING() può ricevere ora nei parametri espressioni
          valutabili come interi.</para>

          <para>Precedentemente la funzione integrata SUBSTRING() poteva
          accettare solo valori interi come secondo e terzo
          parametro(rispettivamente posizione iniziale e lunghezza). Ora tali
          argomenti possono essere costituiti da qualsiasi espressione che
          possa avere un valore numerico, tra cui parametri host, risultati di
          funzione, espressioni, subquery ecc. ecc.</para>

          <tip>
            <para>Se nel tentativo di usare questa caratteristica ci sono
            errori di <quote>invalid token</quote>, ricordarsi che le
            espressioni usate negli argomenti spesso devono essere racchiuse
            tra parentesi tonde!</para>
          </tip>
        </section>

        <section id="rnfb20x-dml-substring2">
          <title>Modifiche ai risultati ottenuti da SUBSTRING()</title>

          <para><emphasis role="bold">(V.2.1.x)</emphasis> Per aderire allo
          standard, la lunghezza in caratteri applicando una SUBSTRING() ad un
          campo VARCHAR o CHAR è adesso un VARCHAR della stessa lunghezza
          dichiarata o dedotta per il valore del primo argomento.</para>

          <para>In Firebird 2.0 e 1.5, il valore era un CHAR con la stessa
          lunghezza in caratteri del valore dichiarato o implicito ancora del
          primo argomento. Tale regola avrebbe creato problemi in in Firebird
          2.0 nel caso in cui la stringa in ingresso era CHAR e l'argomento
          del FOR era un'espressione la cui dimensione sarebbe stata ignota la
          momento della preparazione della zona di memoria che avrebbe dovuto
          contenere la stringa risultante. La modifica della V.2.1 ha corretto
          questo fatto.</para>

          <para>Non è necessario ridefinire ogni variabile PSQL che è stata
          dichiarata a ricevere il risultato da una SUBSTRING(). Rimane
          corretto dichiarare la sua dimensione grande abbastanza a contenere
          il dato effettivamente riportato. È sufficiente essere certi che
          qualsiasi espressione usata nell'argomento del FOR non possa avere
          un valore intero superiore al numero dei caratteri dichiarati di
          quella variabile.</para>

          <important>
            <title>Problemi dei campi BLOB</title>

            <para>Chiaramente, essendo un testo BLOB di lunghezza
            indeterminata, non può rientrare in un paradigma in cui può
            riempire una stringa di dimensione massima nota. Pertanto, il
            risultato riportato da SUBSTRING() applicato ad un BLOB di testo
            non è un VARCHAR() come specificato sopra, ma ancora un BLOB di
            testo.</para>

            <para>Questa modifica può pertanto bloccare codice PSQL ed altre
            espressioni funzionanti.</para>

            <itemizedlist>
              <listitem>
                <para>Attenzione ai sottodimensionamenti! Fare particolare
                attenzione ai CAST e alle concatenazioni.</para>
              </listitem>

              <listitem>
                <para>Fare attenzione all'uso della memoria quando si
                assegnano BLOB temporanei nei cicli! Il motore alloca un
                minimo di una pagina di memoria per ogni BLOB temporaneo,
                indipendentemente dalla sua reale dimensione.</para>
              </listitem>
            </itemizedlist>
          </important>
        </section>
      </section>
    </section>

    <section id="rnfb20x-dml-parsing"
             xreflabel="In DSQL la scansione dei nomi di tabella è più rigida">
      <sectioninfo>
        <title>In DSQL la scansione dei nomi di tabella è più rigida</title>

        <author>
          <firstname>A.</firstname>

          <surname>Brinkman</surname>
        </author>
      </sectioninfo>

      <para>La gestione degli alias e la ricerca dei nomi di campo ambigui è
      stata migliorata. In sostanza:</para>

      <orderedlist type="a">
        <listitem>
          <para>Quando viene specificato l'alias per una tabella, o si usa
          l'alias o non si usa niente. Non è più permesso specificare il nome
          della tabella.</para>
        </listitem>

        <listitem>
          <para>Il controllo di ambiguità per prima cosa ora verifica
          nell'ambito del livello corrente le ambiguità presenti nei nomi di
          campo, validandole in certi casi come colonne utilizzabili senza
          qualificatori in un ambito di livello più alto.</para>
        </listitem>
      </orderedlist>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <orderedlist>
        <listitem>
          <para>Quando è specificato un alias per una tabella, i suoi campi
          vanno specificati con l'alias oppure non va usato nulla.</para>

          <orderedlist type="a">
            <listitem>
              <para>Questa query era permessa fino a FB1.5:</para>

              <programlisting>
    SELECT
      RDB$RELATIONS.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>

              <para>ma ora riporterà correttamente un errore specificando che
              il campo "RDB$RELATIONS.RDB$RELATION_NAME" non può essere
              trovato.</para>

              <para>Invece va usato così (preferibilmente):</para>

              <programlisting>
    SELECT
      R.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>

              <para>oppure così:</para>

              <programlisting>
    SELECT
      RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
            </listitem>

            <listitem>
              <para>La frase seguente correttamente ora recupera il campo
              FieldID dalla subquery e dalla tabella da :</para>

              <programlisting>
    UPDATE
      TableA
    SET
      FieldA = (SELECT SUM(A.FieldB) FROM TableA A
        WHERE A.FieldID = TableA.FieldID)
        </programlisting>

              <note>
                <para>In Firebird è possibile specificare un alias nelle frasi
                di aggiornamento. Sebbene molti altri database non lo
                supportino, questa possibilità dovrebbe aiutare quegli
                sviluppatori che hanno richiesto di rendere il linguaggio SQL
                di Firebird più compatibile con quei prodotti che la
                supportano.</para>
              </note>
            </listitem>

            <listitem>
              <para>Questo esempio non funziona corretamente in Firebird 1.5 e
              precedenti:</para>

              <programlisting>
    SELECT
      RDB$RELATIONS.RDB$RELATION_NAME,
      R2.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS
      JOIN RDB$RELATIONS R2 ON
        (R2.RDB$RELATION_NAME = RDB$RELATIONS.RDB$RELATION_NAME)
        </programlisting>

              <para>Se RDB$RELATIONS contiene 90 record, riporta 90 * 90 =
              8100 record, ma in Firebird 2 e successivi riporta correttamente
              solo 90 records.</para>
            </listitem>
          </orderedlist>
        </listitem>

        <listitem>
          <orderedlist type="a">
            <listitem>
              <para>Questo dava un errore di sintassi in Firebird 1.5, ma è
              accettato in Firebird 2:</para>

              <programlisting>
    SELECT
      (SELECT RDB$RELATION_NAME FROM RDB$DATABASE)
    FROM
      RDB$RELATIONS
        </programlisting>
            </listitem>

            <listitem>
              <para>Il controllo di ambiguità nelle subqueries: la query
              seguente funzionava in Firebird 1.5 senza segnalare alcuna
              ambiguità, cosa che invece viene effettuata da Firebird
              2:</para>

              <programlisting>
    SELECT
      (SELECT
         FIRST 1 RDB$RELATION_NAME
       FROM
         RDB$RELATIONS R1
         JOIN RDB$RELATIONS R2 ON
           (R2.RDB$RELATION_NAME = R1.RDB$RELATION_NAME))
    FROM
      RDB$DATABASE
       </programlisting>
            </listitem>
          </orderedlist>
        </listitem>
      </orderedlist>
    </section>

    <section id="rnfb20x-dml-execute-block" xreflabel="La frase EXECUTE BLOCK">
      <sectioninfo>
        <title>La frase EXECUTE BLOCK</title>

        <author>
          <firstname>V.</firstname>

          <surname>Khorsun</surname>
        </author>
      </sectioninfo>

      <para>EXECUTE BLOCK è un'estensione al linguaggio SQL che permette l'uso
      del "PSQL dinamico" all'interno di una SELECT. Ha l'effetto di ottenere
      un blocco di codice PSQL autocontenuto in modo da essere eseguito in una
      SQL dinamico come se fosse una stored procedure.</para>

      <para>
        <emphasis role="bold">Sintassi</emphasis>
      </para>

      <programlisting>
   EXECUTE BLOCK [ (param datatype = ?, param datatype = ?, ...) ]
     [ RETURNS (param datatype, param datatype, ...) ]
   AS
   [DECLARE VARIABLE var datatype; ...]
   BEGIN
     ...
   END
      </programlisting>

      <para>Per il client, la chiamata <function>isc_dsql_sql_info</function>
      col parametro <function>isc_info_sql_stmt_type</function> riporta</para>

      <itemizedlist>
        <listitem>
          <para><function>isc_info_sql_stmt_select</function> se il blocco ha
          parametri in uscita. La semantica della chiamata è simile a quella
          di una SELECT: il client ha un cursore aperto, puo ricevere dati
          attraverso di esso, e lo deve chiudere dopo l'uso.</para>
        </listitem>

        <listitem>
          <para><function>isc_info_sql_stmt_exec_procedure</function> se il
          blocco non ha parametri in uscita. La semantica della chiamata è
          simile a quella di una EXECUTE: il client non ha nessun cursore e
          l'esecuzione continua fino alla fine del blocco o termina per aver
          incontrato una SUSPEND.</para>
        </listitem>
      </itemizedlist>

      <para>Il client deve preprocessare solo la testata dello statement SQL
      oppure usare '? invece di ':' come indicatore di parametro, perché, nel
      corpo del blocco, potrebbero esserci riferimenti a variabili locali o ad
      argomenti con il prefisso ':' .</para>

      <para>
        <emphasis role="bold">Esempio</emphasis>
      </para>

      <para>Se il comando SQL da usare è</para>

      <programlisting>
   EXECUTE BLOCK (X INTEGER = :X)
     RETURNS (Y VARCHAR)
   AS
   DECLARE V INTEGER;
   BEGIN
     INSERT INTO T(...) VALUES (... :X ...);
     SELECT ... FROM T INTO :Y;
     SUSPEND;
   END
      </programlisting>

      <para>Il comando SQL preprocessato deve essere</para>

      <programlisting>
   EXECUTE BLOCK (X INTEGER = ?)
     RETURNS (Y VARCHAR)
   AS
   DECLARE V INTEGER;
   BEGIN
     INSERT INTO T(...) VALUES (... :X ...);
     SELECT ... FROM T INTO :Y;
     SUSPEND;
   END
      </programlisting>
    </section>

    <section id="rnfb20x-dml-derived-tables" xreflabel="Tabelle derivate">
      <sectioninfo>
        <title>Tabelle derivate (Derived Tables oppure DT)</title>

        <author>
          <firstname>A.</firstname>

          <surname>Brinkman</surname>
        </author>
      </sectioninfo>

      <para>Il supporto per le tabelle derivate in DSQL (cha sono sottoquery
      poste nella clausola FROM) è stato aggiunto come definito nello standard
      SQL200X. Una tabella derivata è un insieme di righe ottenute da una
      frase SELECT dinamica. Le tabelle derivate possono essere innestate, se
      necessario, per costruire copmplesse query e possono far parte di JOIN
      come se fossero normali tabelle o viste.</para>

      <para>
        <emphasis role="bold">Sintassi</emphasis>
      </para>

      <programlisting>
    SELECT
      &lt;elenco di selezioni&gt;
    FROM
      &lt;elenco riferimenti tabellari&gt;

    &lt;elenco riferimenti tabellari&gt; ::= &lt;riferimento tabellare&gt; [{&lt;virgola&gt; &lt;riferimento tabellare&gt;}...]

    &lt;riferimento tabellare&gt; ::=
        &lt;tabella primaria&gt;
      | &lt;tabella di join&gt;

    &lt;tabella primaria&gt; ::=
        &lt;tabella&gt; [[AS] &lt;pseudonimo&gt;]
      | &lt;tabella derivata&gt;

    &lt;tabella derivata&gt; ::=
        &lt;espressione query&gt; [[AS] &lt;pseudonimo&gt;]
          [&lt;parentesi aperta&gt; &lt;elenco di colonne derivate&gt; &lt;parentesi chiusa&gt;]

    &lt;elenco di colonne derivate&gt; ::= &lt;nome colonna&gt; [{&lt;virgola&gt; &lt;nome colonna&gt;}...]
      </programlisting>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <para>a) Tabella derivata semplice:</para>

      <programlisting>
  SELECT
    *
  FROM
    (SELECT
       RDB$RELATION_NAME, RDB$RELATION_ID
     FROM
       RDB$RELATIONS) AS R (RELATION_NAME, RELATION_ID)
      </programlisting>

      <para>b) Aggregazione su una tabella derivata che contiene a sua volta
      un aggregato</para>

      <programlisting>
  SELECT
    DT.FIELDS,
    Count(*)
  FROM
    (SELECT
       R.RDB$RELATION_NAME,
       Count(*)
     FROM
       RDB$RELATIONS R
       JOIN RDB$RELATION_FIELDS RF ON (RF.RDB$RELATION_NAME = R.RDB$RELATION_NAME)
     GROUP BY
       R.RDB$RELATION_NAME) AS DT (RELATION_NAME, FIELDS)
  GROUP BY
    DT.FIELDS
      </programlisting>

      <para>c) Esempio con UNION e ORDER BY:</para>

      <programlisting>
  SELECT
    DT.*
  FROM
    (SELECT
       R.RDB$RELATION_NAME,
       R.RDB$RELATION_ID
     FROM
       RDB$RELATIONS R
     UNION ALL
     SELECT
       R.RDB$OWNER_NAME,
       R.RDB$RELATION_ID
     FROM
       RDB$RELATIONS R
     ORDER BY
       2) AS DT
  WHERE
    DT.RDB$RELATION_ID &lt;= 4
      </programlisting>

      <para>
        <emphasis role="bold">Note essenziali</emphasis>
      </para>

      <itemizedlist>
        <listitem>
          <para>Ogni colonna nelle tabelle derivatet deve avere un nome. Le
          espressioni innominate come le costanti dovrebbero essere aggiunte
          con una alias oppure specificando l'elenco delle colonne
          risultato.</para>
        </listitem>

        <listitem>
          <para>Il numero di campi nella lista di colonne risultatnte dovrebbe
          essere lo stesso del numero di colonne nella espressione della
          query.</para>
        </listitem>

        <listitem>
          <para>L'ottimizzatore è in grado di gestire in modo molto efficiente
          le tabelle derivate. Tuttavia, se la tabella derivata è coinvolta in
          una INNER JOIN e contiene subquery, non si può ottenere un
          ordinamento sulla join e le prestazioni ne soffrono.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="rnfb20x-dml-rb-retain" xreflabel="ROLLBACK RETAIN">
      <sectioninfo>
        <title>Sintassi per ROLLBACK RETAIN</title>

        <author>
          <firstname>D.</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para>In DSQL adesso è supportata anche la frase ROLLBACK RETAIN.</para>

      <para>Il <quote>rollback retaining</quote> era stato introdotto in
      InterBase 6.0, ma questa modalità di rollback poteva essere usata solo
      attravarso una chiamata API: la
      <firstterm>isc_rollback_retaining()</firstterm>. Invece, il
      <quote>commit retaining</quote> poteva essere invocato sia con la
      chiamata API <firstterm>isc_commit_retaining()</firstterm>, sia usando
      il comando DSQL <literal>COMMIT RETAIN</literal>.</para>

      <para>Firebird 2.0 aggiunge una clausola opzionale
      <literal>RETAIN</literal> alla comando DSQL <literal>ROLLBACK</literal>
      per renderlo consistente al COMMIT [RETAIN].</para>

      <para>La <emphasis>sintassi</emphasis>: è simile a quella del COMMIT
      RETAIN.</para>
    </section>

    <section id="rnfb20x-dml-rows" xreflabel="Sintassi ROWS">
      <sectioninfo>
        <title>Sintassi ROWS</title>

        <author>
          <firstname>D.</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para>La sintassi ROWS si usa per limitare il numero di righe riportate
      da un'espressione di selezione. Viene applicata alla fine di una frase
      di SELECT di livello principale, e specifica il numero di righe da
      riportare al programma principale. Di fatto costituisce un'alternativa
      meglio comprensibile alle clausole FIRST/SKIP, e, oltre ad essere in
      accordo con lo standard SQL più recente, la sintassi ROWS da' alcuni
      benefici extra. Può infatti essere usata nelle UNION, in ogni tipo di
      subquery e nelle frasi UPDATE o DELETE.</para>

      <para>Disponibile sia in DSQL che in PSQL.</para>

      <para>
        <emphasis role="bold">Sintassi</emphasis>
      </para>

      <programlisting>
   SELECT ...
     [ORDER BY &lt;expr_list&gt;]
     ROWS &lt;expr1&gt; [TO &lt;expr2&gt;]
      </programlisting>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <para>1.</para>

      <programlisting>
  SELECT * FROM T1
    UNION ALL
  SELECT * FROM T2
    ORDER BY COL
    ROWS 10 TO 100
      </programlisting>

      <para>2.</para>

      <programlisting>
   SELECT COL1, COL2,
     ( SELECT COL3 FROM T3 ORDER BY COL4 DESC ROWS 1 )
   FROM T4
      </programlisting>

      <para>3.</para>

      <programlisting>
   DELETE FROM T5
     ORDER BY COL5
     ROWS 1
      </programlisting>

      <para>
        <emphasis role="bold">Note essenziali</emphasis>
      </para>

      <orderedlist>
        <listitem>
          <para>Quando si omette &lt;expr2&gt;, allora ROWS &lt;expr1&gt; ha
          lo stesso significato di FIRST &lt;expr1&gt;. Quando si usano
          emtrambe le espressioni &lt;expr1&gt; e &lt;expr2&gt;, allora 
           ROWS &lt;expr1&gt; TO &lt;expr2&gt; ha lo stesso signifiacato di 
           FIRST (&lt;expr2&gt; - &lt;expr1&gt; + 1) SKIP (&lt;expr1&gt; -
          1)</para>
        </listitem>

        <listitem>
          <para>Non c'è nulla di equivalente alla clausola SKIP usata senza la
          clausola FIRST.</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="rnfb20x-dml-union">
      <title>Miglioramenti alla gestione delle UNION</title>

      <para>Le regole per le query UNION sono state migliorate come
      segue:</para>

      <section id="rnfb20x-dml-union-distinct" xreflabel="UNION DISTINCT">
        <sectioninfo>
          <title>Implementazione di UNION DISTINCT</title>

          <author>
            <firstname>D.</firstname>

            <surname>Yemanov</surname>
          </author>
        </sectioninfo>

        <para>UNION DISTINCT è attualmente permesso come sinonimo di una
        semplice UNION, in accordo con le specifiche SQL-99. C'è una piccola
        differenza: DISTINCT è il funzionamento di default, in accordo allo
        standard. Precedentemente, Firebird non supportava l'esplicita
        inclusione della parola chiave opzionale DISTINCT.</para>

        <para>
          <emphasis>Sintassi</emphasis>
        </para>

        <programlisting>
  UNION [{DISTINCT | ALL}]
        </programlisting>
      </section>

      <section id="rnfb20x-dml-union-coercion"
               xreflabel="Coercizione del tipo di dato nelle UNION migliorata">
        <sectioninfo>
          <title>Coercizione del tipo di dato nelle UNION migliorata</title>

          <author>
            <firstname>A.</firstname>

            <surname>Brinkman</surname>
          </author>
        </sectioninfo>

        <para>Automatic resolution of the data type of the result of an
        aggregation over values of compatible data types, such as case
        expressions and columns at the same position in a union query
        expression, now uses smarter rules.</para>

        <para>Il sistema che risolve quale tipo di dato attribuire in
        automatico ad una aggregazione di valori fra loro compatibili, come
        tra le varie espressioni di un CASE o le colonne nella stessa
        posizione in una query unione, adesso utilizza un insieme di regole
        più raffinato.</para>

        <para>
          <emphasis role="bold">Regole sintattiche</emphasis>
        </para>

        <para>Sia DTS l'insieme dei tipi di dato da cui si deve determinare il
        tipo di dato risultante</para>

        <orderedlist>
          <listitem>
            <para>Tutti i dati in DTS devono esser efra loro
            compatibili.</para>
          </listitem>

          <listitem>
            <para>Si possono verificare i seguenti casi:</para>

            <orderedlist type="a">
              <listitem>
                <para>se uno qualsiasi dei tipi di dato in DTS è una stringa
                di caratteri, allora:</para>

                <orderedlist type="i">
                  <listitem>
                    <para>se uno qualsiasi dei tipi di dato in DTS è una
                    stringa di caratteri a lunghezza variabile, allora il tipo
                    risultante è una stringa di caratteri a lunghezza
                    variabile con lunghezza massima (in caratteri) uguale al
                    più grande dei tipi di dato nel DTS.</para>
                  </listitem>

                  <listitem>
                    <para>Altrimenti, il tipo del dato risultante è una
                    stringa di caratteri a lunghezza fissa con lunghezza (in
                    caratteri) uguale alla massima lunghezza dei tipi di dato
                    nel DTS.</para>
                  </listitem>

                  <listitem>
                    <para>Il set di caratteri e l'ordinamento vengono presi
                    dalla prima stringa del DTS.</para>
                  </listitem>
                </orderedlist>
              </listitem>

              <listitem>
                <para>se tutto il DTS è in precisione numerica esatta, allora
                il risultato è numerico esatto con scala uguale al massimo
                delle scale dei tipi di dato nel DTS e la precisione massima
                dei dati del DTS.</para>

                <note>
                  <para>ATTENZIONE: il controllo per l'overflow di precisione
                  viene fatto solamente durente l'esecuzione del comando. Chi
                  sviluppa deve prendere le necessarie precauzioni per evitare
                  che l'aggregazione risolva ad un overflow di
                  precisione.</para>
                </note>
              </listitem>

              <listitem>
                <para>Se un qualche dato del DTS è un numero approssimato,
                allora ogni dato nel DTS deve esser enumerico altrimenti viene
                generato un errore.</para>
              </listitem>

              <listitem>
                <para>Se un qualche dato del DTS è di un tipo orario (date,
                time, timestamp), allora ogni dato nel DTS deve essere
                esattamente dello stesso tipo del primo.</para>
              </listitem>

              <listitem>
                <para>se un qualche dato del DTS è un BLOB, allora tutti i
                dati del DTS devono essere BLOB e tutti dello stesso
                sottotipo.</para>
              </listitem>
            </orderedlist>
          </listitem>
        </orderedlist>
      </section>

      <section id="rnfb20x-dml-union-subqueries"
               xreflabel="UNION permesse nelle subquery ANY/ALL/IN">
        <sectioninfo>
          <title>UNION permesse nelle subquery ANY/ALL/IN</title>

          <author>
            <firstname>D.</firstname>

            <surname>Yemanov</surname>
          </author>
        </sectioninfo>

        <para>L'elemento subquery in una ricerca ANY, ALL o IN può essere una
        query UNION.</para>
      </section>
    </section>

    <section id="rnfb20x-dml-nulls">
      <title>Enhancements to NULL Logic</title>

      <para>Sono state aggiunte le seguenti caratteristiche che riguardano la
      gestione del NULL in DSQL:</para>

      <section id="rnfb20x-dml-nulls-distinct"
               xreflabel="Nuovo predicato [NOT] DISTINCT">
        <sectioninfo>
          <title>Nuovo predicato [NOT] DISTINCT per valutare l'uguaglianza di
          due operandi NULL</title>

          <author>
            <firstname>O.</firstname>

            <surname>Loa, D. Yemanov</surname>
          </author>
        </sectioninfo>

        <para>Si tratta di un nuovo predicato di equivalenza che si comporta
        esattamente come i predicati di uguaglianza/disuguaglianza, ma, invece
        di controllare l'uguaglianza, verifica se i due operandi sono distinti
        fra loro.</para>

        <para>Pertanto, IS NOT DISTINCT tratta (NULL uguale NULL) come se
        fosse vero, poichè NULL (o un'espressione che vale NULL) non è
        distinguibile da un'altra. Questo è disponibile sia in DSQL che in
        PSQL.</para>

        <para>
          <emphasis role="bold">Sintassi</emphasis>
        </para>

        <programlisting>
   &lt;valore&gt; IS [NOT] DISTINCT FROM &lt;valore&gt;
        </programlisting>

        <para>
          <emphasis role="bold">Esempi</emphasis>
        </para>

        <para>1.</para>

        <programlisting>
   SELECT * FROM T1
     JOIN T2
       ON T1.NAME IS NOT DISTINCT FROM T2.NAME;
        </programlisting>

        <para>2.</para>

        <programlisting>
   SELECT * FROM T
     WHERE T.MARK IS DISTINCT FROM 'test';
        </programlisting>

        <note>
          <title>Precisazioni essenziali</title>

          <orderedlist>
            <listitem>
              <para>Il predicato DISTINCT non considera distinti due valori
              NULL, pertanto non riporta un risultato sconosciuto come i
              predicati di uguaglianza/disuguaglianza. Come il predicato IS
              [NOT] NULL, può essere solamente o vero o falso.</para>

              <tip>
                <title>Per maggiori informazioni sui NULL</title>

                <para>Per maggiori informazioni su come sono valutati i
                confronti che coinvolgono campi a NULL, esaminare la
                <emphasis>Guida sull'uso di NULL nel linguaggio SQL di
                Firebird</emphasis> (Firebird Null Guide), disponibile in
                italiano sul sito di Firebird nell' <ulink
                url="http://firebirdsql.org/index.php?op=doc#category_1">Indice
                dei documenti</ulink>.</para>
              </tip>
            </listitem>

            <listitem>
              <para>Il predicato NOT DISTINCT può essere ottimizzato usando un
              indice, se è disponibile.</para>
            </listitem>
          </orderedlist>
        </note>
      </section>

      <section id="rnfb20x-dml-nulls-equivalence"
               xreflabel="Ammorbidita la regola per comparare i NULL">
        <sectioninfo>
          <title>Ammorbidita la regola per i NULL espliciti</title>

          <author>
            <firstname>D.</firstname>

            <surname>Yemanov</surname>
          </author>
        </sectioninfo>

        <para>Un esplicito NULL può essere ora usato come un valore in tutte
        le espressioni, senza dare un errore di sintassi. Pertanto espressioni
        come le seguenti sono adesso valide:</para>

        <programlisting>
  A = NULL
  B &gt; NULL
  A + NULL
  B || NULL
        </programlisting>

        <note>
          <para>Tutte queste espressioni sono valutate a NULL. La modifica non
          altera il significato dell'espressione per il motore, semplicemente
          la fa accettare come espressione valida.</para>
        </note>
      </section>

      <section id="rnfb20x-dml-nulls-ordering"
               xreflabel="Modifiche all'ordinamento dei NULL">
        <sectioninfo>
          <title>Modifiche all'ordinamento dei NULL per aderire allo
          standard</title>

          <author>
            <firstname>N.</firstname>

            <surname>Samofatov</surname>
          </author>
        </sectioninfo>

        <para>La posizione dei NULL in un insieme ordinato è stata modificata
        in accordo con le specifiche dello standard SQL in modo tale che sia
        consistente con l'ordinamento, cioè se un ordinamento ASC[ENDING] li
        mette alla fine, allora un ordinamento DESC[ENDING] li mette
        all'inizio o viceversa. Questo si applica alle basi di dati create con
        la ODS 11 o successiva, poiché per funzionare questa modifica ha
        bisogno delle modifiche apportate agli indici.</para>

        <important>
          <para>Se si forza il posizionamento di default, non può essere usato
          nessun indice per l'ordinamento. Pertanto, non potrà essere usato
          nessun indice né per un ordinamento ASCENDING se viene specificato
          NULLS LAST, né per un ordinamento DESCENDING se si specifica NULLS
          FIRST.</para>
        </important>

        <para>
          <emphasis role="bold">Esempi</emphasis>
        </para>

        <programlisting>
  Database:  proc.fdb
  SQL&gt; create table gnull(a int);
  SQL&gt; insert into gnull values(null);
  SQL&gt; insert into gnull values(1);
  SQL&gt; select a from gnull order by a;
             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a asc;

             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a desc;

             A
  ============
             1
        &lt;null&gt;

  SQL&gt; select a from gnull order by a asc nulls first;

             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a asc nulls last;

             A
  ============
             1
        &lt;null&gt;


  SQL&gt; select a from gnull order by a desc nulls last;

             A
  ============
             1
        &lt;null&gt;

  SQL&gt; select a from gnull order by a desc nulls first;

             A
  ============
        &lt;null&gt;
             1
        </programlisting>
      </section>
    </section>

    <section id="rnfb20x-dml-complex-dml"
             xreflabel="Insiemi UNION nelle subquery">
      <sectioninfo>
        <title>Le subquery e l'INSERT possono accettare insiemi UNION</title>

        <author>
          <firstname>D.</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para>Le specifiche di una SELECT nelle subquery e nelle frasi INSERT
      INTO &lt;specifica-di-insert&gt; SELECT... possono ora specificare anche
      insiemi UNION.</para>
    </section>

    <section id="rnfb20x-dml-extensions"
             xreflabel="Nuove estensioni ad UPDATE e DELETE">
      <sectioninfo>
        <title>Nuove estensioni alle sintassi di UPDATE e DELETE</title>

        <author>
          <firstname>O.</firstname>

          <surname>Loa</surname>
        </author>
      </sectioninfo>

      <para>Le specifiche di ROWS e le clausole PLAN e ORDER BY possono ora
      essere usate nelle frasi di UPDATE e di DELETE.</para>

      <para>Gli utenti possono ora definire PLAN specifici per le frasi di
      UPDATE e di DELETE in modo da ottimizzarle a mano. Inoltre è possibile
      limitare il numero dei record influenzati dalla direttiva con una
      clausola ROWS, opzionalmente usata in combinazione con una clausola
      ORDER BY per ottenere un insieme di registrazioni ordinato.</para>

      <para>
        <emphasis>Sintassi</emphasis>
      </para>

      <programlisting>
  UPDATE ... SET ... WHERE ...
  [PLAN &lt;elementi di plan&gt;]
  [ORDER BY &lt;lista elementi ordinamento&gt;]
  [ROWS &lt;valnum-1&gt; [TO &lt;valnum-2&gt;]]
      </programlisting>

      <para>or</para>

      <programlisting>
  DELETE ... FROM ...
  [PLAN &lt;elementi di plan&gt;]
  [ORDER BY &lt;lista elementi ordinamento&gt;]
  [ROWS &lt;valnum-1&gt; [TO &lt;valnum-2&gt;]]
      </programlisting>
    </section>

    <section id="rnfb20x-dml-context"
             xreflabel="Estensioni alle variabili di contesto">
      <title>Estensioni alle variabili di contesto</title>

      <para>Un certo numero di caratteristiche sono state aggiunte per
      estendere le informazioni di contesto che possono essere gestite:</para>

      <section id="rnfb20x-dml-context-subsecond">
        <sectioninfo>
          <title>Precisione e millesimi di secondo nelle variabili Time e
          DateTime</title>

          <author>
            <firstname>D.</firstname>

            <surname>Yemanov</surname>
          </author>
        </sectioninfo>

        <section id="rnfb20x-dml-context-subsecond-milli">
          <title>CURRENT_TIMESTAMP e 'NOW' ora riportano i
          millisecondi</title>

          <para>La variabile di contesto CURRENT_TIMESTAMP ed il letterale
          'NOW' ora riportano le frazioni di secondo in millisecondi.</para>
        </section>

        <section id="rnfb20x-dml-context-subsecond-other">
          <title>Specificabile la precisione in secopndi in CURRENT_TIME e
          CURRENT_TIMESTAMP</title>

          <para>CURRENT_TIME e CURRENT_TIMESTAMP ora possono opzionalmente
          specificare una precisione nei secondi.</para>

          <para>La caratteristica è disponibile sia in DSQL che in
          PSQL.</para>

          <para>
            <emphasis role="bold">Sintassi</emphasis>
          </para>

          <programlisting>
    CURRENT_TIME [(&lt;precisione&gt;)]
    CURRENT_TIMESTAMP [(&lt;precisione&gt;)]
          </programlisting>

          <para>
            <emphasis role="bold">Esempi</emphasis>
          </para>

          <programlisting>
    1. SELECT CURRENT_TIME FROM RDB$DATABASE;
    2. SELECT CURRENT_TIME(3) FROM RDB$DATABASE;
    3. SELECT CURRENT_TIMESTAMP(3) FROM RDB$DATABASE;
          </programlisting>

          <note>
            <orderedlist>
              <listitem>
                <para>La massima precisione specificabile è 3, che significa
                l'accuratezza ad un millesimo di secondo. Questa precisione
                potrebbe essere aumentata in futuro.</para>
              </listitem>

              <listitem>
                <para>Se non si specifica la precisione, i valori di default
                impliciti sono:</para>

                <itemizedlist>
                  <listitem>
                    <para>0 per CURRENT_TIME</para>
                  </listitem>

                  <listitem>
                    <para>3 per CURRENT_TIMESTAMP</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </orderedlist>
          </note>
        </section>
      </section>

      <section id="rnfb20x-dml-context-ns">
        <sectioninfo>
          <title>Nuove funzioni di sistema per gestire le variabili di
          contesto</title>

          <author>
            <firstname>N.</firstname>

            <surname>Samofatov</surname>
          </author>
        </sectioninfo>

        <para>I valori delle variabili di contesto possono ora essere ottenuti
        usando le funzioni di sistema RDB$GET_CONTEXT() e RDB$SET_CONTEXT().
        Queste nuove funzioni integrate accedono in SQL ad informazioni
        relative alla connessione e transazione attuali. Attraverso di esse è
        possibile ora gestire dati di contesto definiti dall'utente
        associandoli alla transazione o alla connessione.</para>

        <para>
          <emphasis role="bold">Sintassi</emphasis>
        </para>

        <programlisting>
    RDB$SET_CONTEXT( &lt;namespace&gt;, &lt;variabile&gt;, &lt;valore&gt; )
    RDB$GET_CONTEXT( &lt;namespace&gt;, &lt;variabile&gt; )
       </programlisting>

        <para>Queste funzioni sono in realtà una specie di funzioni esterne
        che però fanno parte integrante di tutti i database invece di dover
        essere richiamate da una libreria esterna caricata dinamicamente. Le
        seguenti dichiarazioni sono fatte automaticamente dal motore alla
        creazione del database:</para>

        <para>
          <emphasis role="bold">Dichiarazioni (implicite)</emphasis>
        </para>

        <programlisting>
  DECLARE EXTERNAL FUNCTION RDB$GET_CONTEXT
      VARCHAR(80),
      VARCHAR(80)
  RETURNS VARCHAR(255) FREE_IT;

  DECLARE EXTERNAL FUNCTION RDB$SET_CONTEXT
      VARCHAR(80),
      VARCHAR(80),
      VARCHAR(255)
  RETURNS INTEGER BY VALUE;
       </programlisting>

        <para>
          <emphasis role="bold">Uso</emphasis>
        </para>

        <para>RDB$SET_CONTEXT e RDB$GET_CONTEXT impostano e recuperano il
        valore attuale per una variabile di contesto. Raggruppamenti di
        variabili di contesto con propeità simili sono reperiti con
        identificatori di <quote>spazi di nomi</quote> (namespace). Ogni
        <quote>spazio di nomi</quote> determina le regole per l'uso, quali ad
        esempio l'accessibilità in lettura o scrittura da parte di un
        utente.</para>

        <note>
          <para>Gli spazi di nomi e i nomi delle variabili sono sensibili alle
          maiuscole/micuscole.</para>
        </note>

        <itemizedlist>
          <listitem>
            <para>RDB$GET_CONTEXT recupera il valore attuale di una variabile.
            Se la variabile non esiste nello spazio di nomi specificato, la
            funzione riporta NULL.</para>
          </listitem>

          <listitem>
            <para>RDB$SET_CONTEXT imposta un valore per la specificata
            variabile, se è possibile l'accesso in scrittura. La funzione
            riporta il valore 1 se la variabile esisteva già valorizzata al
            momento della chiamata, altrimenti riporta 0.</para>
          </listitem>

          <listitem>
            <para>Per eliminare una variabile da un contesto, impostarla a
            NULL.</para>
          </listitem>
        </itemizedlist>

        <section id="rnfb20x-dml-context-ns-pd">
          <title>Nomi di spazi predefiniti</title>

          <para>Sono disponibili un certo numero di spazi di nomi
          prefissati:</para>

          <section id="rnfb20x-dml-context-ns-pd-user-session">
            <title>USER_SESSION</title>

            <para>Permette l'accesso a variabili definite dall'utente
            specifiche per la sessione corrente. Si possono definire ed
            impostare i valori a variabili con qualsiasi nome in questo
            contesto.</para>
          </section>

          <section id="rnfb20x-dml-context-ns-pd-user-transaction">
            <title>USER_TRANSACTION</title>

            <para>Offre le stesse possibilità del precedente, però a livello
            di singola transazione.</para>
          </section>

          <section id="rnfb20x-dml-context-ns-pd-system">
            <title>SYSTEM</title>

            <para>Permette un accesso in sola lettura alle seguenti variabili
            predefinite:</para>

            <itemizedlist>
              <listitem>
                <para>NETWORK_PROTOCOL :: Il protocollo di rete utilizzato dal
                client per connettersi. I valori attualmente definiti sono :
                <quote>TCPv4</quote>, <quote>WNET</quote>, <quote>XNET</quote>
                e NULL.</para>
              </listitem>

              <listitem>
                <para>CLIENT_ADDRESS :: L'indirizzo di rete del client remoto,
                come stringa. Il valore è, per i protocolli TCPv4. un
                indirizzo IP nella forma "xxx.xxx.xxx.xxx" oppure, per il
                procollo XNET è l'ID del processo locale oppure, per ogni
                altro protocollo, NULL.</para>
              </listitem>

              <listitem>
                <para>DB_NAME :: Nome canonico del database corrente. Può
                essere il nome dell'alias (se la connessione attraverso i nomi
                di file è disabilitata con DatabaseAccess = NONE in
                firebird.conf) oppure, il nome del file completo per
                esteso.</para>
              </listitem>

              <listitem>
                <para>ISOLATION_LEVEL :: Il livello di isolamento della
                transazione corrente. Il valore può essere uno fra "READ
                COMMITTED", "SNAPSHOT", "CONSISTENCY".</para>
              </listitem>

              <listitem>
                <para>TRANSACTION_ID :: L'ID numerico della transazione
                corrente. Il valore è lo stesso della pseudo-variabile
                CURRENT_TRANSACTION.</para>
              </listitem>

              <listitem>
                <para>SESSION_ID :: L'ID numerico della sessione attuale. Il
                valore riportato è lo stesso della pseudo variabile
                CURRENT_CONNECTION.</para>
              </listitem>

              <listitem>
                <para>CURRENT_USER :: L'utente attuale. Il valore riportato è
                lo stesso riportato dalla pseudo-variabile CURRENT_USER o
                dalla variabile predefinita USER.</para>
              </listitem>

              <listitem>
                <para>CURRENT_ROLE :: Il ruolo della connessione. Riporta lo
                stesso valore della pseudo-variabile CURRENT_ROLE.</para>
              </listitem>
            </itemizedlist>
          </section>
        </section>

        <section id="rnfb20x-dml-context-ns-notes">
          <title>Note</title>

          <para>Per impedire attacchi del tipo DoS (Denial of Service) al
          Server Firebird, il numero di variabili memorizzate in ogni contesto
          di sessione o transazione è limitato a 1000.</para>

          <para>
            <emphasis role="bold">Esempi d'uso</emphasis>
          </para>

          <programlisting>
   set term ^;
   create procedure set_context(User_ID varchar(40), Trn_ID integer) as
   begin
     RDB$SET_CONTEXT('USER_TRANSACTION', 'Trn_ID', Trn_ID);
     RDB$SET_CONTEXT('USER_TRANSACTION', 'User_ID', User_ID);
   end ^

  create table journal (
     jrn_id integer not null primary key,
     jrn_lastuser varchar(40),
     jrn_lastaddr varchar(255),
     jrn_lasttransaction integer
  )^

CREATE TRIGGER UI_JOURNAL FOR JOURNAL BEFORE INSERT OR UPDATE
  as
  begin
    new.jrn_lastuser = rdb$get_context('USER_TRANSACTION', 'User_ID');
    new.jrn_lastaddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');
    new.jrn_lasttransaction = rdb$get_context('USER_TRANSACTION', 'Trn_ID');
  end ^
  commit ^
  execute procedure set_context('skidder', 1) ^

  insert into journal(jrn_id) values(0) ^
  set term ;^
          </programlisting>

          <para>Poichè rdb$set_context riporta 1 o zero, può funzionare anche
          in una semplice frase SELECT:</para>

          <para>
            <emphasis role="bold">Esempio</emphasis>
          </para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', 'ru')
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                0
          </programlisting>

          <para>Il risultato uguale a 0 significa che precedentemente non era
          definita e che è stata impostata, in questo caso a 'ru'.</para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', 'ca')
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                1
          </programlisting>

          <para>Il risultato 1 significa che era già definita e che l'abbiamo
          modificata in questo caso in 'ca'.</para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', NULL)
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                1
          </programlisting>

          <para>1 dice che era definita; cambiandola in NULL l'abbiamo
          cancellata.</para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', NULL)
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                0
          </programlisting>

          <para>A questo punto 0 significa che non è successo nulla: non
          esisteva prima e non esiste adesso.</para>
        </section>
      </section>
    </section>

    <section id="rnfb20x-dml-plans" xreflabel="Miglioramenti ai PLAN">
      <sectioninfo>
        <title>Miglioramenti nella gestione dei PLAN specificati
        dall'utente</title>

        <author>
          <firstname>D.</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <orderedlist>
        <listitem>
          <para>Frammenti di PLAN sono propagati ai livelli di join interni,
          permettendo l'ottimizzazione manuale di outer join complesse</para>
        </listitem>

        <listitem>
          <para>La correttezza di un PLAN specificato dall'utente viene
          verificata nelle outer join</para>
        </listitem>

        <listitem>
          <para>È stata aggiunta l'ottimizzazione di corto circuito per i PLAN
          specificati dall'utente</para>
        </listitem>

        <listitem>
          <para>Un percorso d'accesso specificato dall'utente può essere
          assegnato ad ogni ffrase o clausola basata sulla SELECT</para>
        </listitem>
      </orderedlist>

      <para>
        <emphasis role="bold">Regole sintattiche</emphasis>
      </para>

      <para>Lo schema seguente descrive le regole sintattiche per la clausola
      PLAN per essere d'aiuto nella loro stesura.</para>

      <programlisting>
PLAN ( { &lt;stream_retrieval&gt; | &lt;sorted_streams&gt; | &lt;joined_streams&gt; } )

&lt;stream_retrieval&gt; ::= { &lt;natural_scan&gt; | &lt;indexed_retrieval&gt; |
    &lt;navigational_scan&gt; }

&lt;natural_scan&gt; ::= &lt;stream_alias&gt; NATURAL

&lt;indexed_retrieval&gt; ::= &lt;stream_alias&gt; INDEX ( &lt;index_name&gt;
    [, &lt;index_name&gt; ...] )

&lt;navigational_scan&gt; ::= &lt;stream_alias&gt; ORDER &lt;index_name&gt;
    [ INDEX ( &lt;index_name&gt; [, &lt;index_name&gt; ...] ) ]

&lt;sorted_streams&gt; ::= SORT ( &lt;stream_retrieval&gt; )

&lt;joined_streams&gt; ::= JOIN ( &lt;stream_retrieval&gt;, &lt;stream_retrieval&gt;
    [, &lt;stream_retrieval&gt; ...] )
    | [SORT] MERGE ( &lt;sorted_streams&gt;, &lt;sorted_streams&gt; )
      </programlisting>

      <para>
        <emphasis role="bold">Dettagli</emphasis>
      </para>

      <para><emphasis>Natural scan</emphasis> (scansione naturale) significa
      che tutte le righe vengono recuperate nell'ordine naturale di
      memorizzazione. Pertanto bisogna leggere tutte le pagine prima di poter
      validare un criterio di ricerca.</para>

      <para><emphasis>Indexed retrieval</emphasis> (accesso indicizzato) usa
      un particolare metodo indicizzato (range index scan) per trovare le
      righe che concordano con il criterio di ricerca dato. Le corrispondenze
      trovate sono combinate in una <quote>mappa di bit sparsi</quote> (sparse
      bitmap) che viene ordinata per numeri di pagina, in modo da dover
      leggere una pagina solo una volta. Dopo di ché le pagine dei dati
      vengono lette e da esse si recuperano le righe richieste.</para>

      <para><emphasis>Navigational scan</emphasis> (scansione in ordine)
      utilizza un indice per riportare le righe in certo ordine, se si può
      effettuare una tale operazione.</para>

      <itemizedlist>
        <listitem>
          <para>L'indice ad albero binario viene percorso dal nodo più a
          sinistra a quello più a destra</para>
        </listitem>

        <listitem>
          <para>Se un qualsiasi criterio di ricerca è definito su una colonna
          specificata anche in una clausola ORDER BY, la navigazione è
          limitata da un qualche sottoalbero ristretto, che dipendce dal
          predicato.</para>
        </listitem>

        <listitem>
          <para>Se un qualche criterio di ricerca è definito su colonne
          indicizzate, allora si effettua per prima cosa un range index scan,
          e ogni chiave recuperata ha il suo ID validato nel bitmap
          risultante. A quel punto si legge la pagina dati e si recupera la
          riga richiesta.</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>Una scansione in ordine (navigational scan) provoca una lettura
        in ordine sparso delle pagine, in quanto le letture non sono
        ottimizzate.</para>
      </note>

      <para>Una operazione di SORT (<emphasis>sort operation</emphasis>)
      effettua un ordinamento esterno del flusso di dati recuperato.</para>

      <para>Una operazione di <emphasis>JOIN</emphasis> può essere effettuata
      sia attraverso un algoritmo ciclico innestato (JOIN plan) oppure con un
      algoritmo di sort merge (MERGE plan).</para>

      <itemizedlist>
        <listitem>
          <para>Una JOIN con ciclo innestato interno (<emphasis>inner nested
          loop join</emphasis>) può contenere tutti quanti flussi si richiede
          di unire. Sono tutti fra loro equivalenti.</para>
        </listitem>

        <listitem>
          <para>Una JOIN con ciclo innestato esterno (<emphasis>outer nested
          loop join</emphasis>) opera sempre e solo con due flussi, pertanto
          nel caso di dover unire 3 o più flussi esterni, si vedranno clausole
          di JOIN innestate.</para>
        </listitem>
      </itemizedlist>

      <para>Un <emphasis>sort merge</emphasis> (ordina e riunisce) opera su
      due flussi in ingresso che sono dapprima ordinati e poi riuniti in una
      unica esecuzione.</para>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <programlisting>
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS
    WHERE RDB$RELATION_NAME LIKE 'RDB$%'
    PLAN (RDB$RELATIONS NATURAL)
    ORDER BY RDB$RELATION_NAME

    SELECT R.RDB$RELATION_NAME, RF.RDB$FIELD_NAME
    FROM RDB$RELATIONS R
      JOIN RDB$RELATION_FIELDS RF
      ON R.RDB$RELATION_NAME = RF.RDB$RELATION_NAME
    PLAN MERGE (SORT (R NATURAL), SORT (RF NATURAL))
      </programlisting>

      <para>
        <emphasis role="bold">Note</emphasis>
      </para>

      <orderedlist type="a">
        <listitem>
          <para>Una clausola PLAN può essere messa in tutte le espressioni di
          selezione, incluse le subquery, tabelle derivate, e definizioni di
          viste. Può inoltre essere usata nelle frasi UPDATE e DELETE, perchè
          sono implicitamente basate su espressioni di selezione.</para>
        </listitem>

        <listitem>
          <para>Se una clausola PLAN contiene descrizioni di accesso non
          valide, allora o viene riportato un errore oppure la clausola errata
          viene silenziosamente ignorata: ciò dipende dalla gravitÍ
          dell'errore.</para>
        </listitem>

        <listitem>
          <para>Il tipo di PLAN specificato con ORDER
          &lt;navigational_index&gt; INDEX ( &lt;filter_indices&gt; ) viene
          riportatodal motore e può essere usato nei PLAN fatti dall'utente a
          partire da FB 2.0.</para>
        </listitem>
      </orderedlist>
    </section>

    <section id="rnfb20x-dml-sorting">
      <sectioninfo>
        <title>Migliorie nelle operazioni di ordinamento</title>

        <author>
          <firstname>A.</firstname>

          <surname>Brinkman</surname>
        </author>
      </sectioninfo>

      <para>Nelle operazioni di ordinamento sono stati fatti alcuni utili
      sviluppi:</para>

      <section id="rnfb20x-dml-sorting-both"
               xreflabel="GROUP BY e ORDER BY con alias">
        <title>GROUP BY e ORDER BY su un &lt;alias&gt;</title>

        <para>I nomi di alias sono ora permessi in entrambe le
        clausole.</para>

        <para>
          <emphasis role="bold">Esempi:</emphasis>
        </para>

        <orderedlist>
          <listitem>
            <para>ORDER BY</para>

            <programlisting>
        SELECT RDB$RELATION_ID AS ID
        FROM RDB$RELATIONS
        ORDER BY ID
        </programlisting>
          </listitem>

          <listitem>
            <para>GROUP BY</para>

            <programlisting>
        SELECT RDB$RELATION_NAME AS ID, COUNT(*)
        FROM RDB$RELATION_FIELDS
        GROUP BY ID
        </programlisting>
          </listitem>
        </orderedlist>
      </section>

      <section id="rnfb20x-dml-sorting-groupby-expr"
               xreflabel="GROUP BY su espressione">
        <title>GROUP BY su espressione arbitraria</title>

        <para>Una condizione di GROUP BY può ora contenere una qualsiasi
        espressione valida.</para>

        <para>
          <emphasis role="bold">Esempio</emphasis>
        </para>

        <programlisting>
  ...
    GROUP BY
    SUBSTRING(CAST((A * B) / 2 AS VARCHAR(15)) FROM 1 FOR 2)
        </programlisting>
      </section>

      <section id="rnfb20x-dml-sorting-orderby"
               xreflabel="Ordinamento di SELECT * per numero">
        <title>Ordinamento di SELECT * attraverso un numero implicito</title>

        <para>L'ordinamento per grado (cioè per posizione del numero di
        colonna) adesso può funzionare anche con SELECT *</para>

        <para>
          <emphasis role="bold">Esempio</emphasis>
        </para>

        <programlisting>
   SELECT *
     FROM RDB$RELATIONS
     ORDER BY 9
        </programlisting>
      </section>

      <section id="rnfb20x-dml-sorting-gotcha"
               xreflabel="ORDER BY numerici e parametri: attenzione!">
        <title>ORDER BY numerici e parametri: attenzione!</title>

        <para>Stando alle regole, a partire da Firebird 1.5, si può fare una
        ORDER BY &lt;espressione&gt;, e tale &lt;espressione&gt; può essere
        sia una variabile che un parametro. Si sarebbe tentati di pensare che
        fare un ORDER BY &lt;numero&gt; possa permettere sostituire
        &lt;numero&gt; con un parametro di input, o una espressione contenente
        un parametro.</para>

        <para>Tuttavia, mentre il parser DSQL non respinge la clausola ORDER
        BY parametrizzata se risolve ad un intero, l'ottimizzatore richiede un
        valore costante assoluto per poter identificare la <emphasis>posizione
        nella lista</emphasis> generata della colonna o campo derivato su cui
        effettuare l'ordinamento. Se un parametro è accettato dal parser, il
        risultato è sottoposto ad un ordinamento fittizio, e il risultato non
        sarà ordinato.</para>
      </section>
    </section>

    <section id="rnfb20x-dml-nextvalue" xreflabel="NEXT VALUE FOR">
      <sectioninfo>
        <title>L'espressione NEXT VALUE FOR</title>

        <author>
          <firstname>D.</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para>L'espressione <firstterm>NEXT VALUE FOR
      &lt;sequence_name&gt;</firstterm> conforme a SQL-99 è stata aggiunta
      come sinonimo di GEN_ID(&lt;generator-name&gt;, 1), integrando
      l'inserimento della sintassi SQL standard <firstterm>CREATE
      SEQUENCE</firstterm> come equivalente di CREATE GENERATOR.</para>

      <para>
        <emphasis role="bold">Esempi</emphasis>
      </para>

      <para>1.</para>

      <programlisting>
   SELECT GEN_ID(S_EMPLOYEE, 1) FROM RDB$DATABASE;
      </programlisting>

      <para>2.</para>

      <programlisting>
   INSERT INTO EMPLOYEE (ID, NAME)
     VALUES (NEXT VALUE FOR S_EMPLOYEE, 'John Smith');
      </programlisting>

      <note>
        <orderedlist>
          <listitem>
            <para>Attualmente, i valori di incremento diversi da 1 (uno)
            possono essere gestiti solo con la funzione GEN_ID. Si prevede
            nelle future versioni di supportare la gestione di generatori
            completamente secondo lo standard SQL-99, che permettono di
            specificare al livello DDL i richiesti intervalli di incremento. A
            meno che non ci sia la impellente necessità di usare un passo che
            non sia 1, si raccomanda di usare l'espressione NEXT VALUE FOR
            anziche la funzione GEN_ID.</para>
          </listitem>

          <listitem>
            <para>GEN_ID(&lt;name&gt;, 0) permette di sapere qual'è il valore
            corrente di un generatore, ma non dovrebbe mai essere usato con
            frasi di INSERT o UPDATE, perché si corre il grosso rischio di
            violare il vincolo di unicità se cisono processi
            concorrenti.</para>
          </listitem>
        </orderedlist>
      </note>
    </section>
  </section>

  <section id="rnfb210-articles">
    <title>Articoli</title>

    <section id="rnfb20x-dml-select-syntax"
             xreflabel="SELECT e sintassi delle espressioni">
      <sectioninfo>
        <title>SELECT e sintassi delle espressioni</title>

        <author>
          <firstname>Dmitry</firstname>

          <surname>Yemanov</surname>
        </author>
      </sectioninfo>

      <para>
        <emphasis>La semantica</emphasis>
      </para>

      <itemizedlist>
        <listitem>
          <para>Una frase SELECT si usa per riportare dati al chiamante (un
          modulo PSQL o un programma client)</para>
        </listitem>

        <listitem>
          <para>Una espressione di selezione SELECT recupera le parti dai dati
          per costruire colonne che possono far parte o dell'insieme finale
          risultante, o di un qualsiasi insieme intermedio. Le espressioni di
          selezione sono note anche come subquery.</para>
        </listitem>
      </itemizedlist>

      <para>
        <emphasis>Regole sintattiche</emphasis>
      </para>

      <programlisting>
  &lt;frase di select&gt; ::=
    &lt;espressione di select&gt; [FOR UPDATE] [WITH LOCK]

  &lt;espressione di select&gt; ::=
    &lt;specifiche di query&gt; [UNION [{ALL | DISTINCT}] &lt;specifiche di query&gt;]

  &lt;specifiche di query&gt; ::=
    SELECT [FIRST &lt;valore&gt;] [SKIP &lt;valore&gt;] &lt;lista di selezione&gt;
    FROM &lt;lista di espressioni tabellari&gt;
    WHERE &lt;condizioni di ricerca&gt;
    GROUP BY &lt;lista valori di raggruppamento&gt;
    HAVING &lt;condizioni di raggruppamento&gt;
    PLAN &lt;lista di elementi PLAN&gt;
    ORDER BY &lt;lista di valori per l'ordinamento&gt;
    ROWS &lt;value&gt; [TO &lt;value&gt;]

  &lt;espressione tabellare&gt; ::=
    &lt;nome tabella&gt; | &lt;tabella in join&gt; | &lt;tabella derivata&gt;

  &lt;tabella in join&gt; ::=
    {&lt;cross join&gt; | &lt;qualified join&gt;}

  &lt;cross join&gt; ::=
    &lt;espressione tabellare&gt; CROSS JOIN &lt;espressione tabellare&gt;

  &lt;qualified join&gt; ::=
    &lt;espressione tabellare&gt; [{INNER | {LEFT | RIGHT | FULL} [OUTER]}] JOIN &lt;espressione tabellare&gt;
    ON &lt;join condition&gt;

  &lt;tabella derivata&gt; ::=
    '(' &lt;espressione di select&gt; ')'
    </programlisting>

      <para>
        <emphasis>Conclusioni</emphasis>
      </para>

      <itemizedlist>
        <listitem>
          <para>La modalità FOR UPDATE ed il blocco di riga WITH LOCK possono
          essere effettuati solo sull'insieme di dati risultante, non possono
          essere applicati ad una subquery</para>
        </listitem>

        <listitem>
          <para>Le unioni con UNION sono possibili in qualsiasi
          subquery</para>
        </listitem>

        <listitem>
          <para>Le clausole FIRST, SKIP, PLAN, ORDER BY, ROWS sono permesse in
          ogni subquery</para>
        </listitem>
      </itemizedlist>

      <para>
        <emphasis>Note</emphasis>
      </para>

      <itemizedlist>
        <listitem>
          <para>Può essere specificata nella stessa SELECT solo una fra
          FIRST/SKIP o ROWS, altrimenti mischiando le sintassi avviene un
          errore di sintassi</para>
        </listitem>

        <listitem>
          <para>Una frase INSERT accetta una espressione di selezione SELECT
          per definire un iunsieme di righe da inserire in una tabella. La
          parte di SELECT relativa supporta tutte le caratteristiche definite
          per le frasi ed espressioni di selezione.</para>
        </listitem>

        <listitem>
          <para>Le frasi di UPDATE e DELETE sono sempre basate su un cursore
          implicito applicato alla tabella specificata e limitato dalla
          clausola WHERE. Si possono inoltre specificare le parti finali della
          sintassi di selezione per limitare il numero di registrazioni
          modificate od ottimizzare il comando.</para>

          <para>Le clausole permesse alla fine di una frase di UPDATE o DELETE
          sono PLAN, ORDER BY e ROWS.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="rnfb210-dataresult"
             xreflabel="Tipo del dato risultante da un'aggregazione">
      <sectioninfo>
        <title>Tipo del dato risultante da un'aggregazione</title>

        <author>
          <firstname>Arno</firstname>

          <surname>Brinkman</surname>
        </author>
      </sectioninfo>

      <para>Quando si effettua un'aggregazione per generare colonne con CASE o
      UNION con una miscela di tipi di dato compatibili, il motore deve
      scegliere un singolo tipo di dato per il risultato di ogni colonna. Chi
      sviluppa deve spesso preparare una variabile per depositarvi il
      risultato e può essere disorientato se avviene un'eccezione sul tipo di
      dato. Le seguenti regole sono quelle seguite per determinare il tipo di
      dato scelto dal motore per i valori di una colonna in tali
      condizioni.</para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>Sia DTS l'insieme dei tipi di dato presenti in una colonna
          risultato di cui dobbiamo determinare il tipo di dato risultante
          (DTR).</para>
        </listitem>

        <listitem>
          <para>Tutti i tipi di dato del DTS devono esser efra loro
          compatibili.</para>
        </listitem>

        <listitem>
          <para>Nel caso in cui</para>

          <orderedlist numeration="loweralpha">
            <listitem>
              <para>un qualsiasi valore del DTS sia una stringa di
              caratteri</para>

              <orderedlist numeration="lowerroman">
                <listitem>
                  <para>se tutti i dati del DTS sono di lunghezza fissa,
                  allora anche il risultato è di lunghezza fissa; altrimenti
                  il risultato è a lunghezza variabile.</para>

                  <para>La lunghezza della stringa risultante, in caratteri, è
                  uguale alla maggiore delle lunghezze, in caratteri, dei vari
                  tipi di dato del DTS.</para>
                </listitem>

                <listitem>
                  <para>Il set di caratteri e l'ordinamento usati sono presi
                  dal tipo di dato della prima stringa nel DTS.</para>
                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>tutto il DTS contiene precisione numerica esatta</para>

              <para>il tipo risultante è in precisione numerica esatta con
              scala uguale alla massima delle scale presenti nel DTS e con
              precisione uguale alla massima precisione presente fra tutti i
              dati del DTS.</para>
            </listitem>

            <listitem>
              <para>un qualunque dato del DTS è in precisione numerica
              approssimata</para>

              <para>ogni dato del DTS deve essere numerico, altrimenti viene
              segnalato un errore.</para>
            </listitem>

            <listitem>
              <para>un qualunque dato del DTS è del tipo data/ora</para>

              <para>tutti i dati del DTS devono essere <emphasis>esattamente
              dello stesso tipo</emphasis> di data/ora del primo, altrimenti
              viene segnalato un errore.</para>
            </listitem>

            <listitem>
              <para>un qualunque dato del DTS è un BLOB</para>

              <para>tutti i dati del DTS devono essere BLOB e tutti dello
              stesso sotto-tipo.</para>
            </listitem>
          </orderedlist>
        </listitem>
      </orderedlist>
    </section>

    <section id="rnfb20x-dml-datetimetyping">
      <sectioninfo>
        <title>La sintassi abbreviata: trucchetto per i letterali di
        data</title>

        <author>
          <firstname>H.</firstname>

          <surname>Borrie</surname>
        </author>
      </sectioninfo>

      <para>Nel passato, prima dell'avvento delle variabili di contesto come
      CURRENT_DATE, CURRENT_TIMESTAMP, ecc. , si usavano delle convenzionali
      <firstterm>stringhe letterali predefinite</firstterm>
      (<firstterm>predefined date literals</firstterm>), come 'NOW', 'TODAY',
      'YESTERDAY' e così via. Queste letterali predefinite sono sopravissute
      nel linguaggio SQL attuale di Firebird e sono ancora molto utili.</para>

      <para>In Interbase 5.x e precedenti, la seguente frase era
      <quote>legale</quote> e riportava un valore di tipo DATE ( ricordare che
      allora il tipo DATE era ciò che adesso è il tipo TIMESTAMP):</para>

      <programlisting>
select 'NOW' from rdb$database /* riporta data ed ora di sistema */
          </programlisting>

      <para>In un datbase con ODS 10 o superiore, quella frase riporta solo la
      stringa 'NOW'. Bisogna pertanto forzare il tipo del dato con CAST per
      ottenere adesso il risultato voluto:</para>

      <programlisting>
select cast('NOW' as TIMESTAMP) from rdb$database
          </programlisting>

      <para>Per molto tempo, probabilmente già da IB 6, c'è stata una non
      documentata <quote>sintassi abbreviata</quote> per forzare
      <emphasis>qualsiasi</emphasis> letterale, non solo quelli di data ed
      ora. Attualmente, è definito nello standard. MOlti di noi semplicemente
      non sapevano di questa possibilità. Questa sintassi ha la forma
      <filename>&lt;tipo-di-dato&gt; &lt;letterale&gt;</filename>. Con
      l'esempio di CAST precedente in mente, l'espressione sintattica
      abbreviata è:</para>

      <programlisting>
select TIMESTAMP 'NOW' from rdb$database
          </programlisting>

      <para>Questo tipo di sintassi abbreviata può essere utilizzata anche in
      altri modi. L'esempio seguente mostra un'operazione aritmetica sulle
      date con un letterale predefinito:</para>

      <programlisting>
update mytable
  set OVERDUE = 'T'
  where DATE 'YESTERDAY' - DATE_DUE &gt; 10
          </programlisting>
    </section>
  </section>
</chapter>