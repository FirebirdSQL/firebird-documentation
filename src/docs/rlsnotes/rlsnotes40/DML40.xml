<chapter id="rnfb40-dml">
  <chapterinfo>
    <title>Data Manipulation Language (DML)</title>
  </chapterinfo>
  <para>In this chapter are the additions and improvements that have been added to the SQL
  data manipulation language subset in Firebird 4.0.</para>

  <section id="rnfb40-dml-quicklinks"><!-- Level 1 section -->
    <title>Quick Links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para><link linkend="rnfb40-dml-lateral">Lateral Derived Tables</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-context_default">DEFAULT Context Value for Inserting and Updating</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-identity-overriding">OVERRIDING Clause for IDENTITY Columns</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-framed_windows">Frames for Window Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-named_windows">Named Windows</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-windows_newfunctions">More Window Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-filter-clause">FILTER Clause for Aggregate Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-autocommit">Optional AUTOCOMMIT for SET TRANSACTION</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-set-tran-snapshot">Sharing Transaction Snapshots</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-built-in-functions">Expressions and Built-in Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-udfs">UDF Changes</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-dml-improvement-01">Improved Error Message for an Invalid
        Write Operation</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-engine-dml-improvement-02">Improved Failure Messages for 
        Expression Indexes</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-engine-dml-improvement-03">RETURNING * Now Supported</link></para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="rnfb40-dml-lateral"><!-- Level 1 section -->
    <title>Lateral Derived Tables</title>
    <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-3435">CORE-3435</ulink></para>
    <para>A derived table defined with the <code>LATERAL keyword</code> is called a lateral derived table.
    If a derived table is defined as lateral, then it is allowed to refer to other tables in the same
    FROM clause, but only those declared before it in the FROM clause.</para>
    <para>The feature is defined in (SQL:2011): 7.6 &lt;table reference&gt; (Feature T491).</para>
    <para><emphasis role="bold">Examples</emphasis>
      <programlisting>
select dt.population, dt.city_name, c.country_name
from (select distinct country_name from cities) AS c,
  LATERAL (select first 1 city_name, population
           from cities
           where cities.country_name = c.country_name
           order by population desc) AS dt;
--
select salespeople.name,
       max_sale.amount,
       customer_of_max_sale.customer_name
from salespeople,
  LATERAL ( select max(amount) as amount from all_sales
            where all_sales.salesperson_id = salespeople.id
  ) as max_sale,
  LATERAL ( select customer_name from all_sales
            where all_sales.salesperson_id = salespeople.id
  and all_sales.amount = max_sale.amount
) as customer_of_max_sale;
      </programlisting>
    </para>

  </section><!-- L1 -->

  <section id="rnfb40-dml-context_default"><!-- Level 1 section -->
    <title>DEFAULT Context Value for Inserting and Updating</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5449">CORE-5449</ulink></para>
    <para>Support has been implemented to enable the declared default value for a column
    or domain to be included directly in INSERT, UPDATE, MERGE and UPDATE OR INSERT statements
    by use of the keyword DEFAULT in the column's position.  If DEFAULT appears in the position 
    of a column that has no default value defined, the engine will attempt to write NULL to that 
    column.</para>
    <para>The feature is defined in (SQL:2011): 6.5 &lt;contextually typed value specification&gt;.</para>
    <para><emphasis role="bold">Simple Examples</emphasis>
      <programlisting>
insert into sometable (id, column1)
values (DEFAULT, 'name')
--
update sometable 
  set column1 = 'a', column2 = default
      </programlisting>

      <note>
        <title>Notes</title>
        <para>If id is an identity column, the identity value will be generated, even
        if there is an UPDATE ... SET command associated with the column.</para>
        <para>If DEFAULT is specified on a computed column, the parser will allow it
        but it will have no effect.</para>
        <para>In columns populated by triggers in the traditional way, the value from 
        DEFAULT enters the NEW context variable of any BEFORE INSERT or BEFORE UPDATE 
        trigger.</para>
      </note>
    </para>

    <section id="rnfb40-dml-defaultstuff"><!-- Level 2 section -->
      <title>DEFAULT vs DEFAULT VALUES</title>
      <para>Since v.2.1, Firebird has supported the DEFAULT VALUES clause. The two 
      clauses are not the same.  The DEFAULT VALUES clause is an alternative to the 
      VALUES clause and can be used only when all of the colums specified in the column
      list have been defined with default values.</para>
    </section>
  </section><!-- L1 -->

  <section id="rnfb40-dml-identity-overriding"><!-- Level 1 section -->
    <title>OVERRIDING Clause for IDENTITY Columns</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5463">CORE-5463</ulink></para>
    <para>Identity columns defined with the BY DEFAULT attibute can be overriden in
    statements that insert rows (INSERT, UPDATE OR INSERT, MERGE ... WHEN NOT MATCHED)
    just by specifying the value in the values list. For identity columns defined with
    the GENERATE ALWAYS attribute, that kind of override is not allowed.</para>
   <para>Making the value passed in the INSERT statement for an ALWAYS column acceptable
    to the engine requires use of the OVERRIDING clause with the SYSTEM VALUE sub-clause,
    as illustrated below:
      <programlisting>
insert into objects (id, name)
  OVERRIDING SYSTEM VALUE values (11, 'Laptop');
      </programlisting>
    </para>
    <para>OVERRIDING supports another sub-clause, USER VALUE, for use with BY DEFAULT
    columns to direct the engine to ignore the value passed in INSERT and use the sequence defined
    for the identity column:
      <programlisting>
insert into objects (id, name)
  OVERRIDING USER VALUE values (12, 'Laptop');  -- 12 is not used
      </programlisting>
    </para>
  </section> <!-- rnfb40-dml-identity-overriding  L1 -->

  <section id="rnfb40-dml-windowing_ext"><!-- Level 1 section -->
    <title>Extension of SQL Windowing Features</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>

    <para>The OVER clause for Window functions in Firebird now supports not just the 
    sub-clauses PARTITION and ORDER subclauses but also <firstterm>frames</firstterm> and 
    <firstterm>windows with names</firstterm> that can be re-used in the same query.</para>

    <para><emphasis role="bold">Syntax Pattern</emphasis></para>
    <para>The pattern for Firebird 4 windowing syntax is as follows:
      <literallayout class="monospaced">
&lt;window function> ::=
&lt;window function name&gt;([&lt;expr&gt; [, &lt;expr&gt; ...]])
    OVER {&lt;window specification&gt; | &lt;existing window name&gt;}

&lt;window specification> ::=
  ([&lt;existing window name&gt;] [&lt;window partition&gt;] [&lt;window order&gt;] [&lt;window frame&gt;])

&lt;window partition> ::=
  PARTITION BY &lt;expr&gt; [, &lt;expr&gt; ...]

&lt;window order&gt; ::=
  ORDER BY &lt;expr&gt; [&lt;direction&gt;] [&lt;nulls placement&gt;] [, &lt;expr&gt; [&lt;direction&gt;] [&lt;nulls placement&gt;]] ...

&lt;window frame&gt; ::=
  {RANGE | ROWS} &lt;window frame extent&gt;

&lt;window frame extent&gt; ::=
  {&lt;window frame start&gt; | &lt;window frame between&gt;}

&lt;window frame start&gt; ::=
  {UNBOUNDED PRECEDING | &lt;expr&gt; PRECEDING | CURRENT ROW}

&lt;window frame between&gt; ::=
  BETWEEN {UNBOUNDED PRECEDING | &lt;expr> PRECEDING | &lt;expr&gt; FOLLOWING | CURRENT ROW} AND
          {UNBOUNDED FOLLOWING | &lt;expr&gt; PRECEDING | &lt;expr&gt; FOLLOWING | CURRENT ROW}

&lt;direction&gt; ::=
  {ASC | DESC}

&lt;nulls placement&gt; ::=
  NULLS {FIRST | LAST}

&lt;query spec&gt; ::=
  SELECT
    [&lt;limit clause&gt;]
    [&lt;distinct clause&gt;]
    &lt;select list&gt;
    &lt;from clause&gt;
    [&lt;where clause&gt;]
    [&lt;group clause&gt;]
    [&lt;having clause&gt;]
    [&lt;named windows clause&gt;]
    [&lt;plan clause&gt;]

&lt;named windows clause&gt; ::=
  WINDOW &lt;window definition&gt; [, &lt;window definition&gt;] ...

&lt;window definition> ::=
  &lt;new window name> AS &lt;window specification&gt;
      </literallayout>
    </para>

    <section id="rnfb40-dml-framed_windows"><!-- Level 2 section -->
      <title>Frames for Window Functions</title>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-3647">CORE-3647</ulink></para>
      <para>A <emphasis>frame</emphasis> can be specified, within which certain
      window functions are to work.</para>
      <para><emphasis>Syntax Elements for Frames</emphasis></para>
      <para>The following extract from the syntax pattern above explains the
      elements that affect frames:
        <literallayout class="monospaced">
&lt;window frame&gt; ::=
  {RANGE | ROWS} &lt;window frame extent&gt;

&lt;window frame extent&gt; ::=
  {&lt;window frame start&gt; | &lt;window frame between&gt;}

&lt;window frame start&gt; ::=
  {UNBOUNDED PRECEDING | &lt;expr&gt; PRECEDING | CURRENT ROW}

&lt;window frame between&gt; ::=
  BETWEEN {UNBOUNDED PRECEDING | &lt;expr> PRECEDING | &lt;expr&gt; FOLLOWING | CURRENT ROW} AND
          {UNBOUNDED FOLLOWING | &lt;expr&gt; PRECEDING | &lt;expr&gt; FOLLOWING | CURRENT ROW}
        </literallayout>
      </para>

      <para>The frame comprises three pieces: unit, start bound and end bound.
      The unit can be RANGE or ROWS and defines how the bounds will work.  The bounds are:
        <simplelist columns="1">
          <member>&lt;expr&gt; PRECEDING</member>
          <member>&lt;expr&gt; FOLLOWING</member>
          <member>CURRENT ROW</member>
        </simplelist>
      </para>
      <itemizedlist>
        <listitem>
          <para>With RANGE, the ORDER BY should specify only one expression, and that
          expression should be of a numeric, date, time or timestamp type. For &lt;expr&gt;
          PRECEDING and &lt;expr&gt; FOLLOWING bounds, &lt;expr&gt; is subtracted from
          the order expression in the case of PRECEDING and added to it in the case of
          FOLLOWING. For CURRENT ROW, the order expression is used as-is.</para>
          <para>All rows inside the partition that are between the bounds are considered
          part of the resulting window frame.</para>
        </listitem>
        <listitem>
          <para>With ROWS, order expressions are not limited by number or type. For this
          unit, &lt;expr&gt; PRECEDING, &lt;expr&gt; FOLLOWING and CURRENT ROW relate to
          the row position under the partition, and not to the values of the
          ordering keys.</para>
        </listitem>
      </itemizedlist>

      <para>UNBOUNDED PRECEDING and UNBOUNDED FOLLOWING work identically with RANGE
      and ROWS. UNBOUNDED PRECEDING looks for the first row and UNBOUNDED FOLLOWING
      the last one, always inside the partition.</para>

      <para>The frame syntax with &lt;window frame start&gt; specifies the start frame,
      with the end frame being CURRENT ROW.</para>

      <para>Some window functions discard frames:
        <itemizedlist spacing="compact">
          <listitem>ROW_NUMBER, LAG and LEAD always work as ROWS BETWEEN UNBOUNDED
          PRECEDING AND CURRENT ROW</listitem>
          <listitem>DENSE_RANK, RANK, PERCENT_RANK and CUME_DIST always work as
          RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW.</listitem>
          <listitem>FIRST_VALUE, LAST_VALUE and NTH_VALUE respect frames, but the
          RANGE unit behaviour is identical to ROWS.</listitem>
        </itemizedlist>
      </para>

      <section id="rnfb40-dml-navig_functions"><!-- Level 3 section -->
        <title>Navigational Functions with Frames</title>
        <para>Navigational functions, implemented in Firebird 3, get the simple
        (non-aggregated) value of an expression from another row that is within 
        the same partition.  They can operate on frames.  These are the 
        syntax patterns:
          <literallayout class="monospaced">
  &lt;navigational window function&gt; ::=
    FIRST_VALUE(&lt;expr&gt;) |
    LAST_VALUE(&lt;expr&gt;) |
    NTH_VALUE(&lt;expr&gt;, &lt;offset&gt;) [FROM FIRST | FROM LAST] |
    LAG(&lt;expr&gt; [ [, &lt;offset&gt; [, &lt;default&gt; ] ] ) |
    LEAD(&lt;expr> [ [, &lt;offset> [, &lt;default&gt; ] ] )
          </literallayout>
        </para>
        
        <para>The default frame is <code>RANGE BETWEEN UNBOUNDED PRECEDING AND
        CURRENT ROW</code> which might produce strange results when a frame with
        these properties is operated on by <code>FIRST_VALUE</code>, <code>NTH_VALUE</code> or,
        particularly, <code>LAST_VALUE</code>.</para>

      </section> <!-- rnfb40-dml-navig_functions  L3 -->
      <!-- Back in Level 2 section -->
      <bridgehead renderas="sect4">Example Using Frames</bridgehead>
      <para>When the ORDER BY window clause is used but a frame clause is omitted,
      the default frame just described causes the query below to produce weird
      behaviour for the <function>sum_salary</function> column. It sums from the
      partition start to the current key, instead of summing
      the whole partition.
        <programlisting>
 select
     id,
     salary,
     sum(salary) over (order by salary) sum_salary
   from employee
   order by salary; </programlisting>
      Result: <literallayout class="monospaced">
 | id | salary | sum_salary |
 |---:|-------:|-----------:|
 |  3 |   8.00 |       8.00 |
 |  4 |   9.00 |      17.00 |
 |  1 |  10.00 |      37.00 |
 |  5 |  10.00 |      37.00 |
 |  2 |  12.00 |      49.00 |
        </literallayout>
      A frame can be set explicitly to sum the whole partition, as follows:<programlisting>
 select
     id,
     salary,
     sum(salary) over (
       order by salary
       ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                      ) sum_salary
   from employee
   order by salary; 
        </programlisting>

      Result: 
        <literallayout class="monospaced">
 | id | salary | sum_salary |
 |---:|-------:|-----------:|
 |  3 |   8.00 |      49.00 |
 |  4 |   9.00 |      49.00 |
 |  1 |  10.00 |      49.00 |
 |  5 |  10.00 |      49.00 |
 |  2 |  12.00 |      49.00 |
        </literallayout>

      This query <quote>fixes</quote> the weird nature of the default frame
      clause, producing a result similar to a simple <function>OVER ()</function>
      clause without <function>ORDER BY</function>.</para>
      <para>We can use a range frame to compute the count of employees with salaries
      between (an employee's salary - 1) and (his salary + 1) with this query:
        <programlisting>
 select
     id,
     salary,
     count(*) over (
       order by salary
       RANGE BETWEEN 1 PRECEDING AND 1 FOLLOWING
     ) range_count
   from employee
   order by salary; 
        </programlisting>

      Result: 
       <literallayout class="monospaced">
 | id | salary | range_count |
 |---:|-------:|------------:|
 |  3 |   8.00 |           2 |
 |  4 |   9.00 |           4 |
 |  1 |  10.00 |           3 |
 |  5 |  10.00 |           3 |
 |  2 |  12.00 |           1 |
        </literallayout>
      </para>

    </section><!-- rnfb40-dml-framed_windows  L2 -->

    <section id="rnfb40-dml-named_windows"><!-- Level 2 -->
      <title>Named Windows</title>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5346">CORE-5346</ulink></para>
      <para>In a query with the WINDOW clause, a window can be explicitly named to
      avoid repetitive or confusing expressions.</para>
      <para>A named window can be used
        <orderedlist type="a">
          <listitem>in the OVER element to reference a window definition, e.g. OVER &lt;window-name&gt;</listitem>
          <listitem>as a base window of another named or inline (OVER) window, if it is not
          a window with a frame (ROWS or RANGE clauses).
            <note>a window with a base window cannot have PARTITION BY, nor override the ordering
            (ORDER BY sequence) of a base window.</note>
          </listitem>
        </orderedlist>
      </para>
      <para>In a query with multiple SELECT and WINDOW clauses (for example, with subqueries),
      the scope of the window name is confined to its query context.  That means a window
      name from an inner context cannot be used in an outer context, nor vice versa. 
      However, the same window name definition can be used independently in different contexts.</para>
      <para><emphasis role="bold">Example Using Named Windows</emphasis></para>
      <programlisting>
select
    id,
    department,
    salary,
    count(*) over w1,
    first_value(salary) over w2,
    last_value(salary) over w2
  from employee
  window w1 as (partition by department),
         w2 as (w1 order by salary)
  order by department, salary;
      </programlisting>
    </section><!--rnfb40-dml-named_windows --><!-- L2 -->
    
    <section id="rnfb40-dml-windows_newfunctions"><!-- Level 2 -->
      <sectioninfo>
        <title>More Window Functions</title>
        <authorgroup>
          <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
          <author><firstname>Hajime</firstname><surname>Nakagami</surname></author>
        </authorgroup>
      </sectioninfo>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-1688">CORE-1688</ulink></para>
      <para>More ANSI SQL:2003 window functions&mdash;the ranking functions
      PERCENT_RANK, CUME_DIST and NTILE.</para>

      <para><emphasis role="bold">Ranking Functions</emphasis></para>

      <literallayout class="monospaced">
&lt;ranking window function&gt; ::=
    DENSE_RANK() |
    RANK() |
    PERCENT_RANK() |
    CUME_DIST() |
    NTILE(&lt;expr&gt;) |
    ROW_NUMBER()
      </literallayout>

      <para>Ranking functions compute the ordinal rank of a row within the window partition.
      The basic functions in this category, present since Firebird 3, are DENSE_RANK,
      RANK and ROW_NUMBER.  These function enable creation of various types of
      incremental counters to generate sets in ways that are analogous with operations such
      as SUM(1) OVER (ORDER BY SALARY).</para>
      <para>The new functions implemented in Firebird 4 are:
        <itemizedlist spacing="compact">
          <listitem>PERCENT_RANK is a ratio of RANK to group count.</listitem>
          <listitem>CUME_DIST is the cumulative distribution of a value in a group.</listitem>
          <listitem>NTILE takes an argument and distributes the rows into
          the specified number of groups. The argument is restricted to integral positive literal,
          variable (:var) and DSQL parameter (?).</listitem>
        </itemizedlist>
      </para>

      <para><emphasis role="bold">Simple Example</emphasis></para>
      <para>The following example illustrates the behaviour of ranking functions.  SUM is
      included for comparison.</para>
      <programlisting>
select
    id,
    salary,
    dense_rank() over (order by salary),
    rank() over (order by salary),
    percent_rank() over (order by salary),
    cume_dist() over (order by salary),
    ntile(3) over (order by salary),
    row_number() over (order by salary),
    sum(1) over (order by salary)
  from employee
  order by salary;
      </programlisting>
      <para>The result set looks something like the following, although trailing zeroes
        have been truncated here in order to fit the lines to the document page:
        <literallayout class="monospaced">
id  salary   dense_rank   rank   percent_rank   cume_dist   ntile   row_number   sum
3     8.00            1      1      0.0000000  0.20000000       1            1     1
4     9.00            2      2      0.2500000  0.40000000       1            2     2
1    10.00            3      3      0.5000000  0.80000000       2            3     4
5    10.00            3      3      0.5000000  0.80000000       2            4     4
2    12.00            4      5      1.0000000  1.00000000       3            5     5
        </literallayout>
      </para>
    </section> <!--rnfb40-dml-windows_newfunctions --> <!-- L2 -->
  </section> <!--rnfb40-dml-windowing_ext --><!-- L1 -->

  <section id="rnfb40-dml-filter-clause"> <!-- Level 1 -->
    <title>FILTER Clause for Aggregate Functions</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5768">CORE-5768</ulink></para>
    <para>The FILTER clause extends aggregate functions (sum, avg, count, etc.) with an
    additional WHERE clause. The set returned is the aggregate of the rows that satisfy
    the conditions of both the main WHERE clause and those inside the FILTER clause(s).</para>
    <para>It can be thought of as a shortcut for situations where one would use an aggregate 
    function with some condition (decode, case, iif) to ignore some of the values that would 
    be considered by the aggregation.</para>
    <para>The clause can be used with any aggregate functions in aggregate or windowed (OVER)
    statements, but not with window-only functions like DENSE_RANK.</para>
    <para><emphasis role="bold">Example</emphasis></para>
    <para>Suppose you have a query where you want to count the number of status = 'A' and the 
    number of status = 'E' as different columns.  The old way to do it would be:
    <programlisting>
select count(decode(status, 'A', 1)) status_a,
       count(decode(status, 'E', 1)) status_e
  from data;
    </programlisting>
    </para>
    <para>The FILTER clause lets you express those conditions more compactly:
    <programlisting>
select count(*) filter (where status = 'A') status_a,
       count(*) filter (where status = 'E') status_e
  from data;
    </programlisting>
    </para>
    <note>
      <title>Tip</title>
      <para>You can use more than one FILTER modifier in an aggregate query.
      You could, for example, use 12 filters on totals aggregating sales 
      for a year to produce monthly figures for a pivot set</para>
    </note>

    <section id="rnfb40-dml-filter-clause-syntax"><!-- Level 2 -->
      <title>Syntax for FILTER Clauses</title>
      <para>
      <literallayout class="monospaced">
 aggregate_function [FILTER (WHERE &lt;condition&gt;)] [OVER (&lt;window&gt;)]
      </literallayout>
      </para>
    </section> <!-- L2 -->
  </section><!-- L1 -->

  <section id="rnfb40-dml-autocommit"><!-- Level 1 -->
    <title>Optional AUTOCOMMIT for SET TRANSACTION</title>
    <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5119">CORE-5119</ulink></para>
     <para>Autocommit mode is now supported in the <code>SET TRANSACTION</code> statement
     syntax.</para>
     <bridgehead renderas="sect4">Example</bridgehead>
     <programlisting>
SET TRANSACTION SNAPSHOT NO WAIT AUTO COMMIT;
     </programlisting>
   </section><!-- L1 -->

  <section id="rnfb40-dml-set-tran-snapshot"><!-- Level 1 -->
    <title>Sharing Transaction Snapshots</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-6018">CORE-6018</ulink></para>
    <para>With this feature it's possible to create parallel (using different attachments) processes reading
    consistent data from a database. For example, a backup process may create multiple threads reading data
    from the database in parallel. Or a web service may dispatch distributed sub-services doing some processing
    in parallel.</para>
    <para>For this purpose, the <code>SET TRANSACTION</code> statement is extended with the
    <code>SNAPSHOT [ AT NUMBER &lt;snapshot number&gt; ]</code> option. Alternatively, this feature can also
    be used via API, new Transaction Parameter Buffer item
    <code>isc_tpb_at_snapshot_number &lt;snapshot number length&gt; &lt;snapshot number&gt;</code> is added
    for this purpose.</para>
    <para>The &lt;snapshot number&gt; from the priorly started transaction may be obtained with
    <code>RDB$GET_CONTEXT('SYSTEM', 'SNAPSHOT_NUMBER')</code> in SQL or using the transaction information
    API call with <code>fb_info_tra_snapshot_number</code> information tag. Note that the
    &lt;snapshot number&gt; passed to the new transaction must be a snapshot of a currently active transaction.</para>
    <bridgehead renderas="sect4">Example</bridgehead>
    <programlisting>
SET TRANSACTION SNAPSHOT AT NUMBER 12345;
    </programlisting>
  </section><!-- L1 -->

  <section id="rnfb40-dml-built-in-functions"> <!-- Level 1 -->
    <title>Expressions and Built-in Functions</title>
    <para>Additions and changes to the sets of built-in functions and
    expressions in Firebird 4.</para>

    <section id="rnfb40-dml-new-built-in-functions"><!-- Level 2 -->
      <title>New Functions and Expressions</title>
      <para>Built-in functions and expressions added in Firebird 4.0.</para>
      
      <section id="rnfb40-dml-new-timezonefuncs"><!-- Level 3 -->
        <title>Functions &amp; Expressions for Timezone Operations</title>
        <author>
          <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
        </author>
        <para>Expressions and built-in functions for timezone operations.</para>

        <section id="rnfb40-dml-timezone-expr-at"><!-- Level 4 -->
          <title>AT Expression</title>
          <para>Translates a time/timestamp value to its corresponding value
          in another time zone.  If <code>LOCAL</code> is used, the value is
          converted to the session time zone.</para>

          <bridgehead renderas="sect4">Syntax</bridgehead>
          <literallayout class="monospaced">
&lt;at expr&gt; ::= &lt;expr&gt; AT { TIME ZONE &lt;time zone string&gt; | LOCAL }
          </literallayout>

          <bridgehead renderas="sect4">Examples</bridgehead>
          <programlisting>
select time '12:00 GMT' at time zone '-03' from rdb$database;
select current_timestamp at time zone 'America/Sao_Paulo' from rdb$database;
select timestamp '2018-01-01 12:00 GMT' at local from rdb$database;
          </programlisting>
        </section><!-- L4 -->
      
        <section id="rnfb40-dml-timezone-expr-localtime"><!-- Level 4 -->
          <title>LOCALTIME Expression</title>
          <para>Returns the current time as a <code>TIME WITHOUT TIME ZONE</code>,
          i.e., in the session time zone.
          <bridgehead renderas="sect4">Example</bridgehead>
          <programlisting>
select localtime from rdb$database;
          </programlisting>
          </para>
        </section><!-- L4 -->

        <section id="rnfb40-dml-timezone-expr-localtimestamp"><!-- Level 4 -->
          <title>LOCALTIMESTAMP Expression</title>
          <para>Returns the current timestamp as a <code>TIMESTAMP WITHOUT TIME ZONE</code>,
          i.e., in the session time zone.
          <bridgehead renderas="sect4">Example</bridgehead>
          <programlisting>
select localtimestamp from rdb$database;
          </programlisting>
          </para>
        </section><!-- L4 -->
     </section><!-- rnfb40-dml-new-timezonefuncs -->

      <section id="rnfb40-dml-new-timefuncs">
        <title>Two New Date/Time Functions</title>
        <author>
          <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
        </author>
        <variablelist>
          <varlistentry>
            <term>FIRST_DAY</term>
            <listitem>
              <para>Returns a date or timestamp (as appropriate) with the 
              first day of the year | month | week of a given date or 
              timestamp value.</para>
              
              <para>Format:
              <literallayout class="monospaced">
 FIRST_DAY( OF { YEAR | MONTH | WEEK } FROM &lt;date_or_timestamp&gt; )
              </literallayout> 
              </para>
            </listitem>
            <listitem>
              <orderedlist>
                <listitem>The first day of the week is considered as Sunday,
                following the same rules as for EXTRACT with WEEKDAY</listitem>
                <listitem>When a timestamp is passed the return value preserves 
                the time part</listitem>
              </orderedlist>
            </listitem>
            <listitem>
              <para><emphasis role="bold">Examples</emphasis></para>
              <para>
                <programlisting>
select first_day(of month from current_date) from rdb$database;
select first_day(of year from current_timestamp) from rdb$database;
select first_day(of week from date '2017-11-01') from rdb$database;
                </programlisting>
              </para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>LAST_DAY</term>
            <listitem>
              <para>Returns a date or timestamp (as appropriate) with the 
              last day of the year | month | week of a given date or
              timestamp value.</para>
              
              <para>Format:
              <literallayout class="monospaced">
 LAST_DAY( OF { YEAR | MONTH | WEEK } FROM &lt;date_or_timestamp&gt; )
              </literallayout> 
              </para>
            </listitem>
            <listitem>
              <orderedlist>
                <listitem>The lastt day of the week is considered as Saturday,
                following the same rules as for EXTRACT with WEEKDAY</listitem>
                <listitem>When a timestamp is passed the return value preserves 
                the time part</listitem>
              </orderedlist>
            </listitem>
            <listitem>
              <para><emphasis role="bold">Examples</emphasis></para>
              <para>
                <programlisting>
select last_day(of month from current_date) from rdb$database;
select last_day(of year from current_timestamp) from rdb$database;
select last_day(of week from date '2017-11-01') from rdb$database;
                </programlisting>
              </para>
            </listitem>
          </varlistentry>
          
        </variablelist>
      </section><!-- rnfb40-dml-new-timefuncs -->
      
      <section id="rnfb40-dml-new-security-funcs">
        <title>Security Functions</title>
        <para>Two new built-in functions were added to support the new security features.
        They are not described here&mdash;the descriptions are located in the Security
        chapter. They are:
          <itemizedlist>
            <listitem><link linkend="rnfb4-rdb$systemprivilege-function">RDB$SYSTEM_PRIVILEGE</link>
            </listitem>
            <listitem><link linkend="rnfb4-rdb$role_in_use-function">RDB$ROLE_IN_USE</link>
            </listitem>
          </itemizedlist>
        </para>
        <para>A number of cryptographic functions was also added. See 
        <link linkend="rnfb4-builtin-crypto-functions">Built-in Cryptographic Functions</link> in
        the Security chapter for syntax and usage details.</para>
      </section><!-- rnfb40-dml-new-security-funcs -->

      <section id="rnfb40-dml-new-decfloat-funcs">
        <title>Special Functions for DECFLOAT</title>
        <para>Firebird supports four functions, designed to support
        DECFLOAT data specifically:
          <itemizedlist>
            <listitem>
              <para>&nbsp;COMPARE_DECFLOAT&mdash;compares two DECFLOAT values to
              be equal, different or unordered.  Returns a SMALLINT value, one of:

                <informaltable frame="none">
                  <tgroup cols="2">
                    <colspec colwidth="1.0in"/>
                    <colspec colwidth="4.5in"/>
                    <tbody>
                      <row><entry>0</entry><entry>Values are equal</entry></row>
                      <row><entry>1</entry><entry>First value is less than second</entry></row>
                      <row><entry>2</entry><entry>First value is greater than second</entry></row>
                      <row><entry>3</entry><entry>Values are unordered, i.e., one or both is NAN / SNAN</entry></row>
                    </tbody>
                  </tgroup>
                </informaltable>
              </para>
              <para>Unlike the comparison operators ('&lt;', '=', '&gt;', etc.) comparison is
              exact: <function>COMPARE_DECFLOAT(2.17, 2.170)</function> returns 2, not 0.</para>
            </listitem>

            <listitem>
              <para>&nbsp;NORMALIZE_DECFLOAT&mdash;takes a single DECFLOAT argument and
              returns it in its simplest form. That means that for any non-zero value,
              trailing zeros are removed with appropriate correction of the exponent.</para>
              <para>For example, <function>NORMALIZE_DECFLOAT(12.00)</function> returns 12 and
              <function>NORMALIZE_DECFLOAT(120)</function> returns 1.2E+2.</para>
            </listitem>

            <listitem>
              <para>&nbsp;QUANTIZE&mdash; takes two DECFLOAT arguments. The returned value
              is the first argument scaled using the second value as a pattern.</para>
              <para>For example, <function>QUANTIZE(1234, 9.999)</function> returns 1234.000.</para>

              <para>There are almost no retrictions on the pattern. However, in almost
              all usages, SNaN will produce an exception, NULL will make the function
              return NULL, and so on.
                <programlisting>
SQL&gt; select v, pic, quantize(v, pic) from examples;

                       V                   PIC QUANTIZE
 ======================= ===================== ==================
                    3.16 0.001                   3.160
                    3.16 0.01                    3.16
                    3.16 0.1                     3.2
                    3.16 1                       3
                    3.16 1E+1                    0E+1
                    -0.1 1                      -0
                       0 1E+5                    0E+5
                     316 0.1                   316.0
                     316 1                     316
                     316 1E+1                  3.2E+2
                     316 1E+2                    3E+2
                </programlisting>
              </para>
              <note>
                <orderedlist spacing="compact">
                  <listitem>If scaling like the example produces a result that
                  would exceed the precision, the error <quote>Decimal float
                  invalid operation</quote> is returned.</listitem>
                  <listitem>A known bug
                  (<ulink url="http://tracker.firebirdsql.org/browse/CORE-5697">CORE-5697</ulink>),
                  can sometimes cause the use of literals in QUANTIZE to produce strange results.
                  A workaround in Beta 1 is to use a string literal, i.e., enclose the
                  DECFLOAT number in single quotes.</listitem>
                </orderedlist>
              </note>
            </listitem>

            <listitem>
              <para>&nbsp;TOTALORDER&mdash;compares two DECFLOAT values including any
              special value. The comparison is exact. Returns a SMALLINT value, one of:
                <informaltable frame="none">
                  <tgroup cols="2">
                    <colspec colwidth="1.0in"/>
                    <colspec colwidth="4.5in"/>
                    <tbody>
                      <row><entry>-1</entry><entry>First value is less than second</entry></row>
                      <row><entry>0</entry><entry>Values are equal</entry></row>
                      <row><entry>1</entry><entry>First value is greater than second</entry></row>
                    </tbody>
                  </tgroup>
                </informaltable>
              </para>
              <para>For TOTALORDER  comparisons, DECFLOAT values are ordered as follows:
                <literallayout class="monospaced">
-nan &lt; -snan &lt; -inf &lt; -0.1 &lt; -0.10 &lt; -0 &lt; 0 &lt; 0.10 &lt; 0.1 &lt; inf &lt; snan &lt; nan
                </literallayout>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </section><!-- rnfb40-dml-new-decfloat-funcs -->

      <section id="rnfb40-dml-new-get-cn">
        <sectioninfo>
          <title>Function RDB$GET_TRANSACTION_CN</title>
          <subtitle>Supporting Snapshots Based on Commit Order</subtitle>
          <author>
            <firstname>Vlad</firstname><surname>Khorsun</surname>
          </author>
        </sectioninfo>
        <para>See Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5921">CORE-5921</ulink>.
        For the background, see
        <link linkend="rnfb40-engine-trans-commit-order">Commit Order for Capturing 
        the Database Snapshot</link> in the Engine chapter.</para>
        <para>Returns the commit number (<quote>CN</quote>)of the supplied transaction.
        Result type is BIGINT.</para>
        <para><emphasis role="bold">Format</emphasis>
          <literallayout class="monospaced">
  RDB$GET_TRANSACTION_CN( &lt;transaction number&gt; )
          </literallayout>
        </para>
        <para>If the value returned is greater than 1, it will be the actual CN of 
        the transaction if it was committed after the database was started.</para>  
        <para>The function could return one of the following results instead, indicating
        the commit status of the transaction:
        <itemizedlist>
          <listitem>-2 &mdash;Transaction is dead (rolled back)</listitem>
          <listitem>-1 &mdash;Transaction is in limbo</listitem>
          <listitem>&nbsp;0 &mdash;Transaction is still active</listitem>
          <listitem>&nbsp;1 &mdash;Transaction committed before the database started
             or less than the Oldest Interesting Transaction for the database</listitem>
          <listitem>NULL&mdash;Transaction number supplied is NULL or greater than
          Next Transaction for the database</listitem>
        </itemizedlist>
        </para>
        <note>
          <title>Note about the numerics</title>
          <para>Internally, the engine uses unsigned 8-byte integer for commit 
          numbers and unsigned 6-byte integer for transaction numbers. Thus, 
          although the SQL language has no unsigned integers and 
          RDB$GET_TRANSACTION_CN returns a signed BIGINT, a negative commit 
          number will never be returned except for the special values returned 
          for uncommitted transactions.</para>
        </note>
        <para><emphasis role="bold">Examples</emphasis>
          <literallayout class="monospaced">
  select rdb$get_transaction_cn(current_transaction) from rdb$database;
  select rdb$get_transaction_cn(123) from rdb$database;
          </literallayout>
        </para>
      </section><!-- rnfb40-dml-new-get-cn -->
      
      <section id="rnfb40-dml-new-make-dbkey">
        <title>Function MAKE_DBKEY</title>
          <author>
            <firstname>Vlad</firstname><surname>Khorsun</surname>
          </author>
        <para>Creates a DBKEY value using relation name or ID, record number, and (optionally)
        logical number of data page and pointer page. Result type is BINARY(8).</para>
        <para><emphasis role="bold">Format</emphasis>
          <literallayout class="monospaced">
  MAKE_DBKEY( &lt;relation&gt;, &lt;recnum&gt; [, &lt;dpnum&gt; [, &lt;ppnum&gt;]] )
          </literallayout>
        </para>
        <para><emphasis role="bold">Notes</emphasis>
        <orderedlist>
          <listitem>If <emphasis>relation</emphasis> is a string expression or literal, then it is
          treated as a relation name and the engine searches for the corresponding relation ID.
          The search is case-sensitive. In the case of string literal, relation ID is evaluated
          at query preparation time. In the case of expression, relation ID is evaluated at
          execution time. If the relation could not be found, then error <emphasis>isc_relnotdef</emphasis>
          is raised.</listitem>
          <listitem>If <emphasis>relation</emphasis> is a numeric expression or literal, then it is
          treated as a relation ID and used "as is", without verification against existing relations.
          If the argument value is negative or greater than the maximum allowed relation ID
          (65535 currently), then NULL is returned.</listitem>
          <listitem>Argument <emphasis>recnum</emphasis> represents an absolute record number
          in relation (if the next arguments <emphasis>dpnum</emphasis> and <emphasis>ppnum</emphasis>
          are missing), or a record number relative to the first record, specified by the next
          arguments.</listitem>
          <listitem>Argument <emphasis>dpnum</emphasis> is a logical number of data page in
          relation (if the next argument <emphasis>ppnum</emphasis> is missing), or number of data page
          relative to the first data page addressed by the given <emphasis>ppnum</emphasis>.</listitem>
          <listitem>Argument <emphasis>ppnum</emphasis> is a logical number of pointer page
          in relation.</listitem>
          <listitem>All numbers are zero-based.  Maximum allowed value for <emphasis>dpnum</emphasis>
          and <emphasis>ppnum</emphasis> is 2^32 (4294967296). If <emphasis>dpnum</emphasis> is
          specified, then <emphasis>recnum</emphasis> could be negative. If <emphasis>dpnum</emphasis>
          is missing and <emphasis>recnum</emphasis> is negative, then NULL is returned. If
          <emphasis>ppnum</emphasis> is specified, then <emphasis>dpnum</emphasis> could be negative.
          If <emphasis>ppnum</emphasis> is missing and <emphasis>dpnum</emphasis> is negative, then
          NULL is returned.</listitem>
          <listitem>If any of specified arguments has NULL value, the result is also NULL.</listitem>
          <listitem>Argument <emphasis>relation</emphasis> is described as INTEGER during query
          preparation, but it could be overriden by a client application as VARCHAR or CHAR. Arguments
	      <emphasis>recnum</emphasis>, <emphasis>dpnum</emphasis> and <emphasis>ppnum</emphasis> are
          described as BIGINT.</listitem>
        </orderedlist>
        </para>
        <para><emphasis role="bold">Examples</emphasis>
          <programlisting>
-- (1) Select record using relation name (note: relation name is uppercased)

select * from rdb$relations where rdb$db_key = make_dbkey('RDB$RELATIONS', 0)

-- (2) Select record using relation ID

select * from rdb$relations where rdb$db_key = make_dbkey(6, 0)

-- (3) Select all records physically residing on the first data page

select * from rdb$relations
  where rdb$db_key &gt;= make_dbkey(6, 0, 0)
	and rdb$db_key &lt; make_dbkey(6, 0, 1)

-- (4) Select all records physically residing on the first data page of 6th pointer page

select * from SOMETABLE
  where rdb$db_key &gt;= make_dbkey('SOMETABLE', 0, 0, 5)
	and rdb$db_key &lt; make_dbkey('SOMETABLE', 0, 1, 5)
          </programlisting>
        </para>
      </section><!-- rnfb40-dml-new-make-dbkey -->

      <section id="rnfb4-builtin-base64">
        <title>BASE64_ENCODE() and BASE64_DECODE()</title>
        <author>
          <firstname>Alex</firstname><surname>Peshkov</surname>
        </author>
        <para>These two functions are for encoding and decoding input data 
        between string and BASE64 representation. They operate with character strings 
        and BLOBs. Considered useful when working with binary objects&mdash;with keys, 
        for example.</para>
        <para><emphasis role="bold">Format</emphasis>
          <literallayout class="monospaced">
  BASE64_ENCODE( &lt;binary data&gt; )
  BASE64_DECODE( &lt;base64 data&gt; )
          </literallayout>
        </para>
        <para><emphasis role="bold">Example</emphasis>
          <literallayout class="monospaced">
  select base64_encode(public_key) from clients;
          </literallayout>
        </para>
      </section><!-- rnfb4-builtin-base64 -->
      
      <section id="rnfb4-builtin-hex">
        <title>HEX_ENCODE() and HEX_DECODE()</title>
        <author>
          <firstname>Alex</firstname><surname>Peshkov</surname>
        </author>
        <para>These two functions are for encoding and decoding input data 
        between string and hexadecimal representation. They operate with character strings 
        and BLOBs.</para>
        <para><emphasis role="bold">Format</emphasis>
          <literallayout class="monospaced">
  HEX_ENCODE( &lt;binary data&gt; )
  HEX_DECODE( &lt;hex data&gt; )
          </literallayout>
        </para>
        <para><emphasis role="bold">Example</emphasis>
          <literallayout class="monospaced">
  select hex_encode(binary_string) from clients;
          </literallayout>
        </para>
      </section><!-- rnfb4-builtin-hex -->
      
      <section id="rnfb4-builtin-crc32">
        <title>CRC32()</title>
        <author>
          <firstname>Alex</firstname><surname>Peshkov</surname>
        </author>
        <para>Accepts an argument than can be a field, variable or expression
        of any type recognised by DSQL/PSQL and returns a CRC-32 code calculated
        from the input data with the polynomial 0x04C11DB7.  A constant, such as
        a file name passed as a string, returns the CRC for only the input.</para>
        <para><emphasis role="bold">Format</emphasis>
          <literallayout class="monospaced">
  CRC32( &lt;any value&gt; )
          </literallayout>
        </para>
        <para><emphasis role="bold">Example</emphasis>
          <literallayout class="monospaced">
  select crc32(job_title) from job;

  select crc32('Firebird-4.0.0.716-Alpha1.amd64.tar.gz') from rdb$database;
          </literallayout>
        </para>
        <note>
        <para>Initially CRC codes were designed as a tool to detect accidental 
        changes to raw data when transferred over the wire or stored somewhere.</para>
        <para>It can be used as a very fast and rather efficient hash function. If 
        the risk of collisions is not critical, its 32-bit integer output bestows a 
        significant advantage over the widely-used SHA family of hashes in that it 
        is easier to use later in various calculations if needed.</para>
        </note>
      </section><!-- rnfb4-builtin-crc32 -->

    </section> <!-- rnfb40-dml-new-built-in-functions -->

    <section id="rnfb40-dml-changes-built-in-functions"><!-- Level 2 -->
      <title>Changes to Built-in Functions and Expressions</title>
      <para>Functions changed or extended in this release:</para>
      
      <section id="rnfb40-dml-changes-functions-timezone"><!-- Level 3 -->
        <title>Changes Arising from Timezone Support</title>
        
        <section id="rnfb40-dml-timezone-expr-extract"><!-- Level 4 -->
          <title>EXTRACT Expressions</title>
          <para>Two new arguments have been added to the <code>EXTRACT</code> expression:
            <itemizedlist>
              <listitem><code>TIMEZONE_HOUR</code>: extracts the time zone hours displacement</listitem>
              <listitem><code>TIMEZONE_MINUTE</code>: extracts the time zone minutes displacement</listitem>
            </itemizedlist>
          </para>
          <bridgehead renderas="sect4">Examples</bridgehead>
          <programlisting>
select extract(timezone_hour from current_time) from rdb$database;
select extract(timezone_minute from current_timestamp) from rdb$database;
          </programlisting>
        </section><!-- L4 -->

        <section id="rnfb40-dml-timezone-changes"><!-- Level 4 -->
          <title>Changes in CURRENT_TIME and CURRENT_TIMESTAMP</title>
          <para>In version 4.0, <code>CURRENT_TIME</code> and <code>CURRENT_TIMESTAMP</code>
          are changed:  they now return <code>TIME WITH TIME ZONE</code> and
          <code>TIMESTAMP WITH TIME ZONE</code>, with the time zone set by the session time
          zone. In previous versions, <code>CURRENT_TIME</code> and <code>CURRENT_TIMESTAMP</code>
          returned the respective types according to the system clock, i.e., without any
          time zone.</para>
          <para>To ease the transition, <code>LOCALTIME</code> and <code>LOCALTIMESTAMP</code>
          were added at v3.0.4, allowing developers to adjust application code without any
          functional changes, before  migrating to Firebird 4.</para>
        </section><!-- L4 -->
        <important>
          <para>See also <link linkend="rnfb40-compat-sql-timezone-changes">Changes in DDL and
          DML Due to Timezone Support</link> in the Compatibility chapter.</para>
        </important>
      </section><!-- rnfb40-dml-changes-functions-timezone L3 -->

      <section id="rnfb40-dml-changes-functions-hash">
        <title>HASH()</title>
        <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
        <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-4436">CORE-4436</ulink></para>
        <para>Returns a hash for a string using a specified algorithm.  Format is:
          <literallayout class="monospaced">
    HASH( &lt;string&gt; [ USING &lt;algorithm&gt; ] )

    algorithm ::= { MD5 | SHA1 | SHA256 | SHA512 }
          </literallayout>
        </para>
        <para>The syntax with the optional USING clause is introduced in FB 4.0 and
        returns VARCHAR strings in character set OCTETS.</para>

        <important>
          <para>The syntax without the USING clause is still supported. It uses
           the 64-bit variation of the non-cryptographic PJW hash function (also known
          as ELF64):</para>
          <para><ulink url="https://en.wikipedia.org/wiki/PJW_hash_function">https://en.wikipedia.org/wiki/PJW_hash_function</ulink>
          </para>
          <para>which is very fast and can be used for general purposes (hash tables,
          etc), but its collision quality is sub-optimal. Other hash functions
          (specified explicitly in the USING clause) should be used for more reliable 
          hashing.</para>
        </important>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
select hash(x using sha256) from y;
--
select hash(x) from y; -- not recommended
        </programlisting>
      </section> <!-- rnfb40-dml-changes-functions-hash -->

    </section> <!-- rnfb40-dml-changes-built-in-functions -->
    
    <section id="rnfb40-dml-substring">
      <title>SUBSTRING()</title>
      <para>A SUBSTRING start position smaller than 1 is now allowed. It has
      some properties that need to be taken into consideration for predicting
      the end of the string value returned.</para>
      <bridgehead renderas="sect4">Examples</bridgehead>
      <para>
        <literallayout class="monospaced">
  select substring('abcdef' from 0) from rdb$database
        </literallayout>
       Expected result: 'abcdef'
        <literallayout class="monospaced">
 select substring('abcdef' from 0 for 2) from rdb$database
        </literallayout>
        Expected result: 'a' (and NOT 'ab', because there is
        <quote>nothing</quote> at position 0)
        <literallayout class="monospaced">
 select substring('abcdef' from -5 for 2) from rdb$database
        </literallayout>
Expected result: ''
      </para>
      <para>Those last two examples might not be what you expect. The
      <code>for &lt;length&gt;</code> is considered from the specified
      <code>from &lt;start&gt;</code> position, not the start of the string,
      so the string returned could be shorter than the specified
      &lt;length&gt;, or even empty.
      </para>
    </section>

    <section id="rnfb40-dml-udfs"><!-- BETA 1 --><!-- Level 2 -->
      <title>UDF Changes</title>
      <para>Many of the UDFs in previous versions became built-in functions.  The UDF feature
      itself is heavily deprecated in Firebird 4&mdash;see
      <link linkend="rnfb40-engine-deprecated-udfs">External Functions (UDFs) Feature Deprecated</link>
      in the Engine chapter.  Most of the remaining UDFs in the <code>ib_udf</code> and <code>fbudf</code>
      libraries now have analogs, either as UDRs in the new library <code>udf_compat</code> or
      as precompiled PSQL functions.</para>
      <para>A script in the <filename>/misc/upgrade/4.0/</filename> sub-directory of your installation
      provides an easy way to upgrade existing UDF declarations to the safe form that is available for
      each respective UDF.  For details and instructions, see
      <link linkend="rnfb40-compat-udfs">Deprecation of External Functions (UDFs)</link> in the
      Compatibility chapter.</para>

      <section id="rnfb40-dml-udfs-getexacttimestamputc"><!-- Level 3 -->
        <title>New UDR GetExactTimestampUTC</title>
        <para>The new UDR <code>GetExactTimestampUTC</code>, in the <code>udf_compat</code>
        library, takes no input argument and returns the TIMESTAMP WITH TIME ZONE value at the moment
        the function is called.</para>
        <para>The older function, <code>GetExactTimestamp</code> has been refactored as a
        stored function, returning, as before, the TIMESTAMP WITHOUT TIME ZONE value at the moment
        the function is called.</para>
      </section><!-- L3 -->
    </section><!-- rnfb40-dml-udfs -->
  </section> <!-- rnfb40-dml-built-in-functions -->

  <section id="rnfb40-dml-improvements"><!-- BETA 1 -->
    <title>Miscellaneous DML Improvements</title>
    <para>Improvements to behaviour and performance in DML include:</para>
  
    <section id="rnfb40-dml-improvement-01">
      <title>Improve Error Message for an Invalid Write Operation</title>
      <author>
        <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
      </author>
      <para>See Tracker ticket
      <ulink url="http://tracker.firebirdsql.org/browse/CORE-5874">CORE-5874</ulink>.</para>
      <para>When a read-only column is incorrectly targeted in an <code>UPDATE ... SET xxx</code>
      operation, the error message now provides the name of the affected column.</para>
    </section>

    <section id="rnfb40-engine-dml-improvement-02"><!-- L2 --><!-- BETA 1 -->
      <title>Improved Failure Messages for Expression Indexes</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5606">CORE-5606</ulink></para>
      <para>If computation of an expression index fails, the exception message
      will now include the name of the index.</para>
    </section><!-- L2 -->

    <section id="rnfb40-engine-dml-improvement-03"><!-- L2 --><!-- BETA 1 -->
      <title>RETURNING * Now Supported</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-3803">CORE-3808</ulink></para>
      <para>The engine now supports <code>RETURNING *</code> syntax, and variants, 
      to return a complete set of field values after committing a row that has been 
      inserted, updated or deleted. The syntax and semantics of<code>RETURNING *</code> 
      are similar to <code>SELECT *</code>.</para>
      <bridgehead renderas="sect4">Examples</bridgehead>
      <programlisting>
INSERT INTO T1 (F1, F2) VALUES (:F1, :F2) RETURNING *

DELETE FROM T1 WHERE F1 = 1 RETURNING *

UPDATE T1 SET F2 = F2 * 10 RETURNING OLD.*, NEW.*
      </programlisting>
    </section><!-- L2 -->

  </section><!-- rnfb40-dml-improvements -->

</chapter>
