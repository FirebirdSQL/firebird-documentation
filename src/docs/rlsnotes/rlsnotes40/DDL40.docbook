<chapter id="rnfb40-ddl">
  <chapterinfo>
    <title>Data Definition Language (DDL)</title>
  </chapterinfo>

  <section id="rnfb40-ddl-links"><!-- Level 1 section -->
    <title>Quick Links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para><link linkend="rnfb40-ddl-objectnames">Extended Length for Object Names</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-ddl-decfloat">Data type DECFLOAT</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-ddl-longer-numerics">Increased Precision for NUMERIC and 
        DECIMAL Types</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-ddl-timezone-datatypes">Data Type Extensions for Time Zone 
        Support</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-ddl-varbinary">Aliases for Binary String Types</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb40-ddl-identity">Extensions to the IDENTITY Type</link></para>
      </listitem>
    </itemizedlist>
  </section>
  
  <section id="rnfb40-ddl-objectnames"><!-- L1 -->
    <title>Extended Length for Object Names</title>
    <author>
      <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-749">CORE-749</ulink></para>
    <para>The maximum length of objects names from this version forward is 63
    characters, up from the previous maximum of 31 bytes.</para>
    <para>Multi-byte identifiers can also be long now.  For example, the previous
    limit allowed only 15 Cyrillic characters;  now, they could be up to 63.</para>
    <note>Double quotes are not counted.</note>

    <section id="rnfb40-ddl-objectnames-restricting"><!-- L2 -->
      <title>Restricting the Length</title>
      <para>If, for some reason, you need to restrict the maximum size of object
      names, either globally or for individual databases, two new configuration
      parameters are available in <filename>firebird.conf</filename> and/or
      <filename>databases.conf</filename>: see <link linkend="rnfb40-config-max-id-lgth">Parameters
      to Restrict Length of Object Identifiers</link> in the Configuration chapter for
      further details.</para>
    </section> <!-- rnfb40-ddl-objectnames-restricting  --><!-- L2 -->
  </section> <!-- rnfb40-ddl-objectnames --><!-- L1 -->

  <section id="rnfb40-ddl-new-data-types"><!-- L1 -->
    <title>New Data Types</title>
    <para>New data types implemented in Firebired 4.0:</para>

    <section id="rnfb40-ddl-decfloat"><!-- L2 -->
      <title>Data type DECFLOAT</title>
      <author>
        <firstname>Alex</firstname><surname>Peshkov</surname>
      </author>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5525">CORE-5525</ulink></para>
      <para>DECFLOAT is an SQL:2016 standard-compliant  numeric type that stores
      floating-point numbers  precisely, unlike FLOAT or DOUBLE PRECISION that provide 
      a binary approximation of the purported precision.  Firebird 4 accords with the 
      IEEE 754-1985 standard types DECIMAL64 and DECIMAL128 by providing both 16-digit 
      and 34-digit precision for this type.</para>
      <para>All intermediate calculations are performed with 34-digit values.</para>
      <note>
        <title>16-digit and 34-digit</title>
        <para>The <quote>16</quote> and <quote>34</quote> refer to the maximum precision in Base-10
        digits.  See <ulink url="https://en/wikipedia.org/wiki/iEEE_754#Basic_and_interchange_formats">
        https://en/wikipedia.org/wiki/iEEE_754#Basic_and_interchange_formats</ulink> for a comprehensive
        table.</para>
      </note>
      <para><emphasis role="bold">Syntax Rules</emphasis></para>
      <literallayout class="monospaced">
          DECFLOAT(16)
          DECFLOAT(34)
          DECFLOAT
      </literallayout>
      <para>The default precision is 34 digits, i.e., if DECFLOAT is declared with no parameter,
      it will be defined as DECFLOAT(34). Storage complies with IEEE 754, storing data as 64 and 
      128 bits, respectively.</para>

      <para><emphasis role="bold">Examples</emphasis></para>
      <literallayout class="monospaced">
 DECLARE VARIABLE VAR1 DECFLOAT(34);
 --
 CREATE TABLE TABLE1 (FIELD1 DECFLOAT(16));
      </literallayout>
      
      <section id="rnfb40-ddl-decfloat-usage"><!-- L3 -->
        <title>Aspects of DECFLOAT Usage</title>

        <section id="rnfb40-ddl-decfloat-literals"><!-- L4 -->
          <title>Length of Literals</title>
          <para>The length of DECFLOAT literals cannot exceed 1024 characters. Scientific
          notation is required for longer values.
          For example, <command>0.0&lt;1020 zeroes&gt;11</command> cannot be used as a
          literal, the equivalent in scientific notation, <command>1.1E-1022</command> is
          valid.  Similarly, <command>10&lt;1022 zeroes&gt;0</command> can be presented
          as <command>1.0E1024</command>.</para>
        </section> <!-- rnfb40-ddl-decfloat-literals --><!-- L4 -->

        <section id="rnfb40-ddl-decfloat-stdfuncs"><!-- L4 -->
          <title>Use with Standard Functions</title>
          <para>A number of standard scalar functions can be used with expressions and 
          values of the DECFLOAT type. They are:
            <simplelist type="vert" columns="5">
              <member>ABS</member> <member>CEILING</member> <member>EXP</member>
              <member>FLOOR</member> <member>LN</member> <member>LOG</member>
              <member>LOG10</member> <member>POWER</member> <member>SIGN</member>
              <member>SQRT</member>
            </simplelist>
          </para>
          <para>The aggregate functions SUM, AVG, MAX and MIN work with DECFLOAT data, 
          as do all of the statistics aggregates (like but not limited to STDDEV or CORR).
          </para>
        </section> <!-- rnfb40-ddl-decfloat-stdfuncs --><!-- L4 -->

        <section id="rnfb40-ddl-decfloat-specialfuncs"><!-- L4 -->
          <title>Special Functions for DECFLOAT</title>
          <para>Firebird supports four functions, designed to support
          DECFLOAT data specifically:
          <itemizedlist>
            <listitem>COMPARE_DECFLOAT&mdash;compares two DECFLOAT values to
             be equal, different or unordered
            </listitem>
            <listitem>NORMALIZE_DECFLOAT&mdash;takes a single DECFLOAT argument and
                returns it in its simplest form
            </listitem>
            <listitem>QUANTIZE&mdash; takes two DECFLOAT arguments and returns the first
            argument scaled using the second value as a pattern</listitem>
            <listitem>TOTALORDER&mdash;performs an exact comparison on two DECFLOAT values
            </listitem>
          </itemizedlist>
          </para>
          <para>Detailed descriptions are in the DML chapter, in the topic
          <link linkend="rnfb40-dml-new-decfloat-funcs">Special Functions for DECFLOAT</link>.
          </para>

        </section> <!-- rnfb40-ddl-decfloat-specialfuncs --><!-- L4 -->
        
        <section id="rnfb40-ddl-decfloat-sessionctl"><!-- L4 -->
          <title>Session Control Operator SET DECFLOAT</title>
          <para>Firebird supports the session control operator SET DECFLOAT which has
          three forms, as follows:
            <itemizedlist>
              <listitem>&nbsp;SET DECFLOAT ROUND &lt;mode&gt; controls the rounding mode used in 
              operations with DECFLOAT values. Valid modes are: 
                <simplelist type="horiz" columns="2">
                  <member>CEILING</member> <member>towards +infinity</member>
                  <member>UP</member> <member>away from 0</member>
                  <member>HALF_UP</member> <member>to nearest, if equidistant, then up</member>
                  <member>HALF_EVEN</member> <member>to nearest, if equidistant, ensure last digit
                  in the result will be even</member>
                  <member>HALF_DOWN</member> <member>to nearest, if equidistant, then down</member>
                  <member>DOWN</member> <member>towards 0</member>
                  <member>FLOOR</member> <member>towards -infinity</member>
                  <member>REROUND</member> <member>up if digit to be rounded is 0 or 5, down in other cases</member>
                </simplelist>
                <para>The default rounding mode is <code>HALF-UP</code>.</para>

              </listitem>

              <listitem>SET DECFLOAT TRAPS TO &lt;comma-separated traps list which may be empty&gt;
              controls which exceptional conditions cause a trap. Valid traps are: 
                <simplelist type="horiz" columns="2">
                  <member>Division_by_zero</member> <member>(set by default)</member>
                  <member>Inexact</member> <member>---</member>
                  <member>Invalid_operation</member> <member>(set by default)</member>
                  <member>Overflow</member> <member>(set by default)</member>
                  <member>Underflow</member> <member>---</member>
                </simplelist>

              </listitem>

              <listitem>
                <para>SET DECFLOAT BIND &lt;bind-type&gt; controls how DECFLOAT values are
                represented externally, i.e. in messages or in the XSQLDA. The range of
                bindings is useful if one plans to use DECFLOAT values with some old client
                that does not support the native format. One can choose between strings
                (ideal precision, but poor support for further processing), floating point
                values (ideal support for further processing but poor precision) or scaled
                integers (good support for further processing and the required precision but
                having a very limited range of values). CHAR binding is a satisfactory choice
                for most general purpose GUI client tools.</para>
                <para>Valid binding types are:
                
                <simplelist type="horiz" columns="2">
                  <member>NATIVE</member> <member>Use IEEE754 binary representation</member>
                  <member>CHAR/CHARACTER</member> <member>Use ASCII string</member>
                  <member>DOUBLE PRECISION</member> <member>Use the same 8-byte floating-point
                  representation as is used for DOUBLE PRECISION fields</member>
                  <member>BIGINT</member> <member>As BIGINT, with optional comma-separated
                  SCALE clause, e.g., <function>BIGINT,3</function></member>
                </simplelist>
                </para>
                <note>
                  <title>Further notes</title>
                  <orderedlist>
                    <listitem>A bound ASCII string will be CHAR(23) for DECFLOAT(16) or
                    CHAR(42) for DECFLOAT(34). The lengths are simple to verify using
                    <emphasis>isql</emphasis> or some other SQL client tool.</listitem>
                    <listitem>The string representation depends on the DECFLOAT value:
                    if it is exponential and precision requirements make it possible to
                    display a value without using scientific notation, the
                    fully written out format is used;  it will be in scientific
                    notation otherwise.</listitem>
                    <listitem>Any overflow or underflow will be treated appropriately
                    according to the TRAPS setting.</listitem>
                  </orderedlist>
                </note>
              </listitem>
            </itemizedlist>
          </para>
        </section> <!-- rnfb40-ddl-decfloat-sessionctl --><!-- L4 -->
      </section> <!-- rnfb40-ddl-decfloat-usage--><!-- L3 -->
      <note>
        <para>The precision of the <code>DECFLOAT</code> column or domain is stored in
        the system table <code>RDB$FIELDS</code>, in <code>RDB$FIELD_PRECISION</code>.</para>
      </note>
    </section> <!-- rnfb40-ddl-decfloat--><!-- L2 -->
  </section><!-- L1 -->

  <section id="rnfb40-ddl-enhance"><!-- L1 -->
    <title>DDL Enhancements</title>
    <para>Enhancements have been added to the SQL data definition
    language lexicon in Firebird 4 include a new, high-precision
    floating-point data type and more extensions for the IDENTITY type.</para>

    <para>New and extended DDL statements supporting the new security features
    are described in the <link linkend="rnfb40-security">Security chapter</link>.</para>

    <section id="rnfb40-ddl-longer-numerics"><!-- BETA 1 --><!-- L2 -->
      <title>Increased Precision for NUMERIC and DECIMAL Types</title>
      <author>
        <firstname>Alex</firstname><surname>Peshkov</surname>
      </author>
      <para>Fixed decimal types NUMERIC and DECIMAL can now be defined with up
      to 34 digits precision.  Any value with precision higher than 18 digits
      will be stored as a 34-digit number.</para>
      <para><emphasis role="bold">Syntax rules</emphasis>
      <programlisting>
NUMERIC ( P [, S] )
DECIMAL ( P [, S] )
      </programlisting>
      where P is precision (P &lt;= 34, previously limited to 18 digits) and 
      the optional S is scale, as previously, i.e., the number of digits after 
      the decimal separator.</para>
      <para><emphasis role="bold">Storage</emphasis> is 128-bit, format according to
      IEEE 754.</para>

      <para><emphasis role="bold">Examples</emphasis>
      <orderedlist>
        <listitem>Declare a variable of 25 digits to behave like an integer:
          <literallayout class="monospaced">
  DECLARE VARIABLE VAR1 DECIMAL(25);
          </literallayout>
        </listitem>
        <listitem>Define a column to accommodate up to 34 digits, with 17 decimal
        places:
          <literallayout class="monospaced">
  CREATE TABLE TABLE1 (FIELD1 NUMERIC(34, 17));
          </literallayout>
        </listitem>
      </orderedlist>
      </para>
      <note>
        <para>Numerics with precision less than 19 digits use SMALLINT, INTEGER, BIGINT 
        or DOUBLE PRECISION as the base datatype, depending on the number of digits and 
        SQL dialect. When precision is between 19 and 34 digits DECFLOAT(34) is used as
        the base and the actual precision is always extended to the full 34 digits.</para>
        <para>For complex calculations, those digits are cast internally, in a trivial 
        way, to <link linkend="rnfb40-ddl-decfloat">DECFLOAT</link>(34).  The result of various mathematical
        operations, such as LOG(), EXP() and so on, and aggregate functions using a high 
        precision numeric argument, will be DECFLOAT(34).</para>
      </note>
    </section><!-- rnfb40-ddl-longer-numerics --><!-- L2 -->

    <section id="rnfb40-ddl-timezone-datatypes"><!-- Level 2 -->
      <title>Data Type Extensions for Time Zone Support</title>
      <para>The syntax for declaring the data types <code>TIMESTAMP</code> and
      <code>TIME</code> has been extended to include arguments defining whether
      the column, domain, parameter or variable should be defined with or
      without time zone adjustments, i.e.,
        <programlisting>
```
TIME [ { WITHOUT | WITH } TIME ZONE ]

TIMESTAMP [ { WITHOUT | WITH } TIME ZONE ]
```
        </programlisting>
      </para>
      <important>
        <para>For a summary of the effects of time zone support on existing
        data and application code, refer to
        <link linkend="rnfb40-compat-sql-timezone-changes">Changes in DDL and
        DML Due to Timezone Support</link> in the Compatibility chapter.</para>
      </important>

      <bridgehead renderas="sect4">Storage</bridgehead>
      <para>Data of types <code>TIME/TIMESTAMP WITH TIME ZONE</code> are stored respectively
      with the same storage as <code>TIME/TIMESTAMP WITHOUT TIME ZONE</code> plus two extra
      bytes for the time zone identifier or displacement.
        <itemizedlist>
          <listitem>The time/timestamp parts, translated from the informed time zone,
          are stored in UTC.</listitem>
          <listitem>
            <para>Time zone identifiers (from regions) are put directly in the time_zone bytes.
            They start from 65535, for the GMT code, decreasing as new time zones are added.</para>
            <para>The time zone literals, together with their time zone identifiers, are listed
            in the Appendix <link linkend="rnfb40-appx-time-zone-regions">Time Zone Regions</link>
            at the end of these release notes.</para>
          </listitem>
          <listitem><para>Time zone displacements <code>(+/- HH:MM)</code> are encoded with
          <code>(sign * (HH * 60 + MM)) + 1439</code>.</para>
          <para>For example, a <code>00:00</code> displacement is encoded as
          <code>(1 * (0 * 60 + 0)) + 1439 = 1439</code> and <code>-02:00</code> as
          <code>(-1 * (2 * 60 + 0)) + 1439 = 1319</code></para>.
          </listitem>
        </itemizedlist>
      The default for both <code>TIME</code> and <code>TIMESTAMP</code> is <code>WITHOUT 
      TIME ZONE</code>.
      </para>
      <para>See also <link linkend="rnfb40-msql-timezone-statements">Management Statements 
      Pertaining to Time Zone Support</link> in the <firstterm>Management Statements</firstterm>
       chapter.</para>
    </section>

    <section id="rnfb40-ddl-varbinary">
      <title>Aliases for Binary String Types</title>
      <author>
        <firstname>Dimitry</firstname><surname>Sibiryakov</surname>
      </author>
      <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5064">CORE-5064</ulink></para>
      <para>Data types named BINARY(n), VARBINARY(n) and BINARY VARYING(n) have been added to the
      lexicon as optional aliases for defining string columns in CHARACTER SET OCTETS.</para>
      <para>BINARY(n) is an alias for CHAR(n) CHARACTER SET OCTETS, while VARBINARY(n) and 
      BINARY VARYING(n) are aliases for VARCHAR(n) CHARACTER SET OCTETS and for each 
      other.</para>
    </section> <!-- rnfb40-ddl-varbinary -->

    <section id="rnfb40-ddl-identity">
      <title>Extensions to the IDENTITY Type</title>
      <author>
        <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
      </author>

      <para>An IDENTITY column is one that is formally associated with an
      internal sequence generator and has its value set automatically when omitted from
      an INSERT statement.</para>
      <para>The IDENTITY sub-type was introduced in Firebird 3 and has undergone a 
      number of extensions in V.4, including implementation of DROP IDENTITY, the 
      GENERATED ALWAYS and OVERRIDE directives and the INCREMENT BY option.</para>

      <section id="rnfb40-ddl-identity-syntx">
        <title>Extended Syntax for Managing IDENTITY Columns</title>
        <literallayout class="monospaced">
&lt;column definition&gt; ::=
  &lt;name> &lt;type&gt; GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( &lt;identity column option&gt;... ) ] &lt;constraints&gt;

&lt;identity column option&gt; ::=
  START WITH &lt;value&gt; |  INCREMENT [ BY ] &lt;value&gt;

&lt;alter column definition&gt; ::=
  &lt;name> &lt;set identity column generation clause&gt; [ &lt;alter identity column option&gt;... ] |
  &lt;name> &lt;alter identity column option&gt;... |
  &lt;name> DROP IDENTITY

 &lt;set identity column generation clause&gt; ::=
  SET GENERATED { ALWAYS | BY DEFAULT }

&lt;alter identity column option&gt; ::=
  RESTART [ WITH &lt;value&gt; ] | SET INCREMENT [ BY ] &lt;value&gt;
        </literallayout>

        <para><emphasis role="bold">Rules and Characteristics</emphasis></para>
        <itemizedlist>
          <listitem>The type of an identity column must be an exact number type with
          zero scale, comprising SMALLINT, INTEGER, BIGINT, NUMERIC(s,0) and
          DECIMAL(s,0).</listitem>
          <listitem>Identity columns cannot have a DEFAULT value or be defined as
          COMPUTED BY &lt;expr&gt;</listitem>
          <listitem>A regular column cannot be altered to be an identity column</listitem>
          <listitem>Identity columns cannot be defined or made non-nullable</listitem>
          <listitem>The engine does not enforce uniqueness automatically. A unique
          constraint or index of the required kind must be defined explicitly.</listitem>
          <listitem>An INCREMENT value cannot be zero</listitem>
        </itemizedlist>
      </section> <!--rnfb40-ddl-identity-syntx-->

      <section id="rnfb40-ddl-identity-fb4">
        <title>The Firebird 4 Extensions to IDENTITY</title>
        <para>The Firebird 3 implementation was minimal, effectively formalizing
        the traditional way of implementing generated keys in Firebird, without many
        options.  Firebird 4 puts some meat on those bones. </para>

        <section id="rnfb40-ddl-identity-always">
          <title>The GENERATED ALWAYS and BY DEFAULT Directives</title>
          <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5463">CORE-5463</ulink></para>
          <para>The earlier implementation behaved like the traditional
          Firebird setup for generating integer keys automatically when
          the column was omitted from the insert operation's column list.
          If the column was not listed, the IDENTITY generator would supply
          the value.</para>
          <para>A GENERATED BY clause is mandatory. The GENERATED BY DEFAULT directive,
          present in the Firebird 3 syntax, implemented this behaviour formally 
          without the alternative GENERATED ALWAYS option, :
            <programlisting>
create table objects (
  id integer generated BY DEFAULT as
     identity primary key,
  name varchar(15)
);

insert into objects (name) values ('Table');
insert into objects (name) values ('Book');
insert into objects (id, name) values (10, 'Computer');

select * from objects order by id;

commit;
            </programlisting>
            <literallayout class="monospaced">

          ID NAME
============ ===============
           1 Table
           2 Book
          10 Computer
            </literallayout>
          </para>
          <para>The GENERATED ALWAYS directive introduces alternative behaviour
          that enforces the use of the identity generator, whether or not the user 
          supplies a value.
            <note>
              <title>Overriding the defined behaviour</title>
              <para>For one-off cases this enforcement can be overridden in DML 
              by including an OVERRIDING SYSTEM VALUE clause. </para>

              <para>On the other hand, for one-off cases where you want to override
              the defined action for a column defined with the GENERATED BY DEFAULT
              directive to behave as though it were defined as GENERATED ALWAYS and
              ignore any DML-supplied value, the clause OVERRIDING USER VALUE is
              available.</para>
              <para>For more details, see
              <link linkend="rnfb40-dml-identity-overriding">OVERRIDING Clause for
              IDENTITY Columns</link> in the DML chapter.</para>
            </note>
          </para>
          <section id="rnfb40-ddl-identity-setgenerated">
            <title>Changing the Defined Behaviour</title>
            <para>The ALTER COLUMN clause of ALTER TABLE now has syntax for changing
            the default GENERATED behaviour from BY DEFAULT to ALWAYS, or vice versa:
              <programlisting>
alter table objects
  alter id
  SET GENERATED ALWAYS;
              </programlisting>
            </para>  
          </section> <!-- rnfb40-ddl-identity-setgenerated -->
        </section> <!-- rnfb40-ddl-identity-always -->

        <section id="rnfb40-ddl-identity-drop">
          <title>DROP IDENTITY Clause</title>
          <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5431">CORE-5431</ulink></para>
          <para>For a situation where you want to drop the IDENTITY property from a
          column but retain the data, the DROP IDENTITY clause is available to the
          ALTER TABLE statement:
            <programlisting>
alter table objects
  alter id
  DROP IDENTITY;
            </programlisting>
          </para>
        </section> <!--rnfb40-ddl-identity-drop-->

        <section id="rnfb40-ddl-identity-increment">
          <title>INCREMENT BY Option for IDENTITY Columns</title>
          <para>Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-5430">CORE-5430</ulink></para>
          <para>By default, identity columns start at 1 and increment by 1.  The INCREMENT BY
          option can now be used to set the increment for some positive step, i.e., 1 or more:
            <programlisting>
create table objects (
  id integer generated BY DEFAULT as
     identity (START WITH 10000 INCREMENT BY 10)
     primary key,
  name varchar(15)
);
            </programlisting>
          </para>
          <section id="rnfb40-ddl-identity-setincrement">
            <title>Changing the Increment (Step) Value</title>
            <para>For changing the step value of the sequence produced by an
            IDENTITY generator, the SET INCREMENT clause is available in the
            latest ALTER TABLE statement syntax:
              <programlisting>
alter table objects
  alter id SET INCREMENT BY 5;
              </programlisting>
            </para>
            <note>
              <orderedlist spacing="compact">
                <listitem>Changing the step value does not affect existing data.
                </listitem>
                <listitem>It is not necessary to specify SET INCREMENT BY 1 for a new column, 
                nor for one that has not been altered previously, as the default step is 1.</listitem>
              </orderedlist>
            </note>
          </section> <!--rnfb40-ddl-identity-setincrement-->
        </section> <!--rnfb40-ddl-identity-increment-->

      </section> <!-- rnfb40-ddl-identity-fb4 -->
      <section id="rnfb40-ddl-identity-impl">
        <title>Implementation</title>
        <para>Two columns have been inserted in RDB$RELATION_FIELDS: RDB$GENERATOR_NAME and
        RDB$IDENTITY_TYPE.  RDB$GENERATOR_NAME stores the automatically created generator
        for the column.</para>
        <para>In RDB$GENERATORS, the value of RDB$SYSTEM_FLAG of that generator will be 6.
        RDB$IDENTITY_TYPE stores the value 0 for GENERATED ALWAYS, 1 for GENERATED BY DEFAULT,
        and NULL for non-identity columns.</para>
      </section> <!-- rnfb40-ddl-identity-impl -->
    </section> <!-- rnfb40-ddl-identity-->
  </section><!-- L1 -->

</chapter>
