  <chapter id="rnfbtwo-dml">
  <chapterinfo>
    <title>Data Manipulation Language (DML)</title>
  </chapterinfo>
    <section id="dml-dsql" xreflabel="Data Manipulation Language (DML)"><!-- Level 1 section -->
    <title>New and Extended DSQL Syntaxes</title>
    <para>In this section are details of DML language statements or constructs that have been added to the DSQL
    language set in Firebird 2.0.</para>
    
<!-- 2007-06-14 Note to translators:  in line 740 the header of the CREATE TRIGGER 
     statement is changed as follows:
CREATE TRIGGER UI_JOURNAL FOR JOURNAL AFTER INSERT OR UPDATE
     becomes
CREATE TRIGGER UI_JOURNAL FOR JOURNAL BEFORE INSERT OR UPDATE
                                      ^^^^^^
-->
      <section id="dml-dsql-execute-block"><!-- Level 2 section -->
      <sectioninfo>
        <title>EXECUTE BLOCK Statement</title>
        <author><firstname>V.</firstname><surname>Horsun</surname></author>
      </sectioninfo>
      <para>The SQL language extension EXECUTE BLOCK makes &quot;dynamic PSQL&quot; available to SELECT specifications. It
 has the effect of allowing a self-contained block of PSQL code to be executed in dynamic SQL as if it were a stored
 procedure.</para>

      <para><emphasis role="bold">Syntax pattern</emphasis></para>
      <programlisting>
   EXECUTE BLOCK [ (param datatype = ?, param datatype = ?, ...) ]
     [ RETURNS (param datatype, param datatype, ...) ]
   AS
   [DECLARE VARIABLE var datatype; ...]
   BEGIN
     ...
   END
      </programlisting>

      <para>For the client, the call <function>isc_dsql_sql_info</function> with the parameter
      <function>isc_info_sql_stmt_type</function> returns</para>

      <itemizedlist>
      <listitem><para><function>isc_info_sql_stmt_select</function> if the block has output parameters.
      The semantics of a call is similar to a SELECT query:  the client has a cursor open, can fetch data from it,
      and must close it after use.</para></listitem>
      <listitem><para><function>isc_info_sql_stmt_exec_procedure</function> if the block has no output parameters.
      The semantics of a call is similar to an EXECUTE query: the client has no cursor and execution continues until
      it reaches the end of the block or is terminated by a SUSPEND.</para></listitem>
      </itemizedlist>

      <para>The client should preprocess only the head of the SQL statement or use '?' instead of ':' as the parameter
      indicator because, in the body of the block, there may be references to local variables or arguments with a colon
      prefixed.</para>

      <para><emphasis role="bold">Example</emphasis></para>

      <para>The user SQL is</para>
      <programlisting>
   EXECUTE BLOCK (X INTEGER = :X)
     RETURNS (Y VARCHAR)
   AS
   DECLARE V INTEGER;
   BEGIN
     INSERT INTO T(...) VALUES (... :X ...);
     SELECT ... FROM T INTO :Y;
     SUSPEND;
   END
      </programlisting>

      <para>The preprocessed SQL is</para>
      <programlisting>
   EXECUTE BLOCK (X INTEGER = ?)
     RETURNS (Y VARCHAR)
   AS
   DECLARE V INTEGER;
   BEGIN
     INSERT INTO T(...) VALUES (... :X ...);
     SELECT ... FROM T INTO :Y;
     SUSPEND;
   END
      </programlisting>
      </section>

      <section id="dml-dsql-derived-tables" xreflabel="Derived Tables"><!-- Level 2 section -->
      <sectioninfo>
        <title>Derived Tables</title>
        <author><firstname>A.</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Implemented support for derived tables in DSQL (subqueries in FROM clause) as defined by SQL200X.  A derived
 table is a set, derived from a dynamic SELECT statement.  Derived tables can be nested, if required, to build complex
 queries and they can be involved in joins as though they were normal tables or views.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
    SELECT
      &lt;select list&gt;
    FROM
      &lt;table reference list&gt;

    &lt;table reference list&gt; ::= &lt;table reference&gt; [{&lt;comma&gt; &lt;table reference&gt;}...]

    &lt;table reference&gt; ::=
        &lt;table primary&gt;
      | &lt;joined table&gt;

    &lt;table primary&gt; ::=
        &lt;table&gt; [[AS] &lt;correlation name&gt;]
      | &lt;derived table&gt;

    &lt;derived table> ::=
        &lt;query expression&gt; [[AS] &lt;correlation name&gt;]
          [&lt;left paren&gt; &lt;derived column list&gt; &lt;right paren&gt;]

    &lt;derived column list&gt; ::= &lt;column name&gt; [{&lt;comma&gt; &lt;column name&gt;}...]
      </programlisting>
      <para><emphasis role="bold">Examples</emphasis></para>
      <para>a) Simple derived table:</para>
      <programlisting>
  SELECT
    *
  FROM
    (SELECT
       RDB$RELATION_NAME, RDB$RELATION_ID
     FROM
       RDB$RELATIONS) AS R (RELATION_NAME, RELATION_ID)
      </programlisting>

      <para>b) Aggregate on a derived table which also contains an aggregate</para>
      <programlisting>
  SELECT
    DT.FIELDS,
    Count(*)
  FROM
    (SELECT
       R.RDB$RELATION_NAME,
       Count(*)
     FROM
       RDB$RELATIONS R
       JOIN RDB$RELATION_FIELDS RF ON (RF.RDB$RELATION_NAME = R.RDB$RELATION_NAME)
     GROUP BY
       R.RDB$RELATION_NAME) AS DT (RELATION_NAME, FIELDS)
  GROUP BY
    DT.FIELDS
      </programlisting>

      <para>c) UNION and ORDER BY example:</para>
      <programlisting>
  SELECT
    DT.*
  FROM
    (SELECT
       R.RDB$RELATION_NAME,
       R.RDB$RELATION_ID
     FROM
       RDB$RELATIONS R
     UNION ALL
     SELECT
       R.RDB$OWNER_NAME,
       R.RDB$RELATION_ID
     FROM
       RDB$RELATIONS R
     ORDER BY
       2) AS DT
  WHERE
    DT.RDB$RELATION_ID &lt;= 4
      </programlisting>
      <para><emphasis role="bold">Points to Note</emphasis></para>
      <itemizedlist>
        <listitem><para>Every column in the derived table must have a name. Unnamed expressions like
    constants should be added with an alias or the column list should be used.</para></listitem>
        <listitem><para>The number of columns in the column list should be the same as the number of
    columns from the query expression.</para></listitem>
        <listitem><para>The optimizer can handle a derived table very efficiently.  However, if the
    derived table is involved in an inner join and contains a subquery, then no join order can be made.</para></listitem>
      </itemizedlist>
      </section><!-- level 2 -->

      <section id="dml-rb-retain" xreflabel="ROLLBACK RETAIN Syntax"><!-- Level 2 section -->
      <sectioninfo>
        <title>ROLLBACK RETAIN Syntax</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>The ROLLBACK RETAIN statement is now supported in DSQL.</para>
      <para>A <quote>rollback retaining</quote> feature was introduced in InterBase 6.0, but this rollback mode
      could be used only via an API call to <firstterm>isc_rollback_retaining()</firstterm>.  By contrast,
      <quote>commit retaining</quote> could be used either via an API call to
      <firstterm>isc_commit_retaining()</firstterm> or by using a DSQL <literal>COMMIT RETAIN</literal> 
      statement.</para>

      <para>Firebird 2.0 adds an optional <literal>RETAIN</literal> clause to the DSQL <literal>ROLLBACK</literal>
      statement to make it consistent with COMMIT [RETAIN].</para>
      <para><emphasis>Syntax pattern</emphasis>: follows that of COMMIT RETAIN.</para>
      </section>

      <section id="dml-dsql-rows"><!-- Level 2 section -->
      <sectioninfo>
        <title>ROWS Syntax</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>ROWS syntax is used to limit the number of rows retrieved from a select expression. For an uppermost-level
    select statement, it would specify the number of rows to be returned to the host program.  A more
    understandable alternative to the FIRST/SKIP clauses, the ROWS syntax accords with the latest SQL standard and
    brings some extra benefits. It can be used in unions, any kind of subquery and in UPDATE or DELETE statements.</para>

      <para>It is available in both DSQL and PSQL.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
   SELECT ...
     [ORDER BY &lt;expr_list&gt;]
     ROWS &lt;expr1&gt; [TO &lt;expr2&gt;]
      </programlisting>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para>1.</para>
      <programlisting>
  SELECT * FROM T1
    UNION ALL
  SELECT * FROM T2
    ORDER BY COL
    ROWS 10 TO 100
      </programlisting>
      <para>2.</para>
      <programlisting>
   SELECT COL1, COL2,
     ( SELECT COL3 FROM T3 ORDER BY COL4 DESC ROWS 1 )
   FROM T4
      </programlisting>

      <para>3.</para>
      <programlisting>
   DELETE FROM T5
     ORDER BY COL5
     ROWS 1
      </programlisting>

      <para><emphasis role="bold">Points to Note</emphasis></para>

      <orderedlist>
      <listitem><para>When &lt;expr2&gt; is omitted, then ROWS &lt;expr1&gt; is semantically equivalent to 
      FIRST &lt;expr1&gt;. When both &lt;expr1&gt; and &lt;expr2&gt; are used, then &nbsp; &nbsp;ROWS &lt;expr1&gt; 
      TO &lt;expr2&gt; means the same as &nbsp; &nbsp;FIRST (&lt;expr2&gt; - &lt;expr1&gt; + 1) 
      SKIP (&lt;expr1&gt; - 1)</para></listitem>
      <listitem><para>There is nothing that is semantically equivalent to a SKIP clause used without a
      FIRST clause.</para></listitem>
      </orderedlist>
      </section>

      <section id="dml-dsql-union"><!-- Level 2 section -->
      <title>Enhancements to UNION Handling</title>
      <para>The rules for UNION queries have been improved as follows:</para>

        <section id="dml-dsql-union-distinct"><!-- Level 3 section -->
        <sectioninfo>
          <title>UNION DISTINCT Keyword Implementation</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <para>UNION DISTINCT is now allowed as a synonym for simple UNION, in accordance with the SQL-99
        specification. It is a minor change: DISTINCT is the default mode, according to the standard.  Formerly,
        Firebird did not support the explicit inclusion of the optional keyword DISTINCT.</para>
        <para><emphasis>Syntax Pattern</emphasis></para>
        <programlisting>
  UNION [{DISTINCT | ALL}]
        </programlisting>
        </section>

        <section id="dml-dsql-union-coercion"><!-- Level 3 section -->
        <sectioninfo>
          <title>Improved Type Coercion in UNIONs</title>
          <author><firstname>A.</firstname><surname>Brinkman</surname></author>
        </sectioninfo>
        <para>Automatic type coercion logic between subsets of a union is now more intelligent.
    Resolution of the data type of the result of an aggregation over values of
    compatible data types, such as case expressions and columns at the same 
    position in a union query expression, now uses smarter rules.</para>

        <para><emphasis role="bold">Syntax Rules</emphasis></para>

        <para>Let DTS be the set of data types over which we must determine the final
   result data type.</para>
        <orderedlist>
        <listitem><para>All of the data types in DTS shall be comparable.</para></listitem>

        <listitem><para>Case:</para>

          <orderedlist type="a">
          <listitem><para>If any of the data types in DTS is character string, then:</para>
            <orderedlist type="i">
            <listitem><para>If any of the data types in DTS is variable-length character string, then the result
            data type is variable-length character string with maximum length in characters equal to the largest
            maximum amongst the data types in DTS.</para></listitem>
            <listitem><para>Otherwise, the result data type is fixed-length character string with length in characters
            equal to the maximum of the lengths in characters of the data types in DTS.</para></listitem>
            <listitem><para>The characterset/collation is used from the first character string data type
            in DTS.</para></listitem>
            </orderedlist>
          </listitem>
          <listitem><para>If all of the data types in DTS are exact numeric, then the result data type is exact 
          numeric with scale equal to the maximum of the scales of the data types in DTS and the maximum precision of 
          all data types in DTS.</para>

          <note>
          <para>NOTE :: Checking for precision overflows is done at run-time only.
          The developer should take measures to avoid the aggregation resolving to a precision overflow.</para>
          </note>
          </listitem>

          <listitem><para>If any data type in DTS is approximate numeric, then each data type in DTS shall be numeric
          else an error is thrown.</para></listitem>

          <listitem><para>If some data type in DTS is a date/time data type, then every data type in DTS shall be a
          date/time data type having the same date/time type.</para></listitem>

          <listitem><para>If any data type in DTS is BLOB, then each data type in DTS shall be BLOB and all with the
          same sub-type.</para></listitem>
          </orderedlist>
        </listitem>
        </orderedlist>
        </section>

        <section id="dml-dsql-union-subqueries"><!-- Level 3 section -->
        <sectioninfo>
          <title>UNIONs Allowed in ANY/ALL/IN Subqueries</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
          <para>The subquery element of an ANY, ALL or IN search may now be a UNION query.</para>
        </section>
      </section>
      
      <section id="dml-dsql-iif"><!-- Level 2 section -->
      <sectioninfo>
        <title>IIF Expression Syntax Added</title>
        <author><firstname>O.</firstname><surname>Loa</surname></author>
      </sectioninfo>
      <programlisting>
   IIF (&lt;search_condition&gt;, &lt;value1&gt;, &lt;value2&gt;)
      </programlisting>
      <para>is implemented as a shortcut for</para>
      <programlisting>
   CASE
     WHEN &lt;search_condition&gt; THEN &lt;value1&gt;
     ELSE &lt;value2&gt;
   END
      </programlisting>

      <para>It returns the value of the first sub-expression if the given search condition
    evaluates to TRUE, otherwise it returns a value of the second sub-expression.</para>

      <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
    SELECT IIF(VAL &gt; 0, VAL, -VAL) FROM OPERATION
      </programlisting>
      </section>
      
      <section id="dml-dsql-cast"><!-- Level 2 section -->
      <sectioninfo>
        <title>CAST() Behaviour Improved</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>The infamous <quote>Datatype unknown</quote> error (SF Bug #1371274) when attempting some castings has
      been eliminated.  It is now possible to use CAST to advise the engine about the data type of a parameter.</para>
      
      <para><emphasis>Example</emphasis></para>
      <programlisting>
  SELECT CAST(? AS INT) FROM RDB$DATABASE
      </programlisting>
      </section>

      <section id="dml-dsql-substring"><!-- Level 2 section -->
      <sectioninfo>
        <title>Built-in Function SUBSTRING() Enhanced</title>
        <author><firstname>O.</firstname><surname>Loa, D. Yemanov</surname></author>
      </sectioninfo>
      <para>The built-in function SUBSTRING() can now take arbitrary expressions in its parameters.</para>

      <para>Formerly, the inbuilt SUBSTRING() function accepted only constants as its second and third arguments 
      (start position and length, respectively). Now, the arguments can be anything that resolves to a value, 
      including host parameters, function results, expressions, subqueries, etc.</para>
      <note>
        <para>The length of the resulting column is the same as the length of the first argument. This means that, 
        in the following</para>
        <programlisting>
x = varchar(50);
substring(x from 1 for 1);
        </programlisting>
        <para>the new column has a length of 50, not 1. (Thank the SQL standards committee!)</para>
      </note>
      </section>

      <section id="dml-dsql-nulls"><!-- Level 2 section -->
      <title>Enhancements to NULL Logic</title>
      <para>The following features involving NULL in DSQL have been implemented:</para>

        <section id="dml-dsql-nulls-distinct"><!-- Level 3 section -->
        <sectioninfo>
        <!-- Altered in 2.0.1 -->
          <title>New [NOT] DISTINCT Test Treats Two NULL Operands as Equal</title>
          <author><firstname>O.</firstname><surname>Loa, D. Yemanov</surname></author>
        </sectioninfo>
        <para>A new equivalence predicate behaves exactly like the equality/inequality predicates,
        but, instead of testing for equality, it tests whether one operand is distinct from the other.</para>
        <para> Thus, IS NOT DISTINCT treats (NULL equals NULL) as if it were true, since one NULL 
        (or expression resolving to NULL) is not distinct from another.  It is available in both 
        DSQL and PSQL.</para>
<!-- End of change in 2.0.1 -->
        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
   &lt;value&gt; IS [NOT] DISTINCT FROM &lt;value&gt;
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>

        <para>1.</para>
        <programlisting>
   SELECT * FROM T1
     JOIN T2
       ON T1.NAME IS NOT DISTINCT FROM T2.NAME;
        </programlisting>

        <para>2.</para>
        <programlisting>
   SELECT * FROM T
     WHERE T.MARK IS DISTINCT FROM 'test';
        </programlisting>

        <note>
        <para><emphasis role="bold">Points to note</emphasis></para>

        <orderedlist>
        <listitem><para>Because the DISTINCT predicate considers that two NULL values are not distinct, it never 
        evaluates to the truth value UNKNOWN.  Like the IS [NOT] NULL predicate, it can only be True or False.</para>
        </listitem>
        <listitem><para>The NOT DISTINCT predicate can be optimized using an index, if one is available.</para>
        </listitem>
        </orderedlist>
        </note>
        </section>

        <section id="dml-dsql-nulls-equivalence"><!-- Level 3 section -->
        <sectioninfo>
          <title>NULL Comparison Rule Relaxed</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <para>A NULL literal can now be treated as a value in all expressions without returning a syntax error. You
        may now specify expressions such as</para>
        <programlisting>
  A = NULL
  B &gt; NULL
  A + NULL
  B || NULL
        </programlisting>
        <note>
        <para>All such expressions evaluate to NULL.  The change does not alter nullability-aware semantics of the
        engine, it simply relaxes the syntax restrictions a little.</para>
        </note>
        </section>

        <section id="dml-dsql-nulls-ordering"><!-- Level 3 section -->
        <sectioninfo>
          <title>NULLs Ordering Changed to Comply with Standard</title>
          <author><firstname>N.</firstname><surname>Samofatov</surname></author>
        </sectioninfo>
        <para>Placement of nulls in an ordered set has been changed to accord with the SQL standard that null ordering
        be consistent, i.e. if ASC[ENDING] order puts them at the bottom, then DESC[ENDING] puts them at the top;
        or vice-versa. This applies only to databases created under the new on-disk structure, since it needs to use
        the index changes in order to work.</para>
<!-- inserted in 2.0.1 -->
        <important>
          <para>If you override the default nulls placement, no index can be used for sorting.  That is, no index 
          will be used for an ASCENDING sort if NULLS LAST is specified, nor for a DESCENDING sort if NULLS FIRST 
          is specified.</para>
        </important>
<!-- -->
        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  Database:  proc.fdb
  SQL&gt; create table gnull(a int);
  SQL&gt; insert into gnull values(null);
  SQL&gt; insert into gnull values(1);
  SQL&gt; select a from gnull order by a;
             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a asc;

             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a desc;

             A
  ============
             1
        &lt;null&gt;

  SQL&gt; select a from gnull order by a asc nulls first;

             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a asc nulls last;

             A
  ============
             1
        &lt;null&gt;


  SQL&gt; select a from gnull order by a desc nulls last;

             A
  ============
             1
        &lt;null&gt;

  SQL&gt; select a from gnull order by a desc nulls first;

             A
  ============
        &lt;null&gt;
             1
        </programlisting>
        </section>
      </section>

      <section id="dml-dsql-cross-join"><!-- Level 2 section -->
      <sectioninfo>
        <title>CROSS JOIN is Now Supported</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>CROSS JOIN is now supported. Logically, this syntax pattern:</para>
      <programlisting>
   A CROSS JOIN B
      </programlisting>
      <para>is equivalent to either of the following:</para>
      <programlisting>
   A INNER JOIN B ON 1 = 1
      </programlisting>
      <para>or, simply:</para>
      <programlisting>
  FROM A, B
      </programlisting>
       <section id="dml-dsql-cross-join-imprv"><!-- Level 3 section -->
         <title>Performance Improvement at V.2.0.6</title>
         <para><emphasis role="bold">(V.2.0.6)</emphasis> In the rare case where a cross join of 
         three or more tables involved table[s] that contained no records, extremely slow performance 
         was reported <ulink url="http://tracker.firebirdsql.org/browse/CORE-2200">
         <emphasis>(CORE-2200)</emphasis></ulink>.  A performance improvement was gained by teaching 
         the optimizer not to waste time and effort on walking through populated tables in an attempt 
         to find matches in empty tables. (Backported from V.2.1.2)</para>
        </section>
      </section>
      <section id="dml-dsql-complex-dml"><!-- Level 2 section -->
      <sectioninfo>
        <title>Subqueries and INSERT Statements Can Now Accept UNION Sets</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>SELECT specifications used in subqueries and in INSERT INTO &lt;insert-specification&gt; 
      SELECT.. statements can now specify a UNION set.</para>
      </section>

      <section id="dml-dsql-extensions"><!-- Level 2 section -->
      <sectioninfo>
        <title>New Extensions to UPDATE and DELETE Syntaxes</title>
        <author><firstname>O.</firstname><surname>Loa</surname></author>
      </sectioninfo>
      <para>ROWS specifications and PLAN and ORDER BY clauses can now be used in UPDATE and DELETE statements.</para>

      <para>Users can now specify explicit plans for UPDATE/DELETE statements in order to optimize them manually. 
      It is also possible to limit the number of affected rows with a ROWS clause, optionally used in combination 
      with an ORDER BY clause to have a sorted recordset.</para>
      
      <para><emphasis>Syntax Pattern</emphasis></para>
      <programlisting>
  UPDATE ... SET ... WHERE ...
  [PLAN &lt;plan items&gt;]
  [ORDER BY &lt;value list&gt;]
  [ROWS &lt;value&gt; [TO &lt;value&gt;]]
      </programlisting>

      <para>or</para>

      <programlisting>
  DELETE ... FROM ...
  [PLAN &lt;plan items&gt;]
  [ORDER BY &lt;value list&gt;]
  [ROWS &lt;value&gt; [TO &lt;value&gt;]]
      </programlisting>

      </section>

      <section id="dml-dsql-context"><!-- Level 2 section -->
      <title>New Context Variables</title>
      <para>A number of new facilities have been added to extend the context information that can be 
      retrieved:</para>

        <section id="dml-dsql-context-subsecond"><!-- Level 3 section -->
        <sectioninfo>
          <title>Sub-second Values Enabled for Time and DateTime Variables</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
          <section id="dml-dsql-context-subsecond-milli"><!-- Level 4 section -->
          <title>CURRENT_TIMESTAMP, 'NOW' Now Return Milliseconds</title>
          <para>The context variable CURRENT_TIMESTAMP and the date/time literal 'NOW' will now return the sub-second
        time part in milliseconds.</para>
          </section><!-- 4 -->
          <section id="dml-dsql-context-subsecond-other"><!-- Level 4 section -->
          <title>Seconds Precision Enabled for CURRENT_TIME and CURRENT_TIMESTAMP</title>
          <para>CURRENT_TIME and CURRENT_TIMESTAMP now optionally allow seconds precision</para>

          <para>The feature is available in both DSQL and PSQL.</para>
          <para><emphasis role="bold">Syntax Pattern</emphasis></para>
          <programlisting>
    CURRENT_TIME [(&lt;seconds precision&gt;)]
    CURRENT_TIMESTAMP [(&lt;seconds precision&gt;)]
          </programlisting>

          <para><emphasis role="bold">Examples</emphasis></para>
          <programlisting>
    1. SELECT CURRENT_TIME FROM RDB$DATABASE;
    2. SELECT CURRENT_TIME(3) FROM RDB$DATABASE;
    3. SELECT CURRENT_TIMESTAMP(3) FROM RDB$DATABASE;
          </programlisting>

          <note>
          <orderedlist>
          <listitem><para>The maximum possible precision is 3 which means accuracy of 1/1000 second
       (one millisecond). This accuracy may be improved in the future versions.</para></listitem>
          <listitem><para>If no seconds precision is specified, the following values are implicit:</para>
            <itemizedlist>
            <listitem><para>0 for CURRENT_TIME</para></listitem>
            <listitem><para>3 for CURRENT_TIMESTAMP</para></listitem>
            </itemizedlist>
          </listitem>
          </orderedlist>
          </note>
          </section><!-- 4 -->
        </section><!-- 3 -->

        <section id="dml-dsql-context-ns"><!-- Level 3 section -->
        <sectioninfo>
          <title>New System Functions to Retrieve Context Variables</title>
          <author><firstname>N.</firstname><surname>Samofatov</surname></author>
        </sectioninfo>
        <para>Values of context variables can now be obtained using the system functions RDB$GET_CONTEXT and
        RDB$SET_CONTEXT. These new built-in functions give access through SQL to some information about the current
    connection and current transaction. They also provide a mechanism to retrieve user context data and associate it
    with the transaction or connection.</para>

       <para><emphasis role="bold">Syntax Pattern</emphasis></para>
       <programlisting>
    RDB$SET_CONTEXT( &lt;namespace&gt;, &lt;variable&gt;, &lt;value&gt; )
    RDB$GET_CONTEXT( &lt;namespace&gt;, &lt;variable&gt; )
       </programlisting>

       <para>These functions are really a form of external function that exists inside the database intead of being 
       called from a dynamically loaded library.  The following declarations are made automatically by the engine at
       database creation time:</para>

       <para><emphasis role="bold">Declaration</emphasis></para>

       <programlisting>
  DECLARE EXTERNAL FUNCTION RDB$GET_CONTEXT
      VARCHAR(80),
      VARCHAR(80)
  RETURNS VARCHAR(255) FREE_IT;

  DECLARE EXTERNAL FUNCTION RDB$SET_CONTEXT
      VARCHAR(80),
      VARCHAR(80),
      VARCHAR(255)
  RETURNS INTEGER BY VALUE;
       </programlisting>

       <para><emphasis role="bold">Usage</emphasis></para>

       <para>RDB$SET_CONTEXT and RDB$GET_CONTEXT set and retrieve the current value of a context variable. Groups of
       context variables with similar properties are identified by Namespace identifiers. The namespace determines the 
       usage rules, such as whether the variables may be read and written to, and by whom.</para>
       <note>
       <para>Namespace and variable names are case-sensitive.</para>
       </note>

       <itemizedlist>
       <listitem><para>RDB$GET_CONTEXT retrieves current value of a variable. If the variable does not exist
       in namespace, the function returns NULL.</para></listitem>
       <listitem><para>RDB$SET_CONTEXT sets a value for specific variable, if it is writable. The function returns a
       value of   1 if the variable existed before the call and 0 otherwise.</para></listitem>
       <listitem><para>To delete a variable from a context, set its value to NULL.</para></listitem>
       </itemizedlist>
         <section id="dml-dsql-context-ns-pd"><!-- Level 4 section -->
          <title>Pre-defined Namespaces</title>
          <para>A fixed number of pre-defined namespaces is available:</para>
            <section id="dml-dsql-context-ns-pd-user-session"><!-- Level 5 section -->
            <title>USER_SESSION</title>
            <para>Offers access to session-specific user-defined variables. You can define and set values for variables
            with any name in this context.</para>
            </section>
            <section id="dml-dsql-context-ns-pd-user-transaction"><!-- Level 5 section -->
            <title>USER_TRANSACTION</title>
            <para>Offers similar possibilities for individual transactions.</para>
            </section>
            <section id="dml-dsql-context-ns-pd-system"><!-- Level 5 section -->
            <title>SYSTEM</title>
            <para>Provides read-only access to the following variables:</para>
            <itemizedlist>
            <listitem>
              <para>NETWORK_PROTOCOL :: The network protocol used by client to connect. Currently used
              values: <quote>TCPv4</quote>, <quote>WNET</quote>, <quote>XNET</quote> and NULL.</para>
            </listitem>
            <listitem><para>CLIENT_ADDRESS :: The wire protocol address of the remote client, represented as a string.
            The value is an IP address in form &quot;xxx.xxx.xxx.xxx&quot; for TCPv4 protocol;  the local process ID
            for XNET protocol;  and NULL for any other protocol.</para></listitem>
            <listitem><para>DB_NAME :: Canonical name of the current database. It is either the alias name (if
            connection via file names is disallowed DatabaseAccess = NONE) or, otherwise, the fully expanded database
            file name.</para></listitem>
            <listitem><para>ISOLATION_LEVEL :: The isolation level of the current transaction. The returned value will
            be one of &quot;READ COMMITTED&quot;, &quot;SNAPSHOT&quot;, &quot;CONSISTENCY&quot;.</para></listitem>
            <listitem><para>TRANSACTION_ID :: The numeric ID of the current transaction. The returned value is the same
            as would be returned by the CURRENT_TRANSACTION pseudo-variable.</para></listitem>
            <listitem><para>SESSION_ID :: The numeric ID of the current session. The returned value is the same as
            would be returned by the CURRENT_CONNECTION pseudo-variable.</para></listitem>
            <listitem><para>CURRENT_USER :: The current user. The returned value is the same as would be returned by
            the CURRENT_USER pseudo-variable or the predefined variable USER.</para></listitem>
            <listitem><para>CURRENT_ROLE :: Current role for the connection. Returns the same value as the CURRENT_ROLE
            pseudo-variable.</para></listitem>
            </itemizedlist>
            </section>
          </section>
          <section id="dml-dsql-context-ns-notes"><!-- Level 4 section -->
          <title>Notes</title>
          <para>To avoid DoS attacks against the Firebird Server, the number of variables stored for each transaction
          or session context is limited to 1000.</para>

          <para><emphasis role="bold">Example of Use</emphasis></para>
          <programlisting>
   set term ^;
   create procedure set_context(User_ID varchar(40), Trn_ID integer) as
   begin
     RDB$SET_CONTEXT('USER_TRANSACTION', 'Trn_ID', Trn_ID);
     RDB$SET_CONTEXT('USER_TRANSACTION', 'User_ID', User_ID);
   end ^

  create table journal (
     jrn_id integer not null primary key,
     jrn_lastuser varchar(40),
     jrn_lastaddr varchar(255),
     jrn_lasttransaction integer
  )^

CREATE TRIGGER UI_JOURNAL FOR JOURNAL BEFORE INSERT OR UPDATE
  as
  begin
    new.jrn_lastuser = rdb$get_context('USER_TRANSACTION', 'User_ID');
    new.jrn_lastaddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');
    new.jrn_lasttransaction = rdb$get_context('USER_TRANSACTION', 'Trn_ID');
  end ^
  commit ^
  execute procedure set_context('skidder', 1) ^

  insert into journal(jrn_id) values(0) ^
  set term ;^
          </programlisting>

          <para>Since rdb$set_context returns 1 or zero, it can be made to work with a simple SELECT
          statement.</para>
          <para><emphasis role="bold">Example</emphasis></para>
          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', 'ru') 
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                0
          </programlisting>

<para>0 means not defined already; we have set it to 'ru' </para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', 'ca')
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                1
          </programlisting>

<para>1 means it was defined already; we have changed it to 'ca' </para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', NULL)
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                1
          </programlisting>

<para>1 says it existed before;  we have changed it to NULL, i.e. undefined it.</para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', NULL)
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                0
          </programlisting>

<para>0, since nothing actually happened this time: it was already undefined .</para>
          </section><!-- 4 -->
        </section><!-- 3 -->
      </section><!-- 2 -->

      <section id="dml-dsql-plans" xreflabel="Query Plans"><!-- Level 2 section -->
      <sectioninfo>
        <title>Improvements in Handling User-specified Query Plans</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <orderedlist>
      <listitem><para>Plan fragments are propagated to nested levels of joins, enabling manual optimization of complex
      outer joins</para></listitem>
      <listitem><para>A user-supplied plan will be checked for correctness in outer joins</para></listitem>
      <listitem><para>Short-circuit optimization for user-supplied plans has been added</para></listitem>
      <listitem><para>A user-specified access path can be supplied for any SELECT-based statement or clause</para></listitem>
      </orderedlist>
      <para><emphasis role="bold">Syntax rules</emphasis></para>

      <para>The following schema describing the syntax rules should be helpful when composing plans.</para>

      <programlisting>
PLAN ( { &lt;stream_retrieval&gt; | &lt;sorted_streams&gt; | &lt;joined_streams&gt; } )

&lt;stream_retrieval&gt; ::= { &lt;natural_scan&gt; | &lt;indexed_retrieval&gt; | 
    &lt;navigational_scan&gt; }

&lt;natural_scan&gt; ::= &lt;stream_alias&gt; NATURAL

&lt;indexed_retrieval&gt; ::= &lt;stream_alias&gt; INDEX ( &lt;index_name&gt; 
    [, &lt;index_name&gt; ...] )

&lt;navigational_scan&gt; ::= &lt;stream_alias&gt; ORDER &lt;index_name&gt;
    [ INDEX ( &lt;index_name&gt; [, &lt;index_name&gt; ...] ) ]

&lt;sorted_streams&gt; ::= SORT ( &lt;stream_retrieval&gt; )

&lt;joined_streams&gt; ::= JOIN ( &lt;stream_retrieval&gt;, &lt;stream_retrieval&gt; 
    [, &lt;stream_retrieval&gt; ...] ) 
    | [SORT] MERGE ( &lt;sorted_streams&gt;, &lt;sorted_streams&gt; )
      </programlisting>

      <para><emphasis role="bold">Details</emphasis></para>

      <para><emphasis>Natural scan</emphasis> means that all rows are fetched in their natural storage order.  Thus,
      all pages must be read before search criteria are validated.</para>
      <para><emphasis>Indexed retrieval</emphasis> uses an index range scan to find row ids that match the given
    search criteria. The found matches are combined in a sparse bitmap which is sorted
    by page numbers, so every data page will be read only once. After that the table
    pages are read and required rows are fetched from them.</para>

      <para><emphasis>Navigational scan</emphasis> uses an index to return rows in the given order, if such an
    operation is appropriate.-</para>

      <itemizedlist>
      <listitem><para>The index b-tree is walked from the leftmost node to the rightmost one.</para></listitem>
      <listitem><para>If any search criterion is used on a column specified in an ORDER BY clause, the
    navigation is limited to some subtree path, depending on a predicate.</para></listitem>
      <listitem><para>If any search criterion is used on other columns which are indexed, then a range index scan is performed
    in advance and every fetched key has its row id validated against the resulting bitmap.
    Then a data page is read and the required row is fetched.</para></listitem>
      </itemizedlist>
      <note>
      <para>Note that a navigational scan incurs random page I/O, as reads are not optimized.</para>
      </note>

      <para>A <emphasis>sort operation</emphasis> performs an external sort of the given stream retrieval.</para>
      <para>A <emphasis>join</emphasis> can be performed either via the nested loops algorithm (JOIN plan) or via
    the sort merge algorithm (MERGE plan).-</para>

      <itemizedlist>
      <listitem><para>An <emphasis>inner nested loop join</emphasis> may contain as many streams as are required to be joined.
    All of them are equivalent.</para></listitem>
      <listitem><para>An <emphasis>outer nested loops join</emphasis> always operates with two streams, so you'll see
    nested JOIN clauses in the case of 3 or more outer streams joined.</para></listitem>
      </itemizedlist>

      <para>A <emphasis>sort merge</emphasis> operates with two input streams which are sorted beforehand, then merged
    in a single run.</para>

      <para><emphasis role="bold">Examples</emphasis></para>
      <programlisting>
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS
    WHERE RDB$RELATION_NAME LIKE 'RDB$%'
    PLAN (RDB$RELATIONS NATURAL)
    ORDER BY RDB$RELATION_NAME

    SELECT R.RDB$RELATION_NAME, RF.RDB$FIELD_NAME
    FROM RDB$RELATIONS R
      JOIN RDB$RELATION_FIELDS RF
      ON R.RDB$RELATION_NAME = RF.RDB$RELATION_NAME
    PLAN MERGE (SORT (R NATURAL), SORT (RF NATURAL))
      </programlisting>

      <para><emphasis role="bold">Notes</emphasis></para>

      <orderedlist type="a">
      <listitem><para>A PLAN clause may be used in all select expressions, including subqueries,
       derived tables and view definitions. It can be also used in UPDATE and DELETE
       statements, because they're implicitly based on select expressions.</para></listitem>
      <listitem><para>If a PLAN clause contains some invalid retrieval description, then either an
       error will be returned or this bad clause will be silently ignored, depending
       on severity of the issue.</para></listitem>
      <listitem><para>ORDER &lt;navigational_index&gt; INDEX ( &lt;filter_indices&gt; ) kind of plan is reported
       by the engine and can be used in the user-supplied plans starting with FB 2.0.</para></listitem>
      </orderedlist>

      </section>

      <section id="dml-dsql-sorting"><!-- Level 2 section -->
      <sectioninfo>
        <title>Improvements in Sorting</title>
        <author><firstname>A.</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Some useful improvements have been made to SQL sorting operations:</para>
        <section id="dml-dsql-sorting-both"><!-- Level 3 section -->
        <title>Order By or Group By &lt;alias-name&gt;</title>
        <para>Column aliases are now allowed in both these clauses.</para>
        <para><emphasis role="bold">Examples:</emphasis></para>
        <orderedlist>
        <listitem><para>ORDER BY</para>
        <programlisting>
        SELECT RDB$RELATION_ID AS ID
        FROM RDB$RELATIONS
        ORDER BY ID
        </programlisting>
        </listitem>
        <listitem><para>GROUP BY</para>
        <programlisting>
        SELECT RDB$RELATION_NAME AS ID, COUNT(*)
        FROM RDB$RELATION_FIELDS
        GROUP BY ID
        </programlisting>
        </listitem>
        </orderedlist>

        </section>
        <section id="dml-dsql-sorting-groupby-expr"><!-- Level 3 section -->
        <title>GROUP BY Arbitrary Expressions</title>
        <para> A GROUP BY condition can now be any valid expression.</para>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
  ...
    GROUP BY
    SUBSTRING(CAST((A * B) / 2 AS VARCHAR(15)) FROM 1 FOR 2)
        </programlisting>
        </section>

        <section id="dml-dsql-sorting-orderby"><!-- Level 3 section -->
        <title>Order SELECT * Sets by Degree Number</title>
        <para>Order by degree (ordinal column position) now works on a select * list.</para>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
   SELECT *
     FROM RDB$RELATIONS
     ORDER BY 9
        </programlisting>
        </section><!-- Level 3 -->

        <section id="dml-dsql-sorting-gotcha"><!-- Level 3 section -->
        <title>Parameters and Ordinal Sorts--a <quote>Gotcha</quote></title>
        <para>According to grammar rules, since v.1.5, ORDER BY &lt;value_expression&gt; is allowed
        and &lt;value_expression&gt; could be a variable or a parameter.  It is tempting to assume that
        ORDER BY &lt;degree_number&gt; could thus be validly represented as a replaceable input parameter, or an
        expression containing a parameter.</para>

        <para>However, while the DSQL parser does not reject the parameterised ORDER BY clause expression if it
        resolves to an integer, the optimizer requires an absolute, constant value in order to identify
        the <emphasis>position in the output list</emphasis> of the ordering column or derived field.  If a
        parameter is accepted by the parser, the output will undergo a <quote>dummy sort</quote> and the returned
        set will be unsorted.</para>

        </section><!-- Level 3 -->
      </section><!-- Level 2 -->

      <section id="dml-dsql-nextvalue" xreflabel="NEXT VALUE FOR"><!-- Level 2 section -->
      <sectioninfo>
        <title>NEXT VALUE FOR Expression Syntax</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>Added SQL-99 compliant NEXT VALUE FOR &lt;sequence_name&gt; expression as a synonym
      for GEN_ID(&lt;generator-name&gt;, 1), complementing the introduction of CREATE SEQUENCE syntax as
      the SQL standard equivalent of CREATE GENERATOR.</para>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para>1.</para>
      <programlisting>
   SELECT GEN_ID(S_EMPLOYEE, 1) FROM RDB$DATABASE;
      </programlisting>
      <para>2.</para>
      <programlisting>
   INSERT INTO EMPLOYEE (ID, NAME)
     VALUES (NEXT VALUE FOR S_EMPLOYEE, 'John Smith');
      </programlisting>

      <note>
      <orderedlist>
      <listitem><para>Currently, increment (&quot;step&quot;) values not equal to 1 (one) can be used only by calling
       the GEN_ID function. Future versions are expected to provide full support for SQL-99 sequence generators,
       which allows the required increment values to be specified at the DDL level.  Unless there is a vital need to
       use a step value that is not 1, use of a NEXT VALUE FOR value expression instead of the GEN_ID function is
       recommended.</para></listitem>

      <listitem><para>GEN_ID(&lt;name&gt;, 0) allows you to retrieve the current sequence value, but it should never
       be used in insert/update statements, as it produces a high risk of uniqueness violations in a concurrent
       environment.</para></listitem>
      </orderedlist>
      </note>
      </section><!-- Level 2 -->

      <section id="dml-dsql-returning"><!-- Level 2 section -->
      <sectioninfo>
        <title>RETURNING Clause for Insert Statements</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>The RETURNING clause syntax has been implemented for the INSERT statement, enabling the return of a
      result set from the INSERT statement.  The set contains the column values actually stored. Most common usage 
      would be for retrieving the value of the primary key generated inside a BEFORE-trigger.</para>
      <para>Available in DSQL and PSQL.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  INSERT INTO ... VALUES (...) [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]
      </programlisting>
      <para><emphasis role="bold">Example(s)</emphasis></para>
      <para>1.</para> 
      <programlisting>
  INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2)
  RETURNING F1, F2 INTO :V1, :V2;
      </programlisting>
      
      <para>2.</para> 
      <programlisting>
 INSERT INTO T2 (F1, F2)
   VALUES (1, 2)
  RETURNING ID INTO :PK;
      </programlisting>
      
      <note>
      <orderedlist>
      <listitem><para>The INTO part (i.e. the variable list) is allowed in PSQL only (to assign local variables)
       and rejected in DSQL.</para></listitem>
      <listitem><para>In DSQL, values are being returned within the same protocol roundtrip as the INSERT itself
       is executed.</para></listitem>
      <listitem><para>If the RETURNING clause is present, then the statement is described as
       isc_info_sql_stmt_exec_procedure by the API (instead of isc_info_sql_stmt_insert),
       so the existing connectivity drivers should support this feature automagically.</para></listitem>

      <listitem><para>Any explicit record change (update or delete) performed by AFTER-triggers is ignored by
       the RETURNING clause.</para></listitem>
      <listitem><para>Cursor based inserts (INSERT INTO ... SELECT ... RETURNING ...) are not supported.</para></listitem>
      <listitem><para>This clause can return table column values or arbitrary expressions.</para></listitem>
      </orderedlist>
      </note>
      </section><!-- Level 2 -->

      <section id="dml-dsql-parsing"><!-- Level 2 section -->
      <sectioninfo>
        <title>DSQL parsing of table aliases is stricter</title>
        <author><firstname>A.</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Alias handling and ambiguous field detecting have been improved.  In summary:</para>
      <orderedlist type="a">
      <listitem><para>When a table alias is provided for a table, either that alias, or no alias, must be used.  It is no
longer valid to supply only the table name.</para></listitem>
      <listitem><para>Ambiguity checking now checks first for ambiguity at the current level of scope, making it valid in some
conditions for columns to be used without qualifiers at a higher scope level.</para></listitem>
      </orderedlist>

      <para><emphasis role="bold">Examples</emphasis></para>
      <orderedlist>
      <listitem><para>When an alias is present it must be used; or no alias at all is allowed.</para>
        <orderedlist type="a">
        <listitem><para>This query was allowed in FB1.5 and earlier versions:</para>
        <programlisting>
    SELECT
      RDB$RELATIONS.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
        <para>but will now correctly report an error that the field &quot;RDB$RELATIONS.RDB$RELATION_NAME&quot;
        could not be found.</para>
        <para>Use this (preferred):</para>
        <programlisting>
    SELECT
      R.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
        <para>or this statement:</para>
        <programlisting>
    SELECT
      RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
        </listitem>

        <listitem><para>The statement below will now correctly use the FieldID from the subquery and from the
        updating table:</para>
        <programlisting>
    UPDATE
      TableA
    SET
      FieldA = (SELECT SUM(A.FieldB) FROM TableA A
        WHERE A.FieldID = TableA.FieldID)
        </programlisting>
        <note>
        <para>In Firebird it is possible to provide an alias in an update statement, but many other database vendors
        do not support it. These SQL statements will improve the interchangeability of Firebird's SQL with other SQL
        database products.</para>
        </note>
        </listitem>
        <listitem><para>This example did not run correctly in Firebird 1.5 and earlier:</para>
        <programlisting>
    SELECT
      RDB$RELATIONS.RDB$RELATION_NAME,
      R2.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS
      JOIN RDB$RELATIONS R2 ON
        (R2.RDB$RELATION_NAME = RDB$RELATIONS.RDB$RELATION_NAME)
        </programlisting>
        <para>If RDB$RELATIONS contained 90 records, it would return 90 * 90 = 8100 records, but in Firebird 2 it will
        correctly return 90 records.</para>
        </listitem>
        </orderedlist>
      </listitem>

      <listitem>
        <orderedlist type="a">
        <listitem><para>This failed in Firebird 1.5, but is possible in Firebird 2:</para>
        <programlisting>
    SELECT
      (SELECT RDB$RELATION_NAME FROM RDB$DATABASE)
    FROM
      RDB$RELATIONS
        </programlisting>
        </listitem>

        <listitem><para>Ambiguity checking in subqueries:  the query below would run in Firebird 1.5 without reporting
        an ambiguity, but will report it in Firebird 2:</para>
       <programlisting>
    SELECT
      (SELECT
         FIRST 1 RDB$RELATION_NAME
       FROM
         RDB$RELATIONS R1
         JOIN RDB$RELATIONS R2 ON
           (R2.RDB$RELATION_NAME = R1.RDB$RELATION_NAME))
    FROM
      RDB$DATABASE
       </programlisting>
       </listitem>
       </orderedlist>
      </listitem>
      </orderedlist>
      </section>
    </section><!-- Level 1 -->

    <section id="dml-select-syntax" xreflabel="Select Statement &amp; Expression Syntax"><!-- Level 1 section -->
    <sectioninfo>
      <title>SELECT Statement &amp; Expression Syntax</title>
      <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
    </sectioninfo>
    <para><emphasis>About the semantics</emphasis></para>
    <itemizedlist>
      <listitem>
        <para>A select statement is used to return data to the caller (PSQL module or the client program)</para>
      </listitem>
      <listitem>
        <para>Select expressions retrieve parts of data that construct columns that can be in either the final
        result set or in any of the intermediate sets. Select expressions are also known as subqueries.</para>
      </listitem>
    </itemizedlist>

    <para><emphasis>Syntax rules</emphasis></para>
    <programlisting>
  &lt;select statement&gt; ::=
    &lt;select expression&gt; [FOR UPDATE] [WITH LOCK]

  &lt;select expression&gt; ::=
    &lt;query specification&gt; [UNION [{ALL | DISTINCT}] &lt;query specification&gt;]

  &lt;query specification&gt; ::=
    SELECT [FIRST &lt;value&gt;] [SKIP &lt;value&gt;] &lt;select list&gt;
    FROM &lt;table expression list&gt;
    WHERE &lt;search condition&gt;
    GROUP BY &lt;group value list&gt;
    HAVING &lt;group condition&gt;
    PLAN &lt;plan item list&gt;
    ORDER BY &lt;sort value list&gt;
    ROWS &lt;value> [TO &lt;value&gt;]

  &lt;table expression> ::=
    &lt;table name&gt; | &lt;joined table&gt; | &lt;derived table&gt;

  &lt;joined table> ::=
    {&lt;cross join&gt; | &lt;qualified join&gt;}

  &lt;cross join&gt; ::=
    &lt;table expression&gt; CROSS JOIN &lt;table expression&gt;

  &lt;qualified join> ::=
    &lt;table expression&gt; [{INNER | {LEFT | RIGHT | FULL} [OUTER]}] JOIN &lt;table expression&gt;
    ON &lt;join condition&gt;

  &lt;derived table> ::=
    '(' &lt;select expression&gt; ')'
    </programlisting>

    <para><emphasis>Conclusions</emphasis></para>
    <itemizedlist>
      <listitem>
        <para>FOR UPDATE mode and row locking can only be performed for a final dataset,
    they cannot be applied to a subquery</para>
      </listitem>
      <listitem>
        <para>Unions are allowed inside any subquery</para>
      </listitem>
      <listitem>
        <para>Clauses FIRST, SKIP, PLAN, ORDER BY, ROWS are allowed for any subquery</para>
      </listitem>
    </itemizedlist>

    <para><emphasis>Notes</emphasis></para>
    <itemizedlist>
      <listitem>
        <para>Either FIRST/SKIP or ROWS is allowed, but a syntax error is thrown if you try to mix the syntaxes</para>
      </listitem>
      <listitem>
        <para>An INSERT statement accepts a select expression to define a set to be inserted into a table. Its 
        SELECT part supports all the features defined for select statments/expressions</para>
      </listitem>
      <listitem>
        <para>UPDATE and DELETE statements are always based on an implicit cursor iterating through its target 
        table and limited with the WHERE clause. You may also specify the final parts of the select expression 
        syntax to limit the number of affected rows or optimize the statement.</para>
        <para>Clauses allowed at the end of UPDATE/DELETE statements are PLAN, ORDER BY and ROWS.</para>
      </listitem>
    </itemizedlist>
    </section>

  </chapter>