<chapter id="rnfb210-dml">
  <chapterinfo>
    <title>Data Manipulation Language (DML)</title>
  </chapterinfo>
  <para>In this chapter are the additions and improvements that have been added to the SQL data manipulation
  language subset in the Firebird 2 development cycle.  Those marked as introduced in v.2.1 are available only
  to ODS 11.1 and higher databases.</para>

  <important>
    <para>A new configuration parameter, named <firstterm>RelaxedAliasChecking</firstterm> was added to the
    <command>firebird.conf</command> in Firebird 2.1 to permit a slight relaxation of the Firebird 2.0.x
    restrictions on mixing relation aliases and table names in a query (see <xref linkend="rnfb20x-dml-parsing"/>, 
    below).</para>
    <para>This parameter will not be a permanent fixture in Firebird but is intended as a migration aid for those 
    needing time to adjust existing code.  More information under <xref linkend="rnfb210-fbconf-relax"/> in the 
    chapter <quote>New Configuration Parameters</quote>.</para>
  </important>

  <section id="rnfb210-dml-links"><!-- Level 1 section -->
    <title>Quick Links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para><xref linkend="rnfb210-cte"/><!-- Common Table Expressions --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-list"/><!-- LIST Function --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-rtrng"/><!-- RETURNING Clause --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-updorinsrt"/><!-- UPDATE OR INSERT Statement --></para>
      </listitem>
      <!-- OMITTED FROM INITIAL RELEASE NOTES -->
      <listitem>
        <para><xref linkend="rnfb210-merge"/><!-- MERGE Statement --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-joins"/><!-- New JOIN Types --></para>
        <itemizedlist spacing="compact">
          <listitem>
            <para><xref linkend="rnfb210-joins-sntx"/><!-- NAMED COLUMNS & NATURAL JOIN --></para>
          </listitem>
          <listitem>
            <para><xref linkend="rnfb20x-dml-cross-join"/><!-- CROSS JOIN --></para>
          </listitem>
        </itemizedlist>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-dml-insrt"/><!-- INSERT with Defaults --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-blbvchar"/><!-- Text BLOB Compatibility --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-blob-compare"/><!-- Compare BLOB=BLOB --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-dsqlchanges-blobsort"/><!-- Sorting on BLOBs --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-dml-dbkey"/><!-- RDB$DB_KEY Returns NULL in Outer Joins --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-builtin-new"/><!-- New Built-in Functions --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-builtin-enh"/><!-- Enhancements to Built-in Functions --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-iif"/><!-- IIF() Expression --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-cast"/><!-- Improvement in CAST() Behaviour --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb210-dml-domaincast"/><!-- CAST(x as <domain-name>) --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-substring"/><!-- Expression Arguments for SUBSTRING() --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-parsing"/><!-- DSQL Parsing of Table Names is Stricter --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-execute-block"/><!-- EXECUTE BLOCK Statement --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-derived-tables"/><!-- Derived Tables --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-rb-retain"/><!-- ROLLBACK RETAIN Syntax --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-rows"/><!-- ROWS Syntax --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-union-distinct"/><!-- UNION DISTINCT --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-union-coercion"/><!-- Improved Type Coercion in UNIONs --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-union-subqueries"/><!-- UNIONs Allowed in ANY/ALL/IN Subqueries --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-nulls-distinct"/><!-- New [NOT] DISTINCT Predicate --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-nulls-equivalence"/><!-- NULL Comparison Rule Relaxed --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-nulls-ordering"/><!-- NULLs Ordering Changed --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-complex-dml"/><!-- UNION Sets in Subquery Constructs --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-context"/><!-- Extended Context Variables --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-plans"/><!-- Query Plans Improvements --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-sorting-both"/><!-- GROUP or ORDER by Alias Name --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-sorting-groupby-expr"/><!-- GROUP BY Arbitrary Expressions --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-sorting-orderby"/><!-- Order * Sets by Implicit Degree Number --></para>
      </listitem>
      <listitem>
        <para><xref linkend="rnfb20x-dml-nextvalue"/><!-- NEXT VALUE FOR --></para>
      </listitem>
      <listitem>
        <para><emphasis role="bold">Articles</emphasis></para>
        <orderedlist spacing="compact">
          <listitem>
            <para><xref linkend="rnfb20x-dml-select-syntax"/><!-- Select Statement & Expression Syntax --></para>
          </listitem>
          <listitem>
            <para><xref linkend="rnfb210-dataresult"/><!-- Data Type of an Aggregation Result --></para>
          </listitem>
          <listitem>
            <para><xref linkend="rnfb210-dml-datetimetyping"/><!-- A Useful Trick with Date Literals --></para>
          </listitem>
        </orderedlist>
      </listitem>
    </itemizedlist>

    <section id="rnfb210-cte" xreflabel="Common Table Expressions"><!-- Level 2 section -->
      <sectioninfo>
        <title>Common Table Expressions</title>
        <authorgroup>
          <author>
            <firstname>Vlad</firstname>
            <surname>Khorsun</surname>
          </author>
          <author>
            <firstname>Based on work by</firstname>
            <surname>Paul Ruizendaal for Fyracle project</surname>
          </author>
        </authorgroup>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> A <firstterm>common table expression</firstterm> (CTE) is like 
      a view that is defined locally within a main query.  The engine treats a CTE like a derived table and no 
      intermediate materialisation of the data is performed.</para>

      <section id="rnfb210-cte-benefits"><!-- Level 3 section -->
        <title>Benefits of CTEs</title>
        <para>Using CTEs allows you to specify dynamic queries that are recursive:</para>
        <itemizedlist>
          <listitem>
            <para>The engine begins execution from a non-recursive member.</para>
          </listitem>
          <listitem>
            <para>For each row evaluated, it starts executing each recursive member one-by-one, using the
            current values from the outer row as parameters.</para>
          </listitem>
          <listitem>
            <para>If the currently executing instance of a recursive member produces no rows, execution loops
            back one level and gets the next row from the outer result set.</para>
          </listitem>
        </itemizedlist>

        <para>The memory and CPU overhead of a recursive CTE is much less than that of an equivalent
        recursive stored procedure.</para>
      </section>

      <section id="rnfb210-cte-limit"><!-- Level 3 section -->
        <title>Recursion Limit</title>
        <para>Currently the recursion depth is limited to a hard-coded value of 1024.</para>
      </section>

      <section id="rnfb210-cte-rules"><!-- Level 3 section -->
        <title>Syntax and Rules for CTEs</title>
        <programlisting>
select :
  select_expr for_update_clause lock_clause
select_expr :
  with_clause select_expr_body order_clause rows_clause
            | select_expr_body order_clause rows_clause
with_clause :
  WITH RECURSIVE with_list | WITH with_list
with_list :
  with_item | with_item ',' with_list
with_item :
  symbol_table_alias_name derived_column_list
    AS '(' select_expr ')'
select_expr_body :
  query_term
  | select_expr_body UNION distinct_noise query_term
             | select_expr_body UNION ALL query_term
        </programlisting>
        <para>A less formal representation:</para>
        <programlisting>
WITH [RECURSIVE]
	CTE_A [(a1, a2, &hellip;)]
	AS ( SELECT &hellip; ),

	CTE_B [(b1, b2, &hellip;)]
	AS ( SELECT &hellip; ),
...
SELECT ...
  FROM CTE_A, CTE_B, TAB1, TAB2 ...
 WHERE ...
        </programlisting>

        <section id="rnfb210-cte-rules-nonr"><!-- Level 4 section -->
          <title>Rules for Non-Recursive CTEs</title>
          <itemizedlist>
            <listitem>
              <para>Multiple table expressions can be defined in one query</para>
            </listitem>
             <listitem>
              <para>Any clause legal in a SELECT specification is legal in table expressions</para>
            </listitem>
            <listitem>
              <para>Table expressions can reference one another</para>
            </listitem>
            <listitem>
              <para>References between expressions should not have loops</para>
            </listitem>
            <listitem>
              <para>Table expressions can be used within any part of the main query or another table
              expression</para>
            </listitem>
            <listitem>
              <para>The same table expression can be used more than once in the main query</para>
            </listitem>
            <listitem>
              <para>Table expressions (as subqueries) can be used in INSERT, UPDATE and DELETE
              statements</para>
            </listitem>
            <listitem>
              <para>Table expressions are legal in PSQL code</para>
            </listitem>
            <listitem>
              <para>WITH statements can not be nested</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Example of a non-recursive CTE</emphasis></para>
          <programlisting>
WITH
  DEPT_YEAR_BUDGET AS (
    SELECT FISCAL_YEAR, DEPT_NO,
        SUM(PROJECTED_BUDGET) AS BUDGET
      FROM PROJ_DEPT_BUDGET
    GROUP BY FISCAL_YEAR, DEPT_NO
  )
SELECT D.DEPT_NO, D.DEPARTMENT,
  B_1993.BUDGET AS B_1993, B_1994.BUDGET AS B_1994,
       B_1995.BUDGET AS B_1995, B_1996.BUDGET AS B_1996
  FROM DEPARTMENT D
    LEFT JOIN DEPT_YEAR_BUDGET B_1993
      ON D.DEPT_NO = B_1993.DEPT_NO
      AND B_1993.FISCAL_YEAR = 1993
    LEFT JOIN DEPT_YEAR_BUDGET B_1994
      ON D.DEPT_NO = B_1994.DEPT_NO
      AND B_1994.FISCAL_YEAR = 1994
    LEFT JOIN DEPT_YEAR_BUDGET B_1995
      ON D.DEPT_NO = B_1995.DEPT_NO
      AND B_1995.FISCAL_YEAR = 1995
    LEFT JOIN DEPT_YEAR_BUDGET B_1996
      ON D.DEPT_NO = B_1996.DEPT_NO
      AND B_1996.FISCAL_YEAR = 1996

  WHERE EXISTS (
    SELECT * FROM PROJ_DEPT_BUDGET B
    WHERE D.DEPT_NO = B.DEPT_NO)
          </programlisting>
        </section>

        <section id="rnfb210-cte-rules-recrsv"><!-- Level 4 section -->
          <title>Rules for Recursive CTEs</title>
          <itemizedlist>
            <listitem>
              <para>A recursive CTE is self-referencing (has a reference to itself)</para>
            </listitem>
            <listitem>
              <para>A recursive CTE is a UNION of recursive and non-recursive members:</para>
              <itemizedlist>
                 <listitem>
                  <para>At least one non-recursive member (anchor) must be present</para>
                </listitem>
                 <listitem>
                  <para>Non-recursive members are placed first in the UNION</para>
                </listitem>
                <listitem>
                  <para>Recursive members are separated from anchor members and from one another
                  with UNION ALL clauses, i.e.,</para>
                  <literallayout>   non-recursive member (anchor)
   UNION [ALL | DISTINCT]
   non-recursive member (anchor)
   UNION [ALL | DISTINCT]
   non-recursive member (anchor)
   UNION ALL
   recursive member
   UNION ALL
   recursive member
                  </literallayout>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>References between CTEs should not have loops</para>
            </listitem>
            <listitem>
              <para>Aggregates (DISTINCT, GROUP BY, HAVING) and aggregate functions
              (SUM, COUNT, MAX etc) are not allowed in recursive members</para>
            </listitem>
            <listitem>
              <para>A recursive member can have only one reference to itself and only in a FROM clause</para>
            </listitem>
            <listitem>
              <para>A recursive reference cannot participate in an outer join</para>
            </listitem>
          </itemizedlist>

          <para><emphasis role="bold">Example of a recursive CTE</emphasis></para>
          <programlisting>
WITH RECURSIVE
  DEPT_YEAR_BUDGET AS
  (
    SELECT FISCAL_YEAR, DEPT_NO,
        SUM(PROJECTED_BUDGET) AS BUDGET
      FROM PROJ_DEPT_BUDGET
    GROUP BY FISCAL_YEAR, DEPT_NO
  ),

  DEPT_TREE AS
  (
    SELECT DEPT_NO, HEAD_DEPT, DEPARTMENT,
        CAST('' AS VARCHAR(255)) AS INDENT
      FROM DEPARTMENT
     WHERE HEAD_DEPT IS NULL

    UNION ALL

    SELECT D.DEPT_NO, D.HEAD_DEPT, D.DEPARTMENT,
    H.INDENT || '  '
      FROM DEPARTMENT D
      JOIN DEPT_TREE H
        ON D.HEAD_DEPT = H.DEPT_NO
  )

  SELECT D.DEPT_NO,
	D.INDENT || D.DEPARTMENT AS DEPARTMENT,
	B_1993.BUDGET AS B_1993,
	B_1994.BUDGET AS B_1994,
	B_1995.BUDGET AS B_1995,
	B_1996.BUDGET AS B_1996

  FROM DEPT_TREE D
    LEFT JOIN DEPT_YEAR_BUDGET B_1993
      ON D.DEPT_NO = B_1993.DEPT_NO
      AND B_1993.FISCAL_YEAR = 1993

    LEFT JOIN DEPT_YEAR_BUDGET B_1994
      ON D.DEPT_NO = B_1994.DEPT_NO
      AND B_1994.FISCAL_YEAR = 1994

    LEFT JOIN DEPT_YEAR_BUDGET B_1995
      ON D.DEPT_NO = B_1995.DEPT_NO
      AND B_1995.FISCAL_YEAR = 1995

    LEFT JOIN DEPT_YEAR_BUDGET B_1996
      ON D.DEPT_NO = B_1996.DEPT_NO
      AND B_1996.FISCAL_YEAR = 1996
          </programlisting>
        </section>
      </section>
    </section>

    <section id="rnfb210-list" xreflabel="LIST Function"><!-- Level 2 section -->
    <sectioninfo>
      <title>The LIST Function</title>
      <authorgroup>
        <author>
          <firstname>Oleg</firstname>
          <surname>Loa</surname>
        </author>
        <author>
          <firstname>Dmitry</firstname>
          <surname>Yemanov</surname>
        </author>
      </authorgroup>
    </sectioninfo>
    <para><emphasis role="bold">(v.2.1)</emphasis> This function returns a string result with the concatenated non-NULL
    values from a group. It returns NULL if there are no non-NULL values.</para>

    <para><emphasis role="bold">Format</emphasis></para>
    <programlisting>
&lt;list function&gt; ::=
  LIST '(' [ {ALL | DISTINCT} ] &lt;value expression&gt; [',' &lt;delimiter value&gt;
   ] ')'

&lt;delimiter value&gt; ::=
      { &lt;string literal&gt; | &lt;parameter&gt; | &lt;variable&gt; }
    </programlisting>

    <para><emphasis role="bold">Syntax Rules</emphasis></para>
    <orderedlist>
      <listitem>
        <para>If neither ALL nor DISTINCT is specified, ALL is implied.</para>
      </listitem>
      <listitem>
        <para>If &lt;delimiter value&gt; is omitted, a comma is used to separate
       the concatenated values.</para>
      </listitem>
    </orderedlist>

    <para><emphasis role="bold">Other Notes</emphasis></para>
    <orderedlist>
      <listitem>
        <para>Numeric and date/time values are implicitly converted to strings
        during evaluation.</para>
      </listitem>
      <listitem>
        <para>The result value is of type BLOB with SUB_TYPE TEXT for all cases
        except list of BLOB with different subtype.</para>
      </listitem>
      <listitem>
        <para>Ordering of values within a group is implementation-defined.</para>
      </listitem>
    </orderedlist>
    <para><emphasis role="bold">Examples</emphasis></para>
    <programlisting>
/* A */
  SELECT LIST(ID, ':')
  FROM MY_TABLE

/* B */
  SELECT TAG_TYPE, LIST(TAG_VALUE)
  FROM TAGS
  GROUP BY TAG_TYPE
      </programlisting>
    </section>

    <section id="rnfb210-rtrng" xreflabel="RETURNING Clause"><!-- Level 2 section -->
      <sectioninfo>
        <title>The RETURNING Clause</title>
        <authorgroup>
          <author>
            <firstname>Dmitry</firstname>
            <surname>Yemanov</surname>
          </author>
          <author>
            <firstname>Adriano</firstname>
            <surname>dos Santos Fernandes</surname>
          </author>
        </authorgroup>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> The purpose of this SQL enhancement is to enable the column 
      values stored into a table as a result of the <filename>INSERT</filename>, <filename>UPDATE
      OR INSERT</filename>, <filename>UPDATE</filename> and <filename>DELETE</filename> statements to be returned 
      to the client.</para>
      <para>The most likely usage is for retrieving the value generated for a primary
      key inside a BEFORE-trigger.  The RETURNING clause is optional and is available
      in both DSQL and PSQL, although the rules differ slightly.</para>
      <para>In DSQL, the execution of the operation itself and the return of the set
      occur in a single protocol round trip.</para>
      <para>Because the RETURNING clause is designed to return a singleton set in
      response to completing an operation on a single record, it is not valid to
      specify the clause in a statement that inserts, updates or deletes multiple
      records.</para>
      <note>
        <para>In DSQL, the statement always returns the set, even if the operation has
        no effect on any record.  Hence, at this stage of implementation, the potential
        exists to return a set that is all nulls.
        (This may be changed in future.)</para>
        <para>In PSQL, if no row was affected by the statement, nothing is returned and values of the receiving variables are unchanged.</para>
      </note>
      <para><emphasis role="bold">Syntax Patterns</emphasis></para>
      <programlisting>
INSERT INTO ... VALUES (...)
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

INSERT INTO ... SELECT ...
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

UPDATE OR INSERT INTO ... VALUES (...) ...
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

UPDATE ... [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]

DELETE FROM ...
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]
      </programlisting>

      <section id="rnfb210-rtrng-rules"><!-- Level 3 section -->
        <title>Rules for Using a RETURNING Clause</title>
        <orderedlist>
          <listitem><!-- 1 -->
            <para>The INTO part (i.e. the variable list) is allowed in PSQL only, for
            assigning the output set to local variables.  It is rejected in DSQL.</para>
          </listitem>
          <listitem><!-- 2 -->
            <para>The presence of the RETURNING clause causes an INSERT statement to be
            described by the API as <filename>isc_info_sql_stmt_exec_procedure</filename>
            rather than <filename>isc_info_sql_stmt_insert</filename>.  Existing
            connectivity drivers should already be capable of supporting this feature
            without special alterations.</para>
          </listitem>

          <listitem><!-- 3 -->
            <para>The RETURNING clause ignores any explicit record change (update or
            delete) that occurs as a result of the execution of an AFTER trigger.</para>
          </listitem>

          <listitem><!-- 4 -->
            <para>OLD and NEW context variables can be used in the RETURNING clause
            of UPDATE and INSERT OR UPDATE statements.</para>
          </listitem>

          <listitem><!-- 5 -->
            <para>In UPDATE and INSERT OR UPDATE statements, field references that are
            unqualified or qualified by table name or relation alias are resolved to
            the value of the corresponding NEW context variable.</para>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">Examples</emphasis></para>
        <orderedlist>
          <listitem><para></para><!-- 1 -->
            <programlisting>
INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2)
      RETURNING F1, F2 INTO :V1, :V2;
            </programlisting>
          </listitem>

          <listitem><para></para><!-- 2 -->
            <programlisting>
INSERT INTO T2 (F1, F2)
    VALUES (1, 2)
      RETURNING ID INTO :PK;
            </programlisting>
          </listitem>

          <listitem><para></para><!-- 3 -->
            <programlisting>
DELETE FROM T1
  WHERE F1 = 1
    RETURNING F2;
            </programlisting>
          </listitem>

          <listitem><para></para><!-- 4 -->
            <programlisting>
UPDATE T1
    SET F2 = F2 * 10
      RETURNING OLD.F2, NEW.F2;
            </programlisting>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section id="rnfb210-updorinsrt" xreflabel="UPDATE OR INSERT Statement"><!-- Level 2 section -->
      <sectioninfo>
        <title>UPDATE OR INSERT Statement</title>
        <author>
          <firstname>Adriano</firstname>
          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> This syntax has been introduced to enable a record to be either 
      updated or inserted, according to whether or not it already exists (checked with IS NOT DISTINCT).  The
      statement is available in both DSQL and PSQL.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
UPDATE OR INSERT INTO &lt;table or view&gt; [(&lt;column_list&gt;)]
    VALUES (&lt;value_list&gt;)
    [MATCHING (&lt;column_list&gt;)]
    [RETURNING &lt;column_list&gt; [INTO &lt;variable_list&gt;]]
      </programlisting>
      <para><emphasis role="bold">Examples</emphasis></para>
      <orderedlist>
        <listitem><para></para><!-- 1 -->
          <programlisting>
UPDATE OR INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2);
          </programlisting>
        </listitem>
        <listitem><para></para><!-- 2 -->
          <programlisting>
UPDATE OR INSERT INTO EMPLOYEE (ID, NAME)
    VALUES (:ID, :NAME)
    RETURNING ID;
          </programlisting>
        </listitem>
        <listitem><para></para><!-- 3 -->
          <programlisting>
UPDATE OR INSERT INTO T1 (F1, F2)
    VALUES (:F1, :F2)
    MATCHING (F1);
          </programlisting>
        </listitem>
        <listitem><para></para><!-- 4 -->
          <programlisting>
UPDATE OR INSERT INTO EMPLOYEE (ID, NAME)
    VALUES (:ID, :NAME)
    RETURNING OLD.NAME;
          </programlisting>
        </listitem>
      </orderedlist>

      <section id="rnfb210-updorinsrt-notes"><!-- Level 3 section -->
        <title>Usage Notes</title>
        <orderedlist>
            <listitem>
              <para>When MATCHING is omitted, the existence of a primary key
              is required.</para><!-- 1 -->
            </listitem>
            <listitem>
              <para>INSERT and UPDATE permissions are needed on &lt;table or
              view&gt;.</para><!-- 2 -->
            </listitem>
            <listitem>
              <para>If the RETURNING clause is present, then the statement is described
              as <filename>isc_info_sql_stmt_exec_procedure</filename> by the API;  &nbsp;otherwise,
              it is described as <filename>isc_info_sql_stmt_insert</filename>.</para><!-- 3 -->
            </listitem>
        </orderedlist>

        <note>
          <para>A <quote>multiple rows in singleton select</quote> error will be raised if the
          RETURNING clause is present and more than one record matches the search condition.</para>
        </note>
      </section>
    </section>
    
    <!-- OMITTED FROM INITIAL RELEASE NOTES -->
    <section id="rnfb210-merge" xreflabel="MERGE Statement"><!-- Level 2 section -->
      <sectioninfo>
        <title>MERGE Statement</title>
        <author>
          <firstname>Adriano</firstname>
          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> This syntax has been introduced to enable a record to be either 
      updated or inserted, according to whether or not a stated condition is met.  The
      statement is available in both DSQL and PSQL.</para>
      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
&lt;merge statement&gt; ::=
MERGE
  INTO &lt;table or view&gt; [ [AS] &lt;correlation name&gt; ]
  USING &lt;table or view or derived table> [ [AS] &lt;correlation name&gt; ]
    ON &lt;condition&gt;
    [ &lt;merge when matched&gt; ]
    [ &lt;merge when not matched&gt; ]

&lt;merge when matched&gt; ::=
  WHEN MATCHED THEN
    UPDATE SET &lt;assignment list&gt;

&lt;merge when not matched> ::=
  WHEN NOT MATCHED THEN
    INSERT [ &lt;left paren&gt; &lt;column list&gt; &lt;right paren&gt; ]
    VALUES &lt;left paren&gt; &lt;value list&gt; &lt;right paren&gt;
      </programlisting>
      <section id="rnfb210-merge-rules"><!-- Level 3 section -->
        <title>Rules for MERGE</title>
        <orderedlist>
          <listitem>
            <para>At least one of &lt;merge when matched&gt; and &lt;merge when not matched&gt; should be
            specified</para>
          </listitem>
          <listitem>
            <para>Neither should be specified more than once.</para>
          </listitem>
        </orderedlist>
      </section>
      <note>
        <para>A right join is made between the INTO and USING tables using the condition. UPDATE is called when a
        matching record exists in the left (INTO) table, otherwise INSERT is called.</para>
        <para>If no record is returned from the join, INSERT is not called.</para>
      </note>

      <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
MERGE INTO customers c
  USING (SELECT * FROM customers_delta WHERE id > 10) cd
  ON (c.id = cd.id)
    WHEN MATCHED THEN
      UPDATE SET
        name = cd.name
    WHEN NOT MATCHED THEN
      INSERT (id, name)
      VALUES (cd.id, cd.name)
      </programlisting>
    </section>

    <section id="rnfb210-joins" xreflabel="New JOIN Types"><!-- Level 2 section -->
      <sectioninfo>
        <title>New JOIN Types</title>
        <author>
          <firstname>Adriano</firstname>
          <surname>dos Santos Fernandes</surname>
        </author>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> Two new JOIN types are introduced:  the NAMED COLUMNS join
      and its close relative, the NATURAL join.</para>

      <section id="rnfb210-joins-sntx" xreflabel="NAMED COLUMNS &amp; NATURAL JOIN"><!-- Level 3 section -->
        <title>Syntax and Rules</title>
        <programlisting>
&lt;named columns join&gt; ::=
  &lt;table reference&gt; &lt;join type&gt; JOIN &lt;table reference&gt;
    USING ( &lt;column list&gt; )

&lt;natural join&gt; ::=
 &lt;table reference&gt; NATURAL &lt;join type&gt; JOIN &lt;table primary&gt;
        </programlisting>

        <section id="rnfb210-joins-ncolms"><!-- Level 4 section -->
          <title>Named columns join</title>
          <orderedlist>
            <listitem>
              <para>All columns specified in &lt;column list&gt; should exist in the
              tables at both sides.</para>
            </listitem>

            <listitem>
              <para>An equi-join (&lt;left table&gt;.&lt;column&gt; =
              &lt;right table&gt;.&lt;column&gt;) is automatically
             created for all columns (ANDed).</para>
            </listitem>

            <listitem>
              <para>The USING columns can be accessed without qualifiers&mdash;in this
              case, the result is equivalent to
             COALESCE(&lt;left table&gt;.&lt;column&gt;, &lt;right table&gt;.&lt;column&gt;).</para>
            </listitem>

            <listitem>
              <para>In <quote>SELECT *</quote>, USING columns are expanded once,
              using the above rule.</para>
            </listitem>
          </orderedlist>
        </section>

        <section id="rnfb210-joins-ntrl"><!-- Level 4 section -->
          <title>Natural join</title>
          <orderedlist>
            <listitem>
              <para>A <quote>named columns join</quote> is automatically created with
              all columns common to the left and right tables.</para>
            </listitem>

            <listitem>
              <para>If there is no common column, a CROSS JOIN is created.</para>
            </listitem>
          </orderedlist>
        </section>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
/* 1 */
select * from employee
  join department
  using (dept_no);

/* 2 */
select * from employee_project
  natural join employee
  natural join project;
        </programlisting>
      </section>

    <!-- ////////////////////////////////////////////////////////////////////////////////////////////////////// -->
    <!-- V.2.0.X CROSS JOIN -->

      <section id="rnfb20x-dml-cross-join" xreflabel="CROSS JOIN"><!-- Level 3 section -->
        <sectioninfo>
          <title>CROSS JOIN</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <para><emphasis role="bold">(V.2.0.x)</emphasis> CROSS JOIN is now supported. Logically, this 
        syntax pattern:</para>
        <programlisting>
   A CROSS JOIN B
        </programlisting>
        <para>is equivalent to either of the following:</para>
        <programlisting>
   A INNER JOIN B ON 1 = 1
        </programlisting>
        <para>or, simply:</para>
        <programlisting>
  FROM A, B
        </programlisting>
        
        <section id="rnfb212-dml-cross-join"><!-- Level 4 section -->
          <sectioninfo>
            <title>Performance Improvement at V.2.1.2</title>
            <author><firstname>D.</firstname><surname>Yemanov</surname></author>
          </sectioninfo>
            <para>In the rare case where a cross join of three or more tables involved table[s] that contained no records,
      extremely slow performance was reported <ulink url="http://tracker.firebirdsql.org/browse/CORE-2200"><emphasis>(CORE-2200)</emphasis></ulink>.  A performance improvement was gained by teaching the optimizer not to waste time and effort on walking through populated tables in an attempt to find matches in empty tables.</para>
        </section>
      </section>
    <!-- ////////////////////////////////////////////////////////////////////////////////////////////////////// -->

    </section>

    <section id="rnfb210-dml-insrt" xreflabel="INSERT with Defaults"><!-- Level 2 section -->
      <sectioninfo>
        <title>INSERT with Defaults</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para><ulink url="http://tracker.firebirdsql.org/browse/CORE-863">Feature request</ulink></para>
      <para><emphasis role="bold">(v.2.1)</emphasis> It is now possible to INSERT without supplying values, if
      Before Insert triggers and/or declared defaults are available for every column and none is dependent on the
      presence of any supplied 'NEW' value.</para>
      <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
INSERT INTO &lt;table&gt;
  DEFAULT VALUES
  [RETURNING &lt;values&gt;]
      </programlisting>
    </section>

    <section id="rnfb210-blbvchar" xreflabel="Text BLOB Compatibility"><!-- Level 2 section -->
      <sectioninfo>
        <title>BLOB Subtype 1 Compatibility with VARCHAR</title>
        <author><firstname>A.</firstname><surname>dos Santos Fernandes</surname></author>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> At various levels of evaluation, the engine now treats text
      BLOBs that are within the 32,765-byte string size limit as though they were VARCHARs.  Operations that now
      allow text BLOBs to behave like strings are:</para>
      <itemizedlist>
        <listitem>
          <para>Assignments, conversions and concatenations (|| operator)</para>
        </listitem>
        <listitem>
          <para>Operators &#x003D; <!-- EQUALS SIGN -->,
          &lt;&gt;, <!-- not equal to -->
          &gt;, <!-- greater than -->
          &lt;, <!-- less than -->
          &gt;&#x003D;, <!-- greater than or equal -->
          &lt;&#x003D;, <!-- less than or equal -->
          BETWEEN, IS [NOT] DISTINCT FROM
          </para>
        </listitem>
        <listitem>
          <para>Functions CAST, BIT_LENGTH, CHAR[ACTER]_LENGTH, OCTET_LENGTH,
          LEFT, RIGHT, HASH, LOWER, UPPER, LPAD, RPAD, TRIM, OVERLAY, 
          REPLACE, POSITION, REVERSE, MINVALUE, MAXVALUE, SUBSTRING</para>
          <warning>
            <title>Note Carefully!</title>
            <para>SUBSTRING(), when applied to a text BLOB, now returns a text BLOB as its
            result, instead of the VARCHAR result that was implemented previously.  This change
            has the potential to break expressions in existing client and PSQL code.</para>
            <para>If the FOR argument is absent, the BLOB returned will be no greater than
            32,767 bytes, even if the end of the string  was not reached.</para>
          </warning>
        </listitem>
        <listitem>
          <para>Existential predicators IN, ANY/SOME, ALL</para>
        </listitem>
        <listitem>
          <para>Search predicators CONTAINING, STARTING [WITH], LIKE</para>
          <important>
            <para>The predicating expression must not resolve to more than 32,767 bytes!</para>
          </important>
        </listitem>
        <listitem>
          <para>A LIST expression.  Note that, prior to v.2.1.4, the last part of the result may 
          be truncated, an effect that applies to native VARCHAR columns also.</para>
        </listitem>
      </itemizedlist>

    </section>

    <section id="rnfb20x-blob-compare" xreflabel="Compare BLOB=BLOB"><!-- Level 2 section -->
        <title>Full Equality Comparisons Between BLOBs</title>
        <para><emphasis role="bold">(v.2.0.x)</emphasis> Comparison can be performed on the entire content
        of a text BLOB.</para>
      </section>

    <section id="rnfb210-dml-dbkey" xreflabel="RDB$DB_KEY Returns NULL in Outer Joins"><!-- Level 2 section -->
      <sectioninfo>
        <title>RDB$DB_KEY Returns NULL in Outer Joins</title>
        <author><firstname>A.</firstname><surname>dos Santos Fernandes</surname></author>
      </sectioninfo>
      <para><ulink url="http://tracker.firebirdsql.org/browse/CORE-979">Feature request CORE-979</ulink></para>
      <para><emphasis role="bold">(v.2.1)</emphasis> By some anomaly, the physical RDB$DB_KEY has always returned a
      value on every output row when specified in an outer join, thereby making a test predicated on the assumption
      that a non-match returns NULL in all fields return False when it ought to return True.  Now, RDB$DB_KEY returns
      NULL when it should do so.</para>
    </section>

    <section id="rnfb210-dsqlchanges-blobsort" xreflabel="Sorting on BLOBs"><!-- Level 2 section -->
      <sectioninfo>
        <title>Sorting on BLOB and ARRAY Columns is Restored</title>
        <author>
          <firstname>Dmitry</firstname>
          <surname>Yemanov</surname>
        </author>
      </sectioninfo>
      <para><emphasis role="bold">(v.2.1)</emphasis> In earlier pre-release versions of Firebird 2.1, changes were introduced to reject sorts (ORDER BY, GROUP BY
      and SELECT DISTINCT operations) at prepare time if the sort clause implicitly or explicitly involved sorting on a
      BLOB or ARRAY column.</para>

      <para>That change was reversed in the RC2 pre-release version, not because it was wrong but because so many users
      complained that it broke the behaviour of legacy applications.</para>

      <important>
        <para>This reversion to <quote>bad old behaviour</quote> does not in any way imply that such queries will
        magically return correct results.  A BLOB cannot be converted to a sortable type and so, as previously, DISTINCT
        sortings and ORDER BY arguments that involve BLOBs, will use the BLOB_ID.  GROUP BY arguments that
        are BLOB types will prepare successfully, but the aggregation will be non-existent.</para>
      </important>
    </section>

    <section id="rnfb210-builtin" xreflabel="Built-in Functions"><!-- Level 2 section -->
      <title>Built-in Functions</title>
      <para><emphasis role="bold">(v.2.1)</emphasis> Some existing built-in functions have been enhanced, while a
      large number of new ones has been added.</para>
      <section id="rnfb210-builtin-new" xreflabel="New Built-in Functions"><!-- Level 3 section -->
        <sectioninfo>
          <title>New Built-in Functions</title>
          <authorgroup>
            <author>
              <firstname>Adriano</firstname>
              <surname>dos Santos Fernandes</surname>
            </author>
            <author>
              <firstname>Oleg</firstname>
              <surname>Loa</surname>
            </author>
            <author>
              <firstname>Alexey</firstname>
              <surname>Karyakin</surname>
            </author>
          </authorgroup>
        </sectioninfo>
        <para>A number of built-in functions has been implemented in V.2.1 to replace common
        UDFs with the same names.  The built-in functions will not be used if the UDF of the
        same name is declared in the database.</para>
        <note>
          <para>The choice between UDF and built-in function is decided when compiling the statement. If the statement
          is compiled in a PSQL module whilst the UDF is available in the database, then the module will continue to
          require the UDF declaration to be present until it is next recompiled.</para>
          <para>The new built-in function <emphasis>DECODE()</emphasis> does not have an
          equivalent UDF in the libraries that are distributed with Firebird.</para>
        </note>

        <para>The functions are detailed in <xref linkend="rnfb210-appx-A"/>.</para>
        <note>
          <para>Several of these built-in functions were already available in Firebird 2/ODS 11, viz., LOWER(), TRIM(),
           BIT_LENGTH(), CHAR_LENGTH() and OCTET_LENGTH().</para>
         </note>  
      </section>

      <section id="rnfb210-builtin-enh" xreflabel="Enhancements to Built-in Functions"><!-- Level 3 section -->
        <sectioninfo>
          <title>Enhancements to Functions</title>
            <author>
              <firstname>A.</firstname>
              <surname>dos Santos Fernandes</surname>
            </author>
         </sectioninfo>
         <variablelist>
           <varlistentry>
             <term>EXTRACT(WEEK FROM DATE)</term>
             <listitem>
               <para>Feature request <ulink url="http://tracker.firebirdsql.org/browse/CORE-663">CORE-663</ulink></para>
               <para>The EXTRACT() function is extended to support the ISO-8601 ordinal week numbers.  For example:</para>
               <programlisting>
EXTRACT (WEEK FROM date '30.09.2007')
               </programlisting>
               <para>returns 39</para>
             </listitem>
             <listitem>
<!-- another example added at v.2.1.2 -->
               <programlisting>
alter table xyz
add WeekOfTheYear 
computed by (
  case
    when (extract(month from CertainDate) = 12)
    and (extract(week from CertainDate) = 1)
    then
      'Week '||extract (WEEK from CertainDate)||' of year '
      || (1 + (extract( year from CertainDate)))
    else 'Week '||extract (WEEK from CertainDate)||' of year '
      ||extract( year from CertainDate)
  end )
               </programlisting>
             </listitem>
           </varlistentry>
           <varlistentry>
             <term>Specify the Scale for TRUNC()</term>
             <listitem>
               <para>Feature request <ulink url="http://tracker.firebirdsql.org/browse/CORE-1340">CORE-1340</ulink></para>
               <para>In Beta 1 the implementation of the TRUNC() function supported only one argument, the value to be
               truncated. From Beta 2, an optional second argument can be supplied to specify the scale of the truncation.
               For example:</para>
               <programlisting>
select
  trunc(987.65, 1),
  trunc(987.65, -1)
  from rdb$database;
               </programlisting>
               <para>returns 987.60, 980.00</para>
               <para>For other examples of using TRUNC() with and without the optional scale argument, refer to the
               alphabetical listing of functions in Appendix A.</para>
             </listitem>
           </varlistentry>
           <varlistentry>
             <term>Milliseconds Handling for EXTRACT(), DATEADD() and DATEDIFF()</term>
             <listitem>
               <para>Feature request <ulink url="http://tracker.firebirdsql.org/browse/CORE-1387">CORE-1387</ulink></para>
               <para>From v.2.1 Beta 2, EXTRACT(), DATEADD() and DATEDIFF() can operate with milliseconds (represented
               as an integer number).  For example:</para>
               <programlisting>
EXTRACT ( MILLISECOND FROM timestamp '01.01.2000 01:00:00.1234' )
               </programlisting>
               <para>returns 123</para>
               <programlisting>
DATEADD ( MILLISECOND, 100, timestamp '01.01.2000 01:00:00.0000' )
DATEDIFF ( MILLISECOND, timestamp '01.01.2000 02:00:00.0000', timestamp '01.01.2000 01:00:00.0000' )
               </programlisting>
               <para>For more explanatory examples of using DATEADD() and DATEDIFF(), refer to the alphabetical listing
               of functions in Appendix A.</para>
             </listitem>
           </varlistentry>
         </variablelist>
       </section>
    </section>

    <!-- ///////////////////////////////////////////////////////////////////////////////////////////// -->
    <!-- FUNCTION ENHANCEMENTS FROM V.2.0.X -->

    <section id="rnfb20x-dml-enhfunc">
      <title>Functions Enhanced in V.2.0.x</title><!-- Level 2 section -->
      <para>Some function enhancements were already available in the V.2.0.x releases:</para>
      <section id="rnfb20x-dml-iif" xreflabel="IIF() Expression"><!-- Level 3 section -->
        <sectioninfo>
          <title>IIF() Expression</title>
          <author><firstname>O.</firstname><surname>Loa</surname></author>
        </sectioninfo>
        <para><emphasis role="bold">(V.2.0.x)</emphasis> An IIF() expression can be used as a shortcut for a CASE
        expression that tests exactly two conditions.  It returns the value of the first sub-expression if the given
        search condition evaluates to TRUE, otherwise it returns a value of the second sub-expression.</para>
        <programlisting>
   IIF (&lt;search_condition&gt;, &lt;value1&gt;, &lt;value2&gt;)
        </programlisting>
        <para>is implemented as a shortcut for</para>
        <programlisting>
   CASE
     WHEN &lt;search_condition&gt; THEN &lt;value1&gt;
     ELSE &lt;value2&gt;
   END
        </programlisting>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
    SELECT IIF(VAL &gt; 0, VAL, -VAL) FROM OPERATION
        </programlisting>
      </section>

      <section id="rnfb20x-dml-cast" xreflabel="Improvement in CAST() Behaviour"><!-- Level 3 section -->
        <sectioninfo>
          <title>Improvement in CAST() Behaviour</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <para><emphasis role="bold">(V.2.0.x)</emphasis> The infamous <quote>Datatype unknown</quote> error
        (SF Bug #1371274) when attempting some castings has been eliminated.  It is now possible to use CAST to
        advise the engine about the data type of a parameter.</para>

        <para><emphasis>Example</emphasis></para>
        <programlisting>
  SELECT CAST(? AS INT) FROM RDB$DATABASE
        </programlisting>
      </section>
      
      <section id="rnfb210-dml-domaincast" xreflabel="CAST(x as &lt;domain-name&gt;)"><!-- Level 3 section -->
        <sectioninfo>
          <title>CAST(x as &lt;domain-name&gt;)</title>
          <author><firstname>A.</firstname><surname>dos Santos Fernandes</surname></author>
        </sectioninfo>
        <para><emphasis role="bold">(V.2.1.x)</emphasis> Casting of compatible values or expressions can now 
        be made to a domain, after the manner of variable declarations in procedural SQL.</para>
        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
CAST (&lt;value&gt; | &lt;expression&gt; AS &lt;builtin-data-type&gt; | &lt;domain-name&gt; | TYPE OF &lt;domain-name&gt;)
        </programlisting>
        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
CREATE DOMAIN DOM AS INTEGER;
...
SELECT CAST (10.44 AS TYPE OF DOM) AN_INTEGER
  FROM RDB$DATABASE;
  
AN_INTEGER
----------
        10
...
SELECT CAST (3.142/2 AS DOM) AN_INTEGER
  FROM RDB$DATABASE;
  
AN_INTEGER
----------
         2 
        </programlisting>
        <note>
          <para>Directly casting to &lt;domain-name&gt; applies any default or constraint defined for the
          domain.  TYPE OF &lt;domain-name&gt; gets only the data type of the domain and ignores any other 
          attributes.</para>
        </note>
      </section>

      <section id="rnfb20x-dml-substring-changes"><!-- Level 3 section -->

        <section id="rnfb20x-dml-substring" xreflabel="Expression Arguments for SUBSTRING()"><!-- Level 4 section -->
          <sectioninfo>
            <title>Expression Arguments for SUBSTRING()</title>
            <author><firstname>O.</firstname><surname>Loa, D. Yemanov</surname></author>
          </sectioninfo>
          <para><emphasis role="bold">(V.2.0.x)</emphasis> The built-in function SUBSTRING() can now take arbitrary
          expressions in its parameters.</para>

          <para>Formerly, the inbuilt SUBSTRING() function accepted only constants as its second and third arguments
          (start position and length, respectively). Now, those arguments can be anything that resolves to a value,
          including host parameters, function results, expressions, subqueries, etc.</para>
          <tip>
            <para>If your attempts to use this feature fail with <quote>invalid token</quote> errors, bear in mind 
            that expression arguments often need to be enclosed in brackets!</para>
          </tip>
        </section>

        <section id="rnfb20x-dml-substring2"><!-- Level 4 section -->
          <title>Changes to Results Returned from SUBSTRING()</title>
          <para><emphasis role="bold">(V.2.1.x)</emphasis> To conform with standards, the character length of
          the result of applying SUBSTRING() to a VARCHAR or CHAR is now a VARCHAR of the same character length
          declared for or deduced from the value in the first argument.</para>

          <para>In Firebird 2.0 and 1.5, the returned value was a CHAR with the same character length as
          the declared or implied value of the first argument, too.  That implementation could become a bug in
          Firebird 2.0 under conditions where the input string was a CHAR and the FOR argument was presented
          as an expression whose result was not known at the point where memory was prepared to receive the
          result string.  The V.2.1 change addresses that.</para>

          <para>It is not necessary to redefine any PSQL variables you have declared to receive the results
          from SUBSTRING().  It is still correct to declare its size just big enough to accommodate the 
          actual data returned.  Just be sure that any FOR argument that is an expression cannot resolve to 
          an integer that is larger than the number of characters declared for your variable.</para>

          <important>
            <title>GOTCHA for BLOBs</title>
            <para>Clearly, a text BLOB, being of indeterminate character length, cannot fit into a paradigm that
            populates a string of known maximum dimension. Therefore, the result returned from applying
            SUBSTRING() to a text BLOB is not a VARCHAR() as previously, but a text BLOB.</para>
            <para>This change can break existing PSQL and expression code.</para>
            <itemizedlist>
              <listitem>
                <para>Watch out for overflows! Take particular care with CASTs and concatenations.</para>
              </listitem>
              <listitem>
                <para>In v.2.1.x sub-releases prior to v.2.1.4, pay attention to memory usage when assigning to 
                temporary BLOBs in loops!  The engine formerly allocated a minimum of one database page of memory 
                for each temporary BLOB, regardless of its actual size.  The implementation was improved in
                v.2.1.4 (see  tracker ticket
            <ulink url="http://tracker.firebirdsql.org/browse/CORE-1658">CORE-1658</ulink>).</para>
              </listitem>
            </itemizedlist>
          </important>
        </section>
      </section>
    </section>

    <!-- ///////////////////////////////////////////////////////////////////////////////////////////// -->


    <!-- ///////////////////////////////////////////////////////////////////////////////////// -->
    <!-- V.2.0.X -->
    <!-- ///////////////////////////////////////////////////////////////////////////////////// -->

    <section id="rnfb20x-dml-parsing" xreflabel="DSQL Parsing of Table Names is Stricter"><!-- Level 2 section -->
      <sectioninfo>
        <title>DSQL Parsing of Table Names is Stricter</title>
        <author><firstname>A.</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Alias handling and ambiguous field detecting have been improved.  In summary:</para>
      <orderedlist type="a">
      <listitem><para>When a table alias is provided for a table, either that alias, or no alias, must be used.  It is no
longer valid to supply only the table name.</para></listitem>
      <listitem><para>Ambiguity checking now checks first for ambiguity at the current level of scope, making it valid in some
conditions for columns to be used without qualifiers at a higher scope level.</para></listitem>
      </orderedlist>

      <para><emphasis role="bold">Examples</emphasis></para>
      <orderedlist>
      <listitem><para>When an alias is present it must be used; or no alias at all is allowed.</para>
        <orderedlist type="a">
        <listitem><para>This query was allowed in FB1.5 and earlier versions:</para>
        <programlisting>
    SELECT
      RDB$RELATIONS.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
        <para>but will now correctly report an error that the field &quot;RDB$RELATIONS.RDB$RELATION_NAME&quot;
        could not be found.</para>
        <para>Use this (preferred):</para>
        <programlisting>
    SELECT
      R.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
        <para>or this statement:</para>
        <programlisting>
    SELECT
      RDB$RELATION_NAME
    FROM
      RDB$RELATIONS R
        </programlisting>
        </listitem>

        <listitem><para>The statement below will now correctly use the FieldID from the subquery and from the
        updating table:</para>
        <programlisting>
    UPDATE
      TableA
    SET
      FieldA = (SELECT SUM(A.FieldB) FROM TableA A
        WHERE A.FieldID = TableA.FieldID)
        </programlisting>
        <note>
        <para>In Firebird it is possible to provide an alias in an update statement.  Although many other 
        database vendors do not support it, this capability should help those developers who have requested 
        it to make Firebird's SQL more interchangeable with SQL database products that do support it.</para>
        </note>
        </listitem>
        <listitem><para>This example did not run correctly in Firebird 1.5 and earlier:</para>
        <programlisting>
    SELECT
      RDB$RELATIONS.RDB$RELATION_NAME,
      R2.RDB$RELATION_NAME
    FROM
      RDB$RELATIONS
      JOIN RDB$RELATIONS R2 ON
        (R2.RDB$RELATION_NAME = RDB$RELATIONS.RDB$RELATION_NAME)
        </programlisting>
        <para>If RDB$RELATIONS contained 90 records, it would return 90 * 90 = 8100 records, but in Firebird 2 it will
        correctly return 90 records.</para>
        </listitem>
        </orderedlist>
      </listitem>

      <listitem>
        <orderedlist type="a">
        <listitem><para>This would except with a syntax error in Firebird 1.5, but is 
        possible in Firebird 2:</para>
        <programlisting>
    SELECT
      (SELECT RDB$RELATION_NAME FROM RDB$DATABASE)
    FROM
      RDB$RELATIONS
        </programlisting>
        </listitem>

        <listitem><para>Ambiguity checking in subqueries:  the query below would run in Firebird 1.5 without reporting
        an ambiguity, but will report it in Firebird 2:</para>
       <programlisting>
    SELECT
      (SELECT
         FIRST 1 RDB$RELATION_NAME
       FROM
         RDB$RELATIONS R1
         JOIN RDB$RELATIONS R2 ON
           (R2.RDB$RELATION_NAME = R1.RDB$RELATION_NAME))
    FROM
      RDB$DATABASE
       </programlisting>
       </listitem>
       </orderedlist>
      </listitem>
      </orderedlist>
      </section>


    <section id="rnfb20x-dml-execute-block" xreflabel="EXECUTE BLOCK Statement"><!-- Level 2 section -->
      <sectioninfo>
        <title>EXECUTE BLOCK Statement</title>
        <author><firstname>V.</firstname><surname>Khorsun</surname></author>
      </sectioninfo>
      <para>The SQL language extension EXECUTE BLOCK makes &quot;dynamic PSQL&quot; available to SELECT specifications. It
 has the effect of allowing a self-contained block of PSQL code to be executed in dynamic SQL as if it were a stored
 procedure.</para>

      <para><emphasis role="bold">Syntax pattern</emphasis></para>
      <programlisting>
   EXECUTE BLOCK [ (param datatype = ?, param datatype = ?, ...) ]
     [ RETURNS (param datatype, param datatype, ...) ]
   AS
   [DECLARE VARIABLE var datatype; ...]
   BEGIN
     ...
   END
      </programlisting>

      <para>For the client, the call <function>isc_dsql_sql_info</function> with the parameter
      <function>isc_info_sql_stmt_type</function> returns</para>

      <itemizedlist>
      <listitem><para><function>isc_info_sql_stmt_select</function> if the block has output parameters.
      The semantics of a call is similar to a SELECT query:  the client has a cursor open, can fetch data from it,
      and must close it after use.</para></listitem>
      <listitem><para><function>isc_info_sql_stmt_exec_procedure</function> if the block has no output parameters.
      The semantics of a call is similar to an EXECUTE query: the client has no cursor and execution continues until
      it reaches the end of the block or is terminated by a SUSPEND.</para></listitem>
      </itemizedlist>

      <para>The client should preprocess only the head of the SQL statement or use '?' instead of ':' as the parameter
      indicator because, in the body of the block, there may be references to local variables or arguments with a colon
      prefixed.</para>

      <para><emphasis role="bold">Example</emphasis></para>

      <para>The user SQL is</para>
      <programlisting>
   EXECUTE BLOCK (X INTEGER = :X)
     RETURNS (Y VARCHAR)
   AS
   DECLARE V INTEGER;
   BEGIN
     INSERT INTO T(...) VALUES (... :X ...);
     SELECT ... FROM T INTO :Y;
     SUSPEND;
   END
      </programlisting>

      <para>The preprocessed SQL is</para>
      <programlisting>
   EXECUTE BLOCK (X INTEGER = ?)
     RETURNS (Y VARCHAR)
   AS
   DECLARE V INTEGER;
   BEGIN
     INSERT INTO T(...) VALUES (... :X ...);
     SELECT ... FROM T INTO :Y;
     SUSPEND;
   END
      </programlisting>
    </section>

    <section id="rnfb20x-dml-derived-tables" xreflabel="Derived Tables"><!-- Level 2 section -->
      <sectioninfo>
        <title>Derived Tables</title>
        <author><firstname>A.</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Implemented support for derived tables in DSQL (subqueries in FROM clause) as defined by SQL200X.  A derived
 table is a set, derived from a dynamic SELECT statement.  Derived tables can be nested, if required, to build complex
 queries and they can be involved in joins as though they were normal tables or views.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
    SELECT
      &lt;select list&gt;
    FROM
      &lt;table reference list&gt;

    &lt;table reference list&gt; ::= &lt;table reference&gt; [{&lt;comma&gt; &lt;table reference&gt;}...]

    &lt;table reference&gt; ::=
        &lt;table primary&gt;
      | &lt;joined table&gt;

    &lt;table primary&gt; ::=
        &lt;table&gt; [[AS] &lt;correlation name&gt;]
      | &lt;derived table&gt;

    &lt;derived table> ::=
        &lt;query expression&gt; [[AS] &lt;correlation name&gt;]
          [&lt;left paren&gt; &lt;derived column list&gt; &lt;right paren&gt;]

    &lt;derived column list&gt; ::= &lt;column name&gt; [{&lt;comma&gt; &lt;column name&gt;}...]
      </programlisting>
      <para><emphasis role="bold">Examples</emphasis></para>
      <para>a) Simple derived table:</para>
      <programlisting>
  SELECT
    *
  FROM
    (SELECT
       RDB$RELATION_NAME, RDB$RELATION_ID
     FROM
       RDB$RELATIONS) AS R (RELATION_NAME, RELATION_ID)
      </programlisting>

      <para>b) Aggregate on a derived table which also contains an aggregate</para>
      <programlisting>
  SELECT
    DT.FIELDS,
    Count(*)
  FROM
    (SELECT
       R.RDB$RELATION_NAME,
       Count(*)
     FROM
       RDB$RELATIONS R
       JOIN RDB$RELATION_FIELDS RF ON (RF.RDB$RELATION_NAME = R.RDB$RELATION_NAME)
     GROUP BY
       R.RDB$RELATION_NAME) AS DT (RELATION_NAME, FIELDS)
  GROUP BY
    DT.FIELDS
      </programlisting>

      <para>c) UNION and ORDER BY example:</para>
      <programlisting>
  SELECT
    DT.*
  FROM
    (SELECT
       R.RDB$RELATION_NAME,
       R.RDB$RELATION_ID
     FROM
       RDB$RELATIONS R
     UNION ALL
     SELECT
       R.RDB$OWNER_NAME,
       R.RDB$RELATION_ID
     FROM
       RDB$RELATIONS R
     ORDER BY
       2) AS DT
  WHERE
    DT.RDB$RELATION_ID &lt;= 4
      </programlisting>
      <para><emphasis role="bold">Points to Note</emphasis></para>
      <itemizedlist>
        <listitem><para>Every column in the derived table must have a name. Unnamed expressions like
    constants should be added with an alias or the column list should be used.</para></listitem>
        <listitem><para>The number of columns in the column list should be the same as the number of
    columns from the query expression.</para></listitem>
        <listitem><para>The optimizer can handle a derived table very efficiently.  However, if the
    derived table is involved in an inner join and contains a subquery, then no join order can be 
    established and performance will suffer.</para></listitem>
      </itemizedlist>
    </section><!-- level 2 -->

    <section id="rnfb20x-dml-rb-retain" xreflabel="ROLLBACK RETAIN Syntax"><!-- Level 2 section -->
      <sectioninfo>
        <title>ROLLBACK RETAIN Syntax</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>The ROLLBACK RETAIN statement is now supported in DSQL.</para>
      <para>A <quote>rollback retaining</quote> feature was introduced in InterBase 6.0, but this rollback mode
      could be used only via an API call to <firstterm>isc_rollback_retaining()</firstterm>.  By contrast,
      <quote>commit retaining</quote> could be used either via an API call to
      <firstterm>isc_commit_retaining()</firstterm> or by using a DSQL <literal>COMMIT RETAIN</literal>
      statement.</para>

      <para>Firebird 2.0 adds an optional <literal>RETAIN</literal> clause to the DSQL <literal>ROLLBACK</literal>
      statement to make it consistent with COMMIT [RETAIN].</para>
      <para><emphasis>Syntax pattern</emphasis>: follows that of COMMIT RETAIN.</para>
    </section>

    <section id="rnfb20x-dml-rows" xreflabel="ROWS Syntax"><!-- Level 2 section -->
      <sectioninfo>
        <title>ROWS Syntax</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>ROWS syntax is used to limit the number of rows retrieved from a select expression. For an uppermost-level
    select statement, it would specify the number of rows to be returned to the host program.  A more
    understandable alternative to the FIRST/SKIP clauses, the ROWS syntax accords with the latest SQL standard and
    brings some extra benefits. It can be used in unions, any kind of subquery and in UPDATE or DELETE statements.</para>

      <para>It is available in both DSQL and PSQL.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
   SELECT ...
     [ORDER BY &lt;expr_list&gt;]
     ROWS &lt;expr1&gt; [TO &lt;expr2&gt;]
      </programlisting>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para>1.</para>
      <programlisting>
  SELECT * FROM T1
    UNION ALL
  SELECT * FROM T2
    ORDER BY COL
    ROWS 10 TO 100
      </programlisting>
      <para>2.</para>
      <programlisting>
   SELECT COL1, COL2,
     ( SELECT COL3 FROM T3 ORDER BY COL4 DESC ROWS 1 )
   FROM T4
      </programlisting>

      <para>3.</para>
      <programlisting>
   DELETE FROM T5
     ORDER BY COL5
     ROWS 1
      </programlisting>

      <para><emphasis role="bold">Points to Note</emphasis></para>

      <orderedlist>
      <listitem><para>When &lt;expr2&gt; is omitted, then ROWS &lt;expr1&gt; is semantically equivalent to
      FIRST &lt;expr1&gt;. When both &lt;expr1&gt; and &lt;expr2&gt; are used, then &nbsp; &nbsp;ROWS &lt;expr1&gt;
      TO &lt;expr2&gt; means the same as &nbsp; &nbsp;FIRST (&lt;expr2&gt; - &lt;expr1&gt; + 1)
      SKIP (&lt;expr1&gt; - 1)</para></listitem>
      <listitem><para>There is nothing that is semantically equivalent to a SKIP clause used without a
      FIRST clause.</para></listitem>
      </orderedlist>
    </section>

    <section id="rnfb20x-dml-union"><!-- Level 2 section -->
      <title>Enhancements to UNION Handling</title>
      <para>The rules for UNION queries have been improved as follows:</para>

        <section id="rnfb20x-dml-union-distinct" xreflabel="UNION DISTINCT"><!-- Level 3 section -->
        <sectioninfo>
          <title>UNION DISTINCT Keyword Implementation</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <para>UNION DISTINCT is now allowed as a synonym for simple UNION, in accordance with the SQL-99
        specification. It is a minor change: DISTINCT is the default mode, according to the standard.  Formerly,
        Firebird did not support the explicit inclusion of the optional keyword DISTINCT.</para>
        <para><emphasis>Syntax Pattern</emphasis></para>
        <programlisting>
  UNION [{DISTINCT | ALL}]
        </programlisting>
        </section>

        <section id="rnfb20x-dml-union-coercion" xreflabel="Improved Type Coercion in UNIONs"><!-- Level 3 section -->
        <sectioninfo>
          <title>Improved Type Coercion in UNIONs</title>
          <author><firstname>A.</firstname><surname>Brinkman</surname></author>
        </sectioninfo>
        <para>Automatic resolution of the data type of the result of an aggregation over 
        values of compatible data types, such as case expressions and columns at the 
        same position in a union query expression, now uses smarter rules.</para>

        <para><emphasis role="bold">Syntax Rules</emphasis></para>

        <para>Let DTS be the set of data types over which we must determine the final
   result data type.</para>
        <orderedlist>
        <listitem><para>All of the data types in DTS shall be comparable.</para></listitem>

        <listitem><para>Case:</para>

          <orderedlist type="a">
          <listitem><para>If any of the data types in DTS is character string, then:</para>
            <orderedlist type="i">
            <listitem><para>If any of the data types in DTS is variable-length character string, then the result
            data type is variable-length character string with maximum length in characters equal to the largest
            maximum amongst the data types in DTS.</para></listitem>
            <listitem><para>Otherwise, the result data type is fixed-length character string with length in characters
            equal to the maximum of the lengths in characters of the data types in DTS.</para></listitem>
            <listitem><para>The characterset/collation is used from the first character string data type
            in DTS.</para></listitem>
            </orderedlist>
          </listitem>
          <listitem><para>If all of the data types in DTS are exact numeric, then the result data type is exact
          numeric with scale equal to the maximum of the scales of the data types in DTS and the maximum precision of
          all data types in DTS.</para>

          <note>
          <para>NOTE :: Checking for precision overflows is done at run-time only.
          The developer should take measures to avoid the aggregation resolving to a precision overflow.</para>
          </note>
          </listitem>

          <listitem><para>If any data type in DTS is approximate numeric, then each data type in DTS shall be numeric
          else an error is thrown.</para></listitem>

          <listitem><para>If some data type in DTS is a date/time data type, then every data type in DTS shall be a
          date/time data type having the same date/time type.</para></listitem>

          <listitem><para>If any data type in DTS is BLOB, then each data type in DTS shall be BLOB and all with the
          same sub-type.</para></listitem>
          </orderedlist>
        </listitem>
        </orderedlist>
        </section>

        <section id="rnfb20x-dml-union-subqueries" xreflabel="UNIONs Allowed in ANY/ALL/IN Subqueries"><!-- Level 3 section -->
        <sectioninfo>
          <title>UNIONs Allowed in ANY/ALL/IN Subqueries</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
          <para>The subquery element of an ANY, ALL or IN search may now be a UNION query.</para>
        </section>
      </section>


      <section id="rnfb20x-dml-nulls"><!-- Level 2 section -->
      <title>Enhancements to NULL Logic</title>
      <para>The following features involving NULL in DSQL have been implemented:</para>

        <section id="rnfb20x-dml-nulls-distinct" xreflabel="New [NOT] DISTINCT Predicate"><!-- Level 3 section -->
        <sectioninfo>
        <!-- Altered in 2.0.1 -->
          <title>New [NOT] DISTINCT Test Treats Two NULL Operands as Equal</title>
          <author><firstname>O.</firstname><surname>Loa, D. Yemanov</surname></author>
        </sectioninfo>
        <para>A new equivalence predicate behaves exactly like the equality/inequality predicates,
        but, instead of testing for equality, it tests whether one operand is distinct from the other.</para>
        <para> Thus, IS NOT DISTINCT treats (NULL equals NULL) as if it were true, since one NULL
        (or expression resolving to NULL) is not distinct from another.  It is available in both
        DSQL and PSQL.</para>
<!-- End of change in 2.0.1 -->
        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
   &lt;value&gt; IS [NOT] DISTINCT FROM &lt;value&gt;
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>

        <para>1.</para>
        <programlisting>
   SELECT * FROM T1
     JOIN T2
       ON T1.NAME IS NOT DISTINCT FROM T2.NAME;
        </programlisting>

        <para>2.</para>
        <programlisting>
   SELECT * FROM T
     WHERE T.MARK IS DISTINCT FROM 'test';
        </programlisting>

        <note>
        <title>Points to note</title>
        <orderedlist>
        <listitem>
          <para>Because the DISTINCT predicate considers that two NULL values are not distinct, it never
          evaluates to the truth value UNKNOWN.  Like the IS [NOT] NULL predicate, it can only be True or
          False.</para>
          <tip>
            <title>Read More About NULL</title>
            <para>For more understanding of the way NULL comparisons are evaluated, please read
            the <emphasis>Firebird Null Guide</emphasis>, available through
            the <ulink url="http://firebirdsql.org/index.php?op=doc#category_1">Documentation Index</ulink> at
            the Firebird website.</para>
          </tip>
        </listitem>
        <listitem><para>The NOT DISTINCT predicate can be optimized using an index, if one is available.</para>
        </listitem>
        </orderedlist>
        </note>
        </section>

        <section id="rnfb20x-dml-nulls-equivalence" xreflabel="NULL Comparison Rule Relaxed"><!-- Level 3 section -->
        <sectioninfo>
          <title>NULL Comparison Rule Relaxed</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <para>A NULL literal can now be treated as a value in all expressions without returning a syntax error. You
        may now specify expressions such as</para>
        <programlisting>
  A = NULL
  B &gt; NULL
  A + NULL
  B || NULL
        </programlisting>
        <note>
        <para>All such expressions evaluate to NULL.  The change does not alter nullability-aware semantics of the
        engine, it simply relaxes the syntax restrictions a little.</para>
        </note>
      </section>

      <section id="rnfb20x-dml-nulls-ordering" xreflabel="NULLs Ordering Changed"><!-- Level 3 section -->
        <sectioninfo>
          <title>NULLs Ordering Changed to Comply with Standard</title>
          <author><firstname>N.</firstname><surname>Samofatov</surname></author>
        </sectioninfo>
        <para>Placement of nulls in an ordered set has been changed to accord with the SQL standard that null ordering
        be consistent, i.e. if ASC[ENDING] order puts them at the bottom, then DESC[ENDING] puts them at the top;
        or vice-versa. This applies only to databases created under an on-disk structure of 11 or higher, since it 
        needs to use the index changes in order to work.</para>
<!-- inserted in 2.0.1 -->
        <important>
          <para>If you override the default nulls placement, no index can be used for sorting.  That is, no index
          will be used for an ASCENDING sort if NULLS LAST is specified, nor for a DESCENDING sort if NULLS FIRST
          is specified.</para>
        </important>
<!-- -->
        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  Database:  proc.fdb
  SQL&gt; create table gnull(a int);
  SQL&gt; insert into gnull values(null);
  SQL&gt; insert into gnull values(1);
  SQL&gt; select a from gnull order by a;
             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a asc;

             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a desc;

             A
  ============
             1
        &lt;null&gt;

  SQL&gt; select a from gnull order by a asc nulls first;

             A
  ============
        &lt;null&gt;
             1

  SQL&gt; select a from gnull order by a asc nulls last;

             A
  ============
             1
        &lt;null&gt;


  SQL&gt; select a from gnull order by a desc nulls last;

             A
  ============
             1
        &lt;null&gt;

  SQL&gt; select a from gnull order by a desc nulls first;

             A
  ============
        &lt;null&gt;
             1
        </programlisting>
      </section>
    </section>

    <section id="rnfb20x-dml-complex-dml" xreflabel="UNION Sets in Subquery Constructs"><!-- Level 2 section -->
      <sectioninfo>
        <title>Subqueries and INSERT Statements Can Now Accept UNION Sets</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>SELECT specifications used in subqueries and in INSERT INTO &lt;insert-specification&gt;
      SELECT.. statements can now specify a UNION set.</para>
    </section>

    <section id="rnfb20x-dml-extensions"><!-- Level 2 section -->
      <sectioninfo>
        <title>New Extensions to UPDATE and DELETE Syntaxes</title>
        <author><firstname>O.</firstname><surname>Loa</surname></author>
      </sectioninfo>
      <para>ROWS specifications and PLAN and ORDER BY clauses can now be used in UPDATE and DELETE statements.</para>

      <para>Users can now specify explicit plans for UPDATE/DELETE statements in order to optimize them manually.
      It is also possible to limit the number of affected rows with a ROWS clause, optionally used in combination
      with an ORDER BY clause to have a sorted recordset.</para>

      <para><emphasis>Syntax Pattern</emphasis></para>
      <programlisting>
  UPDATE ... SET ... WHERE ...
  [PLAN &lt;plan items&gt;]
  [ORDER BY &lt;value list&gt;]
  [ROWS &lt;value&gt; [TO &lt;value&gt;]]
      </programlisting>

      <para>or</para>

      <programlisting>
  DELETE ... FROM ...
  [PLAN &lt;plan items&gt;]
  [ORDER BY &lt;value list&gt;]
  [ROWS &lt;value&gt; [TO &lt;value&gt;]]
      </programlisting>

    </section>

    <section id="rnfb20x-dml-context" xreflabel="Extended Context Variables"><!-- Level 2 section -->
      <title>Extended Context Variables</title>
      <para>A number of new facilities have been added to extend the context information that can be
      retrieved:</para>

        <section id="rnfb20x-dml-context-subsecond"><!-- Level 3 section -->
        <sectioninfo>
          <title>Sub-second Values Enabled for Time and DateTime Variables</title>
          <author><firstname>D.</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
          <section id="rnfb20x-dml-context-subsecond-milli"><!-- Level 4 section -->
          <title>CURRENT_TIMESTAMP, 'NOW' Now Return Milliseconds</title>
          <para>The context variable CURRENT_TIMESTAMP and the date/time literal 'NOW' will now return the sub-second
        time part in milliseconds.</para>
          </section><!-- 4 -->
          <section id="rnfb20x-dml-context-subsecond-other"><!-- Level 4 section -->
          <title>Seconds Precision Enabled for CURRENT_TIME and CURRENT_TIMESTAMP</title>
          <para>CURRENT_TIME and CURRENT_TIMESTAMP now optionally allow seconds precision</para>

          <para>The feature is available in both DSQL and PSQL.</para>
          <para><emphasis role="bold">Syntax Pattern</emphasis></para>
          <programlisting>
    CURRENT_TIME [(&lt;seconds precision&gt;)]
    CURRENT_TIMESTAMP [(&lt;seconds precision&gt;)]
          </programlisting>

          <para><emphasis role="bold">Examples</emphasis></para>
          <programlisting>
    1. SELECT CURRENT_TIME FROM RDB$DATABASE;
    2. SELECT CURRENT_TIME(3) FROM RDB$DATABASE;
    3. SELECT CURRENT_TIMESTAMP(3) FROM RDB$DATABASE;
          </programlisting>

          <note>
          <orderedlist>
          <listitem><para>The maximum possible precision is 3 which means accuracy of 1/1000 second
       (one millisecond). This accuracy may be improved in the future versions.</para></listitem>
          <listitem><para>If no seconds precision is specified, the following values are implicit:</para>
            <itemizedlist>
            <listitem><para>0 for CURRENT_TIME</para></listitem>
            <listitem><para>3 for CURRENT_TIMESTAMP</para></listitem>
            </itemizedlist>
          </listitem>
          </orderedlist>
          </note>
          </section><!-- 4 -->
        </section><!-- 3 -->

        <section id="rnfb20x-dml-context-ns"><!-- Level 3 section -->
        <sectioninfo>
          <title>New System Functions to Retrieve Context Variables</title>
          <author><firstname>N.</firstname><surname>Samofatov</surname></author>
        </sectioninfo>
        <para>Values of context variables can now be obtained using the system functions RDB$GET_CONTEXT and
        RDB$SET_CONTEXT. These new built-in functions give access through SQL to some information about the current
    connection and current transaction. They also provide a mechanism to retrieve user context data and associate it
    with the transaction or connection.</para>

       <para><emphasis role="bold">Syntax Pattern</emphasis></para>
       <programlisting>
    RDB$SET_CONTEXT( &lt;namespace&gt;, &lt;variable&gt;, &lt;value&gt; )
    RDB$GET_CONTEXT( &lt;namespace&gt;, &lt;variable&gt; )
       </programlisting>

       <para>These functions are really a form of external function that exists inside the database instead of being
       called from a dynamically loaded library.  The following declarations are made automatically by the engine at
       database creation time:</para>

       <para><emphasis role="bold">Declaration</emphasis></para>

       <programlisting>
  DECLARE EXTERNAL FUNCTION RDB$GET_CONTEXT
      VARCHAR(80),
      VARCHAR(80)
  RETURNS VARCHAR(255) FREE_IT;

  DECLARE EXTERNAL FUNCTION RDB$SET_CONTEXT
      VARCHAR(80),
      VARCHAR(80),
      VARCHAR(255)
  RETURNS INTEGER BY VALUE;
       </programlisting>

       <para><emphasis role="bold">Usage</emphasis></para>

       <para>RDB$SET_CONTEXT and RDB$GET_CONTEXT set and retrieve the current value of a context variable. Groups of
       context variables with similar properties are identified by Namespace identifiers. The namespace determines the 
       usage rules, such as whether the variables may be read and written to, and by whom.</para>
       <note>
       <para>Namespace and variable names are case-sensitive.</para>
       </note>

       <itemizedlist>
       <listitem><para>RDB$GET_CONTEXT retrieves current value of a variable. If the variable does not exist
       in namespace, the function returns NULL.</para></listitem>
       <listitem><para>RDB$SET_CONTEXT sets a value for specific variable, if it is writable. The function returns a
       value of   1 if the variable existed before the call and 0 otherwise.</para></listitem>
       <listitem><para>To delete a variable from a context, set its value to NULL.</para></listitem>
       </itemizedlist>
         <section id="rnfb20x-dml-context-ns-pd"><!-- Level 4 section -->
          <title>Pre-defined Namespaces</title>
          <para>A fixed number of pre-defined namespaces is available:</para>
            <section id="rnfb20x-dml-context-ns-pd-user-session"><!-- Level 5 section -->
            <title>USER_SESSION</title>
            <para>Offers access to session-specific user-defined variables. You can define and set values for variables
            with any name in this context.</para>
            </section>
            <section id="rnfb20x-dml-context-ns-pd-user-transaction"><!-- Level 5 section -->
            <title>USER_TRANSACTION</title>
            <para>Offers similar possibilities for individual transactions.</para>
            </section>
            <section id="rnfb20x-dml-context-ns-pd-system"><!-- Level 5 section -->
            <title>SYSTEM</title>
            <para>Provides read-only access to the following variables:</para>
            <itemizedlist>
            <listitem>
              <para>NETWORK_PROTOCOL :: The network protocol used by client to connect. Currently used
              values: <quote>TCPv4</quote>, <quote>WNET</quote>, <quote>XNET</quote> and NULL.</para>
            </listitem>
            <listitem><para>CLIENT_ADDRESS :: The wire protocol address of the remote client, represented as a string.
            The value is an IP address in form &quot;xxx.xxx.xxx.xxx&quot; for TCPv4 protocol;  the local process ID
            for XNET protocol;  and NULL for any other protocol.</para></listitem>
            <listitem><para>DB_NAME :: Canonical name of the current database. It is either the alias name (if
            connection via file names is disallowed DatabaseAccess = NONE) or, otherwise, the fully expanded database
            file name.</para></listitem>
            <listitem><para>ISOLATION_LEVEL :: The isolation level of the current transaction. The returned value will
            be one of &quot;READ COMMITTED&quot;, &quot;SNAPSHOT&quot;, &quot;CONSISTENCY&quot;.</para></listitem>
            <listitem><para>TRANSACTION_ID :: The numeric ID of the current transaction. The returned value is the same
            as would be returned by the CURRENT_TRANSACTION pseudo-variable.</para></listitem>
            <listitem><para>SESSION_ID :: The numeric ID of the current session. The returned value is the same as
            would be returned by the CURRENT_CONNECTION pseudo-variable.</para></listitem>
            <listitem><para>CURRENT_USER :: The current user. The returned value is the same as would be returned by
            the CURRENT_USER pseudo-variable or the predefined variable USER.</para></listitem>
            <listitem><para>CURRENT_ROLE :: Current role for the connection. Returns the same value as the CURRENT_ROLE
            pseudo-variable.</para></listitem>
            </itemizedlist>
            </section>
          </section>
          <section id="rnfb20x-dml-context-ns-notes"><!-- Level 4 section -->
          <title>Notes</title>
          <para>To avoid DoS attacks against the Firebird Server, the number of variables stored for each transaction
          or session context is limited to 1000.</para>

          <para><emphasis role="bold">Example of Use</emphasis></para>
          <programlisting>
   set term ^;
   create procedure set_context(User_ID varchar(40), Trn_ID integer) as
   begin
     RDB$SET_CONTEXT('USER_TRANSACTION', 'Trn_ID', Trn_ID);
     RDB$SET_CONTEXT('USER_TRANSACTION', 'User_ID', User_ID);
   end ^

  create table journal (
     jrn_id integer not null primary key,
     jrn_lastuser varchar(40),
     jrn_lastaddr varchar(255),
     jrn_lasttransaction integer
  )^

CREATE TRIGGER UI_JOURNAL FOR JOURNAL BEFORE INSERT OR UPDATE
  as
  begin
    new.jrn_lastuser = rdb$get_context('USER_TRANSACTION', 'User_ID');
    new.jrn_lastaddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');
    new.jrn_lasttransaction = rdb$get_context('USER_TRANSACTION', 'Trn_ID');
  end ^
  commit ^
  execute procedure set_context('skidder', 1) ^

  insert into journal(jrn_id) values(0) ^
  set term ;^
          </programlisting>

          <para>Since rdb$set_context returns 1 or zero, it can be made to work with a simple SELECT
          statement.</para>
          <para><emphasis role="bold">Example</emphasis></para>
          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', 'ru') 
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                0
          </programlisting>

<para>0 means not defined already; we have set it to 'ru' </para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', 'ca')
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                1
          </programlisting>

<para>1 means it was defined already; we have changed it to 'ca' </para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', NULL)
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                1
          </programlisting>

<para>1 says it existed before;  we have changed it to NULL, i.e. undefined it.</para>

          <programlisting>
  SQL&gt; select rdb$set_context('USER_SESSION', 'Nickolay', NULL)
  CNT&gt; from rdb$database;

  RDB$SET_CONTEXT
  ===============
                0
          </programlisting>

<para>0, since nothing actually happened this time: it was already undefined .</para>
          </section><!-- 4 -->
        </section><!-- 3 -->
      </section><!-- 2 -->

      <section id="rnfb20x-dml-plans" xreflabel="Query Plans Improvements"><!-- Level 2 section -->
      <sectioninfo>
        <title>Improvements in Handling User-specified Query Plans</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <orderedlist>
      <listitem><para>Plan fragments are propagated to nested levels of joins, enabling manual optimization of complex
      outer joins</para></listitem>
      <listitem><para>A user-supplied plan will be checked for correctness in outer joins</para></listitem>
      <listitem><para>Short-circuit optimization for user-supplied plans has been added</para></listitem>
      <listitem><para>A user-specified access path can be supplied for any SELECT-based statement or clause</para></listitem>
      </orderedlist>
      <para><emphasis role="bold">Syntax rules</emphasis></para>

      <para>The following schema describing the syntax rules should be helpful when composing plans.</para>

      <programlisting>
PLAN ( { &lt;stream_retrieval&gt; | &lt;sorted_streams&gt; | &lt;joined_streams&gt; } )

&lt;stream_retrieval&gt; ::= { &lt;natural_scan&gt; | &lt;indexed_retrieval&gt; | 
    &lt;navigational_scan&gt; }

&lt;natural_scan&gt; ::= &lt;stream_alias&gt; NATURAL

&lt;indexed_retrieval&gt; ::= &lt;stream_alias&gt; INDEX ( &lt;index_name&gt; 
    [, &lt;index_name&gt; ...] )

&lt;navigational_scan&gt; ::= &lt;stream_alias&gt; ORDER &lt;index_name&gt;
    [ INDEX ( &lt;index_name&gt; [, &lt;index_name&gt; ...] ) ]

&lt;sorted_streams&gt; ::= SORT ( &lt;stream_retrieval&gt; )

&lt;joined_streams&gt; ::= JOIN ( &lt;stream_retrieval&gt;, &lt;stream_retrieval&gt; 
    [, &lt;stream_retrieval&gt; ...] ) 
    | [SORT] MERGE ( &lt;sorted_streams&gt;, &lt;sorted_streams&gt; )
      </programlisting>

      <para><emphasis role="bold">Details</emphasis></para>

      <para><emphasis>Natural scan</emphasis> means that all rows are fetched in their natural storage order.  Thus,
      all pages must be read before search criteria are validated.</para>
      <para><emphasis>Indexed retrieval</emphasis> uses an index range scan to find row ids that match the given
    search criteria. The found matches are combined in a sparse bitmap which is sorted
    by page numbers, so every data page will be read only once. After that the table
    pages are read and required rows are fetched from them.</para>

      <para><emphasis>Navigational scan</emphasis> uses an index to return rows in the given order, if such an
    operation is appropriate.-</para>

      <itemizedlist>
      <listitem><para>The index b-tree is walked from the leftmost node to the rightmost one.</para></listitem>
      <listitem><para>If any search criterion is used on a column specified in an ORDER BY clause, the
    navigation is limited to some subtree path, depending on a predicate.</para></listitem>
      <listitem><para>If any search criterion is used on other columns which are indexed, then a range index scan is performed
    in advance and every fetched key has its row id validated against the resulting bitmap.
    Then a data page is read and the required row is fetched.</para></listitem>
      </itemizedlist>
      <note>
      <para>Note that a navigational scan incurs random page I/O, as reads are not optimized.</para>
      </note>

      <para>A <emphasis>sort operation</emphasis> performs an external sort of the given stream retrieval.</para>
      <para>A <emphasis>join</emphasis> can be performed either via the nested loops algorithm (JOIN plan) or via
    the sort merge algorithm (MERGE plan).-</para>

      <itemizedlist>
      <listitem><para>An <emphasis>inner nested loop join</emphasis> may contain as many streams as are required to be joined.
    All of them are equivalent.</para></listitem>
      <listitem><para>An <emphasis>outer nested loops join</emphasis> always operates with two streams, so you'll see
    nested JOIN clauses in the case of 3 or more outer streams joined.</para></listitem>
      </itemizedlist>

      <para>A <emphasis>sort merge</emphasis> operates with two input streams which are sorted beforehand, then merged
    in a single run.</para>

      <para><emphasis role="bold">Examples</emphasis></para>
      <programlisting>
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS
    WHERE RDB$RELATION_NAME LIKE 'RDB$%'
    PLAN (RDB$RELATIONS NATURAL)
    ORDER BY RDB$RELATION_NAME

    SELECT R.RDB$RELATION_NAME, RF.RDB$FIELD_NAME
    FROM RDB$RELATIONS R
      JOIN RDB$RELATION_FIELDS RF
      ON R.RDB$RELATION_NAME = RF.RDB$RELATION_NAME
    PLAN MERGE (SORT (R NATURAL), SORT (RF NATURAL))
      </programlisting>

      <para><emphasis role="bold">Notes</emphasis></para>

      <orderedlist type="a">
      <listitem><para>A PLAN clause may be used in all select expressions, including subqueries,
       derived tables and view definitions. It can be also used in UPDATE and DELETE
       statements, because they're implicitly based on select expressions.</para></listitem>
      <listitem><para>If a PLAN clause contains some invalid retrieval description, then either an
       error will be returned or this bad clause will be silently ignored, depending
       on severity of the issue.</para></listitem>
      <listitem><para>ORDER &lt;navigational_index&gt; INDEX ( &lt;filter_indices&gt; ) kind of plan is reported
       by the engine and can be used in the user-supplied plans starting with FB 2.0.</para></listitem>
      </orderedlist>

    </section>

    <section id="rnfb20x-dml-sorting"><!-- Level 2 section -->
      <sectioninfo>
        <title>Improvements in Sorting</title>
        <author><firstname>A.</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Some useful improvements have been made to SQL sorting operations:</para>
        <section id="rnfb20x-dml-sorting-both" xreflabel="GROUP or ORDER by Alias Name"><!-- Level 3 section -->
        <title>Order By or Group By &lt;alias-name&gt;</title>
        <para>Column aliases are now allowed in both these clauses.</para>
        <para><emphasis role="bold">Examples:</emphasis></para>
        <orderedlist>
        <listitem><para>ORDER BY</para>
        <programlisting>
        SELECT RDB$RELATION_ID AS ID
        FROM RDB$RELATIONS
        ORDER BY ID
        </programlisting>
        </listitem>
        <listitem><para>GROUP BY</para>
        <programlisting>
        SELECT RDB$RELATION_NAME AS ID, COUNT(*)
        FROM RDB$RELATION_FIELDS
        GROUP BY ID
        </programlisting>
        </listitem>
        </orderedlist>

        </section>
        <section id="rnfb20x-dml-sorting-groupby-expr" xreflabel="GROUP BY Arbitrary Expressions"><!-- Level 3 section -->
        <title>GROUP BY Arbitrary Expressions</title>
        <para> A GROUP BY condition can now be any valid expression.</para>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
  ...
    GROUP BY
    SUBSTRING(CAST((A * B) / 2 AS VARCHAR(15)) FROM 1 FOR 2)
        </programlisting>
        </section>

        <section id="rnfb20x-dml-sorting-orderby" xreflabel="Order * Sets by Implicit Degree Number"><!-- Level 3 section -->
        <title>Order * Sets by Implicit Degree Number</title>
        <para>Order by degree (ordinal column position) now works on a select * list.</para>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
   SELECT *
     FROM RDB$RELATIONS
     ORDER BY 9
        </programlisting>
        </section><!-- Level 3 -->

        <section id="rnfb20x-dml-sorting-gotcha"><!-- Level 3 section -->
        <title>Parameters and Ordinal Sorts--a <quote>Gotcha</quote></title>
        <para>According to grammar rules, since v.1.5, ORDER BY &lt;value_expression&gt; is allowed
        and &lt;value_expression&gt; could be a variable or a parameter.  It is tempting to assume that
        ORDER BY &lt;degree_number&gt; could thus be validly represented as a replaceable input parameter, or an
        expression containing a parameter.</para>

        <para>However, while the DSQL parser does not reject the parameterised ORDER BY clause expression if it
        resolves to an integer, the optimizer requires an absolute, constant value in order to identify
        the <emphasis>position in the output list</emphasis> of the ordering column or derived field.  If a
        parameter is accepted by the parser, the output will undergo a <quote>dummy sort</quote> and the returned
        set will be unsorted.</para>

        </section><!-- Level 3 -->
      </section><!-- Level 2 -->

      <section id="rnfb20x-dml-nextvalue" xreflabel="NEXT VALUE FOR"><!-- Level 2 section -->
      <sectioninfo>
        <title>NEXT VALUE FOR Expression</title>
        <author><firstname>D.</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>Added SQL-99 compliant NEXT VALUE FOR &lt;sequence_name&gt; expression as a synonym
      for GEN_ID(&lt;generator-name&gt;, 1), complementing the introduction of CREATE SEQUENCE syntax as
      the SQL standard equivalent of CREATE GENERATOR.</para>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para>1.</para>
      <programlisting>
   SELECT GEN_ID(S_EMPLOYEE, 1) FROM RDB$DATABASE;
      </programlisting>
      <para>2.</para>
      <programlisting>
   INSERT INTO EMPLOYEE (ID, NAME)
     VALUES (NEXT VALUE FOR S_EMPLOYEE, 'John Smith');
      </programlisting>

      <note>
      <orderedlist>
      <listitem><para>Currently, increment (&quot;step&quot;) values not equal to 1 (one) can be used only by calling
       the GEN_ID function. Future versions are expected to provide full support for SQL-99 sequence generators,
       which allows the required increment values to be specified at the DDL level.  Unless there is a vital need to
       use a step value that is not 1, use of a NEXT VALUE FOR value expression instead of the GEN_ID function is
       recommended.</para></listitem>

      <listitem><para>GEN_ID(&lt;name&gt;, 0) allows you to retrieve the current sequence value, but it should never
       be used in insert/update statements, as it produces a high risk of uniqueness violations in a concurrent
       environment.</para></listitem>
      </orderedlist>
      </note>
    </section><!-- Level 2 -->
  </section><!-- Level 1 -->

    <!-- ///////////////////////////////////////////////////////////////////////////////////// -->
    <!-- ARTICLES -->
    <!-- ///////////////////////////////////////////////////////////////////////////////////// -->

  <section id="rnfb210-articles">
    <title>Articles</title>

    <section id="rnfb20x-dml-select-syntax" xreflabel="Select Statement &amp; Expression Syntax"><!-- Level 1 section -->
      <sectioninfo>
        <title>SELECT Statement &amp; Expression Syntax</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para><emphasis>About the semantics</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>A select statement is used to return data to the caller (PSQL module or the client program)</para>
        </listitem>
        <listitem>
          <para>Select expressions retrieve parts of data that construct columns that can be in either the final
          result set or in any of the intermediate sets. Select expressions are also known as subqueries.</para>
        </listitem>
      </itemizedlist>

      <para><emphasis>Syntax rules</emphasis></para>
      <programlisting>
  &lt;select statement&gt; ::=
    &lt;select expression&gt; [FOR UPDATE] [WITH LOCK]

  &lt;select expression&gt; ::=
    &lt;query specification&gt; [UNION [{ALL | DISTINCT}] &lt;query specification&gt;]

  &lt;query specification&gt; ::=
    SELECT [FIRST &lt;value&gt;] [SKIP &lt;value&gt;] &lt;select list&gt;
    FROM &lt;table expression list&gt;
    WHERE &lt;search condition&gt;
    GROUP BY &lt;group value list&gt;
    HAVING &lt;group condition&gt;
    PLAN &lt;plan item list&gt;
    ORDER BY &lt;sort value list&gt;
    ROWS &lt;value> [TO &lt;value&gt;]

  &lt;table expression> ::=
    &lt;table name&gt; | &lt;joined table&gt; | &lt;derived table&gt;

  &lt;joined table> ::=
    {&lt;cross join&gt; | &lt;qualified join&gt;}

  &lt;cross join&gt; ::=
    &lt;table expression&gt; CROSS JOIN &lt;table expression&gt;

  &lt;qualified join> ::=
    &lt;table expression&gt; [{INNER | {LEFT | RIGHT | FULL} [OUTER]}] JOIN &lt;table expression&gt;
    ON &lt;join condition&gt;

  &lt;derived table> ::=
    '(' &lt;select expression&gt; ')'
    </programlisting>

      <para><emphasis>Conclusions</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>FOR UPDATE mode and row locking can only be performed for a final dataset,
          they cannot be applied to a subquery</para>
        </listitem>
        <listitem>
          <para>Unions are allowed inside any subquery</para>
        </listitem>
        <listitem>
          <para>Clauses FIRST, SKIP, PLAN, ORDER BY, ROWS are allowed for any subquery</para>
        </listitem>
      </itemizedlist>

      <para><emphasis>Notes</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>Either FIRST/SKIP or ROWS is allowed, but a syntax error is thrown if you try to mix the syntaxes</para>
        </listitem>
        <listitem>
          <para>An INSERT statement accepts a select expression to define a set to be inserted into a table. Its
          SELECT part supports all the features defined for select statments/expressions</para>
        </listitem>
        <listitem>
          <para>UPDATE and DELETE statements are always based on an implicit cursor iterating through its target
          table and limited with the WHERE clause. You may also specify the final parts of the select expression
          syntax to limit the number of affected rows or optimize the statement.</para>
          <para>Clauses allowed at the end of UPDATE/DELETE statements are PLAN, ORDER BY and ROWS.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="rnfb210-dataresult" xreflabel="Data Type of an Aggregation Result"><!-- Level 2 section -->
      <sectioninfo>
        <title>Data Type of an Aggregation Result</title>
        <author>
          <firstname>Arno</firstname>
          <surname>Brinkman</surname>
        </author>
      </sectioninfo>
      <para>When aggregations, CASE evaluations and UNIONs for output columns are performed over a mix of comparable
      data types, the engine has to choose one data type for the result.  The developer often has to prepare a
      variable or buffer for such results and is mystified when a request returns a data type exception.  The rules
      followed by the engine in determining the data type for an output column under these conditions are explained
      here.</para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>Let DTS be the set of data types over which we must determine the final
           result data type.</para>
        </listitem>

        <listitem>
           <para>All of the data types in DTS shall be comparable.</para>
        </listitem>

        <listitem>
          <para>In the case that</para>
          <orderedlist numeration="loweralpha">
            <listitem>
              <para>any of the data types in DTS is character string</para>
              <orderedlist numeration="lowerroman">
                <listitem>
                  <para>If all data types in DTS are fixed-length character strings, then
                  the result is also a fixed-length character string; otherwise the result is
                  a variable-length character string.</para>
                  <para>The resulting string length, in characters, is equal to the maximum of
                  the lengths, in characters, of the data types in DTS.</para>
                </listitem>
                <listitem>
                 <para>The character set and collation used are taken from the data type of the
                 first character string in DTS.</para>
                </listitem>
              </orderedlist>
            </listitem>

            <listitem>
              <para>all of the data types in DTS are exact numeric</para>
              <para>the result data type is exact numeric with scale equal to the
              maximum of the scales of the data types in DTS and precision equal to the
              maximum precision of all data types in DTS.</para>
            </listitem>
            <listitem>
              <para>any data type in DTS is approximate numeric</para>
              <para>each data type in DTS must be numeric, otherwise an error is thrown.</para>
            </listitem>
            <listitem>
              <para>any data type in DTS is a date/time data type</para>
              <para>every data type in DTS must be a date/time type having
              the <emphasis>same date/time type</emphasis>, otherwise an error is thrown.</para>
            </listitem>
            <listitem>
              <para>any data type in DTS is BLOB</para>
              <para>each data type in DTS must be BLOB and all with the same sub-type.</para>
            </listitem>

          </orderedlist>
        </listitem>

      </orderedlist>
    </section>

    <section id="rnfb210-dml-datetimetyping" xreflabel="A Useful Trick with Date Literals"><!-- Level 2 section -->
      <sectioninfo>
        <title>A Useful Trick with Date Literals</title>
        <author><firstname>H.</firstname><surname>Borrie</surname></author>
      </sectioninfo>
      <para>In days gone by, before the advent of context variables like CURRENT_DATE, CURRENT_TIMESTAMP, et al., we
      had <firstterm>predefined date literals</firstterm>, such as 'NOW', 'TODAY', 'YESTERDAY' and so on.  These
      predefined date literals survive in Firebird's SQL language set and are still useful.</para>
      <para>In InterBase 5.x and lower, the following statement was <quote>legal</quote> and returned a DATE value (
      remembering that the DATE type then was what is now TIMESTAMP):</para>
      <programlisting>
select 'NOW' from rdb$database /* returns system date and time */
      </programlisting>
      <para>In a database of ODS 10 or higher, that statement returns the string 'NOW'.  We have had to learn to
      cast the date literal to get the result we want:</para>
      <programlisting>
select cast('NOW' as TIMESTAMP) from rdb$database
      </programlisting>

      <para>For a long time&mdash;probably since IB 6&mdash; there has been an undocumented
      <quote>short expression syntax</quote> for casting not just the predefined date/time literals but
      <emphasis>any</emphasis> date literals.  Actually, it is defined in the standard.  Most of us were just not
      aware that it was available.  It takes the form
      <filename>&lt;data type&gt; &lt;date literal&gt;</filename>.  Taking the CAST example above, the short syntax
      would be as follows:</para>
      <programlisting>
select TIMESTAMP 'NOW' from rdb$database
      </programlisting>
      <para>This short syntax can participate in other expressions.  The following example illustrates a date/time
      arithmetic operation on a predefined literal:</para>
      <programlisting>
update mytable
  set OVERDUE = 'T'
  where DATE 'YESTERDAY' - DATE_DUE > 10
      </programlisting>
    </section><!-- 2 -->

  </section>

</chapter>