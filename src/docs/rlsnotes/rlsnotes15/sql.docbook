
  <chapter id="rlsnotes15-sql">
  <chapterinfo>
    <title>SQL Language Enhancements</title>
  </chapterinfo>
  <para>A large number of additions and enhancements were made to the various subsets of Firebird's SQL language.</para>

    <section id="sql-any"><!-- Level 1 section -->
    <sectioninfo>
      <title>Changes affecting All SQL</title>
    </sectioninfo>

      <section id="sql-comment"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Enhancement to single-line comment marker</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <para>Single-line comments can be in any position in the line, not just the first.  For use in scripts, DSQL,
      stored procedures and triggers.</para>
      <para>So, in 1.5, the &quot;--&quot; marker can be used for a comment at the end of a line statement in a script,
      stored procedure, trigger or DSQL statement.  It can thus be used to &quot;comment out&quot; unwanted parts of
      statements.  All characters from the &quot;--&quot; marker until the next carriage return or line feed will be
      ignored.</para>

      <programlisting>
  ...
  WHERE COL1 = 9 OR COL2 = 99 -- OR COL3 = 999
      </programlisting>

      <para><emphasis role="bold">Previous implementation</emphasis> (v.1.0, Claudio Valderrama)</para>
      <programlisting>
  -- This is a comment
      </programlisting>

      <para>This new marker can be used for &quot;commenting out&quot; a single line of code in a script, DDL/DML
      statement, stored procedure or trigger.  The logic is to ignore characters is as follows:</para>

      <orderedlist>
        <listitem><para>Skip '--' if it is found as the first character pair following an end-of-line marker (LF on
        Linux/Unix, CRLF on Windows)</para></listitem>
        <listitem><para>Continue skipping characters until the next end-of-line marker</para></listitem>
      </orderedlist>
      <para>This logic is NOT intended for mixing with the block comment logic ( /* a comment */ ).  In other words,
      don't use the '--' style of commenting within a block comment and don't use the block-style of commenting within
      a '--' line.</para>

      <para><emphasis role="bold">Interactive isql sessions</emphasis></para>
      <para>Keep this in mind when working in an interactive isql session.  isql will accept pieces of a statement in
      separate continuation segments, displaying the 'CON>' prompt until it receives the terminator symbol
      (normally ';').  If you type a '--' pair at the start of a continuation line, the ignoring logic will finish
      at the end-of-line marker that is printed to the screen or your OUTPUT file when you press Enter.</para>

      <para>There is potential for errors if you subsequently add a continuation, expecting it to be ignored.</para>

      <para>The problem with isql arises because it has its own special commands that should be parsed only by isql.
      If they are not recognized due to tricky placement of "--", then they are passed to the engine. Obviously, the
      engine doesn't understand isql's SET and SHOW commands and rejects them.</para>
      </section><!-- level 2 -->

      <section id="sql-context"><!-- Level 2 section -->
      <title>(1.0)  CURRENT_USER and CURRENT_ROLE</title>
      <para>These two new context variables have been added to reference the USER and (if implemented1) the ROLE of
      the current connection context.</para>

      <para><emphasis role="bold">Examples</emphasis></para>

      <programlisting>
  CREATE GENERATOR GEN_USER_LOG;
  CREATE DOMAIN INT_64 AS NUMERIC(18,0);
  COMMIT;
  CREATE TABLE USER_LOG(
    LOG_ID  INT_64 PRIMARY KEY NOT NULL,
    OP_TIMESTAMP TIMESTAMP,
    LOG_TABLE VARCHAR(31),
    LOG_TABLE_ID INT_64,
    LOG_OP CHAR(1),
    LOG_USER VARCHAR(8),
    LOG_ROLE VARCHAR(31));

  COMMIT;

  CREATE TRIGGER ATABLE_AI FOR ATABLE
  ACTIVE AFTER INSERT POSITION O AS
  BEGIN
    INSERT INTO USER_LOG VALUES(
      GEN_ID(GEN_USER_LOG, 1),
      CURRENT_TIMESTAMP,
      'ATABLE',
      NEW.ID,
      'I',
      CURRENT_USER,
      CURRENT_ROLE);
  END
      </programlisting>

      <para>CURRENT_USER is a DSQL synonym for USER that appears in the SQL standard.  They are identical. There is
      no advantage of CURRENT_USER over USER.</para>
      <orderedlist>
        <listitem><para>If you insist on using an InterBase v.4.x or 5.1 database with Firebird, ROLE is not
        supported, so current_role will be NONE (as mandated by the SQL standard in absence of an explicit role)
        even if the user passed a role name.</para></listitem>
        <listitem><para>If you use IB 5.5, IB 6 or Firebird, the ROLE passed is verified.  If the role does not
        exist, it is reset to NONE without returning an error.</para>

        <para>This means that in FB you can never get an invalid ROLE returned by CURRENT_ROLE, because it will be
        reset to NONE. This is in contrast with IB, where the bogus value is carried internally, although it is not
        visible to SQL.</para></listitem>
      </orderedlist>
      </section><!-- level 2 -->
    </section><!-- level 1 -->

    <section id="sql-ddl"><!-- Level 1 section -->
    <title>Data Definition Language (DDL)</title>
    <para>DDL is the language subset that is used for creating, altering and dropping metadata.  The following
    changes have been implemented:</para>

      <section id="sql-ddl-datatypes"><!-- Level 2 section -->
      <title>New Data Types</title>

        <section id="sql-ddl-datatypes-bigint"><!-- Level 3 section -->
        <title>(1.5) BIGINT</title>
        <para>BIGINT is the new SQL99-compliant name for the 64-bit signed, exact numeric type, with a scale of
        zero.  Available in Dialect 3 only.</para>

        <para><emphasis role="bold">Examples</emphasis></para>
        <para>i)</para>
        <programlisting>
  DECLARE VARIABLE VAR1 BIGINT;
        </programlisting>
        <para>ii)</para>
        <programlisting>
  CREATE TABLE TABLE1 (FIELD1 BIGINT);
        </programlisting>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-ddl-named-contraints"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Enhancements to named constraints</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>Indexes that enforce named constraints may now be named with user-defined identifiers.</para>
      <para>Previously, although it was possible to created named PRIMARY, FOREIGN KEY and UNIQUE constraints,
      the identifier of the automatically-generated enforcing index was calculated by the system, e.g.,
      RDB$FOREIGN13, and could not be altered.  This remains the default behaviour when named constraints are not
      used.</para>

      <para>However, language extensions have been added to enable</para>
      <orderedlist type="a">
        <listitem><para>a system-generated index to receive automatically the same identifier as the named
        constraint it enforces</para></listitem>
        <listitem><para>an index which enforces a named or unnamed constraint to be explicitly assigned a custom
        identifier and to be optionally constructed in DESCENDING order.</para></listitem>
      </orderedlist>
      <note><para>It is not currently possible to use a pre-existing index.</para></note>

      <para id="pbreak-01"><!-- page break here --><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  ...
  [ADD] CONSTRAINT [&lt;constraint-identifier&gt;]
  &lt;constraint-type&gt; &lt;constraint-definition&gt;
  [USING [ASC[ENDING] | DESC[ENDING]] INDEX &lt;index_name&gt;]
      </programlisting>

      <caution><para>Make sure that foreign key and primary key indexes use the same sort
      order (DESC | ASC ).</para></caution>

      <para><emphasis role="bold">Examples</emphasis></para>

      <para><emphasis>i) Named constraint and explicitly-named index:</emphasis></para>
      <programlisting>
  CREATE TABLE ATEST (
    ID BIGINT NOT NULL,
    DATA VARCHAR(10));
  COMMIT;
      </programlisting>

      <para>The following statement will create a primary key constraint named PK_ATEST and an enforcing,
      descending index named IDX_PK_ATEST:</para>

      <programlisting>
  ALTER TABLE ATEST
  ADD CONSTRAINT PK_ATEST PRIMARY KEY(ID)
  USING DESC INDEX IDX_PK_ATEST;
  COMMIT;
      </programlisting>

      <para><emphasis>ii) Alternative to i) above:</emphasis></para>
      <programlisting>
  CREATE TABLE ATEST (
    ID BIGINT NOT NULL,
    DATA VARCHAR(10),
    CONSTRAINT PK_ATEST PRIMARY KEY(ID)
    USING DESC INDEX IDX_PK_ATEST;
      </programlisting>

      <para><emphasis>iii) This statement creates the table ATEST with the primary key PK_ATEST.  The enforcing
      index is also named PK_ATEST.:</emphasis></para>
      <programlisting>
  CREATE TABLE ATEST (
    ID BIGINT NOT NULL,
    DATA VARCHAR(10),
    CONSTRAINT PK_ATEST PRIMARY KEY(ID));
      </programlisting>
      </section><!-- level 2 -->

      <section id="sql-ddl-multi-triggers"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Multi-action triggers</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>Triggers are enhanced to enable them to handle multiple row-level operations conditionally.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  CREATE TRIGGER name FOR table
    [ACTIVE | INACTIVE]
    {BEFORE | AFTER} &lt;multiple_action&gt;
    [POSITION number]
  AS trigger_body

  &lt;multiple_action&gt; ::= &lt;single_action&gt; [OR &lt;single_action&gt; [OR &lt;single_action&gt;]]
  &lt;single_action&gt; ::= {INSERT | UPDATE | DELETE}
      </programlisting>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para><emphasis>i)</emphasis></para>
      <programlisting>
  CREATE TRIGGER TRIGGER1 FOR TABLE1
  ACTIVE BEFORE INSERT OR UPDATE AS
  ...;
      </programlisting>

      <para><emphasis>ii)</emphasis></para>
      <programlisting>
  CREATE TRIGGER TRIGGER2 FOR TABLE2
  ACTIVE AFTER INSERT OR UPDATE OR DELETE AS
  ...;
      </programlisting>

      <para><emphasis role="bold">ODS Change</emphasis></para>
      <para>Encoding of field RDB$TRIGGER_TYPE (relation RDB$TRIGGERS) has been extended to allow complex
      trigger actions. For details, refer to the document <function>readme.universal_triggers.txt</function> in
      the <function>/doc/sql.extensions</function> branch of the Firebird CVS tree.</para>

      <para><emphasis role="bold">Notes</emphasis></para>
      <orderedlist>
        <listitem>
          <para>One-action triggers are fully compatible at ODS level with FB 1.0.</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>RDB$TRIGGER_TYPE encoding is order-dependant, i.e., BEFORE INSERT OR UPDATE and BEFORE UPDATE
          OR INSERT will be coded differently, although they have the same semantics and will be executed exactly
          the same way.</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>Both OLD and NEW context variables are available in multiple-action triggers. If the
          trigger invocation forbids one of them (e.g. OLD context for INSERT operation), then all fields of
          that context will evaluate to NULL.  If they are assigned to an improper context, a runtime exception
          will be thrown.</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>The new Boolean context variables INSERTING/UPDATING/DELETING can be used to check the operation
          type at runtime.  (See below.)</para>
        </listitem>
      </orderedlist>
      </section><!-- level 2 -->

      <section id="sql-ddl-recreate-view"><!-- level 2 -->
      <title>(1.5)  RECREATE VIEW</title>
      <para>Exactly the same as CREATE VIEW if the view does not already exist.  If it does exist, RECREATE VIEW
      will try to drop it and create a completely new object.  RECREATE VIEW will fail if the object is in use.</para>

      <para>Uses the same syntax as CREATE VIEW.</para>
      </section><!-- level 2 -->

      <section id="sql-ddl-create-alter-proc"><!-- level 2 -->
      <title>(1.5)  CREATE OR ALTER {TRIGGER | PROCEDURE }</title>
      <para>Statement that will either create a new trigger or procedure (if it does not already exist) or alter
      it (if it already exists) and recompile it.  The CREATE OR ALTER syntax preserves existing dependencies and
      permissions.</para>

      <para>Syntax is as for CREATE TRIGGER | CREATE PROCEDURE, respectively, except for the additional
      keywords &quot;OR ALTER&quot;.</para>
      </section><!-- level 2 -->


      <section id="sql-ddl-count"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5) (1.0)  Alter Trigger no longer increments the change count on tables</title>
      </sectioninfo>
      <para>When the count of metadata changes on any single table reaches the maximum of 255, the database becomes
      unavailable.  Backup and restore are required in order to reset the change count and make the database once
      again available.  The intention of this feature is to enforce a database cleanup when table structures have
      undergone a lot of changes, not to inhibit useful capabilities in the engine.</para>

      <para>Previously, each time a trigger was set ACTIVE|INACTIVE by an ALTER TRIGGER statement, the change count
      for the associated table would be incremented.  This affected the usefulness of disabling and re-enabling
      trigger code for regular operations, since it would cause the change count to rise quickly.  Now, it is not
      treated as a metadata change for table versioning purposes.</para>
      </section><!-- level 2 -->

      <section id="sql-ddl-nulls"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  NULLs in unique constraints and indices</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      
<!-- NOTICE TO TRANSLATORS :: The following paragraph got corrupted at v.1.5.2 and 
     remained that way.  It was repaired some months after the release of the v.1.5.4 
     notes, on June 25, 2007. -->

      <para>It is now possible to apply a UNIQUE constraint or a unique index to a 
      column that does not have the NOT NULL constraint, in compliance with SQL-99.
      Be cautious about using this if you plan to revert your database to Firebird 
      1.0.x or any InterBase version, since those older servers will see the index as 
      corrupt.</para>

      <para><emphasis role="bold">Syntax Details</emphasis></para>
      <programlisting>

  &lt;unique constraint or index definition> ::=
    &lt;unique specification&gt; ( &lt;unique column list UCL&gt; )
  &lt;unique specification&gt; ::=
    {{[constraint-name]UNIQUE | UNIQUE INDEX index-name]} |
      [constraint-name] PRIMARY KEY}
      </programlisting>

      <para>where &lt;unique column list&gt; can contain one or more columns without the NOT NULL attribute,
      if &lt;unique specification&gt; is UNIQUE or UNIQUE INDEX index-name.</para>

      <caution><para>All columns in PRIMARY KEY still must be declared NOT NULL.</para></caution>

      <para>The constraint allows existence of only those rows for which search condition (i) or (ii) evaluates
      as True, according to the following logic:</para>

      <orderedlist type="i">
        <listitem><para>If the &lt;unique specification&gt; specifies PRIMARY KEY, then the search condition shall
        be:</para>
        <programlisting>
  UNIQUE ( SELECT UCL FROM TN ) AND ( UCL ) IS NOT NULL
        </programlisting>
        <para>&nbsp;</para></listitem>
        <listitem><para>Otherwise, the &lt;search condition&gt; shall be:</para>
        <programlisting>
  UNIQUE ( SELECT UCL FROM TN )
        </programlisting>
        <para>In this case, the condition UNIQUE can not be True if ( SELECT UCL FROM TN ) could output two
        rows where all of the corresponding non-null segment pairs match.</para></listitem>
      </orderedlist>

      <para>The constraint allows existence of only those rows for which the aforementioned &lt;search condition&gt;
      evaluates to True.  In a unique index or under a UNIQUE constraint, two sets of column values will be
      considered distinct and thus allowed if:</para>
      <orderedlist type="a">
        <listitem><para>both sets contain only nulls, or</para>
        <para>&nbsp;</para></listitem>
        <listitem><para>there is at least one pair of corresponding values of which one is non-null, and the
        other either null or a different non-null value.</para></listitem>
      </orderedlist>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para><emphasis>UNIQUE constraint:</emphasis></para>
      <programlisting>
  CREATE TABLE t (
    a INTEGER,
    b INTEGER,
    CONSTRAINT pk UNIQUE (a, b));
      </programlisting>
      <para><emphasis>or UNIQUE index:</emphasis></para>
      <programlisting>
  CREATE TABLE t (a INTEGER, b INTEGER);
  COMMIT;

  CREATE UNIQUE INDEX uqx ON t(a, b);
  COMMIT;

  INSERT INTO t
    VALUES (NULL, NULL); /* ok, nulls allowed */

  INSERT INTO t
    VALUES (1, 2); /* as are non-nulls */

  INSERT INTO t
    VALUES (1, NULL); /* and combinations */

  INSERT INTO t
    VALUES (NULL, NULL); /* ok, all pairs of nulls are distinct */
      </programlisting>
      <para><emphasis>but not:</emphasis></para>
      <programlisting>
  INSERT INTO t
    VALUES (1, NULL);
    /* fails because all corresponding non-null segments match */
      </programlisting>
      <para>It means that the PRIMARY KEY constraint doesn't allow NULLs whilst the UNIQUE constraint and
      unique indexes allow an arbitrary number of NULLs.  For multi-column result sets of ( SELECT UCL FROM TN ),
      the common rules for NULLs are applied, i.e. (1, NULL) is distinct from (NULL, 1) and one (NULL, NULL)
      is distinct from any other (NULL, NULL).</para>
      </section><!-- level 2 -->

      <section id="sql-ddl-drop-gen"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.0)  DROP GENERATOR</title>
      </sectioninfo>
      <para>Enables unused generators to be removed from the database.  Storage will be freed for re-use upon the
      next RESTORE.  Available in SQL and DSQL.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  DROP GENERATOR &lt;generator name&gt;;
      </programlisting>
      </section><!-- level 2 -->

      <section id="sql-ddl-v1"><!-- Level 2 section -->
      <title>From Firebird v.1.0.x</title>
      <para>The following were implemented in Firebird 1.0.  They are described again here for the convenience of the
      reader.</para>

        <section id="sql-ddl-v1-recreproc"><!-- Level 3 section -->
        <title>(1.0)  RECREATE PROCEDURE</title>
        <para>This new DDL command lets you create a new stored procedure with the same name as an existing
        procedure, replacing the old procedure, without needing to drop the old procedure first.  The syntax is
        identical to CREATE PROCEDURE.</para>
        <para>Available in SQL and DSQL.</para>
        </section><!-- level 3 -->

        <section id="sql-ddl-v1-recretbl"><!-- Level 3 section -->
        <title>(1.0)  RECREATE TABLE</title>
        <para>This new DDL command lets you create a new structure for an existing table without needing to drop
        the old table first.  The syntax is identical to CREATE TABLE.</para>
        <note><para>Observe that RECREATE TABLE does not preserve the data in the old table.</para></note>

        <para>Available in SQL and DSQL.</para>
        </section><!-- level 3 -->
      </section><!-- level 2 -->
    </section><!-- level 1 -->

    <section id="sql-dml"><!-- Level 1 section -->
    <title>Data Manipulation Language (DML)</title>
    <para>Data manipulation language, or <firstterm>DML</firstterm> is the language of query statements, the commands
    we use to <emphasis>manipulate data</emphasis>, that is, to SELECT FROM, INSERT, UPDATE and DELETE from tables
    and to EXECUTE PROCEDUREs.</para>

      <section id="sql-dml-expr"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Expressions and variables as procedure arguments</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>Calls to EXECUTE PROCEDURE ProcName(&lt;Argument-list&gt;) and SELECT &lt;Output-list&gt; FROM
      ProcName(&lt;Argument-list&gt;) can now accept local variables (in PSQL) and expressions (in DSQL and PSQL)
      as arguments.</para>
      </section><!-- level 2 -->

      <section id="sql-dml-case-expr"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  New constructs for CASE expressions</title>
        <author><firstname>Arno</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
        <section id="sql-dml-case-expr-case"><!-- Level 3 section -->
        <title>a)  CASE</title>

        <para>Allow the result of a column to be determined by the outcome of a group of exclusive conditions.</para>

        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  &lt;case expression&gt; ::=
      &lt;case abbreviation&gt;  | &lt;case specification&gt;

  &lt;case abbreviation&gt; ::=
      NULLIF &lt;left paren&gt; &lt;value expression&gt; &lt;comma&gt; &lt;value expression&gt; &lt;right paren&gt;
    | COALESCE &lt;left paren&gt; &lt;value expression&gt; { &lt;comma&gt; &lt;value expression&gt; }... &lt;right paren&gt;

  &lt;case specification&gt; ::=
      &lt;simple case&gt;  | &lt;searched case&gt;

  &lt;simple case&gt; ::=
    CASE &lt;value expression&gt;  &lt;simple when clause&gt;...
      [ &lt;else clause&gt; ]
    END

  &lt;searched case&gt; ::=
    CASE &lt;searched when clause&gt;...
      [ &lt;else clause&gt; ]
    END

  &lt;simple when clause&gt; ::= WHEN &lt;when operand&gt; THEN &lt;result&gt;
  &lt;searched when clause&gt; ::= WHEN &lt;search condition&gt; THEN &lt;result&gt;
  &lt;when operand&gt; ::= &lt;value expression&gt;
  &lt;else clause&gt; ::= ELSE &lt;result&gt;
  &lt;result&gt; ::= &lt;result expression&gt;  | NULL
  &lt;result expression&gt; ::= &lt;value expression&gt;
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>

        <para><emphasis>i) simple</emphasis></para>
        <programlisting>
  SELECT
      o.ID,
      o.Description,
      CASE o.Status
        WHEN 1 THEN 'confirmed'
        WHEN 2 THEN 'in production'
        WHEN 3 THEN 'ready'
        WHEN 4 THEN 'shipped'
        ELSE 'unknown status ''' || o.Status || ''''
      END
  FROM Orders o;
        </programlisting>

        <para><emphasis>ii) searched</emphasis></para>
        <programlisting>
  SELECT
      o.ID,
      o.Description,
      CASE
        WHEN (o.Status IS NULL) THEN 'new'
        WHEN (o.Status = 1) THEN 'confirmed'
        WHEN (o.Status = 3) THEN 'in production'
        WHEN (o.Status = 4) THEN 'ready'
        WHEN (o.Status = 5) THEN 'shipped'
        ELSE 'unknown status ''' || o.Status || ''''
      END
    FROM Orders o;
        </programlisting>
        </section><!-- level 3 -->

        <section id="sql-dml-case-expr-coalesce"><!-- Level 3 section -->
        <title>b)  COALESCE</title>

        <para>Allows a column value to be calculated by a number of expressions, from which the first expression
        to return a non-NULL value is returned as the output value.</para>

        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  &lt;case abbreviation&gt; ::=
    | COALESCE &lt;left paren&gt; &lt;value expression&gt;
      { &lt;comma&gt; &lt;value expression&gt; }... &lt;right paren&gt;
        </programlisting>

        <para id="pbreak-02"><!-- page break here --><emphasis role="bold">Syntax Rules</emphasis></para>

        <orderedlist type="i">
          <listitem><para>COALESCE (V1, V2) is equivalent to the following &lt;case specification&gt;:</para>
          <programlisting>
  CASE WHEN V1 IS NOT NULL THEN V1 ELSE V2 END
          </programlisting>
          <para>&nbsp;</para></listitem>

          <listitem><para>COALESCE (V1, V2,..., Vn), for n &gt;= 3, is equivalent to the following &lt;case
          specification&gt;:</para>
          <programlisting>
  CASE WHEN V1 IS NOT NULL THEN V1
       ELSE COALESCE (V2,...,Vn) END
          </programlisting>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  SELECT
      PROJ_NAME AS Projectname,
      COALESCE(e.FULL_NAME,'[&lt; not assigned &gt;]') AS Employeename
  FROM
    PROJECT p
    LEFT JOIN EMPLOYEE e
    ON (e.EMP_NO = p.TEAM_LEADER);

  SELECT
      COALESCE(Phone,MobilePhone,'Unknown') AS &quot;Phonenumber&quot;
  FROM
    Relations;
        </programlisting>
        </section><!-- level 3 -->

        <section id="sql-dml-case-expr-nullif"><!-- Level 3 section -->
        <title>c)  NULLIF</title>

        <para>Returns NULL for a sub-expression if it has a specific value, otherwise returns the value of the
        sub-expression.</para>

        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  &lt;case abbreviation&gt; ::=
    NULLIF &lt;left paren&gt; &lt;value expression&gt; &lt;comma&gt; &lt;value expression&gt; &lt;right paren&gt;
        </programlisting>

        <para><emphasis role="bold">Syntax Rules</emphasis></para>

        <para>NULLIF (V1, V2) is equivalent to the following &lt;case specification&gt;:</para>
        <programlisting>
  CASE WHEN V1 = V2 THEN NULL ELSE V1 END
        </programlisting>

        <para><emphasis role="bold">Example</emphasis></para>

        <programlisting>
  UPDATE PRODUCTS
     SET STOCK = NULLIF(STOCK,0)
        </programlisting>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-dml-savepoints"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  SQL99-compliant Savepoints</title>
        <author><firstname>Nickolay</firstname><surname>Samofatov</surname></author>
      </sectioninfo>

      <para>User savepoints (alternative name nested transactions) provide a convenient method to handle business
      logic errors without needing to roll back the transaction.  Available only in DSQL.</para>

      <para>Use the SAVEPOINT statement to identify a point in a transaction to which you can later roll back.</para>

      <para><emphasis role="bold">Syntax Patterns</emphasis></para>
      <programlisting>
  SAVEPOINT &lt;identifier&gt;;
      </programlisting>

      <para><emphasis>&lt;identifier&gt;</emphasis> specifies the name of a savepoint to be created. After a savepoint has
      been created, you can either continue processing, commit your work, roll back the entire transaction,
      or roll back to the savepoint.</para>
      <para>Savepoint names must be distinct within a given transaction. If you create a second savepoint with
      the same identifer as an earlier savepoint, the earlier savepoint is erased.</para>

      <programlisting>
  ROLLBACK [WORK] TO [SAVEPOINT] &lt;identifier&gt;;
      </programlisting>

      <para>This statement performs the following operations:</para>
      <itemizedlist>
        <listitem><para>Rolls back changes performed in the transaction after the savepoint</para>
          <para>&nbsp;</para></listitem>
        <listitem><para>Erases all savepoints created after that savepoint. The named savepoint is retained,
          so you can roll back to the same savepoint multiple times. Prior savepoints are also retained.</para>
          <para>&nbsp;</para></listitem>
        <listitem><para>Releases all implicit and explicit record locks acquired since the savepoint. Other
          transactions that have requested access to rows locked after the savepoint must continue to wait until
          the transaction is committed or rolled back. Other transactions that have not already requested the
          rows can request and access the rows immediately.</para>
          <note><para>This behaviour may change in future product versions.</para></note>
        </listitem>
      </itemizedlist>

      <important><para>The Savepoint undo log may consume significant amounts of server memory, especially if you
      update the same records in the same transaction multiple times. Use the RELEASE SAVEPOINT statement to
      release system resources consumed by savepoint maintenance.</para></important>

      <programlisting>
  RELEASE SAVEPOINT &lt;identifier&gt; [ONLY];
      </programlisting>

      <para>RELEASE SAVEPOINT statement erases the savepoint &lt;identifer&gt; from the transaction context.
      Unless you specify the ONLY keyword, all savepoints established since the savepoint &lt;identifier&gt; are
      erased too.</para>

      <para><emphasis role="bold">Example using Savepoints</emphasis></para>
      <programlisting>
  create table test (id integer);
  commit;
  insert into test values (1);
  commit;
  insert into test values (2);
  savepoint y;
  delete from test;
  select * from test; -- returns no rows
  rollback to y;
  select * from test; -- returns two rows
  rollback;
  select * from test; -- returns one row
      </programlisting>

        <section id="sql-dml-savepoints-int"><!-- Level 3 section -->
        <title>Internal savepoints</title>
        <para>By default, the engine uses an automatic transaction-level system savepoint to perform
        transaction rollback.  When you issue a ROLLBACK statement, all changes performed in this
        transaction are backed out via a transaction-level savepoint and the transaction is then committed.
        This logic reduces the  amount of garbage collection caused by rolled back transactions.</para>
        <para>When the volume of changes performed under a transaction-level savepoint is getting large
        (10^4-10^6 records affected) the engine releases the transaction-level savepoint and uses the TIP
        mechanism to roll back the transaction if needed.</para>

        <tip><para>If you expect the volume of changes in your transaction to be large, you can use the
        TPB flag <function>isc_tpb_no_auto_undo</function> to avoid the transaction-level savepoint being
        created.</para></tip>
        </section><!-- level 3 -->

        <section id="sql-dml-savepoints-psql"><!-- Level 3 section -->
        <title>Savepoints and PSQL</title>
        <para>Implementing user savepoints in PSQL layer would break the atomicity rule for statements,
        including procedure call statements.  Firebird provides exception handling in PSQL to undo changes
        performed in stored procedures and triggers. Each SQL/PSQL statement is executed under a system of
        automatic, internal savepoints, whereby either the entire statement will complete successfully or
        ALL its changes are rolled back and an exception is raised.</para>
        <para>Each PSQL exception handling block is also bounded by automatic system savepoints.</para>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-dml-withlock"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Explicit locking</title>
        <author><firstname>Nickolay</firstname><surname>Samofatov</surname></author>
      </sectioninfo>
      <para>The addition of the optional WITH LOCK clause provides a limited explicit pessimistic locking
      capability for cautious use in conditions where the affected row set is</para>
      <orderedlist type="a">
        <listitem><para>extremely small (ideally, a singleton) AND</para></listitem>
        <listitem><para>precisely controlled by the application code.</para></listitem>
      </orderedlist>
      <caution>
        <para><emphasis role="bold">This is for experts only!</emphasis></para>
        <para>The need for a pessimistic lock in Firebird is very rare indeed and should be well understood
        before use of this extension is considered.</para>
        <para>It is essential to understand the effects of transaction isolation and other transaction
        attributes before attempting to implement explicit locking in your application.</para>
      </caution>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  SELECT ... FROM &lt;sometable&gt;
    [WHERE ...]
    [FOR UPDATE [OF ...]]
    [WITH LOCK]
  ...;
      </programlisting>

      <para>If the WITH LOCK clause succeeds, it will secure a lock on the selected rows and prevent any other
      transaction from obtaining write access to any of those rows, or their dependants, until your transaction
      ends.</para>

      <para>If the FOR UPDATE clause is included, the lock will be applied to each row, one by one, as it is
      fetched into the server-side row cache.  It becomes possible, then, that a lock which appeared to succeed
      when requested will nevertheless <emphasis>fail subsequently</emphasis>, when an attempt is made to fetch a
      row which becomes locked by another transaction.</para>

      <para>The SELECT... WITH LOCK construct is available in DSQL and PSQL.</para>

      <important>
        <para>The SELECT... WITH LOCK construct can succeed only in a top-level, single-table SELECT
        statement.  It is <emphasis role="bold">not available</emphasis></para>
        <itemizedlist>
          <listitem><para>in a subquery specification</para><para>&nbsp;</para></listitem>
          <listitem><para>for joined sets</para><para>&nbsp;</para></listitem>
          <listitem><para>with the DISTINCT operator, a GROUP BY clause or any other aggregating operation</para>
          <para>&nbsp;</para></listitem>
          <listitem><para>with a view</para><para>&nbsp;</para></listitem>
          <listitem><para>with the output of a selectable stored procedure</para><para>&nbsp;</para></listitem>
          <listitem><para>with an external table</para></listitem>
        </itemizedlist>
      </important>

        <section id="sql-dml-withlock-clause"><!-- Level 3 section -->
        <title>Understanding the WITH LOCK clause</title>
        <para>As the engine considers, in turn, each record falling under an explicit lock statement, it returns
        either the record version that is the most currently committed, regardless of database state when the
        statement was submitted, or an exception.</para>

        <para>Wait behaviour and conflict reporting depend on the transaction parameters specified in the
        TPB block:</para>
        <table id="tpb-effects">
          <title>How TPB settings affect explicit locking</title>
            <tgroup cols="2">
            <colspec align="left" colname="tpbmode" colwidth="1*"/>
            <colspec align="left" colname="behaviour" colwidth="2*"/>
            <thead>
              <row>
                <entry align="center">TPB mode</entry>
                <entry align="center">Behaviour</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry align="center"><para>isc_tpb_consistency</para></entry>
                <entry align="left"><para>Explicit locks are overridden by implicit or explicit table-level locks
                and are ignored</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_concurrency</para>
                <para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If a record is modified by any transaction that was committed since the
                transaction attempting to get explicit lock started, or an active transaction has performed a
                modification of this record, an update conflict exception is raised immediately</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_concurrency</para>
                <para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If the record is modified by any transaction that has committed since the
                transaction attempting to get explicit lock started, an update conflict exception is raised
                immediately.</para>
                <para>If an active transaction is holding ownership on this record (via explicit locking or by a
                normal optimistic write-lock) the transaction attempting the explicit lock waits for the outcome of
                the blocking transaction and, when it finishes, attempts to get the lock on the record again. This
                means that, if the blocking transaction committed a modified version of this record, an update
                conflict exception will be raised.</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_read_committed</para>
                <para>+ isc_tpb_nowait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on this record (via
                explicit locking or normal update), an update conflict exception is raised immediately.</para></entry>
              </row>
              <row>
                <entry align="center"><para>isc_tpb_read_committed</para>
                <para>+ isc_tpb_wait</para></entry>
                <entry align="left"><para>If there is an active transaction holding ownership on this record
                (via explicit locking or by a normal optimistic write-lock), the transaction attempting the explicit
                lock waits for the outcome of blocking transation and when it finishes, attempts to get the lock on
                the record again.</para>
                <para>Update conflict exceptions can never be raised by an explicit lock statement in this TPB
                mode.</para></entry>
              </row>
            </tbody>
            </tgroup>
        </table>
        </section><!-- level 3 -->

        <section id="sql-dml-withlock-engine"><!-- Level 3 section -->
        <title>How the engine deals with WITH LOCK</title>
        <para>When an UPDATE statement tries to access a record that is locked by another transaction, it either
        raises an update conflict exception or waits for the locking transaction to finish, depending on TPB mode.
        Engine behaviour here is the same as if this record had already been modified by the locking
        transaction.</para>

        <para>No special gdscodes are returned from conflicts involving pessimistic locks.</para>

        <para>The engine guarantees that all records returned by an explicit lock statement are actually locked and
        DO meet the search conditions specified in WHERE clause, as long as the search conditions do not depend on
        any other tables, via joins, subqueries, etc.  It also guarantees that rows not meeting the search conditions
        will not be locked by the statement. It can NOT  guarantee that there are no rows which, though meeting the
        search conditions, are not locked.</para>
        <note>
          <para>This situation can arise if other, parallel transactions commit their changes during the course of
            the locking statement's execution.</para>
        </note>

        <para>The engine locks rows at fetch time. This has important consequences if you lock several rows at once.
        Many access methods for Firebird databases default to fetching output in packets of a few hundred rows
        (&quot;buffered fetches&quot;). Most data access components cannot bring you the rows contained in the
        last-fetched packet, where an error occurred.</para>
        </section><!-- level 3 -->

        <section id="sql-dml-withlock-of"><!-- Level 3 section -->
        <title>The optional OF &lt;column-names&gt; sub-clause</title>
        <para>The FOR UPDATE clause provides a technique to prevent usage of buffered fetches, optionally with the
        <function>OF &lt;column-names&gt;</function> to enable positioned updates.</para>
        <tip>
          <para>Alternatively, it may be possible in your access components to set the size of the fetch buffer
          to 1.  This would enable you to process the currently-locked row before the next is fetched and locked,
          or to handle errors without rolling back your transaction.</para>
        </tip>
        </section><!-- level 3 -->

        <section id="sql-dml-withlock-caveat"><!-- Level 3 section -->
        <title>Caveats using WITH LOCK</title>
        <itemizedlist>
          <listitem>
            <para>Rolling back of an implicit or explicit savepoint releases record locks that were taken
            under that savepoint, but it doesn't notify waiting transactions. Applications should not depend on this
            behaviour as it may get changed in the future.</para>
            <para>&nbsp;</para>
          </listitem>
          <listitem>
            <para>While explicit locks can be used to prevent and/or handle unusual update conflict errors,
            the volume of deadlock errors will grow unless you design your locking strategy carefully and control
            it rigorously.</para>
            <para>&nbsp;</para>
          </listitem>
          <listitem>
            <para>Most applications do not need explicit locks at all. The main purposes of explicit locks are
            (1) to prevent expensive handling of update conflict errors in heavily loaded applications
            and (2) to maintain integrity of objects mapped to a relational database in a clustered environment.
            If your use of explicit locking doesn't fall in one of these two categories, then it's the wrong way to
            do the task in Firebird.</para>
            <para>&nbsp;</para>
          </listitem>
          <listitem>
            <para>Explicit locking is an advanced feature, do not misuse it !  While solutions for these kinds of
            problems may be very important for web sites handling thousands of concurrent writers, or for ERP/CRM
            systems operating in large corporations, most application programs do not need to work in such
            conditions.</para>
          </listitem>
        </itemizedlist>
        </section><!-- level 3 -->

        <section id="sql-dml-withlock-examples"><!-- Level 3 section -->
        <title>Examples using Explicit Locking</title>
        <para><emphasis>i) (simple)</emphasis></para>
        <programlisting>
  SELECT * FROM DOCUMENT WHERE ID=? WITH LOCK
        </programlisting>

        <para><emphasis>ii) (multiple rows, one-by-one processing with DSQL cursor)</emphasis></para>
        <programlisting>
  SELECT * FROM DOCUMENT WHERE PARENT_ID=?
    FOR UPDATE WITH LOCK
        </programlisting>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-dml-aggregate"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Improved Aggregate Handling</title>
        <author><firstname>Arno</firstname><surname>Brinkman</surname></author>
      </sectioninfo>
      <para>Originally, grouped sets could be grouped only on named columns.   In Firebird 1.0, it became
      possible to group by a UDF expression.  In 1.5, several further extensions to the handling of aggregate
      functions and the GROUP BY clause now allow groupings to be made by the degree of columns in the output
      specification (their 1-based &quot;ordinal left-to-right position&quot;, as in the ORDER BY clause) or
      by a variety of expressions.</para>
      <caution>
        <para>Not all expressions are currently allowed inside the GROUP BY list.  For example,
        concatenation is not allowed.</para>
      </caution>

      <para><emphasis role="bold">Group By syntax</emphasis></para>
      <programlisting>
  SELECT ... FROM .... [GROUP BY group_by_list]

    group_by_list : group_by_item [, group_by_list];

    group_by_item : column_name
      | degree (ordinal)
      | udf
      | group_by_function;

  group_by_function : numeric_value_function
      | string_value_function
      | case_expression
      ;

  numeric_value_function : EXTRACT '(' timestamp_part FROM value ')';

  string_value_function	: SUBSTRING '(' value FROM pos_short_integer ')'
      | SUBSTRING '(' value FROM pos_short_integer FOR nonneg_short_integer ')'
      | KW_UPPER '(' value ')'
      ;
      </programlisting>

      <important>
        <para>The group_by_item cannot be a reference to any aggregate-function (including any that are buried
        inside an expression) from the same context.</para>

        <variablelist>
          <varlistentry><term>HAVING</term>
          <listitem>
            <para>The having clause only allows aggregate functions or valid expressions that are part of the
            GROUP BY clause.  Previously it was allowed to use columns that were not part of the GROUP BY clause
            and to use non-valid expressions.</para>
          </listitem></varlistentry>
          <varlistentry><term>ORDER BY</term>
          <listitem>
            <para>When the context is an aggregate statement, the ORDER BY clause only allows valid expressions
            that are aggregate functions or expression parts of the GROUP BY clause.</para>
            <para>Previously it was allowed to use non-valid expressions.</para>
          </listitem></varlistentry>
        </variablelist>
      </important>

        <section id="dml-aggregate-subq"><!-- Level 3 section -->
        <title>Aggregate functions inside subqueries</title>
        <para>It is now possible to use an aggregate function or expression contained in the GROUP BY clause
        inside a subquery.</para>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  SELECT
    r.RDB$RELATION_NAME,
    MAX(r.RDB$FIELD_POSITION),
    (SELECT
       r2.RDB$FIELD_NAME
     FROM
       RDB$RELATION_FIELDS r2
     WHERE
       r2.RDB$RELATION_NAME = r.RDB$RELATION_NAME and
       r2.RDB$FIELD_POSITION = MAX(r.RDB$FIELD_POSITION))
  FROM
    RDB$RELATION_FIELDS r
  GROUP BY
    1
  /* ************ */
  SELECT
    rf.RDB$RELATION_NAME AS &quot;Relationname&quot;,
    (SELECT
       r.RDB$RELATION_ID
     FROM
       RDB$RELATIONS r
     WHERE
       r.RDB$RELATION_NAME = rf.RDB$RELATION_NAME)
    AS &quot;ID&quot;,
    COUNT(*) AS "Fields"
  FROM
    RDB$RELATION_FIELDS rf
  GROUP BY
    rf.RDB$RELATION_NAME
        </programlisting>
        </section><!-- level 3 -->

        <section id="dml-aggregate-mixed"><!-- Level 3 section -->
        <title>Mixing aggregate functions from different contexts</title>
        <para>Aggregate functions from different contexts can be used inside an expression.</para>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  SELECT
    r.RDB$RELATION_NAME,
    MAX(i.RDB$STATISTICS) AS &quot;Max1&quot;,
    (SELECT
       COUNT(*) || ' - ' || MAX(i.RDB$STATISTICS)
     FROM RDB$RELATION_FIELDS rf
    WHERE
      rf.RDB$RELATION_NAME = r.RDB$RELATION_NAME) AS &quot;Max2&quot;
  FROM
    RDB$RELATIONS r
    JOIN RDB$INDICES i on (i.RDB$RELATION_NAME = r.RDB$RELATION_NAME)
  GROUP BY
    r.RDB$RELATION_NAME
  HAVING
    MIN(i.RDB$STATISTICS) &lt;&gt; MAX(i.RDB$STATISTICS)
        </programlisting>

        <para>Note! This query gives results in FB1.0, but they are WRONG!</para>
        </section><!-- level 3 -->

        <section id="dml-aggregate-singleton"><!-- Level 3 section -->
        <title>Subqueries are supported inside an aggregate function</title>
        <para>Using a singleton SELECT expression inside an aggregate function is supported.</para>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
  SELECT
    r.RDB$RELATION_NAME,
    SUM((SELECT
           COUNT(*)
         FROM
           RDB$RELATION_FIELDS rf
         WHERE
           rf.RDB$RELATION_NAME = r.RDB$RELATION_NAME))
  FROM
    RDB$RELATIONS r
    JOIN RDB$INDICES i
      on (i.RDB$RELATION_NAME = r.RDB$RELATION_NAME)
  GROUP BY
    r.RDB$RELATION_NAME
        </programlisting>
        </section><!-- level 3 -->

        <section id="dml-aggregate-nested"><!-- Level 3 section -->
        <title>Nested aggregate functions</title>
        <para>Using an aggregate function inside another aggregate function is possible if the inner aggregate
        function is from a lower context (see example above).</para>
        </section><!-- level 3 -->

        <section id="dml-aggregate-bydegree"><!-- Level 3 section -->
        <title>Grouping by degree (ordinal number)</title>
        <para>Using the degree number of the output column in the GROUP BY clause 'copies' the expression
        from the select list (as does the ORDER BY clause). This means that, when a degree number refers to a
        subquery, the subquery is executed at least twice.</para>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-dml-orderby"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  ORDER BY clause can specify expressions and nulls placement</title>
        <author><firstname>Nickolay</firstname><surname>Samofatov</surname></author>
      </sectioninfo>

      <variablelist>
        <varlistentry><term>Order by expression</term>
        <listitem>
          <para>The ORDER BY clause lets you specify any valid expressions to sort query results. If the
          expression consists of a single number, it is interpreted as column (degree) number, as
          previously.</para>
        </listitem></varlistentry>
        <varlistentry><term>Nulls placement</term>
        <listitem>
          <para>The ordering of nulls in the result set can be controlled using a <firstterm>nulls
          placement</firstterm> clause.</para>
          <para>Results can be sorted so that nulls are placed either above (NULLS FIRST) or below (NULLS LAST) the
          sorted non-nulls.</para>
          <para>Behaviour when nulls placement is unspecified is NULLS LAST.</para>
        </listitem></varlistentry>
      </variablelist>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  SELECT ... FROM .... [ORDER BY order_list]....;

  order_list : order_item [, order_list];
  order_item : &lt;expression&gt; [order_direction] [nulls_placement]
  order_direction : ASC | DESC;
  nulls_placement : NULLS FIRST | NULLS LAST;
      </programlisting>

      <para><emphasis role="bold">Restrictions</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>If NULLS FIRST is specified, no index will be used for sorting.</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>The results of a sort based on values returned from a UDF or a stored procedure will be unpredictable
          if the values returned cannot be used to determine a logical sorting sequence.</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>The number of procedure invocations from specifying a sort based on a UDF or stored procedure
          will be unpredictable, regardless of whether the ordering is specified by the expression itself or by an
          ordinal number representing an expression in the column-list specification.</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>An ordering clause for sorting the output of a union query may use only ordinal (degree) numbers to
          refer to the ordering columns.</para>
        </listitem>
      </itemizedlist>

      <para id="pbreak-03"><!-- page break here --><emphasis role="bold">Examples</emphasis></para>
      <para><emphasis >i)</emphasis></para>
      <programlisting>
  SELECT * FROM MSG
  ORDER BY PROCESS_TIME DESC NULLS FIRST
      </programlisting>
      <para><emphasis >ii)</emphasis></para>
      <programlisting>
  SELECT FIRST 10 * FROM DOCUMENT
  ORDER BY STRLEN(DESCRIPTION) DESC
      </programlisting>
      <para><emphasis >iii)</emphasis></para>
      <programlisting>
  SELECT DOC_NUMBER, DOC_DATE FROM PAYORDER
  UNION ALL
  SELECT DOC_NUMBER, DOC_DATA FROM BUDGORDER
  ORDER BY 2 DESC NULLS LAST, 1 ASC NULLS FIRST
      </programlisting>
      </section><!-- level 2 -->

      <section id="sql-dml-selectfirst"><!-- Level 2 section -->
      <title>(1.5)  SELECT FIRST 0.. is Now Valid</title>
      <para>In Firebird 1.5, zero can be accepted as an argument for FIRST in the <function>SELECT FIRST m ..
      SKIP n</function> construction.  An empty result set will be returned.</para>

        <section id="sql-dml-selectfirst-v1"><!-- Level 3 section -->
        <title>(1.0)  SELECT FIRST m .. SKIP n</title>
        <para><emphasis>(from the v.1.0 release notes)</emphasis></para>
        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  SELECT [FIRST (&lt;integer expr m&gt;)] [SKIP (&lt;integer expr n&gt;)]
        </programlisting>
        <para>Retrieves the first m rows of the selected output set.  The optional SKIP clause will cause the first
        n rows to be discarded and return an output set of m rows starting at n + 1.    In the simplest form,
        m and n are integers but any Firebird expression that evaluates to an integer is valid.</para>
        
        <para>Available in SQL and DSQL except where otherwise indicated.</para>

          <section id="sql-dml-selectfirst-v1-args"><!-- Level 4 section -->
          <title>Arguments m and n</title>
          <para>Parentheses are required for expression arguments and are optional otherwise.</para>
          <para>The arguments can also bind variables, e.g.</para>
          <blockquote>
            <para><function>SKIP ? * FROM ATABLE</function> returns the remaining dataset after discarding  the n
            rows at the top, where n is passed in the "?" variable.</para>
            <para><function>SELECT FIRST ? COLUMNA, COLUMNB FROM ATABLE</function> returns the first m rows and
            discards the rest.</para>
          </blockquote>
          <para>An identifier that evaluates to an integer may also be used in GDML, although not in SQL
          or DSQL.</para>
          </section><!-- level 4 -->

          <section id="sql-dml-selectfirst-v1-elements"><!-- Level 4 section -->
          <title>FIRST and SKIP Elements</title>
          <para>The FIRST clause is also optional, i.e. you can include SKIP in a statement without FIRST to get
          an output set that simply excludes the rows appointed to SKIP.</para>

          <para><emphasis role="bold">Example</emphasis></para>
          <programlisting>
  SELECT SKIP (5+3*5) * FROM MYTABLE;

  SELECT FIRST (4-2) SKIP ? * FROM MYTABLE;

  SELECT FIRST 5 DISTINCT FIELD FROM MYTABLE;
          </programlisting>
          </section><!-- level 4 -->

          <section id="sql-dml-selectfirst-v1-gotchas"><!-- Level 4 section -->
          <title>Two Gotchas with SELECT FIRST</title>
          <para>1.  This:</para>
          <programlisting>
  delete from TAB1
    where PK1 in (select first 10 PK1 from TAB1);
          </programlisting>
          <para>will delete all of the rows in the table.  Ouch! the sub-select is evaluating each 10 candidate
          rows for deletion, deleting them, slipping forward 10 more...ad infinitum, until there are no rows left.
          Beware!</para>

          <para>2. Queries like:</para>
          <programlisting>
  ...
  WHERE F1 IN ( SELECT FIRST 5 F2 FROM TABLE2
    ORDER BY 1 DESC )
          </programlisting>
          <para>won't work as expected, because the optimization performed by the engine transforms the correlated
          <function>WHERE...IN (SELECT...)</function>  predicate to a correlated EXISTS predicate. It's obvious
          that in this case FIRST N doesn't make any sense:</para>
          <programlisting>
  ...
  WHERE EXISTS (
     SELECT FIRST 5 TABLE2.F2 FROM TABLE2
     WHERE TABLE2.F2 = TABLE1.F1
     ORDER BY 1 DESC )
          </programlisting>
          </section><!-- level 4 -->
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-dml-v1"><!-- Level 2 section -->
      <title>Other Firebird 1.0.x Features</title>
      <para>The remaining items in this section are DML enhancements that were introduced in Firebird 1.0.x,
      described again for the reader's convenience.</para>

        <section id="sql-dml-v1-groupby"><!-- Level 3 section -->
        <title>(1.0)  GROUP BY UDF</title>
        <para>It is now possible to aggregate a SELECT by grouping on the output of a UDF. e.g.</para>
        <programlisting>
  select
    strlen(rtrim(rdb$relation_name)),
    count(*) from rdb$relations
  group by strlen(rtrim(rdb$relation_name))
  order by 2
        </programlisting>
        <para>A side-effect of the changes enabling grouping by UDFs is that, whereas previously you could not
        call built-in Firebird functions in GROUP BY, now, by creating a dummy UDF wrapper, you can do:</para>
        <programlisting>
  select count(*)
  from rdb$relations r
  group by bin_or((select count(rdb$field_name)
     from rdb$relation_fields f
     where f.rdb$relation_name = r.rdb$relation_name),1)
        </programlisting>
        </section><!-- level 3 -->

        <section id="sql-dml-v1-substring"><!-- Level 3 section -->
        <title>(1.0)  SUBSTRING( &lt;string expr&gt; FROM &lt;pos&gt; [FOR &lt;length&gt;])</title>

        <para>Internal function, available in SQL and DSQL, implementing the ANSI SQL SUBSTRING() function.  It
        will return a stream consisting of the byte at &lt;pos&gt; and all subsequent bytes up to the end of the
        string.  If the optional <function>FOR &lt;length&gt;</function> is specified, it will return the lesser
        of &lt;length&gt; bytes or the number of bytes up to the end of the input stream.</para>

        <para>The first argument can be any expression, constant or identifier that evaluates to a string.</para>
        <para>&lt;pos&gt; must evaluate to an integer.  &lt;pos&gt; in the string starts at 1, like other SQL
        positional elements.</para>

        <para>Neither &lt;pos&gt; nor &lt;length&gt; can be query parameters:  they must evaluate to constants.</para>

        <para>Because &lt;pos&gt; and &lt;length&gt; are byte positions, the identifier of the input string can be
        a binary blob,  or a sub_type 1 text blob with an underlying one-byte-per-character charset.  The function
        currently does not handle text blobs with Chinese (2 byte/char maximum) or Unicode (3 byte/char maximum)
        character sets.</para>

        <para>For a string argument (as opposed to a blob), the function will tackle ANY charset.</para>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
  UPDATE ATABLE
    SET COLUMNB = SUBSTRING(COLUMNB FROM 4 FOR 99)
    WHERE ...
        </programlisting>
        <para>Please refer also to the later section on External Functions (UDFs) for details of changes and
        additions to external substring functions in the standard UDF library.</para>
        </section><!-- level 3 -->
      </section><!-- level 2 -->
    </section><!-- level 1 -->

    <section id="sql-psql"><!-- Level 1 section -->
    <title>Stored Procedure and Trigger Language (PSQL)</title>
    <para>The following enhancements have been made to PSQL, the set of language extensions available for writing
    stored procedures and triggers.</para>

      <section id="sql-psql-execstmt"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  EXECUTE STATEMENT</title>
        <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
      </sectioninfo>

      <para><firstterm>EXECUTE STATEMENT &quot;string&quot;</firstterm> is a PSQL extension which takes a string
      that is a valid dynamic SQL statement and executes it as if it had been submitted to DSQL.</para>

      <para>Available in triggers and stored procedures.</para>

      <para><emphasis role="bold">Syntax Patterns</emphasis></para>

      <para>The syntax may have three forms.-</para>

      <variablelist>
        <varlistentry><term>Syntax 1</term>
        <listitem>
          <para>Executes &quot;string> as an SQL operation that does not return any data rows, viz. INSERT,
          UPDATE, DELETE, EXECUTE PROCEDURE or any DDL statement except CREATE/DROP DATABASE.</para>
          <programlisting>
  EXECUTE STATEMENT &lt;string&gt;;
          </programlisting>

          <para><emphasis role="bold">Example</emphasis></para>
          <programlisting>
  CREATE PROCEDURE DynamicSampleOne (Pname VARCHAR(100))
  AS
  DECLARE VARIABLE Sql VARCHAR(1024);
  DECLARE VARIABLE Par INT;
  BEGIN
     SELECT MIN(SomeField) FROM SomeTable INTO :Par;
     Sql = 'EXECUTE PROCEDURE ' || Pname || '(';
     Sql = Sql || CAST(Par AS VARCHAR(20)) || ')';
     EXECUTE STATEMENT Sql;
  END
          </programlisting>
        </listitem></varlistentry>

        <varlistentry><term>Syntax 2</term>
        <listitem>
          <para>Executes &quot;string&quot; as an SQL operation, returning single data row. Only singleton SELECT
          operators may be executed with this form of EXECUTE STATEMENT.</para>
          <programlisting>
  EXECUTE STATEMENT &lt;string&gt; INTO :var1, [&amp;, :varn] ;
          </programlisting>
          <para id="pbreak-04"><!-- page break here --><emphasis role="bold">Example</emphasis></para>
          <programlisting>
  CREATE PROCEDURE DynamicSampleTwo (TableName VARCHAR(100))
  AS
  DECLARE VARIABLE Par INT;
  BEGIN
     EXECUTE STATEMENT
       'SELECT MAX(CheckField) FROM ' || TableName INTO :Par;
     IF (Par > 100) THEN
      EXCEPTION Ex_Overflow 'Overflow in ' || TableName;
  END
          </programlisting>
        </listitem></varlistentry>
        <varlistentry><term>Syntax 3</term>
        <listitem>
          <para>Executes &quot;string&quot; as SQL operation, returning multiple data rows. Any SELECT operator
          may be executed with this form of EXECUTE STATEMENT.</para>
          <programlisting>
  FOR EXECUTE STATEMENT &lt;string&gt; INTO :var1, &amp;, :varn
    DO
     &lt;compound-statement&gt;;

          </programlisting>
          <para><emphasis role="bold">Example</emphasis></para>
          <programlisting>
  CREATE PROCEDURE DynamicSampleThree (
     TextField VARCHAR(100),
     TableName VARCHAR(100))
  RETURNS (Line VARCHAR(32000))
  AS
  DECLARE VARIABLE OneLine VARCHAR(100);
  BEGIN
    Line = '';
    FOR EXECUTE STATEMENT
     'SELECT ' || TextField || ' FROM ' || TableName
     INTO :OneLine
    DO
      IF (OneLine IS NOT NULL) THEN
         Line = Line || OneLine || ' ';
    SUSPEND;
  END
          </programlisting>
        </listitem></varlistentry>
      </variablelist>

        <section id="psql-execstmt-caveat"><!-- Level 3 section -->
        <title>Caveats with EXECUTE STATEMENT</title>

        <para>The 'EXECUTE STATEMENT' DSQL string cannot contain any parameters in any syntax variation. All
        variable substitution into the static part of the SQL statement should be performed before the execution
        of EXECUTE STATEMENT.</para>

        <para>This feature is intended only for very cautious use and should be used with all factors taken into
        account.  It should be a rule of thumb to use EXECUTE STATEMENT only when other methods are impossible, or
        perform even worse than EXECUTE STATEMENT.</para>
        <para id="pbreak-05"><!-- page break here --></para>
        <caution>
          <para>EXECUTE STATEMENT is potentially unsafe in several ways:</para>
          <orderedlist>
            <listitem>
              <para>There is no way to validate the syntax of the enclosed statement.</para>
              <para>&nbsp;</para>
            </listitem>
            <listitem>
              <para>There are no dependency checks to discover whether tables or columns have been dropped.</para>
              <para>&nbsp;</para>
            </listitem>
            <listitem>
              <para>Operations will be slow because the embedded statement has to be prepared every time it is
              executed.</para>
              <para>&nbsp;</para>
            </listitem>
            <listitem>
              <para>Return values are strictly checked for data type in order to avoid unpredictable type-casting
              exceptions.  For example, the string '1234' would convert to an integer, 1234, but 'abc' would give
              a conversion error.</para>
              <para>&nbsp;</para>
            </listitem>
            <listitem>
              <para>If the stored procedure has special privileges on some objects, the dynamic statement submitted
              in the EXECUTE STATEMENT string does not inherit them. Privileges are restricted to those granted to
              the user who is executing the procedure.</para>
            </listitem>
          </orderedlist>
        </caution>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-psql-contextvar"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  New Context Variables</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>A number of new context variables for PSQL have been implemented.</para>

        <section id="sql-psql-contextvar-current"><!-- Level 3 section -->
        <title>CURRENT_CONNECTION and CURRENT_TRANSACTION</title>

        <para>These context variables return the system identifier of the <firstterm>active connection</firstterm>
        or the <firstterm>current transaction</firstterm> context, respectively.  Return type is INTEGER.  Available
        in DSQL and PSQL.</para>
        <important>
          <para>Because these values are stored on the database header page, they will be reset after a database
          restore.</para>
        </important>

        <para><emphasis role="bold">Syntax Patterns</emphasis></para>
        <programlisting>
  CURRENT_CONNECTION
  CURRENT_TRANSACTION
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  SELECT CURRENT_CONNECTION FROM RDB$DATABASE;

  NEW.TXN_ID = CURRENT_TRANSACTION;

  EXECUTE PROCEDURE P_LOGIN(CURRENT_CONNECTION);
        </programlisting>
        </section><!-- level 3 -->

        <section id="sql-psql-contextvar-rowcount"><!-- Level 3 section -->
        <title>ROW_COUNT</title>

        <para>Returns an integer, the number of rows affected by the last DML statement.  Available in PSQL,
        in the context of the procedure or trigger module.</para>
        <para>Currently returns zero from a SELECT statement.</para>

        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  ROW_COUNT
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
  UPDATE TABLE1 SET FIELD1 = 0 WHERE ID = :ID;
  IF (ROW_COUNT = 0) THEN
   INSERT INTO TABLE1 (ID, FIELD1) VALUES (:ID, 0);
        </programlisting>
        <note>
          <para>ROW_COUNT cannot be used for checking the rows affected by an EXECUTE STATEMENT command.</para>
        </note>
        </section><!-- level 3 -->

        <section id="sql-psql-contextvar-sqlcode"><!-- Level 3 section -->
        <title>SQLCODE and GDSCODE</title>

        <para>Each context variable returns an integer which is the numeric error code for the active exception.
        Available in PSQL, within the scope of the particular exception handling block.  Both will evaluate to zero
        outside the block.</para>
        <para>The GDSCODE variable returns a numeric representation of the GDS (ISC) error code, e.g. '335544349L'
        will return 335544349.</para>
        <para>A 'WHEN SQLCODE' or 'WHEN ANY' exception block will catch a non-zero value for the SQLCODE variable
        and return zero for GDSCODE.  Only a 'WHEN GDSCODE' block can catch a non-zero GDSCODE variable (and will
        return zero in SQLCODE).</para>

        <para>If a user-defined exception is thrown, both SQLCODE and GDSCODE variables contain zero, regardless
        of the exception handling block type.</para>
        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  SQLCODE
  GDSCODE
        </programlisting>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
BEGIN
   ...
   WHEN SQLCODE -802 DO
     EXCEPTION E_EXCEPTION_1;
   WHEN SQLCODE -803 DO
     EXCEPTION E_EXCEPTION_2;
   WHEN ANY DO
     EXECUTE PROCEDURE P_ANY_EXCEPTION(SQLCODE);
END
        </programlisting>

        <para>See also the EXCEPTION HANDLING ENHANCEMENTS, below, and the document README.exception_handling in
        the firebird2/doc/sql.extensions branch of the Firebird CVS tree.</para>
        </section><!-- level 3 -->

        <section id="sql-psql-contextvar-inserting"><!-- Level 3 section -->
        <title>INSERTING, UPDATING and DELETING</title>

        <para>Three pseudo-Boolean expressions that can be tested to determine the type of DML operation being
        executed.  Available in PSQL, only in triggers.  Intended for use with multi-action triggers (see the DML
        section, above).</para>

        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  INSERTING
  UPDATING
  DELETING
        </programlisting>

        <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
  IF (INSERTING OR UPDATING) THEN
  BEGIN
    IF(NEW.SERIAL_NUM IS NULL) THEN
      NEW.SERIAL_NUM = GEN_ID(G_GENERATOR_1, 1);
        </programlisting>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-psql-exceptions"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5)  Enhancements to Exception Handling in PSQL</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>The common syntax for an EXCEPTION statement in PSQL is:</para>
      <programlisting>
   EXCEPTION [name [value]];
      </programlisting>

      <para>The enhancements in 1.5 allow you to</para>
      <orderedlist>
        <listitem>
          <para>define a run-time message for a named exception</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
          <para>re-initiate (re-raise) a caught exception within the scope of the exception block</para>
          <para>&nbsp;</para>
        </listitem>
        <listitem>
        <para>Obtain a numeric error code for a caught exception</para>
        </listitem>
      </orderedlist>

        <section id="sql-psql-exceptions-rtmsg"><!-- Level 3 section -->
        <title>1) Run-time exception messaging</title>
        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  EXCEPTION &lt;exception_name&gt; &lt;message_value&gt;;
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>
        <para><emphasis>a)</emphasis></para>
        <programlisting>
EXCEPTION E_EXCEPTION_1 'Error!';
        </programlisting>
        <para><emphasis>b)</emphasis></para>
        <programlisting>
EXCEPTION
  E_EXCEPTION_2 'Wrong type for record with ID=' || new.ID;
        </programlisting>
        </section><!-- level 3 -->

        <section id="sql-psql-exceptions-reraise"><!-- Level 3 section -->
        <title>2) Re-raising an exception</title>
        <note><para>This has no effect outside an exception block.</para></note>

        <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <programlisting>
  EXCEPTION;
        </programlisting>

        <para><emphasis role="bold">Examples</emphasis></para>
        <para><emphasis>a)</emphasis></para>
        <programlisting>
  BEGIN
    ...
    WHEN SQLCODE -802 DO
      EXCEPTION E_ARITH_EXCEPT;
    WHEN SQLCODE -802 DO
      EXCEPTION E_KEY_VIOLATION;
    WHEN ANY THEN
      EXCEPTION;
  END
        </programlisting>
        <para><emphasis>b)</emphasis></para>
        <programlisting>
  WHEN ANY DO
  BEGIN
     INSERT INTO ERROR_LOG (...) VALUES (SQLCODE, ...);
     EXCEPTION;
  END
        </programlisting>
        </section><!-- level 3 -->

        <section id="sql-psql-exceptions-rterrcodes"><!-- Level 3 section -->
        <title>3)  Run-time error codes</title>
        <para>See SQLCODE / GDSCODE (above).</para>
        </section><!-- level 3 -->
      </section><!-- level 2 -->

      <section id="sql-psql-leave"><!-- Level 2 section -->
      <title>(1.5)  LEAVE | BREAK statement</title>
      <para>Terminates the flow in a loop, causing flow of control to move to the statement following the
      END statement that completes that loop.  Available for WHILE, FOR SELECT and FOR EXECUTE language constructs
      only, otherwise a parser error will be thrown. Available in triggers as well as stored procedures.</para>

      <important><para>The SQL-99 standard keyword LEAVE deprecates the existing use of BREAK.</para></important>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  LEAVE;
      </programlisting>

      <para><emphasis role="bold">Examples</emphasis></para>
      <para><emphasis>i)</emphasis></para>
      <programlisting>
  BEGIN
     &lt;statements&gt;;
   IF (&lt;conditions&gt;) THEN 
     LEAVE;
   &lt;statements&gt;;
  END
      </programlisting>

      <para><emphasis>ii)</emphasis></para>
      <programlisting>
  WHILE (&lt;condition&gt;) DO
    BEGIN
      &lt;statements&gt;;
      WHEN ... DO
        LEAVE;
    END
      </programlisting>
      <para>The condition that branches to a LEAVE statement must be inside a block that is controlled by a
      looping construct (i.e., WHILE or FOR SELECT...INTO...DO).</para>
      <important>
        <para>It is emphasised that LEAVE will not terminate other types of BEGIN...END block.</para>
      </important>

      <note><para>LEAVE | BREAK and EXIT statements can now be used in triggers.</para></note>
      </section><!-- level 2 -->

      <section id="sql-psql-triggerplan"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5) Valid PLAN statements can now be included in triggers</title>
        <author><firstname>Ignacio J.</firstname><surname>Ortega</surname></author>
      </sectioninfo>

      <para>Until now, a trigger containing a PLAN statement would be rejected by the compiler.  Now, a valid
      plan can be included and will be used.</para>
      </section><!-- level 2 -->

      <section id="sql-psql-emptyblocks"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5) Empty BEGIN..END blocks</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>

      <para>Empty BEGIN..END blocks in PSQL modules are now legal.  For example, you can now write &quot;stub&quot;
      modules like</para>
      <programlisting>
  CREATE TRIGGER BI_ATABLE FOR ATABLE
  ACTIVE BEFORE INSERT POSITION 0
  AS
  BEGIN
  END ^
      </programlisting>
      </section><!-- level 2 -->

      <section id="sql-psql-declarevar"><!-- Level 2 section -->
      <sectioninfo>
        <title>(1.5) Declare and define local variable in single statement</title>
        <author><firstname>Claudio</firstname><surname>Valderrama</surname></author>
      </sectioninfo>
      <para>Simplifies syntax and allows local variables to be declared and defined (or initialized) in one
      statement.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <programlisting>
  DECLARE [VARIABLE] name &lt;variable_type&gt; [{'=' | DEFAULT} value];
      </programlisting>
      <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
  DECLARE my_var INTEGER = 123;
      </programlisting>
      </section><!-- level 2 -->
    </section><!-- level 1 -->

    <section id="sql-reswords"><!-- Level 1 section -->
    <title>New Reserved Words</title>
    <para>The following new Firebird keywords should be added to the list of reserved words published for
    InterBase 6.0.1.</para>

    <programlisting>
      BIGINT (1.5)     CASE (1.5)                 CURRENT_CONNECTION (1.5)
      CURRENT_ROLE     CURRENT_TRANSACTION (1.5)  CURRENT_USER
      RECREATE         ROW_COUNT (1.5)            RELEASE
      SAVEPOINT
    </programlisting>

    <para> The following keywords are reserved for future planned use:</para>
    <programlisting>
      ABS              BOOLEAN                    BOTH
      CHAR_LENGTH      CHARACTER_LENGTH           FALSE
      LEADING          OCTET_LENGTH               TRIM
      TRAILING         TRUE                       UNKNOWN
    </programlisting>

    <para>The following keywords were reserved words in Firebird 1.0 and are no longer reserved in
    Firebird 1.5:</para>
    <programlisting>
      BREAK            DESCRIPTOR                 FIRST
      IIF              SKIP                       SUBSTRING
    </programlisting>

    <para>The following non-reserved words are recognised in 1.5 as keywords when used in their respective
    structural contexts:</para>
    <programlisting>
      COALESCE         DELETING                   INSERTING
      LAST             LEAVE                      LOCK
      NULLIF           NULLS                      STATEMENT
      UPDATING         USING
    </programlisting>

    <para>The following new InterBase 6.5 and 7 keywords (not reserved in Firebird) should also be treated as
    if they were reserved, for compatibility:</para>
    <programlisting>
      BOOLEAN          FALSE                      GLOBAL
      PERCENT          PRESERVE                   ROWS
      TEMPORARY        TIES                       TRUE
    </programlisting>
    </section><!-- level 1 -->

  </chapter>
