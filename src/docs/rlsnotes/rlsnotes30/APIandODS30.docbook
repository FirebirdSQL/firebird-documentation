  <chapter id="rnfb30-apiods">
    <chapterinfo>
      <title>Changes to the Firebird API and ODS</title>
      <para><emphasis role="bold">as at Release 3.0</emphasis></para>
    </chapterinfo>

    <section id="rnfb30-apiods-ods" xreflabel="ODS Changes"><!-- Level 1 section -->
      <title>ODS (On-Disk Structure) Changes</title>

      <section id="rnfb30-apiods-ods-number"><!-- Level 2 section -->
        <title>New ODS Number</title>
        <para>Firebird 3.0 creates databases with an ODS (On-Disk Structure) version of 12. In the initial release, 
        a database with an older ODS cannot be opened by Firebird 3.0. In order to work with a database with an 
        older ODS it will be necessary to make a backup using <emphasis>gbak</emphasis> under the older server and 
        restore it with <emphasis>gbak</emphasis> on Firebird 3.</para>
        <note>
          <para>A legacy provider for databases with ODS 8 to 11.2 is planned for a future sub-release.</para>
        </note>
      </section>

      <section id="rnfb30-apiods-ods-impids">
        <title>Implementation ID is Deprecated</title>
        <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
        <para>The Implementation ID in the ODS of a database is deprecated in favour of
        a new field in database headers describing hardware details that need to match in order for the database
        to be assumed to have been created by a compatible implementation.</para>
        <para>The old Implementation ID is replaced with a 4-byte structure consisting of hardware ID,
        operating system ID, compiler ID and compatibility flags. The three ID fields are just for information:
        the ODS does not depend upon them directly and they are not checked when opening the database.</para>
        <para>The compatibility flags <emphasis>are checked</emphasis> for a match between the database and the
        engine opening it. Currently we have only one flag, for endianness. As previously, Firebird will not
        open a database on little-endian that was created on big-endian, nor vice versa.</para>
        <para><emphasis role="bold">Sample gstat Output</emphasis></para>
        <literallayout class="monospaced">
# ./gstat -h employee
Database <quote>/usr/home/firebird/trunk/gen/Debug/firebird/examples/empbuild/employee.fdb</quote>
Database header page information:
        ..............
        Implementation          HW=AMD/Intel/x64 little-endian OS=Linux CC=gcc
        ..............
        </literallayout>

        <para>The purpose is to make it easier to do ports of Firebird for new platforms.</para>
      </section>
      
      <section id="rnfb30-apiods-dbsize">
        <title>Maximum Database Size</title>
        <para>Maximum database size is increased to 2<superscript>32</superscript> pages (previously
        2<superscript>31</superscript> pages). The new limit is 16TB|32TB|64TB, depending on 
        the page size.</para>
      </section>

      <section id="rnfb30-apiods-page_size"><!-- Level 2 section -->
        <title>Maximum Page Size</title>
        <para>The maximum page size remains 16 KB (16384 bytes).</para>
      </section>

      <section id="rnfb30-apiods-num_buffers"><!-- Level 2 section -->
        <title>Maximum Number of Page Buffers in Cache</title>
        <para>The maximum number of pages that can be configured for the database cache
        depends on whether the database is running under 64-bit or 32-bit Firebird:</para>
        <itemizedlist>
          <listitem>
            <para>64-bit :: 2<superscript>31</superscript> -1 (2,147,483,647) pages</para>
          </listitem>
          <listitem>
            <para>32-bit :: 128,000 pages, i.e., unchanged from V.2.5</para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="rnfb30-apiods-transaclimit">
        <title>Extension of Transaction ID Space Limit</title>
        <author>
          <firstname>Dmitry</firstname><surname>Yemanov</surname>
        </author>
        <para>Historically, transaction ID space was limited to 2<superscript>31</superscript>
        transactions, counted from the time the database was created.  After that point, the database becomes
        unavailable until backup and restore is performed to reset the transaction ID counter back to zero.
        Initially in Firebird 3.0, the transaction ID space was raised to 2<superscript>32</superscript>
        transactions, doubling the database up-time without backup and restore.</para>
        <para>This improvement request is about shifting that limit even further, with the introduction
        of 48-bit internal transaction IDs that are publicly (via the API and the MON$ tables) represented as
        64-bit numbers. This makes the new limit roughly equal to 2.8 * 10<superscript>14</superscript>
        transactions.  Later, it could be extended up to the 2<superscript>63</superscript> limit.</para>
        <para>The implemented solution has no additional storage overhead until the transaction counters grow
        beyond the 2<superscript>32</superscript> boundary.</para>
      </section>

      <section id="rnfb30-apiods-otherlimits">
        <title>Limits Raised for Attachment and Statement IDs</title>
        <para>Attachment IDs and statement IDs were changed to 64-bit numbers, both internally and externally 
        via the API and the MON$ tables.</para>
      </section>

      <section id="rnfb30-apiods-systables"><!-- L2 -->
        <title>System Tables</title>
        <section id="rnfb30-apiods-newsystables"><!-- L3 -->
          <title>New System Tables</title>
          <simplelist type="horiz" columns="2">
            <member>RDB$AUTH_MAPPING</member><member>Stores authentication and other security mappings</member>
            <member>RDB$PACKAGES</member><member>Header for SQL packages</member>
            <member>RDB$DB_CREATORS</member><member>A list of users granted the CREATE DATABASE privilege 
            when using the specified security database</member>
            <member>SEC$USERS</member><member>Virtual table to query the local user list</member>
            <member>SEC$USER_ATTRIBUTES</member><member>Virtual table storing local user attributes</member>
            <member>SEC$DB_CREATORS</member><member>SQL interface to access the list in RDB$CREATORS, i.e.
            <function>select * from SEC$DB_CREATORS</function></member>
            <member>SEC$GLOBAL_AUTH_MAPPING</member><member>SQL interface to access the members of 
            RDB$AUTH_MAPPING that have access to all databases using the specified security database, i.e.
            <function>select * from SEC$GLOBAL_AUTH_MAPPING</function>.</member>
            <member></member><member>For information about authentication mapping, see 
             <link linkend="rnfb30-security-mapping"><citetitle>Mapping of Users to Objects</citetitle></link>
             in the Security chapter.</member>
          </simplelist>
        </section><!-- L3 -->
        <section><!-- L3 -->
          <title>Changes to System Tables</title>
            <section><!-- L4 -->
              <title>RDB$SYSTEM_FLAG</title>
              <author><firstname>Claudio</firstname><surname>Valderrama C.</surname></author>
              <para>RDB$SYSTEM_FLAG has been made NOT NULL in all tables.</para>
              <para><ulink url="http://tracker.firebirdsql.org/browse/CORE-2787">CORE-2787</ulink>.</para>
            </section><!-- L4 -->

            <section><!-- L4 -->
              <title>RDB$TYPES</title>
              <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
              <para>Missing entries were added to RDB$TYPES. They describe the numeric values for these columns:</para>
             <literallayout class="monospaced">
  RDB$PARAMETER_TYPE     (table RDB$PROCEDURE_PARAMETERS)
  RDB$INDEX_INACTIVE     (table RDB$INDICES)
  RDB$UNIQUE_FLAG        (table RDB$INDICES)
  RDB$TRIGGER_INACTIVE   (table RDB$TRIGGERS)
  RDB$GRANT_OPTION       (table RDB$USER_PRIVILEGES)
  RDB$PAGE_TYPE          (table RDB$PAGES)
  RDB$PRIVATE_FLAG       (tables RdB$PROCEDURES and RDB$FUNCTIONS)
  RDB$LEGACY_FLAG        (table RDB$FUNCTIONS)
  RDB$DETERMINISTIC_FLAG (table RDB$FUNCTIONS)
              </literallayout>
            </section><!-- L4 -->
            <section id="rnfb3-apiods-montables">
            <title>Monitoring Tables</title>
              <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>

              <section id="rnfb3-apiods-montables-reporting"><!-- L5 -->
                <title>Changes to Client Address Reporting</title>
                <para>Prior to Firebird 3.0, the network address of remote clients
                were reported in <function>MON$ATTACHMENTS.MON$REMOTE_ADDRESS</function>
                and <function>RDB$GET_CONTEXT('SYSTEM', 'CLIENT_ADDRESS')</function>.
                For TCP/IP protocol (a.k.a. INET), it contained a TCPv4 dot-separated
                address. For Named Pipes (a.k.a. WNET, NetBeui) protocol, it was always
                NULL. For shared memory (aka XNET) protocol, it contained the local host
                name.</para>
                <para>Starting with Firebird 3.0, the network address of a remote client
                contains the TCP/IP port number of the remote client, separated with a slash:
                  <blockquote><literallayout class="monospaced">
&lt;IP address&gt;/&lt;port&gt;
                  </literallayout></blockquote>
                The port number is also retrieved via the new built-in context variable
                RDB$GET_CONTEXT('SYSTEM', 'CLIENT_PORT').
                </para>
                <para>The host name is also reported now, in the new column MON$REMOTE_HOST.</para>

                <warning>
                  <title>Alert</title>
                  <para>The WNET (Named Pipes/Netbeui) protocol should be considered as
                  deprecated.  It is likely to be abandoned in a future version.</para>
                </warning>
              </section>

              <para>Per-table performance counters have been added to all of the monitoring tables.  See Tracker
               <ulink url="http://tracker.firebirdsql.org/browse/CORE-4564">CORE-4564</ulink>.</para>

              <section id="rnfb3-apiods-montables-chgs"><!-- L5 -->
                <title>MON$ATTACHMENTS</title>
                <para>New information is now available:</para>
                <itemizedlist>
                  <listitem>
        <para>Operating system user name.  See Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-3779">CORE-3779</ulink>.</para>
      </listitem>
                  <listitem>
        <para>Protocol and client library version.  See Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-2780">CORE-2780</ulink>.</para>
      </listitem>
                  <listitem>
        <para>Client host name.  See Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-2187">CORE-2187</ulink>.</para>
                  </listitem>
                  <listitem>
        <para>authentication method used for connection (MON$AUTH_METHOD). See
        Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-4222">CORE-4222</ulink>.</para>
                  </listitem>
                  <listitem>
        <para> MON$REMOTE_ADDRESS now contains the &lt;IP&gt;/&lt;port&gt; string. See
        Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-5028">CORE-5028</ulink>.</para>
                  </listitem>
                </itemizedlist>

              </section><!-- L5 -->

              <section><!-- L5 -->
                <title>MON$DATABASE</title>
                <itemizedlist>
                  <listitem>
                  <para>Database owner (MON$OWNER) added.
    See Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-4218">CORE-4218</ulink>.</para>
                  </listitem>
                  <listitem>
                    <para>Security database type (MON$SEC_DATABASE) flag added.  Value will be
                    one of Default/Self/Other.
                    See Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-4729">CORE-4729</ulink>.</para>
                  </listitem>
                </itemizedlist>
              </section><!-- L5 -->

              <section><!-- L5 -->
                <title>MON$STATEMENTS</title>
                  <para>The PLAN is now included.  See Tracker <ulink
    url="http://tracker.firebirdsql.org/browse/CORE-2303">CORE-2303</ulink>.</para>
              </section><!-- L5 -->
            </section><!-- L4 -->
          </section><!-- L3 -->
        </section><!-- L2 -->
    </section><!-- L1 -->


      <!-- API -->

    <section id="rnfb30-apiods-api" xreflabel="New APIs"><!-- Level 2 section -->
      <title>Application Programming Interfaces</title>
      <para>A new public API replaces the legacy one in new applications, especially object-oriented
      ones. The interface part can be found in the header file <filename>Interfaces.h</filename> in the
      directory <filename>/include/firebird</filename> beneath the installation root directory.</para>
      <note>
        <para>POSIX installations have a symlink pointing 
        to <filename>/usr/include/firebird/Interfaces.h</filename></para>
      </note>
      <para>The new public API can be also used inside user-defined routines (UDR, q.v.) for callbacks
      inside the engine, allowing a UDR to select or modify something in the database, for example.</para>
      <para>The main difference between the new API and the legacy one is that UDRs can query and modify
      data in the same connection or transaction context as the user query that called that UDR.
      It is now possible to write external triggers and procedures, not just external functions (UDFs).</para>

      <section><!-- L2 -->
        <title>Interfaces and the New Object-oriented API</title>
        <author>
          <firstname>Alex</firstname><surname>Peshkov</surname>
        </author>
        <para>Firebird needed a modernised API for a number of compelling reasons.</para>
        <itemizedlist>
          <listitem>
            <para>High on the list was the limitation of the 16-bit integer pervading the legacy API,
            encompassing message size, SQL operator length, BLOB data portions, to name a few examples.
            While 16-bit was probably adequate when that old API came to life, in today's environments
            it is costly to work around.</para>
            <para>A trivial solution might be to add new functions that support 32-bit variables. The big
            downside is the obvious need to retain support for the old API by having pairs of functions
            with the same functionality but differing integer sizes. In fact, we did something like this
            to support 64-bit performance counters, for no better reason than being pressed to provide for
            it without having a more elegant way to implement it.</para>
          </listitem>

          <listitem>
            <para>Another important reason, less obvious, derives from the era when Firebird's predecessor,
            InterBase, did not support SQL.  It used a non-standard query language, GDML, to manage databases.
            Data requests were transported between client and server using messages whose formats were defined at
            request compilation time in BLR (binary language representation). In SQL, the operator does not
            contain the description of the message format so the decision was taken to surround each message with
            a short BLR sequence describing its format.</para>
            <para>The ISC API also has the XSQLDA layer over BLR. The trap with the XSQLDA solution is that it
            encapsulates both the location of the data and their format, making it possible to change location or
            format (or both) between fetch calls.  Hence, the need for the BLR wrapping in
            <emphasis>every</emphasis> fetch call&mdash;notwithstanding, this potential capability to change the
            data format between fetches was broken in the network layer before Firebird existed.</para>
            <para>But to support the XSQLDA layer that rides on top of the message-based API that lower level API
            also has support sending format BLR at every turn.</para>

            <para>This system involving calls processing data through multiple layers is hard to extend and wastes
            performance; the SQLDA is not simple to use;  the desire to fix it was strong.</para>
          </listitem>

          <listitem>
            <para>Other reasons&mdash;numerous but perhaps less demanding&mdash;for changing the API included
            enhancing the status vector and optimizing dynamic library loading.  Interfaces also make it so much
            easier and more comfortable to use the messages API.</para>
          </listitem>

        </itemizedlist>

        <section><!-- L3 -->
          <title>The Non-COM Choice</title>
          <para>The new interfaces are not compatible with COM, deliberately, and the reasons have to do
          with future performance enhancement.</para>

          <para>At the centre of the Providers architecture in Firebird 3.0 is the <command>y-valve</command>,
          which is directed at dispatching API calls to the correct provider.  Amongst the potential providers
          are older ones with potentially older interfaces.  If we used COM, we would have to call the method
          <command>IUnknown</command> for each call (including record fetch), just to ensure that the provider
          really had some newer API method. Along with that comes the likelihood of future additions to the
          catalogue of API calls to optimize performance. A COM-based solution does not play well with that.</para>

          <para>Firebird interfaces, unlike COM, support multiple versions.  The interface version is
          determined by the total number of virtual functions it encompasses and is stored as a pointer-size
          integer at the beginning of the virtual functions table. This makes it possible for very fast 
          checking of the interface version, since it requires no virtual call. That is to say, the pointer 
          check has no overhead, unlike COM.</para>

        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>The Hierarchy of Interfaces</title>
          <para>A detailed discussion of all the functions presented by all the interfaces is outside the
          scope of this overview.  The general schematic looks like this:</para>

          <mediaobject>
            <imageobject>
              <imagedata srccredit="Alex Peshkov" fileref="images/interfaces_hierarchy.png" format="PNG"
               align="center" valign="middle" scale="33%"/>
            </imageobject>
          </mediaobject>

          <para>The base of the structure is <command>IVersioned</command>.  It is the interface that
          enables a version upgrade. A lot of interfaces not requiring additional lifetime control are
          based directly on <command>IVersioned</command>. <command>IMaster</command> is one example
          already mentioned.  Others include a number of callback interfaces whose lifetimes must
          match the lifetimes of the objects from which they were to be used for callback.</para>

          <para>Two interfaces deal with lifetime control: <command>IDisposable</command> and
          <command>IRefCounted</command>. The latter is especially active in the creation of other
          interfaces:  <command>IPlugin</command> is reference counted, as are many other interfaces
          that are used by plug-ins. These include the interfaces that describe database attachment,
          transaction management and SQL statements.</para>
          
          <para>Not everything needs the extra overhead of a reference-counted interface.  For example,
          IMaster, the main interface that calls functions available to the rest of the API, has unlimited
          lifetime by definition.  For others, the API is defined strictly by the lifetime of a parent
          interface;  the IStatus interface is non-threaded.  For interfaces with limited lifetimes it is
          of benefit to have a simple way to destroy them, that is, a dispose() function.</para>

          <para>Each plug-in has one and only one main interface&mdash;<command>IPlugin</command>&mdash;which
          is responsible for basic plug-in functionality.  In fact, a lot of plugins have only that
          interface, although that is not a requirement.</para>

          <para>Finally, there is <command>IProvider</command>, a kind of <quote>main</quote> plug-in
          in the Firebird API.  <command>IProvider</command> is derived from <command>IPlugin</command> and
          must be implemented by every provider.  If you want to write your own provider you must implement
          <command>IProvider</command>.  It is implemented also by the <command>y-valve</command>: it is
          the <command>y-valve</command> implementation that is returned to the user when
          the <command>getDispatcher()</command> function from the master interface is called.</para>
          <para><command>IProvider</command> contains functions enabling creation of an attachment to
          a database (attach and create) or to the Services Manager.</para>
        </section><!-- L3 -->


        <section><!-- L3 -->
          <title>Interfaces Q &amp; A</title>

          <para>Q. We access new API using IMaster. But how to get access to IMaster itself?</para>
          <itemizedlist>
            <listitem>
              <para>A. This is done using just the one new API function <command>fb_get_master_interface()</command>.
              It is exported by the <filename>fbclient</filename> library. Also IMaster is passed as a parameter to
              each plug-in during its registration in the system.</para>
            </listitem>
          </itemizedlist>

          <para>Q. The non-use of COM-based interfaces was said to be to avoid working with IUnknown
          methods and that this is done due to performance issues. Instead you have to check 
          the interface version. Why is that faster than using IUnknown?</para>
          <itemizedlist>
            <listitem>
              <para>A. As was already mentioned we do not need to execute virtual calls when checking the
              interface version. Taking into an account that each virtual call means a reset of the CPU 
              cache, it is an important difference, especially for the very small calls like getting 
              specific metadata properties from IMetadata.</para>
            </listitem>
          </itemizedlist>
        </section><!-- L3 -->
      </section><!-- L2 -->

      <section><!-- L2 -->
        <title>Other New APIs</title>
        <para>Other new APIs support various plug-ins by declaring the interfaces between the engine
        and the plug-in. Besides pluggable authentication and pluggable encryption, Firebird 3 supports
        <quote>external engines</quote>, bridges between the engine and the execution environments that
        can run UDRs: native code, Java and others. By and large they are intended for use by third-party
        solution providers, rather than for client application development.</para>
        <para>For creating custom plug-ins and bridges, the relevant interface (API) needs to be
        implemented in the plug-in code.</para>
      </section><!-- L2 -->

      <section><!-- L2 -->
        <title>API Improvements</title>
        <para>Improvements to the legacy API include.-</para>
        
<!-- Support for scrollable cursors -->

        <section id="rnfb30-dsql-scrollcursors"><!-- L3 -->
          <title>Scrollable Cursor Support</title>
          <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
          <para>In PSQL, a <link linkend="rnfb30-psql-scrollcursors">scrollable cursor</link>
          can be operated on directly to navigate flexibly from the current row to any another
          row either forwards or backwards. API support is available to make scrollable cursors
          available to DSQL applications.</para>
          <section id="rnfb30-dsql-cursoruse"><!-- L4 -->
            <title>Scrollable Cursor Usage</title>
            <para>The result set must be opened with the flag <command>IStatement::CURSOR_TYPE_SCROLLABLE</command>
            explicitly specified.</para>
            <para><emphasis role="bold">Fetch Methods</emphasis></para>
            <para>The following fetch methods of the IResultSet interface are available:</para>
            <programlisting>
int fetchNext(IStatus* status, void* message);
// equivalent to FETCH NEXT FROM &lt;cursor name&gt;
            </programlisting>
            <para>Moves the cursor's current position to the next row and returns it. If the cursor is
            empty or already positioned at the last row, the condition <command>NO_DATA</command>
            is returned.</para>
            <programlisting>
int fetchPrior(IStatus* status, void* message);
// equivalent to FETCH PRIOR FROM &lt;cursor name&gt;
            </programlisting>
            <para>Moves the cursor's current position to the prior row and returns it. If the cursor is
            empty or already positioned at the first row, the condition <command>NO_DATA</command>
            is returned.</para>
            <programlisting>
int fetchFirst(IStatus* status, void* message);
// equivalent to FETCH FIRST FROM &lt;cursor name&gt;
            </programlisting>
            <para>Moves the cursor's current position to the first row and returns it. If the cursor is
            empty, the condition <command>NO_DATA</command> is returned.</para>
            <programlisting>
int fetchLast(IStatus* status, void* message);
// equivalent to FETCH LAST FROM &lt;cursor name&gt;
            </programlisting>
            <para>Moves the cursor's current position to the last row and returns it. If the cursor is
            empty, the condition <command>NO_DATA</command> is returned.</para>
            <programlisting>
int fetchAbsolute(IStatus* status, int position, void* message);
// equivalent to FETCH ABSOLUTE &lt;position&gt; FROM &lt;cursor name&gt;
            </programlisting>
            <para>Moves the cursor's current position to the specified &lt;position&gt; and returns the
            located row.  If &lt;position&gt; is beyond the cursor's boundaries, the
            condition <command>NO_DATA</command> is returned.</para>
            <programlisting>
int fetchRelative(IStatus* status, int offset, void* message);
// equivalent to FETCH RELATIVE &lt;offset&gt; FROM &lt;cursor name&gt;
            </programlisting>
            <para>Moves the cursor's current position backward or forward by the specified &lt;offset&gt;
            and returna the located row.  If the calculated position is beyond the cursor's boundaries, the
            condition <command>NO_DATA</command> is returned.</para>
          </section><!-- L4 -->
          <note>
            <title>Notes</title>
            <orderedlist>
              <listitem>
                <para>When a scrolling option is omitted, NO SCROLL is implied (i.e., the cursor is opened
                as forward-only). This means that only the <command>fetchNext()</command> API call can be
                used. Other fetch methods will return an error.</para>
              </listitem>
              <listitem>
                <para>Scrollable cursors are internally materialized as a temporary record set, thus consuming
                memory/disk resources, so this feature should be used only when really necessary.</para>
              </listitem>
            </orderedlist>
          </note>

        </section><!-- L3 -->
        
        <section id="rnfb30-api-spb-gbakstats"><!-- L3 -->
          <title>SPB Support for New Statistics Feature in <emphasis>gbak</emphasis> Output</title>
          <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
          <para>A new, much requested feature was added to <emphasis>gbak</emphasis> verbose
          output:  optional run-time statistics.  <link linkend="rnfb30-util-gbakstats">Read about it
          here</link>.  The feature is fully supported in the Services API with a new item
          in the SPB (Services Parameter Block),
            <blockquote><literallayout class="monospaced">
#define isc_spb_bkp_stat 15
            </literallayout></blockquote>
          along with its synonym
            <blockquote><literallayout class="monospaced">
#define isc_spb_res_stat isc_spb_bkp_stat
            </literallayout></blockquote>
          </para>
         <bridgehead renderas="sect4">Usage</bridgehead>
          <para>
            <blockquote><literallayout class="monospaced">
isc_spb_bkp_stat, &lt;len&gt;, &lt;string&gt;
isc_spb_res_stat, &lt;len&gt;, &lt;string&gt;
            </literallayout></blockquote>
          where <function>&lt;len&gt;</function> (2 bytes) indicates the length of 
          the following string parameter, and &lt;string&gt; (1-4 bytes) is a string 
          consisting of one character per statistics item.</para>
          <para>The <emphasis>fbsvcmgr</emphasis> utility also supports the new SPB tags.</para>

        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>Better Error Reports for String Overflows</title>
          <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
          <para>Include expected and actual string length in the error message
          for string overflows (SQLCODE -802).</para>
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>More Detail in <quote>Wrong Page Type</quote> Error Reports</title>
          <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
          <para>More details in the error message &quot;wrong page type&quot;, i.e.,
          identifying expected and encountered page types by name instead of numerical
          type.</para>
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>New Item for isc_database_info() Call</title>
          <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
          <para>An option was added to the API function <function>isc_database_info()</function> to 
          return the number of free pages in a database.  See 
          <ulink url="http://tracker.firebirdsql.org/browse/CORE-1538">CORE-1538</ulink>.</para>
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>New Services Tag for Overriding LINGER</title>
          <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
          <para>The Services API now includes the tag
          <command>isc_spb_prp_nolinger</command>, for example (in one line):</para>
          <literallayout class="monospaced">
 fbsvcmgr host:service_mgr user sysdba password xxx
        action_properties dbname employee prp_nolinger
          </literallayout>

          <para>For information regarding LINGER,
          see <link linkend="rnfb30-ddl-enhance-linger">the write-up in the DDL chapter</link>.</para>
        </section><!-- L3 -->

        <section id="rnfb30-apiods-api-winlocal">
          <title>New Connection Formats for Local Superserver Clients on Windows</title>
          <para>In previous Firebird versions, a serverless protocol known as <quote>Windows
          Local</quote> was available to local clients connecting to Superserver on a
          Windows platform, using the XNET subsystem.  A typical connection string looked like this:
          <literallayout class="monospaced">
  c:\Program Files\Firebird_2_5\examples\empbuild\employee.fdb
          </literallayout>
          Under the new unified server, that form of connection attempts to load an
          embedded server.  It is no longer valid for a serverless client connection
          to Superserver.  If you try, you will get a refusal message to the effect
          <quote>File is in use by another process</quote>.  This is not a bug.  Since 
          Superserver clients share resources, another server (in this case, an embedded 
          server) cannot attach a client to the same database that Superserver has any 
          clients attached to.</para>
          <para>However, all is not lost.  The XNET subsystem can still do local client
          sessions for Superserver.  You just need a more elaborate connection string now.
          You have a few choices:
            <itemizedlist>
              <listitem>this one is the former <quote>Windows local</quote>, using the XNET
              subsystem and shared memory for a (nominally) serverless connection:
                <literallayout class="monospaced">
  xnet://alias-or-path-to-database
                </literallayout>
          So, for our connection to the employee database:
                <literallayout class="monospaced">
  xnet://c:\Program Files\Firebird_3_0\examples\empbuild\employee.fdb
                </literallayout>
          or using an alias:
                <literallayout class="monospaced">
  xnet://employee
                </literallayout>
              </listitem>
              <listitem>Connection to host/port via TCP:
                <literallayout class="monospaced">
  inet://host:port/alias-or-path-to-database
                </literallayout>
              </listitem>
              <listitem>Connection to host/port via Named Pipes (aka NetBEUI):
                <literallayout class="monospaced">
  wnet://host:port/alias-or-path-to-database
                </literallayout>
              </listitem>
              <listitem>Connection to localhost via TCP:
                <literallayout class="monospaced">
  inet://alias-or-path-to-database
                </literallayout>
              </listitem>
              <listitem>Connection to localhost via named pipes (aka NetBEUI):
                <literallayout class="monospaced">
  wnet://alias-or-path-to-database
                </literallayout>
              </listitem>
            </itemizedlist>
          </para>
        </section>

        <section id="rnfb30-apiods-api-onlinevalidation"><!-- Level 3 section -->
          <sectioninfo>
            <title>Perform Some Validation Services On-line</title>
            <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
          </sectioninfo>
          <para>This feature was ported forward from Firebird 2.5.4.</para>
          <para>Database validation enables low-level checks of the consistency
          of on-disk structures and even to fix some minor corruptions. The
          recommended procedure for any valuable database is for the DBA to validate
          a database periodically to ensure it is healthy.</para>
          <para>Exclusive access to the database is required:  any kind of concurrent
          access is forbidden during validation.  Sometimes, blocking user access could
          be a major hold-up, especially if the database is large and complex.</para>
          <para>Online validation is a new feature that allows some consistency checks
          to be performed without exclusive access.</para>
          <section><!-- L4 -->
            <title>What Online Validation Can Do</title>
            <itemizedlist>
              <listitem>
                <para>validate some (or all) user tables in a database.</para>
                <para><emphasis>System tables are not validated.</emphasis></para>
              </listitem>
              <listitem>
                <para>validate some (or all) indices</para>
              </listitem>
            </itemizedlist>

             <para>Other ODS checks, such as Header\PIP\TIP\Generators pages, are not
             performed.</para>
           </section><!-- L4 -->

           <section><!-- L4 -->
             <title>Protection During Online Validation</title>
             <para>While a table (and\or its index) is undergoing validation, user attachments
             are allowed to read this table. Any attempt to change data (INSERT\UPDATE\DELETE)
             will wait until validation finishes or, depending on the lock timeout of the
             user transaction, will return a lock timeout error.</para>
             <para>Any kind of garbage collection on the table or its indexes is disabled whilst
             it is undergoing validation:</para>
             <itemizedlist>
               <listitem>
                 <para>background and cooperative garbage collection will just skip this table</para>
               </listitem>
               <listitem>
                 <para>sweep will be terminated with an error</para>
               </listitem>
             </itemizedlist>
             <para>When online validation starts to check a table, it acquires a couple of locks
             to prevent concurrent modifications of its data:</para>
             <itemizedlist>
               <listitem>
                 <para>a relation lock in PR (protected read) mode</para>
               </listitem>
               <listitem>
                 <para>(NEW) a garbage collection lock in PW (protected write) mode</para>
               </listitem>
             </itemizedlist>
             <para>Both locks are acquired using a user-specified lock timeout. An error is
             reported for any lock request that fails and that table is skipped.</para>
           </section><!-- L4 -->

           <para>Once the locks are acquired, the table and its indexes are validated in the
           same way as a full validation does it.  The locks are released when it completes
           and the whole procedure is repeated for the next table.</para>
           <section><!-- L4 -->
             <title>The New Services API action: isc_action_svc_validate</title>
             <para>Online validation is implemented as a Firebird service and is accessed through
             the Services API.  Thus, it cannot be run from the <emphasis>gfix</emphasis> utility.</para>
             <para>The call involves the following elements:</para>
             <literallayout class="monospaced">
Action:
	isc_action_svc_validate

Parameters:
	isc_spb_dbname :
		database file name, string, mandatory

	isc_spb_val_tab_incl, isc_spb_val_tab_excl,
	isc_spb_val_idx_incl, isc_spb_val_idx_excl :
		patterns for tables\indices names, string, optional

	isc_spb_val_lock_timeout :
		lock timeout, integer, optional

Output:
	text messages with progress of online validation process
             </literallayout>
           </section><!-- L4 -->
           <section><!-- L4 -->
             <title>Using isc_action_svc_validate Interactively</title>
             <para>The <emphasis>fbsvcmgr</emphasis> utility has full support for
             the new service.  The syntax is:</para>
             <programlisting>
fbsvcmgr [host:]service_mgr [user &lt;...&gt;] [password &lt;...&gt;]
	action_validate dbname &lt;filename&gt;
	[val_tab_incl &lt;pattern&gt;]
	[val_tab_excl &lt;pattern&gt;]
	[val_idx_incl &lt;pattern&gt;]
	[val_idx_excl &lt;pattern&gt;]
	[val_lock_timeout &lt;number&gt;]
             </programlisting>
             <para>where
             <simplelist type="horiz" columns="2">
             <member>val_tab_incl</member><member>pattern for table names to include in validation run</member>
             <member>val_tab_excl</member><member>pattern for table names to exclude from validation run</member>
             <member>val_idx_incl</member><member>pattern for index names to include in validation run,
						by default %, i.e. all indexes</member>
             <member>val_idx_excl</member><member>pattern for index names to exclude from validation run</member>
             <member>val_lock_timeout</member><member>lock timeout, used to acquire locks for table to validate,
						in seconds, default is 10 secs. 0 is no-wait, -1 is infinite wait</member>
             </simplelist>
             </para>
             <note>
               <title>Usage Notes</title>
               <itemizedlist>
                 <listitem>Patterns are regular expressions, processed by the same rules as SIMILAR TO expressions.</listitem>
                 <listitem>All patterns are case-sensitive, regardless of database dialect.</listitem>
                 <listitem>If the pattern for tables is omitted then all user tables will be validated.</listitem>
                 <listitem>If the pattern for indexes is omitted then all indexes of the appointed tables will
                 be validated.</listitem>
                 <listitem>System tables are not validated.</listitem>
                 <listitem>
                  <para>To specify a list of tables or indexes:</para>
                  <orderedlist type="a">
                    <listitem>Separate names with the pipe character '|'</listitem>
                    <listitem>Do not add spaces: TAB1 | TAB2 is wrong</listitem>
                    <listitem>Enclose the whole list in double quotes to avoid confusing the
                    command interpreter</listitem>
                  </orderedlist>
                 </listitem>
               </itemizedlist>
             </note>
             <para><emphasis role="bold">Examples</emphasis></para>

             <orderedlist>
               <listitem>
                 <para>Validate all tables in database 'c:\db.fdb' with names starting with 'A'.
                 Indexes are not validated. Lock wait is not performed.</para>
                 <programlisting>
fbsvcmgr.exe service_mgr user SYSDBA password masterkey
		action_validate dbname c:\db.fdb
		val_tab_incl A%
		val_idx_excl %
		val_lock_timeout 0
                 </programlisting>
               </listitem>
               <listitem>
                 <para>Validate tables TAB1 and TAB2 and all their indexes.
                 Lock wait timeout is 10 seconds (the default):</para>
                 <programlisting>
fbsvcmgr.exe service_mgr user SYSDBA password masterkey
		action_validate dbname c:\db.fdb
		val_tab_incl &quot;TAB1|TAB2&quot;
                 </programlisting>
               </listitem>
               <listitem>
                 <para>Default behavior of val_XXX options: validate all user tables and
                 their indexes in database 'c:\db.fdb', lock wait is the default
                 10 seconds:</para>
                 <programlisting>
fbsvcmgr.exe service_mgr user SYSDBA password masterkey
               action_validate dbname c:\db.fdb
                 </programlisting>
               </listitem>
             </orderedlist>
           </section><!-- L4 -->
        </section><!--L3-->

        <section><!-- L3 -->
          <title>Code Improvement</title>
          <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
          <para>(<ulink url="http://tracker.firebirdsql.org/browse/CORE-4387">CORE-4387</ulink>)
          &nbsp;&nbsp;The functions <code>IStatement::execute()</code>
          and <code>IAttachment::execute()</code> now return an error pointer to the old
          transaction interface.</para>
        </section>

      </section><!-- L2 -->
    </section><!-- L1 -->
  </chapter>

