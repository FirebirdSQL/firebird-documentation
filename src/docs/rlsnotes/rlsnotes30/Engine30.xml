<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
  <chapter id="rnfb30-engine" xreflabel="Changes in the Firebird Engine">
    <chapterinfo>
      <title>Changes in the Firebird Engine</title>
    </chapterinfo>
    <para>In Firebird 3, the remodelling of the architecture that was begun in v.2.5 was completed
    with the implementation of full SMP support for the Superserver model.  In the new scheme, it is
    possible to configure the execution model individually per database.</para>

    <section><!-- L1 -->
      <sectioninfo>
        <author>
          <firstname>Dmitry</firstname><surname>Yemanov</surname>
        </author>
      </sectioninfo>
      <title>Remodelled Architecture</title>
      <para>The remodelled architecture integrates the core engine for Classic/Superclassic, Superserver
      and embedded models in a common binary.  The cache and lock behaviours that distinguish the execution
      models are now determined externally by the settings in the new configuration parameter
      <command>ServerMode</command>.  The connection method is determined by the order and content of another
      parameter, <command>Providers</command> and the <link linkend="rnfb30-engine-modes-protocols">connection 
      protocol</link> that is deduced at run-time from the connection string supplied when a client requests 
      an attachment.</para>
      
      <para>The parameters for configuring the architecture are specified
      globally (in <filename>firebird.conf</filename>). <command>Providers</command> can be overridden specifically 
      for a database (in <filename>databases.conf</filename>).</para>
      <note>
        <para><filename>databases.conf</filename> is the old <filename>aliases.conf</filename> from previous 
        versions, with a new name. In Firebird 3, the role of this file involves (potentially) much more than 
        being just a lookup for database file paths.  For more details about what can be configured at 
        database level, refer to the chapter
        <link linkend="rnfb30-fbconf">Configuration Additions and Changes</link>.</para>
      </note>

      <section id="rnfb30-engine-modes"><!-- l2 -->
        <title>Server Modes</title>
        <table frame="all">
          <title>Matrix of Server Modes</title>
          <tgroup cols="4" colsep="1" rowsep="1">
            <colspec colname="col1" colwidth="*"></colspec>
            <colspec colname="col2" colwidth="*"></colspec>
            <colspec colname="col3" colwidth="2*"></colspec>
            <colspec colname="col4" colwidth="*"></colspec>
            <spanspec spanname="all" namest="col1" nameend="col4"/>
            <thead valign="middle">
              <row>
                <entry align="center">ServerMode</entry>
                <entry align="center">Synonym</entry>
                <entry align="center">Resource Model</entry>
                <entry align="center">Provider[s]</entry>
              </row>
            </thead>
            <tfoot valign="middle">
              <row>
                <entry align="right" spanname="all"><superscript>1</superscript> <emphasis>Only if exclusive access is available</emphasis></entry>
              </row>
            </tfoot>
            <tbody valign="middle">
              <row>
                <entry>Super</entry>
                <entry>ThreadedDedicated</entry>
                <entry>Database is opened exclusively by a single server process. User attachments are processed 
                by threads launched from the common pool and all share a single database page cache inside the 
                process. <emphasis>This is the installation default</emphasis>.</entry>
                <entry>
                  <simplelist>
                    <member>Remote,</member>
                    <member>Engine12<superscript>1</superscript>,</member>
                    <member>Loopback</member>
                  </simplelist>
                </entry>
              </row>
              <row>
                <entry>Superclassic</entry>
                <entry>ThreadedShared</entry>
                <entry>Databases are opened by a single server process, but access is not exclusive:  an
                embedded process can open the same database concurrently.  User attachments are processed by 
                threads launched from the common pool, each having its own database page cache.</entry>
                <entry>
                  <simplelist>
                    <member>Remote,</member>
                    <member>Engine12,</member>
                    <member>Loopback</member>
                  </simplelist>
                </entry>
              </row>
              <row>
                <entry>Classic</entry>
                <entry>MultiProcess</entry>
                <entry>A separate process is started for each attachment to server.  A database may be opened
                by multiple Classic processes, including local processes for embedded access. Each process has
                its own database page cache.</entry>
                <entry>
                  <simplelist>
                    <member>Remote,</member>
                    <member>Engine12,</member>
                    <member>Loopback</member>
                  </simplelist>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>

      </section><!-- L2 -->

      <section id="rnfb30-engine-providers" xreflabel="Providers"><!-- l2 -->
        <title>Providers</title>
        <para>The providers are more or less what we traditionally thought of as the methods used to
        connect a client to a server, that is to say, across a network, host-locally, via the local loopback
        (<quote>localhost</quote>) or by a more direct local connection (the old <filename>libfbembed.so</filename>
        on POSIX, now implemented as the plug-in library <filename>libEngine12.so</filename>; on Windows,
        <filename>engine12.dll</filename>; on MacOSX, <filename>engine12.dylib</filename>).
          <itemizedlist>
            <listitem><para>In <filename>firebird.conf</filename>, all are available by default, as follows:</para>
              <literallayout class="monospaced">
#Providers = Remote,Engine12,Loopback
              </literallayout>
            </listitem>
            <listitem><para>In <filename>databases.conf</filename>, one or more providers can be blocked by pasting
            the line from <filename>firebird.conf</filename>, uncommenting it, and deleting the unwanted
            provider[s].</para></listitem>
          </itemizedlist>
        </para>
        <section id="rnfb30-engine-providers-about"><!-- L3 -->
          <sectioninfo>
            <author>
              <firstname>Alex</firstname><surname>Peshkov</surname>
            </author>
          </sectioninfo>
          <title>The Providers Architecture</title>
          <para>Although a key feature of Firebird 3, the Providers architecture is not new. Providers existed
          historically in Firebird's predecessors and, though well hidden, are present in all previous
          versions of Firebird. They were introduced originally to deal with a task that has been
          performed since then by <quote>interface layers</quote> such as ODBC, ADO, BDE and the like, to
          enable access to different database engines using a single external interface.</para>

          <para>Subsequently, this Providers architecture (known then as Open Systems Relational Interface, OSRI)
          also showed itself as very efficient for supporting a mix of old and new database formats&#x2014;different
          major on-disk structure versions&#x2014;on a single server having mixed connections to local
          and remote databases.</para>

          <para>The providers implemented in Firebird 3 make it possible to support all these modes (remote connections,
          databases with differing ODS, foreign engines) as well as <emphasis>chaining</emphasis> providers.
          Chaining is a term for a situation where a provider is using a callback to the standard API when
          performing an operation on a database.</para>
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>The Components</title>
          <para>The main element of the Providers architecture is the <command>y-valve</command>.
          On the initial <function>attach</function> or <function>create database</function> call <command>y-valve</command>
          scans the list of known providers and calls them one by one until one of them completes the requested operation
          successfully. For a connection that is already established, the appropriate provider is called at once with
          almost zero overhead.</para>

          <para>Let's take a look at some samples of <command>y-valve</command> operation when it selects
          the appropriate provider at the <function>attach</function> stage.  These use the default configuration,
          which contains three providers:</para>
          <itemizedlist>
            <listitem>
              <para><command>Remote</command> (establish network connection)</para>
            </listitem>
            <listitem>
              <para><command>Engine12</command> (main database engine)</para>
            </listitem>
            <listitem>
              <para><command>Loopback</command> (force network connection to the local server for &lt;database name&gt; 
              without an explicit network protocol being supplied).</para>
            </listitem>
          </itemizedlist>

          <para>The typical client configuration works this way: when one attaches to a database
          called <function>RemoteHost:dbname</function> (TCP/IP syntax) or <function>\\RemoteHost\dbname</function>
          (NetBios) the <command>Remote</command> provider detects explicit <link 
          linkend="rnfb30-engine-modes-protocols">network protocol syntax</link> and, finding it first in the Provider 
          list, redirects the call to RemoteHost.</para>

          <para>When &lt;database name&gt; does not contain a network protocol but just the database name, the
          <command>Remote</command> provider rejects it and the <command>Engine12</command> provider comes to
          the fore and tries to open the named database file.  If it succeeds, we get an embedded connection to the
          database.</para>
          <note>
            <para>A special <quote>embedded library</quote> is no longer required.  To make the embedded connection,
            the standard client loads the appropriate provider and becomes an embedded server.</para>
          </note>

          <section><!-- L4 -->
            <title>Failure Response</title>
            <para>But what happens if the engine returns an error on an attempt to attach to a database?</para>
            <itemizedlist>
              <listitem>
                <para>If the database file to be attached to does not exist there is no interest at all.</para>
              </listitem>
              <listitem>
                <para>An embedded connection may fail if the user attaching to it does not have enough rights to open
                the database file. That would be the normal case if the database was not created by that user in
                embedded mode or if he was not explicitly given OS rights for embedded access to databases on that box.</para>
                <note>
                  <para>Setting access rights in such a manner is a requirement for correct Superserver operation.</para>
                </note>
              </listitem>
              <listitem>
                <para>After a failure of <command>Engine12</command> to access the database, the <command>Loopback</command>
                provider is attempted for an attach. It is not very different to <command>Remote</command> except
                that it tries to access the named database <function>&lt;dbname&gt;</function> on a server running a
                TCP/IP local loopback.</para>

                <para>On Windows, XNET is tried first, then TCP/IP loopback (with localhost: prepended to &lt;dbname&gt;), then
                Named Pipes (NetBEUI) loopback (with \\.\ prepended). The server may be started with XNET (or any other
                protocol) disabled, so we try all the options. On POSIX only TCP/IP protocol is supported, other options
                are not available</para>
                <para>If the attachment succeeds, a remote-like connection is established with the database even though it is
                located on the local machine.</para>
              </listitem>
            </itemizedlist>
          </section><!-- L4 -->
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>Other Providers</title>
          <para>Use of providers is not limited to the three standard ones. Firebird 3 does not support pre-ODS 12
          databases. Removing support for old formats from the engine helps to simplify its code and gain a little
          speed. Taking into account that this speed gain sometimes takes place in performance-critical places,
          like searching a key in an index block, avoiding old code and related branches really does make Firebird
          fly faster.</para>

          <para>Nevertheless, the Providers architecture does make it possible to access old databases when 
          changing to a higher version of Firebird.  A suitable provider may be considered for inclusion in a 
          later sub-release.</para>

          <section><!-- L4 -->
            <title>Custom Providers</title>
            <para>A strong feature of the Providers architecture is ability for the deployer to add his own providers
            to the server, the client, or both.</para>
            <para>So what else might be wanted on a client, other than a remote connection? Recall <emphasis>Provider chaining</emphasis>
            that was mentioned earlier. Imagine a case where a database is accessed via very slow network connection, say
            something like 3G or, worse, GPRS. What comes to mind as a way to speed it up is to cache on the client
            some big tables that rarely change. Such systems were actually implemented but, to do it,
            one had to rename <filename>fbclient</filename> to something arbitrary and load it into its own library
            called <filename>fbclient</filename>, thus making it possible to use standard tools to access the database
            at the same time as caching required tables. It works but, as a solution, it is clearly not ideal.</para>

            <para>With the Providers architecture, instead of renaming libraries, one just adds a local caching
            provider which can use any method to detect connections to it (something like a <function>cache@</function>
            prefix at the beginning of the database name, or whatever else you choose).</para>
            <para>In this example, when the database name <function>cache@RemoteHost:dbname</function> is used,
            the caching provider accepts the connection and invokes the <command>y-valve</command> once more with
            the traditional database name <function>RemoteHost:dbname</function>. When the user later performs any
            call to his database, the caching provider gets control of it before <command>Remote</command> does
            and, for a locally cached table, can forestall calls to the remote server.</para>

            <para>Use of chaining allows a lot of other useful things to be implemented. An example might be 
            MySQL-style replication at statement level without the need for triggers:  just repeat the same 
            calls for the replication host, perhaps whena transaction is committed. In this case, the chaining 
            provider would be installed on the server, not the client, and no modification of the command line would
            be needed.
            <note>
              <para>That said, statement-level replication is very questionable feature.</para>
            </note>
            </para>

            <para>To avoid cycling when performing a callback to <command>y-valve</command> at attach time, such
            a provider can modify the list of providers using the <function>isc_dpb_config parameter</function> in
            the DPB.  The same technique may be used at the client, too.</para>
            <para>For details, see the <link linkend="rnfb30-fbconf">Configuration Additions and Changes</link>
            chapter.</para>

            <para>The ability to access foreign database engines using providers should not be overlooked, either.
            It might seem strange to consider this, given the number of tools available for this sort of task.
            Think about the ability to access other Firebird databases using EXECUTE STATEMENT, that became
            available in Firebird 2.5.  With a provider to ODBC or other common tool to access various data sources
            it is within reach to use EXECUTE STATEMENT to get direct access from procedures and triggers, to data
            from any database having a driver for the chosen access tool. It is even possible to have a provider
            to access some particular type of foreign database engine if there is some reason to want to
            avoid the ODBC layer.</para>
          </section><!-- L4 -->
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>Providers Q &amp; A</title>
          <para>Q. Interfaces and providers are probably very good, but I have an old task written using plain
          API functions and for a lot of reasons I can't rewrite it in the near future. Does it mean I will have
          problems migrating to Firebird 3?</para>
          <itemizedlist>
            <listitem>
              <para>A. Definitely no problems. The old API is supported for backward compatibility in Firebird 3
              and will be supported in future versions as long as people need it.</para>
            </listitem>
          </itemizedlist>
          <para>And what about performance when using the old API?</para>
          <itemizedlist>
            <listitem>
              <para>A. The functional API is implemented as a very thin layer over interfaces. Code in most
              cases is trivial: convert passed handles to pointers to interfaces&#x2014;hitherto referred to
              as <quote>handle validation</quote>&#x2014;and invoke the appropriate function
              from the interface.</para>
              <para>Functions that execute an SQL operation and fetch data from it are one place where coding
              is a little more complex, involving the SQLDA construct.  The data moves related to the SQLDA have
              always created an overhead. The logic between the new and old APIs does not add significantly to
              that old overhead.</para>
            </listitem>
          </itemizedlist>
        </section><!-- L3 -->
      </section><!-- L2 -->

      <section id="rnfb30-engine-modes-protocols"><!-- L2 -->
        <title>Connection String and Protocols</title>
        <para><firstterm>Connection string</firstterm> refers to the local or remote path to the database to
        which a client requests an attachment (connection).  The syntax of the connection string determines
        the transport protocol by which clients and the server communicate. The legacy syntaxes for the
        available protocols, supported by all Firebird versions, are as follows:

          <variablelist>
            <varlistentry>
              <term>For TCP/IP (aka INET) protocol:</term>
              <listitem>
                <literallayout class="monospaced">
  &lt;host&gt; [ / &lt;port&gt;] : &lt;database file path or alias&gt;
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>For named pipes (aka NetBEUI, aka WNET) protocol:</term>
              <listitem>
                <literallayout class="monospaced">
  \\ &lt;host&gt; [ @ &lt;port&gt;] \ &lt;database file path or alias&gt;
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>For local connections, simply:</term>
              <listitem>
                <literallayout class="monospaced">
  &lt;database file path or alias&gt;
                </literallayout>
                <para>Local connection is implied if &lt;host&gt; is omitted. Depending on settings,
                platform and Firebird version, it could be performed via either the embedded engine,
                XNET (shared memory) protocol or TCP/IP localhost loopback.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </para>

        <bridgehead renderas="sect4">Examples</bridgehead>
        <variablelist>
          <varlistentry>
            <term>Connect via TCP/IP using database name:</term>
            <listitem>
              <literallayout class="monospaced">
  192.168.0.11:/db/mydb.fdb
  192.168.0.11:C:\db\mydb.fdb
  myserver:C:\db\mydb.fdb
  localhost:/db/mydb.fdb
              </literallayout>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Connect via TCP/IP using database alias:</term>
            <listitem>
              <literallayout class="monospaced">
  192.168.0.11:mydb
  myserver:mydb
  localhost:mydb
              </literallayout>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Connect via TCP/IP using non-default port 3051:</term>
            <listitem>
              <literallayout class="monospaced">
  192.168.0.11/3051:C:\db\mydb.fdb
  192.168.0.11/3051:mydb
  myserver/3051:/db/mydb.fdb
  localhost/3051:/db/mydb.fdb
  myserver/3051:mydb
  localhost/3051:mydb
              </literallayout>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Connect via TCP/IP using non-default service name:</term>
            <listitem>
              <literallayout class="monospaced">
  192.168.0.11/fb_db:C:\db\mydb.fdb
  192.168.0.11/fb_db:mydb
  localhost/fb_db:/db/mydb.fdb
  myserver/fb_db:/db/mydb.fdb
  myserver/fb_db:mydb
  localhost/fb_db:mydb
              </literallayout>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Connect via named pipes (Windows only): </term>
            <listitem>
              <literallayout class="monospaced">
  \\myserver\C:\db\mydb.fdb
  \\myserver@fb_db\C:\db\mydb.fdb
              </literallayout>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>Local connection:</term>
            <listitem>
              <literallayout class="monospaced">
  /db/mydb.fdb
  C:\db\mydb.fdb
  mydb
              </literallayout>
            </listitem>
          </varlistentry>
        </variablelist>

        <section> <!-- L3 -->
          <title>URL-Style Connection Strings</title>
          <para>Firebird 3.0 introduces an additional, generalized, URL-style syntax for
          connection strings.  The pattern is:
            <literallayout class="monospaced">
  [ &lt;protocol&gt; : // [ &lt;host&gt; [ : &lt;port&gt; ] ] ] / &lt;database file path or alias&gt;

  &lt;protocol&gt; ::= INET | WNET | XNET
            </literallayout>
          INET resolves to TCP/IP, WNET to Named Pipes, while XNET surfaces the old <quote>Windows local
          protocol</quote> (shared memory).
          </para>
          <bridgehead renderas="sect5">Examples</bridgehead>
          <variablelist>
            <varlistentry>
              <term>  Connect via TCP/IP using database name:</term>
              <listitem>
                <literallayout class="monospaced">
  inet://192.168.0.11//db/mydb.fdb
  inet://192.168.0.11/C:\db\mydb.fdb
  inet://myserver/C:\db\mydb.fdb
  inet://localhost//db/mydb.fdb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Connect via TCP/IP using database alias:</term>
              <listitem>
                <literallayout class="monospaced">
  inet://192.168.0.11/mydb
  inet://myserver/mydb
  inet://localhost/mydb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Connect via TCP/IP using non-default port 3051:</term>
              <listitem>
                <literallayout class="monospaced">
  inet://192.168.0.11:3051/C:\db\mydb.fdb
  inet://192.168.0.11:3051/mydb
  inet://myserver:3051//db/mydb.fdb
  inet://localhost:3051//db/mydb.fdb
  inet://myserver:3051/mydb
  inet://localhost:3051/mydb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Connect via TCP/IP using non-default service name:</term>
              <listitem>
                <literallayout class="monospaced">
  inet://192.168.0.11:fb_db/C:\db\mydb.fdb
  inet://192.168.0.11:fb_db/mydb
  inet://localhost:fb_db//db/mydb.fdb
  inet://myserver:fb_db//db/mydb.fdb
  inet://myserver:fb_db/mydb
  inet://localhost:fb_db/mydb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Connect via named pipes:</term>
              <listitem>
                <literallayout class="monospaced">
  wnet://myserver/C:\db\mydb.fdb
  wnet://myserver:fb_db/C:\db\mydb.fdb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Loopback connection via TCP/IP:</term>
              <listitem>
                  <literallayout class="monospaced">
  inet:///db/mydb.fdb
  inet://C:\db\mydb.fdb
  inet://mydb
                  </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Loopback connection via named pipes:</term>
              <listitem>
                <literallayout class="monospaced">
  wnet://C:\db\mydb.fdb
  wnet://mydb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Local connection via shared memory:</term>
              <listitem>
                <literallayout class="monospaced">
  xnet://C:\db\mydb.fdb
  xnet://mydb
                </literallayout>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Local (embedded by default) connection:</term>
              <listitem>
                <literallayout class="monospaced">
  /db/mydb.fdb
  C:\db\mydb.fdb
  mydb
              </literallayout>
            </listitem>
            </varlistentry>
          </variablelist>
          <para>Local connection is implied if &lt;host&gt; is omitted. Depending on
          settings, platform and Firebird version, it could be performed via either the
          embedded engine, XNET (shared memory) protocol or TCP/IP localhost loopback.</para>

          <para>On the server side, the <link linkend="rnfb30-engine-providers">provider
          configuration</link> is in the default order Remote, Engine12, Loopback.
          If the <firstterm>Remote</firstterm> provider fails to match the connection string
          because the protocol or host parts are missing, then <firstterm>Engine12</firstterm>,
          the embedded engine, handles it as a hostless connection. To connect locally using a
          specific transport protocol, it is necessary to specify that protocol:
            <literallayout class="monospaced">
  inet://&lt;database file path or alias&gt;
  or
  wnet://&lt;database file path or alias&gt;
  or
  xnet://&lt;database file path or alias&gt;
            </literallayout>
            <note>
              <para>WNET (named pipes) and XNET (shared memory) protocols are available only
              on Windows.</para>
            </note>
          </para>
        </section> <!-- L3 URL-style strings -->
      </section><!-- L2 Connection strings -->

      <section id="rnfb30-engine-plugins" xreflabel="Plug-Ins"><!-- l2 -->
        <sectioninfo>
          <author>
            <firstname>Alex</firstname><surname>Peshkov</surname>
          </author>
        </sectioninfo>
        <title>Plug-Ins</title>
        <para>From version 3 onward, Firebird's architecture supports plug-ins. For a number of predefined points in the Firebird
        code, a developer can write his own fragment of code for execution when needed.</para>
        <para>A plug-in is not necessarily one written by a third party: Firebird has a number of intrinsic plug-ins.
        Even some core parts of Firebird are implemented as plug-ins.</para>

        <section><!-- L3 -->
          <title>What is a Plug-In?</title>

          <para>The term <quote>plug-in</quote> is used to name related but different things:</para>
          <itemizedlist>
            <listitem>
              <para>a dynamic library, containing code to be loaded as a plug-in (often called a <emphasis>plug-in module</emphasis>)
              and stored in the <filename>$FIREBIRD/plugins</filename> directory;</para>
            </listitem>
            <listitem>
              <para>code <emphasis>implementing</emphasis> a plug-in.  That is slightly different from the <emphasis>library</emphasis>,
              since a single dynamic library may contain code for more than one plug-in;</para>
            </listitem>
            <listitem>
              <para>a plug-in's <emphasis>factory</emphasis>: an object created by that code (pure virtual C++ class), creating
              instances of the plug-in at Firebird's request;</para>
            </listitem>
            <listitem>
              <para>an <emphasis>instance</emphasis> of the plug-in, created by its factory.</para>
            </listitem>
          </itemizedlist>

        </section>

        <section><!-- L3 -->

          <title>Plug-In Types</title>
          <para>Firebird's plug-in architecture makes it possible to create plug-ins of predefined types. Each version
          of Firebird will have a fixed set of supported plug-in types. To add a further type, the first requirement is to
          modify the Firebird code. Our plug-in architecture facilitates both adding new types of plug-ins
          and simplifying the coding of the plug-in along generic lines.</para>

          <para>To be able to implement a plug-in, say, for encrypting a database on the disk, the Firebird code has to be 
          prepared for it: it must have a point from which the plug-in is called.</para>
          <para>The set of plug-in types implemented in Firebird 3 comprises:</para>
          <variablelist>
            <varlistentry>
              <term>user authentication related:</term>
              <listitem>
                <itemizedlist>
                  <listitem><para>AuthServer (validates user's credentials on server when logins are used)</para></listitem>
                  <listitem><para>AuthClient (prepares credentials to be passed over the wire)</para></listitem>
                  <listitem><para>AuthUserManagement (maintains a list of users on a server in a format known to AuthServer)</para></listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>ExternalEngine</term>
              <listitem>
                <para>Controls the use of various engines, see <link linkend="rnfb30-engine-extengines">External Engines</link>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Trace</term>
              <listitem>
                <para>The Trace plug-in was introduced in Firebird 2.5, but the way it interacts with the engine was changed
                in Firebird 3 to accord with the new generic rules.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Encryption</term>
              <listitem>
                <para>encrypting plug-ins are for</para>
                <itemizedlist>
                  <listitem>
                    <para>network (WireCrypt)</para>
                  </listitem>
                  <listitem>
                    <para>disk (DbCrypt)</para>
                  </listitem>
                  <listitem>
                    <para>a helper plug-in (KeyHolder), used to help maintain the secret key(s) for DbCrypt</para>
                  </listitem>
                </itemizedlist>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Provider</term>
              <listitem>
                <para>Firebird 3 supports <link linkend="rnfb30-engine-providers-about">providers</link> 
                as a plug-in type.
                <!-- See README.Providers for more information. --></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section><!-- L3 -->

        <section><!-- L3 -->
          <title>Technical Details</title>
          <para>Plug-ins use a set of special Firebird interfaces.
          <!-- (see README.interfaces about interfaces in Firebird). -->
          All plug-in-specific interfaces are reference counted, thus putting their lifetime under specific control.
          Interfaces are declared in the include file <filename>plug-in.h</filename>. A simple example for writing 
          a plug-in module can be found in <filename>DbCrypt_example</filename>.</para>
          <note>
            <para>The example does not perform any actual encryption, it is just a sample of how to write a plug-in.
            Complete instructions for writing plug-ins are not in scope for this document.</para>
          </note>
          <section><!-- L4 -->
            <title>Features of a Plug-In</title>
            <para>A short list of plug-in features:</para>
            <itemizedlist>
              <listitem>
                <para>You can write a plug-in in any language that supports pure virtual interfaces. Interface
                declarations will need to be written for your language if they are missing.</para>
              </listitem>
              <listitem>
                <para>As with UDFs, you are free to add any reasonable code to your plug-in&#x2014;with emphasis on
                <emphasis>reasonable</emphasis>.  For example, prompting for user input at the server's 
                console from a plug-in is hardly <quote>reasonable</quote>!</para>
              </listitem>
              <listitem>
                <para>Calling the Firebird API from your plug-in is OK, if needed.  For example, the default
                authentication server and user manager use a Firebird database to store accounts.</para>
              </listitem>
              <listitem>
                <para>Firebird provides a set of interfaces to help with configuring your plug-ins. It is not
                obligatory to use them, since the plug-in code is generic and can employ any useful method for
                capturing configuration information.  However, using the standard tools provides commonality
                with the established configuration style and should save the additional effort of rolling your
                own and documenting it separately.</para>
              </listitem>
            </itemizedlist>
          </section><!-- L4 -->

          <section id="rnfb30-config-plugins"><!-- L4 -->
            <title>Configuring Plug-ins</title>
            <para>Configuration of plug-ins has two parts:</para>
            <orderedlist>
              <listitem>
                <para>The engine has to be instructed what plug-ins it should load</para>
              </listitem>
              <listitem>
                <para>The plug-ins themselves sometimes need some configuration.</para>
              </listitem>
            </orderedlist>

            <para>The plug-ins to be loaded for each plug-in type are defined in the main
            configuration file, <filename>firebird.conf</filename>, usually with defaults.  The ones
            defined in Firebird 3 are discussed in the chapter entitled
            <quote><link linkend="rnfb30-fbconf">Configuration Additions and Changes</link></quote>.
            In summary, the set that provides normal operation in the server, client and embedded cases
            consists of:</para>
            <itemizedlist>
              <listitem><para>AuthServer = Srp, Win_Sspi</para></listitem>
              <listitem><para>AuthClient = Srp, Win_Sspi, Legacy_Auth</para></listitem>
              <listitem><para>UserManager = Srp</para></listitem>
              <listitem><para>TracePlugin = fbtrace</para></listitem>
              <listitem><para>Providers = Remote,Engine12,Loopback</para></listitem>
              <listitem><para>WireCryptPlugin = Arc4</para></listitem>
            </itemizedlist>
            <note>
              <para>If you want to add other plug-ins, they must be cited in firebird.conf.  Apart from
              other considerations, this requirement acts as a security measure to avoid loading unknown
              code.</para>
            </note>

            <para>Taking the entry <command>TracePlugin = fbtrace</command> as an example, what does the
            value <command>fbtrace</command> signify? In a trivial case, it can indicate the name of a
            dynamic library but the precise answer is more complicated.</para>

            <para>As mentioned earlier, a single plug-in module may implement more than one plug-in.
            In addition, a single plug-in may have more than one configuration at once, with a separate
            plug-in factory created for each configuration. Each of these three object contexts
            (module | implementation | factory) has its own name:</para>
            <itemizedlist>
              <listitem><para>The name of a module is the file name of a dynamic library</para></listitem>
              <listitem><para>The name of a plug-in implementation is the one given to it by the developer
              of the plug-in.  It is hard-coded inside the module.</para></listitem>
              <listitem><para>The name of a factory is, by default, the same as the name of the plug-in
              implementation's name. It is the factory name which is actually used in
              <filename>firebird.conf</filename>.</para></listitem>
            </itemizedlist>

            <para>In a typical trivial case, a module contains one plug-in that works with just one
            configuration and all three names are equal, and no more configuration is needed.  An example
            would be libEngine12.so | Engine12.dll | Engine12.dylib, that contains the implementation of
            the embedded provider Engine12.  Nothing other than the record
            <command>Providers = Engine12</command> is needed to load it.</para>
            <para>For something more complex a file will help you to set up the plug-in factories
            precisely.</para>
          </section><!-- L4 -->

          <section><!-- L4 -->
          <title>plugins.conf</title>

            <para>The file <filename>$(root)/plugins.conf</filename> has two types of records:
            <command>config</command> and <command>plugin</command>.</para>
            <para>the <command>plugin</command> record is a set of rules for loading land activating
            the plug-in. Its format is:</para>
            <programlisting>
Plugin = PlugName ## this is the name to be referenced in firebird.conf
  {
    Module = LibName ## name of dynamic library
    RegisterName = RegName ## name given to plug-in by its developer
    Config = ConfName ## name of config record to be used
    ConfigFile = ConfFile ## name of a file that contains plug-in's configuration
  }
              </programlisting>
              <para>When plug-in <emphasis>PlugName</emphasis> is needed, Firebird loads the
              library <emphasis>LibName</emphasis> and locates the plug-in registered with the name
              <emphasis>RegName</emphasis>.  The configuration values from the config record <emphasis>ConfName</emphasis>
              or the config file <emphasis>ConfFile</emphasis> are passed to the library.</para>
              <note>
                <para>If both <emphasis>ConfName</emphasis> and <emphasis>ConfFile</emphasis> are given, then
                the config record will be used.</para>
                <para>If both parameters are missing, the default <emphasis>PlugName</emphasis> is used;
                <emphasis role="bold">except that</emphasis> if the <command>ConfigFile</command> is present
                and its name is the same as the module's dynamic library but with a <filename>.conf</filename>
                extension, it will be used.</para>
              </note>

              <para>The <command>ConfigFile</command> is expected to use the format <command>Key=Value</command>,
              in line with other Firebird configuration files.</para>
              <para>For the plug-in configuration record the same format is used:</para>
              <programlisting>
Config = ConfName
  {
    Key1 = Value1
    Key2 = Value2
    ...
  }
              </programlisting>
              <para><emphasis role="bold">A Sample Setup</emphasis></para>

              <para>Suppose you have a server for which some clients trust the wire encryption
              from one vendor and others prefer a different one.  They have different licences
              for the appropriate client components but both vendors use the name <quote>BestCrypt</quote>
              for their products.</para>
              <para>The situation would require renaming the libraries to, say, WC1 and WC2, since
              there cannot be two files in the same directory with the same name.  Now, the modules stop
              loading automatically because neither is called <quote>BestCrypt</quote> any longer.</para>
              <para>To fix the problem, <filename>plug-ins.conf</filename> should contain something like this:</para>
              <programlisting>
Plugin = WC1
  {
    RegisterName = BestCrypt
  }
Plugin = WC2
  {
    RegisterName = BestCrypt
  }
              </programlisting>

              <para>The module names will be automatically set to WC1 and WC2 and found. You can add any
              configuration info that the plug-ins need.</para>
              <para>Remember to modify firebird.conf to enable both plug-ins for the <command>WireCryptPlugin</command>
              parameter:</para>
              <literallayout class="monospaced">
WireCryptPlugin = WC1, WC2
              </literallayout>
              <para>The server will now select appropriate plug-in automatically to talk to the client.</para>

              <para>Another sample is distributed with Firebird, in <filename>$(root)/plugins.conf</filename>,
              configuring one of the standard plug-ins, UDR.  Because it was written to a use non-default configuration,
              the module name and one configuration parameter are supplied explicitly.</para>
            </section><!-- L4 -->
          </section><!-- L3 -->

          <section><!-- L3 -->
            <title>Plug-Ins Q &amp; A</title>

            <para>Q. There are plug-ins named Remote, Loopback, Arc4 in the default configuration,
            but no libraries with such names. How do they work?</para>
            <itemizedlist>
              <listitem>
                <para>A. They are <quote>built-in</quote> plug-ins, built into the fbclient library, and
                thus always present. Their existence is due to the old ability to distribute the Firebird
                client for Windows as a single dll. The feature is retained for cases where the standard
                set of plug-ins is used.</para>
              </listitem>
            </itemizedlist>

            <para>Q. What do the names of Srp and Arc4 plug-ins mean?</para>
            <itemizedlist>
              <listitem>
                <para>A. Srp implements the Secure Remote Passwords protocol, the default way of
                authenticating users in Firebird 3. Its effective password length is 20 bytes,
                resistant to most attacks (including <quote>man in the middle</quote>) and works
                without requiring any key exchange between client and server to work.</para>
                <para>Arc4 means Alleged RC4 - an implementation of RC4 cypher. Its advantage
                is that it can generate a unique, cryptographically strong key on both client
                and server that is impossible to guess by capturing data transferred over the
                wire during password validation by SRP.</para>
                <para>The key is used after the SRP handshake by Arc4, which makes wire encryption
                secure without need to exchange any keys between client and server explicitly.</para>
              </listitem>
            </itemizedlist>

            <para>Q. What do Win_Sspi and Legacy_Auth mean?</para>
            <itemizedlist>
              <listitem>
                <para>A. Windows SSPI has been in use since Firebird 2.1 for Windows trusted user
                authentication. Legacy_Auth is a compatibility plug-in to enable connection by the
                Firebird 3 client to older servers. It is enabled by default in the client.</para>
                <para>And Yes, it still transfers almost plain passwords over the wire, for
                compatibility.</para>
                <para>On the server it works with <filename>security3.fdb</filename> just as with
                a security database from Firebird 2.5  It should be avoided except in situations 
                where you understand well what you are sacrificing.</para>
                <para>To use Legacy_Auth on the server you will need to avert network traffic
                encryption in <filename>firebird.conf</filename> by reducing the default Required
                setting for the <emphasis role="bold">WireCrypt</emphasis> parameter, either</para>
                <literallayout class="monospaced">
  WireCrypt = Enabled
                </literallayout>
                <para>or</para>
                <literallayout class="monospaced">
  WireCrypt = Disabled
                </literallayout>
              </listitem>
            </itemizedlist>
            <para>Q. How can I find out what the standard Authentication and User Manager plug-ins are?</para>
            <itemizedlist>
              <listitem>
                <para>They are listed in <filename>firebird.conf</filename>.</para>
              </listitem>
            </itemizedlist>
          </section><!-- L3 -->

        </section><!-- L2 -->

        <section id="rnfb30-engine-extengines" xreflabel="External Engines"><!-- l2 -->
          <sectioninfo>
            <author>
              <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
            </author>
          </sectioninfo>
          <title>External Engines</title>
          <para>The UDR (User Defined Routines) engine adds a layer on top of the FirebirdExternal
          engine interface with the purpose of</para>
          <itemizedlist>
            <listitem>
              <para>establishing a way to hook external modules into the server and make
              them available for use</para>
            </listitem>
            <listitem>
              <para>creating an API so that external modules can register their available
              routines</para>
            </listitem>
            <listitem>
              <para>making instances of routines <quote>per attachment</quote>, rather than
              dependent on the internal implementation details of the engine</para>
            </listitem>
          </itemizedlist>

          <section><!-- L3 -->
            <title>External Names</title>
            <para>An external name for the UDR engine is defined as</para>
          <literallayout class="monospaced">
  '&lt;module name&gt;!&lt;routine name&gt;!&lt;misc info&gt;'
            </literallayout>
            <para>The &lt;module name&gt; is used to locate the library, &lt;routine name&gt; is
            used to locate the routine registered by the given module, and &lt;misc info&gt; is
            an optional user-defined string that can be passed to the routine to be read by
            the user.</para>
          </section><!-- L3 -->

          <section><!-- L3 -->
            <title>Module Availability</title>
            <para>Modules available to the UDR engine should be in a directory listed by way of
            the path attribute of the corresponding plugin_config tag. By default, a UDR module
            should be on &lt;fbroot&gt;/plugins/udr, in accordance with its path attribute
            in &lt;fbroot&gt;/plugins/udr_engine.conf.</para>
            <para>The user library should include FirebirdUdr.h (or FirebirdUdrCpp.h) and link
            with the udr_engine library. Routines are easily defined and registered, using some
            macros, but nothing prevents you from doing things manually.</para>
            <note>
              <para>A sample routine library is implemented in <filename>examples/udr</filename>,
              showing how to write functions, selectable procedures and triggers. It also shows
              how to interact with the current attachment through the legacy API.</para>
            </note>

          </section><!-- L3 -->

          <section><!-- L3 -->
            <title>Scope</title>
            <para>The state of a UDR routine (i.e., its member variables) is shared among
            multiple invocations of the same routine until it is unloaded from the metadata
            cache. However, it should be noted that the instances are isolated <quote>per
            session</quote>.</para>
          </section><!-- L3 -->

          <section><!-- L3 -->
            <title>Character Set</title>
            <para>By default, UDR routines use the character set that was specified by
            the client.</para>
            <note>
              <para>In future, routines will be able to modify the character set by 
              overriding the <command>getCharSet</command> method. The chosen character set 
              will be valid for communication with the old Firebird client library as well 
              as the communications passed through the FirebirdExternal API.</para>
            </note>
          </section><!-- L3 -->

          <section><!-- L3 -->
            <title>Enabling UDRs in the Database</title>
            <para>Enabling an external routine in the database involves a DDL command to
            <quote>create</quote> it.  Of course, it was already created
            externally and (we hope) well tested.</para>
            <para><emphasis role="bold">Syntax Pattern</emphasis></para>
              <literallayout class="monospaced">
  { CREATE [ OR ALTER ] | RECREATE | ALTER } PROCEDURE &lt;name&gt;
    [ ( &lt;parameter list&gt; ) ]
    [ RETURNS ( &lt;parameter list&gt; ) ]
    EXTERNAL NAME '&lt;external name&gt;' ENGINE &lt;engine&gt;

  { CREATE [ OR ALTER ] | RECREATE | ALTER } FUNCTION &lt;name&gt;
    [ &lt;parameter list&gt; ]
    RETURNS &lt;data type&gt;
    EXTERNAL NAME '&lt;external name&gt;' ENGINE &lt;engine&gt;

  { CREATE [ OR ALTER ] | RECREATE | ALTER } TRIGGER &lt;name&gt;
    ...
    EXTERNAL NAME '&lt;external name&gt;' ENGINE &lt;engine&gt;
              </literallayout>
            
              <para><emphasis role="bold">Examples</emphasis></para>
              <programlisting>
create procedure gen_rows (
  start_n integer not null,
  end_n integer not null
) returns (
  n integer not null
) external name 'udrcpp_example!gen_rows'
  engine udr;

create function wait_event (
  event_name varchar(31) character set ascii
) returns integer
  external name 'udrcpp_example!wait_event'
  engine udr;

create trigger persons_replicate
  after insert on persons
  external name 'udrcpp_example!replicate!ds1'
  engine udr;
              </programlisting>

          </section><!-- L3 -->

          <section><!-- L3 -->
            <title>How it Works</title>
            <para>The external names are opaque strings to Firebird. They
            are recognized by specific external engines.  External engines are
            declared in configuration files, possibly in the same file as a
            plug-in, as in the sample UDR library that is implemented in
            <filename>$(root)/plugins</filename>.</para>
            <literallayout class="monospaced">
  external_engine = UDR {
  	plugin_module = UDR_engine
  }

  plugin_module = UDR_engine {
  	filename = $(this)/udr_engine
  	plugin_config = UDR_config
  }

plugin_config = UDR_config {
	path = $(this)/udr
  }
            </literallayout>
            <para>When Firebird wants to load an external routine (function, procedure
            or trigger) into its metadata cache, it gets the external
            engine through the plug-in external engine factory and asks it for the routine.
            The plug-in used is the one referenced by the attribute <command>plugin_module</command>
            of the external engine.</para>
            <note>
              <para>Depending on the server architecture (Superserver, Classic, etc) and implementation details, 
              Firebird may get external engine instances <quote>per database</quote> or <quote>per connection</quote>.
              Currently, it always gets instances <quote>per database</quote>.</para>
            </note>
          </section><!-- L3 -->

      </section><!-- L2 -->
    </section>
    
    <section id="rnfb3-engine-optimizer">
      <sectioninfo>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <title>Optimizer Improvements</title>
      <itemizedlist>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4528">CORE-4528</ulink>.</para>
          <para>Hash/merge joins for non-field (DBKEY or derived expression) equalities are now allowed.</para>
        </listitem>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-1482">CORE-1482</ulink>.</para>
          <para>The optimizer now considers the ORDER BY optimization when making its decision
          about join order.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="rnfb3-engine-optimizations">
      <sectioninfo>
        <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
      </sectioninfo>
      <title>Other Optimizations</title>
      <itemizedlist>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4556">CORE-4556</ulink>.</para>
          <para>Data pages are now allocated as a group of sequential ordered pages (extents).</para>
        </listitem>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4445">CORE-4445</ulink>.</para>
          <para>The main database file extends faster when physical backup state changes from
          <emphasis>stalled</emphasis> to <emphasis>merge</emphasis>.</para>
        </listitem>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4443">CORE-4443</ulink>.</para>
          <para>Linux systems that support <quote>fast file growth</quote> can now use it.</para>
        </listitem>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4432">CORE-4432</ulink>.</para>
          <para>Attachments no longer block others when the allocation table is read for the first time.</para>
        </listitem>
        <listitem>
          <para>See Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4431">CORE-4431</ulink>.</para>
          <para>Contention has been reduced for the allocation table lock while database is in
          <emphasis>stalled</emphasis> physical backup state.</para>
        </listitem>
      </itemizedlist>
    </section>


    <section id="rnfb3-engine-remote">
      <sectioninfo>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      </sectioninfo>
      <title>Remote Interface/Network Protocol</title>
      <para>Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-2530">CORE-2530</ulink>.</para>
      <para>Further improvements were made to Firebird's network protocol, providing a denser data
      stream and better prefetch logic.  The following improvements were implemented:</para>
      <orderedlist>
        <listitem>
          <para>The full length of a field whose value is NULL is no longer sent over the wire.
          (Tracker item <ulink url="http://tracker.firebirdsql.org/browse/CORE-2897">CORE-2897</ulink>).
          NULL flags (4 bytes per field) are replaced with a bitmap and only these flags are
          transmitted, in the bitmap.</para>
          <para>This improvement is available for the DSQL API only, so <emphasis>gbak</emphasis> does
          not benefit from this improvement, as it uses a lower level BLR API.</para>
        </listitem>
        <listitem>
          <para>The prefetch (batch receive) algorithm is now aware of variable-length messages, so that
          VARCHARs and NULLs may reduce the transmitted message size, allowing more rows to be transmitted
          in each batch.</para>
        </listitem>
      </orderedlist>
      <note>
        <title>Acknowledgement</title>
        <para>This work was sponsored by donations collected at the 9th Firebird Developers' Day 
        conference in Brazil.</para>
      </note>
    </section>

    <section><!-- L1 -->
      <title>Miscellaneous Improvements</title>
      <para>Miscellaneous engine improvements include.-</para>

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Paul</firstname><surname>Beach</surname></author>
        </sectioninfo>
        <title>Connections Limit Raised</title>
        <para>(<ulink url="http://tracker.firebirdsql.org/browse/CORE-4439">CORE-4439</ulink>) ::
        Maximum connections (FD_SETSIZE) on Windows Superserver and Superclassic was raised 
        from 1024 to 2048.</para>
      </section><!-- l2 -->

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
        </sectioninfo>
        <title>Better Error Diagnosis</title>
        <para>(<ulink url="http://tracker.firebirdsql.org/browse/CORE-3881">CORE-3881</ulink>) ::
        The error reported for index/constraint violations has been extended to 
        include the problematic key value.</para>
      </section><!-- l2 -->

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
        </sectioninfo>
        <title>ICU Version Upgraded</title>
        <para>(<ulink url="http://tracker.firebirdsql.org/browse/CORE-2224">CORE-2224</ulink>) ::
        The ICU version was upgraded to v.52.1.</para>
      </section><!-- l2 -->

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
        </sectioninfo>
        <title>Internal Debug Info Made Human-readable</title>
        <para>A new BLOB filter translates internal debug information into text.</para>
      </section><!-- l2 -->

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Claudio</firstname><surname>Valderrama C.</surname></author>
        </sectioninfo>
        <title>A Silly Message is Replaced</title>
        <para>A silly message sent by the parser when a reference to an undefined object
        was encountered was replaced with one that tells it like it really is.</para>
      </section><!-- l2 -->

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
        </sectioninfo>
        <title>New Pseudocolumn RDB$RECORD_VERSION</title>
        <para>A pseudocolumn named RDB$RECORD_VERSION returns the number of the transaction that
        created the current record version.</para>
        <para>It is retrieved the same way as RDB$DB_KEY, i.e., <command>select RDB$RECORD_VERSION
        from aTable where...</command></para>
      </section><!-- l2 -->

      <section><!-- l2 -->
        <sectioninfo>
          <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
        </sectioninfo>
        <title>systemd init Scripts</title>
        <para>systemd init scripts are available in Firebird 3 POSIX installers.  See Tracker
        ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-4085">CORE-4085</ulink>.</para>
      </section><!-- l2 -->
      
      <section id="rnfb3-engine-loaderrors"><!-- l2 -->
        <sectioninfo>
          <author><firstname>Alex</firstname><surname>Peshkov</surname></author>
        </sectioninfo>
        <title>Firebird 3.0.4: Better Reporting on Dynamic Library Loading Errors</title>
        <para>A mistake in the initial design of the <code>ModuleLoader</code> class
        meant that errors displayed when dynamic libraries failed to load were lacking 
        any OS-specific information about the reason for the failure (no such file,
        invalid format, unresolved external reference, etc.).  The only report was
        &quot;Module/library not loaded&quot;. In many cases, that made it extremely 
        hard to find and fix the related bugs.</para>
        <para>Firebird 3.0.4 extends the errors reported to show the exact reason
        a library failed to load.</para>
        <note>
          <title>Exclusions</title>
          <para>Because the use of external functions (UDFs) has been deprecated, 
          those modules do not get this extended error treatment.  The other exclusion 
          is the ICU modules, due to the fact more than 50 retries are done when 
          those libraries fail to load.  Reporting such an avalanche of error detail 
          was considered impracticable.</para>
        </note>
      </section><!-- l2 -->
    </section><!-- L1 -->

  </chapter>

