<chapter id="rnfb30-dml">
  <chapterinfo>
    <title>Data Manipulation Language (DML)</title>
  </chapterinfo>
  <para>In this chapter are the additions and improvements that have been added to the SQL
  data manipulation language subset in Firebird 3.0.</para>

  <section id="rnfb30-dml-quicklinks"><!-- Level 1 section -->
    <title>Quick Links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para><link linkend="rnfb30-dml-merge">Supplemental SQL 2008 Features for MERGE</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-windowfuncs">Window (Analytical)
        Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-planoutput">Advanced PLAN Output</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-substring">SUBSTRING With Regular Expressions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-hyperbolic">Inverse Hyperbolic Trig Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-statistical">Statistical Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-functions-dateadd">Enhancements to DATEADD() Internal Function</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-trim">TRIM() BLOB Arguments Lose 32 KB limit</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-altquoting">Alternatives for Embedding Quotes in String Literals</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-offsetfetch">SQL:2008-Compliant OFFSET and FETCH Clauses</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-mixjoins">Prohibit Edgy Mixing of Implicit/Explicit Joins</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-leftparam">Support for Left-side Parameters in WHERE Clause</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-returningalias">RETURNING Clause Can be Aliased</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-returningcursor">RETURNING Clause from Positioned Updates and Deletes</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-curstability">Cursor Stability</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-gtt">Improvements for Global Temporary Tables</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-validate">Improvements for DML Strings</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-countresult">COUNT() Now Returns BIGINT</link> </para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-similarto">SIMILAR TO Performance Improvement</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-orparam">OR'ed Parameter in WHERE Clause</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-dialect1">A Little Dialect 1 Accommodation</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-dml-esql">Embedded SQL (ESQL) Enhancements</link></para>
      </listitem>
    </itemizedlist>
  </section>

<!-- MERGE -->
  <section id="rnfb30-dml-merge">
    <title>Supplemental SQL 2008 Features for MERGE</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
    <para>In summary, support for MERGE was supplemented with the introduction of these
    features:</para>
    <itemizedlist>
      <listitem>
        <para>Addition of the DELETE extension (<ulink url="http://tracker.firebirdsql.org/browse/CORE-2005">CORE-2005</ulink>)</para>
      </listitem>
      <listitem>
        <para>Enabling the use of multiple WHEN MATCHED | NOT MATCHED clauses (<ulink url="http://tracker.firebirdsql.org/browse/CORE-3639">CORE-3639</ulink>)
        and ability to apply conditions to WHEN MATCHED | NOT MATCHED</para>
      </listitem>
      <listitem>
        <para>Addition of the RETURNING ... INTO ... clause (<ulink url="http://tracker.firebirdsql.org/browse/CORE-3020">CORE-3020</ulink>)</para>
      </listitem>
    </itemizedlist>

    <para>The purpose of MERGE is to read data from the source and INSERT or UPDATE in the target table according
    to a condition.  It is available in DSQL and PSQL.</para>
    <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <literallayout class="monospaced">
  &lt;merge statement&gt; ::=
	MERGE
		INTO &lt;table or view&gt; [ [AS] &lt;correlation name&gt; ]
		USING &lt;table or view or derived table&gt; [ [AS] &lt;correlation name&gt; ]
		ON &lt;condition&gt;
		&lt;merge when&gt;...
		&lt;returning clause&gt;

  &lt;merge when&gt; ::=
	&lt;merge when matched&gt; |
	&lt;merge when not matched&gt;

  &lt;merge when matched&gt; ::=
	WHEN MATCHED [ AND &lt;condition&gt; ] THEN
		{ UPDATE SET &lt;assignment list&gt; | DELETE }

  &lt;merge when not matched&gt; ::=
	WHEN NOT MATCHED [ AND &lt;condition&gt; ] THEN
		INSERT [ &lt;left paren&gt; &lt;column list&gt; &lt;right paren&gt; ]
			VALUES &lt;left paren&gt; &lt;value list&gt; &lt;right paren&gt;
      </literallayout>
    

    <para><emphasis role="bold">Rules</emphasis></para>
      <para>At least one of &lt;merge when matched&gt; or &lt;merge when not matched&gt; should be specified.</para>
    

    <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
MERGE INTO customers c
  USING
    (SELECT * FROM customers_delta WHERE id &gt; 10) cd
     ON (c.id = cd.id)
  WHEN MATCHED THEN
    UPDATE SET name = cd.name
  WHEN NOT MATCHED THEN
    INSERT (id, name)
    VALUES (cd.id, cd.name)
      </programlisting>
    
    <note>
      <title>Notes</title>
      <para>A right join is made between the INTO (left-side) and USING tables using the condition.
      UPDATE is called when a record exists in the left table (INTO), otherwise INSERT is called.</para>

      <para>As soon as it is determined whether or not the source matches a record in the target, the set
      formed from the corresponding (WHEN MATCHED / WHEN NOT MATCHED) clauses is evaluated in the
      order specified, to check their optional conditions. The first clause whose condition evaluates
      to true is the one which will be executed, and the subsequent ones will be ignored.</para>

      <para>If no record is returned in the join, INSERT is not called.</para>
    </note>
  </section>

<!-- Window (analytical) functions -->
  <section id="rnfb30-dml-windowfuncs">
    <title>Window (Analytical) Functions</title>
    <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
    <para>According to the SQL specification, window functions (also known as analytical functions)
    are a kind of aggregation, but one that does not <quote>filter</quote> the result set of a
    query. The rows of aggregated data are mixed with the query result set.</para>
    <para>The window functions are used with the OVER clause. They may appear only in the SELECT
    list or the ORDER BY clause of a query.</para>
    <para>Besides the OVER clause, Firebird window functions may be <emphasis>partitioned</emphasis>
    and <emphasis>ordered</emphasis>.</para>

    <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <literallayout class="monospaced">
    &lt;window function&gt; ::= &lt;window function name&gt;([&lt;expr&gt; [, &lt;expr&gt; ...]]) OVER (
      [PARTITION BY &lt;expr&gt; [, &lt;expr&gt; ...]]
      [ORDER BY &lt;expr&gt; 
        [&lt;direction&gt;] 
        [&lt;nulls placement&gt;] 
        [, &lt;expr&gt; [&lt;direction&gt;] [&lt;nulls placement&gt;] ...]
    )

    &lt;direction&gt; ::= {ASC | DESC}

    &lt;nulls placement&gt; ::= NULLS {FIRST | LAST}
     </literallayout>
   

    <section><!-- L2 -->
      <title>Aggregate Functions Used as Window Functions</title>
      <para>All aggregate functions may be used as window functions, adding the OVER clause.</para>
      <para>Imagine a table EMPLOYEE with columns ID, NAME and SALARY, and the need to show each employee
      with his respective salary and the percentage of his salary over the payroll.</para>
      <para>A normal query could achieve this, as follows:</para>
      <programlisting>
select
    id,
    department,
    salary,
    salary / (select sum(salary) from employee) portion
  from employee
  order by id;
      </programlisting>
      <para><emphasis role="bold">Results</emphasis></para>
        <literallayout class="monospaced">
  id  department  salary  portion
  --  ----------  ------  ----------
  1   R &amp; D        10.00      0.2040
  2   SALES        12.00      0.2448
  3   SALES         8.00      0.1632
  4   R &amp; D         9.00      0.1836
  5   R &amp; D        10.00      0.2040
        </literallayout>
      
      <para>The query is repetitive and lengthy to run, especially if EMPLOYEE happened to
      be a complex view.</para>
      <para>The same query could be specified in a much faster and more elegant way
      using a window function:</para>
      <programlisting>
select
    id,
    department,
    salary,
    salary / sum(salary) OVER () portion
  from employee
  order by id;
      </programlisting>
     <para>Here, <command>sum(salary) over ()</command> is computed with the sum of
     all SALARY from the query (the employee table).</para>
    </section><!-- L2 -->

    <section><!-- L2 -->
      <title>Partitioning</title>
      <para>Like aggregate functions, that may operate alone or in relation to a group,
      window functions may also operate on a group, which is called a <quote>partition</quote>.</para>
      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
        <literallayout class="monospaced">
    &lt;window function&gt;(...) OVER (PARTITION BY &lt;expr&gt; [, &lt;expr&gt; ...])
        </literallayout>
      
      <para>Aggregation over a group could produce more than one row, so the result
      set generated by a partition is joined with the main query using the same expression
      list as the partition.</para>
      <para>Continuing the employee example, instead of getting the portion of each
      employee's salary over the all-employees total, we would like to get the portion
      based on just the employees in the same department:</para>
      <programlisting>
select
    id,
    department,
    salary,
    salary / sum(salary) OVER (PARTITION BY department) portion
  from employee
  order by id;
      </programlisting>
      <para><emphasis role="bold">Results</emphasis></para>
        <literallayout class="monospaced">
  id  department  salary  portion
  --  ----------  ------  ----------
  1   R &amp; D        10.00      0.3448
  2   SALES        12.00      0.6000
  3   SALES         8.00      0.4000
  4   R &amp; D         9.00      0.3103
  5   R &amp; D        10.00      0.3448
        </literallayout>
      
    </section><!-- L2 -->

    <section>
      <title>Ordering</title>
      <para>The ORDER BY sub-clause can be used with or without partitions and, with
      the standard aggregate functions, make them return the partial aggregations as
      the records are being processed.</para>
      <para><emphasis role="bold">Example</emphasis></para>
        <programlisting>
select
    id,
    salary,
    sum(salary) over (order by salary) cumul_salary
  from employee
  order by salary;
        </programlisting>
      
      <para><emphasis role="bold">The result set produced:</emphasis></para>
        <literallayout class="monospaced">
  id  salary  cumul_salary
  --  ------  ------------
  3     8.00          8.00
  4     9.00         17.00
  1    10.00         37.00
  5    10.00         37.00
  2    12.00         49.00
        </literallayout>
      
      <para>Then cumul_salary returns the partial/accumulated (or running) aggregation
      (of the SUM function).  It may appear strange that 37.00 is repeated for the ids 1 and 5,
      but that is how it should work. The ORDER BY keys are grouped together and the aggregation
      is computed once (but summing the two 10.00). To avoid this, you can add the ID field to
      the end of the ORDER BY clause.</para>
      <para>It's possible to use multiple windows with different orders, and ORDER BY parts
      like ASC/DESC and NULLS FIRST/LAST.</para>

      <para>With a partition, ORDER BY works the same way, but at each partition boundary
      the aggregation is reset.</para>
      <para>All aggregation functions, other than LIST(), are usable with ORDER BY.</para>
    </section><!-- L2 -->

    <section><!-- L2 -->
      <title>Exclusive window functions</title>
      <para>Beyond aggregate functions are the exclusive window functions, currently divided
      into <emphasis>ranking</emphasis> and <emphasis>navigational</emphasis> categories.
      Both sets can be used with or without partition and ordering, although the usage does
      not make much sense without ordering.</para>

      <section><!-- L3 -->
        <title>Ranking Functions</title>
        <para>The rank functions compute the ordinal rank of a row within the window
        partition. In this category are the functions DENSE_RANK, RANK and ROW_NUMBER.</para>
        <para><emphasis role="bold">Syntax</emphasis></para>
          <literallayout class="monospaced">
    &lt;ranking window function&gt; ::=
        DENSE_RANK() |
        RANK() |
        ROW_NUMBER()
          </literallayout>
        
        <para>The ranking functions can be used to create different type of incremental
        counters. Consider <command>SUM(1) OVER (ORDER BY SALARY)</command> as an example of
        what they can do, each of them in a different way. Following is an example query,
        also comparing with the SUM behavior.</para>
        <programlisting>
select
    id,
    salary,
    dense_rank() over (order by salary),
    rank() over (order by salary),
    row_number() over (order by salary),
    sum(1) over (order by salary)
  from employee
  order by salary;
        </programlisting>
        <para><emphasis role="bold">The result set:</emphasis></para>
          <literallayout class="monospaced">
  id  salary  dense_rank  rank  row_number  sum
  --  ------  ----------  ----  ----------  ---
  3     8.00           1     1           1    1
  4     9.00           2     2           2    2
  1    10.00           3     3           3    4
  5    10.00           3     3           4    4
  2    12.00           4     5           5    5
          </literallayout>
        
        <para>The difference between DENSE_RANK and RANK is that there is a gap related to
        duplicate rows (relative to the window ordering) only in RANK. DENSE_RANK continues
        assigning sequential numbers after the duplicate salary. On the other hand, ROW_NUMBER
        always assigns sequential numbers, even when there are duplicate values.</para>
      </section><!-- L3 -->

      <section><!-- L3 -->
        <title>Navigational Functions</title>
        <para>The navigational functions get the simple (non-aggregated) value of an expression
        from another row of the query, within the same partition.</para>
        <para><emphasis role="bold">Syntax</emphasis></para>
          <literallayout class="monospaced">
    &lt;navigational window function&gt; ::=
        FIRST_VALUE(&lt;expr&gt;) |
        LAST_VALUE(&lt;expr&gt;) |
        NTH_VALUE(&lt;expr&gt;, &lt;offset&gt;) [FROM FIRST | FROM LAST] |
        LAG(&lt;expr&gt; [ [, &lt;offset&gt; [, &lt;default&gt; ] ] ) |
        LEAD(&lt;expr&gt; [ [, &lt;offset&gt; [, &lt;default&gt; ] ] )
          </literallayout>
        

        <important>
          <title>Important to Note</title>
          <para>FIRST_VALUE, LAST_VALUE and NTH_VALUE also operate on a window frame.
          Currently, Firebird always frames from the first to the current row of the partition,
          not to the last. This is likely to produce strange results for NTH_VALUE and
          especially LAST_VALUE.</para>
        </important>
        <para><emphasis role="bold">Example</emphasis></para>
          <programlisting>
select
    id,
    salary,
    first_value(salary) over (order by salary),
    last_value(salary) over (order by salary),
    nth_value(salary, 2) over (order by salary),
    lag(salary) over (order by salary),
    lead(salary) over (order by salary)
  from employee
  order by salary;
          </programlisting>
        
        <para><emphasis role="bold">The result set:</emphasis></para>
          <literallayout class="monospaced">
  id  salary  first_value  last_value  nth_value     lag    lead
  --  ------  -----------  ----------  ---------  ------  ------
  3     8.00         8.00        8.00     &lt;null&gt;  &lt;null&gt;    9.00
  4     9.00         8.00        9.00       9.00    8.00   10.00
  1    10.00         8.00       10.00       9.00    9.00   10.00
  5    10.00         8.00       10.00       9.00   10.00   12.00
  2    12.00         8.00       12.00       9.00   10.00  &lt;null&gt;
          </literallayout>
        
        <para>FIRST_VALUE and LAST_VALUE get, respectively, the first and last value
        of the ordered partition.</para>
        <para>NTH_VALUE gets the n-th value, starting from the first (default) or the last
        record, from the ordered partition. An offset of 1 from first would be equivalent
        to FIRST_VALUE;  an offset of 1 from last is equivalent to LAST_VALUE.</para>
        <para>LAG looks for a preceding row, and LEAD for a following row. LAG and LEAD
        get their values within a distance respective to the current row and the offset
        (which defaults to 1) passed.</para>
        <para>In a case where the offset points outside the partition, the default parameter
        (which defaults to NULL) is returned.</para>
      </section><!-- L3 -->
    </section><!-- L2 -->
  </section><!-- L1 -->

  <section id="rnfb30-dml-planoutput">
    <title>Advanced Plan Output</title>
    <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
    <para>PLAN output can now be output in a more structured and comprehensible form, e.g.</para>
    <literallayout class="monospaced">
SELECT statement
   -&gt; First [10]
     -&gt; Sort [SUM, O_ORDERDATE]
       -&gt; Aggregate
         -&gt; Sort [L_ORDERKEY, O_ORDERDATE, O_SHIPPRIORITY]
           -&gt; Inner Loop Join
             -&gt; Filter
               -&gt; Table &Lt;ORDERS&Gt; Access By ID
                 -&gt; Bitmap
                   -&gt; Index &Lt;ORDERS_ORDERDATE&Gt; Range Scan
             -&gt; Filter
               -&gt; Table &Lt;CUSTOMER&Gt; Access By ID
                 -&gt; Bitmap
                   -&gt; Index &Lt;CUSTOMER_PK&Gt; Unique Scan
             -&gt; Filter
               -&gt; Table &Lt;LINEITEM&Gt; Access By ID
                 -&gt; Bitmap
                   -&gt; Index &Lt;LINEITEM_PK&Gt; Unique Scan
    </literallayout>
    <section>
      <title>Advanced PLAN Output in isql</title>
      <para>New syntax <command>SET EXPLAIN [ON | OFF ]</command> has been 
      added to the <emphasis>isql</emphasis> utility to surface this option.  For details, 
      refer to <link linkend="rnfb30-util-isql-setexplain">SET EXPLAIN Extensions for Viewing 
      Detailed Plans</link> in the <command>Utilities</command> chapter.</para>
    </section><!-- L2 -->
  </section><!-- L1 -->


<!-- Internal Functions -->

  <section><!-- L1 -->
    <title>Internal Functions</title>
    <para>Additions and enhancements to the internal functions set are:</para>

    <section id="rnfb30-dml-substring"><!-- L2 -->
      <title>SUBSTRING with Regular Expressions</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>A substring search can now use a regular expression.</para>
      <para><emphasis role="bold">Search Pattern</emphasis></para>
        <literallayout class="monospaced">
  SUBSTRING(&lt;string&gt; [NOT] SIMILAR TO &lt;pattern&gt; ESCAPE &lt;char&gt;)
        </literallayout>
      
      <para>Discussion: Tracker<ulink url="http://tracker.firebirdsql.org/browse/CORE-2006">CORE-2006</ulink></para>
      <para>For more information about the use of SIMILAR TO expressions, refer to <filename>README.similar_to.txt</filename>
      in the /doc/ subdirectory of your Firebird installation.</para>
      <tip>
        <para>The regex used is the SQL one.  A guide is available in the DML chapter
        of the v.2.5 release notes and also at the <ulink
        url="http://www.firebirdsql.org/file/documentation/release_notes/html/rlsnotes253.html#rnfb25-dml-regex">Firebird
        web site</ulink>.</para>
      </tip>

    </section><!-- L2 -->

    <section id="rnfb30-dml-hyperbolic"><!-- L2 -->
      <title>Inverse Hyperbolic Trigonometric Functions</title>
      <author><firstname>Claudio</firstname><surname>Valderrama C.</surname></author>
      <para>The six inverse hyperbolic trigonometric functions have been implemented
      internally.  They are:</para>
      <variablelist>
        <varlistentry>
          <term>ACOSH</term>
          <listitem>
            <para>Returns the hyperbolic arc cosine of a number (expressed in radians).
            Format: <command>ACOSH( &lt;number&gt; )</command></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ASINH</term>
          <listitem>
            <para>Returns the hyperbolic arc sine of a number (expressed in radians).
            Format: <command>ASINH( &lt;number&gt; )</command></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>ATANH</term>
          <listitem>
            <para>Returns the hyperbolic arc tangent of a number (expressed in radians).
            Format: <command>ATANH( &lt;number&gt; )</command></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>COSH</term>
          <listitem>
            <para>Returns the hyperbolic cosine of an angle (expressed in radians).
            Format: <command>COSH( &lt;number&gt; )</command></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>SINH</term>
          <listitem>
            <para>Returns the hyperbolic sine of an angle (expressed in radians).
            Format:  <command>SINH( &lt;number&gt; )</command></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>TANH</term>
          <listitem>
            <para>Returns the hyperbolic tangent of an angle (expressed in radians).
            Format: <command>TANH( &lt;number&gt; )</command></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section><!-- L2 -->

    <section id="rnfb30-dml-statistical"><!-- L2 -->
      <sectioninfo>
        <title>Statistical Functions</title>
        <authorgroup>
          <author><firstname>Hajime</firstname><surname>Nakagami</surname></author>
          <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
        </authorgroup>
      </sectioninfo>
      <para>A suite of SQL-standards-compliant statistical functions has been
      implemented.</para>
<!-- Aggregate Statistical Functions -->
      <section id="rnfb30-dml-statistical-sd"><!--L3 -->
        <title>Aggregate Statistical Functions</title>
        <para>Functions comprise Sample Variance, Population Variance, Sample Standard Deviation,
        Population Standard Deviation, Sample Population, Population Covariance and Coefficient
        of Correlation.  See Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-4717">CORE-4717</ulink>.</para>

        <para><emphasis role="bold">Syntax</emphasis></para>
        <literallayout class="monospaced">
  &lt;single param statistical function&gt; ::= &lt;single param statistical function name&gt;(&lt;expr&gt;)
  &lt;single param statistical function name&gt; := { VAR_POP | VAR_SAMP | STDDEV_POP | STDDEV_SAMP }

  &lt;dual param statistical function&gt; ::= &lt;dual param statistical function name&gt;(&lt;expr1&gt;, &lt;expr&gt;>)
  &lt;dual param statistical function name&gt; := { COVAR_POP | COVAR_SAMP | CORR }
        </literallayout>
        <note>
          <title>Semantics</title>
          <itemizedlist>
            <listitem>NULL is returned from VAR_SAMP, STDDEV_SAMP or COVAR_SAMP if the
            result count is 0 or 1</listitem>
            <listitem>NULL is returned from VAR_POP, STDDEV_POP, COVAR_POP or CORR if the
            result count is 0</listitem>
          </itemizedlist>
        </note>

        <para><emphasis role="bold">Syntax</emphasis></para>
        <programlisting>
SELECT STDDEV_SAMP(salary) FROM employees;
        </programlisting>

        <para><emphasis role="bold">SD/Variance Function Descriptions</emphasis></para>
        <informaltable id="rnfb30-statistical01">
          <tgroup cols="3">
            <colspec align="center" colname="col-func" colwidth="2*"/>
            <colspec align="center" colname="col-fmt" colwidth="4*"/>
            <colspec align="left" colname="col-desc" colwidth="6*"/>
            <spanspec spanname="span-equiv" namest="col-func" nameend="col-desc"
              colsep="0"/>
            <thead>
              <row>
                <entry align="center">Function</entry>
                <entry align="center">Format</entry>
                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
    <!-- table entry -->
              <row>
                <entry><emphasis>VAR_SAMP</emphasis></entry>
                <entry>VAR_SAMP( &lt;expr&gt; )</entry>
                <entry>Returns the Sample Variance, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
(SUM(&lt;expr&gt; ^ 2) - SUM(&lt;expr&gt;) ^ 2 / COUNT(&lt;expr&gt;)) / (COUNT(&lt;expr&gt;) - 1)
                </programlisting></entry>
              </row>


    <!-- table entry -->
              <row>
                <entry><emphasis>VAR_POP</emphasis></entry>
                <entry>VAR_POP( &lt;expr&gt; )</entry>
                <entry>Returns the the Population Variance, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
(SUM(&lt;expr&gt; ^ 2) - SUM(&lt;expr&gt;) ^ 2 / COUNT(&lt;expr&gt;)) / COUNT(&lt;expr&gt;)
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>STDDEV_SAMP</emphasis></entry>
                <entry>STDDEV_SAMP( &lt;expr&gt; )</entry>
                <entry>Returns the Sample Standard Deviation, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
SQRT(VAR_SAMP(&lt;expr&gt;))
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>STDDEV_POP</emphasis></entry>
                <entry>STDDEV_POP( &lt;expr&gt; )</entry>
                <entry>Returns the Population Standard Deviation, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
SQRT(VAR_POP(&lt;expr&gt;))
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>COVAR_SAMP</emphasis></entry>
                <entry>COVAR_SAMP( &lt;expr1&gt;, &lt;expr2&gt; )</entry>
                <entry>Returns the Sample Population, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
(SUM(&lt;expr1&gt; * &lt;expr2&gt;) - SUM(&lt;expr1&gt;) * SUM(&lt;expr2&gt;) / COUNT(*)) / (COUNT(*) - 1)
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>COVAR_POP</emphasis></entry>
                <entry>COVAR_POP( &lt;expr1&gt;, &lt;expr2&gt; )</entry>
                <entry>Returns the Population Covariance, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
(SUM(&lt;expr1&gt; * &lt;expr2&gt;) - SUM(&lt;expr1&gt;) * SUM(&lt;expr2&gt;) / COUNT(*)) / COUNT(*)
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>CORR</emphasis></entry>
                <entry>CORR( &lt;expr1&gt;, &lt;expr2&gt; )</entry>
                <entry>Returns the Coefficient of Correlation, equivalent to</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
COVAR_POP(&lt;expr1&gt;, &lt;expr2&gt;) / (STDDEV_POP(&lt;expr2&gt;) * STDDEV_POP(&lt;expr1&gt;))
                </programlisting></entry>
              </row>

            </tbody>
          </tgroup>
        </informaltable>
      </section>
<!-- Linear Regression Functions -->
      <section id="rnfb30-dml-statistical-regr"><!--L3 -->
        <title>Linear Regression Functions</title>
        <para>The suite of REGR_* functions analyses the relationships
        between two sets of numeric data, considering only sets that
        are not NULL in either expression. See Tracker ticket 
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-4722">CORE-4722</ulink>.</para>

        <para><emphasis role="bold">Syntax</emphasis></para>
        <literallayout class="monospaced">
&lt;regr function&gt; ::= &lt;function name&gt;(&lt;expr1&gt;, &lt;expr2&gt;)
&lt;function name&gt; := { REGR_AVGX | REGR_AVGY | REGR_COUNT | REGR_INTERCEPT |
                         REGR_R2 | REGR_SLOPE | REGR_SXX | REGR_SXY | REGR_SYY }
        </literallayout>

        <para><emphasis role="bold">Formulae</emphasis></para>
        <para>The formulae use the following variables:</para>
        <literallayout class="monospaced">
  Y: &lt;expr1&gt; (&lt;expr1&gt; IS NOT NULL AND &lt;expr2&gt; IS NOT NULL)
  X: &lt;expr2&gt; (&lt;expr1&gt; IS NOT NULL AND &lt;expr2&gt; IS NOT NULL)
  N: COUNT of recordset unless &lt;expr1&gt; IS NULL OR &lt;expr2&gt; IS NULL
        </literallayout>
        <important>
          <para>Y and X are DOUBLE PRECISION. N is SMALLINT, INTEGER or BIGINT.</para>
          <para>All functions eliminate expression pairs where either expression in the pair is NULL.
          If no rows remain, the functions (except REGR_COUNT()) return NULL.</para>
        </important>

        <para><emphasis role="bold">Linear Regression Function Descriptions</emphasis></para>
        <informaltable id="rnfb30-statistical02">
          <tgroup cols="3">
            <colspec align="center" colname="col-func" colwidth="2*"/>
            <colspec align="center" colname="col-fmt" colwidth="4*"/>
            <colspec align="left" colname="col-desc" colwidth="6*"/>
            <spanspec spanname="span-equiv" namest="col-func" nameend="col-desc"
              colsep="0"/>
            <thead>
              <row>
                <entry align="center">Function</entry>
                <entry align="center">Format</entry>
                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_AVGX</emphasis></entry>
                <entry>REGR_AVGX(Y, X)</entry>
                <entry>Returns the average of the independent expression (Y) in the expression pair.
                The return value is of type DOUBLE PRECISION.</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_AVGX(Y, X) = SUM(X) / N
                </programlisting></entry>
              </row>
    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_AVGY</emphasis></entry>
                <entry>REGR_AVGY(Y, X)</entry>
                <entry>Returns the average of the dependent expression (X) in the expression pair.
                The return value is of type DOUBLE PRECISION.</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_AVGY(Y, X) = SUM(Y) / N
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_COUNT</emphasis></entry>
                <entry>REGR_COUNT(Y, X)</entry>
                <entry>Returns the number of expression pairs (Y and X). The return value
                is of type SMALLINT, INTEGER or BIGINT. If no rows remain after elimination
                of pairs where either expression is NULL, the function returns 0.</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_COUNT(Y, X) = N
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_INTERCEPT</emphasis></entry>
                <entry>REGR_INTERCEPT(Y, X)</entry>
                <entry>Returns the y-intercept of the regression line determined by a set
                of expression pairs (Y and X).</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_INTERCEPT(Y, X) = REGR_AVGY(Y, X) - REGR_SLOPE(Y, X) * REGR_AVGX(Y, X)
                </programlisting></entry>
              </row>

    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_R2</emphasis></entry>
                <entry>REGR_R2(Y, X)</entry>
                <entry>Returns the square of the correlation coefficient of a set of
                expression pairs (Y and X).</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_R2(Y, X) = POWER(CORR(Y, X),2)
                </programlisting></entry>
              </row>
    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_SLOPE</emphasis></entry>
                <entry>REGR_SLOPE(Y, X)</entry>
                <entry>Returns the slope of the regression line, determined by a
                set of expression pairs (Y and X).</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_SLOPE(Y, X) = COVAR_POP(Y, X) / VAR_POP(X)
                </programlisting></entry>
              </row>
    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_SXX</emphasis></entry>
                <entry>REGR_SXX(Y, X)</entry>
                <entry>Returns the sum of squares of the independent expression (Y)
                in an expression pair (Y and X).</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_SXX(Y, X) = N * VAR_POP(X)
                </programlisting></entry>
              </row>
    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_SXY</emphasis></entry>
                <entry>REGR_SXY(Y, X)</entry>
                <entry>Returns the sum of products of the independent expression multiplied
                by the dependent expression in an expression pair (Y and X).</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_SXY(Y, X) = N * COVAR_POP(Y, X)
                </programlisting></entry>
              </row>
    <!-- table entry -->
              <row>
                <entry><emphasis>REGR_SYY</emphasis></entry>
                <entry>REGR_SYY(Y, X)</entry>
                <entry>Returns the sum of squares of the dependent expression 
                in an expression pair (Y and X).</entry>
              </row>
              <row>
                <entry spanname="span-equiv" colsep="0">
                <programlisting>
Formula: REGR_SYY(Y, X) = N * VAR_POP(Y)
                </programlisting></entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
      </section>
    </section><!--L2 -->

    <section id="rnfb30-dml-trim"><!-- L2 -->
      <title>TRIM() BLOB Arguments Lose 32 KB limit</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>In prior versions, TRIM(substring from string) allowed BLOBs for both arguments,
      but the first argument had to be smaller than 32 KB.  Now both arguments can take BLOBs
      of up to 4 GB.</para>
    </section><!-- L2 -->

    <section id="rnfb30-dml-literalstring"><!-- L2 -->
      <title>String Literal Limit Adjustments</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>The internal length of a string can, at some levels, be almost 64 KB.  Tests 
      demonstrated that it is safe to accept a string literal of up to that size for 
      writing to a text BLOB.  Accordingly,
        <orderedlist spacing="compact">
          <listitem>The (32KB - 3) <quote>safety limit</quote> on literal string length for writing
          to text BLOBs has been raised to 65,533 bytes (64KB - 3);</listitem>
          <listitem>A limit, in characters, is calculated in run-time for strings that are in
          multi-byte character sets, to avoid overrunning the bytes limit.  For example, for
          a UTF8 string (max. 4 bytes/character) the run-time limit is likely to be about
          (floor (65533/4)) = 16383 <emphasis>characters</emphasis>. </listitem>
        </orderedlist>
      </para>
      <para>See Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-4881">CORE-4881</ulink>.
      </para>
    </section><!-- L2 -->

<!-- ENHANCEMENTS TO DATEADD() FUNCTION -->
    <section id="rnfb30-dml-functions-dateadd"><!-- L2 -->
      <title>Enhancements to DATEADD() Internal Function</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>For the internal function DATEADD()</para>
      <itemizedlist>
        <listitem>
          <para>The function now supports a fractional value for MILLISECOND.  See Tracker
          item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4457">CORE-4457</ulink>.</para>
        </listitem>
        <listitem>
          <para>the data type of input &lt;amount&gt; arguments has changed from INTEGER
          to BIGINT.  See Tracker
          item <ulink url="http://tracker.firebirdsql.org/browse/CORE-4310">CORE-4310</ulink>.</para>
        </listitem>
      </itemizedlist>
    </section><!-- L2 -->

  </section><!-- L1 -->

<!-- DML Improvements -->
  <section><!-- L1 -->
    <title>DML Improvements</title>
    <para>A collection of useful DML improvements is released with Firebird 3.</para>

<!-- Support for alternative quoting of string literals -->

    <section id="rnfb30-dml-altquoting"><!-- L2 -->
      <title>Alternatives for Embedding Quotes in String Literals</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>It is now possible to use a character, or character pair, other than the
      doubled (escaped) apostrophe, to embed a quoted string inside another string.
      The keyword <command>q</command> or <command>Q</command> preceding a quoted string
      informs the parser that certain left-right pairs or pairs of identical characters
      within the string are the delimiters of the embedded string literal.</para>
      <para><emphasis role="bold">Syntax</emphasis></para>
        <literallayout class="monospaced">
&lt;alternate string literal&gt; ::=
    { q | Q } &lt;quote&gt; &lt;alternate start char&gt; [ { &lt;char&gt; }... ] &lt;alternate end char&gt; &lt;quote&gt;
        </literallayout>

      <note>
        <title>Rules</title>
        <para>When &lt;alternate start char&gt; is '(', '{', '[' or '&lt;', &lt;alternate end char&gt; is paired up
        with its respective <quote>partner</quote>, viz. ')', '}', ']' and '&gt;'. In other cases, &lt;alternate end char&gt;
        is the same as &lt;alternate start char&gt;.</para>
        <para>Inside the string, i.e., &lt;char&gt; items, single (not escaped) quotes could be used. Each quote
        will be part of the result string.</para>
      </note>
      <para><emphasis role="bold">Examples</emphasis></para>
        <programlisting>
select q'{abc{def}ghi}' from rdb$database;        -- result: abc{def}ghi
select q'!That's a string!' from rdb$database;    -- result: That's a string
        </programlisting>
      
    </section><!-- L2 -->
    
    <section id="rnfb30-dml-offsetfetch"><!-- L2 -->
      <title>SQL:2008-Compliant OFFSET and FETCH Clauses</title>
      <author><firstname>Mark</firstname><surname>Rotteveel</surname></author>
      <para>New SQL:2008 compliant OFFSET and FETCH clauses provide a standard equivalent 
      for FIRST and SKIP, and an alternative for ROWS...TO, when fetching sets from
      ordered output.</para>
      <itemizedlist>
        <listitem>
          <para>The OFFSET clause specifies the number of rows to skip</para>
        </listitem>
        <listitem>
          <para>The FETCH clause specifies the number of rows to fetch.</para>
        </listitem>
      </itemizedlist>

      <para>As with SKIP and FIRST, OFFSET and FETCH clauses can be applied independently, 
      in both top-level and nested query expressions.  They are available in PSQL and 
      DSQL.</para>

      <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <literallayout class="monospaced">
  SELECT ... [ ORDER BY &lt;expr_list&gt; ]
      [ OFFSET &lt;simple_value_expr&gt; { ROW | ROWS } ]
      [ FETCH { FIRST | NEXT } [ &lt;simple_value_expr&gt; ] { ROW | ROWS } ONLY ]
      </literallayout>
      <para><command>&lt;simple_value_expr&gt;</command> is a (numeric) literal,
      a DSQL parameter (?) or a PSQL named parameter (:namedparameter) that 
      resolves to an integer data type.</para>

      <para><emphasis role="bold">Examples</emphasis></para>
      <programlisting>
-- 1:
SELECT * FROM T1 ORDER BY COL1
  OFFSET 10 ROWS;
-- 2:
SELECT * FROM T1 ORDER BY COL1
  FETCH FIRST 10 ROWS ONLY;
-- 3:
SELECT * FROM (
               SELECT * FROM T1 ORDER BY COL1 DESC
               OFFSET 1 ROW
               FETCH NEXT 10 ROWS ONLY
               ) a
       ORDER BY a.COL1
       FETCH FIRST ROW ONLY;
      </programlisting>
      <note>
        <title>Notes</title>
        <orderedlist>
          <listitem>
            <para>The FIRST/SKIP and ROWS clauses are non-standard alternatives.</para>
          </listitem>
          <listitem>
            <para>The OFFSET and/or FETCH clauses cannot be mixed with clauses from
            the FIRST/SKIP or ROWS alternatives in the same query expression.</para>
          </listitem>
          <listitem>
            <para>Expressions and column references are not allowed within either the
            OFFSET or the FETCH clause.</para>
          </listitem>
          <listitem>
            <para>Unlike the ROWS clause, OFFSET and FETCH are available only in SELECT
            statements.</para>
          </listitem>
          <listitem>
            <para>The <quote>percentage FETCH</quote> defined in the SQL standard is not
            supported.</para>
          </listitem>
          <listitem>
            <para><quote>FETCH ... WITH TIES</quote> defined in the SQL standard is not
            supported.</para>
          </listitem>

        </orderedlist>
      </note>
    </section>

    <section id="rnfb30-dml-mixjoins"><!-- L2 -->
      <title>Prohibit Edgy Mixing of Implicit/Explicit Joins</title>
      <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      <para>While mixing of implicit and explict join syntaxes is not recommended at all, the parser 
      would allows them, nevertheless.  Certain <quote>mixes</quote> actually cause the optimizer to produce unexpected
      results, including <quote>No record for fetch</quote> errors.  The same edgy styles are prohibited
      by other SQL engines and now they are prohibited in Firebird.</para>

      <para>To visit some discussion on the subject, see the Tracker
      ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-2812">CORE-2812</ulink>.</para>
    </section><!-- L2 -->

    <section id="rnfb30-dml-leftparam"><!-- L2 -->
      <title>Support for Left-side Parameters in WHERE Clause</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>The following style of subquery, with the parameter in the left side of a WHERE...IN (SELECT...)
      condition, would fail with the error <quote>The data type of the parameter is unknown</quote>.</para>
      <para>This style is now accepted.  For example:</para>
      <programlisting>
SELECT &lt;columns&gt; FROM table_1 t1
  WHERE &lt;conditions on table_1&gt;
  AND (? IN (SELECT some_col FROM table_2 t2 WHERE t1.id = t2.ref_id))
      </programlisting>

      <important>
        <para>Better SQL coding practice would be to use EXISTS in these cases;  however, developers
        were stumbling over this problem when using generated SQL from Hibernate, which used the
        undesirable style.</para>
      </important>
    </section><!-- L2 -->


<!-- RETURNING clause -->

    <section id="rnfb30-dml-returning"><!-- L2 -->
      <title>Enhancements to the RETURNING Clause</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>Two enhancements were added to the RETURNING clause: </para>

      <section id="rnfb30-dml-returningalias"><!-- L3 -->
        <title>RETURNING Clause Value Can be Aliased</title>
        <para>When using the RETURNING clause to return a value to the client, the value
        can now be passed under an alias.</para>
        <para><emphasis role="bold">Example Without and With Aliases</emphasis></para>
          <literallayout class="monospaced">
  UPDATE T1 SET F2 = F2 * 10
    RETURNING OLD.F2, NEW.F2; -- without aliases

  UPDATE T1 SET F2 = F2 * 10
    RETURNING OLD.F2 OLD_F2, NEW.F2 AS NEW_F2; -- with aliases
          </literallayout>
        
        <note>
          <para>The keyword AS is optional.</para>
        </note>
      </section><!-- L3 -->

      <section id="rnfb30-dml-returningcursor"><!-- L3 -->
        <title>RETURNING Clause from Positioned Updates and Deletes</title>
        <para>Support has been added for a RETURNING clause in positioned (WHERE CURRENT OF)
        UPDATE and DELETE statements.</para>
        <para><emphasis role="bold">Example</emphasis></para>
          <literallayout class="monospaced">
  UPDATE T1 SET F2 = F2 * 10 WHERE CURRENT OF C
    RETURNING NEW.F2;
          </literallayout>

      </section><!-- L3 -->
    </section><!-- L2 -->

    <section id="rnfb30-dml-curstability"><!-- L2 -->
      <title>Cursor Stability</title>
      <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
      <para>Until this release, Firebird suffered from an infamous bug whereby
      a data modification operation could loop infinitely and, depending on
      the operation, delete all the rows in a table, continue updating the
      same rows ad infinitum or insert rows until the host machine ran out
      of resources. All DML statements were affected (INSERT, UPDATE, DELETE,
      MERGE).  It occurred because the engine used an implicit cursor for
      the operations.</para>

      <para>To ensure stability, rows to be inserted, updated or deleted
      had to be marked in some way in order to avoid multiple visits.  Another
      workaround was to force the query to have a SORT in its plan, in order
      to materialize the cursor.</para>

      <para>From Firebird 3, engine uses the Undo log to check whether a row
      was already inserted or modified by the current cursor.</para>
      <important>
        <para>This stabilisation does NOT work with SUSPEND loops in PSQL.</para>
      </important>
    </section><!-- L2 -->


<!-- Global temporary tables are improved -->

    <section id="rnfb30-dml-gtt"><!-- L2 -->
      <title>An Improvement for GTTs</title>
      <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
      <para>Global temporary tables (GTTs) are now writable even in read-only
      transactions.  The effect is as follows.-</para>
      <variablelist>
        <varlistentry>
          <term>Read-only transaction in read-write database</term>
          <listitem>
            <para>Writable in both ON COMMIT PRESERVE ROWS and ON
            COMMIT DELETE ROWS</para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Read-only transaction in read-only database</term>
          <listitem>
            <para>Writable in ON COMMIT DELETE ROWS only</para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Also</para>
      <itemizedlist>
        <listitem>
          <para>Rollback for GTT ON COMMIT DELETE ROWS is faster</para>
        </listitem>
        <listitem>
          <para>Rows do not need to be backed out on rollback</para>
        </listitem>
        <listitem>
          <para>Garbage collection in GTT is not delayed by active
          transactions of other connections</para>
        </listitem>
      </itemizedlist>
      <note>
        <para>The same refinements were also backported to Firebird 2.5.1.</para>
      </note>
    </section><!-- L2 -->

<!-- DML STRING VALIDATION/TRANSFORMATION -->
    <section id="rnfb30-dml-validate"><!-- L2 -->
      <title>An Improvement for DML Strings</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>Strings in DML queries are now transformed or validated to avoid passing
      malformed strings to the engine internals, for example, to the MON$STATEMENTS.MON$SQL_TEXT column.</para>
      <para>The solution adopted depends on the character set of the attachment.-</para>
      <itemizedlist>
        <listitem>
          <para>NONE&mdash;non-ASCII characters are transformed to question marks</para>
        </listitem>
        <listitem>
          <para>Others&mdash;the string is checked for malformed characters</para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="rnfb30-dml-countresult"><!-- L2 -->
      <title>COUNT() Now Returns BIGINT</title>
      <para>The COUNT() aggregator now returns its result as BIGINT instead of INTEGER.</para>
    </section>

<!-- Optimizations -->

    <section><!-- L2 -->
      <title>Optimizations</title>
      <para>Optimizations made for this release included:</para>

      <section id="rnfb30-dml-similarto"><!-- L3 -->
        <title>SIMILAR TO</title>
        <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
        <para>The performance of SIMILAR TO was improved.</para>
      </section><!-- L3 -->

      <section id="rnfb30-dml-orparam"><!-- L3 -->
        <title>OR'ed Parameter in WHERE Clause</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
        <para>Performance for <command>(table.field = :param or :param = -1)</command>
        in the WHERE clause was enhanced.</para>
      </section><!-- L3 -->

      <section id="rnfb30-dml-perf01"><!-- L3 -->
        <title>Better Choices for Navigation</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
        <para>Previously, when an ORDER plan was in a SELECT structure, the optimizer would choose
        the first index candidate that matched the ORDER BY or GROUP BY clause. This
        <quote>first come</quote> approach is not the best when multiple index choices
        are available.  The Firebird 3 engine surveys all of the available choices
        and picks the most suitable index.</para>
        <para>See Tracker ticket
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-4285">CORE-4285</ulink>.</para>
      </section><!-- L3 -->

      <section id="rnfb30-dml-perf02"><!-- L3 -->
        <title>Plainer Execution Path for UNION Queries</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
        <para>Previously, the execution path for UNION queries was hierarchical, often causing
        redundant reads.  This optimization replaces the hierarchical execution path with a
        plainer one that improves performance.</para>
        <para>See Tracker ticket
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-4165">CORE-4165</ulink>.</para>
      </section><!-- L3 -->

      <section id="rnfb30-dml-perf03"><!-- L3 -->
        <title>Index Walk for Compound Index</title>
        <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
        <para>The optimizer now allows an index walk (ORDER plan) when a suitable
        compound index (A, B) is available for a query condition of the style
        <command>WHERE A = ? ORDER BY B</command>.</para>
        <para>See Tracker ticket
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-1846">CORE-1846</ulink>.</para>
      </section><!-- L3 -->

      <section id="rnfb30-dml-perf04"><!-- L3 -->
        <title>Performance Improvement for SET STATISTICS INDEX</title>
        <author><firstname>Vlad</firstname><surname>Khorsun</surname></author>
        <para>BTR_selectivity() would walk the whole leaf level of given index b-tree to calculate
        index selectivity.  Throughout the process, the only rescheduling would happen
        at a disk I/O operation.  The effect was to impose long waits for AST requests from concurrent
        attachments, such as page lock requests, monitoring, cancellation, etc.  An
        improvement in Firebird 3 seems to solve that problem.</para>
        <para>See Tracker ticket 
        <ulink url="http://tracker.firebirdsql.org/browse/CORE-1846">CORE-1846</ulink>.</para>
      </section><!-- L3 -->

    </section><!-- L2 -->

<!-- Dialect 1 Interface -->

    <section id="rnfb30-dml-dialect1"><!-- L2 -->
      <title>Dialect 1 Interface</title>
      <author><firstname>Adriano</firstname><surname>dos Santos Fernandes</surname></author>
      <para>Selection of SQL_INT64, SQL_DATE and SQL_TIME in dialect 1 was enabled.</para>
      <para>See Tracker <ulink url="http://tracker.firebirdsql.org/browse/CORE-3972">CORE-3972</ulink></para>
    </section><!-- L2 -->

<!-- Embedded SQL (ESQL) -->

    <section id="rnfb30-dml-esql"><!-- L2 -->
      <title>Embedded SQL (ESQL) Enhancements</title>
      <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
      <para>Two enhancements were included in the Embedded SQL subset in this release:</para>
      <variablelist>
        <varlistentry>
          <term>Support for UPDATE OR INSERT statement</term>
          <listitem>
            <para>See Tracker ticket  <ulink url="http://tracker.firebirdsql.org/browse/CORE-4438">CORE-4438</ulink></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Support for the RETURNING clause</term>
          <listitem>
            <para>See Tracker ticket <ulink url="http://tracker.firebirdsql.org/browse/CORE-4437">CORE-4437</ulink></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section><!-- L2 -->
  </section><!-- L1 -->
</chapter>