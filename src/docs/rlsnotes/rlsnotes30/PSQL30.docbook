<chapter id="rnfb30-psql">
  <chapterinfo>
    <title>Procedural SQL (PSQL)</title>
  </chapterinfo>
  <para>Advancements in procedural SQL (PSQL) include:</para>

  <section id="rnfb30-psql-links"><!-- Level 1 section -->
    <title>Quick Links</title>
    <itemizedlist spacing="compact">
      <listitem>
        <para><link linkend="rnfb30-psql-funcs">PSQL Stored Functions</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-subroutines">PSQL Subroutines</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-packages">Packages</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-ddltriggers">DDL Triggers</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-exceptparams">Exceptions with Parameters</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-continue">CONTINUE in Looping Logic</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-cursor-stablility">PSQL Cursor Stabilization</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-cursor-asvariable">PSQL Cursors as Variables</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-whensqlstate">SQLSTATE Now Valid in Exception Trap</link></para>
      </listitem>
      <listitem>
        <para><link linkend="rnfb30-psql-limitsoff">Some Size Limits Removed Using New API</link></para>
      </listitem>
    </itemizedlist>
  </section><!-- sect 1 -->

<!-- STORED FUNCTIONS -->
  <section id="rnfb30-psql-funcs"><!-- L1 -->
    <title>PSQL Stored Functions</title>
    <author>
      <firstname>Dmitry</firstname><surname>Yemanov</surname>
    </author>
    <para>It is now possible to write a scalar function in PSQL and call it just
    like an internal function.</para>
    <para><emphasis role="bold">Syntax for the DDL</emphasis></para>
      <literallayout class="monospaced">
  {CREATE [OR ALTER] | ALTER | RECREATE} FUNCTION &lt;name&gt;
  [(param1 [, ...])]
  RETURNS &lt;type&gt;
  AS
  BEGIN
    ...
  END
      </literallayout>
      <tip>
        <para>The CREATE statement is the <emphasis>declaration syntax</emphasis> for PSQL functions, parallel 
        to DECLARE for legacy UDFs.</para>
      </tip>
    
      <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
CREATE FUNCTION F(X INT) RETURNS INT
AS
BEGIN
  RETURN X+1;
END;
SELECT F(5) FROM RDB$DATABASE;
      </programlisting>
    
  </section><!-- L1 -->

<!-- SUB-ROUTINES -->
  <section id="rnfb30-psql-subroutines"><!-- L1 -->
    <title>PSQL Sub-routines</title>
    <author>
      <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <para>The header of a PSQL module (stored procedure, stored function,
    trigger, executable block) can now accept sub-procedure and sub-function
    blocks in the header declarations for use within the body of the module.</para>
    <para><emphasis role="bold">Syntax for Declaring a Sub-procedure</emphasis></para>
      <literallayout class="monospaced">
  DECLARE PROCEDURE &lt;name&gt; [(param1 [, ...])]
  [RETURNS (param1 [, ...])]
  AS
  ...
      </literallayout>

    <para><emphasis role="bold">Syntax for declaring a Sub-function</emphasis></para>
      <literallayout class="monospaced">
  DECLARE FUNCTION &lt;name&gt; [(param1 [, ...])]
  RETURNS &lt;type&gt;
  AS
  ...
      </literallayout>

    <para><emphasis role="bold">Examples</emphasis></para>
      <programlisting>
SET TERM ^;
--
-- Sub-function in EXECUTE BLOCK
--
EXECUTE BLOCK RETURNS (N INT)
AS
  DECLARE FUNCTION F(X INT) RETURNS INT
  AS
  BEGIN
    RETURN X+1;
  END
BEGIN
  N = F(5);
  SUSPEND;
END ^
--
-- Sub-function inside a stored function
--
CREATE OR ALTER FUNCTION FUNC1 (n1 INTEGER, n2 INTEGER)
  RETURNS INTEGER
  AS
  DECLARE FUNCTION SUBFUNC (n1 INTEGER, n2 INTEGER)
    RETURNS INTEGER
    AS
    BEGIN
      RETURN n1 + n2;
    END
    BEGIN
      RETURN SUBFUNC(n1, n2);
    END ^
--
select func1(5, 6) from rdb$database ^
      </programlisting>

  </section><!-- L1 -->

<!-- PACKAGES -->
  <section id="rnfb30-psql-packages"><!-- L1 -->
    <title>Packages</title>
    <author>
      <firstname>A.</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <note>
    <title>Acknowledgement</title>
      <para>This feature was sponsored with donations gathered at the fifth Brazilian
      Firebird Developers' Day, 2008</para>
    </note>
    <para>A package is a group of procedures and functions managed as one entity.
    The notion of <quote>packaging</quote> the code components of a database
    operation addresses several objectives:</para>
    <variablelist>
      <varlistentry>
        <term>Modularisation</term>
        <listitem>
          <para>The idea is to separate blocks of interdependent code into logical
          modules, as programming languages do.</para>
          <para>In programming it is well recognised that grouping code in various ways,
          in namespaces, units or classes, for example, is a good thing. With standard procedures
          and functions in the database this is not possible. Although they can be grouped in
          different script files, two problems remain:</para>
          <orderedlist>
            <listitem>
              <para>The grouping is not represented in the database metadata.</para>
            </listitem>
            <listitem>
              <para>Scripted routines all participate in a flat namespace and are callable by
              everyone (we are not referring to security permissions here).</para>
            </listitem>
          </orderedlist>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>To facilitate dependency tracking</term>
        <listitem>
          <para>We want a mechanism to facilitate dependency tracking between a collection
          of related internal routines, as well as between this collection and other
          routines, both packaged and unpackaged.</para>
          <para>Firebird packages come in two parts: a <emphasis>header</emphasis> (keyword
          PACKAGE) and a <emphasis>body</emphasis> (keyword PACKAGE BODY). This division is
          very similar to a Delphi unit, the header corresponding to the interface part and
          the body corresponding to the implementation part.</para>
          <para>The header is created first (CREATE PACKAGE) and the body (CREATE PACKAGE BODY)
          follows.</para>
          <para>Whenever a packaged routine determines that it uses a certain database object,
          a dependency on that object is registered in Firebird system tables.  Thereafter,
          to drop, or maybe alter that object, you first need to remove what depends on it.
          As it is a package body that depends on it, that package body can just be dropped,
          even if some other database object depends on this package. When the body is dropped,
          the header remains, allowing you to recreate its body once the changes related to the
          removed object are done.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term>To facilitate permission management</term>
        <listitem>
          <para>It is good practice in general to create routines to require privileged
          use and to use roles or users to enable the privileged use. As Firebird runs
          routines with the caller privileges, it is necessary also to grant resource usage
          to each routine when these resources would not be directly accessible to the
          caller.  Usage of each routine needs to be granted to users and/or roles.</para>
          <para>Packaged routines do not have individual privileges. The privileges act on
          the package. Privileges granted to packages are valid for all package body routines,
          including private ones, but are stored for the package header.</para>
          <para><emphasis role="bold">For example:</emphasis></para>
            <literallayout class="monospaced">
  GRANT SELECT ON TABLE secret TO PACKAGE pk_secret;
  GRANT EXECUTE ON PACKAGE pk_secret TO ROLE role_secret;
            </literallayout>

        </listitem>
      </varlistentry>

      <varlistentry>
        <term>To enable <quote>private scope</quote></term>
        <listitem>
          <para>This objective was to introduce private scope to routines; that is, to make them
          available only for internal usage within the defining package.</para>
          <para>All programming languages have the notion of routine scope, which is not possible
          without some form of grouping.  Firebird packages also work like Delphi units in
          this regard. If a routine is not declared in the package header (interface) and is
          implemented in the body (implementation), it becomes a private routine. A private
          routine can only be called from inside its package.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section id="rnfb30-psql-pkg-signatures"><!-- L2 -->
      <title>Signatures</title>
      <para>For each routine that is assigned to a package, elements of a digital 
      signature (the set of [routine name, parameters and return type]) are stored in 
      the system tables.</para>
      <para>The signature of a procedure or routine can be queried, as follows:</para>
      <programlisting>
SELECT...
-- sample query to come
      </programlisting>
    </section>

    <section><!-- L2 -->
      <title>Packaging Syntax</title>
      <literallayout class="monospaced">
    &lt;package_header&gt; ::=
        { CREATE [OR ALTER] | ALTER | RECREATE } PACKAGE &lt;name&gt;
        AS
        BEGIN
            [ &lt;package_item&gt; ... ]
        END

    &lt;package_item&gt; ::=
        &lt;function_decl&gt; ; |
        &lt;procedure_decl&gt; ;

    &lt;function_decl&gt; ::=
        FUNCTION &lt;name&gt; [( &lt;parameters&gt; )] RETURNS &lt;type&gt;

    &lt;procedure_decl&gt; ::=
        PROCEDURE &lt;name&gt; [( &lt;parameters&gt; ) [RETURNS ( &lt;parameters&gt; )]]

    &lt;package_body&gt; ::=
        { CREATE | RECREATE } PACKAGE BODY &lt;name&gt;
        AS
        BEGIN
            [ &lt;package_item&gt; ... ]
            [ &lt;package_body_item&gt; ... ]
        END

    &lt;package_body_item&gt; ::=
        &lt;function_impl&gt; |
        &lt;procedure_impl&gt;

    &lt;function_impl&gt; ::=
        FUNCTION &lt;name&gt; [( &lt;parameters&gt; )] RETURNS &lt;type&gt;
        AS
        BEGIN
           ...
        END
        |
        FUNCTION &lt;name&gt;  [( &lt;parameters&gt; )] RETURNS &lt;type&gt;
            EXTERNAL NAME '&lt;name&gt;' ENGINE &lt;engine&gt;

    &lt;procedure_impl&gt; ::=
        PROCEDURE &lt;name&gt; [( &lt;parameters&gt; ) [RETURNS ( &lt;parameters&gt; )]]
        AS
        BEGIN
           ...
        END
        |
        PROCEDURE &lt;name&gt; [( &lt;parameters&gt; ) [RETURNS ( &lt;parameters&gt; )]]
            EXTERNAL NAME '&lt;name&gt;' ENGINE &lt;engine&gt;

    &lt;drop_package_header&gt; ::=
        DROP PACKAGE &lt;name&gt;

    &lt;drop_package_body&gt; ::=
        DROP PACKAGE BODY &lt;name&gt;
      </literallayout>

      <para><emphasis role="bold">Syntax rules</emphasis></para>
      <itemizedlist>
        <listitem>
          <para>All routines declared in the header and at the start of the body should
          be implemented in the body with the
          same <link linkend="rnfb30-psql-pkg-signatures">signature</link>, i.e., 
          you cannot declare the routine in different ways in the header and in the 
          body.</para>
        </listitem>
        <listitem>
          <para>Default values for procedure parameters cannot be redefined
          in &lt;package_item&gt; and &lt;package_body_item&gt;. They can be
          in &lt;package_body_item&gt; only for private procedures that are not
          declared.</para>
        </listitem>
      </itemizedlist>

      <note>
        <title>Notes</title>
        <itemizedlist>
          <listitem>
            <para>DROP PACKAGE drops the package body before dropping its header.</para>
          </listitem>
          <listitem>
            <para>The source of package bodies is retained after ALTER/RECREATE PACKAGE.
            The column RDB$PACKAGES.RDB$VALID_BODY_FLAG indicates the state of the package body.
            See Tracker item
            <ulink url="http://tracker.firebirdsql.org/browse/CORE-4487">CORE-4487</ulink>.</para>
          </listitem>
          <listitem>
            <para>UDF declarations (DECLARE EXTERNAL FUNCTION) are currently not supported
            inside packages.</para>
          </listitem>
          <listitem>
            <para>Syntax is available for a description (COMMENT ON) for package procedures and
            functions and their parameters.  See Tracker item
            <ulink url="http://tracker.firebirdsql.org/browse/CORE-4484">CORE-4484</ulink>.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>

    <section><!-- L2 -->
      <title>Simple Packaging Example</title>

      <programlisting>
SET TERM ^;
-- package header, declarations only
CREATE OR ALTER PACKAGE TEST
AS
BEGIN
  PROCEDURE P1(I INT) RETURNS (O INT); -- public procedure
END

-- package body, implementation
RECREATE PACKAGE BODY TEST
AS
BEGIN
  FUNCTION F1(I INT) RETURNS INT; -- private function
  PROCEDURE P1(I INT) RETURNS (O INT)
  AS
  BEGIN
  END
  FUNCTION F1(I INT) RETURNS INT
  AS
  BEGIN
    RETURN 0;
  END
END ^
      </programlisting>

      <note>
        <para>More examples can be found in the Firebird installation,
        in ../examples/package/.</para>
      </note>
    </section><!-- L2 -->
  </section><!-- L1 -->
<!-- DDL TRIGGERS -->
  <section id="rnfb30-psql-ddltriggers"><!-- L1 -->
    <title>DDL triggers</title>
    <author>
      <firstname>A.</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <note>
      <title>Acknowledgement</title>
      <para>This feature was sponsored with donations gathered at the fifth Brazilian
      Firebird Developers' Day, 2008</para>
    </note>
    <para>The purpose of a <quote>DDL trigger</quote> is to enable restrictions to be
    placed on users who attempt to create, alter or drop a DDL object.</para>
    <para><emphasis role="bold">Syntax Pattern</emphasis></para>
      <literallayout class="monospaced">
	&lt;database-trigger&gt; ::=
		{CREATE | RECREATE | CREATE OR ALTER}
			TRIGGER &lt;name&gt;
			[ACTIVE | INACTIVE]
			{BEFORE | AFTER} &lt;ddl event&gt;
			[POSITION &lt;n&gt;]
		AS
		BEGIN
			...
		END

	&lt;ddl event&gt; ::=
		ANY DDL STATEMENT
	  | &lt;ddl event item&gt; [{OR &lt;ddl event item&gt;}...]

	&lt;ddl event item&gt; ::=
          CREATE TABLE
	  | ALTER TABLE
	  | DROP TABLE
	  | CREATE PROCEDURE
	  | ALTER PROCEDURE
	  | DROP PROCEDURE
	  | CREATE FUNCTION
	  | ALTER FUNCTION
	  | DROP FUNCTION
	  | CREATE TRIGGER
	  | ALTER TRIGGER
	  | DROP TRIGGER
	  | CREATE EXCEPTION
	  | ALTER EXCEPTION
	  | DROP EXCEPTION
	  | CREATE VIEW
	  | ALTER VIEW
	  | DROP VIEW
	  | CREATE DOMAIN
	  | ALTER DOMAIN
	  | DROP DOMAIN
	  | CREATE ROLE
	  | ALTER ROLE
	  | DROP ROLE
	  | CREATE SEQUENCE
	  | ALTER SEQUENCE
	  | DROP SEQUENCE
	  | CREATE USER
	  | ALTER USER
	  | DROP USER
	  | CREATE INDEX
	  | ALTER INDEX
	  | DROP INDEX
	  | CREATE COLLATION
	  | DROP COLLATION
	  | ALTER CHARACTER SET
	  | CREATE PACKAGE
	  | ALTER PACKAGE
	  | DROP PACKAGE
	  | CREATE PACKAGE BODY
	  | DROP PACKAGE BODY
      </literallayout>
    

    <para><emphasis role="bold">Semantics</emphasis></para>
      <orderedlist>
        <listitem><!-- 1 -->
          <para>BEFORE triggers are fired before changes to the system tables. AFTER
          triggers are fired after system table changes.</para>
          <important>
            <title>Important Rule</title>
            <para>The event type [BEFORE | AFTER] of a DDL trigger cannot be changed. </para>
          </important>
        </listitem>

        <listitem><!-- 2 -->
          <para>When a DDL statement fires a trigger that raises an exception (BEFORE or AFTER, intentionally 
          or unintentionally) the statement will not be committed.  That is, exceptions can be used to ensure 
          that a DDL operation will fail if the conditions are not precisely as intended.</para>
        </listitem>

        <listitem><!-- 3 -->
          <para>DDL trigger actions are executed only when <emphasis>committing</emphasis> the transaction
          in which the affected DDL command runs.  Never overlook the fact that what is possible to do in
          an AFTER trigger is exactly what is possible to do after a DDL command without autocommit. You
          cannot, for example, create a table in the trigger and use it there.</para>
        </listitem>

        <listitem><!-- 4 -->
          <para>With <quote>CREATE OR ALTER</quote> statements, a trigger is fired one time at the CREATE
          event or the ALTER event, according to the previous existence of the object. With RECREATE
          statements, a trigger is fired for the DROP event if the object exists, and for the
          CREATE event.</para>
        </listitem>

        <listitem><!-- 5 -->
          <para>ALTER and DROP events are generally not fired when the object name does not exist.
          For the exception, see point 6.</para>
        </listitem>

        <listitem><!-- 6 -->
          <para>The exception to rule 5 is that BEFORE ALTER/DROP USER triggers fire even when the user
          name does not exist. This is because, underneath, these commands perform DML on the security
          database and the verification is not done before the command on it is run. This is likely to be
          different with embedded users, so do not write code that depends on this.</para></listitem>

        <listitem><!-- 7 -->
          <para>If some exception is raised after the DDL command starts its execution and before AFTER
	   triggers are fired, AFTER triggers will not be fired.</para>
        </listitem>

        <listitem><!-- 8 -->
          <para>Packaged procedures and triggers do not fire individual <command>{CREATE | ALTER | DROP} {PROCEDURE |
	   FUNCTION}</command> triggers.</para></listitem>

      </orderedlist>
    
    <section><!-- L2 -->
      <title>Permissions</title>
      <para>The following users can create, alter or drop DDL triggers and access the
      <link linkend="rnfb30-psql-utils-notriggers">trigger-related switches</link> in 
      the Firebird utilities:</para>
      <itemizedlist>
        <listitem>
          <para>the database owner</para>
        </listitem>
        <listitem>
          <para>SYSDBA</para>
        </listitem>
        <listitem>
          <para>a user logged in under the RDB$ADMIN role</para>
        </listitem>
        <listitem>
          <para>a user having the ALTER DATABASE <link
          linkend="rnfb30-security-metadataprivs">metadata privilege</link></para>
        </listitem>
      </itemizedlist>
    </section><!-- L2 -->
    
    <section id="rnfb30-psql-utils-notriggers"><!-- L2 -->
      <title>Support in Utilities</title>
      <para>A DDL trigger is a type of database trigger, so the parameters <command>-nodbtriggers</command>
      (GBAK and ISQL) and <command>-T</command> (NBACKUP) apply to them.  Remember that only users 
      with the appropriate metadata privileges can use these switches.</para>
    </section><!-- L2 -->

    <section><!-- L2 -->
      <title>DDL_TRIGGER Context Namespace</title>
      <para>The introduction of DDL triggers brings with it the new <command>DDL_TRIGGER</command> namespace
      for use with RDB$GET_CONTEXT. Its usage is valid only when a DDL trigger is running. Its use is valid
      in stored procedures and functions called by DDL triggers.</para>

      <para>The DDL_TRIGGER context works like a stack. Before a DDL trigger is fired, the
      values relative to the executed command are pushed onto this stack. After the trigger finishes,
      the values are popped. So in the case of cascade DDL statements, when an user DDL command
      fires a DDL trigger and this trigger executes another DDL command with EXECUTE STATEMENT, the values
      of the DDL_TRIGGER namespace are the ones relative to the command that fired the last DDL trigger
      on the call stack.</para>

      <section><!-- L3 -->
        <title>Elements of DDL_TRIGGER Context</title>
        <itemizedlist>
          <listitem>
            <para>EVENT_TYPE: event type (CREATE, ALTER, DROP)</para>
          </listitem>
          <listitem>
            <para>OBJECT_TYPE: object type (TABLE, VIEW, etc)</para>
          </listitem>
          <listitem>
            <para>DDL_EVENT: event name (&lt;ddl event item&gt;), where &lt;ddl_event_item&gt; is EVENT_TYPE || ' ' || OBJECT_TYPE</para>
          </listitem>
          <listitem>
            <para>OBJECT_NAME: metadata object name</para>
          </listitem>
          <listitem>
            <para>OLD_OBJECT_NAME: for tracking the renaming of a domain (see note)</para>
          </listitem>
          <listitem>
            <para>NEW_OBJECT_NAME: for tracking the renaming of a domain (see note)</para>
          </listitem>
          <listitem>
            <para>SQL_TEXT: sql statement text</para>
          </listitem>
        </itemizedlist>
        <note>
          <para>ALTER DOMAIN &lt;<replaceable>old name&gt;</replaceable> TO &lt;<replaceable>new name</replaceable>&gt;
          sets OLD_OBJECT_NAME and NEW_OBJECT_NAME in both BEFORE and AFTER triggers. For this command, OBJECT_NAME will
          have the old object name in BEFORE triggers and the new object name in AFTER triggers.</para>
        </note>

      </section><!-- L3 -->
    </section><!-- l2 -->

    <para><emphasis role="bold">Examples Using DDL Triggers</emphasis></para>
      <para>Here is how you might use a DDL trigger to enforce a consistent naming scheme,
      in this case, stored procedure names should begin with the prefix <quote>SP_</quote>:</para>
      <programlisting>
set auto on;
create exception e_invalid_sp_name 'Invalid SP name (should start with SP_)';

set term !;

create trigger trig_ddl_sp before CREATE PROCEDURE
as
begin
    if (rdb$get_context('DDL_TRIGGER', 'OBJECT_NAME') not starting 'SP_') then
        exception e_invalid_sp_name;
end!

-- Test

create procedure sp_test
as
begin
end!

create procedure test
as
begin
end!

-- The last command raises this exception and procedure TEST is not created
-- Statement failed, SQLSTATE = 42000
-- exception 1
-- -E_INVALID_SP_NAME
-- -Invalid SP name (should start with SP_)
-- -At trigger 'TRIG_DDL_SP' line: 4, col: 5

set term ;!
      </programlisting>

      <para>Implement custom DDL security, in this case restricting the running
      of DDL commands to certain users:</para>
      <programlisting>
create exception e_access_denied 'Access denied';

set term !;

create trigger trig_ddl before any ddl statement
as
begin
    if (current_user &lt;&gt; 'SUPER_USER') then
        exception e_access_denied;
end!

-- Test

create procedure sp_test
as
begin
end!

-- The last command raises this exception and procedure SP_TEST is not created
-- Statement failed, SQLSTATE = 42000
-- exception 1
-- -E_ACCESS_DENIED
-- -Access denied
-- -At trigger 'TRIG_DDL' line: 4, col: 5

set term ;!
      </programlisting>
      <para>Use a trigger to log DDL actions and attempts:</para>
      <programlisting>
create sequence ddl_seq;

create table ddl_log (
    id bigint not null primary key,
    moment timestamp not null,
    user_name varchar(31) not null,
    event_type varchar(25) not null,
    object_type varchar(25) not null,
    ddl_event varchar(25) not null,
    object_name varchar(31) not null,
    sql_text blob sub_type text not null,
    ok char(1) not null
);

set term !;

create trigger trig_ddl_log_before before any ddl statement
as
    declare id type of column ddl_log.id;
begin
    -- We do the changes in an AUTONOMOUS TRANSACTION, so if an exception happens 
    -- and the command didn't run, the log will survive.
    in autonomous transaction do
    begin
        insert into ddl_log (id, moment, user_name, event_type, object_type, 
                             ddl_event, object_name, sql_text, ok)
            values (next value for ddl_seq, current_timestamp, current_user,
                    rdb$get_context('DDL_TRIGGER', 'EVENT_TYPE'),
                    rdb$get_context('DDL_TRIGGER', 'OBJECT_TYPE'),
                    rdb$get_context('DDL_TRIGGER', 'DDL_EVENT'),
                    rdb$get_context('DDL_TRIGGER', 'OBJECT_NAME'),
                    rdb$get_context('DDL_TRIGGER', 'SQL_TEXT'),
                    'N')
            returning id into id;
        rdb$set_context('USER_SESSION', 'trig_ddl_log_id', id);
    end
end!

-- Note: the above trigger will fire for this DDL command. It's good idea to
-- use -nodbtriggers when working with them!
create trigger trig_ddl_log_after after any ddl statement
as
begin
    -- Here we need an AUTONOMOUS TRANSACTION because the original transaction
    -- will not see the record inserted on the BEFORE trigger autonomous
    -- transaction if user transaction is not READ COMMITTED.
    in autonomous transaction do
       update ddl_log set ok = 'Y' 
       where id = rdb$get_context('USER_SESSION', 'trig_ddl_log_id');
end!

commit!

set term ;!

-- Delete the record about trig_ddl_log_after creation.
delete from ddl_log;
commit;

-- Test

-- This will be logged one time 
-- (as T1 did not exist, RECREATE acts as CREATE) with OK = Y.
recreate table t1 (
    n1 integer,
    n2 integer
);

-- This will fail as T1 already exists, so OK will be N.
create table t1 (
    n1 integer,
    n2 integer
);

-- T2 does not exist. There will be no log.
drop table t2;

-- This will be logged twice 
-- (as T1 exists, RECREATE acts as DROP and CREATE) with OK = Y.
recreate table t1 (
    n integer
);

commit;
      </programlisting>
      <literallayout class="monospaced">
select id, ddl_event, object_name, sql_text, ok
          from ddl_log order by id;

                   ID DDL_EVENT                 OBJECT_NAME                      SQL_TEXT OK
===================== ========================= ======================= ================= ======
                    2 CREATE TABLE              T1                                   80:3 Y
======================================================================
SQL_TEXT:
recreate table t1 (
    n1 integer,
    n2 integer
)
======================================================================
                    3 CREATE TABLE              T1                                   80:2 N
======================================================================
SQL_TEXT:
create table t1 (
    n1 integer,
    n2 integer
)
======================================================================
                    4 DROP TABLE                T1                                   80:6 Y
======================================================================
SQL_TEXT:
recreate table t1 (
    n integer
)
======================================================================
                    5 CREATE TABLE              T1                                   80:9 Y
======================================================================
SQL_TEXT:
recreate table t1 (
    n integer
)
======================================================================
      </literallayout>

  </section><!-- L1 -->

<!-- Support for scrollable cursors -->

  <section id="rnfb30-psql-scrollcursors"><!-- L1 -->
    <title>Scrollable (Bi-directional) Cursor Support</title>
    <author><firstname>Dmitry</firstname><surname>Yemanov</surname></author>
    <para>Instead of just fetching rows sequentially in a forward direction,
    <quote>scrollability</quote> allows flexible navigation through an open cursor 
    set both backwards and forwards.  Rows next to, prior to and relative to the
    current cursor row can be targetted.  In PSQL, a scrollable cursor can be operated 
    on directly.  API support is available to enable DSQL applications to fetch rows in
    a similar manner.</para>

    <section id="rnfb30-psql-cursorrules"><!-- L2 -->
      <title>Cursor Syntax for PSQL</title>
      <para>To declare a cursor:</para>
      <programlisting>
DECLARE &lt;name&gt; SCROLL CURSOR FOR ( &lt;select expression&gt; )
      </programlisting>

      <para>To fetch forward:</para>
      <programlisting>
FETCH &lt;cursor name&gt; [INTO &lt;var name&gt; [, &lt;var name&gt; ...]];
      </programlisting>

      <para>To fetch in any direction:</para>
      <programlisting>
FETCH {NEXT | PRIOR | FIRST | LAST | ABSOLUTE &lt;n&gt; | RELATIVE &lt;n&gt;}
  FROM &lt;cursor name&gt; [INTO &lt;var name&gt; [, &lt;var name&gt; ...]];
      </programlisting>

       <para>See also <link linkend="rnfb30-dsql-scrollcursors">Scrollable Cursor Support 
       for DSQL</link>
       in the chapter entitled <citation>Changes to the Firebird API and ODS</citation>. 
       The section entitled <link linkend="rnfb30-dsql-cursoruse">Scrollable Cursor Usage</link> 
       explains a little more about the usage of the various FETCH options.</para>
     </section>
     <note>
       <title>Notes</title>
       <orderedlist>
         <listitem>
           <para>When a scrolling option is omitted, NO SCROLL is implied (i.e., the cursor is opened 
           as forward-only). This means that only FETCH [NEXT FROM] commands can be used.
           Other commands will return an error.</para>
         </listitem>
         <listitem>
           <para>Scrollable cursors are internally materialized as a temporary record set, thus consuming
           memory/disk resources, so this feature should be used only when really necessary.</para>
         </listitem>
       </orderedlist>
     </note>
  </section>

<!-- EXCEPTIONS WITH PARAMETERS -->

  <section id="rnfb30-psql-exceptparams"><!-- L1 -->
    <title>Exceptions with parameters</title>
    <author>
      <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <para>An exception can now be defined with a message containing slots for parameters
    which are filled and passed when raising the exception, using the syntax
    pattern
      <literallayout class="monospaced">
  EXCEPTION &lt;name&gt; USING ( &lt;value list&gt; )
      </literallayout>
    </para>
    <para><emphasis role="bold">Examples</emphasis></para>
    <literallayout class="monospaced">
  create exception e_invalid_val 'Invalid value @1 for the field @2';
    </literallayout>
    <programlisting>
...
if (val &lt; 1000) then
   thing = val;
else
   exception e_invalid_val using (val, 'thing');
end
    </programlisting>

    <literallayout class="monospaced">
CREATE EXCEPTION EX_BAD_SP_NAME
'Name of procedures must start with ''@1'' : ''@2''';
    </literallayout>
    <programlisting>
CREATE TRIGGER TRG_SP_CREATE BEFORE CREATE PROCEDURE
AS
DECLARE SP_NAME VARCHAR(255);
BEGIN
  SP_NAME = RDB$GET_CONTEXT('DDL_TRIGGER', 'OBJECT_NAME');

  IF (SP_NAME NOT STARTING 'SP_')
  THEN EXCEPTION EX_BAD_SP_NAME USING ('SP_', SP_NAME);
END;
    </programlisting>

    <note>
      <title>Notes</title>
      <para>The status vector is generated using this code combination:
      isc_except, &lt;exception&nbsp;number&gt;,
      isc_formatted_exception, &lt;formatted&nbsp;exception&nbsp;message&gt;,
      &lt;exception&nbsp;parameters&gt;</para>
      <para>Since a new error code (isc_formatted_exception) is used, the client
      must be v.3.0, or at least use the <filename>firebird.msg</filename> file
      from v.3.0, in order to translate the status vector to a string.</para>
      <para>Considering, in left-to-right order, each parameter passed in the exception-raising
      statement as <quote>the Nth</quote>, with N starting at 1:
        <itemizedlist>
          <listitem>
            <para>If an Nth parameter is not passed, the text is not substituted.</para>
          </listitem>
          <listitem>
            <para>If NULL is passed, it is replaced by the string '*** null ***'.</para>
          </listitem>
          <listitem>
            <para>If more parameters are passed than are defined in the exception message,
            the surplus ones are ignored.</para>
          </listitem>
          <listitem>
            <para>The total length of the message, including the values of the parameters,
            is still limited to 1053 bytes.</para>
          </listitem>
        </itemizedlist>
      </para>
    </note>
  </section><!-- L1 -->

<!-- CONTINUE IN LOOPS -->
  <section id="rnfb30-psql-continue"><!-- L1 -->
    <title>CONTINUE in Looping Logic</title>
    <author>
      <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <para>CONTINUE is a complementary command to BREAK/LEAVE, allowing flow of control
    to break (leave) and start of the next iteration of a FOR/WHILE loop.</para>
    <para><emphasis role="bold">Syntax</emphasis></para>
      <literallayout class="monospaced">
  CONTINUE [&lt;label&gt;];
      </literallayout>

    <para><emphasis role="bold">Example</emphasis></para>
      <programlisting>
FOR SELECT A, D FROM ATABLE INTO :achar, :ddate
  DO BEGIN
    IF (ddate &lt; current_data - 30) THEN
      CONTINUE;
    ELSE
      /* do stuff */
    ...
  END
      </programlisting>

  </section><!-- L1 -->

<!-- CURSOR STABILITY -->
  <section id="rnfb30-psql-cursor-stablility"><!-- L1 -->
    <title>PSQL Cursor Stabilization</title>
    <author>
      <firstname>Vlad</firstname><surname>Khorsun</surname>
    </author>
    <para>PSQL cursors without SUSPEND inside are now stable:</para>
    <programlisting>
FOR SELECT ID FROM T WHERE VAL IS NULL INTO :ID
  DO BEGIN
    UPDATE T SET VAL = 1
     WHERE ID = :ID;
  END
    </programlisting>
    <para>Previously, this block would loop interminably.  Now, the loop
    will not select the value if it was set within the loop.</para>
    <note>
      <para>This could change the behaviour of legacy code.</para>
    </note>
    <para>If there is a SUSPEND inside the block, the old instability
    remains: this query, for example, still produces the infinite loop:</para>
    <programlisting>
FOR SELECT ID FROM T INTO :ID
  DO BEGIN
    INSERT INTO T (ID) VALUES (:ID);
    SUSPEND;
  END
    </programlisting>
  </section><!-- L1 -->

  <section id="rnfb30-psql-colonusage"><!-- L1 -->
    <title>Extension of Colon Prefix Usage</title>
    <author>
      <firstname>Adriano</firstname><surname>dos Santos Fernandes</surname>
    </author>
    <para>Hitherto, the colon (:) prefix has been used in PSQL to mark a
    reference to a variable in DML statements.  Its use has been extended
    in Firebird 3 for two unrelated purposes:</para>
    <orderedlist>
      <listitem>
        <para>to allow OLD/NEW fields in cursors to be read or assigned to
        and to assign them to variables.</para>
      </listitem>
      <listitem>
        <para>to make variable assignment in both DML and PSQL statements in
        modules and blocks more flexible and, where needed, to resolve
        ambiguity between field names and variable names</para>
      </listitem>
    </orderedlist>

<!-- PSQL Cursors as Variables -->
    <section id="rnfb30-psql-cursor-asvariable"><!-- L2 -->
      <title>PSQL Cursors as Variables</title>
      <para>Referencing cursors as record variables is now supported in PSQL.  Either
      explicit (DECLARE AS CURSOR) or implicit (FOR SELECT) PSQL cursors make their
      current record available via the cursor name, thus making the INTO clause
      optional.</para>
      <para>In FOR SELECT loops, it requires the AS CURSOR clause to be specified. For example:</para>
      <programlisting>
execute block as
begin
  for
    select id, x from t1 as cursor c1
  do begin
    for select id, x from t2 where x = :c1.x as cursor c2 do
    begin
          /* . . . */
    end
  end
end
      </programlisting>
      <note>
        <para>Notice the extension of the use of a colon (:) as a prefix to the
        referenced cursor field.</para>
      </note>
      <para><emphasis role="bold">Another example</emphasis></para>
      <programlisting>
for
  select rdb$relation_id as id, rdb$relation_name as name
  from rdb$relations
  where rdb$view_blr is null
  as cursor tables
do begin
  out_id = tables.id;
  out_name = tables.name;
  suspend;
end
      </programlisting>
      <para>To avoid ambiguity, the colon prefix could be used:</para>
      <literallayout class="monospaced">
  out_id = :tables.id;
  out_name = :tables.name;
/* or */
  :out_id = :tables.id;
  :out_name = :tables.name;
      </literallayout>
      <para><quote>tables</quote> here is a cursor name and acts similarly
      to OLD/NEW in triggers.</para>
    </section><!-- L2 -->

<!-- Colon prefix for variables -->
    <section id="rnfb30-psql-assign-variable"><!-- L2 -->
      <title>Colon Prefix as a Variable Marker</title>
      <para>It is now valid to apply the colon prefix to a variable on either
      side of an assignment statement in PSQL-only constructs.</para>
      <para>Previously, these were valid assignments:</para>
      <literallayout class="monospaced">
  var1 = :var2;
/* or */
  new.fld = :var;
      </literallayout>
      <para>whereas, these were invalid:</para>
      <literallayout class="monospaced">
  :var1 = :var2;
/* or */
  :new.fld = :var;
      </literallayout>
      <para>The extension (<ulink url="http://tracker.firebirdsql.org/browse/CORE-4434">CORE-4434</ulink>)
      fixes this inconsistency.</para>

      <para>This is now valid syntax:</para>
      <programlisting>
create trigger t1 before insert on t1
as
  declare v integer;
begin
  :v = :old.n;
  :new.n = :v;
end
      </programlisting>

      <para>In fact, using this example, there is no difference between</para>
      <literallayout class="monospaced">
 :v = :old.n;
/* and */
  v = :old.n;
      </literallayout>
      <para>Here, it is just <quote>syntactic sugar</quote> but, in other cases,
      it provides the means to resolve ambiguity between field name references and
      variable names.</para>
      <para><emphasis role="bold">Example of possible ambiguity</emphasis></para>
      <programlisting>
for
  select rdb$relation_id as id, rdb$relation_name as name
  from rdb$relations
  where rdb$view_blr is null
  as cursor tables
do begin
  out_id = :table.id;
  select tables.name from tables where tables.id = :tables.id into :out_name;
  suspend;
end
      </programlisting>
      <para>Inside the nested SELECT, <quote>tables</quote> is both a table name 
      and a cursor name here, so the colon is used to resolve the ambiguity.</para>
    </section><!-- L2 -->
  </section><!-- L1 -->

<!-- SQLSTATE IN WHEN HANDLER -->
  <section id="rnfb30-psql-whensqlstate"><!-- L1 -->
    <title>SQLSTATE in Exception Handlers</title>
    <author>
      <firstname>Dmitry</firstname><surname>Yemanov</surname>
    </author>
    <para>An SQLSTATE code becomes a valid condition for trapping an exception with a WHEN 
    statement.  In alignment with SQLCODE and GDSCODE, the SQLSTATE code can be used 
    as in the following snippet:
      <programlisting>
...
WHEN SQLSTATE '22006' DO
BEGIN
  -- do something
END
...
      </programlisting>
    </para>
    <note>
      <para>SQLSTATE codes are string literals.</para>
    </note>
  </section><!-- L1 -->
  
<!-- EXECUTE BLOCK RUNTIME ERRORS -->
  <section id="rnfb30-psql-execute-block-errors"><!-- L1 -->
    <title>EXECUTE BLOCK Run-time Errors</title>
     <para>From v.3.0.1, line and column numbers (location context) are now provided for 
     run-time errors raised inside EXECUTE BLOCK.</para>
   </section>

<!-- REMOVAL OF SOME SIZE LIMITS -->
  <section id="rnfb30-psql-limitsoff"><!-- L1 -->
    <title>PSQL Body Size Limit Raised</title>
     <para>If and only if the new API is being used, the size of the body of a stored procedure or
    a trigger can exceed the traditional limit of 32 KB. Currently, as a security measure, a hard-coded limit
    of 10MB is imposed, although the theoretical limit is 4GB. The traditional size of all input or output
    parameters no longer limited to the traditional size of (64KB minus overhead), either.</para>
    <para>For details, see <link linkend="rnfb30-apiods-sqlsize">Some SQL Size Limits Removed Using New 
    API</link> in the API chapter.</para>
  </section><!-- L1 -->

</chapter>