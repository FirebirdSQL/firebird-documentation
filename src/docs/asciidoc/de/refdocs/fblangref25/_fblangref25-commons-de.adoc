[[fblangref25-commons-de]]
= Allgemeine Sprachelemente

Dieser Abschnitt behandelt die Elemente, die in der SQL-Sprache als allgemeingültig betrachtet werden können -- die _Ausdrücke_, die verwendet werden um Fakten aus Daten zu extrahieren, diese zu verarbeiten und die _Prädikate_, die den Wahrheitswert dieser Fakten prüfen.

[[fblangref25-commons-expressions-de]]
== Ausdrücke

SQL-Ausdrücke bieten formelle Methoden zum Auswerten, Transformieren und Vergleichen von Werten.
SQL-Ausdrücke können Tabellenspalten, Variablen, Konstanten, Literale, andere Statements und Prädikate sowie andere Ausdrücke enthalten.
Folgend die vollständige Liste möglicher Elemente.

[[fblangref25-dtyp-tbl-exprelements-de]]
.Beschreibung der Ausdruck-Elemente
Spaltenname::
Kennung einer Spalte aus einer angegebenen Tabelle, die in Auswertungen oder als Suchbedingung verwendet wird.
Eine Spalte des Array-Typs kann kein Element innerhalb eines Ausdrucks sein, es sei denn sie wird mit dem ``IS [NOT] NULL``-Prädikat verwendet.

Array-Element::
Ein Ausdruck kann einen Verweis auf ein Array-Element enthalten.

Arithmetische Operatoren::
Die Zeichen `+`, `-`, `*`, `/` werden verwendet um Berechnungen durchzuführen.

Verkettungsoperator::
Der Operator `||` ("`Doppel-Pipe`") wird verwendet um Strings zu verketten.

Logische Operatoren::
Die reservierten Wörter `NOT`, `AND` sowie `OR` werden verwendet um einfache Suchbedingungen oder komplexere Behauptungen zu erstellen.

Vergleichsoperatoren::
Die Zeichen `=`, `<>`, `!=`, `~=`, `^=`, `<`, `<=`, `>`, `>=`, `!<`, `~<`, `^<`, `!>`, `~>` und `^>`

Vergleichsprädikate::
`LIKE`, `STARTING WITH`, `CONTAINING`, `SIMILAR TO`, `BETWEEN`, `IS [NOT] NULL` und `IS [NOT] DISTINCT FROM`

Existenzprädikate::
Prädikate, die für die Existenzprüfung von Werten Verwendung finden.
Das Prädikat `IN` kann sowohl innerhalb von Listen kommagetrennter Konstanten als auch mit Unterabfragen, die nur eine Spalte zurückgeben, verwendet werden.
Die Prädikate `EXISTS`, `SINGULAR`, `ALL`, `ANY` und `SOME` können nur mit Unterabfragen verwendet werden.

Konstanten::
Eine Zahl;
oder eine Zeichenkette, die in Apostrophs eingeschlossen wird.

Datum-/Zeitliterale::
Ein Ausdruck, ähnlich zu Zeichenketten, eingeschlossen in Apostrophs, der als Datum, Zeit oder Zeitstempel interpretiert wird.
Datumsliterale können vordefinierte Literale ('TODAY', 'NOW', etc.) oder Zeichenketten aus Buchstaben oder Zahlen sein, wie zum Beispiel '25.12.2016 15:30:35', die zu einem Datum und/oder einer Zeit aufgelöst werden können.

Kontextvariablen::
Eine intern definierte Kontextvariable

Lokale Variablen::
Deklarierte lokale Variablen, Über- und Rückgabeparameter eines PSQL-Moduls (Stored Procedure, Trigger, unbenannter PSQL-Block in DSQL)

Positionale Parameter::
Ein Mitglied innerhalb einer geordneten Gruppe von einem oder mehreren unbenannten Parametern, die an eine gespeicherte Prozedur oder eine vorbereitete Abfrage übergeben wurden.

Unterabfrage::
Eine ``SELECT``-Anweisung, die in Klammern eingeschlossen ist, die einen einzelnen (skalaren) Wert zurückgibt oder, wenn er in existenziellen Prädikaten verwendet wird, einen Satz von Werten.

Funktionskennung::
Die Kennung einer internen oder externen Funktion in einem Funktionsausdruck

Type-Cast::
Ein Ausdruck, der explizit Daten von einem in einen anderen Datentyp unter Verwendung der ``CAST``-Funktion (`CAST (<value> AS <datatype>)`) konvertiert.
Nur für Datum-/Zeit-Literale ist die Kurzschreibweise <datatype> <value> (`DATE '25.12.2016'`) möglich.

Bedingter Ausdruck::
Ausdrücke mit `CASE` und verwandten internen Funktionen

Klammern::
Klammernpaare `(...)` werden verwendet, um Ausdrücke zu gruppieren.
Operationen innerhalb der Klammern werden vor Operationen außerhalb von ihnen durchgeführt.
Wenn eingebettete Klammern verwendet werden, werden die tiefsten eingebetteten Ausdrücke zuerst ausgewertet und dann bewegen sich die Auswertungen von innen nach außen durch die Einbettungsstufen.

``COLLATE``-Klausel::
Klausel, die für ``CHAR``- und ``VARCHAR``-Datentypen angewendet werden kann, um die Collation für String-Vergleiche festzulegen.

`NEXT VALUE FOR __Sequenz__`::
Ausdruck zum Ermitteln des nächsten Wertes eines bestimmten Generators (Sequenz).
Die interne Funktion `GEN_ID()` tut das Gleiche.

[[fblangref25-commons-constants-de]]
=== Konstanten

Eine Konstante ist ein Wert der direkt in einem SQL-Statement verwendet wird und weder von einem Ausdruck, einem Parameter, einem Spaltenverweis noch einer Variablen abgeleitet wird.
Dies kann eine Zeichenkette oder eine Zahl sein.

[[fblangref25-commons-string-constant-de]]
==== Zeichenkonstanten (Literale)

Eine String-Konstante ist eine Aneinanderreihung von Zeichen, die zwischen einem Paar von Apostrophen ("`einfache Anführungszeichen`") eingeschlossen werden.
Die größtmögliche Länge dieser Zeichenketten ist 32.767 Bytes;
die maximale Anzahl der Zeichen wird durch die verwendete Zeichenkodierung bestimmt.

[NOTE]
====
* Doppelte Anführungszeichen _dürfen nicht_ für die Kennzeichnung von Zeichenketten verwendet werden.
SQL sieht hierfür einen anderen Zweck vor.
* Wird ein Apostroph innerhalb der Zeichenkette benötigt, wird dieses durch ein vorangehendes Apostroph "`escaped`". Zum Beispiel `'Mother O''Reilly's home-made hooch'`.
* Vorsicht ist geboten bei String-Längen, wenn der Wert in ein Feld des Typs `VARCHAR` geschrieben wird.
Hierfür gilt die maximale Länge von 32.765 Bytes.
====

Es wird angenommen, dass der Zeichensatz einer Zeichenkonstanten der gleiche ist wie der Zeichensatz seines Bestimmungsspeichers.

[[fblangref25-commons-hexstrings-de]]
===== Stringkonstanten in Hexadezimalnotation

Ab Firebird 2.5 aufwärts, können Stringliterale in hexadezimaler Schreibweise eingegeben werden, die sogenannten "`Binary Strings`".
Jedes Paar hexadezimaler Stellen definiert ein Byte der Zeichenkette.
Zeichenketten die in dieser Form eingegeben werden, besitzen den Zeichensatz `OCTETS` als Standard.
Die <<fblangref25-commons-introducer-syntax-de,[term]_Introducer-Syntax_>> kann auch genutzt werden um zu erzwingen, dass die Zeichenkette als ein anderer Zeichensatz interpretiert wird.

.Syntax
[listing,subs=+quotes]
----
{x|X}'<hexstring>'

<hexstring> ::= _eine gerade Anzahl von <hexdigit>_
<hexdigit>  ::= _eines aus 0..9, A..F, a..f_
----

.Beispiele
[source]
----
select x'4E657276656E' from rdb$database
-- liefert 4E657276656E, a 6-byte 'binary' string

select _ascii x'4E657276656E' from rdb$database
-- liefert 'Nerven' (same string, now interpreted as ASCII text)

select _iso8859_1 x'53E46765' from rdb$database
-- liefert 'Säge' (4 chars, 4 bytes)

select _utf8 x'53C3A46765' from rdb$database
-- liefert 'Säge' (4 chars, 5 bytes)
----

.Hinweise
[NOTE]
====
Die Client-Schnittstelle legt fest, wie Binärzeichenfolgen dem Benutzer angezeigt werden.
Das __isql__-Werkzeug beispielsweise, nutzt großgeschriebene Buchstaben A-F, während FlameRobin Kleinschreibung verwendet.
Andere Client-Applikationen könnten andere Konventionen bevorzugen, zum Beispiel Leerzeichen zwischen den Bytepaaren: '4E 65 72 76 65 6E'.

Mit der hexadezimalen Notation kann jeder Bytewert (einschließlich 00) an beliebiger Stelle im String eingefügt werden.
Allerdings, wenn Sie diesen auf etwas anderes als OCTETS erzwingen wollen, liegt es in Ihrer Verantwortung, die Bytes in einer Sequenz  zu liefern, die für den Zielzeichensatz gültig ist.
====

[[fblangref25-commons-introducer-syntax-de]]
===== Introducer-Syntax für String-Literale

Bei Bedarf kann ein String-Literal einem Zeichensatznamen vorangestellt werden, dem ein Unterstrich "`++_++`" vorangestellt ist.
Dies wird als [term]_Introducer-Syntax_ bezeichnet.
Sein Ziel ist es, die Engine darüber zu informieren, wie man den eingehenden String interpretiert und speichert.

Beispiel 
[source]
----
INSERT INTO People
VALUES (_ISO8859_1 'Hans-Jörg Schäfer')
----

[[fblangref25-commons-number-constant-de]]
==== Zahlenkonstanten

Eine Zahlkonstante ist eine gültige Zahl in einer unterstützten Notation: 

* In SQL wird der Dezimalpunkt, für Zahlen in der Standard-Dezimal-Notation, immer durch das Punkt-Zeichen dargestellt.
Tausender werden nicht getrennt.
Einbeziehung von Komma, Leerzeichen usw. führt zu Fehlern.
* Exponentielle Notation wird unterstützt.
Zum Beispiel kann 0.0000234 auch als `2.34e-5` geschrieben werden.
* Hexadezimal-Notation wird von Firebird 2.5 und höheren Versionen unterstützt -- siehe unten.

[[fblangref25-commons-hexnumbers-de]]
===== Hexadezimale Notation für Ziffern

Von Firebird 2.5 aufwärts können ganzzahlige Werte in hexadezimaler Notation eingegeben werden.
Zahlen mit 1-8 Hex-Ziffern werden als Typ `INTEGER` interpretiert;
Zahlen mit 9-16 Hex-Ziffern als Typ `BIGINT`.

.Syntax
[listing,subs=+quotes]
----
0{x|X}<hexdigits>

<hexdigits> ::= _1-16 als <hexdigit>_
<hexdigit>  ::= _eins aus 0..9, A..F, a..f_
----

.Beispiele
[source]
----
select 0x6FAA0D3 from rdb$database          -- liefert 117088467
select 0x4F9 from rdb$database              -- liefert 1273
select 0x6E44F9A8 from rdb$database         -- liefert 1850014120
select 0x9E44F9A8 from rdb$database         -- liefert -1639646808 (an INTEGER)
select 0x09E44F9A8 from rdb$database        -- liefert 2655320488 (a BIGINT)
select 0x28ED678A4C987 from rdb$database    -- liefert 720001751632263
select 0xFFFFFFFFFFFFFFFF from rdb$database -- liefert -1
----

[[fblangref25-commons-hexranges-de]]
====== Hexadezimale Wertebereiche

* Hex-Nummern im Bereich 0 .. 7FFF FFFF sind positive `INTEGER` mit Dezimalwerten zwischen 0 .. 2147483647.
Um eine Zahl als `BIGINT` zu erzwingen, müssen Sie genügend Nullen voranstellen, um die Gesamtzahl der Hex-Ziffern auf neun oder mehr zu bringen.
Das ändert den Typ, aber nicht den Wert.
* Hex-Nummern zwischen 8000 0000 .. FFFF FFFF erfordern etwas Aufmerksamkeit: 
+
--
** Bei der Eingabe mit acht Hex-Ziffern, wie in 0x9E44F9A8, wird ein Wert als 32-Bit-``INTEGER`` interpretiert.
Da das erste Bit (Vorzeichenbit) gesetzt ist, wird es dem negativen Dezimalbereich -2147483648 .. -1 zugeordnet.
** Bei einer oder mehreren Nullen, die wie in 0x09E44F9A8 vorangestellt werden, wird ein Wert als 64-Bit-``BIGINT`` im Bereich  0000 0000 8000 0000 .. 0000 0000 FFFF FFFF interpretiert.
Das Zeichen-Bit ist jetzt nicht gesetzt, also wird der Dezimalwert dem positiven Bereich 2147483648 .. 4294967295 zugewiesen.
--
+
So ergibt sich in diesem Bereich -- und nur in diesem Bereich -- anhand einer mathematisch  unbedeutenden 0 ein gänzlich anderer Wert.
Dies ist zu beachten. 
* Hex-Zahlen zwischen 1 0000 0000 .. 7FFF FFFF FFFF FFFF sind alle positiv `BIGINT`.
* Hex-Zahlen zwischen 8000 0000 0000 0000 .. FFFF FFFF FFFF FFFF sind alle negativ `BIGINT`.
* Ein `SMALLINT` kann nicht in Hex geschrieben werden, streng genommen zumindest, da sogar 0x1 als `INTEGER` ausgewertet wird.
Wenn Sie jedoch eine positive Ganzzahl innerhalb des 16-Bit-Bereichs 0x0000 (Dezimal-Null) bis 0x7FFF (Dezimalzahl 32767) schreiben, wird sie transparent in `SMALLINT` umgewandelt.
+ 
Es ist möglich einen negativen `SMALLINT` in Hex zu schreiben, wobei eine 4-Byte-Hexadezimalzahl im Bereich 0xFFFF8000 (Dezimal -32768) bis 0xFFFFFFFF (Dezimal -1) verwendet wird.

[[fblangref25-commons-sqloperators-de]]
=== SQL-Operatoren

SQL-Operatoren umfassen Operatoren zum Vergleichen, Berechnen, Auswerten und Verknüpfen von Werten.

[[fblangref25-commons-operpreced-de]]
==== Vorrang der Operatoren

SQL Operatoren sind in vier Typen unterteilt.
Jeder Operator-Typ hat eine _Priorität_, eine Rangfolge, die die Reihenfolge bestimmt, in der die Operatoren und die mit ihrer Hilfe erhaltenen Werte in einem Ausdruck ausgewertet werden.
Je höher der Vorrang des Operator-Typs ist, desto früher wird er ausgewertet.
Jeder Operator hat seine eigene Priorität innerhalb seines Typs, der die Reihenfolge bestimmt, in der sie in einem Ausdruck ausgewertet werden.

Operatoren der gleichen Rangfolge werden von links nach rechts ausgewertet.
Um dieses Verhalten zu beeinflussen, können Gruppen mittels Klammern erstellt werden.

[[fblangref25-dtyp-tbl-operpreced-de]]
.Vorrang der Operatortypen
[cols="<1,<1,<3", options="header",stripes="none"]
|===
^| Operatortyp
^| Vorrang
^| Erläuterung

|Verkettung
|1
|Strings werden verkettet, bevor andere Operationen stattfinden

|Arithmetik
|2
|Arithmetische Operationen werden durchgeführt, nachdem Strings verkettet sind, aber vor Vergleichs- und logischen Operationen

|Vergleiche
|3
|Vergleichsoperationen erfolgen nach String-Verkettung und arithmetischen Operationen, aber vor logischen Operationen

|Logical
|4
|Logische Operatoren werden nach allen anderen Operatortypen ausgeführt
|===

[[fblangref25-commons-concat-de]]
===== Verkettungsoperator

Der Verkettungsoperator, zwei Pipe-Zeichen, auch "`Doppel-Pipe`" -- '```||```' -- verkettet (verbindet) zwei Zeichenketten zu einer einzigen Zeichenkette.
Zeichenketten können dabei Konstante Werte oder abgeleitet von einer Spalte oder einem Ausdruck sein.

.Beispiel
[source]
----
SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
FROM EMPLOYEE
----

[[fblangref25-commons-arith-de]]
===== Arithmetische Operatoren

[[fblangref25-dtyp-tbl-arithpreced-de]]
.Vorrang arithmetischer Operatoren
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Operator
^| Zweick
^| Vorrang

|`{plus}Zahl mit Vorzeichen`
|unäres Plus
|1

|`-Zahl mit Vorzeichen`
|unäres Minus
|1

|`{asterisk}`
|Multiplikation
|2

|`/`
|Division
|2

|`{plus}`
|Addition
|3

|`-`
|Subtraktion
|3
|===

.Beispiel
[source]
----
UPDATE T
  SET A = 4 + 1/(B-C)*D
----

[NOTE]
====
Wenn Operatoren den gleichen Vorrang besitzen, werden diese von links nach rechts ausgewertet.
====

[[fblangref25-commons-compar-de]]
===== Vergleichsoperatoren

[[fblangref25-dtyp-tbl-comparpreced-de]]
.Prioritäten der Vergleichsoperatoren
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Operator
^| Zweck
^| Priorität

|`=`
|Ist gleich, ist identisch mit
|1

|`<>`, `!=`, `~=`, `^=`
|Ist ungleich zu
|1

|`>`
|Ist größer als
|1

|`<`
|Ist kleiner als
|1

|`>=`
|Ist größer oder gleich als
|1

|`<=`
|Ist kleiner oder gleich als
|1

|`!>`, `~>`, `^>`
|Ist nicht gößer als
|1

|`!<`, `~<`, `^<`
|Ist nicht kleiner als
|1
|===

Diese Gruppe enthält außerdem die Vergleichsprädikate `BETWEEN`, `LIKE`, `CONTAINING`, `SIMILAR TO`, `IS` und andere.

.Beispiel
[source]
----
IF (SALARY > 1400) THEN
…
----

.See also
<<fblangref25-commons-othercomppreds-de,Andere Vergleichsprädikate>>.

[[fblangref25-commons-logical-de]]
===== Logische Operatoren

[[fblangref25-dtyp-tbl-logical-de]]
.Prioritäten logischer Operatoren
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Operator
^| Zweck
^| Priorität

|`NOT`
|Negierung eines Suchkriteriums
|1

|`AND`
|Kombiniert zwei oder mehr Prädikate, wobei jedes als wahr angesehen werden muss, damit der Gesamtausdruck ebenfalls als wahr aufgelöst wird
|2

|`OR`
|Kombiniert zwei oder mehr Prädikate, wobei mindestens eines als wahr angesehen werden muss, damit der Gesamtausdruck ebenfalls als wahr aufgelöst wird
|3
|===

.Beispiel
[source]
----
IF (A < B OR (A > C AND A > D) AND NOT (C = D)) THEN …
----

[[fblangref25-commons-conditional-nxtvlufor-de]]
==== `NEXT VALUE FOR`

.Verfügbar
DSQL, PSQL

`NEXT VALUE FOR` gibt den nächsten Wert einer Sequenz zurück.
`SEQUENCE` ist ein SQL-konformer Begriff für Generatoren in Firebird und dessen Vorgänger, InterBase.
Der Operator `NEXT VALUE FOR` ist equivalent zur ursprünglichen Funktion `GEN_ID (..., 1)` und ist die empfohlene Syntax zum Holen des nächsten Wertes.

.Syntax für NEXT VALUE FOR
[listing,subs=+quotes]
----
NEXT VALUE FOR _Sequenzname_
----

.Beispiel
[source]
----
NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
----

[NOTE]
====
Anders als `GEN_ID (..., 1)` verwendet `NEXT VALUE FOR` keine Parameter, wodurch es nicht möglich ist den _aktuellen Wert_ einer Sequenz zu ermitteln sowie eine andere Schrittweite als 1 zu nutzen.
`GEN_ID (..., <step value>)` wird noch immer für diesen Zweck verwendet.
Eine _Schrittweite_ von 0 gibt den aktuellen Sequenzwert zurück.
====

.Siehe auch
<<fblangref25-ddl-sequence-de,SEQUENCE (GENERATOR)>>, <<fblangref25-functions-scalarfuncs-gen-id-de,`GEN_ID()`>>

[[fblangref25-commons-conditional-de]]
=== Bedingte Ausdrücke

Ein bedingter Ausdruck ist einer der verschiedene Werte zurückgibt, je nach verwendeter Bedingung.
Es besteht aus einem bedingten Funktionskonstrukt, wovon Firebird mehrere unterstützt.
Dieser Abschnitt beschreibt nur ein bedingtes Ausdruckskonstrukt: `CASE`.
Alle anderen bedingten Ausdrücke sind interne Funktionen und leiten sich von `CASE` ab und werden in  <<fblangref25-functions-conditional-de,Bedingte Funktionen>> beschrieben.

[[fblangref25-commons-conditional-case-de]]
==== `CASE`

.Verfügbar
DSQL, PSQL

Das ``CASE``-Konstrukt gibt einen einzigen Wert aus einer Reihe von Werten zurück.
Zwei syntaktische Varianten werden unterstützt: 

* Das _einfache_{nbsp}``CASE``, vergleichbar zu einem [term]_CASE-Konstrukt_ in Pascal oder einem [term]_Switch_ in C
* Das _gesuchte_{nbsp}``CASE``, welches wie eine Reihe aus "```if ... else if ... else if```"-Klauseln funktioniert.

[[fblangref25-commons-conditional-case-simple-de]]
===== Einfaches `CASE`

.Syntax
[listing]
----
…
CASE <test-expr>
  WHEN <expr> THEN <result>
  [WHEN <expr> THEN <result> ...]
  [ELSE <defaultresult>]
END
…
----

Wenn diese Variante verwendet wird, wird _test-expr_ mit _expr_ 1, _expr_ 2 etc. verglichen, bis ein Treffer gefunden und das passende Ergebnis zurückgegeben wird.
Wenn kein passender Treffer vorhanden ist, wird _defaultresult_ aus der optionalen ``ELSE``-Klausel zurückgegeben,  andernfalls `NULL`.

Der Trefferwahl funktioniert identisch zum '```=```'-Operator.
Daher gilt, wenn _test-expr_ gleich `NULL` ist, wird kein Treffer für _expr_ ermittelt, nicht einmal wenn dieser zu `NULL` aufgelöst wird.

Das zurückgegebene Ergebnis muss kein literaler Wert sein: Es kann ein Feld oder ein Variablenname, ein Ausdruck oder ``NULL``-Literal sein.

.Beispiel
[source]
----
SELECT
  NAME,
  AGE,
  CASE UPPER(SEX)
    WHEN 'M' THEN 'Male'
    WHEN 'F' THEN 'Female'
    ELSE 'Unknown'
  END GENDER,
RELIGION
  FROM PEOPLE
----

Eine Kurzform des einfachen ``CASE``-Konstrukts wird auch in der <<fblangref25-functions-scalarfuncs-decode-de,`DECODE`>>  -Funktion verwendet.

[[fblangref25-commons-conditional-case-srched-de]]
===== Gesuchtes `CASE`

.Syntax
[listing]
----
CASE
  WHEN <bool_expr> THEN <result>
  [WHEN <bool_expr> THEN <result> …]
  [ELSE <defaultresult>]
END
----

Der __bool_expr__-Ausdruck gibt ein ternäres logisches Ergebnis zurück: `TRUE`, `FALSE` oder `NULL`.
Der erste Ausdruck, der `TRUE` ermittelt, wird als Ergebnis verwendet.
Gibt kein Ausdruck `TRUE` zurück, kommt _defaultresult_ aus der optionalen ``ELSE``-Klausel zum Einsatz.
Gibt kein Ausdruck `TRUE` zurück und gibt es keine ``ELSE``-Klausel, ist der Rückgabewert `NULL`.

So wie im einfachen ``CASE``-Konstrukt, muss das Ergebnis nicht zwangsläufig ein Literal sein: es kann ein Feld- oder Variablenname, ein zusammengesetzter Ausdruck oder `NULL` sein.

.Beispiel
[source]
----
CANVOTE = CASE
  WHEN AGE >= 18 THEN 'Yes'
  WHEN AGE < 18 THEN 'No'
  ELSE 'Unsure'
END
----

[[fblangref25-commons-null-in-expr-de]]
=== `NULL` in Ausdrücken

`NULL` kein Wert in SQL, sondern ein _Status_ der anzeigt, dass der Wert des Elements entweder _unbekannt_ (engl.
unknown) ist oder nicht existiert.
Es ist weder null, noch void, noch ein "`leerer String`", und es verhält sich auch nicht wie ein anderer Wert.

Wenn Sie `NULL` in numerischen, String- oder Datums/Zeit-Ausdrücken verwenden, wird das Ergebnis immer `NULL` sein.
Verwenden Sie `NULL` in logischen (Boolean) Ausdrücken, hängt das Ergebnis von der Art der Operation ab und anderen partizipierenden Werten.
Wenn Sie einen Wert mit `NULL` vergleichen, wird das Ergebnis _unknown_ sein.

.Zu beachten
[IMPORTANT]
====
`NULL` heißt `NULL`, jedoch gilt in Firebird, dass das logische Ergebnis _unknown_ ebenfalls durch `NULL` __repräsentiert__ wird.
====

[[fblangref25-commons-returningnull-de]]
==== Ausdrücke die `NULL` zurückgeben

Ausdrücke in dieser Liste werden immer `NULL` zurückgeben:

[source]
----
1 + 2 + 3 + NULL
'Home ' || 'sweet ' || NULL
MyField = NULL
MyField <> NULL
NULL = NULL
not (NULL)
----

Wenn es Ihnen schwerfällt dies zu verstehen, beachten Sie, dass `NULL` ein Status ist, der für "`unknown`" (unbekannt) steht.

[[fblangref25-commons-nullinlogical-de]]
==== `NULL` in logischen Ausdrücken

Es wurde bereits gezeigt, dass `not (NULL)` in `NULL` aufgeht.
Dieser Effekt ist etwas komplizierter für logische ``AND``- sowie logische ``OR``-Operatoren:

[source]
----
NULL or false = NULL
NULL or true = true
NULL or NULL = NULL
NULL and false = false
NULL and true = NULL
NULL and NULL = NULL
----

Bis einschließlich Firebird 2.5.x existiert keine Implementierung für logische (Boolean) Datentypen -- diese gibt es erst seit Firebird 3.
Jedoch gibt es logische Ausdrücke (Prädikate), die true, false oder unknown zurückgeben können.

.Beispiele
[source]
----
(1 = NULL) or (1 <> 1) -- liefert NULL
(1 = NULL) or (1 = 1) -- liefert TRUE
(1 = NULL) or (1 = NULL) -- liefert NULL
(1 = NULL) and (1 <> 1) -- liefert FALSE
(1 = NULL) and (1 = 1) -- liefert NULL
(1 = NULL) and (1 = NULL) -- liefert NULL
----

[[fblangref25-commons-subqueries-de]]
=== Unterabfragen

Eine Unterabfrage ist eine spezielle Form eines Ausdrucks, die innerhalb einer anderen Abfrage eingebettet wird.
Unterabfragen werden in der gleichen Weise geschrieben wie reguläre ``SELECT``-Abfragen, werden jedoch von Klammern umschlossen.
Unterabfrage-Ausdrücke können in folgender Art und Weise verwendet werden: 

* Um eine Ausgabespalte in der SELECT-Liste anzugeben
* Um Werte zu holen oder als Kriterium für Suchprädikate (die ``WHERE``- und ``HAVING``-Klauseln)
* Um ein Set zu erstellen, das die Eltern-Abfrage verwenden kann, so als wäre dies eine reguläre Tabelle oder View.
Unterabfragen wie diese erscheinen in der FROM-Klausel (Derived Tables) oder in einer  Common Table Expression (CTE)

[[fblangref25-commons-correlatedsq-de]]
==== Korrelierte Unterabfragen

Eine Unterabfrage kann _korrelierend_ sein.
Sie ist korellierend, wenn die Hauptafrage und die Unterabfrage voneinander abhängig sind.
Um einen Datensatz in der Unterabfrage zu verarbeiten, ist es notwendig einen Datensatz in der Hauptabfrage zu holen;
beispielsweise hängt die Unterabfrage vollständig von der Hauptabfrage ab.

.Beispiel einer korrelierenden Unterabfrage
[source]
----
SELECT *
FROM Customers C
WHERE EXISTS
  (SELECT *
   FROM Orders O
   WHERE C.cnum = O.cnum
     AND O.adate = DATE '10.03.1990');
----

Werden Unterabfragen verwendet um Werte einer Ausgabespalte aus einer SELECT-Liste zu holen, muss die Unterabfrage ein _skalares_ Ergebnis zurückliefern.

[[fblangref25-commons-scalarsq-de]]
==== Skalare Ergebnisse

Unterabfragen, die in Suchprädikaten verwendet werden, mit Ausnahme von existenziellen und quantifizierten Prädikaten,  müssen ein _skalares_ Ergebnis zurückgeben;
Das heißt, nicht mehr als eine Spalte von nicht mehr als einer passenden Zeile oder Aggregation.
Sollte mehr zurückgegeben werden, wird es zu einem Laufzeitfehler kommen ("`Multiple rows in a singleton select...`").

[NOTE]
====
Obwohl es einen echten Fehler berichtet, kann die Nachricht etwas irreführend sein.
Ein "`singleton SELECT`" ist eine Abfrage, die nicht mehr als eine Zeile zurückgeben kann.
Jedoch sind "`singleton`" und "`skalar`" nicht gleichzusetzen: nicht alle singleton SELECTs müssen zwangsläufig skalar sein;
und Einspalten-SELECTs können mehrere Zeilen für existenzielle und quantifizierte Prädikate zurückgeben.
====

.Unterabfrage-Beispiele
. Eine Unterabfrage als Ausgabespalte in einer ``SELECT``-Liste:
+
[source]
----
SELECT
  e.first_name,
  e.last_name,
  (SELECT
       sh.new_salary
   FROM
       salary_history sh
   WHERE
       sh.emp_no = e.emp_no
   ORDER BY sh.change_date DESC ROWS 1) AS last_salary
FROM
  employee e
----
. eine Unterabfrage in der ``WHERE``-Klausel, um das höchste Gehalt eines Mitarbeiters zu ermitteln und hierauf zu filtern:
+
[source]
----
SELECT
  e.first_name,
  e.last_name,
  e.salary
FROM
  employee e
WHERE
  e.salary = (
              SELECT MAX(ie.salary)
              FROM employee ie
             )
----

[[fblangref25-commons-predicates-de]]
== Prädikate

Ein Prädikat ist ein einfacher Ausdruck, der eine Behauptung aufstellt, wir nennen sie `P`.
Wenn `P` zu TRUE (wahr) aufgelöst wird, ist die Behauptung erfolgreich.
Wird sie zu FALSE (unwahr, falsch) oder NULL (UNKNOWN) aufgelöst, ist die Behauptung falsch.
Hier gibt es einen Fallstrick: Nehmen wir an, das Prädikat `P` gibt FALSE zurück.
In diesem Falle gilt, dass `NOT(P)` TRUE zurückgeben wird.
Andererseits gilt, falls `P` NULL (unknown) zurückgibt, dann gibt `NOT(P)` ebenfalls NULL zurück.

In SQL können Prädikate in ``CHECK``-Constraints auftreten, ``WHERE``- und ``HAVING``-Klauseln, ``CASE``-Ausdrücken, der ``IIF()``-Funktion und in der ``ON``-Bedingung der ``JOIN``-Klausel.

[[fblangref25-commons-assertions-de]]
=== Behauptungen

Eine Behauptung ist ein Statement über Daten, die, wie ein Prädikat, zu TRUE, FALSE oder NULL aufgelöst werden können.
Behauptungen bestehen aus einem oder mehr Prädikaten, möglicherweise mittels `NOT` negiert und verbunden durch ``AND``- sowie ``OR``-Operatoren.
Klammern können verwendet werden um Prädikate zu gruppieren und die Ausführungsreihenfolge festzulegen.

Ein Prädikat kann andere Prädikate einbetten.
Die Ausführung ist nach außen gerichtet, das heißt, das innenliegendste Prädikat wird zuerst ausgeführt.
Jede "`Ebene`" wird in ihrer Rangfolge ausgewertet bis der Wahrheitsgehalt der endgültigen Behauptung aufgelöst wird.

[[fblangref25-commons-comppreds-de]]
=== Vergleichs-Prädikate

Ein Vergleichsprädikat besteht aus zwei Ausdrücken, die mit einem Vergelichsoperator verbunden sind.
Es existieren traditionel sechs Vergleichsoperatoren:

[listing]
----
=, >, <, >=, <=, <>
----

Für die vollständige Liste der Vergleichsoperatoren mit ihren Variantenformen siehe <<fblangref25-commons-compar-de,Vergleichsoperatoren>>.

Wenn eine der Seiten (links oder rechts) eines Vergleichsprädikats `NULL` darin hat, wird der Wert des Prädikats UNKNOWN.

.Beispiele
. Abrufen von Informationen über Computer mit der CPU-Frequenz nicht weniger als 500 MHz und der Preis niedriger als $800:
+
[source]
----
SELECT *
FROM Pc
WHERE speed >= 500 AND price < 800;
----
. Abrufen von Informationen über alle Punktmatrixdrucker, die weniger als $300 kosten:
+
[source]
----
SELECT *
FROM Printer
WHERE ptrtype = 'matrix' AND price < 300;
----
. Die folgende Abfrage gibt keine Daten zurück, auch nicht wenn es Drucker ohne zugewiesenen Typ gibt, da ein Prädikat, das `NULL` mit `NULL` vergleicht, `NULL` zurückgibt:
+
[source]
----
SELECT *
FROM Printer
WHERE ptrtype = NULL AND price < 300;
----
+
Auf der anderen Seite kann [replaceable]``ptrtype`` auf `NULL` getestet werden;
mit dem Ergebnis, dass die kein __Vergleichs__test ist:
+
[source]
----
SELECT *
FROM Printer
WHERE ptrtype IS NULL AND price < 300;
----
+
-- siehe <<fblangref25-commons-isnotnull-de,`IS [NOT] NULL`>>.

.Hinweis zu String-Vergleichen
[NOTE]
====
Werden ``CHAR``- und ``VARCHAR``-Felder auf Gleichheit verglichen, werden nachfolgende Leerzeichen in allen Fällen ignoriert.
====

[[fblangref25-commons-othercomppreds-de]]
==== Andere Vergleichsprädikate

Andere Vergleichsprädikate werden durch Schlüsselwörter gekennzeichnet.

[[fblangref25-commons-predbetween-de]]
===== `BETWEEN`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] BETWEEN <value_1> AND <value_2>
----

Das ``BETWEEN``-Prädikat prüft, ob ein Wert innerhalb eines angegebenen Bereichs zweier Werte liegt.
(`NOT BETWEEN` prüft, ob dieser Wert außerhalb der beiden Grenzen liegt.)

Die Operanden des ``BETWEEN``-Prädikates sind zwei Argumente kompatibler Datentypen.
Anders als in anderen DBMS ist das ``BETWEEN``-Prädikat nicht symmetrisch -- ist der kleinere Wert nicht das erste Argument, wird immer FALSE zurückgegeben.
Die Suche ist inkludiert (die Werte beider Argumente werden in die Suche eingebunden).
Anders ausgedrückt bedeutet dies, dass das ``BETWEEN``-Prädikat auch anders geschrieben werden kann:

[listing]
----
<value> >= <value_1> AND <value> <= <value_2>
----

Wird `BETWEEN` in Suchkriterien für DML-Abfragen verwendet, kann der Firebird-Optimizer einen Index auf der Suchspalte nutzen, sofern verfügbar.

.Beispiel
[source]
----
SELECT *
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
----

[[fblangref25-commons-predlike-de]]
===== `LIKE`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
<match value> [NOT] LIKE <pattern>
   [ESCAPE <escape character>]

<match value>      ::= _character-type expression_
<pattern>          ::= _search pattern_
<escape character> ::= _escape character_
----

Das ``LIKE``-Prädikat vergleicht zeichenbasierte Ausdrücke mit dem im zweiten Ausdruck definierten Muster.
Groß- und Kleinschreibung bzw. Akzent-Sensitivität für den Vergleich wird durch die zugrunde liegende Collation bestimmt.
Eine Collation kann für jeden  Operanden angegeben werden, wenn erforderlich.

[[fblangref25-commons-wildcards-de]]
====== Wildcards

Zwei Wildcard-Zeichen sind für die Suche verfügbar: 

* Das Prozentzeichen (`%`) berücksichtigt alle Sequenzen von null oder mehr Zeichen im getesteten Wert
* Das Unterstrichzeichen (`++_++`) berücksichtigt jedes beliebige Einzelzeichen im getesteten Wert

Wenn der getestete Wert dem Muster entspricht, unter Berücksichtigung von Wildcard-Zeichen ist das Prädikat TRUE.

[[fblangref25-commons-escapechar-de]]
====== Verwendung der ``ESCAPE``-Zeichen-Option

Wenn der Such-String eines der Wildcard-Zeichen beinhaltet, kann die ``ESCAPE``-Klausel verwendet werden, um ein Escape-Zeichen zu definieren.
Das Escape-Zeichen muss dem '```%```' oder '```++_++```'  Symbol im Suchstring vorangestellt werden, um anzuzeigen, dass das Symbol als wörtliches Zeichen interpretiert werden soll.

====== Beispiele für `LIKE`

. Finde die Nummern der Abteilung, deren Namen mit dem Wort "`Software`" starten:
+
[source]
----
SELECT DEPT_NO
FROM DEPT
WHERE DEPT_NAME LIKE 'Software%';
----
+
Es ist möglich einen Index für das Feld DEPT_NAME zu verwenden, sofern dieser existiert.
+
.Über `LIKE` und den Optimizer
[NOTE]
====
Eigentlich verwendet das ``LIKE``-Prädikat keinen Index.
Wird das Prädikat jedoch in Form von `LIKE 'string%'` verwendet, wird dieses zum Prädikat `STARTING WITH` konvertiert, welches einen Index verwendet.

Somit gilt -- wenn Sie nach einem Wortanfang suchen, sollten Sie das Prädikat `STARTING WITH` anstelle von `LIKE` verwenden.
====
. Suche nach Mitarbeitern deren Namen aus 5 Buchstaben bestehen, die mit "`Sm`" beginnen und mit "`th`" enden.
Das Prädikat wird wahr für die Namen wie "`Smith`" und "`Smyth`".
+
[source]
----
SELECT
  first_name
FROM
  employee
WHERE first_name LIKE 'Sm_th'
----
. Suche nach allen Mandanten, deren Adresse den String "`Rostov`" enthält:
+
[source]
----
SELECT *
FROM CUSTOMER
WHERE ADDRESS LIKE '%Rostov%'
----
+
[NOTE]
====
Benötigen Sie eine Suche, die Groß- und Kleinschreibung _innerhalb_ einer Zeichenkette ignoriert (`LIKE '%Abc%'`), sollten Sie das ``CONTAINING``-Prädikat, anstelle des ``LIKE``-Prädikates, verwenden.
====
. Suche nach Tabellen, die das Unterstrich-Zeichen im Namen besitzen. Das Zeichen '```#```' wird als Escape-Zeichen definiert:
+
[source]
----
SELECT
  RDB$RELATION_NAME
FROM RDB$RELATIONS
WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
----

.Siehe auch
<<fblangref25-commons-predstartwith-de,`STARTING WITH`>>, <<fblangref25-commons-predcontaining-de,`CONTAINING`>>, <<fblangref25-commons-predsiimilarto-de,`SIMILAR TO`>>

[[fblangref25-commons-predstartwith-de]]
===== `STARTING WITH`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] STARTING WITH <value>
----

Das Prädikat `STARTING WITH` sucht nach einer Zeichenkette oder einem zeichenkettenähnlichen Datentyp, die mit den Zeichen des Argumentes _value_ beginnt.
Die Suche unterscheidet zwischen Groß- und Kleinschreibung.

Wenn `STARTING WITH` als Suchkriterium in DML-Abfragen verwendet wird, nutzt der Firebird-Optimizer einen Index auf der Suchspalte, sofern  vorhanden.

.Beispiel
Suche nach Mitarbeitern deren Namen mit "`Jo`" beginnen:

[source]
----
SELECT LAST_NAME, FIRST_NAME
FROM EMPLOYEE
WHERE LAST_NAME STARTING WITH 'Jo'
----

.Siehe auch
<<fblangref25-commons-predlike-de,`LIKE`>>

[[fblangref25-commons-predcontaining-de]]
===== `CONTAINING`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] CONTAINING <value>
----

Das Prädikat `CONTAINING` sucht innerhalb von Zeichenketten oder zeichenkettenähnlichen Datentypen nach der Buchstabenfolge, die im Argument angegeben wurde.
Es kann für alphanumerische (zeichenkettenähnliche) Suchen auf Zahlen und Daten genutzt werden.
Eine Suche mit `CONTAINING` unterscheidet nicht nach Groß- und Kleinschreibung.
Wird jedoch eine akzentsensitive Collation verwendet, ist auch die Suche akzentsensitiv.

Wenn `CONTAINING` als Suchkriterium in DML-Abfragen verwendet wird, kann der Firebird-Optimizer einen Index der Suchspalte nutzen, sofern ein passender existiert.

.Beispiele
. Suche nach Projekten, deren Namen die Zeichenkette "`Map`" enhalten:
+
[source]
----
SELECT *
FROM PROJECT
WHERE PROJ_NAME CONTAINING 'Map';
----
+
Zwei Zeilen mit den Namen "`AutoMap`" und "`MapBrowser port`" werden zurückgegeben.
. Suche nach Änderungen in den Gehältern, die die Zahl 84 im Datum enthalten (in diesem Falle heißt dies, Änderungen im Jahr 1984):
+
[source]
----
SELECT *
FROM SALARY_HISTORY
WHERE CHANGE_DATE CONTAINING 84;
----

.Siehe auch
<<fblangref25-commons-predlike-de,`LIKE`>>

[[fblangref25-commons-predsiimilarto-de]]
===== `SIMILAR TO`

.Verfügbar
DSQL, PSQL

.Syntax
[listing,subs=+quotes]
----
_string-expression_ [NOT] SIMILAR TO <pattern> [ESCAPE <escape-char>]

<pattern>     ::= _an SQL regular expression_
<escape-char> ::= _a single character_
----

`SIMILAR TO` findet eine Zeichenkette anhand eines Regulären Ausdruck-Musters in SQL (engl. SQL Regular Expression Pattern).
Anders als in einigen anderen Sprachen muss das Muster mit der gesamten Zeichenkette  übereinstimmen, um erfolgreich zu sein -- die Übereinstimmung eines Teilstrings reicht nicht aus.
Ist ein Operand `NULL`, ist auch das Ergebnis `NULL`.
Andernfalls ist das Ergebnis `TRUE` oder `FALSE`.

[[fblangref25-commons-syntaxregex-de]]
====== Syntax: SQL Reguläre Ausdrücke

Die folgende Syntax definiert das SQL-Standardausdruckformat.
Es ist eine komplette und korrekte Top-down-Definition.
Es ist auch sehr formell, ziemlich lang und vermutlich perfekt geeignet, jeden zu entmutigen, der nicht schon Erfahrungen mit Regulären Ausdrücken (oder mit sehr formalen, eher langen Top-down-Definitionen) gesammelt hat.
Fühlen Sie sich frei, dies zu überspringen und den nächsten Abschnitt, <<fblangref25-commons-buildregex-de,Aufbau Regulärer Ausdrücke>>, zu lesen, der einen Bottom-up-Ansatz verfolgt und sich an den Rest von uns richtet.

[listing,subs=+quotes]
----
<regular expression> ::= <regular term> ['|' <regular term> ...]

<regular term> ::= <regular factor> ...

<regular factor> ::= <regular primary> [<quantifier>]

<quantifier> ::= ? | * | + | '{' <m> [,[<n>]] '}'

<m>, <n> ::= _unsigned int, mit <m> <= <n> wenn beide vorhanden_

<regular primary> ::=
     <character> | <character class> | %
    | (<regular expression>)

<character> ::= <escaped character> | <non-escaped character>

<escaped character> ::=
    <escape-char> <special character> | <escape-char> <escape-char>

<special character> ::= _eines der Zeichen []()|^-+*%_?{_

<non-escaped character> ::=
  _ein Zeichen, das nicht ein <special character> ist_
  _und nicht gleich <escape-char> (wenn definiert)_

<character class> ::=
    '_' | '[' <member> ... ']' | '[^' <non-member> ... ']'
  | '[' <member> ... '^' <non-member> ... ']'

<member>, <non-member> ::= <character> | <range> | <predefined class>

<range> ::= <character>-<character>

<predefined class> ::= '[:' <predefined class name> ':]'

<predefined class name> ::=
  ALPHA | UPPER | LOWER | DIGIT | ALNUM | SPACE | WHITESPACE
----

[[fblangref25-commons-buildregex-de]]
====== Aufbau Regulärer Ausdrücke

Dieser Abschnitt behandelt die Elemente und Regeln zum Aufbau Regulärer Ausdrücke in SQL.

[float]
[[fblangref25-commons-regexchar-de]]
====== Zeichen

Innerhalb Regulärer Ausdrücke repräsentieren die meisten Zeichen sich selbst.
Die einzige Ausnahme bilden die folgenden Zeichen:

[listing]
----
[ ] ( ) | ^ - + * % _ ? { }
----

$$...$$ und das Escape-Zeichen, sofern definiert.

Ein Regulärer Ausdruck, der keine Sonderzeichen oder Escape-Zeichen beinhaltet, findet nur Strings, die identisch zu sich selbst sind (abhängig von der verwendeten Collation).
Das heißt, es agiert wie der '```=```'-Operator:

[source]
----
'Apple' similar to 'Apple'  -- true
'Apples' similar to 'Apple' -- false
'Apple' similar to 'Apples' -- false
'APPLE' similar to 'Apple'  -- abhängig von der Collation
----

[float]
[[fblangref25-commons-regexwildcards-de]]
====== Wildcards

Die bekannten SQL-Wildcards '```++_++```' und '```%```' finden beliebige Einzelzeichen und Strings beliebiger Länge:

[source]
----
'Birne' similar to 'B_rne'   -- true
'Birne' similar to 'B_ne'    -- false
'Birne' similar to 'B%ne'    -- true
'Birne' similar to 'Bir%ne%' -- true
'Birne' similar to 'Birr%ne' -- false
----

Beachten Sie, wie '```%```' auch den leeren String berücksichtigt.

[float]
[[fblangref25-commons-regexcharclass-de]]
====== Zeichenklassen

Ein Bündel von Zeichen, die in Klammern eingeschlossen sind, definiert eine Zeichenklasse.
Ein Zeichen in der Zeichenfolge entspricht einer Klasse im Muster, wenn das Zeichen Mitglied der Klasse ist:

[source]
----
'Citroen' similar to 'Cit[arju]oen'     -- true
'Citroen' similar to 'Ci[tr]oen'        -- false
'Citroen' similar to 'Ci[tr][tr]oen'    -- true
----

Wie aus der zweiten Zeile ersichtlich ist, entspricht die Klasse nur einem einzigen Zeichen, nicht einer Sequenz.

Innerhalb einer Klassendefinition definieren zwei Zeichen, die durch einen  Bindestrich verbunden sind, einen Bereich.
Ein Bereich umfasst die beiden Endpunkte und alle  Zeichen, die zwischen ihnen in der aktiven Sortierung liegen.
Bereiche können überall in der Klassendefinition ohne spezielle Begrenzer platziert werden, um sie von den anderen Elementen zu trennen.

[source]
----
'Datte' similar to 'Dat[q-u]e'          -- true
'Datte' similar to 'Dat[abq-uy]e'       -- true
'Datte' similar to 'Dat[bcg-km-pwz]e'   -- false
----

[float]
[[fblangref25-commons-regexpredefclass-de]]
====== Vordefinierte Zeichenklassen

Die folgenden vordefinierten Zeichenklassen können auch in einer Klassendefinition verwendet werden:

`[:ALPHA:]`::
Lateinische Buchstaben a..z und A..Z.
Mit einer akzentunempfindlichen Sortierung  stimmt diese Klasse auch mit akzentuierten Formen dieser Zeichen überein.

`[:DIGIT:]`::
Dezimalziffern 0..9.

`[:ALNUM:]`::
Gesamtheit aus `[:ALPHA:]` und `[:DIGIT:]`.

`[:UPPER:]`::
Großgeschriebene Form der lateinischen Buchstaben A..Z.
Findet auch kleingeschriebene Strings mit  groß- und kleinschreibunempfindlicher Collation sowie akzentunempfindlicher Collation.

`[:LOWER:]`::
Kleingeschriebene Form der lateinischen Buchstaben A..Z.
Findet auch großgeschriebene Strings mit  groß- und kleinschreibunempfindlicher Collation sowie akzentunempfindlicher Collation.

`[:SPACE:]`::
Findet das Leerzeichen (ASCII 32).

`[:WHITESPACE:]`::
Findet horizontalen Tabulator (ASCII 9), Zeilenvorschub (ASCII 10), vertikalen Tabulator (ASCII 11), Seitenvorschub (ASCII 12), Wagenrücklauf (ASCII 13) und Leerzeichen (ASCII 32).

Das Einbinden einer vordefinierten Klasse hat den gleichen Effekt wie das Einbinden all seiner Mitglieder.
Vordefinierte Klassen sind nur in Klassendefinitionen erlaubt.
Wenn Sie gegen eine vordefinierte Klasse  prüfen und gegen nichts sonst, platzieren Sie ein zusätzliches Paar von Klammern um sie herum.

[source]
----
'Erdbeere' similar to 'Erd[[:ALNUM:]]eere'     -- true
'Erdbeere' similar to 'Erd[[:DIGIT:]]eere'     -- false
'Erdbeere' similar to 'Erd[a[:SPACE:]b]eere'   -- true
'Erdbeere' similar to [[:ALPHA:]]              -- false
'E'        similar to [[:ALPHA:]]              -- true
----

Wenn eine Klassendefinition mit einer eckigen Klammer beginnt, wird alles, was folgt, von der Klasse ausgeschlossen.
Alle anderen Zeichen entsprechen:

[source]
----
'Framboise' similar to 'Fra[^ck-p]boise'       -- false
'Framboise' similar to 'Fr[^a][^a]boise'       -- false
'Framboise' similar to 'Fra[^[:DIGIT:]]boise'  -- true
----

Wird die eckige Klammer nicht am Anfang der Reihe platziert, enthält die Klasse alles vor dieser, mit Ausnahme der Elemente die nach der Klammer vorkommen:

[source]
----
'Grapefruit' similar to 'Grap[a-m^f-i]fruit'   -- true
'Grapefruit' similar to 'Grap[abc^xyz]fruit'   -- false
'Grapefruit' similar to 'Grap[abc^de]fruit'    -- false
'Grapefruit' similar to 'Grap[abe^de]fruit'    -- false

'3' similar to '[[:DIGIT:]^4-8]'               -- true
'6' similar to '[[:DIGIT:]^4-8]'               -- false
----

Zuletzt sei noch erwähnt, dass die Wildcard-Zeichen '```++_++```' eine eigene Zeichenklasse sind, die einem beliebigen einzelnen Zeichen entspricht.

[float]
[[fblangref25-commons-regexquantifiers]]
====== Bezeichner

Ein Fragezeichen, direkt von einem weiteren Zeichen oder Klasse gefolgt, gibt an, dass das folgende Element gar nicht oder einmalig vorkommen darf:

[source]
----
'Hallon' similar to 'Hal?on'                   -- false
'Hallon' similar to 'Hal?lon'                  -- true
'Hallon' similar to 'Halll?on'                 -- true
'Hallon' similar to 'Hallll?on'                -- false
'Hallon' similar to 'Halx?lon'                 -- true
'Hallon' similar to 'H[a-c]?llon[x-z]?'        -- true
----

Ein Sternchen, direkt von einem weiteren Zeichen oder Klasse gefolgt, gibt an, dass das folgende Element gar nicht oder mehrmals vorkommen darf:

[source]
----
'Icaque' similar to 'Ica*que'                  -- true
'Icaque' similar to 'Icar*que'                 -- true
'Icaque' similar to 'I[a-c]*que'               -- true
'Icaque' similar to '_*'                       -- true
'Icaque' similar to '[[:ALPHA:]]*'             -- true
'Icaque' similar to 'Ica[xyz]*e'               -- false
----

Ein Plus-Zeichen, direkt von einem weiteren Zeichen oder Klasse gefolgt, gibt an, dass das folgende Element einmalig oder mehrmals vorkommen darf:

[source]
----
'Jujube' similar to 'Ju_+'                     -- true
'Jujube' similar to 'Ju+jube'                  -- true
'Jujube' similar to 'Jujuber+'                 -- false
'Jujube' similar to 'J[jux]+be'                -- true
'Jujube' sililar to 'J[[:DIGIT:]]+ujube'       -- false
----

Folgt eine Zahl in Klammern auf ein Zeichen oder eine Klasse, muss letzteres genau so oft wie angegeben vorkommen:

[source]
----
'Kiwi' similar to 'Ki{2}wi'                    -- false
'Kiwi' similar to 'K[ipw]{2}i'                 -- true
'Kiwi' similar to 'K[ipw]{2}'                  -- false
'Kiwi' similar to 'K[ipw]{3}'                  -- true
----

Wird eine Zahl von einem Komma gefolgt, bedeutet dies, dass das Element mindestens so oft wie angegeben vorkommen muss:

[source]
----
'Limone' similar to 'Li{2,}mone'               -- false
'Limone' similar to 'Li{1,}mone'               -- true
'Limone' similar to 'Li[nezom]{2,}'            -- true
----

Wenn die Klammern zwei Zahlen enthalten, die mittels Komma getrennt sind, die zweite Zahl nicht kleiner als die erste ist, muss das Element mindestens so oft wie die erste Zahl vorkommen und maximal so oft wie in der zweiten Zahl angegeben:

[source]
----
'Mandarijn' similar to 'M[a-p]{2,5}rijn'       -- true
'Mandarijn' similar to 'M[a-p]{2,3}rijn'       -- false
'Mandarijn' similar to 'M[a-p]{2,3}arijn'      -- true
----

Die Bezeichner '```?```', '```{asterisk}```' und '```{plus}```' sind Kurzschreibweisen für `{0,1}`, `{0,}` und `{1,}`.

[float]
[[fblangref25-commons-regexoring-de]]
====== Oder-verknüpfte Terme

Reguläre Ausdrücke können Oder-verknüpft werden mittels '```|```'-Operator.
Eine Gesamtübereinstimmung tritt auf, wenn die Argumentzeichenkette mit mindestens einem Term übereinstimmt.

[source]
----
'Nektarin' similar to 'Nek|tarin'              -- false
'Nektarin' similar to 'Nektarin|Persika'       -- true
'Nektarin' similar to 'M_+|N_+|P_+'            -- true
----

[float]
[[fblangref25-commons-regexsubexpr-de]]
====== Unterausdrücke

Ein oder mehrere Teile der regulären Ausdrücke können in Unterausdrücke gruppiert werden (auch Untermuster genannt), indem diese in runde Klammern eingeschlossen werden.
Ein Unterausdruck ist ein eigener regulärer Ausdruck.
Dieser kann alle erlaubten Elemente eines  regulären Ausdrucks enthalten, und auch eigene Bezeichner.

[source]
----
'Orange' similar to 'O(ra|ri|ro)nge'           -- true
'Orange' similar to 'O(r[a-e])+nge'            -- true
'Orange' similar to 'O(ra){2,4}nge'            -- false
'Orange' similar to 'O(r(an|in)g|rong)?e'      -- true
----

[float]
[[fblangref25-commons-regexescap-de]]
====== Sonderzeichen escapen

Soll eine Übereinstimmung auf Sonderzeichen innerhalb eines regulären Ausdrucks geprüft werden, muss dieses Zeichen escaped werden.
Es gibt kein Standard-Escape-Zeichen; stattdessen definiert der Benutzer eines, wenn dies benötigt wird:

[source]
----
'Peer (Poire)' similar to 'P[^ ]+ \(P[^ ]+\)' escape '\'    -- true
'Pera [Pear]'  similar to 'P[^ ]+ #[P[^ ]+#]' escape '#'    -- true
'Päron-äppledryck' similar to 'P%$-ä%' escape '$'           -- true
'Pärondryck' similar to 'P%--ä%' escape '-'                 -- false
----

Die letzte Zeile demonstriert, dass das Escape-Zeichen auch sich selbst escapen kann, wenn notwendig. 

[[fblangref25-commons-isnotdistinct-de]]
===== `IS [NOT] DISTINCT FROM`

.Verfügbar
DSQL, PSQL

.Syntax
[listing]
----
<operand1> IS [NOT] DISTINCT FROM <operand2>
----

Zwei Operanden werden als _DISTINCT_ angesehen, wenn sie unterschiedliche Werte besitzen oder wenn einer `NULL` ist und der andere nicht-``NULL``.
Sie werden als _NOT DISTINCT_ angesehen, wenn sie den gleichen Wert besitzen oder beide  Operanden `NULL` sind.

.Siehe auch
<<fblangref25-commons-isnotnull-de,`IS [NOT] NULL`>>

[[fblangref25-commons-isnotnull-de]]
===== `IS [NOT] NULL`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> IS [NOT] NULL
----

Da `NULL` kein Wert ist, sind diese Operatoren keine Vergleichsoperatoren.
Das Prädikat `IS [NOT] NULL` prüft die Behauptung, dass der Ausdruck auf der linken Seite einen Wert (_IS NOT NULL_) oder keinen Wert hat (_IS NULL_).

.Beispiel
Suche nach Verkäufen, die kein Versanddatum besitzen:

[source]
----
SELECT * FROM SALES
WHERE SHIP_DATE IS NULL;
----

.Hinweis bezüglich des IS-Prädikates
[NOTE]
====
Bis einschließlich Firebird 2.5, hat das Prädikat `IS`, wie andere Vergleichsprädikate, keinen Vorrang gegenüber anderer.
Ab Firebird 3.0 hat dieses Prädikat Vorrang gegenüber den anderen.
====

[[fblangref25-commons-existential-de]]
=== Existenzprädikate

Diese Gruppe von Prädikaten beinhaltet die, die Unterabfragen nutzen um Werte für alle möglichen Arten von Behauptungen zu prüfen.
Existenzprädikate werden so genannt, da sie verschiedene Methoden verwenden, um auf die [term]_Exiszenz_ oder [term]_nicht-Existenz_ von Behauptungen zu prüfen.
Die Prädikate geben `TRUE` zurück, wenn die Existenz oder nicht-Existenz bestätigt wurde, andernfalls ``FALSE`.

[[fblangref25-commons-exists-de]]
==== `EXISTS`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
[NOT] EXISTS (<select_stmt>)
----

Das Prädikat `EXISTS` nutzt einen Unterabfrage-Ausdruck als Argument.
Es gibt `TRUE` zurück, wenn die Unterabfrage mindestens einen Datensatz zurückgibt;
andernfalls gibt es `FALSE` zurück.

`NOT EXISTS` gibt `FALSE` zurück, wenn die Unterabfrage mindestens eine Datenzeile zurückgibt;
es gibt andernfalls `TRUE` zurück.

[NOTE]
====
Die Unterabfrage kann mehrere Spalten enthalten, oder `SELECT {asterisk}`, da die Prüfung anhand der zurückgegebenen Datenzeilen vorgenommen wird, die die Bedingungen erfüllen.
====

.Beispiele
. Finde die Mitarbeiter, die Projekte haben.
+
[source]
----
SELECT *
FROM employee
WHERE EXISTS(SELECT *
             FROM  employee_project ep
             WHERE ep.emp_no = employee.emp_no)
----
. Finde die Mitarbeiter, die keine Projekte haben.
+
[source]
----
SELECT *
FROM employee
WHERE NOT EXISTS(SELECT *
                 FROM employee_project ep
                 WHERE ep.emp_no = employee.emp_no)
----

[[fblangref25-commons-in-de]]
==== `IN`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] IN (<select_stmt> | <value_list>)

<value_list> ::= <value_1> [, <value_2> …]
----

Das Prädikat `IN` prüft, ob der Wert des Ausdrucks auf der linken Seite im Wertesatz der rechten Seite vorkommt.
Der Wertesatz darf nicht mehr als 1500 Elemente enthalten.
Das ``IN``-Prädikat kann mit folgender äquivalenter Form ersetzt werden:

[listing]
----
(<value> = <value_1> [OR <value> = <value_2> …])

<value> = { ANY | SOME } (<select_stmt>)
----

Wenn das Prädikat `IN` als Suchbedingung in DML-Abfragen verwendet wird, kann der Firebird-Optimizer einen Index auf die Suchspalte nutzen, sofern einer vorhanden ist.

In seiner zweiten Form prüft das Prädikat `IN`, ob der linke Ausdruckswert im Ergebnis der Unterabfrage vorhanden ist (oder nicht vorhanden, wenn `NOT IN`  verwendet wird).

Die Unterabfrage darf nur eine Spalte abfragen, andernfalls wird es zum Fehler "`count of column list and variable list do not match`" kommen.

Abfragen, die das Prädikat `IN` mit einer Unterabfrage verwenden, können durch eine ähnliche Abfrage mittels des ``EXISTS``-Prädikates ersetzt werden.
Zum Beispiel folgende Abfrage:

[source]
----
SELECT
  model, speed, hd
FROM PC
WHERE
model IN (SELECT model
          FROM product
          WHERE maker = 'A');
----

kann ersetzt werden mittels EXISTS-Prädikat:

[source]
----
SELECT
  model, speed, hd
FROM PC
WHERE
 EXISTS (SELECT *
         FROM product
         WHERE maker = 'A'
           AND product.model = PC.model);
----

Jedoch gilt zu beachten, dass eine Abfrage mittels `NOT IN` und einer Unterabfrage nicht immer das gleiche Ergebnis zurückliefert wie sein Gegenpart mit `NOT EXISTS`.
Dies liegt daran, dass `EXISTS` immer TRUE oder FALSE zurückgibt, wohingegen `IN` `NULL` in diesen beiden Fällen zurückliefert:

[loweralpha]
. wenn der geprüfte Wert `NULL` ist und die ``IN ()``-Liste nicht leer ist
. wenn der geprüfte Wert keinen Treffer in der ``IN ()``-Liste enthält und mindestens ein Element `NULL` ist.

Nur in diesen beiden Fällen wird `IN ()` `NULL` zurückgeben, während das ``EXISTS``-Prädikat `FALSE` zurückgibt ('keine passende Zeile gefunden', engl. 'no matching row found').
In einer Suche oder, zum Beispiel in einem ``IF (...)``-Statement, bedeuten beide Ergebnisse einen "`Fehler`" und es macht damit keinen Unterschied.

Aber für die gleichen Daten gibt `NOT IN ()` `NULL` zurück, während `NOT EXISTS` `TRUE` zurückgibt, was das Gegenteilige Ergebnis ist.

Schauen wir uns das folgendes Beispiel an:

[source]
----
-- Suche nach Bürgern die nicht am gleichen Tag wie eine
-- berühmte New Yorker Persönlichkeit geboren wurden
SELECT P1.name AS NAME
FROM Personnel P1
WHERE P1.birthday NOT IN (SELECT C1.birthday
                          FROM Celebrities C1
                          WHERE C1.birthcity = 'New York');
----

Nehmen wir nun an, dass die Liste der New Yorker Berühmtheiten nicht leer ist und mindestens einen NULL-Geburtstag aufweist.
Dann gilt für alle Bürger, die nicht am gleichen Tag mit einer Berühmtheit Geburtstag haben, dass `NOT IN` `NULL` zurückgibt, da dies genau das ist was `IN` tut.
Die Suchbedingung wurde nicht erfüllt und die Bürger werden nicht im Ergebnis des `SELECT` berücksichtigt, da die Aussage falsch ist.

Bürger, die am gleichen Tag wie eine Berühmtheit Geburtstag feiern, wird `NOT IN` korrekterweise `FALSE` zurückgeben, womit diese  ebenfalls aussortiert werden, und damit keine Zeile zurückgegeben wird.

Wird die Form `NOT EXISTS` verwendet:

[source]
----
-- Suche nach Bürgern, die nicht am gleichen Tag wie eine
-- berühmte New Yorker Persönlichkeit geboren wurden
SELECT P1.name AS NAME
FROM Personnel P1
WHERE NOT EXISTS (SELECT *
                  FROM Celebrities C1
                  WHERE C1.birthcity = 'New York'
                    AND C1.birthday = P1.birthday);
----

nicht-Übereinstimmungen werden im ``NOT EXISTS``-Ergebnis `TRUE` erhalten und ihre Datensätze landen im Rückgabesatz. 

.Hinweis
[CAUTION]
====
Wenn es im Bereich des Möglichen liegt, dass `NULL` innerhalb der Suche für eine nicht-Prüfung vorhanden sein kann, sollten Sie `NOT EXISTS` verwenden.
====

.Beispiele für die Verwendung
. Finde Mitarbeiter mit den Namen "`Pete`", "`Ann`" und "`Roger`":
+
[source]
----
SELECT *
FROM EMPLOYEE
WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
----
. Finde alle Computer, die deren Hersteller mit dem Buchstaben "`A`" beginnt:
+
[source]
----
SELECT
  model, speed, hd
FROM PC
WHERE
  model IN (SELECT model
            FROM product
            WHERE maker STARTING WITH 'A');
----

.Siehe auch
<<fblangref25-commons-exists-de,EXISTS>>

[[fblangref25-commons-singular-de]]
==== `SINGULAR`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
[NOT] SINGULAR (<select_stmt>)
----

Das ``SINGULAR``-Prädikat verwendet eine Unterabfrage als Argument und gibt True zurück, wenn diese exakt eine Datenzeile zurückgibt;
andernfalls wird das Prädikat zu False aufgelöst.
Die Unterabfrage kann mehrere Ausgabespalten beinhalten, da die Zeilen ja nicht wirklich ausgegeben werden.
Sie werden nur auf (einzigartige) Existenz geprüft.
Der Kürze halbe, wird häufig nur '```SELECT {asterisk}```'  verwendet.
Das Prädikat `SINGULAR` kann nur zwei Werte zurückgeben:  `TRUE` oder `FALSE`.

.Beispiel
Finde die Mitarbeiter, die nur ein Projekt haben.

[source]
----
SELECT *
FROM employee
WHERE SINGULAR(SELECT *
               FROM employee_project ep
               WHERE ep.emp_no = employee.emp_no)
----

[[fblangref25-commons-quantifiedsq-de]]
=== Quantifizierte Unterabfrage-Prädikate

Ein Quantifizierer ist ein logischer Operator, der die Anzahl der Objekte festlegt, für die diese Behauptung wahr ist.
Es ist keine numerische Größe, sondern eine logische, die die Behauptung mit dem vollen Satz möglicher Objekte verbindet.
Solche Prädikate basieren auf logischen universellen und existentiellen Quantifizierern, die in der formalen Logik erkannt werden.

In Unterabfrage-Ausdrücken machen es Quantifizierer-Prädikate möglich einzelne Werte mit den Ergebnissen von Unterabfragen zu vergleichen; sie besitzen die folgende gemeinsame Form:

[source]
----
<value expression> <comparison operator> <quantifier> <subquery>
----

[[fblangref25-commons-quant-all-de]]
==== `ALL`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> <op> ALL (<select_stmt>)
----

Wenn der ``ALL``-Quantifizierer verwendet wird, ist das Prädikat TRUE, wenn jeder Wert, der von der Unterabfrage zurückgegeben wird, die Bedingung des Prädikates in der Hauptabfrage erfüllt ist.

.Beispiel
Zeige nur jene Kunden an, deren Bewertungen höher sind als die Bewertung jedes Kunden in Paris.

[source]
----
SELECT c1.*
FROM Customers c1
WHERE c1.rating > ALL
      (SELECT c2.rating
       FROM Customers c2
       WHERE c2.city = 'Paris')
----

[IMPORTANT]
====
Wenn die Unterabfrage einen leeren Satz zurückgibt, ist das Prädikat TRUE für jeden linken Wert, unabhängig vom Operator.
Dies mag widersprüchlich erscheinen, denn jeder linke Wert wird gegenüber dem rechten betrachtet als: kleiner als, größer als, gleich sowie ungleich.

Dennoch passt dies perfekt in die formale Logik: Wenn der Satz leer ist, ist das Prädikat 0 mal wahr, d.h. für jede Zeile im Satz.
====

[[fblangref25-commons-quant-anysome-de]]
==== `ANY` and `SOME`

.Verfügbar
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> <op> {ANY | SOME} (<select_stmt>)
----

Die Quantifizierer `ANY` und `SOME` sind in ihrem Verhalten identisch.
Offensichtlich sind beide im SQL-Standard vorhanden, so dass sie austauschbar verwendet werden können, um die Lesbarkeit der Operatoren zu verbessern.
Wird der ``ANY``- oder ``SOME``-Quantifizierer verwendet, ist das Prädikat TRUE, wenn einer der zurückgegebenen Werte der Unterabfrage die Suchbedingung der Hauptabfrage erfüllt.
Gibt die Unterabfrage keine Zeile zurück, wird das Prädikat automtisch als FALSE angesehen.

.Beispiel
Zeige nur die Kunden, deren Bewertungen höher sind  als die eines oder mehrerer Kunden in Rom.

[source]
----
SELECT *
FROM Customers
WHERE rating > ANY
      (SELECT rating
       FROM Customers
       WHERE city = 'Rome')
----
