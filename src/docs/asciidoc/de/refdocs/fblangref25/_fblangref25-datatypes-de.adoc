[[fblangref25-datatypes-de]]
= Datentypen und Unterdatentypen

Daten unterschiedlicher Typen werden verwendet für: 

* die Spaltendefinition in Datenbanktabellen mittels ``CREATE TABLE``-Statement oder zum Ändern der Spalten mittels `ALTER TABLE`
* die Deklaration oder Änderung einer _Domain_ unter Verwendung der Statements `CREATE DOMAIN` oder `ALTER DOMAIN`
* die Deklaration lokaler Variablen in gespeicherten Prozeduren, PSQL-Blöcken und Triggern sowie spezifizierter Parameter in gespeicherten Prozeduren
* die indirekte Spezifikation von Argumenten und Rückgabewerten bei der Deklaration externer Funktionen (UDFs -- user-defined functions)
* die zur Verfügungstellung von Argumenten für die Funktion `CAST()` um Daten von einem Typ zu einem anderen zu konvertieren

[[fblangref25-dtyp-tbl-dtypinfo-de]]
.Übersicht der Datentypen
[cols="<1,<1,<1,<2", options="header",stripes="none"]
|===
^| Name
^| Größe
^| Präzision & Grenzen
^| Beschreibung

|`BIGINT`
|64 Bits
|Von -2^63^ bis (2^63^ - 1)
|Nur in Dialekt 3 verfügbar

|`BLOB`
|unterschiedlich
|Die Größe eines BLOB-Segments ist auf 64K begrenzt.
Die maximale Größe eines BLOB-Feldes sind 4GB.
|Ein Datentyp mit dynamisch unterschiedlicher Größe für die Ablage von großen Datenmengen, wie z.B. Bilder, Texte, Audiodaten.
Die strukturelle Basiseinheit is das Segment.
Der BLOB-Untertyp definiert dessen Inhalt.

|`CHAR(__n__)`, `CHARACTER(__n__)`
|_n_ Zeichen.
Größe in Bytes abhängig von der Encodierung, der Anzahl Bytes pro Zeichen
|von 1 bis 32,767 Bytes
|Ein Datentyp mit fester Länge.
Bei Anzeige der Daten werden Leerzeichen an das Ende der Zeichenkette bis zur angegebenen Länge angefügt.
Die Leerzeichen werden nicht in der Datenbank gespeichert, jedoch wiederhergestellt, um die definierte Länge bei Anzeige am Client zu erreichen.
Die Leerzeichen werden nicht über das Netzwerk versendet, was den Datenverkehr reduziert.
Wurde kein Zeichenlänge angegeben, wird 1 als Standardwert verwendet.

|`DATE`
|32 Bits
|von 01.01.0001 AD bis 31.12.9999 AD
|`ISC_DATE`.
Nur Datum, kein Zeitelement

|`DECIMAL (__precision__, __scale__)`
|Varying (16, 32 or 64 bits)
|_precision_ = von 1 bis 18, legt die mindestmögliche Anzahl zu speichernder Ziffern fest;
_scale) = von 0 bis 18, gibt die Anzahl der Nachkommastellen an.
|Eine Kommazahl mit _scale_ Nachkommastellen.
_scale_ muss kleiner oder gleich -precision_ sein.
Beispiel: `NUMERIC(10,3)` ist eine Zahl im Format: `ppppppp.sss`

|`DOUBLE PRECISION`
|64 Bits
|2.225 * 10^-308^ bis 1.797 * 10^308^
|Doppelte Präzision nach IEEE, ~15 Stellen, zuverlässige Größe hängt von der Plattform ab.

|`FLOAT`
|32 bits
|1.175 * 10^-38^ bis 3.402 * 10^38^
|Einfache Präzision nach IEEE, ~7 Stellen

|`INTEGER`, `INT`
|32 Bits
|-2.147.483.648 up to 2.147.483.647
|Ganzzahlen mit Vorzeichen

|`NUMERIC (__precision__, __scale__)`
|Unterschiedlich (16, 32 oder 64 Bits)
|_precision_ = von 1 bis 18, legt die genaue Anzahl zu speichernder Stellen fest;
_scale_ = von 0 bis 18, legt die Anzahl der Nachkommastellen fest.
|Eine Kommazahl mit _scale_ Nachkommastellen.
_scale_ muss kleiner oder gleich -precision_ sein.
Beispiel: `NUMERIC(10,3)` ist eine Zahl im Format: `ppppppp.sss`

|`SMALLINT`
|16 Bits
|-32.768 bis 32.767
|Ganzzahlen mit Vorzeichen (word)

|`TIME`
|32 Bits
|0:00 to 23:59:59.9999
|`ISC_TIME`.
Tageszeit.
Kann nicht zum Spiechern von Zeitintervallen verwendet werden.

|`TIMESTAMP`
|64 Bits (2 X 32 Bits)
|Von Anfang des Tages 01.01.0001 AD bis Ende des Tages 31.12.9999 AD
|Datum und Uhrzeit eines Tages

|`VARCHAR(__n__)`, `CHAR VARYING`, `CHARACTER VARYING`
|_n_ Zeichen.
Größe in Bytes, abhängig von der Enkodierung, der Anzahl von Bytes für ein Zeichen
|von 1 bis 32,765 Bytes
|Zeichenkette mit variabler Länge.
Die Gesamtgröße der Zeichen darf (32KB-3) nicht übersteigen.
Dies berücksichtigt auch die hinterlegte Enkodierung.
Die beiden hinteren Bytes speichern die deklarierte Länge.
Es gibt keine Standardgröße.
Das Argument _n_ ist erforderlich.
Führende und abschließende Leerzeichen werden gespeichert und nicht abgeschnitten, außer den Leerzeichen, die hinter der definierten Länge liegen.
|===

.Hinweis zu Daten
[NOTE]
====
Beachten Sie, dass eine Zeitreihe, bestehend aus Daten der letzten Jahrhunderte, verarbeitet wird, ohne auf historische Gegebenheiten Rücksicht zu nehmen.
Dennoch ist der Gregorianische Kalender komplett anwendbar.
====

[[fblangref25-datatypes-inttypes-de]]
== Integer-Datentypen

Die Datentypen `SMALLINT`, `INTEGER` und `BIGINT` werden für Ganzzahlen verschiedener Präzisionen in Dialekt 3 verwendet.
Firebird unterstützt keine vorzeichenlosen (unsigned) Integer.

[[fblangref25-datatypes-smallint]]
=== `SMALLINT`

Der Datentyp `SMALLINT` dient dem Speichern von Kleinstzahlen mit einem Bereich -2^16^ bis 2^16^ - 1, also von -32.768 bis 32.767.

.SMALLINT-Beispiel
[source]
----
CREATE DOMAIN DFLAG AS SMALLINT DEFAULT 0 NOT NULL
  CHECK (VALUE=-1 OR VALUE=0 OR VALUE=1);

CREATE DOMAIN RGB_VALUE AS SMALLINT;
----

[[fblangref25-datatypes-int-de]]
=== `INTEGER`

Daten vom Typ `INTEGER` werden als 4-Byte-Integer repräsentiert.
Der Kurzname dieses Datentyps ist `INT`.
Der gültige Bereich des Datentyps `INTEGER` reicht von -2^32^ bis 2^32^ - 1, also von -2.147.483.648 bis 2.147.483.647.

.INTEGER_Beispiel
[source]
----
CREATE TABLE CUSTOMER (
  CUST_NO INTEGER NOT NULL,
  CUSTOMER VARCHAR(25) NOT NULL,
  CONTACT_FIRST VARCHAR(15),
  CONTACT_LAST VARCHAR(20),
  ...
    PRIMARY KEY (CUST_NO) )
----

[[fblangref25-datatypes-bigint-de]]
=== `BIGINT`

`BIGINT` ist ein SQL:99-konformer, 64-Bit langer Integer-Datentyp, der nur in Dialekt 3 zur Verfügung steht.
Wenn der Client Dialekt 1 verwendet, sendet der Server den auf 32 Bit (Integer) reduzierten Generatorwert.
Bei Dialekt 3 wird der Datentyp `BIGINT` verwendet.

Der Zahlenraum des Datentyps BIGINT liegt im Bereich zwischen -2^63^ und 2^63^ - 1, also von -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807.

=== Hexadezimales Format für INTEGER-Zahlen

Seit Firebird 2.5 können Zahlen vom Datentyp `BIGINT` auch im Hexadezimalen Format geschrieben werden.
Dabei können 9 bis 16 Stellen angegeben werden.
Kürzere Hexadezimalzahlen werden als `INTEGER` interpretiert.

.BIGINT-Beispiel
[source]
----
CREATE TABLE WHOLELOTTARECORDS (
  ID BIGINT NOT NULL PRIMARY KEY,
  DESCRIPTION VARCHAR(32)
);

INSERT INTO MYBIGINTS VALUES (
  -236453287458723,
  328832607832,
  22,
  -56786237632476,
  0X6F55A09D42,       -- 478177959234
  0X7FFFFFFFFFFFFFFF, -- 9223372036854775807
  0XFFFFFFFFFFFFFFFF, -- -1
  0X80000000,         -- -2147483648, ein INTEGER
  0X080000000,        -- 2147483648, ein BIGINT
  0XFFFFFFFF,         -- -1, ein INTEGER
  0X0FFFFFFFF         -- 4294967295, ein BIGINT
);
----

Die hexadezimalen `INTEGER` im obigen Beispiel werden automatisch in den ``BIGINT``-Datentyp gewandelt, bevor sie in die Tabelle eingefügt werden.
Jedoch passiert dies _nachdem_ der numerische Wert bestimmt wurde, wodurch 0x80000000 (8 Stellen) und 0x080000000 (9 Stellen) als unterschiedliche ``BIGINT``-Werte gespeichert werden.

[[fblangref25-datatypes-floattypes-de]]
== Fließkomma-Datentypen

Fließkomma-Datentypen werden nach dem IEEE 754-Standard binär gespeichert und enthalten Vorzeichen, Exponent und Mantisse.
Die Genauigkeit ist dynamisch, je nach verwendetem Speicherformat, welches 4 Bytes für `FLOAT` oder 8 Bytes für `DOUBLE PRECISION` im Speicher belegt.

Angesichts der Besonderheiten bei der Speicherung von Fließkommazahlen in einer Datenbank, werden diese Datentypen nicht zum Speichern von monetären Daten empfohlen.
Aus den gleichen Gründen sollte die Verwendung dieser Felder für Schlüssel und Eindeutigkeiten vermieden werden.

Für die Prüfung von Daten in Spalten mit Fließkomma-Datentypen sollten Ausdrücke auf bestimmte Bereiche, statt auf Übereinstimmungen geprüft werden.

Wenn diese Datentypen in Ausdrücken Verwendung finden, ist äußerste Sorgfalt in Bezug auf die Rundung der Ergebnisse zu legen.

[[fblangref25-datatypes-float-de]]
=== `FLOAT`

Dieser Datentyp hat eine ungefähre Genauigkeit von 7 Stellen nach dem Komma.
Um die korrekte Sicherung der Daten zu gewährleisten, verwenden Sie nur 6 Stellen.

[[fblangref25-datatypes-double]]
=== `DOUBLE PRECISION`

Dieser Datentyp besitzt eine ungefähre Genauigkeit von 15 Stellen.

[[fblangref25-datatypes-fixedtypes]]
== Festkomma-Datentypen

Festkomma-Datentypen sorgen für die Vorhersehbarkeit bei Multiplikations- und Divisionoperationen.
Somit sind sie die erste Wahl zum Speichern monetärer Daten.
Firebird implementiert zwei Festkomma-Datentypen: `NUMERIC` und `DECIMAL`.
Gemäß dem Standard, werden beide Datentypen mit der Anzahl zu speichernder Stellen (Stellen nach dem Komma) begrenzt.

Verschiedene Behandlungen beschränken die Genauigkeit für jeden Typ: Die Genauigkeit für ``NUMERIC``-Felder ist genau "`wie deklariert`", wohingegen ``DECIMAL``-Felder Zahlen akzeptieren, deren Genauigkeit mindestens der Deklaration entspricht.

Beispielsweise definiert `NUMERIC(4, 2)` eine Zahl mit insgesamt 4 Stellen und 2 Nachkommastellen;
das heißt, es können bis zu zwei Stellen vor dem Komma und maximal 2 Stellen nach dem Komma verwendet werden.
Wird die Zahl 3,1415 in ein Feld dieses Datentyps geschrieben, wird der Wert 3,14 gespeichert.

Die Art der Deklaration für Festkomma-Datentypen, zum Beispiel `NUMERIC(__p__, __s__)`, ist beiden Typen gleich.
Zu beachten ist, dass die Skalierung mittels des Arguments _s_, vielmehr die Bedeutung "`Anzahl der Stellen nach dem Dezimalkomma`" hat.
Das Verständnis wie Festkomma-Datentypen ihre Daten speichern und abrufen zeigt auch, warum dies so ist: beim Speichern wird die Zahl mit 10^s^ multipliziert (10 hoch _s_) und als Integer gespeichert;
beim Lesen wird der Integer wieder zurückkonvertiert.

Die Art und Weise wie Festkomma-Daten im DBMS abgelegt werden, hängt von diversen Faktoren ab: Genauigkeit, Datenbankdialekt, Deklartionstyp.

[[fblangref25-dtyp-tbl-realnums-de]]
.Verfahren zum Speichern von reellen Zahlen
[cols="<2,<3,<3,<3", options="header",stripes="none"]
|===
^| Skalierung
^| Datentyp
^| Dialekt 1
^| Dialekt 3

|1 - 4
|`NUMERIC`
|`SMALLINT`
|`SMALLINT`

|1 - 4
|`DECIMAL`
|`INTEGER`
|`INTEGER`

|5 - 9
|`NUMERIC` oder `DECIMAL`
|`INTEGER`
|`INTEGER`

|10 - 18
|`NUMERIC` oder `DECIMAL`
|`DOUBLE PRECISION`
|`BIGINT`
|===

[[fblangref25-datatypes-numeric-de]]
=== `NUMERIC`

.Datenformat für die Deklaration
[listing,subs=+quotes]
----
  NUMERIC
| NUMERIC(_precision_)
| NUMERIC(_precision_, _scale_)
----

.Beispiel der Speicherung
In Bezug auf das obige Beispiel, wird das DBMS ``NUMERIC``-Daten in Abhängigkeit von der angegebenen Genauigkeit (_precision_) und der Skalierung (_scale_) speichern.
Weitere Beispiele:

[listing,subs=+quotes]
----
NUMERIC(4) wird gespeichert als SMALLINT (exakte Daten)
NUMERIC(4,2)                    SMALLINT (Daten * 10^2^)
NUMERIC(10,4) (Dialekt 1)       DOUBLE PRECISION
              (Dialekt 3)       BIGINT (Daten * 10^4^)
----

[CAUTION]
====
Beachten Sie, dass das Speicherformat von der Genauigkeit abhängt.
So können Sie zum Beispiel die Spalte als `NUMERIC(2,2)` definieren, vorausgesetzt ihr Wertebereich liegt zwischen -0.99...0.99.
Dennoch liegt der reale Wertebereich zwischen -327.68..327.67, wodurch deutlich wird, dass der ``NUMERIC(2,2)``-Datentyp  im ``SMALLINT``-Format abgelegt wird.
Gleiches gilt für ``NUMERIC(4,2)`` und ``NUMERIC(3,2)``.
Das heißt, wenn Sie den Wertebereich auf -0.99...0.99 beschränken wollen, müssen Sie einen Constraint hierfür erstellen.
====

[[fblangref25-datatypes-decimal]]
=== `DECIMAL`

.Datenformat für die Deklaration
[listing,subs=+quotes]
----
  DECIMAL
| DECIMAL(_precision_)
| DECIMAL(_precision_, _scale_)
----

.Beispiel der Speicherung
Das Speicherformat in der Datenbank für ``DECIMAL``-Felder ist ähnlich dem von `NUMERIC`, mit dem Unterschied, dass es leichter zu verstehen ist, mit ein paar Beispielen:

[listing,subs=+quotes]
----
DECIMAL(4) gespeichert als INTEGER (exakte Daten)
DECIMAL(4,2)               INTEGER (Daten * 10^2^)
DECIMAL(10,4) (Dialekt 1)  DOUBLE PRECISION
              (Dialekt 3)  BIGINT (Daten * 10^4^)
----

[[fblangref25-datatypes-datetime-de]]
== Datentypen für Datum und Zeit

Die Datentypen `DATE`, `TIME` und `TIMESTAMP` werden zur Arbeit mit Daten verwendet, die Daten und Zeiten beinhalten.
Dialekt 3 unterstützt alle drei Typen, während Dialekt 1 nur `DATE` kennt.
Der Datentyp `DATE` in Dialekt 3 ist "`nur Datum`", wohingegen der Datentyp `DATE` in Dialekt 1 Datum und Tageszeit speichert.
Somit ist dieser equivalent zu `TIMESTAMP` in Dialekt 3.
Dialekt 1 kennt keinen "`nur Datum`"-Typ.

[NOTE]
====
In Dialekt 1 können ``DATE``-Daten alternativ als `TIMESTAMP` definiert werden.
Dies ist die empfohlene Anwendung für neue Definitionen in Dialekt 1-Datenbanken.
====

.Sekundenbruchteile
Werden Sekundenbruchteile in Datums- und Zeitfeldern benötigt, speichert Firebird diese in zehntausendstel Sekunden.
Wird eine geringere Genauigkeit bevorzugt, kann diese explizit als tausendstel, hundertstel oder zehntel Sekunde in Dialekt 3-Datenbanken ab ODS 11 spezifiziert werden.

.Einige nützliche Informationen zur Genauigkeit von Sekundenbruchteilen:
[NOTE]
====
Der Zeitanteil eines ``TIME``- oder ``TIMESTAMP``-Datentyps ist ein 4-Byte WORD, mit Raum für Dezimalsekunden-Genauigkeit.
Die Zeitwerte werden als Dezimalmillisekunden ab Mitternacht gespeichert.
Die derzeitige Genauigkeit dieser Werte, die mittels Zeit(stempel)-Funktionen oder -Variablen gelesen oder geschrieben werden ist: 

* `CURRENT_TIME` nutzt standardmäßig Sekundengenauigkeit und kann bis zu Millisekundengenauigkeit definiert werden: `CURRENT_TIME (0|1|2|3)`
* `CURRENT_TIMESTAMP` Millisekundengenauigkeit.
Genauigkeit von Sekunden bis zu Millisekunden kann mit `CURRENT_TIMESTAMP (0|1|2|3)` definiert werden.
* Literal `'NOW'`: Millisekundengenauigkeit
* Die Funktionen `DATEADD()` und `DATEDIFF()` unterstützen die Genauigkeit bis zu Millisekunden.
Dezimalmillisekunden können definiert werden, diese werden jedoch auf die nächste Ganzzahl gerundet, bevor weitere Operationen durchgeführt werden.
* Die Funktion `EXTRACT()` gibt die Genauigkeit bis auf Dezimalmillisekunden zurück, wenn die Argumente `SECOND` und `MILLISECOND` verwendet werden.
* Für die Literale `TIME` und `TIMESTAMP` akzeptiert Firebird glücklicherweise Genauigkeiten bis zu Dezimalmillisekunden, schneidet (nicht rundet) den Zeitteil jedoch auf die nächste, untere oder gleiche Millisekunde ab.
Versuchen Sie beispielsweise `SELECT TIME '14:37:54.1249' FROM rdb$database`
* werden Sie feststellen, dass die Operatoren '```{plus}```' und '```-```' mit Dezimalmillisekunden-Genauigkeit arbeiten, jedoch nur _innerhalb_ des Ausdrucks.
Sobald irgendwas gespeichert oder nur von `RDB$DATABASE` abgefragt (SELECTed) wird, wandelt sich die Genauigkeit zu Millisekunden.

Die Genauigkeit auf Basis von Dezimalmillisekunden ist selten und wird derzeit nicht in Spalten oder Variablen gespeichert.
Obwohl Firebird die Werte von `TIME` und den Zeitteil von `TIMESTAMP` als Dezimalmillisekunden (10^-4^ Sekunden) seit Mitternacht speichert, kann die Genauigkeit von Sekunden zu Millisekunden variieren.
====

[[fblangref25-datatypes-date-de]]
=== `DATE`

Der Datentyp `DATE` in Dialekt 3 speichert nur das Datum ohne Zeitangabe.
Der verfügbare Bereich reicht vom 1. Januar 0001 bis zum 31. Dezember 9999.

In Dialekt 1 gibt es keinen "`nur Datum`"-Datentyp. 

[TIP]
====
In Dialekt 1, erhalten Datums-Literale ohne Zeitangabe, genauso wie `'TODAY'`, `'YESTERDAY'` und `'TOMORROW'` automatisch einen Null-Zeitteil.

Sollte es für Sie wichtig sein, aus welchem Grund auch immer, einen Zeitstempel-Literal mit einem expliziten Null-Zeitteil in Dialekt 1 zu speichern, wird die Datenbank ein Literal wie `'25.12.2016 00:00:00.0000'` akzeptieren.
Der Wert `'25.12.2016'` hätte jedoch den gleichen Effekt, mit weniger Tastenschlägen!
====

[[fblangref25-datatypes-time-de]]
=== `TIME`

Der Datentyp `TIME` ist nur in Dialekt 3 verfügbar.
Er speichert die Tageszeit im Bereich von 00:00:00.0000 bis 23:59:59.9999.

Sollten Sie den Zeitteil eines `DATE` in Dialekt 1 benötigen, können Sie die  Funktion `EXTRACT` verwenden.

.Beispielverwendung von `EXTRACT`
[source]
----
EXTRACT (HOUR FROM DATE_FIELD)
EXTRACT (MINUTE FROM DATE_FIELD)
EXTRACT (SECOND FROM DATE_FIELD)
----

[[fblangref25-datatypes-timestamp-de]]
=== `TIMESTAMP`

Der Datentyp `TIMESTAMP` ist in Dialekt 1 und 3 verfügbar.
Er besteht aus zwei 32-Bit-Teilen -- einem Datums- und einem Zeitteil -- womit eine Struktur gebildet wird, die sowohl Datum wie auch Tageszeit aufnimmt.
Der Datentyp ist identisch mit `DATE` in Dialekt 1.

Die Funktion `EXTRACT` arbeitet für `TIMESTAMP`	genauso wie für `DATE` in Dialekt 1.

[[fblangref25-datatypes-datetimeops-de]]
=== Operationen, die Datums- und Zeitwerte verwenden

Das Verfahren zum Speichern der Datums- und Zeitwerte macht es möglich, diese als Operanden in arithmetischen Operationen zu verwenden.
Gespeichert, wird ein Datumswert als Zahl seit dem "`Datum Null`" -- 17. November 1898 -- repräsentiert, ein Zeitwert als Anzahl der Sekunden (unter Berücksichtigung der Sekundenbruchteile) seit Mitternacht.

Ein Beispiel ist das Subtrahieren eines früheren Datum, einer Zeit oder eines Zeitstempels von einem späteren, was in einm Zeitintervall, in Tagen und Bruchteilen von Tagen resultiert.

[[fblangref25-dtyp-tbl-dateops-de]]
.Arithmetische Operationen für Datums- und Zeitdatentypen
[cols="<1,^1,<1,<2", options="header",stripes="none"]
|===
^| Operand 1
^| Operation
^| Operand 2
^| Ergebnis

|`DATE`
|{plus}
|`TIME`
|`TIMESTAMP`

|`DATE`
^|{plus}
|Numerischer Wert `n`
|`DATE` um _n_ ganze Tage erhöht.
Gebrochene Werte werden auf die nächste Ganzzahl gerundet (nicht abgeschnitten).

|`TIME`
|{plus}
|`DATE`
|`TIMESTAMP`

|`TIME`
|{plus}
|Numerischer Wert `n`
|`TIME` um _n_ Sekunden erhöht.
Bruchteile werden berücksichtigt.

|`TIMESTAMP`
|{plus}
|Numerischer Wert `n`
|`TIMESTAMP`, wobei das Datum um die Anzahl der Tage und der Teil eines Tages durch die Zahl _n_ repräsentiert wird -- somit wird "```+ 2.75```" das Datum um 2 Tage und 18 Stunden weiterstellen wird

|`DATE`
|-
|`DATE`
|Anzahl der vergangenen Tage innerhalb des Bereichs `DECIMAL(9, 0)`

|`DATE`
|-
|Numerischer Wert `n`
|`DATE` um _n_ ganze Tage reduziert.
Gebrochene Werte werden auf die nächste Ganzzahl gerundet (nicht abgeschnitten).

|`TIME`
|-
|`TIME`
|Anzahl der vergangenen Sekunden, innerhalb des Bereichs `DECIMAL(9, 4)`

|`TIME`
|-
|Numerischer Wert `n`
|`TIME` um _n_ Sekunden reduziert.
Bruchteile werden berücksichtigt.

|`TIMESTAMP`
|-
|`TIMESTAMP`
|Anzahl der Tage und der Tageszeit, innerhalb des Bereichs `DECIMAL(18, 9)`

|`TIMESTAMP`
|-
|Numerischer Wert `n`
|`TIMESTAMP` wobei das Datum sich auf der Anzahl der Tage und der Tageszeit beruht, die durch die Zahl _n_ repräsentiert wird -- somit wird "```- 2.25```" das Datum um 2 Tage und 6 Stunden reduzieren.
|===

.Hinweise
[NOTE]
====
Der Datentyp `DATE` ist als `TIMESTAMP` in Dialekt 1 zu betrachten.
====

.Siehe auch
<<fblangref25-functions-scalarfuncs-dateadd-de,`DATEADD`>>, <<fblangref25-functions-scalarfuncs-datediff-de,`DATEDIFF`>>

[[fblangref25-datatypes-chartypes-de]]
== Zeichendatentypen

Für die Arbeit mit Zeichendaten bietet Firebird die Datentypen `CHAR` mit Festlänge und `VARCHAR` mit variabler Zeichenlänge.
Die Maximalgröße der hiermit speicherbaren Daten beträgt 32.767 Bytes für `CHAR` und 32.765 Bytes für `VARCHAR`.
Das Maximum der möglichen _Zeichen_, das in diese Grenzen passt, hängt vom verwendeten Zeichensatz (`CHARACTER SET`) ab.
Die Sortiermethode `COLLATE` wirkt sich nicht auf die Maximalgrenze aus, wohingegen sie durchaus die maximale Größe eines Indexes auf dieser Spalte beeinflussen kann.

Wurde während der Definition eines Zeichenobjektes kein expliziter Zeichensatz festgelegt, wird der Standardzeichensatz der Datenbank verwendet.
Wurde für die Datenbank kein Standardzeichensatz festgelegt, erhält das Feld den Zeichensatz `NONE`.

[[fblangref25-datatypes-chartypes-unicode-de]]
=== Unicode

Die meisten aktuellen Entwicklertools unterstützen Unicode, welches in Firebird mit den Zeichensätzen `UTF8` und `UNICODE_FSS` integriert ist.
`UTF8` bietet Sortierungen für viele Sprachen.
`UNICODE_FSS` ist deutlich begrenzter und wird hauptsächlich intern durch Firebird für das Speichern von Metadaten verwendet.
Beachten Sie, dass ein ``UTF8``-Zeichen bis zu 4 Bytes beanspruchen kann, wodurch die Größe von ``CHAR``-Feldern auf 8.191 Zeichen reduziert werden kann (32.767/4).

[NOTE]
====
Der genaue Wert der "`Bytes pro Zeichen`" hängt vom Bereich des Zeichens ab.
Nicht-akzentuierte Latin-Buchstaben beanspruchen 1 Byte, kyrillische Zeichen mit WIN1251-Enkodierung beanspruchen 2 Bytes, andere Zeichenenkodierungen können bis zu 4 Bytes beanspruchen.
====

Der in Firebird implementierte ``UTF8``-Zeichensatz, unterstützt die aktuellste Version des Unicode-Standards.
Somit ist dieser für internationale Datenbanken empfohlen.

[[fblangref25-datatypes-chartypes-client-de]]
=== Client-Zeichensatz

Während der Arbeit mit Zeichenketten, ist es notwendig, den Zeichensatz des Clients zu berücksichtigen.
Sollte eine Diskrepanz zwischen den Zeichensätzen der gespeicherten Daten und der Clientverbindung existieren, werden Ausgaben für Textfelder automatisch neu enkodiert.
Dies gilt für Daten, die vom Client zum Server gesendet werden und anders herum.
Wurde die Datenbank beispielsweise mit `WIN1251` enkodiert, der Client verwendet  jedoch `KOI8R` oder `UTF8`, stellt sich die Diskrepanz transparent dar.

[[fblangref25-datatypes-chartypes-special-de]]
=== Spezielle Zeichensätze

.Zeichensatz `NONE`
Der Zeichensatz `NONE` ist ein _Spezialzeichensatz_ in Firebird.
Er kann so beschrieben werden, als wäre jedes Byte Teil einer Zeichenkette, die jedoch keine Angaben zur Beschreibung eines Zeichens macht: Zeichenenkodierung, Sortierung, Klein- und Großschreibung, etc. sind einfach unbekannt.
Es liegt in der Verantwortung der Client-Anwendung mit den Daten umzugehen und die richtigen Mittel bereitzustellen, um die Folge von Bytes in irgendeiner Weise interpretieren zu können, die für die Anwendung sinnvoll sind und für den Menschen lesbar.

.Zeichensatz `OCTETS`
Daten der ``OCTETS``-Enkodierung werden als Bytes behandelt, die nicht direkt als Zeichen interpretiert werden.
`OCTETS` bieten einen Weg um Binärdaten zu speichern, was die Ergebnisse einiger Firebird-Funktionen sein könnten.
Die Datenbank weiß nicht was mit einer Zeichenkette aus Bits in `OCTETS` zu tun ist, außer diese zu speichern und abzufragen.
Auch hier ist wieder der Client verantwortlich für die Validierung der Daten und diese sowohl der Anwendung wie auch dem Benutzer in verständlicher Form anzuzeigen.
Dies gilt auch für Ausnahmen, die durch die Enkodierung und Dekodierung verursacht werden.

[[fblangref25-datatypes-chartypes-collation-de]]
=== `COLLATION`

Jeder Zeichensatz hat eine Standardsortiermethode (`COLLATE`).
Üblicherweise stellt diese nicht mehr bereit als die Reihenfolge basierend auf einem numerischen Code der Zeichen und einer Basiszuordnung der Klein- und Großbuchstaben.
Wird ein Verhalten außerhalb der Collation benötigt und eine alternative Methode für den Zeichensatz unterstützt, kann eine ``COLLATE __Sortier__``-Klausel in der Felddefinition verwendet werden.

Eine ``COLLATE __Sortier__``-Klausel kann auch in anderen Zusammenhängen neben der Spaltendefinition angewandt werden.
Für größer-als-/kleiner-als-Vergleiche, kann sie in die ``WHERE``-Klausel des ``SELECT``-Statements aufgenommen werden.
Wird eine speziell alphabetisch geordnete oder Groß- und Kleinschreibungsinsensitive Ausgabe benötigt, und sollte eine passende Collation existieren, dann kann die ``COLLATE``-Klausel auch in der ``ORDER BY``-Klausel verwendet werden.

[[fblangref25-datatypes-chartypes-caseinsenstv-de]]
==== Groß- und Kleinschreibungsinsensitive Suche

Für die Groß- und Kleinschreibungsinsensitive Suche, kann die Funktion `UPPER` verwendet werden, damit das Suchargument und der die gesuchte Zeichenkette in Großbuchstaben gewandelt werden, bevor der Vergleich stattfindet:

[source]
----
…
where upper(name) = upper(:flt_name)
----

Für Zeichenketten eines Zeichensatzes, der keine Groß- und Kleinschreibungsinsensitive Sortierung bereitstellt, können sie die Sortierung anwenden, um das Suchargument und die gesuchte Zeichenkette direkt miteinander zu vergleichen.
Beispielsweise ist unter dem Zeichensatz `WIN1251` die Sortierung `PXW_CYRL` Groß- und Kleinschreibungsinsensitiv.
Somit gilt:

[source]
----
…
WHERE FIRST_NAME COLLATE PXW_CYRL >= :FLT_NAME
…
ORDER BY NAME COLLATE PXW_CYRL
----

.Vgl. auch
<<fblangref25-commons-predcontaining-de,`CONTAINING`>>

[[fblangref25-datatypes-chartypes-utf8collations-de]]
==== ``UTF8``-Collation

Die folgende Tabelle zeigt mögliche Sortiermethoden für den ``UTF8``-Zeichensatz.

[[fblangref25-dtyp-tbl-utfcollats-de]]
.Collation für den Zeichensatz UTF8
[cols="<1,<3", options="header",stripes="none"]
|===
^| Sortierung
^| Merkmale

|`UCS_BASIC`
|Sortierung arbeitet abhängig von der Position des Zeichens in der Tabelle (binär).
Hinzugefügt in Firebird 2.0

|`UNICODE`
|Sortierung arbeitet abhängig vom UCA-Algorithmus (Unicode Collation Algorithm) (alphabetisch).
Hinzugefügt in Firebird 2.0

^|`UTF8`
|Die Standard-Sortierung, binär, identisch zu ``UCS_BASIC``, welche im Rahmen der SQL-Kompatibilität hinzugefügt wurde.

^|`UNICODE_CI`
|Groß- und Kleinschreibungsinsensitive Sortierung, arbeitet ohne Groß- und Kleinschreibung zu berücksichtigen.
Hinzugefügt in Firebird 2.1

^|`UNICODE_CI_AI`
|Groß- und Kleinschreibungsunabhängige, akzentunabhängige Sortierung, die weder Groß- und Kleinschreibung noch Akzentuierung von Zeichen berücksichtigt.
Arbeitet alphabetisch.
Hinzugefügt in Firebird 2.5
|===

.Beispiel
Ein Beispiel einer Sortierung für den UTF8-Zeichensatz ohne Berücksichtigung  der Groß- und Kleinschreibung oder Akzentuierung der Zeichen (ähnlich zu ``COLLATE PXW_CYRL``).

[source]
----
...
ORDER BY NAME COLLATE UNICODE_CI_AI
----

[[fblangref25-datatypes-chartypes-charindxs-de]]
=== Zeichenindizes

In Firebird-Versionen vor 2.0 kann es zu Problemen beim Erstellen eines Index für Zeichenspalten kommen, die eine außergewöhnliche Collation nutzen: die Länge eines indizierten Feldes ist auf 252 Bytes beschränkt, sofern kein `COLLATE` spezifiziert wurde, andernfalls sind es 84 Bytes.
Multi-Byte-Zeichensätze schränken die Indizes weiter ein.

Ab Firebird 2.0 beschränkt sich die Indexlänge auf ein Viertel der Seitengröße (page size), z.B. von 1.024 bis 4.096 Bytes.
Die größtmögliche Länge einer indizierten Zeichenkette liegt bei 9 Bytes weniger als die Viertel-Seiten-Grenze.

.Berechnung der maximalen Länge eines indizierten Zeichenfeldes
Die folgende Formel berechnet der maximale Länge eines indizierten Zeichenfeldes (in Zeichen):

[source]
----
max_char_length = FLOOR((page_size / 4 - 9) / N)
----

wobei N die Anzahl der Bytes pro Zeichen im Zeichensatz darstellt. 

Die folgende Tabelle zeigt die Maximallänge einer indizierten Zeichenkette (in Zeichen),  abhängig von der Seitengröße und Zeichensatz.
Die Maximallänge wurde mittels der o.a. Formel berechnet.

[[fblangref25-dtyp-tbl-charindxsz-de]]
.Maximale Indexlänge nach Seitengröße und Zeichengröße
[cols=">1,>1,>1,>1,>1,>1",stripes="none"]
|===
.2+^h| Seitengröße (Page Size)
5+^h| Maximale Länge einer indizierten Zeichenkette für ein Zeichen, Bytes / Zeichen

^h|1
^h|2
^h|3
^h|4
^h|6

|4.096
|1.015
|507
|338
|253
|169

|8.192
|2.039
|1.019
|679
|509
|339

|16.384
|4.087
|2.043
|1.362
|1.021
|682
|===

[NOTE]
====
Mit Collations ("`++_CI++`"), die Groß- und Kleinschreibungsinsensitiv sind, wird ein Zeichen im _Index_ nicht 4, sondern 6 Bytes, beanspruchen.
Hierdurch wird die maximale Schlüssellänge für eine Seitengröße von zum Beispiel 4.096 Bytes auf 169 Zeichen begrenzt. 
====

.Vergleichen Sie auch
<<fblangref25-ddl-db-create-de,`CREATE DATABASE`>>, <<fblangref25-datatypes-chartypes-collation-de>>, <<fblangref25-dml-select-de,`SELECT`>>, <<fblangref25-dml-select-where-de,`WHERE`>>, <<fblangref25-dml-select-groupby-de,`GROUP BY`>>, <<fblangref25-dml-select-orderby-de,`ORDER BY`>>

[[fblangref25-datatypes-chartypes-detail-de]]
=== Zeichendatentypen im Detail

[[fblangref25-datatypes-chartypes-char-de]]
==== `CHAR`

`CHAR` ist ein Festlängen-Datentyp.
Ist die eingegebene Anzahl der Zeichen kleiner als die definierte Länge, werden Leerzeichen zu dem Feld hinzugefügt.
Grundsätzlich muss das Füllzeichen kein Leerzeichen sein: dies hängt vom Zeichensatz ab.
So ist das Füllzeichen für den ``OCTETS``-Zeichensatz beispielsweise die Null.

Der volle Name dieses Datentyps ist `CHARACTER`, es ist jedoch nicht erforderlich volle Namen zu verwenden und die Leute tun dies auch sehr selten.

Daten für Festlängen-Zeichen können verwendet werden, um Codes zu speichern, deren Länge standardisiert ist und die eine definierte "`Breite`" besitzen.
Ein Beispiel hierfür ist ein EAN13-Barcode -- 13 Zeiche, alle gefüllt.

.Syntax für die Deklaration
[listing,subs=+quotes]
----
{ CHAR | CHARACTER } [ (_length_) ]
  [CHARACTER SET <set>] [COLLATE <name>]
----

[NOTE]
====
Wurde keine Länge (_length_) angegeben, wird 1 verwendet.

Eine gültige Länge (_length_) befindet sich im Bereich von 1 bis maximal so vielen Zeichen, die in 32,767 Bytes passen.
====

[[fblangref25-datatypes-chartypes-varchar-de]]
==== `VARCHAR`

`VARCHAR` ist der Standarddatentyp zum Speichern von Texten variabler Länge.
Die Zeichen müssen in 32.765 Bytes passen.
Die Speicherstruktur ist identisch mit der aktuellen Datengröße plus 2 Bytes.

Alle Zeichen, die von der Client-Anwendung an die Datenbank gesendet werden, werden als sinnvoll erachtet, was auch für führende und nachrangige Leerzeichen gilt.
Jedoch werden angestellte Leerzeichen nicht gespeichert: Sie werden wiederhergestellt, sobald die Daten abgerufen werden.
Die Zeichenkette wird dann bis zu der gespeicherten Länge mit dem Leerzeichen aufgefüllt.

Der volle Name dieses Datentyps ist `CHARACTER VARYING`.
Eine weitere  Variante dieses Namens wird auch mit `CHAR VARYING` bezeichnet.

.Syntax
[listing,subs=+quotes]
----
{ VARCHAR | CHAR VARYING | CHARACTER VARYING } (_length_)
  [CHARACTER SET <set>] [COLLATE <name>]
----

[[fblangref25-datatypes-chartypes-nchar-de]]
==== `NCHAR`

`NCHAR` ist ein Festlängen-Datentyp.
Der ``ISO8859_1``-Zeichensatz ist vordefiniert.
In allen anderen Bezügen verhält  sich dieser Datentyp identisch zu `CHAR`.

.Syntax
[listing,subs=+quotes]
----
{ NCHAR | NATIONAL { CHAR | CHARACTER } } [ (_length_) ]
----

Für variable Längen gibt es einen ähnlichen Datentyp: `NATIONAL CHARACTER VARYING`.

[[fblangref25-datatypes-bnrytypes-de]]
== Binärdatentypen

``BLOB``s (Binary Large Objects) nutzen komplexe Strukturen, um Texte und binäre Daten beliebiger Länge zu speichern.
Diese Daten sind häufig sehr groß.

.Syntax
[listing]
----
BLOB [SUB_TYPE <subtype>]
  [SEGMENT SIZE <segment size>]
  [CHARACTER SET <character set>]
  [COLLATE <collation name>]
----

.Gekürzte Syntax
[listing]
----
BLOB (<segment size>)
BLOB (<segment size>, <subtype>)
BLOB (, <subtype>)
----

.Segmentgröße
Das Spezifizieren von BLOB-Segmenten ist ein Rückschritt in vergangene Zeiten, als die Programme zur Verarbeitung von BLOB-Daten noch mit Hilfe des __gpre__-Pre-Compilers in C (Embedded SQL) geschrieben wurden.
Heutzutage ist dies irrelevant.
Die Segmentgröße für BLOB-Daten wird auf Client-Seite festgelegt und ist üblicherweise größer als die Größe der Datenseite.

[[fblangref25-datatypes-bnrytypes-sub-de]]
=== `BLOB` Untertypen

Der optionale Parameter `SUB_TYPE` gibt die Art der zu schreibenden Felddaten an.
Firebird unterstützt zwei vordefinierte Untertypen für die Datenspeicherung:

Untertyp 0: `BINARY`::
Wurde kein Untertyp angegeben, wird von einem unspezifizierten Datentyp ausgegangen und somit als Standard `SUB_TYPE 0` verwendet.
Der Alias für diesen Untertyp ist `BINARY`.
Dies ist der Untertyp, der bei der Arbeit mit jeglichen Binärdaten Verwendung findet: Bilder, Audio, Textdokumente, PDFs usw.

Untertyp 1: `TEXT`::
Untertyp 1 besitzt den Alias `TEXT`, welcher in Deklarationen und Definitionen  verwendet werden kann.
Zum Beispiel `BLOB SUB_TYPE TEXT`.
Dies ist ein spezieller Untertyp zum Speichern von Textdaten, die zu lang für die üblichen  Zeichenketten sind.
Ein Zeichensatz (`CHARACTER SET`) kann definiert werden, sofern dieser vom Standard der Datenbank abweicht.
Seit Firebird 2.0 ist die Angabe der ``COLLATE``-Klausel ebenfalls gültig.

.Benutzerdefinierte Untertypen
Weiterhin ist es möglich eigene Untertypen zu definieren, wofür der Zahlenbereich von -1 bis -32.768 reserviert ist.
Selbstdefinierte Untertypen im positiven Zahlenbereich werden nicht unterstützt, da Firebird diese, von 2 aufwärts, für  interne Untertypen in den Metadaten verwendet.

[[fblangref25-datatypes-bnrytypes-more-de]]
=== `BLOB` Specifics

.Größe
Die Maximalgröße eines ``BLOB``-Feldes ist auf 4GB begrenzt, unanhängig vom darunterliegenden 32- oder 64-Bit-Server.
(Die internen Strukturen im Zusammenhang mit ``BLOB``s nutzen ihre eigenen 4-Byte-Zähler.)
Für Seitengrößen (page size) von 4 KB (4096 Bytes) ist die Maximalgröße geringer -- etwas weniger als 2 GB.

.Operationen und Ausdrücke
Text-BLOBs beliebiger Länge und jeder Zeichensatz -- inklusive Multi-Byte -- können Operanden für praktisch jede Art von Statement oder interne Funktionen sein.
Die folgenden Operatoren werden vollständig unterstützt:

[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|=
|(Zuweisung)
|=, <>, <, <=, >, >=
|(Vergleich)
|{vbar}{vbar}
|(Verkettung)
|`BETWEEN`,
|`IS [NOT] DISTINCT FROM`,
|`IN`,
|`ANY` {vbar} `SOME`,
|`ALL`
|{nbsp}
|===

Teilunterstützt: 

* Ein Fehler wird ausgeworfen, wenn das Suchkritierium größer als 32 KB ist:
+
[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|`STARTING [WITH]`,
|`LIKE`,
|`CONTAINING`
|{nbsp}
|===
* Aggregations-Klauseln funktionieren nicht auf Basis der eigentlichen Feldwerte, jedoch mit den BLOB-IDs.
Dementsprechend gibt es ein paar Macken:
+
[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|`SELECT DISTINCT`
|Gibt fälschlicherweise mehrere NULL-Werte zurück, sofern diese vorhanden sind.
|`ORDER BY`
|--
|`GROUP BY`
|===
* Verkettet die gleichen Zeichenketten, wenn sie aufeinanderfolgen, jedoch nicht, wenn sie voneinader entfernt liegen.

.``BLOB``-Speicherung
* Standardmäßig wird ein regulärer Datensatz für jeden BLOB erstellt und in der Datenseite (data page), die hierfür zugewiesen wurde, gespeichert.
Passt das gesamte BLOB in diese Seite, spricht man auch von einem _Level 0 BLOB_.
Die Seitenzahl dieses speziellen Datensatzes wird im Tabellendatensatz gespeichert und belegt 8 Bytes.
* Passt das BLOB hingegen nicht in die Datenseite, wird der Inhalt auf separate Seiten verteilt, die exklusive hierfür belegt werden (BLOB-Seiten).
Die Seitennummern werden in den BLOB-Datensatz geschrieben.
Hierbei spricht man von einem _Level 1 BLOB_.
* Falls das Array der Seitenzahlen, die die BLOB-Daten enthalten nicht in die Datenseite passen, wird diese Array auf separate BLOB-Seiten verteilt, während die Seitenzahlen dieser Seiten in den BLOB-Datensatz geschrieben werden.
Hierbei spricht man von einem _Level 2 BLOB_.
* Level größer als 2 werden nicht unterstützt.

.Vergleichen Sie auch
<<fblangref25-ddl-filter-de,`FILTER`>>, <<fblangref25-ddl-filter-declare-de,`DECLARE FILTER`>>

[[fblangref25-datatypes-array-de]]
=== `ARRAY` Type

Die Unterstützung von Arrays im Firebird DBMS ist eine Abkehr vom traditionellen relationalen Modell.
Unterstützung von Arrays im DBMS könnte es einfacher machen, Datenverarbeitungsaufgaben mit großen Mengen von ähnlichen Daten zu lösen.

Array werden in Firebird mittels speziellen ``BLOB``-Typen gespeichert.
Arrays können ein- und multidimensional sein.
Sie dürfen aus beliebigen Datentypen, außer  `BLOB` und `ARRAY` bestehen.

.Beispiel
[source]
----
CREATE TABLE SAMPLE_ARR (
  ID INTEGER NOT NULL PRIMARY KEY,
  ARR_INT INTEGER [4]
);
----

Dieses Beispiel erstellt eine Tabelle mit einem Array-Feld, welches 4 Ganzzahlenelemente (Integer) enthält.
Die Indizes werden von 1 bis 4 gezählt.

[[fblangref25-datatypes-array-bounds-de]]
==== Festlegen expliziter Dimensionsgrenzen

Standardmäßig sind die Indizes 1-basierend -- Zählung begind bei 1.
Um die Ober- und Untergrenzen explizit festzulegen, nutzen Sie folgende Syntax:

[listing]
----
'[' <lower>:<upper> ']'
----

[[fblangref25-datatypes-array-adddim-de]]
==== Weitere Dimensionen hinzufügen

Eine neue Dimension wird nach dem Komma in der Syntax hinzugefügt.
In diesem Beispiel erstellen wir eine Tabelle mit einem zweidimensionalen Array, mit der unteren Indizegrenze von 0 beginnend:

[source]
----
CREATE TABLE SAMPLE_ARR2 (
  ID INTEGER NOT NULL PRIMARY KEY,
  ARR_INT INTEGER [0:3, 0:3]
);
----

Das DBMS bietet, im Vergleich mit anderen Sprachen oder Werkzeugen, nicht viele Möglichkeiten zur Arbeit mit Array-Inhalten.
Die Datenbank `employee.fdb`, die im Unterverzeichnis `../examples/empbuild` jedes Firebird-Pakets gefunden werden kann, beinhaltet eine beispielhafte Gespeicherte Prozedur (stored procedure), die einfache Routinen im Umgang mit Arrays zeigt:

==== PSQL Quelltext für `SHOW_LANGS`, eine Prozedur zur Arbeit mit Arrays

[source]
----
CREATE OR ALTER PROCEDURE SHOW_LANGS (
  CODE VARCHAR(5),
  GRADE SMALLINT,
  CTY VARCHAR(15))
RETURNS (LANGUAGES VARCHAR(15))
AS
  DECLARE VARIABLE I INTEGER;
BEGIN
  I = 1;
  WHILE (I <= 5) DO
  BEGIN
    SELECT LANGUAGE_REQ[:I]
    FROM JOB
    WHERE (JOB_CODE = :CODE)
      AND (JOB_GRADE = :GRADE)
      AND (JOB_COUNTRY = :CTY)
      AND (LANGUAGE_REQ IS NOT NULL))
    INTO :LANGUAGES;

    IF (LANGUAGES = '') THEN
    /* PRINTS 'NULL' INSTEAD OF BLANKS */
      LANGUAGES = 'NULL';
    I = I +1;
    SUSPEND;
  END
END
----

Reichen die beschriebenen Features für Ihre Aufgaben aus, können Sie darüber nachdenken, Arrays in Ihrem Projekt zu verwenden.
Derzeit planen die Firebird-Entwickler keine Verbesserungen im Bereich Arrays.

[[fblangref25-datatypes-special-de]]
== Spezialdatentypen

"`Spezial`"-Datentypen ...

[[fblangref25-datatypes-special-sqlnull-de]]
=== ``SQL_NULL``-Datentyp

Der Datentyp `SQL_NULL` besitzt keinen Wert, sondern nur einen Status: null (`NULL`) oder nicht null (`NOT NULL`).
Er ist nicht verfügbar als Datentyp zur Deklaration von Tabellenfeldern, PSQL-Variablen oder als Parameterbeschreibung.
Dieser Datentyp wurde eingeführt, um untypiserte Parameter in Ausdrücken  mit dem ``IS NULL``-Prädikat zu verwenden.

Ein Auswertungsproblem tritt auf, wenn optionale Filter verwendet werden, um Abfragen der folgenden Art zu erstellen:

[source]
----
WHERE col1 = :param1 OR :param1 IS NULL
----

Nach der Verarbeitung auf API-Ebene, sieht die Abfrage folgendermaßen aus:

[source]
----
WHERE col1 = ? OR ? IS NULL
----

Dies ist der Fall, wenn ein Entwickler eine SQL-Abfrage schreibt und der Auffassung ist, dass sich `:param1` wie eine _Variable_ verhält, sodass er diese auf zwei Arten verwenden kann.
Jedoch erhält sich die Abfrage auf der API-Ebene zwei unabhängige _Parameter_.
Der Server kann den Typen des zweiten Parameters nicht ermitteln, da dieser in Verbindung mit `IS NULL` steht.

Der Datentyp `SQL_NULL` löst dieses Problem.
Wannimmer die Datenbank auf das ``'? IS NULL'``-Prädikat in einer Abfrage stößt, weist sie dem Parameter den Typ  `SQL_NULL` zu, was wiederum dazu führt, dass dieser Parameter nur auf "`Nullbarkeit`" geprüft werden muss und der Datentyp bzw. der Wert nicht wichtig ist.

Das folgende Beispiel demonstriert die praktische Verwendung.
Es verwendet 2 benannte Parameter -- sagen wir, `:size` und `:colour` -- welche, im Beispiel, zwei Werte vom Bildschirmtext oder Drop-Down-Listen erhalten.
Jeder dieser Parameter korrospondiert mit zwei Parametern in der Abfrage.

[source]
----
SELECT
  SH.SIZE, SH.COLOUR, SH.PRICE
FROM SHIRTS SH
WHERE (SH.SIZE = ? OR ? IS NULL)
  AND (SH.COLOUR = ? OR ? IS NULL)
----

Um zu verstehen was hier passiert, muss der Leser mit der Firebird-API sowie der Übergabe von Parametern in der XSQLVAR-Struktur vertraut sein -- was unter der Haube passiert, ist nicht von Belang, sofern keine Treiber oder Anwendungen geschrieben werden, die die "`nackte`"	API verwenden.

Die Anwendung übergibt die parameteresierte Abfrage an den Server in der üblichen ``?``-Form.
Paare "`identischer`" Parameter können nicht in einem zusammengeführt werden, somit werden für zwei optionale Filter, beispielsweise, 4 Parameter benötigt: einer für jede `?` in unserem Beispiel.

Nach dem Aufruf von `isc_dsql_describe_bind()`, wird der SQLTYPE des zweiten und vierten Parameters auf `SQL_NULL` gesetzt.
Firebird hat keine Kenntnis ihrer speziellen Verbindung zu dem ersten bzw. dritten Parameter: hierfür ist allein die Anwendung verantwortlich.

Sobald die Werte für Größe (size) und Farbe (colour) festgelegt wurden (oder auch nicht), und die Abfrage ausgeführt wurde, wird jedes Paar der XSQLVARs folgendermaßen ausgefüllt:

Benutzer hat einen Wert angegeben::
Erster Parameter (vergleiche Werte): Lege `{asterisk}sqldata` auf den übergebenen Wert fest und `{asterisk}sqlind` auf `0` (für `NOT NULL`)
+
Zweiter Parameter (teste auf `NULL`): Lege `sqldata` auf `null` fest (null-Zeiger, nicht SQL `NULL`) und `{asterisk}sqlind` auf `0` (für `NOT NULL`)

Benutzer hat das Feld leer gelassen::
Beide Parameter: Setze `sqldata` auf `null` (null-Zeiger, nicht SQL `NULL`) und `{asterisk}sqlind` auf `-1` (repräsentiert `NULL`)

In anderen Worten: Der Parameter zum Vergleich des Wertes wird wie üblich gesetzt.
Der ``SQL_NULL``-Parameter wird genauso verwendet, mit dem Unterschied, dass `sqldata` über die gesamte Zeit hinweg `null` bleibt.

[[fblangref25-datatypes-conversion-de]]
== Datentyp-Konvertierungen

Wenn Sie einen Ausdruck erstellen oder eine Operation spezifizieren, sollte das Ziel sein, kompatible Datentypen als Operanden zu verwenden.
Wenn die Notwendigkeit besteht, verschiedene Datentypen zu verwenden, müssen Sie einen Weg finden, diese inkompatiblen Typen vor der eigentlichen Operation zu konvertieren.
Wenn Sie mit Dialekt 1 arbeiten, kann dies zum Problem werden.

[[fblangref25-datatypes-convert-explicit-de]]
=== Explizite Datentyp-Konvertierung

Die ``CAST``-Funktion ermöglicht die explizite Konvertierung  zwischen diversen Datentypen.

.Syntax
[listing,subs=+quotes]
----
CAST ( { <value> | NULL } AS <data_type>)

<data_type> ::=
    <sql_datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN __relname__.__colname__
----

[[fblangref25-datatypes-convert-domain-de]]
==== Casting zu einer Domain

Beim Ausführen eines Cast zu einer Domain, werden alle Constraints berücksichtigt, die hierfür deklariert wurden, z.B. ``NOT NULL``- oder ``CHECK``-Constraints.
Wenn der Wert (_value_) diese Prüfung nicht besteht, schlägt der Cast fehl.

Wird `TYPE OF` zusätzlich angegeben -- Umwandlung auf den Basistyp -- , werden alle Domain-Contraints während des Cast ignoriert.
Wird `TYPE OF` mit einem Zeichentyp (`CHAR/VARCHAR`) verwendet, werden der Zeichensatz und die Collation beibehalten.

[[fblangref25-datatypes-convert-typeof-de]]
==== Casting zu `TYPE OF COLUMN`

Werden Operanden auf den Datentyp einer Spalte konvertiert, kann die angegebene Spalte aus einer Tabelle oder View stammen.

Nur der Typ der Spalte selbst wird verwendet.
Für Zeichentypen wird der Zeichensatz bei der Konvertierung inkludiert, jedoch nicht die Collation.
Die Constraints und Vorgabewerte der Quellspalte werden nicht angewandt.

.Beispiel
[source]
----
CREATE TABLE TTT (
  S VARCHAR (40)
  CHARACTER SET UTF8 COLLATE UNICODE_CI_AI
);
COMMIT;

SELECT
  CAST ('I have many friends' AS TYPE OF COLUMN TTT.S)
FROM RDB$DATABASE;
----

[[fblangref25-datatypes-convert-conversions-de]]
==== Mögliche konvertierungen für die ``CAST``-Funktion

[[fblangref25-dtyp-tbl-conversions-de]]
.Konvertierungen mit CAST
[cols="<1,<3", options="header",stripes="none"]
|===
^| von Datentyp
<| zu Datentyp

|Numerische Typen
|Numerische Typen, `[VAR]CHAR`, `BLOB`

|`[VAR]CHAR`
|`[VAR]CHAR`, `BLOB`, Numerische Typen, `DATE`, `TIME`, `TIMESTAMP`

|`BLOB`
|`[VAR]CHAR`, `BLOB`, Numerische Typen, `DATE`, `TIME`, `TIMESTAMP`

|`DATE`, `TIME`
|`[VAR]CHAR`, `BLOB`, `TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR`, `BLOB`, `DATE`, `TIME`
|===

[IMPORTANT]
====
Beachten Sie, dass Informationsteile möglicherweise verloren gehen.
Zum Beispiel geht der Zeitteil bei der Konvertierung eines `TIMESTAMP` zu einem `DATE` verloren.
====

[[fblangref25-datatypes-convert-literalformats-de]]
==== Literalformate

Für den Cast von String-Datentypen zu ``DATE``-, ``TIME``- oder ``TIMESTAMP``-Datentypen, müssen Sie eines der vordefinierten Datum- bzw. Zeit-Literale (vgl. Tabelle 3.7) oder ein gültiges __Datum-Zeit-Literal__-Format verwenden:

[listing,subs=+quotes]
----
<timestamp_format> ::=
    { [__YYYY__<p>]__MM__<p>__DD__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]
    | __MM__<p>__DD__[<p>__YYYY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | __DD__<p>__MM__[<p>__YYYY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | __MM__<p>__DD__[<p>__YY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | __DD__<p>__MM__[<p>__YY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | NOW
    | TODAY
    | TOMORROW
    | YESTERDAY }

<date_format> ::=
    { [__YYYY__<p>]__MM__<p>__DD__
    | __MM__<p>__DD__[<p>__YYYY__]
    | __DD__<p>__MM__[<p>__YYYY__]
    | __MM__<p>__DD__[<p>__YY__]
    | __DD__<p>__MM__[<p>__YY__]
    | TODAY
    | TOMORROW
    | YESTERDAY }

<time_format> :=
    { __HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]
    | NOW }

<p> ::= whitespace | . | : | , | - | /
----

[[fblangref25-dtyp-tbl-keydesc-de]]
.Formatierungsargumente für Datum- und Zeit-LiteraleDate and Time Literal
[cols="<2,<3", options="header",stripes="none"]
|===
^| Argument
^| Beschreibung

|datetime_literal
|Datum- und Zeit-Literal

|time_literal
|Zeit-Literal

|date_literal
|Datum-Literal

|YYYY
|vierstelliges Jahr

|YY
|zweistelliges Jahr

|MM
|Monat. Dieser kann aus 1 oder 2 Stellen bestehen (1-12 oder 01-12).
Sie können auch die mit drei Buchstaben abgekürzte Form oder den vollen Monatsnamen in englisch angeben.
Dies berücksichtigt keine Groß- und Kleinschreibung.

|DD
|Tag.
Kann aus 1 oder 2 Stellen bestehen (1-31 oder 01-31)

|HH
|Stunde.
Kann aus 1 oder 2 Stellen bestehen (0-23 oder 00-23)

|mm
|Minute.
Kann aus 1 oder 2 Stellen bestehen (0-59 oder 00-59)

|SS
|Sekunde.
Kann aus 1 oder 2 Stellen bestehen (0-59 oder 00-59)

|NNNN
|Zehntausendstel Sekunde.
Kann aus 1 bis 4 Stellen bestehen (0-9999)

|p
|Separator, jedes gültige Zeichen.
Führende und nachgestellte Leerzeichen werden ignoriert.
|===

[[fblangref25-dtyp-tbl-predliterals-de]]
.Literale mit vordefinierten Datums- und Zeitwerten
[cols="<2,<3,<3,<2",stripes="none"]
|===
.2+^h| Literal
.2+^h| Beschreibung
2+^h| Datentyp

^h|Dialekt 1
^h|Dialekt 3

|`'NOW'`
|Aktuelles Datum und Zeit
|`DATE`
|`TIMESTAMP`

|`'TODAY'`
|Aktuelle Datum
|`DATE` mit Nullzeit
|`DATE`

|`'TOMORROW'`
|Heutiges Datum + 1 (Tag)
|`DATE` mit Nullzeit
|`DATE`

|`'YESTERDAY'`
|Heutiges Datum - 1 (Tag)
|`DATE` mit Nullzeit
|`DATE`
|===

[IMPORTANT]
====
Die Nutzung des Jahres in vierstelliger Schreibweise -- ``YYYY`` -- wird dringend empfohlen, um Verwirrungen bei der Datumsberechnung und bei Aggregationen zu vermeiden.
====

.Beispiele für die Interpretation von Datum-Literalen
[source]
----
select
  cast('04.12.2014' as date) as d1, -- DD.MM.YYYY
  cast('04 12 2014' as date) as d2, -- MM DD YYYY
  cast('4-12-2014' as date) as d3,  -- MM-DD-YYYY
  cast('04/12/2014' as date) as d4, -- MM/DD/YYYY
  cast('04,12,2014' as date) as d5, -- MM,DD,YYYY
  cast('04.12.14' as date) as d6,   -- DD.MM.YY
  -- DD.MM with current year
  cast('04.12' as date) as d7,
  -- MM/DD with current year
  cast('04/12' as date) as d8,
  cast('2014/12/04' as date) as d9, -- YYYY/MM/DD
  cast('2014 12 04' as date) as d10, -- YYYY MM DD
  cast('2014.12.04' as date) as d11, -- YYYY.MM.DD
  cast('2014-12-04' as date) as d12, -- YYYY-MM-DD
  cast('4 Jan 2014' as date) as d13, -- DD MM YYYY
  cast('2014 Jan 4' as date) as dt14, -- YYYY MM DD
  cast('Jan 4, 2014' as date) as dt15, -- MM DD, YYYY
  cast('11:37' as time) as t1, -- HH:mm
  cast('11:37:12' as time) as t2, -- HH:mm:ss
  cast('11:31:12.1234' as time) as t3, -- HH:mm:ss.nnnn
  cast('11.37.12' as time) as t4, -- HH.mm.ss
  -- DD.MM.YYYY HH:mm
  cast('04.12.2014 11:37' as timestamp) as dt1,
  -- MM/DD/YYYY HH:mm:ss
  cast('04/12/2014 11:37:12' as timestamp) as dt2,
  -- DD.MM.YYYY HH:mm:ss.nnnn
  cast('04.12.2014 11:31:12.1234' as timestamp) as dt3,
  -- MM/DD/YYYY HH.mm.ss
  cast('04/12/2014 11.37.12' as timestamp) as dt4
from rdb$database
----

[[fblangref25-datatypes-convert-shortcasts-de]]
==== Kurzschreibweisen für Casts von Datums- und Zeit-Datentypen

Firebird erlaubt die Verwendung von Kurzschreibweisen ("`C-Stil`") für die Konvertierung von Strings zu ``DATE``-, ``TIME``- und ``TIMESTAMP``-Typen.

.Syntax
[listing,subs=+quotes]
----
<data_type> '__date_literal_string__'
----

.Beispel

[source]
[source]
----
-- 1
  UPDATE PEOPLE
  SET AGECAT = 'SENIOR'
  WHERE BIRTHDATE < DATE '1-Jan-1943';
-- 2
  INSERT INTO APPOINTMENTS
  (EMPLOYEE_ID, CLIENT_ID, APP_DATE, APP_TIME)
  VALUES (973, 8804, DATE 'today' + 2, TIME '16:00');
-- 3
  NEW.LASTMOD = TIMESTAMP 'now';
----

[NOTE]
====
Diese Kurzschreibweisen werden direkt während des Parsens ausgewertet, so als ob das Statement bereits für die Ausführung vorbereitet wäre.
Dadurch hat beispielsweise `timestamp 'now'` immer den gleichen Wert, egal wie viel Zeit verstrichen ist.

Benötigen Sie hingegen eine Möglichkeit, die die Zeit bei jeder Ausführung neu ermittelt, müssen Sie die vollständige ``CAST``-Syntax verwenden.
Eine beispielhafte Verwendung eines solchen Ausdrucks in einem Trigger:

[source]
----
NEW.CHANGE_DATE = CAST('now' AS TIMESTAMP);
----
====

[[fblangref25-datatypes-convert-implicit-de]]
=== Implizite Datentyp-Konvertierung

Implizite Datenkonvertierung ist in Dialekt 3 nicht möglich -- die ``CAST``-Funktion wird fast immer benötigt, um Datentyp-Probleme zu vermeiden.

In Dialekt 1 wird in vielen Fällen ein Datentyp implizit in einen anderen gewandelt, ohne die ``CAST``-Funktion verwenden zu müssen.
Beispielsweise ist die folgende Klausel in einem ``SELECT``-Statement in Dialekt 1 gültig:

[source]
----
WHERE DOC_DATE < '31.08.2014'
----

und der String-Typ wird implizit in den Datums-Datentyp gewandelt.

In Dialekt 1 ist das Vermischen von Ganzzahlendaten und numerischen Zeichenketten grundsätzlich möglich, da der Parser versuchen wird, die Zeichenketten implizit zu konvertieren.
Beispielsweise wird:

[source]
----
2 + '1'
----

korrekt ausgeführt.

In Dialekt 3 wird dieser Ausdruck einen Fehler ausgeben.
Somit sind Sie gezwungen, einen ``CAST``-Ausdruck zu erstellen:

[source]
----
2 + CAST('1' AS SMALLINT)
----

Die Ausnahme bildet hier die _String-Verkettung_.

[[fblangref25-datatypes-convert-implicit-concat-de]]
==== Implizite Konvertierung während der String-Verkettung

Werden mehrere Elemente miteinander verkettet, werden alle nicht-Zeichen-Daten unter der Hand zu einer Zeichenkette konvertiert, sofern möglich.

.Beispiel
[source]
----
SELECT 30||' days hath September, April, June and November' CONCAT$
  FROM RDB$DATABASE;

CONCAT$
------------------------------------------------
30 days hath September, April, June and November
----

[[fblangref25-datatypes-custom-de]]
== Benutzerdefinierte Datentypen -- Domains

In Firebird wurde das Konzept "`benutzerdefinierter Datentypen`" in Form von __Domain__s implementiert.
Beim Erstellen einer Domain wird nicht wirklich ein neuer Datentyp generiert.
Eine Domain kapselt vielmehr einen bestehenden Datentyp mit diversen Attributen und macht diese "`Kaspel`" für verschiedene Anwendungsbereiche in der Datenbank verfügbar.
Wenn mehrere Tabellen Spalten benötigen, die die gleichen oder nahezu gleichen Eigenschaften haben sollen, macht die Verwendung von Domains Sinn.

Die Verwendung von Domains ist nicht auf die Spaltendefinition in Tabellen oder Views begrenzt.
Sie können auch als Übergabe- und Rückgabeparameter sowie Variablen in PSQL-Code verwendet werden.

[[fblangref25-datatypes-domainattribs-de]]
=== Domain-Eigenschaften

Eine Domain-Definition beinhaltet benötigte sowie optionale Eigenschaften.
Der _Datentyp_ ist ein benötigtes Attribut.
Optionale Eigenschaften sind: 

* ein Vorgabewert
* erlauben oder verbieten von `NULL`
* `CHECK` Constraints
* Zeichensatz (für Textdatentypen und Text-BLOB-Felder)
* Collation (für Textdatentypen)

.Beispielhafte Domain-Definition
[source]
----
CREATE DOMAIN BOOL3 AS SMALLINT
  CHECK (VALUE IS NULL OR VALUE IN (0, 1));
----

.vgl. auch
<<fblangref25-datatypes-convert-typeof-de,Explicite Datentyp-Konvertierung>> für die Beschreibung der Unterschiede im Mechanismus der Datenkonvertierung, wenn Domains für die ``TYPE OF``- und ``TYPE OF COLUMN``-Modifizierer verwendet werden.

[[fblangref25-datatypes-domainoverride-de]]
=== Domain-Überschreibung

Während des Festlegens der Domain-Definitionen, ist es möglich einige geerbte Eigenschaften zu überschreiben.
Tabelle 3.9 fasst die Regeln hierfür zusammen.

[[fblangref25-dtyp-tbl-domoverride-de]]
.Regeln zum Überschreiben von Domain-Eigenschaften in Spaltendefinitionen
[cols="<2,<1,<3", options="header",stripes="none"]
|===
^| Eigenschaft
^| Überschreiben?
^| Hinweis

|Datentyp
|Nein
|{nbsp}

|Vorgabewert
|Ja
|{nbsp}

|Zeichensatz
|Ja
|Dies kann auch verwendet werden, um die Vorgabewerte der Datenbank für die Spalte wiederherzustellen.

|Sortiermethode
|Ja
|{nbsp}

|``CHECK``-Constraints
|Ja
|Zum Hinzufügen von neuen Kriterien, können Sie die korrospondierenden ``CHECK``-Klauseln der ``CREATE``- und ``ALTER``-Anweisungen auf Tabellenebene verwenden.

|`NOT NULL`
|Nein
|Häufig ist es besser Domains nullbar in ihren Definitionen zu lassen und erst beim Erstellen der Spaltedefinition über `NOT NULL` zu entscheiden.
|===

[[fblangref25-datatypes-domaincreate-de]]
=== Domains erstellen und verwalten

Eine Domain wird mit der DDL-Anweisung `CREATE DOMAIN` erstellt.

.Kurz-Syntax
[listing,subs=+quotes]
----
CREATE DOMAIN _name_ [AS] <type>
  [DEFAULT {<const> | <literal> | NULL | <context_var>}]
  [NOT NULL] [CHECK (<condition>)]
  [COLLATE <collation>]
----

.vgl. auch
<<fblangref25-ddl-domn-create-de,`CREATE DOMAIN`>> im Abschnitt Data Definition Language (DDL).

[[fblangref25-datatypes-domainalter-de]]
==== Ändern einer Domain

Zum Ändern der Domain-Eigenschaften, nutzen Sie die Anweisung `ALTER DOMAIN`.
Mit dieser Anweisung können Sie 

* die Domain umbenennen
* den Datentyp ändern
* den derzeitigen Vorgabewert ändern
* einen neuen Vorgabewert festlegen
* einen vorhandenen ``CHECK``-Constraint löschen
* einen neuen ``CHECK``-Constraint hinzufügen

.Kurz-Syntax
[listing,subs=+quotes]
----
ALTER DOMAIN _name_
  [{TO <new_name>}]
  [{SET DEFAULT {<literal> | NULL | <context_var>} |
    DROP DEFAULT}]
  [{ADD [CONSTRAINT] CHECK (<dom_condition>) |
    DROP CONSTRAINT}]
  [{TYPE <datatype>}]
----

Wenn Sie vorhaben eine Domain zu ändern, müssen Sie die vorhandenen Abhängigkeiten berücksichtigen: wurden Tabellenspalten, Variablen, Übergabe- und/oder Rückgabeparameter mit dieser Domain in PSQL deklariert?
Wenn Sie Domains voreilig ändern, ohne diese eingehend zu überprüfen, kann es passieren, dass Ihr Code anschließend nicht mehr läuft!

[IMPORTANT]
====
Wenn Sie Datentypen einer Domain ändern, dürfen Sie keine Konvertierungen durchführen, die zu Datenverlust führen können.
Zum Beispiel sollten Sie vorab prüfen, ob das Konvertieren von `VARCHAR` zu `INTEGER` für alle Daten erfolgreich durchgeführt werden kann.
====

.vgl. auch
<<fblangref25-ddl-domn-alter-de,`ALTER DOMAIN`>> im Abschnitt Data Definition Language (DDL).

[[fblangref25-datatypes-domaindrop-de]]
==== Löschen einer Domain

Die Anweisung `DROP DOMAIN` löscht eine Domain aus der  Datenbank, sofern diese nicht von anderen Datenbankobjekten verwendet wird.

.Syntax
[listing,subs=+quotes]
----
DROP DOMAIN _name_
----

[IMPORTANT]
====
Jeder mit der Datenbank verbundene Benutzer kann eine Domain löschen.
====

.Beispiel
[source]
----
DROP DOMAIN Test_Domain
----

.vgl. auch
<<fblangref25-ddl-domn-drop-de,`DROP DOMAIN`>> im Abschnitt Data Definition Language (DDL).
