[[fblangref25-ddl-de]]
= Statements der Data Definition (DDL)

DDL ist die Untermenge der SQL-Sprache von Firebird zum Festlegen von Datendefinitionen.
DDL-Anweisungen werden zum Erstellen, Ändern und Löschen von Datenbankobjekten verwendet, die von Benutzern erstellt wurden.
Wenn eine DDL-Anweisung commited wird, werden die Metadaten für die Objekte erstellt, geändert oder gelöscht. 

[[fblangref25-ddl-db-de]]
== `DATABASE`

In diesem Abschnitt wird beschrieben, wie Sie eine Datenbank erstellen, eine Verbindung zu einer vorhandenen Datenbank herstellen, die Dateistruktur einer Datenbank ändern und löschen.
Außerdem wird erläutert, wie Sie eine Datenbank auf zwei verschiedene Arten sichern können und wie Sie die Datenbank in den "`kopiersicheren`" Modus umwandeln können, um ein externes Backup sicher durchzuführen.

[[fblangref25-ddl-db-create-de]]
=== `CREATE DATABASE`

.Benutzt für
Erstellen einer neuen Datenbank

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
CREATE {DATABASE | SCHEMA} <filespec>
  [USER '_username_' [PASSWORD '_password_']]
  [PAGE_SIZE [=] _size_]
  [LENGTH [=] _num_ [PAGE[S]]
  [SET NAMES '_charset_']
  [DEFAULT CHARACTER SET _default_charset_
    [COLLATION _collation_]] -- _not supported in ESQL_
  [<sec_file> [<sec_file> ...]]
  [DIFFERENCE FILE '_diff_file_'] -- _not supported in ESQL_

<filespec> ::= "'" [_server_spec_]{_filepath_ | _db_alias_} "'"

<server_spec> ::= _servername_[/{_port_|_service_}]: | {backslash}{backslash}__servername__\

<sec_file> ::=
  FILE '_filepath_'
  [LENGTH [=] _num_ [PAGE[S]]
  [STARTING [AT [PAGE]] _pagenum_]
----

[[fblangref25-ddl-tbl-createdatabase-de]]
.`CREATE DATABASE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|filespec
|Dateispezifikation für primäre Datenbankdatei

|server_spec
|Spezifikation des Remoteservers im TCP / IP- oder Windows-Netzwerkstil.
Enthält optional eine Portnummer oder einen Servicenamen

|filepath
|Vollständiger Pfad und Dateiname einschließlich seiner Erweiterung.
Der Dateiname muss gemäß den Regeln des verwendeten Plattformdateisystems angegeben werden.

|db_alias
|Datenbank-Alias, der zuvor in der Datei `aliases.conf` definiert wurde.

|servername
|Hostname oder IP-Adresse des Servers, auf dem die Datenbank erstellt werden soll.

|username
|Benutzername des Eigentümers der neuen Datenbank.
Es kann aus bis zu 31 Zeichen bestehen.
Groß- / Kleinschreibung ist vernachlässigbar.

|password
|Kennwort des Benutzers oder Datenbankeigentümers.
Die maximale Länge beträgt 31 Zeichen;
es werden jedoch nur die ersten 8 Zeichen berücksichtigt.
Groß- / Kleinschreibung beachten.

|size
|Seitengröße der Datenbank in Bytes. Mögliche Werte sind 4096 (Standard), 8192 und 16384

|num
|Maximale Größe des primären Datenbankdatei, oder einer sekundären, in Seiten (pages).

|charset
|Legt den Zeichensatz der Verbindung fest, die von einem Client verwendet wird, nachdem die Datenbank erfolgreich erstellt wurde.
Einfache Anführungszeichen sind zu verwenden.

|default_charset
|Legt den Standardzeichensatz für String-Datentypen fest.

|collation
|Standard-Collation für den Standardzeichensatz

|sec_file
|Dateispezifikation für eine sekundäre Datei

|pagenum
|Startseitenzahl für eine sekundäre Datenbankdatei

|diff_file
|Dateipfad und -name für DIFFERENCE-Dateien (.delta-Dateien)
|===

Das Statement `CREATE DATABASE` erstellt eine neue Datenbank.
Sie können sowohl `CREATE DATABASE` wie auch `CREATE SCHEMA` verwenden.
Dies sind Synonyme füreinander.

Eine Datenbank besteht aus einer oder mehrerer Dateien.
Die erste (Haupt-) Datei wird auch als die _primäre Datei_ bezeichnet, folgende als  _sekundäre Datei[en]_.

.Multi-Datei-Datenbanken
[NOTE]
====
Heutzutage gelten Multi-File-Datenbanken als rückschrittlich.
Es ist sinnvoll, Datenbanken mit mehreren Dateien auf alten Dateisystemen zu verwenden, bei denen die Größe einer Datei begrenzt ist.
Sie können beispielsweise keine Datei mit mehr  als 4 GB auf FAT32 erstellen. 
====

Die primäre Dateispezifikation ist der Name der Datenbankdatei und ihrer Erweiterung mit dem vollständigen Pfad zu den Regeln des verwendeten Betriebssystemplattformdateisystems.
Die Datenbankdatei darf zum Zeitpunkt der Datenbankerstellung nicht vorhanden sein.
Wenn dies der Fall ist, erhalten Sie eine Fehlermeldung und die Datenbank wird nicht erstellt. 

Wenn der vollständige Pfad zur Datenbank nicht angegeben ist, wird die Datenbank in einem der Systemverzeichnisse erstellt.
Das bestimmte Verzeichnis hängt vom Betriebssystem ab.
Geben Sie daher immer den absoluten Pfad an, wenn Sie entweder die Datenbank oder einen _Alias_ dafür erstellen, es sei denn, Sie haben einen guten Grund, diese Situation zu bervorzugen.

[[fblangref25-ddl-db-alias-de]]
==== Einen Datenbank-Alias verwendenUsing a Database Alias

Sie können Aliasnamen anstelle des vollständigen Pfads zur primären Datenbankdatei verwenden.
Aliase sind in der Datei `aliases.conf` im folgenden Format definiert:

[listing,subs=+quotes]
----
_alias_ = _filepath_
----

[[fblangref25-ddl-db-createremote-de]]
==== Eine Datenbank remote erstellen

Wenn Sie eine Datenbank auf einem Remoteserver erstellen, sollten Sie die Spezifikation des Remoteservers angeben.
Die Spezifikation des  Remoteservers hängt vom verwendeten Protokoll ab.
Wenn Sie das TCP / IP-Protokoll zum Erstellen einer Datenbank verwenden, sollte die primäre Dateispezifikation wie folgt aussehen:

[listing]
----
_servername_[/{_port_|_service_}]:{_filepath_ | _db_alias_}
----

Wenn Sie das Named Pipes-Protokoll verwenden, um eine Datenbank auf einem Windows-Server zu erstellen, sollte die primäre Dateispezifikation wie folgt aussehen:

[listing,subs="+quotes,attributes"]
----
{backslash}{backslash}__servername__\{_filepath_ | _db_alias_}
----

[[fblangref25-ddl-db-createdbopts-de]]
==== Optionale Parameter für `CREATE DATABASE`

`USER` und `PASSWORD`::
Klauseln zur Angabe des Benutzernamens bzw. des Passworts eines vorhandenen Benutzers in der Sicherheitsdatenbank `security2.fdb`.
Sie müssen den Benutzernamen und das Kennwort nicht angeben, wenn die Umgebungsvariablen `ISC_USER` und `ISC_PASSWORD` festgelegt sind.
Der Benutzer, der beim Erstellen der Datenbank angegeben wird, wird ihr Eigentümer sein.
Dies ist wichtig, wenn Sie Datenbank- und Objektberechtigungen berücksichtigen.

`PAGE_SIZE`::
Klausel zum Festlegen der Seitengröße der Datenbank.
Diese Größe wird für die primäre Datei und alle sekundären Dateien der Datenbank festgelegt.
Wenn Sie die Datenbankseitengröße unter 4.096 angeben, wird diese automatisch auf die Standardseitengröße 4.096 geändert.
Andere Werte, die nicht 4.096, 8.192 oder 16.384 entsprechen, werden in den nächst kleineren unterstützten Wert geändert.
Wenn die Größe der Datenbankseite nicht angegeben ist, wird der Standardwert auf 4.096 gesetzt.

`LENGTH`::
Klausel, die die maximale Größe der primären oder sekundären Datenbankdatei in Seiten angibt.
Wenn eine Datenbank erstellt wird, belegen ihre primären und sekundären Dateien die Mindestanzahl an Seiten, die zum Speichern der Systemdaten erforderlich sind, unabhängig vom in der ``LENGTH``-Klausel angegebenen Wert.
Der Wert der `LENGTH` wirkt sich nicht auf die Größe der einzigen (oder zuletzt in einer Datei mit mehreren Dateien) Datei aus.
Die Datei wird bei Bedarf automatisch vergrößert. 

`SET NAMES`::
Klausel, die den Zeichensatz der Verbindung angibt, die verfügbar ist, nachdem die Datenbank erfolgreich erstellt wurde.
Der Zeichensatz `NONE` wird standardmäßig verwendet.
Beachten Sie, dass der Zeichensatz in einem Apostroph-Paar eingeschlossen sein sollte (einfache Anführungszeichen).

`DEFAULT CHARACTER SET`::
Klausel, die den Standardzeichensatz zum Erstellen von Datenstrukturen von String-Datentypen angibt.
Zeichensätze werden auf Datentypen `CHAR`, `VARCHAR` und `BLOB TEXT` angewendet.
Der Zeichensatz `NONE` wird standardmäßig  verwendet.
Es ist auch möglich, den Standardwert `COLLATION` für den Standardzeichensatz festzulegen, wodurch diese Sortierfolge zum Standardwert für den Standardzeichensatz wird.
Der Standardwert wird für die gesamte Datenbank verwendet, es sei denn, ein alternativer Zeichensatz mit oder ohne eine  angegebene Collation wird explizit für ein Feld, eine Domain, eine Variable, einen Ausdruck usw. verwendet.

`STARTING AT`::
Klausel, die die Datenbankseitennummer angibt, bei der die nächste sekundäre Datenbankdatei gestartet werden soll.
Wenn die vorherige Datei vollständig mit Daten gemäß der angegebenen Seitennummer gefüllt ist, fügt das System neue Daten zur nächsten Datenbankdatei hinzu.

`DIFFERENCE FILE`::
Klausel, die den Pfad und den Namen für das Datei-Delta angibt, das Änderungen in der Datenbankdatei speichert, nachdem es durch die Anweisung `ALTER DATABASE BEGIN BACKUP` auf den  "`kopiersicheren`" Modus gestellt wurde.
Eine detaillierte Beschreibung dieser Klausel finden Sie unter `ALTER DATABASE`.

`SET SQL DIALECT`::
Datenbanken werden standardmäßig in Dialekt 3 erstellt.
Damit die Datenbank in SQL-Dialekt 1 erstellt wird, müssen Sie die Anweisung `SET SQL DIALECT 1` aus dem Skript oder der Clientanwendung, z.B. _isql_, ausführen, noch vor der Anweisung `CREATE DATABASE`.

[[fblangref25-ddl-db-createdbexamples-de]]
==== Beispiele zur Verwendung von `CREATE DATABASE`

. Erstellen einer Datenbank in Windows auf der Festplatte D mit einer Seitengröße von 8.192.
Der Besitzer der Datenbank ist der Benutzer _wizard_.
Die Datenbank befindet sich in Dialekt 1 und verwendet als Standardzeichensatz `WIN1251`.
+
[source]
----
SET SQL DIALECT 1;
CREATE DATABASE 'D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192 DEFAULT CHARACTER SET WIN1251;
----
. Erstellen einer Datenbank im Linux-Betriebssystem mit einer Seitengröße von 4.096.
Der Besitzer der Datenbank ist der Benutzer _wizard_.
Die Datenbank befindet sich in Dialekt 3 und verwendet `UTF8` als Standardzeichensatz, wobei `UNICODE_CI_AI` als Standardsortierung verwendet wird.
+
[source]
----
CREATE DATABASE '/home/firebird/test.fdb'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8 COLLATION UNICODE_CI_AI;
----
. Erstellen einer Datenbank auf dem entfernten Server "`baseserver`" mit dem angegebenen Alias "`test`", der zuvor in der Datei `aliases.conf` definiert wurde.
Das TCP / IP-Protokoll wird verwendet.
Der Besitzer der Datenbank wird der Benutzer _wizard_ sein.
Die Datenbank befindet sich in Dialekt 3 und verwendet `UTF8` als Standardzeichensatz.
+
[source]
----
CREATE DATABASE 'baseserver:test'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8;
----
. Erstellen einer Datenbank in Dialekt 3 mit `UTF8` als Standardzeichensatz.
Die primäre Datei enthält bis zu 10.000 Seiten mit einer Seitengröße von 8.192.
Sobald die primäre Datei die maximale Anzahl an Seiten erreicht hat, beginnt Firebird, Seiten der sekundären Datei `test.fdb2` zuzuweisen.
Wenn diese Datei ebenfalls maximal gefüllt ist, wird `test.fdb3` zum Empfänger aller neuen Seitenzuweisungen.
Als letzte Datei hat Firebird kein Seitenlimit.
Neue Zuweisungen werden so lange fortgesetzt, wie es das Dateisystem zulässt, oder bis das Speichergerät keinen freien Speicher mehr hat.
Wenn für diese letzte Datei ein ``LENGTH``-Parameter angegeben wurde, wird dieser ignoriert.
+
[source]
----
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
STARTING AT PAGE 10001
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
----
. Erstellen einer Datenbank in Dialekt 3 mit `UTF8` als Standardzeichensatz.
Die primäre Datei enthält bis zu 10.000 Seiten mit einer Seitengröße von 8.192.
In Bezug auf die Dateigröße und die Verwendung von Sekundärdateien verhält sich diese Datenbank genau wie im vorherigen Beispiel.
+
[source]
----
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
LENGTH 10000 PAGES
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
----

.Siehe auch
<<fblangref25-ddl-db-alter-de>>, <<fblangref25-ddl-db-drop-de>>

[[fblangref25-ddl-db-alter-de]]
=== `ALTER DATABASE`

.Benutzt für
Ändern der Dateiorganisation einer Datenbank oder um diese in den "`kopiersicheren`" Modus zu setzen

.Verfügbar in
DSQL -- beide Funktionen.
ESQL -- nur Dateireorganisation

.Syntax
[listing,subs=+quotes]
----
ALTER {DATABASE | SCHEMA}
  [<add_sec_clause> [<add_sec_clause> ...]]
  [ADD DIFFERENCE FILE '_diff_file_' | DROP DIFFERENCE FILE]
  [{BEGIN | END} BACKUP]

<add_sec_clause> ::= ADD <sec_file> [<sec_file> ...]

<sec_file> ::=
  FILE '_filepath_'
  [STARTING [AT [PAGE]] _pagenum_]
  [LENGTH [=] _num_ [PAGE[S]]
----

[NOTE]
====
Mehrere Dateien können mit einer ADD-Klausel hinzugefügt werden:

[source]
----
ALTER DATABASE
  ADD FILE x LENGTH 8000
    FILE y LENGTH 8000
    FILE z
----

Mehrere ``ADD FILE``-Klauseln sind erlaubt;
und eine ``ADD FILE``-Klausel, die mehrere Dateien hinzufügt (wie im obigen Beispiel), kann mit anderen gemischt werden, die nur eine Datei hinzufügen.
Die Aussage wurde in der alten [ref]_InterBase 6 Language Reference_ falsch dokumentiert.
====

.`ALTER DATABASE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|add_sec_clause
|Hinzufügen einer sekundären Datenbankdatei

|sec_file
|Dateispezifikation für sekundäre Datei

|filepath
|Vollständiger Pfad und Dateiname der Delta-Datei oder der sekundären Datenbankdatei

|pagenum
|Seitennummer, von der aus die sekundäre Datenbankdatei gestartet werden soll

|num
|Maximale Größe der sekundären Datei in Seiten

|diff_file
|Dateipfad und Name der .delta-Datei (Differenzdatei)
|===

Das Statement `ALTER DATABASE` kann 

* sekundäre Dateien zu einer Datenbank hinzufügen
* eine Ein-Datei-Datenbank in und aus dem Modus "`kopiersicher`" schalten (nur DSQL)
* festlegen und entfernen des Pfades und der Namen der Delta-Dateien für physikalische Backups (nur DSQL)

Nur <<fblangref25-security-administrators-de,Administratoren>> haben die Berechtigung das Statement `ALTER DATABASE` auszuführen.

[[fblangref25-ddl-db-alterdbopts-de]]
==== Parameter für `ALTER DATABASE`

`ADD FILE`::
Die ``ADD FILE``-Klausel fügt eine sekundäre Datei zur Datenbank hinzu.
Es ist erforderlich, den vollständigen Pfad zur Datei und den Namen der sekundären Datei anzugeben.
Die Beschreibung für die sekundäre Datei ähnelt der für die Anweisung `CREATE DATABASE`.

`ADD DIFFERENCE FILE`::
Die ``ADD DIFFERENCE FILE``-Klausel gibt den Pfad und den Namen der Delta-Datei an, die Änderungen in der Datenbank speichert, wenn diese auf den Modus "`kopiersicher`" umgestellt wird.
Diese Klausel fügt tatsächlich keine Datei hinzu.
Sie überschreibt nur den Standardnamen und den Standardpfad der Delta-Datei.
Um die vorhandenen Einstellungen zu ändern, sollten Sie die vorher angegebene Beschreibung der .delta-Datei mit der ``DROP DIFFERENCE FILE``-Klausel vor der Angabe der neuen Beschreibung der Deltadatei löschen.
Wenn Pfad und Name der .delta-Datei nicht überschrieben werden, hat die Datei denselben Pfad und denselben Namen wie die Datenbank, jedoch mit der Dateierweiterung `.delta`.
+
[CAUTION]
====
Wenn nur ein Dateiname angegeben ist, wird die .delta-Datei im aktuellen Verzeichnis des Servers erstellt.
Unter Windows wird dies das Systemverzeichnis sein -- ein sehr unkluger Speicherort für flüchtige Benutzerdateien und entgegen den Windows-Dateisystemregeln.
====

`DROP DIFFERENCE FILE`::
Dies ist die Klausel, die die Beschreibung (Pfad und Name) der zuvor in der ``ADD DIFFERENCE FILE``-Klausel angegebenen Deltadatei löscht.
Die Datei wird nicht gelöscht.
`DROP DIFFERENCE FILE` löscht den Pfad und den Namen der .delta-Datei aus dem Datenbank-Header.
Beim nächsten Umschalten der Datenbank auf den "`kopiersicheren`" Modus werden die Standardwerte verwendet (d.h.
derselbe Pfad und Name wie die Datenbank, jedoch mit der Erweiterung .delta). 

`BEGIN BACKUP`::
Dies ist die Klausel, die die Datenbank in den "`kopiersicheren`" Modus umschaltet.
`ALTER DATABASE` friert mit dieser Klausel die Hauptdatenbankdatei ein und ermöglicht die sichere Sicherung mithilfe von Dateisystemtools, selbst wenn Benutzer verbunden sind und Operationen mit Daten ausführen.
Bis der Sicherungsstatus der Datenbank auf _NORMAL_ zurückgesetzt wird, werden alle an der Datenbank vorgenommenen Änderungen in die .delta (Differenz)-Datei geschrieben.
+
[IMPORTANT]
====
Trotz seiner Syntax startet eine Anweisung mit der Klausel `BEGIN BACKUP` keinen Sicherungsprozess, sondern erstellt lediglich die Bedingungen für die Ausführung einer Aufgabe, für die die Datenbankdatei nur vorübergehend schreibgeschützt sein muss.
====

`END BACKUP`::
`END BACKUP` ist die Klausel, mit der die Datenbank vom "`kopiersicheren`" Modus in den normalen Modus umgeschaltet wird.
Eine Anweisung mit dieser Klausel fügt die .delta-Datei mit der Hauptdatenbankdatei zusammen und stellt den normalen Betrieb der Datenbank wieder her.
Sobald der ``END BACKUP``-Prozess gestartet wird, sind die Bedingungen für das Erstellen sicherer Backups mit Dateisystemtools nicht mehr vorhanden.

[WARNING]
====
Die Verwendung von `BEGIN BACKUP` und `END BACKUP` und das Kopieren der Datenbankdateien mit den Dateisystemtools ist _nicht sicher_ mit Mehrdateiendatenbanken!
Verwenden Sie diese Methode nur für Datenbanken mit einer einzigen Datei.

Ein sicheres Backup mit dem Dienstprogramm _gbak_ ist jederzeit möglich, wenn auch nicht empfohlen, solange sich die Datenbank im Zustand _LOCKED_ oder _MERGE_ befindet.
====

==== Beispiele zur Verwendung von `ALTER DATABASE`

. Hinzufügen einer sekundären Datei zur Datenbank.
Sobald in der vorherigen primären oder sekundären Datei 30000 Seiten gefüllt sind, fügt die Firebird-Engine Daten zur sekundären Datei `test4.fdb` hinzu.
+
[source]
----
ALTER DATABASE
  ADD FILE 'D:\test4.fdb'
    STARTING AT PAGE 30001;
----
. Pfad und Name der Delta-Datei angeben:
+
[source]
----
ALTER DATABASE
  ADD DIFFERENCE FILE 'D:\test.diff';
----
. Beschreibung der Delta-Datei löschen:
+
[source]
----
ALTER DATABASE
  DROP DIFFERENCE FILE;
----
. Wechseln der Datenbank in den "`kopiersicheren`" Modus:
+
[source]
----
ALTER DATABASE
  BEGIN BACKUP;
----
. Umschalten der Datenbank vom "`kopiersicheren`" Modus in den normalen Betriebsmodus:
+
[source]
----
ALTER DATABASE
  END BACKUP;
----

.Siehe auch
<<fblangref25-ddl-db-create-de>>, <<fblangref25-ddl-db-drop-de>>

[[fblangref25-ddl-db-drop-de]]
=== `DROP DATABASE`

.Benutzt für
Löschen der Datenbank, mit der Sie gerade verbunden sind

.Verfügbar in
DSQL, ESQL

.Syntax
[listing]
----
DROP DATABASE
----

Die Anweisung `DROP DATABASE` löscht die aktuelle Datenbank.
Bevor Sie eine Datenbank löschen, müssen Sie eine Verbindung herstellen.
Die Anweisung löscht die primäre Datei, alle sekundären Dateien und alle <<fblangref25-ddl-shadow-de,Schattendateien>>.

Nur <<fblangref25-security-administrators-de,Administratoren>> haben die notwendigen Rechte zum Ausführen der Anweisung `DROP DATABASE`.

.Beispiel
Löschen der Datenbank, mit der der Client verbunden ist.

[source]
----
DROP DATABASE;
----

.Siehe auch
<<fblangref25-ddl-db-create-de>>, <<fblangref25-ddl-db-alter-de>>

[[fblangref25-ddl-shadow-de]]
== `SHADOW`

Ein _shadow_ ist eine exakte Seite-für-Seite-Kopie einer Datenbank.
Sobald ein Shadow erstellt wurde, spiegeln sich alle Änderungen in der Datenbank sofort im Shadow wider.
Wenn die primäre Datenbankdatei aus irgendeinem Grund nicht verfügbar ist, wechselt das DBMS auf den Shadow.

In diesem Abschnitt wird beschrieben, wie Sie Schattendateien erstellen und löschen.

[[fblangref25-ddl-createshadow-de]]
=== `CREATE SHADOW`

.Benutzt für
Erstellen eines Shadows für die aktuelle Datenbank

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE SHADOW <sh_num> [AUTO | MANUAL] [CONDITIONAL]
  '_filepath_' [LENGTH [=] _num_ [PAGE[S]]]
  [<secondary_file> ...]

<secondary_file> ::=
  FILE '_filepath_'
  [STARTING [AT [PAGE]] _pagenum_]
  [LENGTH [=] _num_ [PAGE[S]]]
----

[[fblangref25-ddl-tbl-createshadow-de]]
.`CREATE SHADOW` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|sh_num
|Schattennummer -- eine positive Zahl, die den Schattensatz identifiziert

|filepath
|Der Name der Schattendatei und der Pfad dazu in Übereinstimmung mit den Regeln des Betriebssystems

|num
|Maximale Schattengröße in Seiten

|secondary_file
|Sekundäre Dateispezifikation

|page_num
|Die Nummer der Seite, auf der die sekundäre Schattendatei gestartet werden soll
|===

Die Anweisung `CREATE SHADOW` erstellt einen neuen Shadow.
Der Schatten beginnt mit dem Duplizieren der Datenbank in dem Moment, in dem sie erstellt wird.
Es ist für einen Benutzer nicht möglich, eine Verbindung zu einem Schatten herzustellen.

Wie bei einer Datenbank kann ein Shadow eine Mehrfachdatei sein.
Die Anzahl und Größe der Dateien eines Schattens hängt nicht mit der Anzahl und Größe der Dateien der Datenbank, die es beschattet, zusammen.

Die Seitengröße für Schattendateien wird auf die Größe der Datenbankseite festgelegt und kann nicht geändert werden.

Wenn ein Unglück mit der ursprünglichen Datenbank auftritt, konvertiert das System den Schatten in eine Kopie der Datenbank und wechselt zu dieser.
Der Schatten ist dann _nicht verfügbar_.
Was als nächstes passiert, hängt von der Option `MODE` ab.

[[fblangref25-ddl-createshadowmode-de]]
==== `AUTO | MANUAL` Modes

Wenn ein Schatten in eine Datenbank konvertiert wird, ist er nicht mehr verfügbar.
Ein Schatten kann auch unverfügbar werden, weil jemand versehentlich seine Datei löscht oder der Speicherplatz, auf dem die Schatten-Dateien gespeichert sind, erschöpft ist oder selbst beschädigt ist.

* Wenn der AUTO-Modus ausgewählt ist (Standardwert), wird die Spiegelung automatisch beendet, alle Referenzen werden aus dem Datenbank-Header gelöscht, und die Datenbank arbeitet normal weiter.
+ 
Wenn die Option `CONDITIONAL` festgelegt wurde, versucht das System, einen neuen Schatten zu erstellen, um den verlorenen  zu ersetzen.
Es ist jedoch nicht immer erfolgreich und ein neuer muss möglicherweise manuell erstellt werden.
* Ist das MANUAL-Modus-Attribut gesetzt, wenn der Schatten nicht mehr verfügbar ist, werden alle Versuche, eine Verbindung zur Datenbank herzustellen und diese abzufragen, Fehlermeldungen erzeugen.
Die Datenbank bleibt so lange unzugänglich, bis entweder der Schatten wieder verfügbar ist oder der Datenbankadministrator sie mithilfe der Anweisung `DROP SHADOW` löscht.
MANUAL sollte ausgewählt werden, wenn kontinuierliches Shadowing wichtiger ist als der unterbrechungsfreie Betrieb der Datenbank.

[[fblangref25-ddl-createshadowopts-de]]
==== Optionen für `CREATE SHADOW`

`LENGTH`::
Klausel, die die maximale Größe der primären oder sekundären Schattendatei in Seiten angibt.
Der Wert `LENGTH` wirkt sich nicht auf die Größe der einzigen Schattendatei aus, noch auf die letzte, wenn es sich um eine Gruppe handelt.
Die letzte (oder einzige) Datei wird  automatisch so lange vergrößert, wie es nötig ist.

`STARTING AT`::
Klausel, die die Schattenseitennummer angibt, bei der die nächste Schattendatei gestartet werden soll.
Das System fügt neue Daten zur nächsten Schattendatei hinzu, wenn die vorherige Datei bis zur angegebenen Seitenzahl mit Daten gefüllt ist.

Nur <<fblangref25-security-administrators-de,Administratoren>> haben die notwendigen Rechte die Anweisung `CREATE SHADOW` auszuführen.

[TIP]
====
Sie können die Größen, Namen und den Speicherort der Schattendateien überprüfen, indem Sie mit _isql_ eine Verbindung zur Datenbank herstellen und den Befehl `SHOW DATABASE;`
====

==== Beispiele für die Verwendung von `CREATE SHADOW`

. Erstellen eines Schattens für die aktuelle Datenbank als "`shadow number 1`":
+
[source]
----
CREATE SHADOW 1 'g:\data\test.shd';
----
. Erstellen eines Mehrdatei-Schattens für die aktuelle Datenbank als "`shadow number 2`":
+
[source]
----
CREATE SHADOW 2 'g:\data\test.sh1'
  LENGTH 8000 PAGES
  FILE 'g:\data\test.sh2';
----

.Siehe auch
<<fblangref25-ddl-db-create-de>>, <<fblangref25-ddl-dropshadow-de>>

[[fblangref25-ddl-dropshadow-de]]
=== `DROP SHADOW`

.Benutzt für
Deleting a shadow from the current database

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP SHADOW _sh_num_
----

[[fblangref25-ddl-tbl-dropshadow-de]]
.`DROP SHADOW` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|sh_num
|Schattennummer -- eine positive Zahl, die den Schattensatz identifiziert
|===

Die Anweisung `DROP SHADOW` löscht den angegebenen Schatten für die Datenbank, mit der eine Verbindung besteht.
Wenn ein Schatten gelöscht wird, werden alle zugehörigen Dateien gelöscht und Schatten auf die angegebene  _sh_num_ werden beendet.

Nur <<fblangref25-security-administrators-de,Administratoren>> haben die notwendigen Rechte die Anweisung `DROP SHADOW` auszuführen.

.Beispiel zum Löschen eines Schattens
Löschen von "`shadow Nummer 1`".

[source]
----
DROP SHADOW 1;
----

.Siehe auch
<<fblangref25-ddl-createshadow-de>>

[[fblangref25-ddl-domn-de]]
== `DOMAIN`

`Domain` ist eine Objektart innerhalb einer relationalen Datenbank.
Eine Domain wird als ein bestimmter Datentyp mit einigen Attributen erstellt.
Sobald es in der Datenbank definiert wurde, kann es wiederholt verwendet werden, um Tabellenspalten, PSQL-Argumente und lokale PSQL-Variablen zu definieren.
Diese Objekte erben alle Attribute der Domain Einige Attribute können bei Bedarf überschrieben werden, wenn das neue  Objekt definiert ist.

In diesem Abschnitt wird die Syntax von Anweisungen beschrieben, mit denen Domains erstellt, geändert und gelöscht werden.
Eine detaillierte Beschreibung von Domains und deren Verwendung finden Sie in <<fblangref25-datatypes-custom-de,Benutzerdefinierte Datentypen -- Domains>>.

[[fblangref25-ddl-domn-create-de]]
=== `CREATE DOMAIN`

.Benutzt für
Erstellen einer neuen Domain

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
CREATE DOMAIN _name_ [AS] <datatype>
  [DEFAULT {<literal> | NULL | <context_var>}]
  [NOT NULL] [CHECK (<dom_condition>)]
  [COLLATE _collation_name_]

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT} [<array_dim>]
  | {FLOAT | DOUBLE PRECISION} [<array_dim>]
  | {DATE | TIME | TIMESTAMP} [<array_dim>]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] [<array_dim>]
  | {{CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [<array_dim>] [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)] [<array_dim>]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<array_dim> ::= '[' [_m_:{endsb}__n__ [,[_m_:{endsb}__n__ ...] ']'

<dom_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<dom_condition>)
  | NOT <dom_condition>
  | <dom_condition> OR <dom_condition>
  | <dom_condition> AND <dom_condition>

<operator> ::=
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    VALUE
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-createdomn-de]]
.`CREATE DOMAIN` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|name
|Domainname aus maximal 31 Zeichen

|datatype
|SQL-Datentyp

|literal
|Ein literaler Wert, der kompatibel zu _datatype_ ist

|context_var
|Jede Kontextvariable, deren Typ kompatibel ist mit _datatype_

|dom_condition
|Domain-Bedingung

|collation_name
|Name einer Collation, die für _charset_name_ gültig ist, sofern dieser mit _datatype_ übergeben wird, oder andernfalls für den Standardzeichensatz der Datenbank

|array_dim
|Array-Dimensionen

|m, n
|``INTEGER``-Ganzzahlen, die den Indexbereich der Array-Dimensionen angeben

|precision
|Die Gesamtzahl der signifikanten Ziffern, die ein Wert von _datatype_ aufnehmen kann (1..18)

|scale
|Die Anzahl der Stellen nach dem Dezimalpunkt (0..__precision__)

|size
|Die maximale Anzahl einer Zeichenkette in Zeichen

|charset_name
|Der Name eines gültigen Zeichensatzes, falls sich der Zeichensatz der Domain vom Standardzeichensatz der Datenbank unterscheidet

|subtype_num
|`BLOB` Subtype-Nummer

|subtype_name
|``BLOB``-Subtyp-Mnemonikname

|seglen
|Segmentgröße (max. 65535)

|select_one
|Eine skalare ``SELECT``-Anweisung -- Auswählen einer Spalte und Zurückgeben nur eines row

|select_list
|Eine ``SELECT``-Anweisung, die eine Spalte auswählt und null oder mehr Zeilen zurückgibt

|select_expr
|Eine ``SELECT``-Anweisung, die eine Spalte oder mehrere Spalten auswählt und null oder mehr Zeilen zurückgibt

|expression
|Ein Ausdruck, der auf einen Wert auflöst, der mit _datatype_ kompatibel ist

|genname
|Sequenzname (Generatorname)

|func
|Interne Funktion oder UDF
|===

Die Anweisung `CREATE DOMAIN` erstellt eine neue Domain.

Jeder SQL-Datentyp kann als Domainntyp angegeben werden.

[[fblangref25-ddl-domn-typespec-de]]
==== Typenspezifische Details

`ARRAY` Typen::
* Wenn die Domain ein Array sein soll, kann der Basistyp ein SQL-Datentyp mit Ausnahme von `BLOB` und `ARRAY` sein.
* Die Dimensionen des Arrays werden in eckigen Klammern angegeben.
(Im Syntaxblock werden diese Klammern fett dargestellt, um sie von den  eckigen Klammern zu unterscheiden, die optionale Syntaxelemente kennzeichnen.)
* Für jede Array-Dimension definieren eine oder zwei ganze Zahlen die untere und obere Grenze ihres Indexbereichs:
** Standardmäßig sind Arrays 1-basiert.
Die untere Grenze ist implizit und nur die obere Grenze muss angegeben werden.
Eine einzelne Zahl kleiner als 1 definiert den Bereich __num__..1 und eine Zahl größer als 1 definiert den Bereich 1..__num__.
** Zwei durch einen Doppelpunkt getrennte Zahlen ('```:```') und optional ein Leerraum, der zweite ist größer als der erste, können verwendet werden, um den Bereich explizit zu definieren.
Eine oder beide Grenzen können kleiner als Null sein, solange die obere Grenze größer als die untere ist.
* Wenn das Array mehrere Dimensionen hat, müssen die Bereichsdefinitionen für jede Dimension durch Kommas und ein optionales Leerzeichen getrennt werden.
* Indizes werden _nur_ validiert, wenn ein Array tatsächlich existiert.
Dies bedeutet, dass keine Fehlermeldungen bezüglich ungültiger Subskripte zurückgegeben werden, wenn ein bestimmtes Element nichts zurückgibt oder wenn ein Array-Feld  `NULL` ist.

CHARACTER Typen::
Sie können die ``CHARACTER SET``-Klausel nutzen, um den Zeichensatz für die Datentypen `CHAR`, `VARCHAR` und `BLOB` (`SUB_TYPE TEXT`) zu definieren.
Wird der Zeichensatz nicht angegeben, wird der in der Datenbank als `DEFAULT CHARACTER SET` Zeichensatz verwendet.
Ist auch dieser nicht festgelegt, wird der Zeichensatz `NONE` als Standard für die Anlage von Domains verwendet. 
+
[WARNING]
====
Bei Zeichensatz `NONE` werden Zeichendaten gespeichert und abgerufen, wie sie übermittelt wurden.
Daten in einer beliebigen Codierung können zu einer Spalte auf der Grundlage einer solchen Domain hinzugefügt werden.
Es ist jedoch nicht möglich, diese Daten zu einer Spalte mit einer anderen Codierung hinzuzufügen.
Da zwischen Quell- und Zielcodierung keine Transkription durchgeführt wird, können Fehler auftreten.
====

``DEFAULT``-Klausel::
Mit der optionalen ``DEFAULT``-Klausel können Sie einen Standardwert für die Domain angeben.
Dieser Wert wird der Tabellenspalte hinzugefügt, die diese Domain erbt, wenn die Anweisung `INSERT` ausgeführt wird, wenn in der DML-Anweisung kein Wert dafür angegeben ist.
Lokale Variablen und Argumente in PSQL-Modulen, die auf diese Domain verweisen, werden mit dem Standardwert initialisiert.
Verwenden Sie als Standardwert ein Literal eines kompatiblen Typs oder eine Kontextvariable eines kompatiblen Typs.

``NOT NULL``-Constraint::
Spalten und Variablen basierend auf einer Domain mit der ``NOT NULL``-Beschränkung werden daran gehindert, als `NULL` geschrieben zu werden, d.h. ein Wert ist _erforderlich_.
+
[CAUTION]
====
Achten Sie beim Anlegen einer Domain darauf, keine Einschränkungen zu spezifizieren, die einander  widersprechen würden.
Zum Beispiel sind NOT NULL und DEFAULT NULL widersprüchlich.
====

``CHECK``-Constraint(s)::
Die optionale Klausel `CHECK` gibt Einschränkungen für die Domain an.
Eine Domainnbeschränkung gibt Bedingungen an, die von den Werten von Tabellenspalten oder Variablen erfüllt werden müssen, die von der Domain erben.
Eine Bedingung muss in Klammern eingeschlossen werden.
Eine Bedingung ist ein logischer Ausdruck (auch Prädikat genannt), der die booleschen Ergebnisse `TRUE`, `FALSE` und `UNKNOWN` zurückgeben kann.
Eine Bedingung gilt als erfüllt, wenn das Prädikat den Wert `TRUE` oder "`UNKNOWN`" (entspricht `NULL`) zurückgibt.
Wenn das Prädikat `FALSE` zurückgibt, ist die Bedingung für die Annahme nicht erfüllt.

`VALUE`-Schlüsselwort::
Das Schlüsselwort `VALUE` in einer Domainbeschränkung ersetzt die Tabellenspalte, die auf dieser Domain oder einer Variablen in einem PSQL-Modul basiert.
Es enthält den Wert, der der Variablen oder der Tabellenspalte zugewiesen ist.
`VALUE` kann überall in der ``CHECK``-Bedingung verwendet werden, obwohl es normalerweise im linken Teil der Bedingung  verwendet wird.

`COLLATE`::
Mit der optionalen ``COLLATE``-Klausel können Sie die Sortierreihenfolge (Collation) angeben, wenn die Domain auf einem der String-Datentypen basiert, einschließlich ``BLOB``s mit Textsubtypen.
Wenn keine Sortierreihenfolge angegeben ist, ist die Sortierreihenfolge diejenige, die für den angegebenen Zeichensatz zum Zeitpunkt der Erstellung der Domain voreingestellt ist.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Domain erstellen.

[[fblangref25-ddl-createdomnexmpls-de]]
==== Beispiele für `CREATE DOMAIN`

. Erstellen einer Domain mit Werten von mehr als 1.000 und einem Standardwert von 10.000.
+
[source]
----
CREATE DOMAIN CUSTNO AS
  INTEGER DEFAULT 10000
  CHECK (VALUE > 1000);
----
. Erstellen einer Domain, die die Werte "Yes" und "No" in dem Standardzeichensatz annehmen kann, der während der Erstellung der Datenbank angegeben wurde.
+
[source]
----
CREATE DOMAIN D_BOOLEAN AS
  CHAR(3) CHECK (VALUE IN ('Yes', 'No'));
----
. Erstellen einer Domain mit dem Zeichensatz `UTF8` und der Sortierreihenfolge (Collation) ``UNICODE_CI_AI``.
+
[source]
----
CREATE DOMAIN FIRSTNAME AS
  VARCHAR(30) CHARACTER SET UTF8
  COLLATE UNICODE_CI_AI;
----
. Erstellen einer Domain vom Typ `DATE`, die NULL nicht akzeptiert und das aktuelle Datum als Standardwert verwendet.
+
[source]
----
CREATE DOMAIN D_DATE AS
  DATE DEFAULT CURRENT_DATE
  NOT NULL;
----
. Erstellen einer Domain, die als ein Array aus zwei Elementen des Typs `NUMERIC(18, 3)` definiert ist.
Der Start-Array-Index ist 1.
+
[source]
----
CREATE DOMAIN D_POINT AS
  NUMERIC(18, 3) [2];
----
+
[NOTE]
====
Über einen Array-Typ definierte Domainn dürfen nur zum Definieren von Tabellenspalten  verwendet werden.
Sie können keine Array-Domainn verwenden, um lokale Variablen in  PSQL-Modulen zu definieren.
====
. Erstellen einer Domain, deren Elemente nur in der Tabelle COUNTRY definierte Ländercodes sein können.
+
[source]
----
CREATE DOMAIN D_COUNTRYCODE AS CHAR(3)
  CHECK (EXISTS(SELECT * FROM COUNTRY
         WHERE COUNTRYCODE = VALUE));
----
+
[NOTE]
====
Das Beispiel zeigt nur die Möglichkeit, Prädikate mit Abfragen in der Domainntestbedingung zu verwenden.
Es wird nicht empfohlen, diesen Stil der Domain in der Praxis zu verwenden es sei denn, die Nachschlagetabelle enthält Daten, die niemals gelöscht werden.
====

.Siehe auch
<<fblangref25-ddl-domn-alter-de>>, <<fblangref25-ddl-domn-drop-de>>

[[fblangref25-ddl-domn-alter-de]]
=== `ALTER DOMAIN`

.Benutzt für
Die aktuellen Attribute einer Domain ändern oder umbenennen

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER DOMAIN _domain_name_
  [TO _new_name_]
  [TYPE <datatype>]
  [SET DEFAULT {<literal> | NULL | <context_var>} | DROP DEFAULT]
  [ADD [CONSTRAINT] CHECK (<dom_condition>) | DROP CONSTRAINT]

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING] [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<dom_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<dom_condition>)
  | NOT <dom_condition>
  | <dom_condition> OR <dom_condition>
  | <dom_condition> AND <dom_condition>

<operator> ::=
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    VALUE
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-alterdomn-de]]
.`ALTER DOMAIN` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|new_name
|Neuer Domainname, bestehend aus maximal 31 Zeichen

|datatype
|SQL-Datentyp

|literal
|Ein literaler Wert, der kompatibel zu _datatype_ ist

|context_var
|Jede Kontextvariable, deren Typ kompatibel ist mit _datatype_

|precision
|Die Gesamtzahl der signifikanten Ziffern, die ein Wert des _Datentyps_ aufnehmen kann (1..18)

|scale
|Die Anzahl der Stellen nach dem Dezimalkomma (0..__precision__)

|size
|Die maximale Größe einer Zeichenkette in Zeichen

|charset_name
|Der Name eines gültigen Zeichensatzes, falls sich der Zeichensatz der Domain vom Standardzeichensatz der Datenbank unterscheidet

|subtype_num
|`BLOB` Subtype-Nummer

|subtype_name
|``BLOB``-Subtyp-Mnemonikname

|seglen
|Segmentgröße (max. 65535)

|select_one
|Eine skalare ``SELECT``-Anweisung -- Auswählen einer Spalte und Zurückgeben nur eines row

|select_list
|Eine ``SELECT``-Anweisung, die eine Spalte auswählt und null oder mehr Zeilen zurückgibt

|select_expr
|Eine ``SELECT``-Anweisung, die eine Spalte oder mehrere Spalten auswählt und null oder mehr Zeilen zurückgibt

|expression
|Ein Ausdruck, der auf einen Wert auflöst, der mit _datatype_ kompatibel ist

|genname
|Sequenzname (Generatorname)

|func
|Interne Funktion oder UDF
|===

Die Anweisung `ALTER DOMAIN` ermöglicht Änderungen an den aktuellen Attributen einer Domain einschließlich ihres Namens.
Sie können beliebig viele Domainnänderungen in einer ``ALTER DOMAIN``-Anweisung vornehmen.

`TO __name__`::
Verwenden Sie die ``TO``-Klausel, um die Domain umzubenennen, solange keine Abhängigkeiten von der Domain vorhanden sind, z.B. Tabellenspalten, lokale Variablen oder Prozedurargumente, die darauf verweisen.

`SET DEFAULT`::
Mit der ``SET DEFAULT``-Klausel können Sie einen neuen Standardwert setzen.
Wenn die Domain bereits einen Standardwert hat, muss sie nicht zuerst gelöscht werden, sondern wird durch die neue ersetzt.

`DROP DEFAULT`::
Mit dieser Klausel löschen Sie einen zuvor festgelegten Standardwert und ersetzen ihn durch `NULL`.

`ADD CONSTRAINT CHECK`::
Verwenden Sie die Klausel `ADD CONSTRAINT CHECK`, um einen ``CHECK``-Constraint zur Domain hinzuzufügen.
Existiert bereits ein ``CHECK``-Constraint für die Domain, muss dieser zunächst gelöscht werden.
Nutzen Sie dazu ein ``ALTER DOMAIN``-Statement, das eine ``DROP CONSTRAINT``-Klausel beinhaltet.

`TYPE`::
Die ``TYPE``-Klausel wird verwendet, um den Datentyp der Domain in eine andere, kompatible zu ändern.
Das System verbietet jede Änderung des Typs, der zu Datenverlust führen könnte.
Ein Beispiel wäre, wenn die Anzahl der Zeichen im neuen Typ kleiner als im vorhandenen Typ wäre.

[IMPORTANT]
====
Wenn Sie die Attribute einer Domain ändern, kann der vorhandene PSQL-Code ungültig werden.
Für Informationen zur Erkennung lesen Sie bitte den Artikel  <<fblangref25-appx01-supp-rdb-validblr-de,[ref]_Das RDB$VALID_BLR Feld_>> in Anhang A.
====

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Domain ändern, sofern sie nicht durch Abhängigkeiten von Objekten verhindert wird, für die dieser Benutzer nicht über ausreichende Berechtigungen verfügt.

[[fblangref25-ddl-domn-cannotalter-de]]
==== Was die Ausführung von `ALTER DOMAIN` verhindert

* Wenn die Domain als ein Array deklariert wurde, ist es nicht möglich, ihren Typ oder ihre Dimensionen zu ändern.
Es kann auch kein anderer Typ in einen ``ARRAY``-Typ geändert werden.
* In Firebird 2.5 und niedriger darf die Einschränkung `NOT NULL` weder für eine Domain aktiviert noch deaktiviert werden.
* Es gibt keine Möglichkeit, die Standardkollation zu ändern, ohne die Domain zu löschen und sie mit den gewünschten Attributen neu zu erstellen.

[[fblangref25-ddl-domn-alterdomnexmpls-de]]
==== Beispiele für `ALTER DOMAIN`

. Ändern des Datentyps in `INTEGER` und festlegen oder ändern des Standardwerts auf 2.000:
+
[source]
----
ALTER DOMAIN CUSTNO
  TYPE INTEGER
  SET DEFAULT 2000;
----
. Umbenennen einer Domain.
+
[source]
----
ALTER DOMAIN D_BOOLEAN TO D_BOOL;
----
. Löschen des Standardwerts und Hinzufügen einer Einschränkung für die Domain:
+
[source]
----
ALTER DOMAIN D_DATE
  DROP DEFAULT
  ADD CONSTRAINT CHECK (VALUE >= date '01.01.2000');
----
. Ändern des ``CHECK``-Constraints:
+
[source]
----
ALTER DOMAIN D_DATE
  DROP CONSTRAINT;

ALTER DOMAIN D_DATE
  ADD CONSTRAINT CHECK
    (VALUE BETWEEN date '01.01.1900' AND date '31.12.2100');
----
. Ändern des Datentyps, um die zulässige Anzahl von Zeichen zu erhöhen:
+
[source]
----
ALTER DOMAIN FIRSTNAME
  TYPE VARCHAR(50) CHARACTER SET UTF8;
----

.Siehe auch
<<fblangref25-ddl-domn-create-de>>, <<fblangref25-ddl-domn-drop-de>>

[[fblangref25-ddl-domn-drop-de]]
=== `DROP DOMAIN`

.Benutzt für
Eine bestehende Domain löschen

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP DOMAIN _domain_name_
----

Die Anweisung `DROP DOMAIN` löscht eine Domain, die in der Datenbank vorhanden ist.
Es ist nicht möglich, eine Domain zu löschen, wenn sie von Spalten der Datenbanktabellen referenziert oder in einem PSQL-Modul verwendet wird.
Um eine Domain zu löschen, die verwendet wird, müssen alle Spalten in allen Tabellen, die auf die Domain verweisen, gelöscht werden und alle Verweise auf die Domain müssen aus PSQL-Modulen entfernt werden.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Domain löschen.

[float]
===== Beispiele

Löschen der COUNTRYNAME-Domain:

[source]
----
DROP DOMAIN COUNTRYNAME;
----

.Siehe auch
<<fblangref25-ddl-domn-create-de>>, <<fblangref25-ddl-domn-alter-de>>

[[fblangref25-ddl-tbl-de]]
== `TABLE`

Als relationales DBMS speichert Firebird Daten in Tabellen.
Eine Tabelle ist eine flache, zweidimensionale Struktur, die eine beliebige Anzahl von Zeilen enthält.
Tabellenzeilen werden oft als _Datensätze_ bezeichnet.

Alle Zeilen in einer Tabelle haben die gleiche Struktur und bestehen aus Spalten.
Tabellenspalten werden oft als _Felder_ bezeichnet.
Eine Tabelle muss  mindestens eine Spalte haben.
Jede Spalte enthält einen einzelnen Typ von SQL-Daten.

In diesem Abschnitt wird beschrieben, wie Sie Tabellen in einer Datenbank erstellen, ändern und löschen.

[[fblangref25-ddl-tbl-create-de]]
=== `CREATE TABLE`

.Benutzt für
Erstellen einer neuen Tabelle (Relation)

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
CREATE [GLOBAL TEMPORARY] TABLE _tablename_
  [EXTERNAL [FILE] '_filespec_']
  (<col_def> [, {<col_def> | <tconstraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]

<col_def> ::= <regular_col_def> | <computed_col_def>

<regular_col_def> ::=
  _colname_ {<datatype> | _domainname_}
  [DEFAULT {<literal> | NULL | <context_var>}]
  [NOT NULL]
  [<col_constraint>]
  [COLLATE _collation_name_]

<computed_col_def> ::=
  _colname_ [<datatype>]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT} [<array_dim>]
  | {FLOAT | DOUBLE PRECISION} [<array_dim>]
  | {DATE | TIME | TIMESTAMP} [<array_dim>]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] [<array_dim>]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [<array_dim>] [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)] [<array_dim>]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<array_dim> ::= '[' [_m_:{endsb}__n__ [, [_m_:{endsb}__n__ ...] ']'

<col_constraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY [<using_index>]
    | UNIQUE      [<using_index>]
    | REFERENCES _other_table_ [(_colname_)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }

<tconstraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY (<col_list>) [<using_index>]
    | UNIQUE      (<col_list>) [<using_index>]
    | FOREIGN KEY (<col_list>)
        REFERENCES _other_table_ [(<col_list>)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }"

<col_list> ::= _colname_ [, _colname_ ...]

<using_index> ::= USING
  [ASC[ENDING] | DESC[ENDING]] INDEX _indexname_

<check_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<check_condition>)
  | NOT <check_condition>
  | <check_condition> OR <check_condition>
  | <check_condition> AND <check_condition>

<operator> ::=
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    _colname_ ['['_array_idx_ [, _array_idx_ ...]']']
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-createtbl-de]]
.`CREATE TABLE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|tablename
|Name (Kennung) für die Tabelle.
Sie kann aus bis zu 31 Zeichen bestehen und in der Datenbank eindeutig sein.

|filespec
|Dateispezifikation (nur für externe Tabellen).
Vollständiger Dateiname und Pfad, der in einfache Anführungszeichen eingeschlossen ist, unter Berücksichtigung der Regeln des lokalen Dateisystems.
Die Datei muss physisch mit dem Host-Computer von Firebird verbunden sein.

|colname
|Name (Bezeichner) für eine Spalte in der Tabelle.
Kann aus bis zu 31 Zeichen bestehen und in der Tabelle eindeutig sein.

|datatype
|SQL-Datentyp

|col_constraint
|Spalten-Constraint

|tconstraint
|Tabellen-Constraint

|constr_name
|Der Name (Bezeichner) einer Einschränkung.
Darf aus bis zu 31 Zeichen bestehen.

|other_table
|Der Name der Tabelle, auf die die Constraint verweist

|other_col
|Der Name der Spalte in _other_table_, auf die der Fremdschlüssel verweist

|literal
|Ein Literalwert, der im angegebenen Kontext zulässig ist

|context_var
|Beliebige Kontextvariable, deren Datentyp im angegebenen Kontext zulässig ist

|check_condition
|Die Bedingung, die auf eine CHECK-Einschränkung angewendet wird, die als wahr, false oder `NULL` aufgelöst wird.

|collation
|Collation

|array_dim
|Array-Dimensionen

|m, n
|INTEGER-Ganzzahlen die den Bereich der Array-Dimensionen angeben

|precision
|Die Gesamtzahl der signifikanten Ziffern, die ein Wert des Datentyps halten kann (1..18)

|scale
|Die Anzahl Stellen nach dem Dezimalkomma (0..__precision__)

|size
|Die maximale Größe eines Strings in Zeichen

|charset_name
|Der Name eines gültigen Zeichensatzes, falls der Zeichensatz der Spalte vom Standardzeichensatz der Datenbank abweichen soll

|subtype_num
|``BLOB``-Subtype-Nummer

|subtype_name
|``BLOB``-Subtyp-Mnemonikname

|seglen
|Segmentgröße (max. 65535)

|select_one
|Eine skalare ``SELECT``-Anweisung -- auswählen einer Spalte und zurückgeben nur einer Zeile

|select_list
|Eine ``SELECT``-Anweisung, die eine Spalte auswählt und null oder mehr Zeilen zurückgibt

|select_expr
|Eine ``SELECT``-Anweisung, die eine oder mehrere Spalten auswählt und null oder mehr Zeilen zurückgibt

|expression
|Ein Ausdruck, der auf einen Wert auflöst, der im angegebenen Kontext zulässig ist

|genname
|Sequenzname (Generatorname)

|func
|Interne Funktion oder UDF
|===

Die Anweisung `CREATE TABLE` erstellt eine neue Tabelle.
Jeder Benutzer kann sie erstellen und ihr Name muss unter den Namen aller Tabellen, Ansichten und gespeicherten Prozeduren in der Datenbank eindeutig sein. 

Eine Tabelle muss mindestens eine Spalte enthalten, die nicht berechnet wird, und die Namen der Spalten müssen in der Tabelle eindeutig sein.

Eine Spalte muss entweder einen expliziten _SQL-Datentyp_, den  Namen einer _Domain_, dessen Attribute für die Spalte kopiert werden  oder als ``COMPUTED BY``-Ausdruck (ein _berechnetes Feld_).

Eine Tabelle kann eine beliebige Anzahl von Tabelleneinschränkungen haben, einschließlich keiner.

[[fblangref25-ddl-tbl-nonnull-de]]
==== Eine Spalte nicht nullbar machen

In Firebird sind Spalten standardmäßig nullwertig.
Die optionale ``NOT NULL``-Klausel gibt an, dass die Spalte `NULL` anstelle eines Wertes nicht verwenden darf.

[[fblangref25-ddl-tbl-character-de]]
==== Zeichen-Spalten

Sie können die ``CHARACTER SET``-Klausel verwenden, um den Zeichensatz für die Typen `CHAR`, `VARCHAR` und `BLOB (SUB_TYPE TEXT)` anzugeben.
Wenn der Zeichensatz nicht angegeben ist, wird standardmäßig der während der Erstellung der Datenbank angegebene Zeichensatz verwendet.
Wurde während der Erstellung der Datenbank kein Zeichensatz angegeben, wird standardmäßig der Zeichensatz `NONE`  übernommen.
In diesem Fall werden Daten gespeichert und abgerufen, wie sie übermittelt wurden.
Daten in einer beliebigen Kodierung können zu einer solchen Spalte hinzugefügt werden, aber es ist nicht möglich, diese Daten zu einer Spalte mit einer anderen Kodierung hinzuzufügen.
Keine Transliteration wird zwischen den Quell- und Zielcodierungen, das dies zu Fehlern führen kann.

Mit der optionalen ``COLLATE``-Klausel können Sie die Sortierreihenfolge für Zeichendatentypen angeben, einschließlich `BLOB SUB_TYPE TEXT`.
Wenn keine Sortierreihenfolge angegeben ist, wird standardmäßig die Sortierreihenfolge angewendet, die für den  angegebenen Zeichensatz beim Erstellen der Spalte standardmäßig verwendet wird.

[[fblangref25-ddl-tbl-default-de]]
==== Angabe eines ``DEFAULT``-Wertes

Die optionale ``DEFAULT``-Klausel erlaubt Ihnen, den Standardwert für eine Tabellenspalte festzulegen.
Dieser Wert wird der Spalte während der Ausführung eines ``INSERT``-Statements zugewiesen, sofern kein anderer Wert festgelegt wurde _und_ diese Spalte von der ``INSERT``-Anweisung ausgelassen wurde.

Der Standardwert kann ein Literal eines kompatiblen Typs sein, eine Kontextvariable, die mit dem Datentyp der Spalte typkompatibel ist, oder ``NULL``, wenn die Spalte dies zulässt.
Wenn kein Standardwert explizit angegeben ist, wird NULL impliziert.

Ein Ausdruck kann nicht als Standardwert verwendet werden.

[[fblangref25-ddl-tbl-domainbased-de]]
==== Domain-basierte Spalten

Um eine Spalte zu definieren, können Sie eine zuvor definierte Domain verwenden.
Wenn die Definition einer Spalte auf einer Domain basiert, enthält sie möglicherweise einen neuen Standardwert, zusätzliche ``CHECK``-Einschränkungen und eine ``COLLATE``-Klausel, die die in der Domain angegebenen Werte überschreibt.
Die Definition einer solchen Spalte kann zusätzliche Spaltenbeschränkungen enthalten (z.B. `NOT NULL`), wenn die Domain diese nicht besitzt.

[IMPORTANT]
====
Es ist nicht möglich, eine Domain-basierte Spalte zu definieren, die nullbar ist, wenn die Domain mit dem Attribut `NOT NULL` definiert wurde.
Wenn Sie eine Domain haben möchten, die zum Definieren sowohl von nullbaren als auch von nicht-nullbaren Spalten und Variablen verwendet werden kann, empfiehlt es sich, die Domain auf null zu setzen und `NOT NULL` in der Spaltendefinition zu verwenden.
====

[[fblangref25-ddl-tbl-computedby-de]]
==== Berechnete Felder

Berechnete Felder können in der Datenbank mittels `COMPUTED [BY]` oder `GENERATED ALWAYS AS` (gemäß SQL:2003 Standard) definiert werden.
Sie meinen dasselbe.
Das Beschreiben des Datentyps ist für berechnete Felder nicht erforderlich (aber möglich), da das DBMS den entsprechenden Typ als Ergebnis der Ausdrucksanalyse berechnet und speichert.
Entsprechende Operationen für die in einem Ausdruck enthaltenen Datentypen müssen genau angegeben werden.

Wenn der Datentyp explizit für ein berechnetes Feld angegeben wird, wird das Berechnungsergebnis in den angegebenen Typ konvertiert.
Dies bedeutet zum Beispiel, dass das Ergebnis eines numerischen Ausdrucks als String dargestellt werden kann.

In einer Abfrage, die eine ``COMPUTED BY``-Spalte auswählt, wird der Ausdruck für jede Zeile der ausgewählten Daten ausgewertet.

[TIP]
====
Anstelle einer berechneten Spalte ist es in manchen Fällen sinnvoll, eine reguläre Spalte zu verwenden, deren Wert in  Triggern zum Hinzufügen und Aktualisieren von Daten ausgewertet wird.
Es kann die Leistung des Einfügens / Aktualisierens von Datensätzen verringern, aber es wird die Leistung der Datenabfrage erhöhen.
====

[[fblangref25-ddl-tbl-array-de]]
==== Definieren einer ``ARRAY``-Spalte

* Wenn die Spalte ein Array sein soll, kann der Basistyp ein beliebiger SQL-Datentyp sein, mit Ausnahme von `BLOB` und `ARRAY`.
* Die Grenzen des Arrays werden in eckigen Klammern angegeben.
(Im <<fblangref25-ddl-tbl-create-de, Syntaxblock>> werden diese Klammern fett dargestellt, um sie von eckigen Klammern zu unterscheiden, die optionale Syntaxelemente kennzeichnen.)
* Für jede Array-Dimension definieren eine oder zwei ganze Zahlen die untere und obere Grenze ihres Indexbereichs:
** Standardmäßig sind Arrays 1-basiert.
Die untere Grenze ist implizit und nur die obere Grenze muss angegeben werden.
Eine einzelne Zahl kleiner als 1 definiert den Bereich _num_.
1 und eine Zahl größer als 1 definiert den Bereich 1..__num__.
** Zwei durch einen Doppelpunkt getrennte Zahlen ('```:```') und optionaler Leerraum, der zweite ist größer als der erste, können verwendet werden, um den Bereich explizit zu definieren.
Eine oder beide Grenzen können kleiner als Null sein, solange die obere Grenze größer als die untere ist.
* Wenn das Array mehrere Dimensionen hat, müssen die Bereichsdefinitionen für jede Dimension durch Kommas und optionales Leerzeichen getrennt werden.
* Indizes werden _nur_ validiert, wenn ein Array tatsächlich existiert.
Dies bedeutet, dass keine Fehlermeldungen bezüglich ungültiger Subskripte zurückgegeben werden, wenn ein bestimmtes Element nichts zurückgibt oder wenn ein Array-Feld `NULL` ist.

[[fblangref25-ddl-tbl-constraints-de]]
==== Constraints

Es gibt vier Constraint-Typen.
Diese sind: 

* Primärschlüssel (`PRIMARY KEY`)
* Eindeutigkeitsschlüssel (`UNIQUE`)
* Fremdschlüssel (`REFERENCES`)
* ``CHECK``-Constraint (`CHECK`)

Constraints können auf Spaltenebene ("`Spaltenbeschränkungen`") oder auf Tabellenebene ("`Tabellenbeschränkungen`") angegeben werden.
Einschränkungen auf Tabellenebene sind erforderlich, wenn Schlüssel (Eindeutigkeitsbeschränkung, Primärschlüssel, Fremdschlüssel) über mehrere Spalten hinweg gebildet werden sollen und wenn eine ``CHECK``-Einschränkung neben der definierten Spalte andere Spalten in der Zeile einbezieht.
Die Syntax für einige Constraint-Typen kann je nachdem, ob die Constraint auf Spalten- oder Tabellenebene definiert wird, leicht unterschiedlich sein. 

* Eine Spaltenbeschränkung wird während einer Spaltendefinition angegeben, nachdem alle Spaltenattribute, mit Ausnahme von `COLLATION`, angegeben wurden und nur die in dieser Definition angegebene Spalte enthalten ist
* Einschränkungen auf Tabellenebene werden nach allen Spaltendefinitionen angegeben.
Sie sind ein flexiblerer Weg, um Einschränkungen festzulegen, da sie Einschränkungen für mehrere Spalten berücksichtigen können
* Sie können Einschränkungen auf Tabellen- und Spaltenebene im gleichen ``CREATE TABLE``-Statement mischen

Das System erstellt automatisch den entsprechenden Index für einen Primärschlüssel (`PRIMARY KEY`),  einen eindeutigen Schlüssel (`UNIQUE`) und einen Fremdschlüssel (`REFERENCES` ist eine Einschränkung auf Spaltenebene, `FOREIGN KEY REFERENCES` eine auf Tabellenebene).

[[fblangref25-ddl-tbl-constraints-names-de]]
===== Name für Constraints und ihre Indizes

Spaltenbeschränkungen und ihre Indizes werden automatisch benannt: 

* Der Constraint-Name besitzt die Form `INTEG_n`, wobei _n_ ein oder mehrere Ziffern repräsentiert
* Der Indexname besitzt die Form `RDB$PRIMARYn` (für einen Primärschlüsselindex), `RDB$FOREIGNn` (für einen Fremdschlüsselindex) oder `RDB$n` (für einen Eindeutigkeitsindex).
Auch hier repräsentiert _n_ eine oder mehrere Ziffern.

Die automatische Benennung von Einschränkungen auf Tabellenebene und deren Indizes folgt dem gleichen Muster, es sei denn, die Namen werden explizit angegeben.

[[fblangref25-ddl-tbl-constraints-named-de]]
====== Benannte Constratints

Ein Constraint kann explizit benannt werden, wenn für ihre Definition die ``CONSTRAINT``-Klausel verwendet wird.
Die ``CONSTRAINT``-Klausel ist optional für die Definition von Spaltentypen auf Spaltenebene.
Sie ist jedoch obligatorisch für Tabellenstufen.
Standardmäßig hat der Constraint-Index denselben Namen wie die Constraint.
Wenn für den Constraint-Index ein anderer Name gewünscht wird, kann eine ``USING``-Klausel enthalten sein.

[[fblangref25-ddl-tbl-constraints-using-de]]
====== Die ``USING``-Klausel

Die Klausel `USING` erlaubt Ihnen die benutzerdefiniserte Benennung des Index, der automatisch erstellt wurde und, optional, die Definition der Indexrichtigung -- entweder aufsteigend (Standardwert) oder absteigend.

[[fblangref25-ddl-tbl-constraints-pk-de]]
===== `PRIMARY KEY`

Der ``PRIMARY KEY``-Constraint wird auf einer oder mehr [term]_Schlüsselspalten_ gebildet, wobei jede Spalte mit einem ``NOT NULL``-Constraint definiert wurde.
Die Werte in den Schlüsselspalten einer Zeile müssen eindeutig sein.
Eine Tabelle kann nur einen Primärschlüssel enthalten. 

* Ein einspaltiger Primärschlüssel kann als Spalten- oder Tabellenebene definiert werden
* Ein mehrspaltiger Primärschlüssel muss als Einschränkung auf Tabellenebene angegeben werden.

[[fblangref25-ddl-tbl-constraints-uq-de]]
===== Der ``UNIQUE``-Constraint

Die Einschränkung `UNIQUE` definiert die Anforderung der Eindeutigkeit des Inhalts für die Werte in einem Schlüssel in der gesamten Tabelle.
Eine Tabelle kann eine beliebige Anzahl von eindeutigen Schlüsseleinschränkungen enthalten.

Wie beim Primärschlüssel kann die eindeutige Einschränkung mehrspaltig sein.
Ist dies der Fall, muss es als Einschränkung auf Tabellenebene angegeben werden.

[[fblangref25-ddl-tbl-uqkey-nulls-de]]
====== `NULL` in Eindeutigkeitsschlüsseln

Die SQL-99-konformen Regeln für ``UNIQUE``-Constraints erlauben einen oder mehrere ``NULL``s in einer Spalte mit einem ``UNIQUE``-Constraint.
Dadurch ist es möglich, eine ``UNIQUE``-Beschränkung für eine Spalte zu definieren, die nicht die Einschränkung `NOT NULL` hat.

Bei ``UNIQUE``-Schlüsseln, die mehrere Spalten umfassen, ist die Logik ein wenig kompliziert:

* Mehrere Zeilen mit Null in allen Spalten des Schlüssels sind erlaubt
* Mehrere Zeilen mit Schlüsseln mit verschiedenen Kombinationen von Nullen und Nicht-Null-Werten sind erlaubt
* Mehrere Zeilen mit denselben Schlüsselspalten null und der Rest mit Werten ungleich null sind zulässig, sofern sich die Werte in mindestens einer Spalte unterscheiden
* Mehrere Zeilen mit denselben Schlüsselspalten null und der Rest mit Nicht-Nullwerten, die in jeder Spalte gleich sind, verletzen die Bedingung

Die Regeln für die Eindeutigkeit lassen sich so zusammenfassen:

[quote]
Im Prinzip werden alle Nullen als eindeutig betrachtet.
Wenn jedoch zwei Zeilen exakt die gleichen Schlüsselspalten aufweisen, die mit Werten gefüllt sind, die nicht Null sind, werden die ``NULL``-Spalten ignoriert und die Eindeutigkeit wird für Spalten ohne Null festgelegt, als ob sie den gesamten Schlüssel  bilden würden.

.Illustration
[source]
----
RECREATE TABLE t( x int, y int, z int, unique(x,y,z));
INSERT INTO t values( NULL, 1, 1 );
INSERT INTO t values( NULL, NULL, 1 );
INSERT INTO t values( NULL, NULL, NULL );
INSERT INTO t values( NULL, NULL, NULL ); -- Erlaubt
INSERT INTO t values( NULL, NULL, 1 );    -- Nicht erlaubt
----

[[fblangref25-ddl-tbl-constraints-refs-de]]
===== `FOREIGN KEY`

Ein Fremdschlüssel stellt sicher, dass die teilnehmenden Spalten nur Werte enthalten dürfen, die auch in der referenzierten Spalte (n) in der Mastertabelle vorhanden sind.
Diese referenzierten Spalten werden oft als [term]_Zielspalten_ bezeichnet.
Sie müssen der Primärschlüssel oder ein eindeutiger Schlüssel in der Zieltabelle sein.
Sie müssen keine ``NOT NULL``-Einschränkung definiert haben, obwohl sie, wenn sie der Primärschlüssel sind, natürlich diese Einschränkung haben.

Die Fremdschlüsselspalten in der referenzierenden Tabelle selbst erfordern keine ``NOT NULL``-Einschränkung.

Ein einspaltiger Fremdschlüssel kann in der Spaltendeklaration definiert werden, wobei das Schlüsselwort `REFERENCES` verwendet wird:

[source]
----
... ,
  ARTIFACT_ID INTEGER REFERENCES COLLECTION (ARTIFACT_ID),
----

Die Spalte `ARTIFACT_ID` im Beispiel verweist auf eine gleichnamige Spalte in der Tabelle `COLLECTIONS`.

Sowohl einspaltige als auch mehrspaltige Fremdschlüssel können auf der [term]_Tabellenebene_ definiert werden.
Bei einem mehrspaltigen Fremdschlüssel ist die Deklaration auf Tabellenebene die einzige Option.
Diese Methode ermöglicht auch die Angabe eines optionalen Namens für die Einschränkung:

[source]
----
...
  CONSTRAINT FK_ARTSOURCE FOREIGN KEY(DEALER_ID, COUNTRY)
    REFERENCES DEALER (DEALER_ID, COUNTRY),
----

Beachten Sie, dass sich die Spaltennamen in der referenzierten Tabelle ("`master`") möglicherweise von denen im Fremdschlüssel unterscheiden.

[NOTE]
====
Wenn keine Zielspalten angegeben sind, verweist der Fremdschlüssel automatisch auf den Primärschlüssel der Zieltabelle.
====

[[fblangref25-ddl-tbl-constraints-fkactions-de]]
====== Fremdschlüsselaktionen

Mit den Unterklauseln `ON UPDATE` und `ON DELETE` ist es möglich, eine Aktion für die betroffenen Fremdschlüsselspalte anzugeben, wenn referenzierte Werte in der  Mastertabelle geändert werden:

`NO ACTION`:: (der Standard) - nichts wird getan
`CASCADE`:: Die Änderung in der Mastertabelle wird an die entsprechende(n) Zeile(n) in der untergeordneten Tabelle weitergegeben.
Wenn sich ein Schlüsselwert ändert, ändert sich der entsprechende Schlüssel in den untergeordneten Datensätzen auf den neuen Wert;
Wenn die Master-Zeile gelöscht wird, werden die untergeordneten Datensätze gelöscht.
`SET DEFAULT`:: Die Fremdschlüsselspalten in den betroffenen Zeilen werden wie bei der Definition der Fremdschlüsselbeschränkung _auf ihre Standardwerte gesetzt_.
`SET NULL`:: Die Fremdschlüssel-Spalten in den betroffenen Zeilen werden auf NULL gesetzt.

Die angegebene Aktion oder die Standardeinstellung `NO ACTION` könnte dazu führen, dass eine Fremdschlüsselspalte ungültig wird.
Beispielsweise könnte er einen Wert erhalten, der in der Mastertabelle nicht vorhanden ist, oder er könnte `NULL` werden, während die Spalte eine ``NOT NULL``-Einschränkung hat.
Solche Bedingungen führen dazu, dass die Operation in der Master-Tabelle mit einer Fehlermeldung fehlschlägt.

.Beispiel
[source]
----
...
  CONSTRAINT FK_ORDERS_CUST
    FOREIGN KEY (CUSTOMER) REFERENCES CUSTOMERS (ID)
      ON UPDATE CASCADE ON DELETE SET NULL
----

[[fblangref25-ddl-tbl-constraints-check-de]]
===== ``CHECK``-Constraint

Die Bedingung `CHECK` definiert die Bedingung, die die in diese Spalte eingefügten Werte erfüllen müssen.
Eine Bedingung ist ein logischer Ausdruck (auch Prädikat genannt), der die Werte TRUE, FALSE und UNKNOWN zurückgeben kann.
Eine Bedingung gilt als erfüllt, wenn das Prädikat TRUE oder den Wert UNKNOWN (entspricht NULL) zurückgibt.
Wenn das Prädikat FALSE zurückgibt, wird der Wert nicht akzeptiert.
Diese Bedingung wird zum  Einfügen einer neuen Zeile in die Tabelle (die Anweisung `INSERT`) und zum Aktualisieren des vorhandenen Werts der Tabellenspalte (die Anweisung `UPDATE` wo eine dieser Aktionen stattfinden kann (`UPDATE OR INSERT`, `MERGE`).

[IMPORTANT]
====
Eine ``CHECK``-Beschränkung für eine Domainbasierte Spalte ersetzt eine vorhandene ``CHECK``-Bedingung in der Domain nicht, sondern wird zu einer Ergänzung.
Die Firebird-Engine hat während der Definition keine Möglichkeit zu überprüfen, ob der zusätzliche `CHECK` nicht mit dem vorhandenen übereinstimmt.
====

``CHECK``-Bedingungen -- ob auf Tabellen- oder Spaltenebene definiert -- beziehen sich auf Tabellenspalten _durch ihren Namen_.
Die Verwendung des Schlüsselworts `VALUE` als Platzhalter wie auch in der ``CHECK``-Bedingung für Domains ist im Kontext der Definition von Spalteneinschränkungen nicht zulässig.

.Beispiele
mit zwei Einschränkungen auf Spaltenebene und einer auf Tabellenebene:

[source]
----
CREATE TABLE PLACES (
  ...
  LAT DECIMAL(9, 6) CHECK (ABS(LAT) <=  90),
  LON DECIMAL(9, 6) CHECK (ABS(LON) <= 180),
  ...
  CONSTRAINT CHK_POLES CHECK (ABS(LAT) < 90 OR LON = 0)
);
----

[[fblangref25-ddl-tbl-gtt-de]]
==== Global Temporary Tables (GTT)

Global Temporary Tables haben persistente Metadaten, aber ihre Inhalte sind transaktions- (Standard) oder verbindungsgebunden.
Jede Transaktion oder Verbindung hat eine eigene private Instanz eines GTT, isoliert von allen anderen.
Instanzen werden nur dann erstellt, wenn auf das GTT verwiesen wird.
Sie werden beim Beenden der Transaktion oder beim Trennen zerstört.
Die Metadaten eines GTT können mit `ALTER TABLE` bzw. `DROP TABLE` geändert oder entfernt werden.

.Syntax
[listing,subs=+quotes]
----
CREATE GLOBAL TEMPORARY TABLE _tablename_
  (<column_def> [, {<column_def> | <table_constraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
----

.Hinweise zur Syntax
[NOTE]
====
* `ON COMMIT DELETE ROWS` erstellt eine transaktionsgebundene GTT (der Standard) `ON COMMIT PRESERVE ROWS` eine verbindungsgebundene GTT
* Eine ``EXTERNAL [FILE]``-Klausel ist nicht zulässig in der Definition einer GTT
====

[[fblangref25-ddl-tbl-gtt-restrictions-de]]
===== Einschränkungen für GTTs

GTTs können mit allen Features und Utensilien gewöhnlicher Tabellen (Schlüssel, Referenzen, Indizes, Trigger usw.) "`ausgestattet werden`", aber es gibt einige Einschränkungen:

* GTTs und reguläre Tabellen können sich nicht gegenseitig referenzieren
* Eine verbindungsgebundene ("`PRESERVE ROWS`") GTT kann nicht auf eine transaktionsgebundene ("`DELETE ROWS`") GTT verweisen
* Domain-Constraints können nicht auf GTTs verweisen
* Die Zerstörung einer GTT-Instanz am Ende ihres Lebenszyklus löst keine `BEFORE`/`AFTER`-Löschtrigger aus

[TIP]
====
In einer vorhandenen Datenbank ist es nicht immer einfach, eine reguläre Tabelle von einer GTT oder einer GTT auf Transaktions- von einer GTT auf Verbindungsebene zu unterscheiden.
Verwenden Sie diese Abfrage, um herauszufinden, welche Art von Tabelle Sie betrachten:

[source]
----
select t.rdb$type_name
from rdb$relations r
join rdb$types t on r.rdb$relation_type = t.rdb$type
where t.rdb$field_name = 'RDB$RELATION_TYPE'
and r.rdb$relation_name = 'TABLENAME'
----

Für einen Überblick über die Typen aller Beziehungen in der Datenbank:

[source]
----
select r.rdb$relation_name, t.rdb$type_name
from rdb$relations r
join rdb$types t on r.rdb$relation_type = t.rdb$type
where t.rdb$field_name = 'RDB$RELATION_TYPE'
and coalesce (r.rdb$system_flag, 0) = 0
----

Das Feld `RDB$TYPE_NAME` zeigt `PERSISTENT` für eine reguläre Tabelle, `VIEW` für eine Ansicht, `GLOBAL_TEMPORARY_PRESERVE` für eine verbindungsgebundene GTT und `GLOBAL_TEMPORARY_DELETE` für eine transaktionsgebundene GTT.
====

[[fblangref25-ddl-tbl-external-de]]
==== Externe Tabellen

Die optionale Klausel `EXTERNAL [FILE]` gibt an, dass die Tabelle außerhalb der Datenbank in einer externen Textdatei mit Datensätzen fester Länge gespeichert wird.
Die Spalten einer Tabelle, die in einer externen Datei gespeichert sind, können von einem beliebigen Typ außer `BLOB`  oder `ARRAY` sein.

Alles, was Sie mit einer in einer externen Datei gespeicherten Tabelle tun können, ist, neue Zeilen einzufügen (`INSERT`) und die Daten abzufragen).
Das Aktualisieren vorhandener Daten (`UPDATE`) und das Löschen von Zeilen (`DELETE`) sind nicht möglich.

Eine Datei, die als externe Tabelle definiert ist, muss sich auf einem Speichergerät befinden, das physisch auf dem Computer vorhanden ist, auf dem der Firebird-Server ausgeführt wird.
Wenn der Parameter _ExternalFileAccess_ in der Konfigurationsdatei `firebird.conf`  auf `Restrict` lautet, muss in einem der dort aufgeführten Verzeichnisse das Argument für `Restrict` stehen.
Wenn die Datei nicht schon existiert, wird Firebird diese beim ersten Zugriff erstellen.

[IMPORTANT]
====
Die Möglichkeit, externe Dateien für eine Tabelle zu verwenden, hängt vom Wert ab, der für den Parameter  _ExternalFileAccess_ in `firebird.conf` festgelegt wurde:

* Wenn der Parameter auf `None` (Standardeinstellung) eingestellt ist, wird jeder Zugriff auf eine externe Datei verweigert.
* Die Einstellung `Restrict` wird empfohlen, um den Zugriff externer Dateien auf Verzeichnisse einzuschränken, die vom Serveradministrator explizit für diesen Zweck erstellt wurden.
Beispielsweise:
** `ExternalFileAccess = Restrict externalfiles` schränkt den Zugriff auf ein Verzeichnis namens `externalfiles` direkt unterhalb des Firebird Wurzelverzeichnisses ein
** `ExternalFileAccess = d:\databases\outfiles; e:\infiles` schränkt den Zugriff auf die zwei angegebenen Verzeichnisse des Windows-Hostservers ein.
Beachten Sie, dass jeder Pfad, der eine Netzwerkzuordnung ist, nicht funktioniert.
Pfade, die in einfachen oder doppelten Anführungszeichen eingeschlossen sind, funktionieren auch nicht.
* Wenn dieser Parameter auf `Full` eingestellt ist, kann auf externe Dateien im Host-Dateisystem zugegriffen werden.
Es schafft eine Sicherheitslücke und wird nicht empfohlen.
====

[[fblangref25-ddl-tbl-ext-format-de]]
===== Externes Dateiformat

Das "`Zeilen`"-Format einer externen Tabelle besteht aus fester Länge.
Es gibt keine Feldbegrenzer: Sowohl Feld- als auch Zeilengrenzen werden durch die maximale Größe der Felddefinitionen in Bytes bestimmt.
Dies ist sowohl beim Definieren der Struktur der externen Tabelle als auch beim Entwerfen einer Eingabedatei für eine externe Tabelle wichtig, die Daten aus einer anderen Anwendung importieren soll.
Das ubiquitäre "`.csv`"-Format ist z.B. nicht nützlich als Eingabedatei und kann nicht direkt in eine externe Datei generiert werden.

Der nützlichste Datentyp für die Spalten externer Tabellen ist der Typ `CHAR` mit fester Länge mit geeigneten Längen für die Daten, die sie tragen sollen.
Datums- und Zahlentypen können problemlos zu und von Zeichenketten umgewandelt werden, solange die Dateien nicht von einer anderen Firebird-Datenbank gelesen werden sollen, werden die nativen Datentypen externen Anwendungen als unparsbar "`alphabetti`" angezeigt.

Natürlich gibt es Möglichkeiten, typisierte Daten zu manipulieren, um Ausgabedateien von Firebird zu generieren, die als Eingabedateien für andere Anwendungen mithilfe von gespeicherten Prozeduren mit oder ohne externe Tabellen gelesen werden können.
Solche Techniken liegen außerhalb des Bereichs einer Sprachreferenz.
Hier finden Sie einige Richtlinien und Tipps zum Erstellen und Arbeiten mit einfachen Textdateien, da die externe Tabellenfunktion häufig als einfache Möglichkeit zum Erstellen oder Lesen von transaktionsunabhängigen Protokollen verwendet wird, die offline in einem Texteditor oder in einem Auditing untersucht werden können Anwendung.

[[fblangref25-ddl-tbl-ext-format-delimiter-de]]
====== Zeilenbegrenzer

Im Allgemeinen sind externe Dateien nützlicher, wenn Zeilen durch ein Trennzeichen in Form einer "`newline`"-Sequenz getrennt werden, die von Leseanwendungen auf der vorgesehenen Plattform erkannt wird.
Für die meisten Kontexte unter Windows ist dies die Zwei-Byte-CRLF-Sequenz, Wagenrücklauf (ASCII-Code dezimal 13) und  Zeilenvorschub (ASCII-Code dezimal 10).
Auf POSIX ist LF für sich allein üblich;
Bei einigen MacOSX-Anwendungen kann es sich um LFCR handeln.
Es gibt verschiedene Möglichkeiten, diese Begrenzerspalte zu füllen.
In unserem Beispiel unten geschieht dies mittel Before Insert-Trigger und der internen Funktion `ASCII_CHAR`.

====== Beispiel einer externen Tabelle

In unserem Beispiel definieren wir eine externe Protokolltabelle, die von einem Ausnahmehandler in einer gespeicherten  Prozedur oder einem Trigger verwendet werden kann.
Die externe Tabelle wird ausgewählt, da die Nachrichten aus den behandelten Ausnahmen im Protokoll beibehalten werden, selbst wenn die Transaktion, die den Prozess gestartet hat, aufgrund einer anderen, nicht behandelten Ausnahme schließlich zurückgesetzt wird.
Zu Demonstrationszwecken gibt es nur zwei Datenspalten, einen Zeitstempel und eine Nachricht.
Die dritte Spalte speichert den Zeilenbegrenzer:

[source]
----
CREATE TABLE ext_log
  EXTERNAL FILE 'd:\externals\log_me.txt' (
  stamp CHAR (24),
  message CHAR(100),
  crlf CHAR(2) -- for a Windows context
);
COMMIT;
----

Jetzt noch einen Trigger erstellen, der Zeitstempel und Zeilenbegrenzer festlegt, sobald eine Nachricht in die Datei geschrieben wird:

[source]
----
SET TERM ^;
CREATE TRIGGER bi_ext_log FOR ext_log
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (new.stamp is NULL) then
    new.stamp = CAST (CURRENT_TIMESTAMP as CHAR(24));
  new.crlf = ASCII_CHAR(13) || ASCII_CHAR(10);
END ^
COMMIT ^
SET TERM ;^
----

Einfügen von Datensätzen (die von einem Exception-Handler oder Shakespeare-Fan gemacht worden sein könnten):

[source]
----
insert into ext_log (message)
values('Shall I compare thee to a summer''s day?');
insert into ext_log (message)
values('Thou art more lovely and more temperate');
----

Die Ausgabe:

[source]
----
2015-10-07 15:19:03.4110Shall I compare thee to a summer's day?
2015-10-07 15:19:58.7600Thou art more lovely and more temperate
----

[[fblangref25-ddl-tbl-exmpls-de]]
==== Beispiele für `CREATE TABLE`

. Erstellen der Tabelle `COUNTRY` mit dem als Spaltenbeschränkung angegebenen Primärschlüssel.
+
[source]
----
CREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL
);
----
. Erstellen der ``STOCK``-Tabelle mit dem auf der Spaltenebene angegebenen benannten Primärschlüssel und dem auf der Tabellenebene angegebenen benannten eindeutigen Schlüssel.
+
[source]
----
CREATE TABLE STOCK (
  MODEL     SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID    INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID)
);
----
. Erstellen der ``JOB``-Tabelle mit einer Primärschlüsselbeschränkung, die zwei Spalten umfasst, eine Fremdschlüsselbeschränkung für die Tabelle `COUNTRY` und eine ``CHECK``-Einschränkung auf Tabellenebene.
Die Tabelle enthält außerdem eine Reihe von 5 Elementen.
+
[source]
----
CREATE TABLE JOB (
  JOB_CODE        JOBCODE NOT NULL,
  JOB_GRADE       JOBGRADE NOT NULL,
  JOB_COUNTRY     COUNTRYNAME,
  JOB_TITLE       VARCHAR(25) NOT NULL,
  MIN_SALARY      NUMERIC(18, 2) DEFAULT 0 NOT NULL,
  MAX_SALARY      NUMERIC(18, 2) NOT NULL,
  JOB_REQUIREMENT BLOB SUB_TYPE 1,
  LANGUAGE_REQ    VARCHAR(15) [1:5],
  PRIMARY KEY (JOB_CODE, JOB_GRADE),
  FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY)
  ON UPDATE CASCADE
  ON DELETE SET NULL,
  CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY)
);
----
. Erstellen der ``PROJECT``-Tabelle mit Primär-, Fremd- und eindeutigen Schlüsseleinschränkungen mit benutzerdefinierten Indexnamen, die mit der ``USING``-Klausel angegeben wurden.
+
[source]
----
CREATE TABLE PROJECT (
  PROJ_ID     PROJNO NOT NULL,
  PROJ_NAME   VARCHAR(20) NOT NULL UNIQUE USING DESC INDEX IDX_PROJNAME,
  PROJ_DESC   BLOB SUB_TYPE 1,
  TEAM_LEADER EMPNO,
  PRODUCT     PRODTYPE,
  CONSTRAINT PK_PROJECT PRIMARY KEY (PROJ_ID) USING INDEX IDX_PROJ_ID,
  FOREIGN KEY (TEAM_LEADER) REFERENCES EMPLOYEE (EMP_NO)
    USING INDEX IDX_LEADER
);
----
. Erstellen der Tabelle `SALARY_HISTORY` mit zwei berechneten Feldern.
Der erste wird gemäß dem Standard SQL:2003 deklariert, während der zweite gemäß der traditionellen Deklaration der berechneten Felder in Firebird deklariert wird.
+
[source]
----
CREATE TABLE SALARY_HISTORY (
  EMP_NO         EMPNO NOT NULL,
  CHANGE_DATE    TIMESTAMP DEFAULT 'NOW' NOT NULL,
  UPDATER_ID     VARCHAR(20) NOT NULL,
  OLD_SALARY     SALARY NOT NULL,
  PERCENT_CHANGE DOUBLE PRECISION DEFAULT 0 NOT NULL,
  SALARY_CHANGE  GENERATED ALWAYS AS
    (OLD_SALARY * PERCENT_CHANGE / 100),
  NEW_SALARY     COMPUTED BY
    (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
);
----
. Erstellen einer verbindungsabhängigen Global Temporary Table.
+
[source]
----
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
  ID  INTEGER NOT NULL PRIMARY KEY,
  TXT VARCHAR(32),
  TS  TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
ON COMMIT PRESERVE ROWS;
----
. Erstellen einer transaktionsbezogenen globalen temporären Tabelle, die einen Fremdschlüssel verwendet, um auf eine globale globale temporäre Tabelle mit Verbindungsbereich zu verweisen.
Die ``ON COMMIT``-Unterklausel ist optional, da `DELETE ROWS` die Standardeinstellung ist.
+
[source]
----
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
  ID        INTEGER NOT NULL PRIMARY KEY,
  PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
  TXT       VARCHAR(32),
  TS        TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ON COMMIT DELETE ROWS;
----

[[fblangref25-ddl-tbl-alter-de]]
=== `ALTER TABLE`

.Benutzt für
Ändern der Tabellenstruktur.

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
ALTER TABLE _tablename_
  <operation> [, <operation> ...]

<operation> ::=
    ADD <col_def>
  | ADD <tconstraint>
  | DROP _colname_
  | DROP CONSTRAINT _constr_name_
  | ALTER [COLUMN] _colname_ <col_mod>

<col_def> ::= <regular_col_def> | <computed_col_def>

<regular_col_def> ::=
  _colname_ {<datatype> | _domainname_}
  [DEFAULT {<literal> | NULL | <context_var>}]
  [NOT NULL]
  [<col_constraint>]
  [COLLATE _collation_name_]

<computed_col_def> ::=
  _colname_ [<datatype>]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)

<col_mod> ::= <regular_col_mod> | <computed_col_mod>

<regular_col_mod> ::=
    TO _newname_
  | POSITION _newpos_
  | TYPE {<datatype> | _domainname_}
  | SET DEFAULT {<literal> | NULL | <context_var>}
  | DROP DEFAULT

<computed_col_mod> ::=
    TO _newname_
  | POSITION _newpos_
  | [TYPE <datatype>] {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT} [<array_dim>]
  | {FLOAT | DOUBLE PRECISION} [<array_dim>]
  | {DATE | TIME | TIMESTAMP} [<array_dim>]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] [<array_dim>]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [<array_dim>] [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)] [<array_dim>]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<array_dim> ::= '[' [_m_:{endsb}__n__ [,[_m_:{endsb}__n__ ...] ']'

<col_constraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY [<using_index>]
    | UNIQUE      [<using_index>]
    | REFERENCES _other_table_ [(_colname_)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }

<tconstraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY (<col_list>) [<using_index>]
    | UNIQUE      (<col_list>) [<using_index>]
    | FOREIGN KEY (<col_list>)
        REFERENCES _other_table_ [(<col_list>)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }

<col_list> ::= _colname_ [, _colname_ ...]

<using_index> ::= USING
  [ASC[ENDING] | DESC[ENDING]] INDEX _indexname_

<check_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<search_condition>)
  | NOT <search_condition>
  | <search_condition> OR <search_condition>
  | <search_condition> AND <search_condition>

<operator> ::=
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    _colname_ ['['_array_idx_ [, _array_idx_ ...]']']
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-altertbl-de]]
.`ALTER TABLE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|tablename
|Name (Kennung) für die Tabelle.
Sie kann aus bis zu 31 Zeichen bestehen und in der Datenbank eindeutig sein.

|operation
|Eine der verfügbaren Operationen, die die Struktur der Tabelle verändert

|colname
|Name (Bezeichner) für eine Spalte in der Tabelle, max. 31 Zeichen.
Muss in der Tabelle eindeutig sein.

|newname
|Neuer Name (Bezeichner) für die Spalte, max. 31 Zeichen.
Muss in der Tabelle eindeutig sein.

|newpos
|Die neue Spaltenposition (eine Ganzzahl zwischen 1 und der Anzahl der Spalten in der Tabelle)

|col_constraint
|Spalten-Constraint

|tconstraint
|Tabellen-Constraint

|constr_name
|Der Name (Bezeichner) einer Einschränkung.
Darf aus bis zu 31 Zeichen bestehen.

|other_table
|Der Name der Tabelle, auf die die Constraint verweist

|literal
|Ein Literalwert, der im angegebenen Kontext zulässig ist

|context_var
|Beliebige Kontextvariable, deren Datentyp im angegebenen Kontext zulässig ist

|check_condition
|Die Bedingung, die auf eine ``CHECK``-Einschränkung angewendet wird, die als wahr, false oder `NULL` aufgelöst wird.


|collation
|Collation

|array_dim
|Array-Dimensionen

|m, n
|INTEGER-Ganzzahlen die den Bereich der Array-Dimensionen angeben

|precision
|Die Gesamtzahl der signifikanten Ziffern, die ein Wert des Datentyps halten kann (1..18)

|scale
|Die Anzahl Stellen nach dem Dezimalkomma (0..__precision__)

|size
|Die maximale Größe eines Strings in Zeichen

|charset_name
|Der Name eines gültigen Zeichensatzes, falls der Zeichensatz der Spalte vom Standardzeichensatz der Datenbank abweichen soll

|subtype_num
|``BLOB``-Subtype-Nummer

|subtype_name
|``BLOB``-Subtyp-Mnemonikname

|seglen
|Segmentgröße (max. 65535)

|select_one
|Eine skalare ``SELECT``-Anweisung -- auswählen einer Spalte und zurückgeben nur einer Zeile

|select_list
|Eine ``SELECT``-Anweisung, die eine Spalte auswählt und null oder mehr Zeilen zurückgibt

|select_expr
|Eine ``SELECT``-Anweisung, die eine oder mehrere Spalten auswählt und null oder mehr Zeilen zurückgibt

|expression
|Ein Ausdruck, der auf einen Wert auflöst, der im angegebenen Kontext zulässig ist

|genname
|Sequenzname (Generatorname)

|func
|Interne Funktion oder UDF
|===

Die ``ALTER TABLE``-Anweisung ändert die Struktur einer vorhandenen Tabelle.
Mit einer Anweisung `ALTER TABLE` können Sie mehrere Operationen ausführen, Spalten und Einschränkungen hinzufügen und löschen sowie Spaltenangaben ändern.

Mehrere Operationen in einer Anweisung `ALTER TABLE` werden durch Kommata getrennt.

[[fblangref25-ddl-tbl-altrvcount-de]]
==== Zählung von Versionsinkrementen

Einige Änderungen in der Struktur einer Tabelle erhöhen den Metadatenänderungszähler ("`Versionszähler`"), der jeder Tabelle zugewiesen ist.
Die Anzahl der Metadatenänderungen ist für jede Tabelle auf 255 beschränkt.
Sobald der Zähler die Grenze von 255 erreicht hat, können Sie keine weiteren Änderungen an der Struktur der Tabelle vornehmen, ohne den Zähler zurückzusetzen.

[sidebar]
.So setzen Sie den Metadaten-Änderungszähler zurück
Sie sollten die Datenbank mithilfe des Dienstprogramms _gbak_ sichern und wiederherstellen.

[[fblangref25-ddl-tbl-altradd-de]]
==== Die ``ADD``-Klausel

Mit der ``ADD``-Klausel können Sie eine neue Spalte oder eine neue Tabellenbeschränkung hinzufügen.
Die Syntax zum Definieren der Spalte und die Syntax zum Definieren der Tabellenbeschränkung entsprechen denen, die für die Anweisung `CREATE TABLE` beschrieben wurden.

.Auswirkung auf die Versionszählung
* Jedes Mal, wenn eine neue Spalte hinzugefügt wird, wächst der Metadatenänderungszähler um eins
* Das Hinzufügen einer neuen Tabellenbeschränkung erhöht den Metadatenänderungszähler nicht

.Zu beachtende Punkte
[CAUTION]
====
. Seien Sie vorsichtig beim Hinzufügen einer neuen Spalte mit der Einschränkungsgruppe `NOT NULL`.
Es kann dazu führen, dass die logische Integrität von Daten beeinträchtigt wird, wenn Sie in einer Spalte, die nicht auf Null gesetzt werden kann, Datensätze mit `NULL`  haben.
Beim Hinzufügen einer nicht-nullbaren Spalte wird empfohlen, entweder einen Standardwert dafür festzulegen oder die Spalte in vorhandenen Zeilen mit einem anderen Wert als Null zu aktualisieren.
. Wenn eine neue ``CHECK``-Beschränkung hinzugefügt wird, werden vorhandene Daten nicht auf Übereinstimmung geprüft.
Es wird empfohlen, vorhandene Daten mit dem neuen ``CHECK``-Ausdruck zu testen.
====

[[fblangref25-ddl-tbl-altrdropcol-de]]
==== Die ``DROP``-Klausel

Die Klausel `DROP __Spaltenname__` löscht die angegebene Spalte aus der Tabelle.
Ein Versuch, eine Spalte zu löschen, schlägt fehl, wenn irgendetwas darauf verweist.
Betrachten Sie die folgenden Elemente als Quellen potenzieller Abhängigkeiten: 

* Spalten- oder Tabellenbeschränkungen
* Indizes
* Stored Procedures und Trigger
* Ansichten (Views)

.Auswirkung auf Versionszählung
Jedes Mal, wenn eine Spalte gelöscht wird, wird der Metadatenänderungszähler der Tabelle um eins erhöht.

[[fblangref25-ddl-tbl-altrdropconstr-de]]
==== Die ``DROP CONSTRAINT``-Klausel

Die ``DROP CONSTRAINT``-Klausel löscht die angegebene Spalten- oder Tabellenebenenbeschränkung.

Eine ``PRIMARY KEY``- oder ``UNIQUE``-Beschränkung kann nicht gelöscht werden, wenn sie in einer anderen Tabelle durch eine ``FOREIGN KEY``-Constraint referenziert wird.
Es ist notwendig, die ``FOREIGN KEY``-Beschränkung zu löschen, bevor Sie versuchen, die hierauf verweisenden ``PRIMARY KEY``-Constraints oder ``UNIQUE``-Constraints zu löschen.

.Auswirkung auf Versionszähler
Das Löschen einer Spaltenbeschränkung oder einer Tabellenbeschränkung erhöht den Metadatenänderungszähler nicht.

[[fblangref25-ddl-tbl-altraltrcol-de]]
==== Die ``ALTER [COLUMN]``-Klausel

Mit der ``ALTER [COLUMN]``-Klausel können Attribute bestehender Spalten geändert werden, ohne dass die Spalte gelöscht oder neu hinzugefügt werden muss.
Erlaubte Änderungen sind: 

* Ändern des Namens (wirkt sich nicht auf den Metadatenversionszähler aus)
* Ändern des Datentyps (erhöht den Metadatenversionszähler um eins)
* Ändern der Spaltenposition in der Spaltenliste der Tabelle (wirkt sich nicht auf den Metadatenversionszähler aus)
* Löschen des Standardspaltenwert (wirkt sich nicht auf den Metadatenversionszähler aus)
* Festlegen des Standardspaltenwertes oder den vorhandenen Standardwert ändern (hat keinen Einfluss auf den Metadatenversionszähler)
* Ändern des Typs und des Ausdrucks für eine berechnete Spalte (wirkt sich nicht auf den Metadatenversionszähler aus)

[[fblangref25-ddl-tbl-altraltrto-de]]
==== Umbenennen einer Spalte: das ``TO``-Schlüsselwort

Das ``TO``-Schlüsselwort mit einer neuen Kennung benennt eine vorhandene Spalte um.
Die Tabelle darf keine existierende Spalte haben, die den gleichen Bezeichner hat.

Es ist nicht möglich, den Namen einer Spalte zu ändern, die in einer Einschränkung enthalten ist: `PRIMARY KEY`, ``UNIQUE``-Schlüssel, `FOREIGN KEY`, Spaltenbeschränkung oder der ``CHECK``-Constraint einer Tabelle.

Das Umbenennen einer Spalte ist ebenfalls nicht zulässig, wenn die Spalte in einem Trigger, einer gespeicherten Prozedur  oder einer Ansicht (View) verwendet wird.

[[fblangref25-ddl-tbl-altraltrtyp-de]]
==== Ändern des Datentyps einer Spalte: Das ``TYPE``-Schlüsselwort

Das Schlüsselwort `TYPE` ändert den Datentyp einer vorhandenen Spalte in einen anderen, zulässigen Typ.
Eine Typänderung, die zu einem Datenverlust führen kann, wird nicht zugelassen.
Beispielsweise kann die Anzahl der Zeichen im neuen Typ für eine ``CHAR``- oder ``VARCHAR``-Spalte nicht kleiner sein als die bestehende Spezifikation dafür.

Wenn die Spalte als Array deklariert wurde, ist keine Änderung des Typs oder der Anzahl der Dimensionen zulässig.

Der Datentyp einer Spalte, die an einem Fremdschlüssel, einem Primärschlüssel oder einer eindeutigen Einschränkung beteiligt ist, kann überhaupt nicht geändert werden.

[[fblangref25-ddl-tbl-altraltrpos-de]]
==== Ändern der Position einer Spalte: Das ``POSITION``-Schlüsselwort

Das ``POSITION``-Schlüsselwort ändert die Position einer vorhandenen Spalte im fiktiven "`von links nach rechts`"-Layout des Datensatzes.

Die Nummerierung der Spaltenpositionen beginnt bei 1. 

* Wenn eine Position kleiner als 1 angegeben ist, wird eine Fehlermeldung zurückgegeben
* Wenn eine Positionsnummer größer als die Anzahl der Spalten in der Tabelle ist, wird die neue Position automatisch an die Anzahl der Spalten angepasst.

[[fblangref25-ddl-tbl-altrdefault-de]]
==== Die ``DROP DEFAULT``- und ``SET DEFAULT``-Klauseln

Die optionale ``DROP DEFAULT``-Klausel löscht den Standardwert für die Spalte, wenn sie zuvor durch eine ``CREATE TABLE``- oder ``ALTER TABLE``-Anweisung dort gesetzt wurde.

* Wenn die Spalte auf einer Domäne mit einem Standardwert basiert, wird der Standardwert auf die Standarddomain zurückgesetzt
* Ein Ausführungsfehler wird ausgelöst, wenn versucht wird, den Standardwert einer Spalte zu löschen, die keinen Standardwert hat oder deren Standardwert Domain-basiert ist

Die optionale ``SET DEFAULT``-Klausel setzt einen Standardwert für die Spalte.
Wenn die Spalte bereits einen Standardwert hat, wird sie durch die neue ersetzt.
Der Standardwert, der auf eine Spalte angewendet wird, überschreibt immer einen von einer Domain geerbten Wert.

[[fblangref25-ddl-tbl-altrcmptd-de]]
==== Die ``COMPUTED [BY]``- oder ``GENERATED ALWAYS AS``-Klauseln

Der Datentyp und der Ausdruck, die einer berechneten Spalte zugrunde liegen, können mit der ``ALTER TABLE ALTER [COLUMN]``-Anweisung angepasst werden.
Die Umwandlung einer regulären Spalte in eine berechnete und umgekehrt ist nicht zulässig.

[[fblangref25-ddl-tbl-altrtblnogo-de]]
==== Attribute, die nicht geändert werden können

Folgende Änderungen werden nicht unterstützt: 

* Aktivieren oder Deaktivieren der Einschränkung `NOT NULL` für eine Spalte
* Ändern der Standardkollation für eine Zeichentypspalte

Nur der Tabelleneigentümer und <<fblangref25-security-administrators-de,Administratoren>> haben die Berechtigung für `ALTER TABLE`.

[[fblangref25-ddl-tbl-altrtblexmpls-de]]
==== Beispiele für die Verwendung von `ALTER TABLE`

. Hinzufügen der Spalte `CAPITAL` zur Tabelle `COUNTRY`.
+
[source]
----
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25);
----
. Hinzufügen der ``CAPITAL``-Spalte mit der ``UNIQUE``-Einschränkung und Löschen der ``CURRENCY``-Spalte.
+
[source]
----
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25) NOT NULL UNIQUE,
  DROP CURRENCY;
----
. Hinzufügen der ``CHK_SALARY``-Prüfbedingung und eines Fremdschlüssels zur ``JOB``-Tabelle.
+
[source]
----
ALTER TABLE JOB
  ADD CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY),
  ADD FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY);
----
. Festlegen des Standardwerts für das Feld `MODEL`, Ändern des Typs der ``ITEMID``-Spalte und umbenennen der Spalte `MODELNAME`.
+
[source]
----
ALTER TABLE STOCK
  ALTER COLUMN MODEL SET DEFAULT 1,
  ALTER COLUMN ITEMID TYPE BIGINT,
  ALTER COLUMN MODELNAME TO NAME;
----
. Ändern der berechneten Spalten `NEW_SALARY` und `SALARY_CHANGE`.
+
[source]
----
ALTER TABLE SALARY_HISTORY
  ALTER NEW_SALARY GENERATED ALWAYS AS
    (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
  ALTER SALARY_CHANGE COMPUTED BY
    (OLD_SALARY * PERCENT_CHANGE / 100);
----

.Siehe auch
<<fblangref25-ddl-tbl-create-de>>, <<fblangref25-ddl-tbl-drop-de>>, <<fblangref25-ddl-domn-create-de>>

[[fblangref25-ddl-tbl-drop-de]]
=== `DROP TABLE`

.Benutzt für
Löschen einer Tabelle

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP TABLE _tablename_
----

[[fblangref25-ddl-tbl-droptbl-de]]
.`DROP TABLE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

^|tablename
<|Name (Kennung) der Tabelle
|===

Die Anweisung `DROP TABLE` löscht eine vorhandene Tabelle.
Wenn die Tabelle Abhängigkeiten hat, schlägt die Anweisung `DROP TABLE` mit einem Ausführungsfehler fehl.

Wenn eine Tabelle gelöscht wird, werden auch alle Trigger für ihre Ereignisse und Indizes, die für ihre Felder erstellt wurden, gelöscht.

Nur der Tabelleneigentümer und <<fblangref25-security-administrators-de,Administratoren>> haben die Berechtigung, `DROP TABLE` zu verwenden.

.Beispiel
Die Tabelle `COUNTRY` löschen.

[source]
----
DROP TABLE COUNTRY;
----

.Siehe auch
<<fblangref25-ddl-tbl-create-de>>, <<fblangref25-ddl-tbl-alter-de>>, <<fblangref25-ddl-tbl-recreate-de>>

[[fblangref25-ddl-tbl-recreate-de]]
=== `RECREATE TABLE`

.Benutzt für
Erstellen einer neuen Tabelle (Relation) oder Wiederherstellen einer bestehenden

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE [GLOBAL TEMPORARY] TABLE _tablename_
  [EXTERNAL [FILE] '_filespec_']
  (<col_def> [, {<col_def> | <tconstraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
----


Vergleichen Sie den <<fblangref25-ddl-tbl-create-de,``CREATE TABLE``-Abschnitt>> für die vollständige Syntax für `CREATE TABLE` und beachten Sie die Beschreibungen zum Definieren von Tabellen, Spalten und Constraints.

`RECREATE TABLE` erstellt eine Tabelle neu oder erneut.
Wenn bereits eine Tabelle mit diesem Namen vorhanden ist, versucht die Anweisung `RECREATE TABLE`, diese zu löschen und  eine neue zu erstellen.
Bestehende Abhängigkeiten verhindern die Ausführung der Anweisung.

.Beispiel
Erstellen oder Wiederherstellen der Tabelle `COUNTRY`.

[source]
----
RECREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL
);
----

.Siehe auch
<<fblangref25-ddl-tbl-create-de>>, <<fblangref25-ddl-tbl-drop-de>>

[[fblangref25-ddl-idx-de]]
== `INDEX`

Ein Index ist ein Datenbankobjekt, das für eine schnellere Datenabfrage aus einer Tabelle oder zur Beschleunigung der Sortierung der Abfrage verwendet wird.
Indizes werden auch verwendet, um die referenziellen Integritätsbedingungen `PRIMARY KEY`, `FOREIGN KEY` und `UNIQUE` sicherzustellen.

In diesem Abschnitt wird beschrieben, wie Sie Indizes erstellen, aktivieren und deaktivieren, löschen und Statistiken sammeln (Selektivität neu berechnen).

[[fblangref25-ddl-idx-create-de]]
=== `CREATE INDEX`

.Benutzt für
Einen Index für eine Tabelle erstellen

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]]
  INDEX _indexname_ ON _tablename_
  {(_col_ [, _col_ …]) | COMPUTED BY (<expression>)}
----

[[fblangref25-ddl-idx-createidx-de]]
.`CREATE INDEX` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|indexname
|Indexname.
Es kann aus bis zu 31 Zeichen bestehen

|tablename
|Der Name der Tabelle, für die der Index erstellt werden soll

|col
|Name einer Spalte in der Tabelle.
Spalten der Typen `BLOB` sowie `ARRAY` und berechnete Felder können nicht in einem Index verwendet werden

|expression
|Der Ausdruck, der die Werte für einen berechneten Index berechnet, auch bekannt als "`Ausdrucksindex`"
|===

Die Anweisung `CREATE INDEX` erstellt einen Index für eine Tabelle, mit der das Suchen, Sortieren und Gruppieren beschleunigt werden kann.
Indizes werden automatisch beim Definieren von Constraints wie Primärschlüssel, Fremdschlüssel oder eindeutigen Constraints erstellt.

Ein Index kann auf den Inhalt von Spalten eines beliebigen Datentyps mit Ausnahme von `BLOB` und Arrays aufgebaut werden.
Der Name (Bezeichner) eines Index muss unter allen Indexnamen eindeutig sein.

.Schlüssel-Indizes
[NOTE]
====
Wenn ein Primärschlüssel, ein Fremdschlüssel oder eine eindeutige Einschränkung zu einer Tabelle oder Spalte hinzugefügt wird, wird automatisch ein Index mit demselben Namen erstellt, ohne explizite Anweisung vom Designer.
Beispielsweise wird der ``PK_COUNTRY``-Index automatisch erstellt, wenn Sie die folgende Anweisung ausführen und übergeben:

[source]
----
ALTER TABLE COUNTRY ADD CONSTRAINT PK_COUNTRY
  PRIMARY KEY (ID);
----
====

[[fblangref25-ddl-idx-uq-de]]
==== Unique-Indizes

Wenn Sie in der Indexerstellungsanweisung das Schlüsselwort `UNIQUE` angeben, wird ein Index erstellt, in dem die Eindeutigkeit in der gesamten Tabelle durchgesetzt wird.
Der Index  wird als "`eindeutiger Index`" bezeichnet.
Ein eindeutiger Index ist keine Einschränkung.

Eindeutige Indizes dürfen keine doppelten Schlüsselwerte (oder Duplikatschlüsselwertkombinationen im Falle von _berechnet_ Indizes oder multi-column oder multi-segment) enthalten.
Duplizierte ``NULL``s sind gemäß dem SQL: 99-Standard sowohl in Indizes mit einem einzelnen Segment als auch mit mehreren Segmenten zulässig.

[[fblangref25-ddl-idx-drctn-de]]
==== Index-Sortierung

Alle Indizes in Firebird sind unidirektional.
Ein Index kann vom niedrigsten Wert zum höchsten (aufsteigend) oder vom höchsten zum niedrigsten (absteigend) erstellt werden.
Die Schlüsselwörter `ASC [ENDING]` und `DESC [ENDING]` werden verwendet, um die Richtung des Index anzugeben.
Die Standardindexreihenfolge ist `ASC [ENDING]`.
Es ist durchaus sinnvoll, sowohl einen auf- als auch einen absteigenden Index für dieselbe Spalte oder denselben Schlüsselsatz zu definieren.

[TIP]
====
Ein absteigender Index kann für eine Spalte nützlich sein, die Suchanfragen auf den hohen Werten unterzogen wird ("`neuestes`", Maximum usw.)
====

[[fblangref25-ddl-idx-exprssn-de]]
==== Berechnete (Ausdrucks-) Indizes

Beim Erstellen eines Index können Sie die ``COMPUTED BY``-Klausel verwenden, um anstelle einer oder mehrerer Spalten einen Ausdruck anzugeben.
Berechnete Indizes werden in Abfragen verwendet, bei denen die Bedingung in einer `WHERE`, `ORDER BY` oder ``GROUP BY``-Klausel exakt dem Ausdruck in der Indexdefinition entspricht.
Der Ausdruck in einem berechneten Index kann mehrere Spalten in der Tabelle enthalten. 

[NOTE]
====
Sie können tatsächlich einen berechneten Index für ein berechnetes Feld erstellen, der Index wird jedoch nie verwendet.
====

[[fblangref25-ddl-idx-limits-de]]
==== Indexgrenzen

Bestimmte Beschränkungen gelten für Indizes.

Die maximale Länge eines Schlüssels in einem Index ist auf ¼ der Seitengröße.

[[fblangref25-ddl-idx-maxno-de]]
===== Maximale Anzahl Indizes pro Tabelle

Die Anzahl der Indizes, die für jede Tabelle untergebracht werden können, ist begrenzt.
Das tatsächliche Maximum für eine bestimmte Tabelle hängt von der Seitengröße und  der Anzahl der Spalten in den Indizes ab.

[[fblangref25-ddl-idx-idxpertbl-de]]
.Maximale Anzahl Indizes pro Tabelle
[%autowidth,cols=">1,>1,>1,>1",stripes="none"]
|===
.2+^h| Seitengröße
3+^h| Anzahl der Indizes in Abhängigkeit von der Spaltenanzahl

^h|einspaltig
^h|zweispaltig
^h|dreispaltig

|4096
|203
|145
|113

|8192
|408
|291
|227

|16384
|818
|584
|454
|===

[[fblangref25-ddl-idx-maxstrnglgth-de]]
===== Zeichenindexgrenzen

Die maximale Länge der indizierten Zeichenfolgen beträgt 9 Byte weniger als die maximale Schlüssellänge.
Die maximale indexierbare Zeichenfolgenlänge  hängt von der Seitengröße und dem Zeichensatz ab.

[[fblangref25-ddl-idx-idxstrnglgth-de]]
.Maximale indizierbare (VAR)CHAR-Länge
[%autowidth,cols=">1,>1,>1,>1,>1", stripes="none"]
|===
.2+^h| Seitengröße
4+^h| Maximale indexierbare Zeichenfolgenlänge nach Zeichensatz

^h|1 Byte/Zeichen
^h|2 Bytes/Zeichen
^h|3 Bytes/Zeichen
^h|4 Bytes/Zeichen

|4096
|1015
|507
|338
|253

|8192
|2039
|1019
|679
|509

|16384
|4087
|2043
|1362
|1021
|===

Nur der Tabelleneigentümer und <<fblangref25-security-administrators-de,Administratoren>> besitzen die notwendigen Rechte für die Verwendung von `CREATE INDEX`.

[[fblangref25-ddl-tbl-crtidxexmpls-de]]
==== Beispiel für die Verwendung von `CREATE INDEX`

. Erstellen eines Index für die `UPDATER_ID` in der Tabelle `SALARY_HISTORY`
+
[source]
----
CREATE INDEX IDX_UPDATER
  ON SALARY_HISTORY (UPDATER_ID);
----
. Erstellen eines Index mit Schlüsseln in absteigender Reihenfolge für die ``CHANGE_DATE``-Spalte in der Tabelle `SALARY_HISTORY`.
+
[source]
----
CREATE DESCENDING INDEX IDX_CHANGE
  ON SALARY_HISTORY (CHANGE_DATE);
----
. Erstellen eines Multisegment-Index für die Spalten `ORDER_STATUS` sowie `PAID` in der Tabelle `SALES`
+
[source]
----
CREATE INDEX IDX_SALESTAT
  ON SALES (ORDER_STATUS, PAID);
----
. Erstellen eines Index, der keine doppelten Werte für die Spalte `NAME` in der Tabelle `COUNTRY` zulässt
+
[source]
----
CREATE UNIQUE INDEX UNQ_COUNTRY_NAME
  ON COUNTRY (NAME);
----
. Erstellen eines berechneten Index für die ``PERSONS``-Tabelle
+
[source]
----
CREATE INDEX IDX_NAME_UPPER ON PERSONS
  COMPUTED BY (UPPER (NAME));
----
+
Ein solcher Index kann für eine Groß- / Kleinschreibungs-sensitive Suche verwendet werden:
+
[source]
----
SELECT *
FROM PERSONS
WHERE UPPER(NAME) STARTING WITH UPPER('Iv');
----

.Siehe auch
<<fblangref25-ddl-idx-altridx-de>>, <<fblangref25-ddl-idx-dropidx-de>>

[[fblangref25-ddl-idx-altridx-de]]
=== `ALTER INDEX`

.Benutzt für
Aktivieren oder Deaktivieren eines Indexes; einen Index neu aufbauen

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER INDEX _indexname_ {ACTIVE | INACTIVE}
----

[[fblangref25-ddl-idx-alteridx-de]]
.`ALTER INDEX` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|indexname
|Indexname
|===

Die ``ALTER INDEX``-Anweisung aktiviert oder deaktiviert einen Index.
In dieser Anweisung gibt es keine Möglichkeit, Attribute des Index zu ändern. 

* Mit der Option `INACTIVE` wird der Index vom aktiven in den inaktiven Zustand geschaltet.
Der Effekt ähnelt der Anweisung `DROP INDEX`, mit der Ausnahme, dass die Indexdefinition in der Datenbank verbleibt.
Das Ändern eines Beschränkungsindex in den inaktiven Zustand ist nicht zulässig.
+ 
Ein aktiver Index kann deaktiviert werden, wenn keine Abfragen mit diesem Index vorhanden sind.
Andernfalls wird ein "`Objekt in Verwendung`"-Fehler zurückgegeben.
+ 
Die Aktivierung eines inaktiven Index ist ebenfalls sicher.
Wenn jedoch aktive Transaktionen die Tabelle ändern, schlägt die Transaktion mit der Anweisung `ALTER INDEX` fehl, wenn das Attribut `NOWAIT` vorhanden ist.
Wenn sich die Transaktion im Modus `WAIT` befindet, wartet sie auf den Abschluss der gleichzeitigen Transaktionen.
+ 
Auf der anderen Seite der Münze werden andere Transaktionen, die diese Tabelle modifizieren den Index nach einem `COMMIT` neu erstellen oder fehlschlagen je nach Status der `WAIT`/``NO WAIT``-Attribute.
Die Situation ist genau dieselbe für `CREATE INDEX`.
+
.Wie sinnvoll ist dies?
[NOTE]
====
Es kann sinnvoll sein, einen Index in den inaktiven Zustand zu wechseln, während Sie einen großen Stapel von Datensätzen in der Tabelle, in der sich der Index befindet, einfügen, aktualisieren oder löschen.
====
* Wenn sich der Index im Status `INACTIVE` befindet, wird es mit der Option `ACTIVE` in den aktiven Status umgeschaltet, und das System erstellt den Index neu.
+
.Wie sinnvoll ist dies?
[NOTE]
====
Auch wenn der Index _active_ ist, wenn `ALTER INDEX ... ACTIVE`  ausgeführt wird, wird der Index neu erstellt.
Die Wiederherstellung von Indizes kann eine nützliche Haushaltshilfe sein, gelegentlich auch für die Indizes einer großen Tabelle in einer Datenbank, die häufige Neuaufnahmen Aktualisierungen oder Löschungen aufweist, aber selten wiederhergestellt wird.
====

[[fblangref25-ddl-idx-altrcnstrntidx-de]]
==== Verwendung von `ALTER INDEX` in einem Constraint-Index

Das Ändern des Erzwingungsindex für eine ``PRIMARY KEY``-, ``FOREIGN KEY``- oder ``UNIQUE``-Einschränkung auf `INACTIVE` ist nicht zulässig.
Jedoch funktionert `ALTER INDEX ... ACTIVE` genauso gut wie andere als Indexwiederherstellungstool.

Nur der Tabelleneigentümer und <<fblangref25-security-administrators-de,Administratoren>> haben die Berechtigungen für die Anweisung `ALTER INDEX`.

==== Beispiele für ALTER INDEX

. Deaktivieren des ``IDX_UPDATER``-Index
+
[source]
----
ALTER INDEX IDX_UPDATER INACTIVE;
----
. Den ``IDX_UPDATER``-Index in den aktiven Zustand zurückschalten und neu erstellen
+
[source]
----
ALTER INDEX IDX_UPDATER ACTIVE;
----

.Siehe auch
<<fblangref25-ddl-idx-create-de>>, <<fblangref25-ddl-idx-dropidx-de>>, <<fblangref25-ddl-idx-setsttstcs-de>>

[[fblangref25-ddl-idx-dropidx-de]]
=== `DROP INDEX`

.Benutzt für
Deleting an index

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP INDEX _indexname_
----

[[fblangref25-ddl-tbl-idx-dropidx]]
.`DROP INDEX` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|indexname
|Indexname
|===

Das Statement `DROP INDEX` löscht den angegebenen Index aus der Datenbank. 

[NOTE]
====
Ein Constraint-Index kann nicht mittels `DROP INDEX` gelöscht werden.
Constraint-Indizes werden während des Ausführens des Befehls `ALTER TABLE ... DROP CONSTRAINT ...` gelöscht.
====

Nur die Tabelleneigentümer und <<fblangref25-security-administrators-de,Administratoren>> besitzen die Berechtigungen die Anweisung `DROP INDEX` auszuführen.

.DROP INDEX Example
Löschen des Index IDX_UPDATER

[source]
----
DROP INDEX IDX_UPDATER;
----

.Siehe auch
<<fblangref25-ddl-idx-create-de>>, <<fblangref25-ddl-idx-altridx-de>>

[[fblangref25-ddl-idx-setsttstcs-de]]
=== `SET STATISTICS`

.Benutzt für
Neuberechnung der Selektivität eines Index

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
SET STATISTICS INDEX _indexname_
----

[[fblangref25-ddl-tbl-idx-setsttstcs-de]]
.`SET STATISTICS` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|indexname
|Indexname
|===

Die Anweisung `SET STATISTICS` berechnet die Selektivität des angegebenen Index neu.

[[fblangref25-ddl-idx-selectivity-de]]
==== Index-Selektivität

Die Selektivität eines Index ergibt sich aus der Auswertung der Anzahl der Zeilen, die bei einer Suche für jeden Indexwert ausgewählt werden können.
Ein eindeutiger Index hat die maximale Selektivität, da es nicht möglich ist, mehr als eine Zeile für jeden Wert eines Indexschlüssels auszuwählen, wenn dieser verwendet wird.
Die Selektivität eines Index auf dem neuesten Stand zu halten ist wichtig für die Wahl des Optimierers bei der Suche nach dem optimalen Abfrageplan.

Indexstatistiken in Firebird werden nicht automatisch als Reaktion auf große Stapel von Neuaufnahmen, Aktualisierungen oder Löschungen neu berechnet.
Es kann vorteilhaft sein, die Selektivität eines Index nach solchen Operationen neu zu berechnen, da die Selektivität dazu neigt, zu veralten.

[NOTE]
====
Die Anweisungen `CREATE INDEX` und `ALTER INDEX ACTIVE` speichern beide Indexstatistiken, die vollständig dem Inhalt des (neu) erstellten Index entsprechen.
====

Die Selektivität eines Index kann vom Besitzer der Tabelle oder einem <<fblangref25-security-administrators-de,Administrator>> neu berechnet werden.
Es kann unter gleichzeitiger Belastung ohne Korruptionsrisiko durchgeführt werden.
Beachten Sie jedoch, dass die neu berechnete Statistik bei gleichzeitiger Auslastung veraltet sein kann, sobald `SET STATISTICS` beendet ist.

==== Beispiele für die Verwendung von SET STATISTICS

Neuberechnung der Selektivität des Index `IDX_UPDATER`

[source]
----
SET STATISTICS INDEX IDX_UPDATER;
----

.Siehe auch
<<fblangref25-ddl-idx-create-de>>, <<fblangref25-ddl-idx-altridx-de>>

[[fblangref25-ddl-view-de]]
== `VIEW`

Eine Sicht (`VIEW`) ist eine virtuelle Tabelle, bei der es sich um eine gespeicherte und benannte ``SELECT``-Abfrage zum Abrufen von Daten beliebiger Komplexität handelt.
Daten können aus einer oder mehreren Tabellen, aus anderen Ansichten und aus ausgewählten gespeicherten Prozeduren abgerufen werden.

Im Gegensatz zu regulären Tabellen in relationalen Datenbanken ist eine Sicht kein unabhängiger Datensatz, der in der Datenbank gespeichert ist.
Das Ergebnis wird dynamisch als Datensatz erstellt, wenn die Ansicht ausgewählt wird.

Die Metadaten einer Sicht sind für den Prozess verfügbar, der den Binärcode für gespeicherte Prozeduren und Trigger generiert, so als wären es konkrete Tabellen, in denen persistente Daten gespeichert werden.

[[fblangref25-ddl-view-create-de]]
=== `CREATE VIEW`

.Benutzt für
Erstellen einer View

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE VIEW _viewname_ [<full_column_list>]
  AS <select_statement>
  [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-createview-de]]
.`CREATE VIEW` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|viewname
|View-Name, maximal 31 Zeichen

|select_statement
|``SELECT``-Statement

|full_column_list
|Die Liste der Spalten in der View

|colname
|Spaltenname der View.
Doppelte Spaltennamen sind nicht zulässig.
|===

Die Anweisung `CREATE VIEW` erstellt eine neue View Der Bezeichner (Name) einer View muss unter den Namen aller Ansichten, Tabellen und gespeicherten Prozeduren in der Datenbank eindeutig sein.

Dem Namen der neuen Sicht kann die Liste der Spaltennamen folgen, die beim Aufrufen der View an den Aufrufer zurückgegeben werden sollen.
Namen in der Liste müssen nicht mit den Namen der Spalten in den Basistabellen verknüpft sein, von denen sie abgeleitet werden.

Wenn die Sichtspaltenliste ausgelassen wird, verwendet das System die Spaltennamen und / oder Aliase aus der Anweisung `SELECT`.
Wenn doppelte Namen oder nicht von Alias-Ausdrucken abgeleitete Spalten das Erstellen einer gültigen Liste unmöglich machen, schlägt die Erstellung der View mit einem Fehler fehl.

Die Anzahl der Spalten in der Liste der Ansichten muss genau der Anzahl der Spalten in der Auswahlliste der zugrunde liegenden ``SELECT``-Anweisung in der Sichtdefinition entsprechen.

.Zusätzliche Punkte
[NOTE]
====
* Wenn die vollständige Liste der Spalten angegeben ist, ist es nicht sinnvoll, Aliase in der Anweisung `SELECT` anzugeben, da die Namen in der Spaltenliste diese überschreiben
* Die Spaltenliste ist optional, wenn alle Spalten in `SELECT` explizit benannt sind und in der Auswahlliste eindeutig sind
====

[[fblangref25-ddl-view-create-updatable-de]]
==== Aktualisierbare Views

Eine View kann aktualisierbar oder schreibgeschützt sein.
Wenn eine Sicht aktualisierbar ist, können die beim Aufruf dieser Sicht abgerufenen Daten durch die DML-Anweisungen `INSERT`, `UPDATE`, `DELETE`, `UPDATE OR INSERT` oder  `MERGE`.
Änderungen, die in einer aktualisierbaren View vorgenommen wurden, werden auf die zugrunde liegenden Tabelle(n) angewendet.

Eine Nur-Lese-Ansicht kann mit Hilfe von Triggern aktualisiert werden.
Nachdem Trigger in einer Sicht definiert wurden, werden Änderungen, die an sie gesendet wurden, niemals automatisch in die zugrunde liegende Tabelle geschrieben, selbst wenn die Ansicht von vornherein aktualisiert werden konnte.
Es liegt in der Verantwortung des Programmierers, sicherzustellen, dass die Trigger die Basistabellen nach Bedarf aktualisieren (oder löschen oder einfügen).

Eine View wird automatisch aktualisiert, wenn alle der folgenden Bedingungen erfüllt sind: 

* Die ``SELECT``-Anweisung fragt nur eine Tabelle oder eine aktualisierbare Ansicht ab
* Die Anweisung `SELECT` ruft keine gespeicherten Prozeduren auf
* jede Spalte der Basistabelle (oder Basissicht), die in der Sichtdefinition nicht vorhanden ist, wird durch eine der folgenden Bedingungen abgedeckt:
** sie ist nullbar
** sie hat einen nicht-``NULL`` Standardwert
** sie hat einen Trigger, der einen zulässigen Wert liefert
* die Anweisung `SELECT` enthält keine Felder, die von Unterabfragen oder anderen Ausdrücken abgeleitet wurden
* die ``SELECT``-Anweisung enthält keine durch Aggregatfunktionen definierten Felder wie `MIN`, `MAX`, `AVG`, `SUM`,  `COUNT`, `LIST`
* Die ``SELECT``-Anweisung enthält keine der Klauseln `ORDER BY` oder `GROUP BY`
* Das ``SELECT``-Statement enthält weder das Schlüsselwort `DISTINCT` noch zeilenbeschränkende Schlüsselwörter wie `ROWS`, `FIRST`, `SKIP`

[[fblangref25-ddl-view-create-chkopt-de]]
==== `WITH CHECK OPTION`

Die optionale Klausel `WITH CHECK OPTION` erfordert eine aktualisierbare Sicht, um zu überprüfen, ob neue oder aktualisierte Daten die in der ``WHERE``-Klausel der `SELECT`.
Jeder Versuch, einen neuen Datensatz einzufügen oder einen bestehenden zu aktualisieren, wird überprüft, ob der neue oder aktualisierte Datensatz den Kriterien aus `WHERE` entspricht.
Wenn die Überprüfung fehlschlägt, wird die Operation nicht ausgeführt und eine entsprechende Fehlermeldung wird zurückgegeben.

`WITH CHECK OPTION` kann nur in einer ``CREATE VIEW``-Anweisung angegeben werden, in der eine ``WHERE``-Klausel vorhanden ist, um die Ausgabe der ``SELECT``-Anweisung einzuschränken.
Eine Fehlermeldung wird ansonsten zurückgegeben.

.Bitte beachten:
[IMPORTANT]
====
Wenn `WITH CHECK OPTION` verwendet wird, prüft das Modul die  Eingabe für die ``WHERE``-Klausel, bevor etwas an die Basisrelation übergeben wird.
Wenn die Überprüfung der Eingabe fehlschlägt, werden daher keine Standardklauseln oder Trigger der Basisrelation, welche möglicherweise zur Korrektur der Eingaben erstellt wurden, ausgeführt.

Außerdem werden Sichtfelder, die in der Anweisung `INSERT` ausgelassen wurden, unabhängig von ihrer Anwesenheit oder Abwesenheit in der ``WHERE``-Klausel als ``NULL``s an die Basisrelation übergeben.
Infolgedessen werden Basistabellenstandards, die für solche Felder definiert sind, nicht angewendet.
Auslöser dagegen werden wie erwartet feuern und arbeiten. 

Für Views, die `WITH CHECK OPTION` nicht enthalten, werden Felder, die in der Anweisung  `INSERT` fehlen, überhaupt nicht an die Basisrelation übergeben.
====

[[fblangref25-ddl-view-createwho-de]]
==== Eigentümer einer View

Der Ersteller einer Sicht wird zu seinem Besitzer.

Um eine Sicht zu erstellen, benötigt ein Benutzer ohne Administratorrechte mindestens ``SELECT``-Zugriff auf die zugrunde liegenden Tabelle(n) und / oder Ansichten und die Berechtigung `EXECUTE` auf abfragbare gespeicherte Prozeduren.

Um Einfügungen, Aktualisierungen und Löschungen durch die Sicht zu ermöglichen, muss der Ersteller / Eigentümer auch die entsprechenden Berechtigungen `INSERT`, `UPDATE` und `DELETE` auf die zugrunde liegenden Objekt(e) besitzen.

Das Freigeben anderer Benutzerprivilegien für die Sicht ist nur möglich, wenn der Sichtbesitzer selbst diese  Berechtigungen für die zugrunde liegenden Objekte `WITH GRANT OPTION` besitzt.
Dies ist immer dann der Fall, wenn der View-Besitzer auch Eigentümer der zugrunde liegenden Objekte ist.

==== Beispiele zum Erstellen von Views

. Creating view returning the `JOB_CODE` and `JOB_TITLE` columns only for those jobs where `MAX_SALARY` is less than $15,000.
+
[source]
----
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY < 15000;
----
. Erstellen einer Ansicht, die die Spalten `JOB_CODE` und `JOB_TITLE` nur für diejenigen Jobs zurückgibt, bei denen `MAX_SALARY` weniger als 15.000 USD beträgt.
Immer wenn ein neuer Datensatz eingefügt oder ein vorhandener Datensatz aktualisiert wird, wird der Wert `MAX_SALARY < 15000` Zustand wird überprüft.
Wenn die Bedingung nicht wahr ist, wird die Operation zum Einfügen / Aktualisieren zurückgewiesen.
+
[source]
----
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY < 15000
WITH CHECK OPTION;
----
. Erstellen einer Ansicht mit einer expliziten Spaltenliste.
+
[source]
----
CREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1
FROM PRICE;
----
. Erstellen einer View mit Hilfe von Aliasnamen für Felder in der ``SELECT``-Anweisung (das gleiche Ergebnis wie in Beispiel 3).
+
[source]
----
CREATE VIEW PRICE_WITH_MARKUP AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1 AS COST_WITH_MARKUP
FROM PRICE;
----
. Erstellen einer schreibgeschützten Ansicht basierend auf zwei Tabellen und einer gespeicherten Prozedur.
+
[source]
----
CREATE VIEW GOODS_PRICE AS
SELECT
  goods.name AS goodsname,
  price.cost AS cost,
  b.quantity AS quantity
FROM
  goods
  JOIN price ON goods.code_goods = price.code_goods
  LEFT JOIN sp_get_balance(goods.code_goods) b ON 1 = 1;
----

.Siehe auch
<<fblangref25-ddl-view-alter-de>>, <<fblangref25-ddl-view-crtoralter-de>>, <<fblangref25-ddl-view-recreate-de>>, <<fblangref25-ddl-view-drop-de>>

[[fblangref25-ddl-view-alter-de]]
=== `ALTER VIEW`

.Benutzt für
Ändern einer existierenden View

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER VIEW _viewname_ [<full_column_list>]
    AS <select_statement>
    [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-alterview-de]]
.`ALTER VIEW` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|viewname
|Name einer existierenden View

|select_statement
|``SELECT``-Statement

|full_column_list
|Die Liste der Spalten in der View

|colname
|Spaltenname der View Doppelte Spaltennamen sind nicht zulässig.
|===

Verwenden Sie die Anweisung `ALTER VIEW`, um die Definition einer vorhandenen View zu ändern.
Berechtigungen für Ansichten bleiben erhalten und Abhängigkeiten sind nicht betroffen.

Die Syntax der Anweisung `ALTER VIEW` entspricht vollständig der von `CREATE VIEW`.

[CAUTION]
====
Seien Sie vorsichtig, wenn Sie die Anzahl der Spalten in einer Ansicht ändern.
Vorhandener Anwendungscode und PSQL-Module, die auf die Sicht zugreifen, können ungültig werden.
Informationen zur Erkennung dieser Art von Problemen in gespeicherten Prozeduren und Triggern finden Sie unter <<fblangref25-appx01-supp-rdb-validblr-de,[ref]_Das RDB$VALID_BLR-Feld_>> im Anhang.
====

Nur der View-Eigentümer und <<fblangref25-security-administrators-de,Administratoren>> besitzen die notwendigen Berechtigungen zum Ausführen von `ALTER VIEW`.

.Beispiele zur Verwendung von `ALTER VIEW`
Ansicht ändern `PRICE_WITH_MARKUP`

[source]
----
ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
----

.Siehe auch
<<fblangref25-ddl-view-create-de>>, <<fblangref25-ddl-view-crtoralter-de>>, <<fblangref25-ddl-view-recreate-de>>

[[fblangref25-ddl-view-crtoralter-de]]
=== `CREATE OR ALTER VIEW`

.Benutzt für
Creating a new view or altering an existing view.

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER VIEW _viewname_ [<full_column_list>]
  AS <select_statement>
  [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-crtalterview-de]]
.`CREATE OR ALTER VIEW` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|viewname
|Name einer View, die vorhanden oder nicht vorhanden ist

|select_statement
|``SELECT``-Statement

|full_column_list
|Die Liste der Spalten in der View

|colname
|Spaltenname der View.
Duplikate sind nicht zulässig.
|===

Verwenden Sie die Anweisung `CREATE OR ALTER VIEW`, um die Definition einer vorhandenen Ansicht zu ändern oder sie zu erstellen, falls sie nicht existiert.
Berechtigungen für eine vorhandene Ansicht bleiben erhalten und Abhängigkeiten werden nicht beeinflusst.

Die Syntax der Anweisung `CREATE OR ALTER VIEW` entspricht vollständig der von `CREATE VIEW`.

.Beispiel
Erstellen Sie die Ansicht `PRICE_WITH_MARKUP` der neuen Ansicht oder ändern Sie sie, falls diese bereits vorhanden ist:

[source]
----
CREATE OR ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
----

.Siehe auch
<<fblangref25-ddl-view-create-de>>, <<fblangref25-ddl-view-alter-de>>, <<fblangref25-ddl-view-recreate-de>>

[[fblangref25-ddl-view-drop-de]]
=== `DROP VIEW`

.Benutzt für
Löschen (dropping) einer View

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
DROP VIEW _viewname_
----

[[fblangref25-ddl-tbl-view-dropview-de]]
.DROP VIEW Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|viewname
|View-Name
|===

Die Anweisung `DROP VIEW` löscht eine existierende View.
Die Anweisung wird fehlschlagen wenn die View Abhängigkeiten besitzt.

Nur der Eigentümer der View und <<fblangref25-security-administrators-de,Administratoren>> besitzen die notwendigen Berechtigungen zum Ausführen von `DROP VIEW`.

.Beispiel
Löschen der View `PRICE_WITH_MARKUP`.

[source]
----
DROP VIEW PRICE_WITH_MARKUP;
----

.Siehe auch
<<fblangref25-ddl-view-create-de>>, <<fblangref25-ddl-view-recreate-de>>, <<fblangref25-ddl-view-crtoralter-de>>

[[fblangref25-ddl-view-recreate-de]]
=== `RECREATE VIEW`

.Benutzt für
Erstellen einer neuen Ansicht oder Wiederherstellen einer vorhandenen View

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE VIEW _viewname_ [<full_column_list>]
  AS <select_statement>
  [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-recreate]]
.RECREATE VIEW Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|viewname
|View-Name, maximal 31 Zeichen

|select_statement
|``SELECT``-Statement

|full_column_list
|Die Liste der Spalten in der View

|colname
|Spaltenname der View.
Duplikate sind nicht zulässig.
|===

Erstellt oder erstellt eine Ansicht neu.
Wenn bereits eine Ansicht mit diesem Namen vorhanden ist, versucht die Engine, sie vor dem Erstellen der neuen Instanz zu löschen.
Wenn die vorhandene Sicht aufgrund von Abhängigkeiten oder unzureichenden Rechten nicht gelöscht werden kann, schlägt `RECREATE VIEW` mit einem Fehler fehl.

.Beispiel
Die neue View `PRICE_WITH_MARKUP` erstellen oder neu erstellen, falls diese bereits vorhanden ist.

[source]
----
RECREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
----

.Siehe auch
<<fblangref25-ddl-view-create-de>>, <<fblangref25-ddl-view-drop-de>>, <<fblangref25-ddl-view-crtoralter-de>>

[[fblangref25-ddl-trgr-de]]
== `TRIGGER`

Ein Trigger ist ein spezieller Typ einer gespeicherten Prozedur, der nicht direkt aufgerufen wird, sondern ausgeführt wird, wenn ein bestimmtes Ereignis in der zugeordneten Tabelle oder Sicht (View) auftritt.
Ein Trigger ist spezifisch für eine und nur eine Relation (Tabelle oder View) und eine Phase im Timing des Ereignisses (_BEFORE_ oder _AFTER_).
Es kann angegeben werden, dass dieser für ein bestimmtes Ereignis (Einfügen, Aktualisieren, Löschen) oder für eine Kombination von zwei oder drei dieser Ereignisse ausgeführt wird.

Eine andere Form eines Triggers -- bekannt als ein "`Datenbanktrigger`" -- kann spezifiziert werden, um in Verbindung mit dem Start oder dem Ende einer Benutzersitzung (Verbindung) oder einer Benutzertransaktion zu ausgelöst zu werden.

[[fblangref25-ddl-trgr-create-de]]
=== `CREATE TRIGGER`

.Benutzt für
Erstellen eines neuen Triggers

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE TRIGGER _trigname_
  { <relation_trigger_legacy>
  | <relation_trigger_sql2003>
  | <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<relation_trigger_legacy> ::=
  FOR {_tablename_ | _viewname_}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <mutation_list>
  [POSITION _number_]

<relation_trigger_sql2003> ::=
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <mutation_list>
  [POSITION _number_]
  ON {_tablename_ | _viewname_}

<database_trigger> ::=
  [ACTIVE | INACTIVE] ON <db_event> [POSITION _number_]

<mutation_list> ::=
  <mutation> [OR <mutation> [OR <mutation>]]

<mutation> ::= { INSERT | UPDATE | DELETE }

<db_event> ::=
  { CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK }

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; …]
----

[[fblangref25-ddl-trgr-createtrigger-de]]
.`CREATE TRIGGER` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|trigname
|Triggername bestehend aus bis zu 31 Zeichen.
Dieser muss unter allen Triggernamen in der Datenbank eindeutig sein.

|relation_trigger_legacy
|Legacy-Stil der Trigger-Deklaration für einen Relation-Trigger

|relation_trigger_sql2003
|Relation-Trigger-Deklaration gemäß dem SQL: 2003-Standard

|database_trigger
|Datenbank-Triggerdeklaration

|tablename
|Name der Tabelle, der der Relationstrigger zugeordnet ist

|viewname
|Name der Sicht, der der Relationstrigger zugeordnet ist

|mutation_list
|Liste von Relationsereignissen (Tabelle {vbar} Ansicht)

|number
|Position des Triggers in der Zündreihenfolge.
Von 0 bis 32.767

|db_event
|Verbindungs- oder Transaktionsereignis

|declarations
|Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn

|declare_var
|Lokale Variablendeklarieren

|declare_cursor
|Benannte Cursor-Deklaration

|PSQL_statements
|Anweisungen in der Programmiersprache von Firebird (PSQL)
|===

Die Anweisung `CREATE TRIGGER` dient zum Erstellen eines neuen Triggers.
Ein Trigger kann entweder für ein Ereignis _Relation (Table | View)_ (oder eine Kombination von Ereignissen) oder für ein _Datenbankereignis_ erstellt werden.

`CREATE TRIGGER`, zusammen mit den zugehörigen Assoziaten `ALTER TRIGGER`, `CREATE OR ALTER TRIGGER` und `RECREATE TRIGGER`, ist eine _zusammengesetzte Anweisung_, bestehend aus einem Header und einem Rumpf.
Der Header spezifiziert den Namen des Triggers, den Namen der Relation (für einen Relations-Trigger), die Phase des Triggers und das Ereignis, für das er gilt.
Der Körper besteht aus optionalen Deklarationen von lokalen Variablen und benannten Cursors, gefolgt von einer oder mehreren Anweisungen oder Anweisungsblöcken, die alle in einem äußeren Block eingeschlossen sind, der mit dem Schlüsselwort `BEGIN` beginnt und mit dem Schlüsselwort `END` endet.
Deklarationen und eingebettete Anweisungen werden mit Semikolons  ('```;```') abgeschlossen.

Der Name des Triggers muss unter allen Triggernamen eindeutig sein.

[[fblangref25-ddl-terminators01-de]]
==== Statement-Terminatoren

Einige SQL-Anweisungseditoren -- insbesondere das mit Firebird mitgelieferte Dienstprogramm _isql_ und möglicherweise einige Editoren von Drittanbietern -- verwenden eine interne Konvention, die erfordert, dass alle Anweisungen mit einem Semikolon abgeschlossen werden.
Dies führt bei der Codierung in diesen Umgebungen zu einem Konflikt mit der PSQL-Syntax.
Wenn Sie mit diesem Problem und seiner Lösung nicht vertraut sind, lesen Sie bitte die Details im Kapitel PSQL im Abschnitt <<fblangref25-sidebar01-de,Umschalten des Terminators in _isql_>>.

[[fblangref25-ddl-trgr-relntrigger-de]]
==== Relations-Trigger (auf Tabellen oder Views)

Relation-Trigger werden jedes Mal auf der Zeilen- (Datensatz-) Ebene ausgeführt, wenn sich das Zeilenbild ändert.
Ein Trigger kann entweder `ACTIVE` oder `INACTIVE` sein.
Nur aktive Trigger werden ausgeführt.
Trigger werden standardmäßig mit `ACTIVE` erstellt.

[[fblangref25-ddl-trgr-relntrigger-form-de]]
===== Formen der Deklaration

Firebird unterstützt zwei Arten der Deklaration für Relationstrigger: 

* Die ursprüngliche Legacy-Syntax
* Das standardmäßige SQL:2003-Formular (empfohlen)

Das standardmäßige SQL:2003-Formular ist das empfohlene Format.

Ein Relationstrigger spezifiziert unter anderem eine _Phase_ und ein oder mehrere _Ereignisse_.

[[fblangref25-ddl-trgr-relntrigger-rowphase-de]]
===== Phase

Die Phase betrifft das Timing des Triggers in Bezug auf das Zustandswechselereignis in der Datenzeile:

* Ein ``BEFORE``-Trigger wird ausgelöst, bevor die angegebene Datenbankoperation (Einfügen, Aktualisieren oder Löschen) ausgeführt wird.
* Ein ``AFTER``-Trigger wird ausgeführt, nachdem die Datenbankoperation abgeschlossen wurde.

[[fblangref25-ddl-trgr-relntrigger-rowevent-de]]
===== Multi-Aktions-Trigger

Eine Relationstriggerdefinition gibt mindestens eine der DML-Operationen `INSERT`, `UPDATE` und `DELETE` an, um ein oder mehrere Ereignisse anzuzeigen, auf die der Trigger ausgelöst werden soll.
Wenn mehrere Operationen angegeben werden, müssen sie durch das Schlüsselwort `OR` getrennt werden.
Keine Operation darf mehrmals auftreten.

Innerhalb des Anweisungsblocks werden die Booleschen Kontextvariablen <<fblangref25-contextvars-inserting-de,`INSERTING`>>, <<fblangref25-contextvars-updating-de,`UPDATING`>> und <<fblangref25-contextvars-deleting-de,`DELETING`>> verwendet, um die Art der derzeit ausgeführten Operation zu prüfen.

[[fblangref25-ddl-trgr-relntrigger-position-de]]
===== Ausführungsreihenfolge von Triggern

Das Schlüsselwort `POSITION` erlaubt es, eine optionale Ausführungsreihenfolge ("`firing order`") für eine Reihe von Triggern anzugeben, die dieselbe Phase und dasselbe Ereignis wie ihr Ziel haben.
Die Standardposition ist 0.
Wenn keine Positionen angegeben werden oder wenn mehrere Trigger eine einzelne Positionsnummer haben, werden die Trigger in der alphabetischen Reihenfolge ihrer Namen ausgeführt.

[[fblangref25-ddl-trgr-relntrigger-declrtns-de]]
===== Variablendeklarationen

Der optionale Deklarationsabschnitt unter dem Schlüsselwort `AS` im Header des Triggers dient zum Definieren von Variablen und benannten Cursorn, die lokal zum Trigger gehören.
Weitere Informationen finden Sie unter <<fblangref25-psql-declare-variable-de,`DECLARE VARIABLE`>> und <<fblangref25-psql-declare-cursor-de,`DECLARE CURSOR`>> im Kapitel <<fblangref25-psql-de, Prozedurales SQL>>.

[[fblangref25-ddl-trgr-relntrigger-body-de]]
===== Der Trigger-Body

Die lokalen Deklarationen (falls vorhanden) sind der letzte Teil des Headerabschnitts eines Triggers.
Der Trigger-Body folgt, wobei ein oder mehrere Blöcke von PSQL-Anweisungen in einer Struktur eingeschlossen sind, die mit dem Schlüsselwort `BEGIN` beginnt und mit dem Schlüsselwort `END` endet.

Nur der Eigentümer der Sicht oder Tabelle und <<fblangref25-security-administrators-de,Administratoren>> haben die Berechtigung, `CREATE TRIGGER` zu verwenden.

===== Beispiele für CREATE TRIGGER für Tabellen und Views

. Erstellung eines Triggers in "`Legacy`"-Form.
Wird vor dem Einfügen eines neuen Datensatzes in die Tabelle `CUSTOMER` ausgelöst.
+
[source]
----
CREATE TRIGGER SET_CUST_NO FOR CUSTOMER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CUST_NO IS NULL) THEN
    NEW.CUST_NO = GEN_ID(CUST_NO_GEN, 1);
END
----
. Erstellen eines Triggers in SQL:2003-konformer Variante, der vor dem Einfügen eines neuen Datensatzes in die Tabelle `CUSTOMER` ausgelöst wird.
+
[source]
----
CREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
----
. Einen Trigger erstellen, der nach dem Einfügen, Aktualisieren oder Löschen eines Datensatzes in der Tabelle `CUSTOMER` ausgeführt wird.
+
[source]
----
CREATE TRIGGER TR_CUST_LOG
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
ON CUSTOMER
AS
BEGIN
  INSERT INTO CHANGE_LOG (LOG_ID,
                          ID_TABLE,
                          TABLE_NAME,
                          MUTATION)
  VALUES (NEXT VALUE FOR SEQ_CHANGE_LOG,
          OLD.CUST_NO,
          'CUSTOMER',
          CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING  THEN 'UPDATE'
            WHEN DELETING  THEN 'DELETE'
          END);
END
----

[[fblangref25-ddl-trgr-dbtrigger-de]]
==== Datenbank-Trigger

Trigger können definiert werden, um auf "`Datenbankereignisse`" zu reagieren.
Dies können verschiedene Ereignisse sein.
Diese können auf den Umfang einer Sitzung (Verbindung) hinweg agieren, aber auch über die Umgebung einer Transaktion wirken:

* `CONNECT`
* `DISCONNECT`
* `TRANSACTION START`
* `TRANSACTION COMMIT`
* `TRANSACTION ROLLBACK`

[[fblangref25-ddl-trgr-dbtrigger-exec-de]]
===== Ausführung von Datenbanktriggern und Fehlerbehandlung

``CONNECT``- und ``DISCONNECT``-Trigger werden in einer speziell für diesen Zweck erstellten Transaktion ausgeführt.
Läuft alles glatt, wird die Transaktion committed.
Nicht abgefangene Ausnahmen bewirken, dass die Transaktion zurückgesetzt wird, und 

* für einen ``CONNECT``-Trigger wird die Verbindung unterbrochen und die Ausnahme wird an den Client zurückgegeben
* für einen ``DISCONNECT``-Trigger werden Ausnahmen nicht gemeldet. Die Verbindung ist wie beabsichtigt unterbrochen

``TRANSACTION``-Trigger werden innerhalb der Transaktion ausgeführt, deren Start, Commit oder Rollback sie hervorruft.
Die Aktion, die nach einer nicht abgefangenen Ausnahme ausgeführt wird, hängt vom Ereignis ab: 

* In einem ``TRANSACTION START``-Trigger wird die Ausnahme an den Client gemeldet und die Transaktion wird zurückgesetzt
* In einem ``TRANSACTION COMMIT``-Trigger wird die Ausnahme gemeldet, die bisherigen Aktionen des Triggers werden rückgängig gemacht und das Commit abgebrochen
* In einem ``TRANSACTION ROLLBACK``-Trigger wird die Ausnahme nicht gemeldet und die Transaktion wird wie beabsichtigt  zurückgesetzt.

[[fblangref25-ddl-trgr-dbtrigger-traps-de]]
====== Fallen

Offensichtlich gibt es keine direkte Möglichkeit zu wissen, ob ein ``DISCONNECT``- oder  ``TRANSACTION ROLLBACK``-Trigger eine Ausnahme verursacht hat.
Daraus folgt auch, dass die Verbindung zur Datenbank nicht zustande kommen kann, wenn ein ``CONNECT``-Trigger eine Ausnahme verursacht und eine Transaktion nicht gestartet werden kann, wenn auch ein ``TRANSACTION START``-Trigger einen auslöst.
Beide Phänomene sperrt Sie effektiv aus Ihrer Datenbank aus, bis Sie mit unterdrückten Datenbanktriggern zurückkehren und den fehlerhaften Code beheben.

[float]
[[fblangref25-ddl-trgr-dbtrigger-notrgr-de]]
====== Triggerunterdrückung

Einige Firebird-Befehlszeilentools wurden mit Switches ausgestattet, mit denen ein Administrator die automatische Auslösung von Datenbanktriggern unterdrücken kann.
Bisher sind sie:

[source]
----
gbak -nodbtriggers
isql -nodbtriggers
nbackup -T
----

[[fblangref25-ddl-trgr-dbtrigger-2pc-de]]
====== Zwei-Phasen Commit

In einem zweiphasigen Commit-Szenario löst ein ``TRANSACTION COMMIT``-Trigger bereits in der Vorbereitungsphase aus und nicht erst beim Commit.

[[fblangref25-ddl-trgr-dbtrigger-caveats-de]]
====== Einige Vorbehalte

. Die Verwendung der Anweisung `IN AUTONOMOUS TRANSACTION DO` in den Datenbanktriggern für Transaktionen (`TRANSACTION START`, `TRANSACTION ROLLBACK`, `TRANSACTION COMMIT`) kann dazu führen, dass die autonome Transaktion eine Endlosschleife generiert
. Die Ereignistrigger `DISCONNECT` und `TRANSACTION ROLLBACK` werden nicht ausgeführt, wenn Clients über  Überwachungstabellen getrennt werden (`DELETE FROM MON$ATTACHMENTS`)

Nur der Datenbankbesitzer und <<fblangref25-security-administrators-de,Administratoren>> haben die Berechtigung zum Erstellen von Datenbanktriggern.

===== Beispiele für `CREATE TRIGGER` für "`Database Triggers`"

. Einen Trigger für das Ereignis erstellen, bei dem eine Verbindung zur Datenbank hergestellt wird, in der Benutzer protokolliert werden, die sich am System anmelden.
Der Trigger wird als inaktiv erstellt.
+
[source]
----
CREATE TRIGGER tr_log_connect
INACTIVE ON CONNECT POSITION 0
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_TIMESTAMP);
END
----
. Einen Trigger für das Ereignis der Verbindung mit der Datenbank erstellen, das es keinem Benutzer, außer SYSDBA, erlaubt, sich außerhalb der Geschäftszeiten anzumelden.
+
[source]
----
CREATE EXCEPTION E_INCORRECT_WORKTIME 'The working day has not started yet.';

CREATE TRIGGER TR_LIMIT_WORKTIME ACTIVE
ON CONNECT POSITION 1
AS
BEGIN
  IF ((CURRENT_USER <> 'SYSDBA') AND
      NOT (CURRENT_TIME BETWEEN time '9:00' AND time '17:00')) THEN
    EXCEPTION E_INCORRECT_WORKTIME;
END
----

.Siehe auch
<<fblangref25-ddl-trgr-alter-de>>, <<fblangref25-ddl-trgr-crtalter-de>>, <<fblangref25-ddl-trgr-recreate-de>>, <<fblangref25-ddl-trgr-drop-de>>

[[fblangref25-ddl-trgr-alter-de]]
=== `ALTER TRIGGER`

.Benutzt für
Ändern und Deaktivieren eines vorhandenen Triggers 

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER TRIGGER _trigname_
  [ACTIVE | INACTIVE]
  [{BEFORE | AFTER} <mutation_list> | ON <db_event>]
  [POSITION _number_]
  [
    AS
      [<declarations>]
    BEGIN
      [<PSQL_statements>]
    END
  ]

<mutation_list> ::=
  <mutation> [OR <mutation> [OR <mutation>]]

<mutation> ::= { INSERT | UPDATE | DELETE }

<db_event> ::=
  { CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK }

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; …]
----

[[fblangref25-ddl-tbl-altertrigger-de]]
.`ALTER TRIGGER` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|trigname
|Name eines vorhandenen Triggers

|mutation_list
|Liste von Relation-Ereignissen (Tabelle {vbar} Ansicht)

|number
|Position des Triggers in der Zündreihenfolge.
Von 0 bis 32.767

|declarations
|Abschnitt zum Deklarieren von lokalen Variablen und benannter Cursor

|declare_var
|Lokale Variablendeklaration

|declare_cursor
|Benannte Cursor-Deklaration

|PSQL_statements
|Anweisungen in der Programmiersprache von Firebird (PSQL)
|===

Die Anweisung `ALTER TRIGGER` erlaubt bestimmte Änderungen am Header und am Rumpf eines Triggers.

[[fblangref25-ddl-trgr-alterwhat-de]]
==== Zulässige Änderungen an Triggern

* Status (`ACTIVE | INACTIVE`)
* Phase (`BEFORE | AFTER`)
* Veranstaltungen;
aber Relationstriggerereignisse können nicht in Datenbanktriggerereignisse geändert werden, und umgekehrt
* Position innerhalb der Ausführungsreihenfolge
* Änderungen am Code im Trigger-Body

Wenn ein Element nicht angegeben wurde, bleibt es unverändert.

.Zur Erinnerungen
[NOTE]
====
Das ``BEFORE``-Schlüsselwort weist darauf hin, dass der Trigger ausgeführt wird, bevor das zugehörige Ereignis eintritt.
Das Schlüsselwort ``AFTER`` weist darauf hin, dass es nach dem Ereignis ausgeführt wird.

Mehr als ein Beziehungsereignis -- `INSERT`, `UPDATE`, DELETE` --  kann mit einem einzigen Trigger abgedeckt werden.
Die Ereignisse sollten mit dem Schlüsselwort `OR` getrennt werden.
Kein Ereignis sollte mehr als einmal erwähnt werden.

Das Schlüsselwort `POSITION` erlaubt es, eine optionale Ausführungsreihenfolge ("`firing order`") für eine Reihe von Triggern anzugeben, die dieselbe Phase und dasselbe Ereignis wie ihr Ziel haben.
Die Standardposition ist 0.
Wenn keine Positionen angegeben werden oder wenn mehrere Trigger eine einzelne Positionsnummer haben, werden die Trigger in der alphabetischen Reihenfolge ihrer Namen ausgeführt.
====

<<fblangref25-security-administrators-de,Administratoren>> und folgende Benutzer haben die Berechtigung für die Ausführung von `ALTER TRIGGER`:

* Für Relations-Trigger der Besitzer des Tisches
* Für Datenbank-Trigger der Eigentümer der Datenbank

==== Beispiele mit ALTER TRIGGER

. Deaktivieren des Triggers `set_cust_no` (Umschalten in den inaktiven Status)
+
[source]
----
ALTER TRIGGER set_cust_no INACTIVE;
----
. Ändern der Ausführungsreihenfolge des Triggers `set_cust_no`.
+
[source]
----
ALTER TRIGGER set_cust_no POSITION 14;
----
. Den Trigger `TR_CUST_LOG` in den inaktiven Status schalten und die Liste der Ereignisse ändern.
+
[source]
----
ALTER TRIGGER TR_CUST_LOG
INACTIVE AFTER INSERT OR UPDATE;
----
. Den ``tr_log_connect``-Trigger in den aktiven Status schalten und seine Position und seinen Körper ändern.
+
[source]
----
ALTER TRIGGER tr_log_connect
ACTIVE POSITION 1
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ROLENAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_ROLE,
          CURRENT_TIMESTAMP);
END
----

.Siehe auch
<<fblangref25-ddl-trgr-create-de>>, <<fblangref25-ddl-trgr-crtalter-de>>, <<fblangref25-ddl-trgr-recreate-de>>, <<fblangref25-ddl-trgr-drop-de>>

[[fblangref25-ddl-trgr-crtalter-de]]
=== `CREATE OR ALTER TRIGGER`

.Benutzt für
Erstellen eines neuen Triggers oder Ändern eines vorhandenen Triggers

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER TRIGGER _trigname_  {
  <relation_trigger_legacy> |
  <relation_trigger_sql2003> |
  <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

Für das vollständige Detail der Syntax siehe <<fblangref25-ddl-trgr-create-de>>.

Die Anweisung `CREATE OR ALTER TRIGGER` erstellt einen neuen Trigger, falls er nicht existiert.
Andernfalls ändert und kompiliert er es erneut, wobei die Privilegien intakt und die Abhängigkeiten unberührt bleiben.

.Beispiel mit `CREATE OR ALTER TRIGGER`
Erstellen eines neuen Triggers, falls er nicht existiert oder anpassen, falls vorhanden.

[source]
----
CREATE OR ALTER TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
----

.Siehe auch
<<fblangref25-ddl-trgr-create-de>>, <<fblangref25-ddl-trgr-alter-de>>, <<fblangref25-ddl-trgr-recreate-de>>

[[fblangref25-ddl-trgr-drop-de]]
=== `DROP TRIGGER`

.Benutzt für
Einen vorhandenen Trigger löschen

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP TRIGGER _trigname_
----

[[fblangref25-ddl-tbl-droptrigger-de]]
.`DROP TRIGGER` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|trigname
|Triggername
|===

Die Anweisung `DROP TRIGGER` löscht einen vorhandenen Trigger.

<<fblangref25-security-administrators-de,Administrators>> und die folgenden Benutzer besitzen die Berechtigung, die Anweisung `DROP TRIGGER` auszuführen: 

* Für Relations-Trigger, der Eigentümer der Tabelle
* Für Datenbank-Trigger, der Eigentümer der Datenbank

.Beispiele für `DROP TRIGGER`
Löschen des Triggers `set_cust_no`.

[source]
----
DROP TRIGGER set_cust_no;
----

.Siehe auch
<<fblangref25-ddl-trgr-create-de>>, <<fblangref25-ddl-trgr-recreate-de>>

[[fblangref25-ddl-trgr-recreate-de]]
=== `RECREATE TRIGGER`

.Benutzt für
Erstellen eines neuen Triggers oder Neuerstellung eines vorhandenen

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE TRIGGER _trigname_ {
  <relation_trigger_legacy> |
  <relation_trigger_sql2003> |
  <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

Für die detaillierte Syntax, vergleichen Sie <<fblangref25-ddl-trgr-create-de>>.

Die Anweisung `RECREATE TRIGGER` erzeugt einen neuen Trigger, wenn kein Trigger mit dem angegebenen Namen existiert.
Andernfalls versucht die Anweisung `RECREATE TRIGGER`, den vorhandenen Trigger zu löschen und einen neuen zu erstellen.
Die Operation schlägt beim `COMMIT` fehl, wenn Triggerabhängigkeiten vorliegen.

[WARNING]
====
Beachten Sie, dass Abhängigkeitsfehler erst in der Phase `COMMIT` dieser Operation erkannt werden.
====

.Beispiele für `RECREATE TRIGGER`
Erstellen oder Neuerstellung des Triggers `set_cust_no`.

[source]
----
RECREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
----

.Siehe auch
<<fblangref25-ddl-trgr-create-de>>, <<fblangref25-ddl-trgr-drop-de>>, <<fblangref25-ddl-trgr-crtalter-de>>

[[fblangref25-ddl-procedure-de]]
== `PROCEDURE`

Eine gespeicherte Prozedur (Stored Procedure) ist ein Softwaremodul, das von einem Client, einer anderen Prozedur, einem ausführbaren Block oder einem Trigger aufgerufen werden kann.
Gespeicherte Prozeduren, ausführbare Blöcke und Trigger werden in prozeduralem SQL (PSQL) geschrieben.
Die meisten SQL-Anweisungen sind auch in PSQL verfügbar, manchmal mit Einschränkungen oder Erweiterungen.
Zu den bemerkenswerten Ausnahmen zählen DDL- und Transaktionskontrollanweisungen.

Gespeicherte Prozeduren können viele Eingabe- und Ausgabeparameter haben.

[[fblangref25-ddl-proc-create-de]]
=== `CREATE PROCEDURE`

.Benutzt für
Erstellen einer neuen gespeicherten Prozedur

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<inparam> ::= <param_decl> [{= | DEFAULT} <value>]

<outparam> ::= <param_decl>

<value> ::= {<literal> | NULL | <context_var>}

<param_decl> ::= _paramname_ <type> [NOT NULL]
  [COLLATE _collation_]

<type> ::=
    <datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN __rel__.__col__

<datatype> ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; …]
----

[[fblangref25-ddl-proc-createproc-de]]
.`CREATE PROCEDURE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|procname
|Der Name der gespeicherten Prozedur besteht aus bis zu 31 Zeichen.
Muss für alle Tabellen-, View- und Prozedurnamen in der Datenbank eindeutig sein

|inparam
|Beschreibung der Eingabeparameter

|outparam
|Beschreibung der Ausgangsparameter

|declarations
|Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn

|declare_var
|Lokale Variablendeklaration

|declare_cursor
|Benannte Cursor-Deklaration

|PSQL_statements
|Prozedurale SQL-Anweisungen

|literal
|Ein Literalwert, der mit dem Datentyp des Parameters zuweisungskompatibel ist

|context_var
|Jede Kontextvariable, deren Typ mit dem Datentyp des Parameters kompatibel ist

|paramname
|Der Name eines Eingabe- oder Ausgabeparameters der Prozedur.
Dieser kann aus bis zu 31 Zeichen bestehen.
Der Name des Parameters muss unter den Eingabe- und Ausgabeparametern der Prozedur und ihren lokalen Variablen eindeutig sein

|datatype
|SQL-Datentyp

|collation
|Sortierfolge

|domain
|Domain-Name

|rel
|Tabellen- oder View-Name

|col
|Spaltenname einer Tabelle oder View

|precision
|Die Gesamtanzahl der signifikanten Stellen, die der Parameter halten kann (1..18)

|scale
|Die Anzahl der Stellen nach dem Dezimalpunkt (0..__precision__)

|size
|Die maximale Größe eines Zeichenfolgentypparameters oder einer Variablen in Zeichen

|charset
|Zeichensatz eines String-Typ-Parameters oder einer Variablen

|subtype_num
|Subtyp-Nummer eines `BLOB`

|subtype_name
|Mnemonischer Name eines ``BLOB``-Subtyps

|seglen
|Segmentgröße (max. 65535)
|===

Die Anweisung `CREATE PROCEDURE` erstellt eine neue gespeicherte Prozedur.
Der Name der Prozedur muss unter den Namen aller gespeicherten Prozeduren, Tabellen und Ansichten in der Datenbank eindeutig sein.

`CREATE PROCEDURE` ist eine _zusammengesetzte Anweisung_, bestehend aus einem Header und einem Body.
Der Header gibt den Namen der Prozedur an und deklariert Eingabeparameter und ggf. die Ausgabeparameter, die von der Prozedur zurückgegeben werden sollen.

Der Prozedurhauptteil besteht aus Deklarationen für alle lokalen Variablen und benannten Cursors, die von der Prozedur verwendet werden, gefolgt von einer oder mehreren Anweisungen oder Anweisungsblöcken, die alle in einem äußeren Block eingeschlossen sind, der mit dem Schlüsselwort `BEGIN` beginnt und mit dem Schlüsselwort `END` endet.
Deklarationen und eingebettete  Anweisungen werden mit Semikolon ('```;```') abgeschlossen.

[[fblangref25-ddl-terminators02-de]]
==== Statement-Terminatoren

Einige SQL-Anweisungseditoren -- insbesondere das mit Firebird mitgelieferte Dienstprogramm _isql_ und möglicherweise einige Editoren von Drittanbietern -- verwenden eine interne Konvention, die erfordert, dass alle Anweisungen mit einem Semikolon abgeschlossen werden.
Dies führt bei der Codierung in diesen Umgebungen zu einem Konflikt mit der PSQL-Syntax.
Wenn Sie mit diesem Problem und seiner Lösung nicht vertraut sind, lesen Sie bitte die Details im Kapitel PSQL im Abschnitt <<fblangref25-sidebar01-de,Umschalten des Terminators in _isql_>>.

[[fblangref25-ddl-proc-params-de]]
==== Parameter

Jeder Parameter hat einen Datentyp, der dafür angegeben ist.
Die Einschränkung `NOT NULL` kann auch für jeden beliebigen Parameter angegeben werden, um zu verhindern, dass `NULL` übergeben oder zugewiesen wird.

Mit der Klausel `COLLATE` kann eine Sortierfolge für Parameter vom Typ String festgelegt werden.

Eingabeparameter::
Eingabeparameter werden nach dem Namen der Prozedur in Klammern angezeigt.
Sie werden als Werte an die Prozedur übergeben, d.h. alles, was sie innerhalb der Prozedur ändert, hat keine Auswirkungen auf die Parameter im aufrufenden Programm.
+
Eingabeparameter können Standardwerte haben.
Diejenigen, für die Werte angegeben sind, müssen sich  am Ende der Parameterliste befinden.

Ausgabeparameter::
Die optionale Klausel `RETURNS` dient zur Angabe einer eingeklammerten Liste von Ausgabeparametern für die gespeicherte Prozedur.

[[fblangref25-ddl-proc-paramsdomns-de]]
===== Verwendung von Domains in Deklarationen

Ein Domainname kann als Typ eines Parameters angegeben werden.
Der Parameter erbt alle Domainattribute.
Wenn ein Standardwert für den Parameter angegeben wird, überschreibt dieser den in der Domänendefinition angegebenen Standardwert.

Wenn die Klausel `TYPE OF` vor dem Domänennamen hinzugefügt wird, wird nur der Datentyp der Domain verwendet: Alle anderen Attribute der Domain -- ``NOT NULL``-Einschränkung, ``CHECK``-Bedingung, Standardwert -- werden weder geprüft noch verwendet.
Wenn die Domain jedoch aus einem Texttyp besteht, werden immer ihre Zeichensatz und die Sortierreihenfolge verwendet.

[[fblangref25-ddl-proc-paramscoltype-de]]
===== Verwendung des Spaltentyps in Deklarationen

Eingabe- und Ausgabeparameter können auch über den Datentyp von Spalten in vorhandenen Tabellen und Ansichten deklariert werden.
Die Klausel `TYPE OF COLUMN` wird dafür verwendet, wobei __relationname__.__columnname__ als Argument angegeben wird.

Wenn `TYPE OF COLUMN` verwendet wird, erbt der Parameter nur den Datentyp, bei Zeichenkettentypen den Zeichensatz und die Sortierreihenfolge.
Die Constraints und der Standardwert der Spalte werden ignoriert.

.Bugwarnung für Versionen vor Firebird 3:
[WARNING]
====
Für Eingabeparameter wird die Sortierung, die mit dem Typ der Spalte geliefert wird,  in Vergleichen ignoriert (z.B. Gleichheitstests).
Bei lokalen Variablen variiert das Verhalten.

Der Bug wurde für Firebird 3 behoben.
====

[[fblangref25-ddl-proc-declarations-de]]
==== Variablen- und Cursor-Deklarationen

Der optionale Deklarationsabschnitt, der zuletzt im Headerabschnitt der Prozedurdefinition aufgeführt ist, definiert lokale Variablen für die Prozedur und ihre benannten Cursor.
Lokale Variablendeklarationen folgen denselben Regeln wie Parameter bezüglich der Spezifikation des Datentyps.
Bitte entnehmen Sie Details den Abschnitten <<fblangref25-psql-de,PSQL chapter>> for <<fblangref25-psql-declare-variable-de,`DECLARE VARIABLE`>> und <<fblangref25-psql-declare-cursor-de,`DECLARE CURSOR`>>.

[[fblangref25-ddl-proc-procbody-de]]
==== Prozedurhauptteil

Auf den Headerabschnitt folgt der Prozedurhauptteil, der aus einer oder mehreren PSQL-Anweisungen besteht, die zwischen den äußeren Schlüsselwörtern `BEGIN` und `END` eingeschlossen sind.
Mehrere ``BEGIN ... END``-Blöcke von beendeten Anweisungen können in den Prozedurtext eingebettet werden.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine neue gespeicherte Prozedur erstellen.
Der Benutzer, der eine gespeicherte Prozedur erstellt, wird zu seinem Besitzer.

[[create-procedure-examples-de]]
==== Beispiele

Erstellen einer gespeicherten Prozedur, die einen Datensatz in die ``BREED``-Tabelle einfügt und den Code des eingefügten Datensatzes zurückgibt:

[source]
----
CREATE PROCEDURE ADD_BREED (
  NAME D_BREEDNAME, /* Domain attributes are inherited */
  NAME_EN TYPE OF D_BREEDNAME, /* Only the domain type is inherited */
  SHORTNAME TYPE OF COLUMN BREED.SHORTNAME,
    /* The table column type is inherited */
  REMARK VARCHAR(120) CHARACTER SET WIN1251 COLLATE PXW_CYRL,
  CODE_ANIMAL INT NOT NULL DEFAULT 1
)
RETURNS (
  CODE_BREED INT
)
AS
BEGIN
  INSERT INTO BREED (
    CODE_ANIMAL, NAME, NAME_EN, SHORTNAME, REMARK)
  VALUES (
    :CODE_ANIMAL, :NAME, :NAME_EN, :SHORTNAME, :REMARK)
  RETURNING CODE_BREED INTO CODE_BREED;
END
----

Erstellen einer wählbaren gespeicherten Prozedur, die Daten für Adressetiketten generiert (aus `employee.fdb`):

[source]
----
CREATE PROCEDURE mail_label (cust_no INTEGER)
RETURNS (line1 CHAR(40), line2 CHAR(40), line3 CHAR(40),
         line4 CHAR(40), line5 CHAR(40), line6 CHAR(40))
AS
  DECLARE VARIABLE customer VARCHAR(25);
  DECLARE VARIABLE first_name VARCHAR(15);
  DECLARE VARIABLE last_name VARCHAR(20);
  DECLARE VARIABLE addr1 VARCHAR(30);
  DECLARE VARIABLE addr2 VARCHAR(30);
  DECLARE VARIABLE city VARCHAR(25);
  DECLARE VARIABLE state VARCHAR(15);
  DECLARE VARIABLE country VARCHAR(15);
  DECLARE VARIABLE postcode VARCHAR(12);
  DECLARE VARIABLE cnt INTEGER;
BEGIN
  line1 = '';
  line2 = '';
  line3 = '';
  line4 = '';
  line5 = '';
  line6 = '';

  SELECT customer, contact_first, contact_last, address_line1,
    address_line2, city, state_province, country, postal_code
  FROM CUSTOMER
  WHERE cust_no = :cust_no
  INTO :customer, :first_name, :last_name, :addr1, :addr2,
    :city, :state, :country, :postcode;

  IF (customer IS NOT NULL) THEN
    line1 = customer;
  IF (first_name IS NOT NULL) THEN
    line2 = first_name || ' ' || last_name;
  ELSE
    line2 = last_name;
  IF (addr1 IS NOT NULL) THEN
    line3 = addr1;
  IF (addr2 IS NOT NULL) THEN
    line4 = addr2;

  IF (country = 'USA') THEN
  BEGIN
    IF (city IS NOT NULL) THEN
  	  line5 = city || ', ' || state || '  ' || postcode;
  	ELSE
      line5 = state || '  ' || postcode;
  END
  ELSE
  BEGIN
    IF (city IS NOT NULL) THEN
  	  line5 = city || ', ' || state;
  	ELSE
      line5 = state;
    line6 = country || '    ' || postcode;
  END

  SUSPEND; -- the statement that sends an output row to the buffer
           -- and makes the procedure "selectable"
END
----

.Siehe auch
<<fblangref25-ddl-proc-crtoralter-de>>, <<fblangref25-ddl-proc-alter-de>>, <<fblangref25-ddl-proc-recreate-de>>, <<fblangref25-ddl-proc-drop-de>>

[[fblangref25-ddl-proc-alter-de]]
=== `ALTER PROCEDURE`

.Benutzt für
Ändern einer vorhandenen gespeicherten Prozedur

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<inparam> ::= <param_decl> [{= | DEFAULT} <value>]

<outparam> ::= <param_decl>

<param_decl> ::= _paramname_ <type> [NOT NULL]
  [COLLATE _collation_]

<type> ::=
    <datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN __rel__.__col__

<datatype> ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISSION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR} [VARYING]
    [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; …]
----

[[fblangref25-ddl-proc-alterproc-de]]
.`ALTER PROCEDURE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|procname
|Der Name einer existierenden gespeicherten Prozedur

|inparam
|Beschreibung der Eingabeparameter

|outparam
|Beschreibung der Ausgangsparameter

|declarations
|Abschnitt zum Deklarieren von lokalen Variablen und benannten Cursorn

|declare_var
|Lokale Variablendeklaration

|declare_cursor
|Benannte Cursor-Deklaration

|PSQL_statements
|Prozedurale SQL-Anweisungen

|literal
|Ein Literalwert, der mit dem Datentyp des Parameters zuweisungskompatibel ist

|context_var
|Jede Kontextvariable, deren Typ mit dem Datentyp des Parameters kompatibel ist

|paramname
|Der Name eines Eingabe- oder Ausgabeparameters der Prozedur.
Dieser kann aus bis zu 31 Zeichen bestehen.
Der Name des Parameters muss unter den Eingabe- und Ausgabeparametern der Prozedur und ihren lokalen Variablen eindeutig sein

|datatype
|SQL-Datentyp

|collation
|Sortierfolge

|domain
|Domain-Name

|rel
|Tabellen- oder View-Name

|col
|Spaltenname einer Tabelle oder View

|precision
|Die Gesamtanzahl der signifikanten Stellen, die der Parameter halten kann (1..18)

|scale
|Die Anzahl der Stellen nach dem Dezimalpunkt (0..__precision__)

|size
|Die maximale Größe eines Zeichenfolgentypparameters oder einer Variablen in Zeichen

|charset
|Zeichensatz eines String-Typ-Parameters oder einer Variablen

|subtype_num
|Subtyp-Nummer eines `BLOB`

|subtype_name
|Mnemonischer Name eines ``BLOB``-Subtyps

|seglen
|Segmentgröße (max. 65535)
|===

Die Anweisung `ALTER PROCEDURE` erlaubt folgende Änderungen der Definition für gespeicherte Prozeduren: 

* Satz und die Eigenschaften von Eingangs- und Ausgangsparametern
* lokale Variablen
* Code im Hauptteil der gespeicherten Prozedur

Nach der Ausführung von `ALTER PROCEDURE` bleiben vorhandene Berechtigungen erhalten und Abhängigkeiten werden nicht beeinflusst.

[CAUTION]
====
Achten Sie darauf, die Anzahl und Art der Eingabe- und Ausgabeparameter in gespeicherten Prozeduren zu ändern.
Bestehender Anwendungscode und Prozeduren und Trigger, die ihn aufrufen, könnten ungültig werden, weil die neue Beschreibung der Parameter mit dem alten Aufrufformat nicht kompatibel ist.
Informationen zum Beheben einer solchen Situation finden Sie im Artikel <<fblangref25-appx01-supp-rdb-validblr-de,Das Feld `RDB$VALID_BLR`>> im Anhang.
====

Der Prozedureigentümer und <<fblangref25-security-administrators-de,Administratoren>> besitzen die Recht zum Ausführen von `ALTER PROCEDURE`.

.Beispiele für ALTER PROCEDURE
Ändern der gespeicherten Prozedur `GET_EMP_PROJ`

[source]
----
ALTER PROCEDURE GET_EMP_PROJ (
  EMP_NO SMALLINT)
RETURNS (
  PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
      PROJ_ID
    FROM
      EMPLOYEE_PROJECT
    WHERE
      EMP_NO = :emp_no
    INTO :proj_id
  DO
    SUSPEND;
END
----

.Siehe auch
<<fblangref25-ddl-proc-create-de>>, <<fblangref25-ddl-proc-crtoralter-de>>, <<fblangref25-ddl-proc-recreate-de>>, <<fblangref25-ddl-proc-drop-de>>

[[fblangref25-ddl-proc-crtoralter-de]]
=== `CREATE OR ALTER PROCEDURE`

.Benutzt für
Erstellen einer neuen gespeicherten Prozedur oder Ändern einer vorhandenen

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

Das vollständige Syntaxdetail finden Sie unter <<fblangref25-ddl-proc-create-de>>.

Die Anweisung `CREATE OR ALTER PROCEDURE` erstellt eine neue gespeicherte Prozedur oder ändert eine vorhandene Prozedur.
Wenn die gespeicherte Prozedur nicht vorhanden ist, wird sie durch das transparente Aufrufen einer Anweisung `CREATE PROCEDURE` erstellt.
Wenn die Prozedur bereits vorhanden ist, wird sie geändert und kompiliert, ohne die vorhandenen Berechtigungen und Abhängigkeiten zu beeinträchtigen.

.Beispiel
Creating or altering the `GET_EMP_PROJ` procedure.

[source]
----
CREATE OR ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
      PROJ_ID
    FROM
      EMPLOYEE_PROJECT
    WHERE
      EMP_NO = :emp_no
    INTO :proj_id
  DO
    SUSPEND;
END
----

.Siehe auch
<<fblangref25-ddl-proc-create-de>>, <<fblangref25-ddl-proc-alter-de>>, <<fblangref25-ddl-proc-recreate-de>>

[[fblangref25-ddl-proc-drop-de]]
=== `DROP PROCEDURE`

.Benutzt für
Löschen einer gespeicherten Prozedur

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP PROCEDURE _procname_
----

[[fblangref25-ddl-tbl-procdrop-de]]
.`DROP PROCEDURE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|procname
|Name einer vorhandenen gespeicherten Prozedur
|===

Die Anweisung `DROP PROCEDURE` löscht eine vorhandene gespeicherte Prozedur.
Wenn die gespeicherte Prozedur Abhängigkeiten aufweist, schlägt der Löschversuch fehl und der entsprechende Fehler wird ausgelöst.

Der Prozedureigentümer und <<fblangref25-security-administrators-de, Administratoren>> haben die Berechtigung, `DROP PROCEDURE` zu verwenden.

.Beispiel
Löschen der gespeicherten Prozedur `GET_EMP_PROJ`

[source]
----
DROP PROCEDURE GET_EMP_PROJ;
----

.Siehe auch
<<fblangref25-ddl-proc-create-de>>, <<fblangref25-ddl-proc-recreate-de>>

[[fblangref25-ddl-proc-recreate-de]]
=== `RECREATE PROCEDURE`

.Benutzt für
Eine neue gespeicherte Prozedur erstellen oder eine vorhandene wiederherstellen

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

Das vollständige Syntaxdetail finden Sie unter <<fblangref25-ddl-proc-create-de>>.

Die Anweisung `RECREATE PROCEDURE` erstellt eine neue gespeicherte Prozedur oder erstellt eine vorhandene Prozedur neu.
Wenn es bereits eine Prozedur mit diesem Namen gibt, versucht die Engine diese zu löschen und eine neue zu erstellen.
Das Wiederherstellen einer vorhandenen Prozedur schlägt bei der Anforderung `COMMIT` fehl, wenn die Prozedur Abhängigkeiten aufweist.

[WARNING]
====
Beachten Sie, dass Abhängigkeitsfehler erst in der Phase `COMMIT` dieser Operation erkannt werden.
====

Nachdem eine Prozedur erfolgreich neu erstellt wurde, werden Berechtigungen zum Ausführen der gespeicherten Prozedur und die Berechtigungen der gespeicherten Prozedur selbst gelöscht.

.Beispiel
Erstellen der neuen gespeicherten Prozedur `GET_EMP_PROJ` oder Wiederherstellen der vorhandenen gespeicherten Prozedur `GET_EMP_PROJ`.

[source]
----
RECREATE PROCEDURE GET_EMP_PROJ (
  EMP_NO SMALLINT)
RETURNS (
  PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
      PROJ_ID
    FROM
      EMPLOYEE_PROJECT
    WHERE
      EMP_NO = :emp_no
    INTO :proj_id
  DO
    SUSPEND;
END
----

.Siehe auch
<<fblangref25-ddl-proc-create-de>>, <<fblangref25-ddl-proc-drop-de>>, <<fblangref25-ddl-proc-crtoralter-de>>

[[fblangref25-ddl-extfunc-de]]
== `EXTERNAL FUNCTION`

.ÜBERPRÜFUNGSSTATUS
[IMPORTANT]
====
Alle Abschnitte von diesem Punkt bis zum Ende des Kapitels warten auf eine technische und redaktionelle Überprüfung.
====

Externe Funktionen, die auch als "`benutzerdefinierte Funktionen`" (UDFs) bezeichnet werden, sind Programme, die in einer externen Programmiersprache geschrieben und in dynamisch geladenen Bibliotheken gespeichert werden.
Sobald sie in einer Datenbank deklariert sind, werden sie in dynamischen und prozeduralen Anweisungen verfügbar, als wären sie intern in der SQL-Sprache implementiert.

Externe Funktionen erweitern die Möglichkeiten zur Datenverarbeitung mit SQL erheblich.
Um eine Funktion für eine Datenbank verfügbar zu machen, wird sie mit der Anweisung `DECLARE EXTERNAL FUNCTON`  deklariert.

Die Bibliothek, die eine Funktion enthält, wird geladen, wenn eine darin enthaltene Funktion aufgerufen wird.

[NOTE]
====
Externe Funktionen können in mehr als einem Bibliotheks- oder "`-Modul`" enthalten sein, wie es in der Syntax erwähnt wird.
====

[[fblangref25-ddl-extfunc-declare-de]]
=== `DECLARE EXTERNAL FUNCTION`

.Benutzt für
Deklarieren einer benutzerdefinierten Funktion (UDF) zur Datenbank

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DECLARE EXTERNAL FUNCTION _funcname_
  [<arg_type_decl> [, <arg_type_decl> ...]]
  RETURNS {
    <sqltype> [BY {DESCRIPTOR | VALUE}] |
    CSTRING(_length_) |
    PARAMETER _param_num_ }
  [FREE_IT]
  ENTRY_POINT '_entry_point_' MODULE_NAME '_library_name_'

<arg_type_decl> ::=
    <sqltype> [{BY DESCRIPTOR} | NULL]
  | CSTRING(_length_) [NULL]
----

[[fblangref25-ddl-tbl-declarefunc-de]]
.`DECLARE EXTERNAL FUNCTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|funcname
|Funktionsname in der Datenbank.
Es kann aus bis zu 31 Zeichen bestehen.
Es sollte unter allen internen und externen Funktionsnamen in der Datenbank eindeutig sein und nicht mit dem Namen übereinstimmen, der aus der UDF-Bibliothek über `ENTRY_POINT`.

|entry_point
|Der exportierte Name der Funktion

|library_name
|Der Name des Moduls (`MODULE_NAME`), aus dem die Funktion exportiert wird.
Dies ist der Name der Datei ohne die "`.dll`" oder "`.so`"-Dateierweiterung.

|sqltype
|SQL-Datentyp.
Es kann kein Array oder Array-Element sein

|length
|Die maximale Länge einer nullterminierten Zeichenfolge, angegeben in Bytes

|param_num
|Die Nummer des Eingabeparameters, von 1 in der Liste der Eingabeparameter in der Deklaration nummeriert, beschreibt den Datentyp, der von der Funktion zurückgegeben wird
|===

Die Anweisung `DECLARE EXTERNAL FUNCTION` stellt eine benutzerdefinierte Funktion in der Datenbank zur Verfügung.
UDF-Deklarationen müssen in _jeder Datenbank_ vorgenommen werden, die sie verwenden soll.
Es gibt keine Notwendigkeit, UDFs zu deklarieren, die niemals verwendet werden.

Der Name der externen Funktion muss unter allen Funktionsnamen eindeutig sein.
Es kann sich  vom exportierten Namen der Funktion unterscheiden, wie im ``ENTRY_POINT``-Argument angegeben.

[[fblangref25-ddl-extfunc-inp-de]]
==== ``DECLARE EXTERNAL FUNCTION``-Eingabeparameter

Die Eingabeparameter der Funktion folgen dem Namen der Funktion und sind durch Kommas getrennt.
Für jeden Parameter ist ein SQL-Datentyp angegeben.
Arrays können nicht als Funktionsparameter verwendet werden.
Neben den SQL-Typen steht der ``CSTRING``-Typ für die Angabe einer nullterminierten Zeichenfolge mit einer maximalen Länge von `LENGTH` Bytes zur Verfügung.

Standardmäßig werden Eingabeparameter _durch Referenz_ übergeben.
Die ``BY DESCRIPTOR``-Klausel kann stattdessen angegeben werden, wenn der Eingabeparameter durch den Deskriptor übergeben wird.
Das Übergeben eines Parameters nach Deskriptor ermöglicht die Verarbeitung von ``NULL``s.

[[fblangref25-ddl-extfunc-keywords-de]]
===== Klauseln und Schlüsselwörter

``RETURNS``-Klausel::
(Erforderlich) gibt den von der Funktion zurückgegebenen Ausgabeparameter an.
Eine Funktion ist skalar: Sie gibt nur einen Parameter zurück.
Der Ausgabeparameter kann von einem beliebigen SQL-Typ (außer einem Array oder einem Array-Element) oder einer nullterminierten Zeichenfolge (`CSTRING`) sein.
Der Ausgabeparameter kann durch Referenz (Standard), Deskriptor oder Wert übergeben werden.
Wenn die Klausel `BY DESCRIPTOR` angegeben ist, wird der Ausgabeparameter von Deskriptor übergeben.
Wenn die ``BY VALUE``-Klausel angegeben ist, wird der Ausgabeparameter über den Wert übergeben.

``PARAMETER``-Schlüsselwort::
gibt an, dass die Funktion den Wert aus dem Parameter an Stelle _param_num_ zurückgibt.
Es ist notwendig, wenn Sie einen Wert des Datentyps `BLOB` zurückgeben müssen.

`FREE_IT` Schlüsselwort::
bedeutet, dass der Speicher, der zum Speichern des Rückgabewerts zugewiesen wurde, freigegeben wird, nachdem die Funktion ausgeführt wurde.
Sie wird nur verwendet, wenn der Speicher in der UDF dynamisch zugewiesen wurde.
In einer solchen UDF muss der Speicher mit Hilfe der Funktion `ib_util_malloc` aus dem ``ib_util``-Modul zugewiesen werden, was die Kompatibilität mit den im Firebird-Code verwendeten Funktionen und Code der ausgelieferten UDF-Module, zum Zuweisen und Freigeben von Speicher.

``ENTRY_POINT``-Klausel::
gibt den Namen des Einstiegspunkts (den Namen der importierten Funktion) an, der aus dem Modul exportiert wird.

``MODULE_NAME``-Klausel::
Definiert den Namen des Moduls, in dem sich die exportierte Funktion befindet.
Der Link zum Modul sollte nicht der vollständige Pfad und die Erweiterung der Datei sein, wenn dies vermieden werden kann.
Wenn sich das Modul am Standardspeicherort (im Unterverzeichnis `../UDF` des Firebird-Serverstammes) oder an einem in `firebird.conf` explizit konfigurierten Speicherort befindet, ist es einfacher, die Datenbank zwischen verschiedene Plattformen.
Der Parameter _UDFAccess_ in der Datei firebird.conf ermöglicht die Konfiguration von Zugriffsbeschränkungen für externe Funktionsmodule.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine externe Funktion (UDF) deklarieren.

==== Beispiele zuv Verwendung von `DECLARE EXTERNAL FUNCTION`

. Deklarieren der externen ``addDay``-Funktion im ``fbudf``-Modul.
Die Ein- und Ausgabeparameter werden als Referenz übergeben.
+
[source]
----
DECLARE EXTERNAL FUNCTION addDay
  TIMESTAMP, INT
  RETURNS TIMESTAMP
  ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';
----
. Deklaration der externen ``Invl``-Funktion im ``fbudf``-Modul.
Die Ein- und Ausgabeparameter werden vom Deskriptor übergeben.
+
[source]
----
DECLARE EXTERNAL FUNCTION invl
  INT BY DESCRIPTOR, INT BY DESCRIPTOR
  RETURNS INT BY DESCRIPTOR
  ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';
----
. Declaring the `isLeapYear` external function located in the `fbudf` module.
The input parameter is passed by reference, while the output parameter is passed by value.
+
[source]
----
DECLARE EXTERNAL FUNCTION isLeapYear
  TIMESTAMP
  RETURNS INT BY VALUE
  ENTRY_POINT 'isLeapYear' MODULE_NAME 'fbudf';
----
. Deklaration der externen Funktion `i64Truncate` im ``fbudf``-Modul.
Die Ein- und Ausgabeparameter werden vom Deskriptor übergeben.
Der zweite Parameter der Funktion wird als Rückgabewert verwendet.
+
[source]
----
DECLARE EXTERNAL FUNCTION i64Truncate
  NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
  RETURNS PARAMETER 2
  ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';
----

.Siehe auch
<<fblangref25-ddl-extfunc-alter-de>>, <<fblangref25-ddl-extfunc-drop-de>>

[[fblangref25-ddl-extfunc-alter-de]]
=== `ALTER EXTERNAL FUNCTION`

.Benutzt für
Ändern des Eintrittspunkts und / oder des Modulnamens für eine  benutzerdefinierte Funktion (UDF)

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER EXTERNAL FUNCTION _funcname_
  [ENTRY_POINT '_new_entry_point_']
  [MODULE_NAME '_new_library_name_']
----

[[fblangref25-ddl-tbl-alterfunc-de]]
.`ALTER EXTERNAL FUNCTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|funcname
|Funktionsname in der Datenbank

|new_entry_point
|Der neue exportierte Name der Funktion

|new_library_name
|Der neue Name des Moduls (`MODULE_NAME`), aus dem die Funktion exportiert wird, ist der Name der Datei ohne die "`.dll`"- oder "`.so`"-Dateierweiterung.
|===

Die Anweisung `ALTER EXTERNAL FUNCTION` ändert den Eintrittspunkt und / oder den Modulnamen für eine benutzerdefinierte Funktion (UDF).
Vorhandene Abhängigkeiten bleiben erhalten, nachdem die Anweisung mit der Änderung[s] ausgeführt wurde.

Die ``ENTRY_POINT``-Klausel::
dient zur Angabe des neuen Eintrittspunktes (der Name der Funktion, die aus dem Modul exportiert wird).

Die ``MODULE_NAME``-Klausel::
Gibt den neuen Namen des Moduls an, in dem sich die exportierte Funktion befindet.

Jeder an die Datenbank angeschlossene Benutzer kann den Eintrittspunkt und den  Modulnamen ändern.

.Beispiele für die Verwendung von ALTER EXTERNAL FUNCTION
. Ändern des Einstiegspunkts für eine externe Funktion
+
[source]
----
ALTER EXTERNAL FUNCTION invl ENTRY_POINT 'intNvl';
----
. Ändern des Modulnamens für eine externe Funktion
+
[source]
----
ALTER EXTERNAL FUNCTION invl MODULE_NAME 'fbudf2';
----

.Siehe auch
<<fblangref25-ddl-extfunc-declare-de>>, <<fblangref25-ddl-extfunc-drop-de>>

[[fblangref25-ddl-extfunc-drop-de]]
=== `DROP EXTERNAL FUNCTION`

.Benutzt für
Entfernen einer benutzerdefinierten Funktion (UDF) aus einer Datenbank

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP EXTERNAL FUNCTION _funcname_
----

[[fblangref25-ddl-tbl-dropfunc-de]]
.`DROP EXTERNAL FUNCTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|funcname
|Funktionsname in der Datenbank
|===

Die Anweisung `DROP EXTERNAL FUNCTION` löscht die Deklaration einer benutzerdefinierten Funktion aus der Datenbank.
Wenn es Abhängigkeiten von der externen Funktion gibt, schlägt die Anweisung fehl und der entsprechende Fehler wird ausgelöst.

Jeder mit der Datenbank verbundene Benutzer kann die Deklaration einer internen Funktion löschen.

.Beispiel der Verwendung von `DROP EXTERNAL FUNCTION`
Löschen der Deklaration der ``addDay``-Funktion.

[source]
----
DROP EXTERNAL FUNCTION addDay;
----

.Siehe auch
<<fblangref25-ddl-extfunc-declare-de>>

[[fblangref25-ddl-filter-de]]
== `FILTER`

Ein ``BLOB FILTER``-Filter ist ein Datenbankobjekt, das eigentlich ein spezieller Typ einer externen Funktion ist, mit dem alleinigen Zweck, ein ``BLOB``-Objekt in einem Format zu verwenden und es zu konvertieren zu einem ``BLOB``-Objekt in einem anderen Format.
Die Formate der ``BLOB``-Objekte werden mit benutzerdefinierten ``BLOB``-Subtypen angegeben.

Externe Funktionen zum Konvertieren von ``BLOB``-Typen werden in dynamischen Bibliotheken gespeichert und bei Bedarf geladen.

Weitere Informationen zu ``BLOB``-Subtypen finden Sie unter <<fblangref25-datatypes-bnrytypes-de,Binäre Datentypen>>.

[[fblangref25-ddl-filter-declare-de]]
=== `DECLARE FILTER`

.Benutzt für
Deklarieren eines ``BLOB``-Filters zur Datenbank

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DECLARE FILTER _filtername_
  INPUT_TYPE <sub_type> OUTPUT_TYPE <sub_type>
  ENTRY_POINT '_function_name_' MODULE_NAME '_library_name_'

<sub_type> ::= _number_ | <mnemonic>

<mnemonic> ::=
    BINARY | TEXT | BLR | ACL | RANGES
  | SUMMARY | FORMAT | TRANSACTION_DESCRIPTION
  | EXTERNAL_FILE_DESCRIPTION | _user_defined_
----

[[fblangref25-ddl-tbl-declarefiltr-de]]
.`DECLARE FILTER` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|filtername
|Name des Filters in der Datenbank.
Es kann aus bis zu 31 Zeichen bestehen.
Es muss nicht derselbe Name sein, wie der aus der Filterbibliothek via `ENTRY_POINT` geholt wird.

|sub_type
|``BLOB``-Subtype

|number
|``BLOB SUB_TYPE``-Nummer (muss negativ sein)

|mnemonic
|`BLOB SUB_TYPE` mnemonischer Name

|function_name
|Der exportierte Name (Einstiegspunkt) der Funktion

|library_name
|Der Name des Moduls, in dem sich der Filter befindet

|user_defined
|Benutzerdefinierter `BLOB SUB_TYPE` mnemonischer Name
|===

Mit der Anweisung `DECLARE FILTER` wird ein ``BLOB``-Filter für die Datenbank verfügbar.
Der Name des ``BLOB``-Filters muss unter den Namen von ``BLOB``-Filtern eindeutig sein.

[[fblangref25-ddl-filter-subtype-de]]
==== Spezifizieren der Subtypen

Die Subtypen können als Untertypnummer oder als Subtyp-Mnemonikname angegeben werden.
Benutzerdefinierte Subtypen müssen durch negative Zahlen (von -1 bis -32.768) dargestellt werden.
Ein Versuch, mehr als einen ``BLOB``-Filter mit derselben Kombination der Ein- und Ausgabetypen zu deklarieren, schlägt mit einem Fehler fehl.

`INPUT_TYPE`::
Klausel, die den ``BLOB``-Subtyp des zu konvertierenden Objekts definiert

`OUTPUT_TYPE`::
Klausel definiert den ``BLOB``-Subtyp des zu erstellenden Objekts.

[NOTE]
====
Mnemonische Namen können für benutzerdefinierte ``BLOB``-Subtypen definiert und manuell in die Systemtabelle `RDB$TYPES` eingefügt werden.

[source]
----
INSERT INTO RDB$TYPES (RDB$FIELD_NAME, RDB$TYPE, RDB$TYPE_NAME)
VALUES ('RDB$FIELD_SUB_TYPE', -33, 'MIDI');
----

Nachdem die Transaktion bestätigt wurde, können die mnemonischen Namen in Deklarationen verwendet werden, wenn Sie neue Filter erstellen.

Der Wert der Spalte `RDB$FIELD_NAME` muss immer `'RDB$FIELD_SUB_TYPE'` sein.
Bei mnemonischen Namen in Großbuchstaben können sie bei der Definition eines Filters case-insensitiv und ohne Anführungszeichen verwendet werden.

.Warning
Ab Firebird 3 sind die Systemtabellen nicht mehr von Benutzern beschreibbar.
However, inserting custom types into `RDB$TYPES` is still possible.
====

[[fblangref25-ddl-filter-params-de]]
==== Parameters

`ENTRY_POINT`::
Klausel, die den Namen des Einstiegspunkts (den Namen der importierten  Funktion) im Modul definiert.

`MODULE_NAME`::
Die Klausel definiert den Namen des Moduls, in dem sich die exportierte Funktion befindet.
Standardmäßig müssen sich die Module im UDF-Ordner des Stammverzeichnisses auf dem Server befinden.
Der Parameter _UDFAccess_ in `firebird.conf` ermöglicht das Bearbeiten von Zugriffsbeschränkungen für Filterbibliotheken.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann einen BLOB-Filter deklarieren.

==== Beispiele

. Erstellen eines ``BLOB``-Filters mit Subtypnummern.
+
[source]
----
DECLARE FILTER DESC_FILTER
  INPUT_TYPE 1
  OUTPUT_TYPE -4
  ENTRY_POINT 'desc_filter'
  MODULE_NAME 'FILTERLIB';
----
. Erstellen eines ``BLOB``-Filters mit Untertyp-Mnemoniknamen.
+
[source]
----
DECLARE FILTER FUNNEL
  INPUT_TYPE blr OUTPUT_TYPE text
  ENTRY_POINT 'blr2asc' MODULE_NAME 'myfilterlib';
----

.Siehe auch
<<fblangref25-ddl-filter-drop-de>>

[[fblangref25-ddl-filter-drop-de]]
=== `DROP FILTER`

.Benutzt für
Entfernen einer ``BLOB``-Filterdeklaration aus der Datenbank

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP FILTER _filtername_
----

[[fblangref25-ddl-tbl-dropfiltr-de]]
.`DROP FILTER` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|filtername
|Filtername in der Datenbank
|===

Die Anweisung `DROP FILTER` entfernt die Deklaration eines ``BLOB``-Filters aus der Datenbank.
Wenn Sie einen ``BLOB``-Filter aus einer Datenbank entfernen, kann er für diese Datenbank nicht mehr verwendet werden.
Die dynamische Bibliothek, in der sich die Konvertierungsfunktion befindet, bleibt erhalten und das Entfernen aus einer Datenbank hat keine Auswirkungen auf andere Datenbanken, in denen derselbe ``BLOB``-Filter noch deklariert ist.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann einen BLOB-Filter löschen.

.Beispiel
Löschen eines ``BLOB``-Filters.

[source]
----
DROP FILTER DESC_FILTER;
----

.Siehe auch
<<fblangref25-ddl-filter-declare-de>>

[[fblangref25-ddl-sequence-de]]
== `SEQUENCE (GENERATOR)`

Eine Sequenz oder ein Generator ist ein Datenbankobjekt, das verwendet wird, um eindeutige Zahlenwerte zu erhalten, um eine Reihe zu füllen.
"`Sequenz`" ist der SQL-konforme Begriff für das gleiche Ding, das in Firebird traditionell als "`Generator`" bekannt ist.
Beide Begriffe sind in Firebird implementiert.
Für beide Terme ist eine Syntax implementiert.

Sequenzen (oder Generatoren) werden immer als 64-Bit-Ganzzahlen gespeichert, unabhängig vom SQL-Dialekt der Datenbank.

[CAUTION]
====
Wenn ein Client mit Dialekt 1 verbunden ist, sendet der Server Sequenzwerte als 32-Bit-Ganzzahlen an ihn.
Das Übergeben eines Sequenzwerts an ein 32-Bit-Feld oder eine Variable führt nicht zu Fehlern, solange der aktuelle Wert der Sequenz die Grenzen einer 32-Bit-Zahl nicht überschreitet.
Sobald jedoch der Sequenzwert diese Grenze überschreitet, erzeugt die Datenbank in Dialekt 3 einen Fehler.
Eine Datenbank in Dialekt 1 wird weiterhin die  Werte beschneiden, was die Einzigartigkeit der Serie beeinträchtigt.
====

In diesem Abschnitt wird beschrieben, wie Sequenzen erstellt, festgelegt und gelöscht werden.

[[fblangref25-ddl-sequence-create-de]]
=== `CREATE SEQUENCE (GENERATOR)`

.Benutzt für
Erstellen einer neuen `SEQUENCE` (`GENERATOR`)

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE {SEQUENCE | GENERATOR} _seq_name_
----

[[fblangref25-ddl-tbl-crtseq-de]]
.`CREATE SEQUENCE` | `CREATE GENERATOR` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|seq_name
|Name der Sequenz (Generator).
Diese kann aus bis zu 31 Zeichen bestehen
|===

Die Anweisungen `CREATE SEQUENCE` und `CREATE GENERATOR` sind Synonyme -- beide erzeugen eine neue Sequenz.
Jede kann verwendet werden, jedoch wird `CREATE SEQUENCE` empfohlen, sofern die normkonforme Metadatenverwaltung wichtig ist.

Wenn eine Sequenz erstellt wird, wird ihr Wert auf 0 gesetzt.
Jedes Mal, wenn der <<fblangref25-commons-conditional-nxtvlufor-de,`NEXT VALUE FOR seq_name`>> wird der Wert um 1 erhöht.
Die ``GEN_ID(seq_name, <step>)``-Funktion kann stattdessen aufgerufen werden, um die Reihe durch eine andere Ganzzahl zu erhöhen oder zu reduzieren.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Sequenz (Generator) erstellen.

.Beispiele
. Erstellen der ``EMP_NO_GEN``-Sequenz mittels `CREATE SEQUENCE`.
+
[source]
----
CREATE SEQUENCE EMP_NO_GEN;
----
. Erstellen der ``EMP_NO_GEN``-Sequenz mittels `CREATE GENERATOR`.
+
[source]
----
CREATE GENERATOR EMP_NO_GEN;
----

.Siehe auch
<<fblangref25-ddl-sequence-alter-de>>, <<fblangref25-ddl-sequence-setgen-de>>, <<fblangref25-ddl-sequence-drop-de>>, <<fblangref25-commons-conditional-nxtvlufor-de,`NEXT VALUE FOR`>>, <<fblangref25-functions-scalarfuncs-gen-id-de,`GEN_ID() function`>>

[[fblangref25-ddl-sequence-alter-de]]
=== `ALTER SEQUENCE`

.Benutzt für
Festlegen des Werts einer Sequenz oder eines Generators auf einen bestimmten Wert

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER SEQUENCE _seq_name_ RESTART WITH _new_val_
----

[[fblangref25-ddl-tbl-alterseq-de]]
.`ALTER SEQUENCE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|seq_name
|Name der Sequenz (Generator)

|new_val
|Neuer Sequenzwert (Generatorwert).
Eine 64-Bit-Ganzzahl von -2^-63^ bis 2^63^-1.
|===

Mit der Anweisung `ALTER SEQUENCE` wird der aktuelle Wert einer Sequenz oder eines Generators auf den angegebenen Wert gesetzt.

[WARNING]
====
Die falsche Verwendung der ``ALTER SEQUENCE``-Anweisung (Ändern des aktuellen Werts der Sequenz oder des Generators) kann die logische Integrität von Daten beeinträchtigen.
====

Jeder an die Datenbank angeschlossene Benutzer kann den Sequenzwert (Generator) festlegen.

.Beispiele
. Festlegen des Werts der ``EMP_NO_GEN``-Sequenz auf 145.
+
[source]
----
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
----
. Das gleiche Prozedere unter Verwendung von `SET GENERATOR`:
+
[source]
----
SET GENERATOR EMP_NO_GEN TO 145;
----

.Siehe auch
<<fblangref25-ddl-sequence-setgen-de>>, <<fblangref25-ddl-sequence-create-de>>, <<fblangref25-ddl-sequence-drop-de>>, <<fblangref25-commons-conditional-nxtvlufor-de,`NEXT VALUE FOR`>>, <<fblangref25-functions-scalarfuncs-gen-id-de,`GEN_ID() function`>>

[[fblangref25-ddl-sequence-setgen-de]]
=== `SET GENERATOR`

.Benutzt für
Festlegen des Werts einer Sequenz oder eines Generators auf einen bestimmten Wert

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
SET GENERATOR _seq_name_ TO _new_val_
----

[[fblangref25-ddl-tbl-setgen-de]]
.`SET GENERATOR` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|seq_name
|Name des Generators (Sequenz)

|new_val
|Neuer Sequenzwert (Generatorwert). Eine 64-Bit-Ganzzahl von -2^-63^ bis 2^63^-1.
|===

Mit der Anweisung `SET GENERATOR` wird der aktuelle Wert einer Sequenz oder eines Generators auf den angegebenen Wert gesetzt.

[NOTE]
====
Obwohl `SET GENERATOR` als veraltet gilt, wird es aus Gründen der Abwärtskompatibilität beibehalten.
Die standardkonforme Anweisung `ALTER SEQUENCE` ist aktuell und wird empfohlen.
====

Jeder an die Datenbank angeschlossene Benutzer kann den Sequenzwert (Generator) festlegen.

.Beispiele
. Einstellen des Werts der `EMP_NO_GEN`-Sequenz auf 145:
+
[source]
----
SET GENERATOR EMP_NO_GEN TO 145;
----
. Das gleiche Prozedere unter Verwendung von `ALTER SEQUENCE`:
+
[source]
----
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
----

.Siehe auch
<<fblangref25-ddl-sequence-alter-de>>, <<fblangref25-ddl-sequence-create-de>>

[[fblangref25-ddl-sequence-drop-de]]
=== `DROP SEQUENCE (GENERATOR)`

.Benutzt für
Löschen von `SEQUENCE` (`GENERATOR`)

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP {SEQUENCE | GENERATOR} _seq_name_
----

[[fblangref25-ddl-tbl-dropseq-de]]
.`DROP SEQUENCE` | `DROP GENERATOR` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|seq_name
|Name der Sequenz (Generator).
Kann aus bis zu 31 Zeichen bestehen.
|===

Die Anweisungen `DROP SEQUENCE` und `DROP GENERATOR` sind gleichwertig: Beide löschen eine vorhandene Sequenz (Generator).
Beide sind gültig, jedoch wird `DROP SEQUENCE` empfohlen.

Die Anweisungen schlagen fehl, wenn die Sequenz (Generator) Abhängigkeiten hat.

Jeder an die Datenbank angeschlossene Benutzer kann eine Sequenz (Generator) löschen.

.Beispiele
Löschen der ``EMP_NO_GEN``-Sequenz:

[source]
----
DROP SEQUENCE EMP_NO_GEN;
----

.Siehe auch
<<fblangref25-ddl-sequence-create-de>>, <<fblangref25-ddl-sequence-alter-de>>, <<fblangref25-ddl-sequence-setgen-de>>

[[fblangref25-ddl-exception-de]]
== `EXCEPTION`

In diesem Abschnitt wird beschrieben, wie [term]_benutzerdefinierte Ausnahmen_ zur Verwendung in Fehlerbehandlungsroutinen in PSQL-Modulen erstellt, geändert und gelöscht werden.

[[fblangref25-ddl-exception-create-de]]
=== `CREATE EXCEPTION`

.Benutzt für
Erstellen einer neuen Ausnahme für die Verwendung in PSQL-Modulen

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-crtexcep-de]]
.`CREATE EXCEPTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exception_name
|Name der Ausnahme.
Die maximale Länge beträgt 31 Zeichen

|message
|Standardfehlermeldung.
Die maximale Länge beträgt 1.021 Zeichen
|===

Die Anweisung `CREATE EXCEPTION` erstellt eine neue Ausnahme zur Verwendung in PSQL-Modulen.
Wenn eine Ausnahme desselben Namens existiert, schlägt die Anweisung mit einer entsprechenden Fehlermeldung fehl.

Der Name der Ausnahme ist eine Standardkennung.
In einer Dialekt 3-Datenbank kann sie in doppelte Anführungszeichen eingeschlossen werden, um Groß- und Kleinschreibung zu berücksichtigen und bei Bedarf Zeichen zu verwenden, die in regulären Bezeichnern nicht gültig sind.
Weitere Informationen finden Sie unter <<fblangref25-structure-identifiers-de,Bezeichner>>.

Die Standardnachricht wird im Zeichensatz `NONE` gespeichert, d.h. In Zeichen eines Einbytezeichensatzes.
Der Text kann im PSQL-Code überschrieben werden, wenn die Ausnahme ausgelöst wird.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahme erstellen.

.Beispiele
. Erstellen einer Ausnahme mit dem Namen `E_LARGE_VALUE`:
+
[source]
----
CREATE EXCEPTION E_LARGE_VALUE
  'The value is out of range';
----
. Erstellen einer Ausnahme mit dem Namen `ERROR_REFIN_RATE`:
+
[source]
----
CREATE EXCEPTION ERROR_REFIN_RATE
  'Error detected in the spread of discount rates';
----

.Tipps
[TIP]
====
Die Zusammenfassung von ``CREATE EXCEPTION``-Anweisungen in Systemaktualisierungsskripts vereinfacht die Arbeit mit ihnen und dokumentiert sie.
Ein System von Präfixen zum Benennen und Kategorisieren von Gruppen von Ausnahmen wird empfohlen. 

Benutzerdefinierte Ausnahmen werden in der Systemtabelle gespeichert <<fblangref-appx04-exceptions-de,`RDB$EXCEPTIONS`>>. 
====

.Siehe auch
<<fblangref25-ddl-exception-alter-de>>, <<fblangref25-ddl-exception-crtalter-de>>, <<fblangref25-ddl-exception-drop-de>>, <<fblangref25-ddl-exception-recreate-de>>

[[fblangref25-ddl-exception-alter-de]]
=== `ALTER EXCEPTION`

.Benutzt für
Ändern der Nachricht, die von einer benutzerdefinierten Ausnahme zurückgegeben wird

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-altrexcep-de]]
.`ALTER EXCEPTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exception_name
|Name der Ausnahme

|message
|Neue Standardfehlermeldung.
Die maximale Länge beträgt 1.021 Zeichen
|===

Die Anweisung `ALTER EXCEPTION` kann jederzeit verwendet werden, um den Standardtext der Nachricht zu ändern.
Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahmemeldung ändern.

.Beispiele
. Ändern der Standardnachricht für die Ausnahme `E_LARGE_VALUE`:
+
[source]
----
ALTER EXCEPTION E_LARGE_VALUE
  'The value exceeds the prescribed limit of 32,765 bytes';
----
. Ändern der Standardnachricht für die Ausnahme `ERROR_REFIN_RATE`:
+
[source]
----
ALTER EXCEPTION ERROR_REFIN_RATE
  'Rate is outside the allowed range';
----

.Siehe auch
<<fblangref25-ddl-exception-create-de>>, <<fblangref25-ddl-exception-crtalter-de>>, <<fblangref25-ddl-exception-drop-de>>, <<fblangref25-ddl-exception-recreate-de>>

[[fblangref25-ddl-exception-crtalter-de]]
=== `CREATE OR ALTER EXCEPTION`

.Benutzt für
Ändern der Nachricht, die von einer benutzerdefinierten Ausnahme zurückgegeben wird, wenn die Ausnahme existiert;
andernfalls erstellen Sie eine neue Ausnahme

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-crtaltrexcep-de]]
.`CREATE OR ALTER EXCEPTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exception_name
|Name der Ausnahme

|message
|Fehlermeldung.
Die maximale Länge ist auf 1.021 Zeichen begrenzt
|===

Die Anweisung `CREATE OR ALTER EXCEPTION` wird verwendet, um die angegebene Ausnahme zu erstellen, falls sie nicht existiert, oder um den Text der von ihr zurückgegebenen Fehlermeldung zu ändern.
Wenn eine vorhandene Ausnahme durch diese Anweisung geändert wird, bleiben vorhandene Abhängigkeiten erhalten.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann diese Anweisung verwenden, um eine Ausnahme zu erstellen oder den bereits vorhandenen Text zu ändern.

.Beispiel
Nachricht für die Ausnahme ändern `E_LARGE_VALUE`:

[source]
----
CREATE OR ALTER EXCEPTION E_LARGE_VALUE
  'The value is higher than the permitted range 0 to 32,765';
----

.Siehe auch
<<fblangref25-ddl-exception-create-de>>, <<fblangref25-ddl-exception-alter-de>>, <<fblangref25-ddl-exception-recreate-de>>

[[fblangref25-ddl-exception-drop-de]]
=== `DROP EXCEPTION`

.Benutzt für
Löschen einer benutzerdefinierten Ausnahme

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP EXCEPTION _exception_name_
----

[[fblangref25-ddl-tbl-dropexcep-de]]
.`DROP EXCEPTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exception_name
|Name der Ausnahme
|===

Die Anweisung `DROP EXCEPTION` wird zum Löschen einer Ausnahme verwendet.
Alle Abhängigkeiten von der Ausnahme führen dazu, dass die Anweisung fehlschlägt und nicht gelöscht wird.

Wenn eine Ausnahme nur in gespeicherten Prozeduren verwendet wird, kann sie jederzeit gelöscht werden.
Wenn es in einem Auslöser verwendet wird, kann es nicht gelöscht werden.

Bei der Planung, eine Ausnahme zu löschen, sollten alle Verweise darauf aus dem Code der gespeicherten Prozeduren entfernt werden, um zu vermeiden, dass die Abwesenheit Fehler verursacht.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahme löschen.

.Beispiele
. Ausnahme löschen `ERROR_REFIN_RATE`:
+
[source]
----
DROP EXCEPTION ERROR_REFIN_RATE;
----
. Ausnahme löschen `E_LARGE_VALUE`:
+
[source]
----
DROP EXCEPTION E_LARGE_VALUE;
----

.Siehe auch
<<fblangref25-ddl-exception-create-de>>, <<fblangref25-ddl-exception-recreate-de>>

[[fblangref25-ddl-exception-recreate-de]]
=== `RECREATE EXCEPTION`

.Benutzt für
Eine neue benutzerdefinierte Ausnahme oder eine bestehende erstellen

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-recrtexcep-de]]
.`RECREATE EXCEPTION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exception_name
|Name der Ausnahme.
Die maximale Länge beträgt 31 Zeichen

|message
|Fehlermeldung.
Die maximale Länge ist auf 1.021 Zeichen begrenzt
|===

Die Anweisung `RECREATE EXCEPTION` erstellt eine neue Ausnahme für die Verwendung in PSQL-Modulen.
Wenn bereits eine Exception mit demselben Namen existiert, versucht die Anweisung `RECREATE EXCEPTION`, diese zu löschen und eine neue zu erstellen.
Wenn es Abhängigkeiten zur bestehenden Ausnahme gibt, schlägt die versuchte Löschung fehl und `RECREATE EXCEPTION` wird nicht ausgeführt.

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Ausnahme erstellen.

.Beispiel
Wiederherstellen der Ausnahme `E_LARGE_VALUE`:

[source]
----
RECREATE EXCEPTION E_LARGE_VALUE
  'The value exceeds its limit';
----

.Siehe auch
<<fblangref25-ddl-exception-create-de>>, <<fblangref25-ddl-exception-drop-de>>, <<fblangref25-ddl-exception-crtalter-de>>

[[fblangref25-ddl-collation-de]]
== `COLLATION`

[[fblangref25-ddl-collation-create-de]]
=== `CREATE COLLATION`

.Benutzt für
Erstellen einer neuen Sortierung für einen unterstützten Zeichensatz, der für die Datenbank verfügbar ist

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE COLLATION _collname_
    FOR _charset_
    [FROM _basecoll_ | FROM EXTERNAL ('_extname_')]
    [NO PAD | PAD SPACE]
    [CASE [IN]SENSITIVE]
    [ACCENT [IN]SENSITIVE]
    ['<specific-attributes>']

<specific-attributes> ::= <attribute> [; <attribute> ...]

<attribute> ::= _attrname_=_attrvalue_
----

[[fblangref25-ddl-tbl-collatcrt-de]]
.`CREATE COLLATION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|collname
|Der Name, der für die neue Collation verwendet werden soll.
Die maximale Länge beträgt 31 Zeichen

|charset
|Ein in der Datenbank vorhandener Zeichensatz

|basecoll
|Eine bereits in der Datenbank vorhandene Collation

|extname
|Der in der Datei `.conf` verwendete Collation-Name
|===

Die Anweisung `CREATE COLLATION` "`erzeugt`" nichts: Sie dient dazu, eine Datenbank-Collation bekannt zu machen.
Die Collation muss bereits auf dem System vorhanden sein, normalerweise in einer Bibliotheksdatei und muss ordnungsgemäß in einer `.conf`-Datei im Unterverzeichnis `intl` der Firebird-Installation registriert sein.

Die Collation kann alternativ auf einer basieren, die bereits in der Datenbank vorhanden ist.

[[fblangref25-ddl-collation-createhow-de]]
==== Wie die Engine die Collation erkennt

Wenn keine ``FROM``-Klausel vorhanden ist, scannt Firebird die ``.conf``-Dateien im ``intl``-Unterverzeichnis nach einer Collation mit dem Namen, der als Objekt mit `CREATE COLLATION` gesetzt wurde.
Anders ausgedrückt, das Weglassen der ``FROM basecoll``-Klausel entspricht der Angabe von `FROM EXTERNAL ('collname')`.

Bei der Angabe von _extname_ muss die Groß- / Kleinschreibung beachtet werden und sie muss genau mit dem Collations-Namen in der Datei `.conf` übereinstimmen.
Bei den Parametern _collname_, _charset_ und  _basecoll_ wird zwischen Groß- und Kleinschreibung unterschieden, sofern sie nicht in doppelten Anführungszeichen eingeschlossen sind.

[[fblangref25-ddl-collation-specatt-de]]
==== Spezifische Attribute

Die verfügbaren spezifischen Attribute sind in der folgenden Tabelle aufgeführt.
Nicht alle spezifischen Attribute gelten für jede Collation auch wenn sie nicht durch einen Fehler verursacht werden.

[IMPORTANT]
====
Spezifische Attribute unterscheiden Groß- und Kleinschreibung.
====

In der Tabelle zeigt "`1 bpc`" an, dass ein Attribut für Collationen von Zeichensätzen mit 1 Byte pro Zeichen (sogenannte enge Zeichensätze) gültig ist.
 "`UNI`" steht für "`UNICODE Collationen`".

[[fblangref25-ddl-tbl-specific-colls-de]]
.Spezifische Collations-Attribute
[cols="<2,<1,<1,<3", options="header"]
|===
^| Atrribute
^| Wert
^| Gültig für
^| Kommentar

|`DISABLE-COMPRESSIONS`
|`0`, `1`
|1 bpc
|Deaktiviert Komprimierungen (a.k.a. Kontraktionen).
Komprimierungen bewirken, dass bestimmte Zeichenfolgen als atomare Einheiten sortiert werden, z.B. spanisch c + h als einzelner Buchstabe ch

|`DISABLE-EXPANSIONS`
|`0`, `1`
|1 bpc
|Deaktiviert Erweiterungen.
Erweiterungen bewirken, dass bestimmte Zeichen (z. B. Ligaturen oder umlautete Vokale) als Zeichenfolgen behandelt und entsprechend sortiert werden

|`ICU-VERSION`
|default oder H.U
|UNI
|Gibt die zu verwendende ICU-Bibliotheksversion an.
Gültige Werte sind diejenigen, die im anwendbaren Element <intl_module> in `intl/fbintl.conf`.
Format: entweder das Stringliteral "`default`" oder eine Hauptversion + Unterversion wie "`3.0`" (beide nicht angegeben).

|`LOCALE`
|xx_YY
|UNI
|Gibt das Sortierungskriterium an.
Benötigt eine vollständige Version von ICU-Bibliotheken.
Format: eine Gebietsschema-Zeichenfolge wie "`du_NL`" (nicht angegeben)

|`MULTI-LEVEL`
|`0`, `1`
|1 bpc
|Verwendet mehr als eine Sortierebene

|`NUMERIC-SORT`
|`0`, `1`
|UNI
|Behandelt zusammenhängende Gruppen von Dezimalziffern in der Zeichenfolge als atomare Einheiten und sortiert sie numerisch.
(Dies ist auch als natürliche Sortierung bekannt)

|`SPECIALS-FIRST`
|`0`, `1`
|1 bpc
|Ordnet Sonderzeichen (Leerzeichen, Symbole etc.) vor alphanumerischen Zeichen
|===

[TIP]
====
Deklarieren Sie die gespeicherte Prozedur `sp_register_character_set (name, max_bytes_per_character)`, die Sie in `misc/ intl.sql` im Firebird-Installationsverzeichnis.

Damit dies funktioniert, muss der Zeichensatz auf dem System vorhanden und in einer `.conf` im Unterverzeichnis `intl` liegen.
====

Jeder Benutzer, der mit der Datenbank verbunden ist, kann `CREATE COLLATION` verwenden, um eine neue Collation hinzuzufügen.

==== Beispiele für die Verwendung von `CREATE COLLATION`

. Erstellen einer Collation mit dem in der Datei `fbintl.conf` enthaltenen Namen (Groß- und Kleinschreibung beachten).
+
[source]
----
CREATE COLLATION ISO8859_1_UNICODE FOR ISO8859_1;
----
. Erstellen einer Collation, mithilfe eines speziellen (benutzerdefinierten) Namens (der "`externe`" Name muss vollständig mit dem Namen in der Datei `fbintl.conf` übereinstimmen).
+
[source]
----
CREATE COLLATION LAT_UNI
  FOR ISO8859_1
  FROM EXTERNAL ('ISO8859_1_UNICODE');
----
. Erstellen einer Collation, die Groß- und Kleinschreibung nicht berücksichtigt und auf einer bereits in der Datenbank vorhandenen basiert.
+
[source]
----
CREATE COLLATION ES_ES_NOPAD_CI
  FOR ISO8859_1
  FROM ES_ES
  NO PAD
  CASE INSENSITIVE;
----
. Erstellen einer Collation, die Groß- und Kleinschreibung nicht berücksichtigt und auf einer bereits in der Datenbank vorhandenen basiert.
Angabe spezifischer Attribute.
+
[source]
----
CREATE COLLATION ES_ES_CI_COMPR
  FOR ISO8859_1
  FROM ES_ES
  CASE INSENSITIVE
  'DISABLE-COMPRESSIONS=0';
----
. Erstellen einer Collation, die Groß- und Kleinschreibung nicht berücksichtigt durch Verwendung von Zahlen (die sogenannte natürliche Collation).
+
[source]
----
CREATE COLLATION nums_coll FOR UTF8
  FROM UNICODE
  CASE INSENSITIVE 'NUMERIC-SORT=1';

CREATE DOMAIN dm_nums AS varchar(20)
  CHARACTER SET UTF8 COLLATE nums_coll; -- original (manufacturer) numbers

CREATE TABLE wares(id int primary key, articul dm_nums ...);
----

.Siehe auch
<<fblangref25-ddl-collation-drop-de>>

[[fblangref25-ddl-collation-drop-de]]
=== `DROP COLLATION`

.Benutzt für
Löschen einer Collation aus der Datenbank

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
DROP COLLATION _collname_
----

[[fblangref25-ddl-tbl-collatdrp-de]]
.`DROP COLLATION` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|collname
|Name der Collation
|===

Die Anweisung `DROP COLLATION` entfernt die angegebene Collation aus der Datenbank, falls vorhanden.
Ein Fehler wird ausgelöst, wenn die angegebene Collation nicht vorhanden ist.

[TIP]
====
Deklarieren und führen Sie die gespeicherte Prozedur `sp_unregister_character_set (name)` aus dem Unterverzeichnis  `misc/intl.sql` der Firebird-Installation aus, wenn Sie einen ganzen Zeichensatz mit allen Collationen aus der Datenbank entfernen möchten.
====

Jeder Benutzer, der mit der Datenbank verbunden ist, kann `DROP COLLATION` verwenden, um eine Collation zu entfernen.

.Beispiele für die Verwendung von `DROP COLLATION`
Löschen der ``ES_ES_NOPAD_CI``-Collation.

[source]
----
DROP COLLATION ES_ES_NOPAD_CI;
----

.Siehe auch
<<fblangref25-ddl-collation-create-de>>

[[fblangref25-ddl-charset-de]]
== `CHARACTER SET`

[[fblangref25-ddl-charset-alter-de]]
=== `ALTER CHARACTER SET`

.Benutzt für
Festlegen der Standardsortierung für einen Zeichensatz

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER CHARACTER SET _charset_
  SET DEFAULT COLLATION _collation_
----

[[fblangref25-ddl-tbl-charsetalter-de]]
.`ALTER CHARACTER SET` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|charset
|Zeichensatzkennung

|collation
|Der Name der Sortierung
|===

Die Anweisung `ALTER CHARACTER SET` ändert die Standardsortierung für den angegebenen Zeichensatz.
Dies wirkt sich auf die zukünftige Verwendung des Zeichensatzes aus, mit Ausnahme der Fälle, in denen die ``COLLATE``-Klausel explizit überschrieben wird.
In diesem Fall bleibt die Sortierreihenfolge bestehender Domainn, Spalten und PSQL-Variablen nach der Änderung der Standardsortierung des zugrunde liegenden Zeichensatzes erhalten.

.Hinweise
[NOTE]
====
Wenn Sie die Standardsortierung für den Datenbankzeichensatz ändern (die beim Erstellen der Datenbank definiert wurde), wird die Standardsortierung für die Datenbank geändert.

Wenn Sie die Standardsortierung für den Zeichensatz ändern, der während der Verbindung angegeben wurde, werden Stringkonstanten gemäß dem neuen Sortierungswert interpretiert, außer in den Fällen, in denen der Zeichensatz und / oder die Collation überschrieben wurde.
====

.Beispiel zur Verwendung
Festlegen der Standard-``UNICODE_CI_AI``-Sortierung für die ``UTF8``-Codierung.

[source]
----
ALTER CHARACTER SET UTF8
  SET DEFAULT COLLATION UNICODE_CI_AI;
----

[[fblangref25-ddl-role-de]]
== `ROLE`

Eine Rolle ist ein Datenbankobjekt, das eine Reihe <<fblangref25-security-privs-de,SQL-Berechtigungen>> paketiert.
Rollen implementieren das Konzept der Zugriffskontrolle auf Gruppenebene.
Der Rolle werden mehrere Berechtigungen erteilt, und diese Rolle kann einem oder mehreren Benutzern gewährt oder widerrufen werden.

Ein Benutzer, dem eine Rolle zugewiesen wurde, muss diese Rolle in seinen Anmeldeinformationen bereitstellen, um die zugehörigen Berechtigungen auszuüben.
Alle anderen Berechtigungen, die dem Benutzer gewährt werden, sind von seiner Anmeldung mit der Rolle nicht betroffen.
Die gleichzeitige Anmeldung mit mehreren Rollen wird nicht unterstützt.

In diesem Abschnitt werden die Aufgaben zum Erstellen und Löschen von Rollen besprochen.

[[fblangref25-ddl-createrole-de]]
=== `CREATE ROLE`

.Benutzt für
Erstellen eines neuen ``ROLE``-Objektes

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE ROLE _rolename_
----

[[fblangref25-ddl-tbl-createrole-de]]
.`CREATE ROLE` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|rolename
|Rollenname.
Die maximale Länge beträgt 31 Zeichen
|===

Die Anweisung `CREATE ROLE` erstellt ein neues Rollenobjekt, dem später ein oder mehrere Berechtigungen erteilt werden können.
Der Name einer Rolle muss unter den Namen der Rollen in der aktuellen Datenbank eindeutig sein.

[WARNING]
====
Es ist ratsam, den Namen einer Rolle auch unter den Benutzernamen eindeutig zu machen.
Das System verhindert nicht die Erstellung einer Rolle, deren Name mit einem vorhandenen Benutzernamen kollidiert.
Wenn dies der Fall ist, kann der Benutzer keine Verbindung zur Datenbank herstellen.
====

Jeder Benutzer, der mit der Datenbank verbunden ist, kann eine Rolle erstellen.
Der Benutzer, der eine Rolle erstellt, wird zu seinem Besitzer.

.Beispiel
Erstellen einer Rolle `SELLERS`:

[source]
----
CREATE ROLE SELLERS;
----

.Siehe auch
<<fblangref25-ddl-droprole-de>>, <<fblangref25-security-privs-grant-de,`GRANT`>>, <<fblangref25-security-privs-revoke-de,`REVOKE`>>

[[fblangref25-ddl-alterrole]]
=== `ALTER ROLE`

`ALTER ROLE` hat keinen Platz im create-alter-drop-Paradigma für Datenbankobjekte, da eine Rolle keine Attribute besitzt, die geändert werden können.
Sein tatsächlicher Effekt besteht darin, ein Attribut der Datenbank zu ändern: Firebird verwendet es, um die Fähigkeit von Windows Adminstratoren zu aktivieren und zu deaktivieren, beim Anmelden automatisch <<fblangref25-security-administrators-de,Administratorrechte>> zu erhalten.

Diese Prozedur trifft nur auf eine Rolle zu: Die systemgenerierte Rolle `RDB$ADMIN`, die in jeder Datenbank von ODS 11.2 oder höher vorhanden ist.
Bei der Aktivierung dieser Funktion sind mehrere Faktoren beteiligt.

Für weitere Details, siehe <<fblangref25-security-autoadminmapping-de,[ref]_AUTO ADMIN MAPPING_>> im Kapitel [ref]_Sicherheit_.

[[fblangref25-ddl-droprole-de]]
=== `DROP ROLE`

.Benutzt für
Löschen einer Rolle

.Verfügbar in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP ROLE _rolename_
----

Die Anweisung `DROP ROLE` löscht eine vorhandene Rolle.
Es braucht nur ein einziges Argument, den Namen der Rolle.
Sobald die Rolle gelöscht wurde, wird der gesamte Berechtigungssatz von allen Benutzern und Objekten, denen die Rolle gewährt wurde, widerrufen.

Eine Rolle kann vom Eigentümer gelöscht oder von einem <<fblangref25-security-administrators-de,Administrator>>.

.Beispiel
Löschen der Rolle `SELLERS`:

[source]
----
DROP ROLE SELLERS;
----

.Siehe auch
<<fblangref25-ddl-createrole-de>>, <<fblangref25-security-privs-grant-de,`GRANT`>>, <<fblangref25-security-privs-revoke-de,`REVOKE`>>

[[fblangref25-ddl-comment-de]]
== `COMMENTS`

Datenbankobjekte und eine Datenbank selbst können Kommentare enthalten.
Es ist ein bequemer Mechanismus zur Dokumentation der Entwicklung und Pflege einer Datenbank.
Kommentare, die mit `COMMENT ON` erstellt wurden, überstehen eine __gbak__-Sicherung und -Wiederherstellung.

[[fblangref25-ddl-comment-create-de]]
=== `COMMENT ON`

.Benutzt für
Documentation von Metadaten

.Verfügbar in
DSQL

.Syntax
[listing,subs=+quotes]
----
COMMENT ON <object> IS {'_sometext_' | NULL}

<object> ::=
    DATABASE
  | <basic-type> _objectname_
  | COLUMN _relationname_._fieldname_
  | PARAMETER _procname_._paramname_

<basic-type> ::=
    CHARACTER SET
  | COLLATION
  | DOMAIN
  | EXCEPTION
  | EXTERNAL FUNCTION
  | FILTER
  | GENERATOR
  | INDEX
  | PROCEDURE
  | ROLE
  | SEQUENCE
  | TABLE
  | TRIGGER
  | VIEW
----

[[fblangref25-ddl-tbl-commenton-de]]
.`COMMENT ON` Statement-Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|sometext
|Kommentartext

|basic-type
|Metadatenobjekttyp

|objectname
|Name des Metadatenobjekts

|relationname
|Name der Tabelle oder View

|procname
|Name der Stored Procedure

|paramname
|Name des Stored Procedure Parameters
|===

Die Anweisung `COMMENT ON` fügt Kommentare zu Datenbankobjekten (Metadaten) hinzu.
Kommentare werden in Textfeldern des Typs `BLOB` in der Spalte `RDB$DESCRIPTION` der entsprechenden Systemtabellen gespeichert.
Clientanwendungen können Kommentare aus diesen Feldern anzeigen. 

[NOTE]
====
Wenn Sie einen leeren Kommentar ("```''```") hinzufügen, wird dieser als `NULL` in der Datenbank gespeichert.
====

Der Eigentümer der Tabelle oder Prozedur und <<fblangref25-security-administrators-de,Administratoren>> haben die notwendigen Berechtigungen die Anweisung `COMMENT ON` zu verwenden.

.Beispiele zur Verwendung von `COMMENT ON`
. Einen Kommentar für die aktuelle Datenbank hinzufügen
+
[source]
----
COMMENT ON DATABASE IS 'It is a test (''my.fdb'') database';
----
. Einen Kommentar für die ``METALS``-Tabelle hinzufügen
+
[source]
----
COMMENT ON TABLE METALS IS 'Metal directory';
----
. Hinzufügen eines Kommentars zum Feld `ISALLOY` in der ``METALS``-Tabelle
+
[source]
----
COMMENT ON COLUMN METALS.ISALLOY IS '0 = fine metal, 1 = alloy';
----
. Einen Kommentar für einen Parameter hinzufügen
+
[source]
----
COMMENT ON PARAMETER ADD_EMP_PROJ.EMP_NO IS 'Employee ID';
----
