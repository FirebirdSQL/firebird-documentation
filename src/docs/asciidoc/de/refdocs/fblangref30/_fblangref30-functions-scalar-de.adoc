[[fblangref30-functions-de]]
= Eingebaute Skalarfunktionen

[[fblangref30-functions-nameclashes-de]]
.Upgrader: BITTE LESEN!
****
Eine große Anzahl von Funktionen, die in früheren Versionen von Firebird als externe Funktionen (UDFs) implementiert wurden, wurden schrittweise als interne (eingebaute) Funktionen neu implementiert.
Wenn eine externe Funktion mit dem gleichen Namen wie eine integrierte Funktion in Ihrer Datenbank deklariert ist,  bleibt sie dort und überschreibt alle internen Funktionen desselben Namens.

Um die internen Funktionen verfügbar sind, müssen Sie entweder ein <<fblangref30-ddl-extfunc-drop-de,`DROP`>> der UDF durchführen oder mittels <<fblangref30-ddl-extfunc-alter-de,`ALTER EXTERNAL FUNCTION`>> den Namen der UDF ändern.
****

[[fblangref30-functions-workcontext-de]]
== Kontextfunktionen

[[fblangref30-scalarfuncs-get-context-de]]
=== `RDB$GET_CONTEXT()`

.Verfügbar in
DSQL, PSQL{nbsp}* Als deklariertes UDF sollte es in ESQL verfügbar sein

.Ergebnistyp
`VARCHAR(255)`

.Syntax
[listing,subs=+quotes]
----
RDB$GET_CONTEXT ('<namespace>', <varname>)

<namespace> ::= SYSTEM | USER_SESSION | USER_TRANSACTION | DDL_TRIGGER
<varname>   ::= Eine Zeichenfolge in Anführungszeichen von max. 80 Zeichen
----

[[fblangref30-funcs-tbl-rdbgetcontext-de]]
.`RDB$GET_CONTEXT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|namespace
|Namespace

|varname
|Variablenname.
Groß-/Kleinschreibung beachten.
Die maximale Länge beträgt 80 Zeichen
|===

Retrieves the value of a context variable from one of the namespaces `SYSTEM`, `USER_SESSION` and `USER_TRANSACTION`.

.Die Namensräume
Die Namensräume `USER_SESSION` und `USER_TRANSACTION` sind zunächst leer.
Der Benutzer kann mit `RDB$SET_CONTEXT()` Variablen darin erstellen und setzen und mit `RDB$GET_CONTEXT()` abrufen.
Der Namespace `SYSTEM` ist schreibgeschützt.
Der Namespace `DDL_TRIGGER` ist nur in DDL-Triggern gültig und schreibgeschützt.
Es enthält eine Reihe vordefinierter Variablen (siehe unten).

.Rückgabewerte und Fehlerverhalten
Existiert die abgefragte Variable im angegebenen Namespace, wird ihr Wert als String von max. 255 Zeichen.
Existiert der Namespace nicht oder versucht man auf eine nicht vorhandene Variable im `SYSTEM`-Namespace zuzugreifen, wird ein Fehler ausgegeben.
Wenn Sie eine nicht vorhandene Variable in einem der anderen Namespaces anfordern, wird `NULL` zurückgegeben.
Sowohl Namespace- als auch Variablennamen müssen in einfachen Anführungszeichen angegeben werden, wobei die Groß-/Kleinschreibung beachtet werden muss, nicht ``NULL``-Strings.

[[fblangref30-funcs-tbl-rdbgetcontext-system-de]]
==== The `SYSTEM` Namespace

[[fblangref30-funcs-tbl-systemnamespace-de]]
.Kontextvariablen im SYSTEM-Namensraum

`CLIENT_ADDRESS`::
Für TCPv4 ist dies die IP-Adresse.
Für XNET die lokale Prozess-ID.
Für alle anderen Protokolle ist diese Variable `NULL`.

`CURRENT_ROLE`::
Wie die globale Variable <<fblangref30-contextvars-current-role-de>>.

`CURRENT_USER`::
Same als globale Variable <<fblangref30-contextvars-current-user-de>>.

`DB_NAME`::
Entweder der vollständige Pfad zur Datenbank oder – falls eine Verbindung über den Pfad nicht erlaubt ist – ihr Alias.

`ENGINE_VERSION`::
Die Firebird-Engine (Server)-Version.

`ISOLATION_LEVEL`::
Die Isolationsstufe der aktuellen Transaktion: `'READ COMMITTED'`, `'SNAPSHOT'` oder `'CONSISTENCY'`.

`NETZWERK_PROTOKOLL`::
Das für die Verbindung verwendete Protokoll: `'TCPv4'`, `'WNET'`, `'XNET'` oder `NULL`.

`SESSION_ID`::
Entspricht der globalen Variable <<fblangref30-contextvars-current-connection-de>>.

`TRANSACTION_ID`::
Wie die globale Variable <<fblangref30-contextvars-current-transaction-de>>.

`WIRE_COMPRESSED`::
Komprimierungsstatus der aktuellen Verbindung.
Wenn die Verbindung komprimiert ist, wird `TRUE` zurückgegeben;
wenn es nicht komprimiert ist, wird `FALSE` zurückgegeben.
Gibt `NULL` zurück, wenn die Verbindung eingebettet ist.
+
Eingeführt in Firebird 3.0.4.

`WIRE_ENCRYPTED`::
Verschlüsselungsstatus der aktuellen Verbindung.
Wenn die Verbindung verschlüsselt ist, wird `TRUE` zurückgegeben;
wenn es nicht verschlüsselt ist, wird `FALSE` zurückgegeben.
Gibt `NULL` zurück, wenn die Verbindung eingebettet ist.
+
Eingeführt in Firebird 3.0.4.

[[fblangref30-funcs-tbl-rdbgetcontext-ddl-trigger-de]]
==== Der `DDL_TRIGGER`-Namespace

Der Namespace `DDL_TRIGGER` ist nur gültig, wenn ein DDL-Trigger ausgeführt wird.
Seine Verwendung ist auch in gespeicherten Prozeduren und Funktionen gültig, die von DDL-Triggern aufgerufen werden.

Der Kontext `DDL_TRIGGER` funktioniert wie ein Stack.
Bevor ein DDL-Trigger ausgelöst wird, werden die Werte relativ zum ausgeführten Befehl auf diesen Stack gelegt.
Nach Abschluss des Triggers werden die Werte ausgegeben.
Wenn also im Fall von kaskadierten DDL-Anweisungen ein Benutzer-DDL-Befehl einen DDL-Trigger auslöst und dieser Trigger einen anderen DDL-Befehl mit `EXECUTE STATEMENT` ausführt, sind die Werte des `DDL_TRIGGER`-Namensraums diejenigen relativ zu dem Befehl, der den letzten ausgelöst hat DDL-Trigger in der Aufrufliste.

.Kontextvariablen im DDL_TRIGGER-Namespace
`EVENT_TYPE`:: Ereignistyp (`CREATE`, `ALTER`, `DROP`)
`OBJECT_TYPE`:: Objekttyp (`TABLE`, `VIEW`, etc)
`DDL_EVENT`:: Ereignisname (`<ddl event item>`), wobei `<ddl_event_item>` `EVENT_TYPE || . ist ' ' || OBJECT_TYPE`
`OBJECT_NAME`:: Name des Metadatenobjekts
`OLD_OBJECT_NAME`:: zum Nachverfolgen der Umbenennung einer Domain (siehe Hinweis)
`NEW_OBJECT_NAME`:: zum Nachverfolgen der Umbenennung einer Domain (siehe Hinweis)
`SQL_TEXT`:: SQL-Anweisungstext

[NOTE]
====
`ALTER DOMAIN __old-name__ TO __new-name__` setzt `OLD_OBJECT_NAME` und `NEW_OBJECT_NAME` sowohl in den `BEFORE`- als auch `AFTER`-Triggern.
Für diesen Befehl hat `OBJECT_NAME` den alten Objektnamen in `BEFORE` Triggern und den neuen Objektnamen in `AFTER` Triggern.
====

[[fblangref30-funcs-tbl-rdbgetcontext-exmpl-de]]
==== Beispiele

[source]
----
select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database

New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');

insert into MyTable (TestField)
  values (rdb$get_context('USER_SESSION', 'MyVar'))
----

.Siehe auch
<<fblangref30-scalarfuncs-set-context-de>>

[[fblangref30-scalarfuncs-set-context-de]]
=== `RDB$SET_CONTEXT()`

.Verfügbar in
DSQL, PSQL{nbsp}* Als deklariertes UDF sollte es in ESQL verfügbar sein

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
RDB$SET_CONTEXT ('<namespace>', <varname>, <value> | NULL)

<namespace> ::= USER_SESSION | USER_TRANSACTION
<varname>   ::= Eine Zeichenfolge in Anführungszeichen von max. 80 Zeichen
<value>     ::= _Ein Wert beliebiger Art, solange er umsetzbar ist_
                _zu einem VARCHAR(255)_
----

[[fblangref30-funcs-tbl-rdbsetcontext-de]]
.`RDB$SET_CONTEXT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|namespace
|Namespace

|varname
|Variablenname.
Groß-/Kleinschreibung beachten.
Die maximale Länge beträgt 80 Zeichen

|value
|Daten eines beliebigen Typs, sofern sie in `VARCHAR(255)` umgewandelt werden können
|===

Erstellt, setzt oder hebt eine Variable in einem der vom Benutzer beschreibbaren Namensräume `USER_SESSION` und `USER_TRANSACTION` auf.

.Die Namensräume
Die Namensräume `USER_SESSION` und `USER_TRANSACTION` sind zunächst leer.
Der Benutzer kann mit `RDB$SET_CONTEXT()` Variablen darin erstellen und setzen und mit `RDB$GET_CONTEXT()` abrufen.
Der Kontext `USER_SESSION` ist an die aktuelle Verbindung gebunden.
Variablen in `USER_TRANSACTION` existieren nur in der Transaktion, in der sie gesetzt wurden.
Wenn die Transaktion endet, werden der Kontext und alle darin definierten Variablen zerstört.

.Rückgabewerte und Fehlerverhalten
Die Funktion gibt `1` zurück, wenn die Variable bereits vor dem Aufruf existierte und `0` wenn dies nicht der Fall war.
Um eine Variable aus einem Kontext zu entfernen, setzen Sie sie auf `NULL`.
Wenn der angegebene Namespace nicht existiert, wird ein Fehler ausgegeben.
Sowohl Namensraum- als auch Variablennamen müssen in einfachen Anführungszeichen eingegeben werden, wobei die Groß-/Kleinschreibung beachtet werden muss, nicht ``NULL``-Zeichenfolgen.

[NOTE]
====
* Die maximale Anzahl von Variablen in einem einzelnen Kontext beträgt 1000.
* Alle `USER_TRANSACTION`-Variablen überleben ein <<fblangref30-transacs-rollback-options-de,`ROLLBACK RETAIN`>> (siehe `ROLLBACK`-Optionen) oder <<fblangref30-transacs-rollback-tosavepoint-de,`ROLLBACK TO SAVEPOINT`>> unverändert, egal zu welchem Zeitpunkt der Transaktion sie gesetzt wurden.
* Aufgrund seiner UDF-ähnlichen Natur kann `RDB$SET_CONTEXT` -- nur in PSQL -- wie eine void-Funktion aufgerufen werden, ohne das Ergebnis zuzuweisen, wie im zweiten Beispiel oben.
Reguläre interne Funktionen erlauben diese Art der Nutzung nicht.
====

.Beispiele
[source]
----
select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database

rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);

select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
  from rdb$database
----

.Siehe auch
<<fblangref30-scalarfuncs-get-context-de>>

[[fblangref30-functions-math-de]]
== Mathematische Funktionen

[[fblangref30-scalarfuncs-abs-de]]
=== `ABS()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
Numerisch

.Syntax
[listing,subs=+quotes]
----
ABS (_number_)
----

[[fblangref30-funcs-tbl-abs-de]]
.`ABS`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den absoluten Wert des Arguments zurück.

[[fblangref30-scalarfuncs-acos-de]]
=== `ACOS()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ACOS (_number_)
----

[[fblangref30-funcs-tbl-acos-de]]
.`ACOS`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs im Bereich [-1, 1]
|===

Gibt den Arkuskosinus des Arguments zurück.

* Das Ergebnis ist ein Winkel im Bereich [0, pi].

.Siehe auch
<<fblangref30-scalarfuncs-cos-de>>, <<fblangref30-scalarfuncs-asin-de>>, <<fblangref30-scalarfuncs-atan-de>>

[[fblangref30-scalarfuncs-acosh-de]]
=== `ACOSH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ACOSH (_number_)
----

[[fblangref30-funcs-tbl-acosh-de]]
.`ACOSH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Jeder Nicht-``NULL``-Wert im Bereich [1, INF].
|===

Gibt den inversen hyperbolischen Kosinus des Arguments zurück.

* Das Ergebnis liegt im Bereich [0, INF].

.Siehe auch
<<fblangref30-scalarfuncs-cosh-de>>, <<fblangref30-scalarfuncs-asinh-de>>, <<fblangref30-scalarfuncs-atanh-de>>

[[fblangref30-scalarfuncs-asin-de]]
=== `ASIN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ASIN (_number_)
----

[[fblangref30-funcs-tbl-asin-de]]
.`ASIN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs im Bereich [-1, 1]
|===

Gibt den Arkussinus des Arguments zurück.

* Das Ergebnis ist ein Winkel im Bereich [-pi/2, pi/2].

.Siehe auch
<<fblangref30-scalarfuncs-sin-de>>, <<fblangref30-scalarfuncs-acos-de>>, <<fblangref30-scalarfuncs-atan-de>>

[[fblangref30-scalarfuncs-asinh-de]]
=== `ASINH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ASINH (_number_)
----

[[fblangref30-funcs-tbl-asinh-de]]
.`ASINH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Jeder Nicht-``NULL``-Wert im Bereich [-INF, INF].
|===

Gibt den inversen hyperbolischen Sinus des Arguments zurück.

* Das Ergebnis liegt im Bereich [-INF, INF].

.Siehe auch
<<fblangref30-scalarfuncs-sinh-de>>, <<fblangref30-scalarfuncs-acosh-de>>, <<fblangref30-scalarfuncs-atanh-de>>

[[fblangref30-scalarfuncs-atan-de]]
=== `ATAN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ATAN (_number_)
----

[[fblangref30-funcs-tbl-atan-de]]
.`ATAN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Die Funktion `ATAN` gibt den Arkustangens des Arguments zurück.
Das Ergebnis ist ein Winkel im Bereich ++<-pi/2, pi/2>++.

.Siehe auch
<<fblangref30-scalarfuncs-atan2-de>>, <<fblangref30-scalarfuncs-tan-de>>, <<fblangref30-scalarfuncs-acos-de>>, <<fblangref30-scalarfuncs-asin-de>>

[[fblangref30-scalarfuncs-atan2-de]]
=== `ATAN2()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

//Note for maintainers/editors: the argument names y and x (in that order!) are chosen on purpose, for geometrical reasons.
.Syntax
[listing,subs=+quotes]
----
ATAN2 (_y_, _x_)
----

[[fblangref30-funcs-tbl-atan2-de]]
.`ATAN2`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|y
|Ein Ausdruck eines numerischen Typs

|x
|Ein Ausdruck eines numerischen Typs
|===

Gibt den Winkel zurück, dessen Sinus-zu-Cosinus-_Verhältnis_ durch die beiden Argumente gegeben ist und dessen Sinus- und Kosinus-_Vorzeichen_ den Vorzeichen der Argumente entsprechen.
Dies ermöglicht Ergebnisse über den gesamten Kreis, einschließlich der Winkel -pi/2 und pi/2.

* Das Ergebnis ist ein Winkel im Bereich [-pi, pi].
* Wenn _x_ negativ ist, ist das Ergebnis pi, wenn _y_ 0 ist, und -pi, wenn _y_ -0 ist.
* Wenn sowohl _y_ als auch _x_ 0 sind, ist das Ergebnis bedeutungslos.
Ab Firebird 3.0 wird ein Fehler ausgegeben, wenn beide Argumente 0 sind.
Bei v.2.5.4 ist es in niedrigeren Versionen immer noch nicht behoben.
Weitere Informationen finden Sie unter http://tracker.firebirdsql.org/browse/CORE-3201[Tracker-Ticket CORE-3201].

[NOTES]
====
* Eine vollständig äquivalente Beschreibung dieser Funktion ist die folgende: `ATAN2(__y__, __x__)` ist der Winkel zwischen der positiven X-Achse und der Linie vom Ursprung zum Punkt _(x, y)_.
Damit ist auch klar, dass `ATAN2(0, 0)` undefiniert ist.
* Wenn _x_ größer als 0 ist, ist `ATAN2(__y__, __x__)` dasselbe wie `ATAN(__y__/__x__)`.
* Wenn sowohl Sinus als auch Kosinus des Winkels bereits bekannt sind, gibt `ATAN2(__sin__, __cos__)` den Winkel an.
====

[[fblangref30-scalarfuncs-atanh-de]]
=== `ATANH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ATANH (_number_)
----

[[fblangref30-funcs-tbl-atanh-de]]
.`ATANH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Jeder Nicht-``NULL``-Wert im Bereich ++<-1, 1>++.
|===

Gibt den inversen hyperbolischen Tangens des Arguments zurück.

* Das Ergebnis ist eine Zahl im Bereich [-INF, INF].

.Siehe auch
<<fblangref30-scalarfuncs-tanh-de>>, <<fblangref30-scalarfuncs-acosh-de>>, <<fblangref30-scalarfuncs-asinh-de>>

[[fblangref30-scalarfuncs-ceil-de]]
=== `CEIL()`, `CEILING()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>> (Betrifft nur `CEILING`)

.Ergebnistyp
`BIGINT` für exakte numerische _Zahl_ oder `DOUBLE PRECISION` für Gleitkomma-_Zahl_

.Syntax
[listing,subs=+quotes]
----
CEIL[ING] (_number_)
----

[[fblangref30-funcs-tbl-ceil-de]]
.`CEIL[ING]`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt die kleinste ganze Zahl zurück, die größer oder gleich dem Argument ist.

.Siehe auch
<<fblangref30-scalarfuncs-floor-de>>, <<fblangref30-scalarfuncs-round-de>>, <<fblangref30-scalarfuncs-trunc-de>>

[[fblangref30-scalarfuncs-cos-de]]
=== `COS()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COS (_angle_)
----

[[fblangref30-funcs-tbl-cos-de]]
.`COS`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Kosinus eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

* Jedes Ergebnis, das nicht ``NULL`` ist, liegt -- offensichtlich -- im Bereich [-1, 1].

.Siehe auch
<<fblangref30-scalarfuncs-acos-de>>, <<fblangref30-scalarfuncs-cot-de>>, <<fblangref30-scalarfuncs-sin-de>>, <<fblangref30-scalarfuncs-tan-de>>

[[fblangref30-scalarfuncs-cosh-de]]
=== `COSH()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COSH (_number_)
----

[[fblangref30-funcs-tbl-cosh-de]]
.`COSH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines numerischen Typs
|===

Gibt den hyperbolischen Kosinus des Arguments zurück.

* Jedes Ergebnis, das nicht ``NULL`` ist, liegt im Bereich [1, INF].

.Siehe auch
<<fblangref30-scalarfuncs-acosh-de>>, <<fblangref30-scalarfuncs-sinh-de>>, <<fblangref30-scalarfuncs-tanh-de>>

[[fblangref30-scalarfuncs-cot-de]]
=== `COT()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COT (_angle_)
----

[[fblangref30-funcs-tbl-cot-de]]
.`COT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Kotangens eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

.Siehe auch
<<fblangref30-scalarfuncs-cos-de>>, <<fblangref30-scalarfuncs-sin-de>>, <<fblangref30-scalarfuncs-tan-de>>

[[fblangref30-scalarfuncs-exp-de]]
=== `EXP()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
EXP (_number_)
----

[[fblangref30-funcs-tbl-exp-de]]
.`EXP`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines numerischen Typs
|===

Gibt die natürliche Exponentialfunktion zurück, _e_^`number`^

.Siehe auch
<<fblangref30-scalarfuncs-ln-de>>

[[fblangref30-scalarfuncs-floor-de]]
=== `FLOOR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`BIGINT` für genaue numerische _number_, oder `DOUBLE PRECISION` für fließkommagenaue _number_

.Syntax
[listing,subs=+quotes]
----
FLOOR (_number_)
----

[[fblangref30-funcs-tbl-floor-de]]
.`FLOOR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt die größte ganze Zahl zurück, die kleiner oder gleich dem Argument ist.

.Siehe auch
<<fblangref30-scalarfuncs-ceil-de>>, <<fblangref30-scalarfuncs-round-de>>, <<fblangref30-scalarfuncs-trunc-de>>

[[fblangref30-scalarfuncs-ln-de]]
=== `LN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LN (_number_)
----

[[fblangref30-funcs-tbl-ln-de]]
.`LN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den natürlichen Logarithmus des Arguments zurück.

* Ein Fehler wird ausgegeben, wenn das Argument negativ oder 0 ist.

.Siehe auch
<<fblangref30-scalarfuncs-exp-de>>, <<fblangref30-scalarfuncs-log-de>>, <<fblangref30-scalarfuncs-log10-de>>

[[fblangref30-scalarfuncs-log-de]]
=== `LOG()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LOG (_x_, _y_)
----

[[fblangref30-funcs-tbl-log-de]]
.`LOG`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|x
|Basis.
Ein Ausdruck eines numerischen Typs

|y
|Ein Ausdruck eines numerischen Typs
|===

Gibt den __x__-basierten Logarithmus von _y_ zurück.

* Wenn eines der Argumente 0 oder kleiner ist, wird ein Fehler ausgegeben.
(Vor 2.5 würde dies `NaN`, `+/-INF` oder 0 ergeben, abhängig von den genauen Werten der Argumente.)
* Wenn beide Argumente 1 sind, wird `NaN` zurückgegeben.
* Wenn _x_ = 1 und _y_ < 1 ist, wird `-INF` zurückgegeben.
* Wenn _x_ = 1 und _y_ > 1 ist, wird `INF` zurückgegeben.

.Siehe auch
<<fblangref30-scalarfuncs-power-de>>, <<fblangref30-scalarfuncs-ln-de>>, <<fblangref30-scalarfuncs-log10-de>>

[[fblangref30-scalarfuncs-log10-de]]
=== `LOG10()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LOG10 (_number_)
----

[[fblangref30-funcs-tbl-log10-de]]
.`LOG10`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den 10-basierten Logarithmus des Arguments zurück.

* Ein Fehler wird ausgegeben, wenn das Argument negativ oder 0 ist.
(In Versionen vor 2.5 würden solche Werte zu `NaN` bzw. `-INF` führen.)

.Siehe auch
<<fblangref30-scalarfuncs-power-de>>, <<fblangref30-scalarfuncs-ln-de>>, <<fblangref30-scalarfuncs-log-de>>

[[fblangref30-scalarfuncs-mod-de]]
=== `MOD()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT` je nach Typ von _a_.
Wenn _a_ ein Gleitkommatyp ist, ist das Ergebnis ein `BIGINT`.

.Syntax
[listing,subs=+quotes]
----
MOD (_a_, _b_)
----

[[fblangref30-funcs-tbl-mod-de]]
.`MOD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|a
|Ein Ausdruck eines numerischen Typs

|b
|Ein Ausdruck eines numerischen Typs
|===

Gibt den Rest einer ganzzahligen Division zurück.

* Nicht ganzzahlige Argumente werden vor der Division gerundet.
"```mod(7.5, 2.5)```" ergibt also 2 ("```mod(8, 3)```"), nicht 0.

[[fblangref30-scalarfuncs-pi-de]]
=== `PI()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing]
----
PI ()
----

Gibt eine Annäherung an den Wert von _pi_ zurück.

[[fblangref30-scalarfuncs-power-de]]
=== `POWER()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
POWER (_x_, _y_)
----

[[fblangref30-funcs-tbl-power]]
.`POWER`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|x
|Ein Ausdruck eines numerischen Typs

|y
|Ein Ausdruck eines numerischen Typs
|===

Gibt _x_ hoch _y_ (_x^y^_) zurück.

.Siehe auch
<<fblangref30-scalarfuncs-exp-de>>, <<fblangref30-scalarfuncs-log-de>>, <<fblangref30-scalarfuncs-log10-de>>, <<fblangref30-scalarfuncs-sqrt-de>>

[[fblangref30-scalarfuncs-rand-de]]
=== `RAND()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing]
----
RAND ()
----

Gibt eine Zufallszahl zwischen 0 und 1 zurück.

[[fblangref30-scalarfuncs-round-de]]
=== `ROUND()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`INTEGER`, (skaliert) `BIGINT` oder `DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ROUND (_number_ [, _scale_])
----

[[fblangref30-funcs-tbl-round-de]]
.`ROUND`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^|Parameter
^|Description

|number
|Ein Ausdruck eines numerischen Typs

|scale
a|Eine ganze Zahl, die die Anzahl der Nachkommastellen angibt, auf die gerundet werden soll, z. B.:

* {nbsp}2 zum Runden auf das nächste Vielfache von 0,01
* {nbsp}1 zum Runden auf das nächste Vielfache von 0,1
* {nbsp}0 zum Runden auf die nächste ganze Zahl
* -1 zum Runden auf das nächste Vielfache von 10
* -2 zum Runden auf das nächste Vielfache von 100
|===

Rundet eine Zahl auf die nächste ganze Zahl.
Wenn der Bruchteil genau '0,5' ist, wird bei positiven Zahlen nach oben und bei negativen Zahlen nach unten gerundet.
Mit dem optionalen Argument _scale_ kann die Zahl auf Zehnerpotenzen (Zehner, Hunderter, Zehntel, Hundertstel usw.) statt auf ganze Zahlen gerundet werden.

[IMPORTANT]
====
Wenn Sie an das Verhalten der externen Funktion `ROUND` gewöhnt sind, beachten Sie bitte, dass die Funktion _internal_ von Null immer auf Hälften rundet, d.h. bei negativen Zahlen nach unten.
====

[[fblangref30-scalarfuncs-round-exmpl-de]]
==== `ROUND`-Beispiele

Wenn das Argument _scale_ vorhanden ist, hat das Ergebnis normalerweise die gleiche Skalierung wie das erste Argument:

[source]
----
ROUND(123.654, 1) -- Ergebnis 123.700 (not 123.7)
ROUND(8341.7, -3) -- Ergebnis 8000.0 (not 8000)
ROUND(45.1212, 0) -- Ergebnis 45.0000 (not 45)
----

Andernfalls ist die Ergebnisskalierung 0:

[source]
----
ROUND(45.1212) -- Ergebnis 45
----

.Siehe auch
<<fblangref30-scalarfuncs-ceil-de>>, <<fblangref30-scalarfuncs-floor-de>>, <<fblangref30-scalarfuncs-trunc-de>>

[[fblangref30-scalarfuncs-sign-de]]
=== `SIGN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
SIGN (_number_)
----

[[fblangref30-funcs-tbl-sign-de]]
.`SIGN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt das Vorzeichen des Arguments zurück: -1, 0 oder 1.

[[fblangref30-scalarfuncs-sin-de]]
=== `SIN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SIN (_angle_)
----

[[fblangref30-funcs-tbl-sin]]
.`SIN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Sinus eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

* Jedes Ergebnis, das nicht `NULL` ist, liegt -- offensichtlich -- im Bereich [-1, 1].

.Siehe auch
<<fblangref30-scalarfuncs-asin-de>>, <<fblangref30-scalarfuncs-cos-de>>, <<fblangref30-scalarfuncs-cot-de>>, <<fblangref30-scalarfuncs-tan-de>>

[[fblangref30-scalarfuncs-sinh-de]]
=== `SINH()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SINH (_number_)
----

[[fblangref30-funcs-tbl-sinh-de]]
.`SINH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den hyperbolischen Sinus des Arguments zurück.

.Siehe auch
<<fblangref30-scalarfuncs-asinh-de>>, <<fblangref30-scalarfuncs-cosh-de>>, <<fblangref30-scalarfuncs-tanh-de>>

[[fblangref30-scalarfuncs-sqrt-de]]
=== `SQRT()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SQRT (_number_)
----

[[fblangref30-funcs-tbl-sqrt-de]]
.`SQRT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt die Quadratwurzel des Arguments zurück.

* Wenn _number_ negativ ist, wird ein Fehler ausgegeben.

.Siehe auch
<<fblangref30-scalarfuncs-power-de>>

[[fblangref30-scalarfuncs-tan-de]]
=== `TAN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TAN (_angle_)
----

[[fblangref30-funcs-tbl-tan-de]]
.`TAN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Tangens eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

.Siehe auch
<<fblangref30-scalarfuncs-atan-de>>, <<fblangref30-scalarfuncs-atan2-de>>, <<fblangref30-scalarfuncs-cos-de>>, <<fblangref30-scalarfuncs-cot-de>>, <<fblangref30-scalarfuncs-sin-de>>, <<fblangref30-scalarfuncs-tan-de>>

[[fblangref30-scalarfuncs-tanh-de]]
=== `TANH()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TANH (_number_)
----

[[fblangref30-funcs-tbl-tanh]]
.`TANH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den hyperbolischen Tangens des Arguments zurück.

* Aufgrund von Rundungen liegt jedes Ergebnis, das nicht `NULL` ist, im Bereich [-1, 1] (mathematisch ist es ++<-1, 1>++).

.Siehe auch
<<fblangref30-scalarfuncs-atanh-de>>, <<fblangref30-scalarfuncs-cosh-de>>, <<fblangref30-scalarfuncs-tanh-de>>

[[fblangref30-scalarfuncs-trunc-de]]
=== `TRUNC()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`, (scaled) `BIGINT` or `DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TRUNC (_number_ [, _scale_])
----

[[fblangref30-funcs-tbl-trunc-de]]
.`TRUNC`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^|Parameter
^|Description

|number
|Ein Ausdruck eines numerischen Typs

|scale
a|Eine ganze Zahl, die die Anzahl der Dezimalstellen angibt, auf die abgeschnitten werden soll, z. B.:

* {nbsp}2 zum Abschneiden auf das nächste Vielfache von 0,01
* {nbsp}1 zum Abschneiden auf das nächste Vielfache von 0,1
* {nbsp}0 zum Abschneiden auf die nächste ganze Zahl
* -1 zum Abschneiden auf das nächste Vielfache von 10
* -2 zum Abschneiden auf das nächste Vielfache von 100
|===

Gibt den ganzzahligen Teil einer Zahl zurück.
Mit dem optionalen Argument _scale_ kann die Zahl auf Zehnerpotenzen (Zehner, Hunderter, Zehntel, Hundertstel usw.) statt auf ganze Zahlen gekürzt werden.

[NOTE]
====
* Wenn das Argument _scale_ vorhanden ist, hat das Ergebnis normalerweise die gleiche Skala wie das erste Argument, z.
** `TRUNC(789.2225, 2)` gibt 789.2200 (nicht 789.22) zurück
** `TRUNC(345.4, -2)` gibt 300.0 (nicht 300) zurück
** `TRUNC(-163.41, 0)` gibt -163.00 (nicht -163) zurück
* Andernfalls ist die Ergebnisskala 0:
** `TRUNC(-163.41)` gibt -163 zurück
====

[IMPORTANT]
====
Wenn Sie an das Verhalten der https://www.firebirdsql.org/file/documentation/reference_manuals/reference_material/html/langrefupd25-udf-truncate.html[externen Funktion `TRUNCATE`] gewöhnt sind, beachten Sie bitte, dass die _interne_ Funktion `TRUNC` immer gegen Null abschneidet, d.h. für negative Zahlen nach oben.
====

.Siehe auch
<<fblangref30-scalarfuncs-ceil-de>>, <<fblangref30-scalarfuncs-floor-de>>, <<fblangref30-scalarfuncs-round-de>>

[[fblangref30-functions-string-de]]
== String-Funktionen

[[fblangref30-scalarfuncs-ascii-char-de]]
=== `ASCII_CHAR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`CHAR(1) CHARACTER SET NONE`

.Syntax
[listing,subs=+quotes]
----
ASCII_CHAR (_code_)
----

[[fblangref30-funcs-tbl-asciichar-de]]
.`ASCII_CHAR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|code
|Eine ganze Zahl im Bereich von 0 bis 255
|===

Gibt das ASCII-Zeichen zurück, das der im Argument übergebenen Zahl entspricht.

[IMPORTANT]
====
* Wenn Sie das Verhalten des `ASCII_CHAR`-UDF gewohnt sind, das einen leeren String zurückgibt, wenn das Argument 0 ist, beachten Sie bitte, dass die interne Funktion hier korrekt ein Zeichen mit dem ASCII-Code 0 zurückgibt.
====

[[fblangref30-scalarfuncs-ascii-val-de]]
=== `ASCII_VAL()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
ASCII_VAL (_ch_)
----

[[fblangref30-funcs-tbl-asciival-de]]
.`ASCII_VAL`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|ch
|Ein String vom Datentyp `[VAR]CHAR` oder ein Text `BLOB` mit der maximalen Größe von 32.767 Bytes
|===

Gibt den ASCII-Code des übergebenen Zeichens zurück.

* Wenn das Argument ein String mit mehr als einem Zeichen ist, wird der ASCII-Code des ersten Zeichens zurückgegeben.
* Wenn das Argument ein leerer String ist, wird 0 zurückgegeben.
* Wenn das Argument `NULL` ist, wird `NULL` zurückgegeben.
* Wenn das erste Zeichen der Argumentzeichenfolge aus mehreren Byte besteht, wird ein Fehler ausgegeben.
(Ein Fehler in Firebird 2.1 - 2.1.3 und 2.5.0 führt zu einem Fehler, wenn _beliebiges_ Zeichen in der Zeichenfolge aus mehreren Byte besteht.
Dies ist in den Versionen 2.1.4 und 2.5.1 behoben.)

[[fblangref30-scalarfuncs-bit-length-de]]
=== `BIT_LENGTH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
BIT_LENGTH (_string_)
----

[[fblangref30-funcs-tbl-bitlength-de]]
.`BIT_LENGTH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt die Länge des Eingabestrings in Bits an.
Bei Mehrbyte-Zeichensätzen kann dies kleiner sein als die Anzahl der Zeichen mal 8 mal die "`formale`" Anzahl von Bytes pro Zeichen wie in `RDB$CHARACTER_SETS` gefunden.

[NOTE]
====
Bei Argumenten vom Typ `CHAR` berücksichtigt diese Funktion die gesamte formale Stringlänge (d.h. die deklarierte Länge eines Feldes oder einer Variablen).
Wenn Sie die "`logische`" Bitlänge erhalten möchten, ohne die abschließenden Leerzeichen zu zählen, rechts-<<fblangref30-scalarfuncs-trim-de,`TRIM`>> das Argument vor der Übergabe an `BIT_LENGTH`.
====

.`BLOB`-Unterstützung
Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[[fblangref30-scalarfuncs-bit-length-exmpl-de]]
==== `BIT_LENGTH`-Beispiele

[source]
----
select bit_length('Hello!') from rdb$database
-- Ergebnis 48

select bit_length(_iso8859_1 'Grüß di!') from rdb$database
-- Ergebnis 64: ü und ß belegen in ISO8859_1 jeweils ein Byte

select bit_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- Ergebnis 80: ü und ß belegen in ISO8859_1 jeweils ein Byte

select bit_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- Ergebnis 208: alle 24 CHAR-Positionen zählen, und zwei davon sind 16-Bit
----

.Siehe auch
<<fblangref30-scalarfuncs-octet-length-de>>, <<fblangref30-scalarfuncs-char-length-de>>

[[fblangref30-scalarfuncs-char-length-de]]
=== `CHAR_LENGTH()`, `CHARACTER_LENGTH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
  CHAR_LENGTH (_string_)
| CHARACTER_LENGTH (_string_)
----

[[fblangref30-funcs-tbl-charlength-de]]
.`CHAR[ACTER]_LENGTH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt die Länge des Eingabestrings in Zeichen an.

[NOTE]
====
* Bei Argumenten vom Typ `CHAR` liefert diese Funktion die formale Stringlänge (d.h. die deklarierte Länge eines Feldes oder einer Variablen).
Wenn Sie die "`logische`" Länge erhalten möchten, ohne die abschließenden Leerzeichen zu zählen, rechts-<<fblangref30-scalarfuncs-trim-de,`TRIM`>> das Argument vor der Übergabe an `CHAR[ACTER]_LENGTH`.
* *``BLOB``-Unterstützung*: Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
====

[[fblangref30-scalarfuncs-char-length-exmpl-de]]
==== `CHAR_LENGTH`-Beispiele
[source]
----
select char_length('Hello!') from rdb$database
-- Ergebnis 6

select char_length(_iso8859_1 'Grüß di!') from rdb$database
-- Ergebnis 8

select char_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- Ergebnis 8; dass ü und ß jeweils zwei Bytes belegen ist irrelevant

select char_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- Ergebnis 24: alle 24 CHAR-Positionen zählen
----

.Siehe auch
<<fblangref30-scalarfuncs-bit-length-de>>, <<fblangref30-scalarfuncs-octet-length-de>>

[[fblangref30-scalarfuncs-hash-de]]
=== `HASH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
HASH (_string_)
----

[[fblangref30-funcs-tbl-hash-de]]
.`HASH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt einen Hashwert für die Eingabezeichenfolge zurück.
Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[[fblangref30-scalarfuncs-left-de]]
=== `LEFT()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
LEFT (_string_, _length_)
----

[[fblangref30-funcs-tbl-left-de]]
.`LEFT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs

|length
|Ganzzahliger Ausdruck.
Definiert die Anzahl der zurückzugebenden Zeichen
|===

Gibt den äußersten linken Teil der Argumentzeichenfolge zurück.
Die Anzahl der Zeichen wird im zweiten Argument angegeben.

* Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge, einschließlich solcher mit einem Multi-Byte-Zeichensatz.
* Wenn _string_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_ der Länge des Eingabestrings.
* Wenn das Argument _length_ die Stringlänge überschreitet, wird der Eingabestring unverändert zurückgegeben.
* Wenn das Argument _length_ keine ganze Zahl ist, wird Banker-Rundung (auf gerade) angewendet, d. h. 0,5 wird zu 0, 1,5 wird zu 2, 2,5 wird zu 2, 3,5 wird zu 4 usw.

.Siehe auch
<<fblangref30-scalarfuncs-right-de>>

[[fblangref30-scalarfuncs-lower-de]]
=== `LOWER()`

.Verfügbar in
DSQL, ESQL, PSQL

.Möglicher Namenskonflikt
YES -> <<lowernote,Lesen Sie die Details unten>>

.Ergebnistyp
`(VAR)CHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
LOWER (_string_)
----

[[fblangref30-funcs-tbl-lower-de]]
.`LOWER`-FunktionsparameterS
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt das Äquivalent der Eingabezeichenfolge in Kleinbuchstaben zurück.
Das genaue Ergebnis hängt vom Zeichensatz ab.
Bei `ASCII` oder `NONE` beispielsweise werden nur ASCII-Zeichen kleingeschrieben;
mit `OCTETS` wird der gesamte String unverändert zurückgegeben.
Seit Firebird 2.1 unterstützt diese Funktion auch Text-``BLOB``s beliebiger Länge und beliebigem Zeichensatz.

[[lowernote]]
.Namenskonflikt
[NOTE]
====
Da `LOWER` ein reserviertes Wort ist, hat die interne Funktion Vorrang, auch wenn die externe Funktion mit diesem Namen ebenfalls deklariert wurde.
Um die (minderwertige!) externe Funktion aufzurufen, verwenden Sie doppelte Anführungszeichen und die genaue Großschreibung, wie in `"LOWER"(__string__)`.
====

[[fblangref30-scalarfuncs-lower-exmpl-de]]
==== `LOWER`-Beispiele

[source]
----
select Sheriff from Towns
  where lower(Name) = 'cooper''s valley'
----

.Siehe auch
<<fblangref30-scalarfuncs-upper-de>>

[[fblangref30-scalarfuncs-lpad-de]]
=== `LPAD()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
LPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref30-funcs-tbl-lpad-de]]
.`LPAD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|endlen
|Länge der Ausgabezeichenfolge

|padstr
|Das Zeichen oder die Zeichenfolge, die verwendet werden soll, um die Quellzeichenfolge bis zur angegebenen Länge aufzufüllen.
Standard ist Leerzeichen ("```' '```")
|===

Füllt eine Zeichenfolge mit der linken Maustaste mit Leerzeichen oder mit einer vom Benutzer angegebenen Zeichenfolge auf, bis eine bestimmte Länge erreicht ist.

* Diese Funktion unterstützt vollständig Text ``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
* Wenn _str_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__endlen__)`.
* Wenn _padstr_ angegeben ist und gleich `''` (leerer String) ist, findet kein Auffüllen statt.
* Wenn _endlen_ kleiner als die aktuelle Stringlänge ist, wird der String auf _endlen_ gekürzt, auch wenn _padstr_ der leere String ist.

[NOTE]
====
In Firebird 2.1-2.1.3 waren alle Nicht-``BLOB``-Ergebnisse vom Typ `VARCHAR(32765)`, was es ratsam machte, sie auf eine bescheidenere Größe umzuwandeln.
Dies ist nicht mehr der Fall.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Obwohl es versucht, den Speicherverbrauch zu begrenzen, kann dies die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-lpad-exmpl-de]]
==== `LPAD`-Beispiele

[source]
----
lpad ('Hello', 12)               -- Ergebnis '       Hello'
lpad ('Hello', 12, '-')          -- Ergebnis '-------Hello'
lpad ('Hello', 12, '')           -- Ergebnis 'Hello'
lpad ('Hello', 12, 'abc')        -- Ergebnis 'abcabcaHello'
lpad ('Hello', 12, 'abcdefghij') -- Ergebnis 'abcdefgHello'
lpad ('Hello', 2)                -- Ergebnis 'He'
lpad ('Hello', 2, '-')           -- Ergebnis 'He'
lpad ('Hello', 2, '')            -- Ergebnis 'He'
----

.Siehe auch
<<fblangref30-scalarfuncs-rpad-de>>

[[fblangref30-scalarfuncs-octet-length-de]]
=== `OCTET_LENGTH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
OCTET_LENGTH (_string_)
----

[[fblangref30-funcs-tbl-octetlength-de]]
.`OCTET_LENGTH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt die Länge des Eingabestrings in Bytes (Oktetts) an.
Bei Mehrbyte-Zeichensätzen kann dies kleiner sein als die Anzahl der Zeichen mal der "`formalen`" Anzahl von Bytes pro Zeichen, wie in `RDB$CHARACTER_SETS` gefunden.

[NOTE]
====
Bei Argumenten vom Typ `CHAR` berücksichtigt diese Funktion die gesamte formale Stringlänge (d.h. die deklarierte Länge eines Feldes oder einer Variablen).
Wenn Sie die "`logische`" Bytelänge erhalten möchten, ohne die abschließenden Leerzeichen zu zählen, rechts-<<fblangref30-scalarfuncs-trim-de,`TRIM`>> das Argument vor der Übergabe an `OCTET_LENGTH`.
====

.`BLOB`-Unterstützung
Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[[fblangref30-scalarfuncs-octet-length-exmpl-de]]
==== `OCTET_LENGTH`-Beispiele

[source]
----
select octet_length('Hello!') from rdb$database
-- Ergebnis 6

select octet_length(_iso8859_1 'Grüß di!') from rdb$database
-- Ergebnis 8: ü und ß belegen in ISO8859_1 jeweils ein Byte

select octet_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- Ergebnis 10: ü und ß belegen in UTF8 jeweils zwei Byte

select octet_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- Ergebnis 26: alle 24 CHAR-Positionen zählen, und zwei davon sind 2-Byte
----

.Siehe auch
<<fblangref30-scalarfuncs-bit-length-de>>, <<fblangref30-scalarfuncs-char-length-de>>

[[fblangref30-scalarfuncs-overlay-de]]
=== `OVERLAY()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
OVERLAY (_string_ PLACING _replacement_ FROM _pos_ [FOR _length_])
----

[[fblangref30-funcs-tbl-overlay-de]]
.`OVERLAY`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Die Zeichenfolge, in die die Ersetzung erfolgt

|replacement
|Ersetzende Zeichenkette

|pos
|Die Position, von der aus ersetzt wird (Ausgangsposition)

|length
|Die Anzahl der zu überschreibenden Zeichen
|===

`OVERLAY()` überschreibt einen Teil eines Strings mit einem anderen String.
Standardmäßig entspricht die Anzahl der aus der Hostzeichenfolge entfernten (überschriebenen) Zeichen der Länge der Ersetzungszeichenfolge.
Mit dem optionalen vierten Argument kann eine andere Anzahl von Zeichen zum Entfernen angegeben werden.

* Diese Funktion unterstützt ``BLOB``s beliebiger Länge.
* Wenn _string_ oder _replacement_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_ der Summe der Längen von _string_ und _replacement_.
* Wie bei SQL-Stringfunktionen üblich, ist _pos_ 1-basiert.
* Wenn _pos_ hinter dem Ende von _string_ steht, wird _replacement_ direkt nach _string_ platziert.
* Wenn die Anzahl der Zeichen von _pos_ bis zum Ende von _string_ kleiner ist als die Länge von _replacement_ (oder als das _length_-Argument, falls vorhanden), wird _string_ an _pos_ abgeschnitten und _replacement_ dahinter platziert.
* Eine "```FOR 0```"-Klausel bewirkt, dass _replacement_ einfach in _string_ eingefügt wird.
* Wenn ein Argument `NULL` ist, ist das Ergebnis `NULL`.
* Wenn _pos_ oder _length_ keine ganze Zahl ist, wird Banker-Rundung (auf-gerade) angewendet, d. h. 0,5 wird zu 0, 1,5 wird zu 2, 2,5 wird zu 2, 3,5 wird zu 4 usw.

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-overlay-exmpl-de]]
==== `OVERLAY`-Beispiele

[source]
----
overlay ('Goodbye' placing 'Hello' from 2)   -- Ergebnis 'GHelloe'
overlay ('Goodbye' placing 'Hello' from 5)   -- Ergebnis 'GoodHello'
overlay ('Goodbye' placing 'Hello' from 8)   -- Ergebnis 'GoodbyeHello'
overlay ('Goodbye' placing 'Hello' from 20)  -- Ergebnis 'GoodbyeHello'

overlay ('Goodbye' placing 'Hello' from 2 for 0) -- Ergebnis 'GHellooodbye'
overlay ('Goodbye' placing 'Hello' from 2 for 3) -- Ergebnis 'GHellobye'
overlay ('Goodbye' placing 'Hello' from 2 for 6) -- Ergebnis 'GHello'
overlay ('Goodbye' placing 'Hello' from 2 for 9) -- Ergebnis 'GHello'

overlay ('Goodbye' placing '' from 4)        -- Ergebnis 'Goodbye'
overlay ('Goodbye' placing '' from 4 for 3)  -- Ergebnis 'Gooe'
overlay ('Goodbye' placing '' from 4 for 20) -- Ergebnis 'Goo'

overlay ('' placing 'Hello' from 4)          -- Ergebnis 'Hello'
overlay ('' placing 'Hello' from 4 for 0)    -- Ergebnis 'Hello'
overlay ('' placing 'Hello' from 4 for 20)   -- Ergebnis 'Hello'
----

.Siehe auch
<<fblangref30-scalarfuncs-replace-de>>

[[fblangref30-scalarfuncs-position-de]]
=== `POSITION()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
  POSITION (_substr_ IN _string_)
| POSITION (_substr_, _string_ [, _startpos_])
----

[[fblangref30-funcs-tbl-position-de]]
.`POSITION`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|substr
|Der Teilstring, dessen Position gesucht werden soll

|string
|Der zu suchende String

|startpos
|Die Position in _string_, an der die Suche beginnen soll
|===

Gibt die (1-basierte) Position des ersten Vorkommens einer Teilzeichenfolge in einer Hostzeichenfolge zurück.
Mit dem optionalen dritten Argument beginnt die Suche an einem bestimmten Offset, wobei alle Übereinstimmungen ignoriert werden, die früher in der Zeichenfolge auftreten können.
Wenn keine Übereinstimmung gefunden wird, ist das Ergebnis 0.

[NOTE]
====
* Das optionale dritte Argument wird nur in der zweiten Syntax (Komma-Syntax) unterstützt.
* Die leere Zeichenfolge wird als Teilzeichenfolge jeder Zeichenfolge betrachtet.
Wenn also _substr_ `''` (leerer String) ist und _string_ nicht `NULL` ist, ist das Ergebnis:
+
--
** 1 wenn _startpos_ nicht angegeben ist;
** _startpos_ wenn _startpos_ innerhalb von _string_ liegt;
** 0, wenn _startpos_ hinter dem Ende von _string_ liegt.
--
+
**Hinweis:** Ein Fehler in Firebird 2.1 - 2.1.3 und 2.5.0 führt dazu, dass `POSITION` _immer_ 1 zurückgibt, wenn _substr_ der leere String ist.
Dies ist in 2.1.4 und 2.5.1 behoben.
* Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Größe und jedes Zeichensatzes.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-position-exmpl-de]]
==== `POSITION`-Beispiele

[source]
----
position ('be' in 'To be or not to be')   -- Ergebnis 4
position ('be', 'To be or not to be')     -- Ergebnis 4
position ('be', 'To be or not to be', 4)  -- Ergebnis 4
position ('be', 'To be or not to be', 8)  -- Ergebnis 17
position ('be', 'To be or not to be', 18) -- Ergebnis 0
position ('be' in 'Alas, poor Yorick!')   -- Ergebnis 0
----

.Siehe auch
<<fblangref30-scalarfuncs-substring-de>>

[[fblangref30-scalarfuncs-replace-de]]
=== `REPLACE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
REPLACE (_str_, _find_, _repl_)
----

[[fblangref30-funcs-tbl-replace]]
.`REPLACE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Die Zeichenfolge, in der die Ersetzung erfolgen soll

|find
|Die Zeichenfolge, nach der gesucht werden soll

|repl
|Die Ersatzzeichenfolge
|===

Ersetzt alle Vorkommen einer Teilzeichenfolge in einer Zeichenfolge.

* Diese Funktion unterstützt vollständig Text ``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
* Wenn ein Argument ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_, das aus den Längen von _str_, _find_ und _repl_ so berechnet wird, dass auch die maximal mögliche Anzahl von Ersetzungen das Feld nicht überläuft.
* Wenn _find_ der leere String ist, wird _str_ unverändert zurückgegeben.
* Wenn _repl_ der leere String ist, werden alle Vorkommen von _find_ aus _str_ gelöscht.
* Wenn ein Argument `NULL` ist, ist das Ergebnis immer `NULL`, auch wenn nichts ersetzt worden wäre.

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-replace-exmpl-de]]
==== `REPLACE`-Beispiele

[source]
----
replace ('Billy Wilder',  'il', 'oog') -- Ergebnis 'Boogly Woogder'
replace ('Billy Wilder',  'il',    '') -- Ergebnis 'Bly Wder'
replace ('Billy Wilder',  null, 'oog') -- Ergebnis NULL
replace ('Billy Wilder',  'il',  null) -- Ergebnis NULL
replace ('Billy Wilder', 'xyz',  null) -- Ergebnis NULL (!)
replace ('Billy Wilder', 'xyz', 'abc') -- Ergebnis 'Billy Wilder'
replace ('Billy Wilder',    '', 'abc') -- Ergebnis 'Billy Wilder'
----

.Siehe auch
<<fblangref30-scalarfuncs-overlay-de>>, <<fblangref30-scalarfuncs-substring-de>>, <<fblangref30-scalarfuncs-position-de>>, <<fblangref30-scalarfuncs-char-length-de>>

[[fblangref30-scalarfuncs-reverse-de]]
=== `REVERSE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR`

.Syntax
[listing,subs=+quotes]
----
REVERSE (_string_)
----

[[fblangref30-funcs-tbl-reverse-de]]
.`REVERSE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt eine Zeichenfolge rückwärts zurück.

[[fblangref30-scalarfuncs-reverse-exmpl-de]]
==== `REVERSE`-Beispiele
[source]
----
reverse ('spoonful')            -- Ergebnis 'lufnoops'
reverse ('Was it a cat I saw?') -- Ergebnis '?was I tac a ti saW'
----

[TIP]
====
Diese Funktion ist sehr praktisch, wenn Sie nach String-Endungen gruppieren, suchen oder sortieren möchten, z.B. beim Umgang mit Domainnamen oder E-Mail-Adressen:

[source]
----
create index ix_people_email on people
  computed by (reverse(email));

select * from people
  where reverse(email) starting with reverse('.br');
----
====

[[fblangref30-scalarfuncs-right-de]]
=== `RIGHT()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listingstring]
----
RIGHT (_string_, _length_)
----

[[fblangref30-funcs-tbl-right-de]]
.`RIGHT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs

|length
|Integer.
Definiert die Anzahl der zurückzugebenden Zeichen
|===

Gibt den ganz rechten Teil der Argumentzeichenfolge zurück.
Die Anzahl der Zeichen wird im zweiten Argument angegeben.

* Diese Funktion unterstützt Text ``BLOB`s' beliebiger Länge, hat aber einen Fehler in den Versionen 2.1 - 2.1.3 und 2.5.0, der dazu führt, dass es bei Text ``BLOB``s fehlschlägt, die größer als 1024 Bytes sind, die ein Multi haben -Byte-Zeichensatz.
Dies wurde in den Versionen 2.1.4 und 2.5.1 behoben.
* Wenn _string_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_ der Länge des Eingabestrings.
* Wenn das Argument _length_ die Stringlänge überschreitet, wird der Eingabestring unverändert zurückgegeben.
* Wenn das Argument _Länge_ keine ganze Zahl ist, wird Banker-Rundung (auf-gerade) angewendet, d. h. 0,5 wird zu 0, 1,5 wird zu 2, 2,5 wird zu 2, 3,5 wird zu 4 usw.

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

.Siehe auch
<<fblangref30-scalarfuncs-left-de>>, <<fblangref30-scalarfuncs-substring-de>>

[[fblangref30-scalarfuncs-rpad-de]]
=== `RPAD()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
RPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref30-funcs-tbl-rpad-de]]
.`RPAD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|endlen
|Länge der Ausgabezeichenfolge

|endlen
|Das Zeichen oder die Zeichenfolge, die verwendet werden soll, um die Quellzeichenfolge bis zur angegebenen Länge aufzufüllen.
Standard ist Leerzeichen (`' '`)
|===

Füllt eine Zeichenfolge mit der rechten Maustaste mit Leerzeichen oder mit einer vom Benutzer angegebenen Zeichenfolge auf, bis eine bestimmte Länge erreicht ist.

* Diese Funktion unterstützt vollständig Text ``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
* Wenn _str_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(_endlen_)`.
* Wenn _padstr_ angegeben ist und gleich `''` (leerer String) ist, findet kein Auffüllen statt.
* Wenn _endlen_ kleiner als die aktuelle Stringlänge ist, wird der String auf _endlen_ gekürzt, auch wenn _padstr_ der leere String ist.

[NOTE]
====
In Firebird 2.1-2.1.3 waren alle Nicht-``BLOB``-Ergebnisse vom Typ `VARCHAR(32765)`, was es ratsam machte, sie auf eine bescheidenere Größe umzuwandeln.
Dies ist nicht mehr der Fall.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Obwohl es versucht, den Speicherverbrauch zu begrenzen, kann dies die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-rpad-exmpl-de]]
==== `RPAD`-Beispiele

[source]
----
rpad ('Hello', 12)               -- Ergebnis 'Hello       '
rpad ('Hello', 12, '-')          -- Ergebnis 'Hello-------'
rpad ('Hello', 12, '')           -- Ergebnis 'Hello'
rpad ('Hello', 12, 'abc')        -- Ergebnis 'Helloabcabca'
rpad ('Hello', 12, 'abcdefghij') -- Ergebnis 'Helloabcdefg'
rpad ('Hello', 2)                -- Ergebnis 'He'
rpad ('Hello', 2, '-')           -- Ergebnis 'He'
rpad ('Hello', 2, '')            -- Ergebnis 'He'
----

.Siehe auch
<<fblangref30-scalarfuncs-lpad-de>>

[[fblangref30-scalarfuncs-substring-de]]
=== `SUBSTRING()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyps
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
SUBSTRING ( <substring-args> )

<substring-args> ::=
    _str_ FROM _startpos_ [FOR _length_]
  | _str_ SIMILAR <similar-pattern> ESCAPE <escape>

<similar-pattern> ::=
  <similar-pattern-R1>
  <escape> " <similar-pattern-R2> <escape> "
  <similar-pattern-R3>
----

[[fblangref30-funcs-tbl-substring-de]]
.`SUBSTRING`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|startpos
|Ganzzahliger Ausdruck, die Position, von der aus mit dem Abrufen der Teilzeichenfolge begonnen werden soll

|length
|Die Anzahl der abzurufenden Zeichen nach dem _startpos_

|similar-pattern
|Muster für reguläre SQL-Ausdrücke, um nach der Teilzeichenfolge zu suchen

|escape
|Escape-Zeichen
|===

Gibt die Teilzeichenfolge einer Zeichenfolge beginnend an der angegebenen Position zurück, entweder bis zum Ende der Zeichenfolge oder mit einer bestimmten Länge, oder extrahiert eine Teilzeichenfolge mithilfe eines Musters für reguläre SQL-Ausdrücke.

Wenn ein Argument `NULL` ist, ist das Ergebnis auch `NULL`.

[WARNING]
====
Bei Verwendung auf einem `BLOB` muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Obwohl es versucht, den Speicherverbrauch zu begrenzen, kann dies die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-substring-pos-de]]
==== Positionsbezogener `SUBSTRING`

In ihrer einfachen Positionsform (mit `FROM`) gibt diese Funktion den Teilstring ab der Zeichenposition _startpos_ zurück (die erste Position ist 1).
Ohne das Argument `FOR` gibt es alle verbleibenden Zeichen in der Zeichenfolge zurück.
Bei `FOR` gibt es _length_ Zeichen oder den Rest des Strings zurück, je nachdem welcher kürzer ist.

Die Funktion unterstützt vollständig binäre und Text ``BLOB``s beliebiger Länge und mit jedem Zeichensatz.
Wenn _str_ ein `BLOB` ist, ist das Ergebnis auch ein `BLOB`.
Bei jedem anderen Argumenttyp ist das Ergebnis ein `VARCHAR`.

Bei Nicht-``BLOB``-Argumenten entspricht die Breite des Ergebnisfelds immer der Länge von _str_, unabhängig von _startpos_ und _length_.
`substring('pinhead' from 4 for 2)` gibt also ein `VARCHAR(7)` zurück, das den String `'he'` enthält.

.Beispiele
[source]
----
insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames
----

[[fblangref30-scalarfuncs-substring-regexp-de]]
==== Regulärer Ausdruck `SUBSTRING`

In der Form des regulären Ausdrucks (mit `SIMILAR`) gibt die Funktion `SUBSTRING` einen Teil des Strings zurück, der einem Muster eines regulären SQL-Ausdrucks entspricht.
Wenn keine Übereinstimmung gefunden wird, wird `NULL` zurückgegeben.

Das Muster "SIMILAR" wird aus drei Mustern für reguläre SQL-Ausdrücke gebildet, _R1_, _R2_ und _R3_.
Das gesamte Muster hat die Form `R1 || '__<Escape>__"' || R2 || '__<Escape>__"' || R3`, wobei _<escape>_ das in der `ESCAPE`-Klausel definierte Escape-Zeichen ist.
_R2_ ist das Muster, das mit der zu extrahierenden Teilzeichenfolge übereinstimmt, und wird zwischen doppelten Anführungszeichen mit Escapezeichen eingeschlossen (`__<escape>__"`, zB "```++#"++```" mit Escape-Zeichen '``` +##++```').
_R1_ entspricht dem Präfix des Strings und _R3_ dem Suffix des Strings.
Sowohl _R1_ als auch _R3_ sind optional (sie können leer sein), aber das Muster muss mit der gesamten Zeichenfolge übereinstimmen.
Mit anderen Worten, es reicht nicht aus, ein Muster anzugeben, das nur die zu extrahierende Teilzeichenfolge findet.

[TIP]
====
Die mit Escapezeichen versehenen doppelten Anführungszeichen um _R2_ können mit der Definition einer einzelnen Erfassungsgruppe in einer gängigeren Syntax für reguläre Ausdrücke wie PCRE verglichen werden.
Das heißt, das vollständige Muster entspricht `__R1__(__R2__)__R3__`, das mit der gesamten Eingabezeichenfolge übereinstimmen muss, und die Erfassungsgruppe ist die zurückzugebende Teilzeichenfolge.
====

[NOTE]
====
Wenn einer von _R1_, _R2_ oder _R3_ keine Zeichenfolge der Länge Null ist und nicht das Format eines regulären SQL-Ausdrucks hat, wird eine Ausnahme ausgelöst.
====

Das vollständige Format für reguläre SQL-Ausdrücke wird in <<fblangref30-commons-syntaxregex-de,Syntax: Reguläre SQL-Ausdrücke>> beschrieben

.Beispiele
[source]
----
substring('abcabc' similar 'a#"bcab#"c' escape '#')  -- bcab
substring('abcabc' similar 'a#"%#"c' escape '#')     -- bcab
substring('abcabc' similar '_#"%#"_' escape '#')     -- bcab
substring('abcabc' similar '#"(abc)*#"' escape '#')  -- abcabc
substring('abcabc' similar '#"abc#"' escape '#')     -- <null>
----

.Siehe auch
<<fblangref30-scalarfuncs-position-de>>, <<fblangref30-scalarfuncs-left-de>>, <<fblangref30-scalarfuncs-right-de>>, <<fblangref30-scalarfuncs-char-length-de>>, <<fblangref30-commons-predsimilarto-de,`SIMILAR TO`>>

[[fblangref30-scalarfuncs-trim-de]]
=== `TRIM()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
TRIM ([<adjust>] _str_)

<adjust> ::=  {[<where>] [_what_]} FROM

<where> ::=  BOTH | LEADING | TRAILING
----

[[fblangref30-funcs-tbl-trim-de]]
.`TRIM`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|where
|Die Position, aus der der Teilstring entfernt werden soll -- `BOTH` {vbar} `LEADING` {vbar} `TRAILING`.
`BOTH` ist die Standardeinstellung

|what
|Die Teilzeichenfolge, die am Anfang, am Ende oder auf beiden Seiten der Eingabezeichenfolge _str_ entfernt werden soll (mehrmals bei mehreren Übereinstimmungen).
Standardmäßig ist es Leerzeichen (`' '`)
|===

Entfernt führende und/oder nachgestellte Leerzeichen (oder optional andere Zeichenfolgen) aus der Eingabezeichenfolge.
Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[NOTE]
====
* Wenn _str_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist es ein `VARCHAR(__n__)` mit _n_ der formalen Länge von _str_.
* Seit Firebird 3.0 wurde die maximale Größe von _what_ -- wenn ein `BLOB -- auf 4 GB erhöht wurde, in früheren Versionen konnte der Wert von _what_ 32.767 Byte nicht überschreiten.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref30-scalarfuncs-trim-exmpl-de]]
==== `TRIM`-Beispiele
[source]
----
select trim ('  Waste no space   ') from rdb$database
-- Ergebnis 'Waste no space'

select trim (leading from '  Waste no space   ') from rdb$database
-- Ergebnis 'Waste no space   '

select trim (leading '.' from '  Waste no space   ') from rdb$database
-- Ergebnis '  Waste no space   '

select trim (trailing '!' from 'Help!!!!') from rdb$database
-- Ergebnis 'Help'

select trim ('la' from 'lalala I love you Ella') from rdb$database
-- Ergebnis ' I love you El'

select trim ('la' from 'Lalala I love you Ella') from rdb$database
-- Ergebnis 'Lalala I love you El'
----

[[fblangref30-scalarfuncs-upper-de]]
=== `UPPER()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
`(VAR)CHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
UPPER (_str_)
----

[[fblangref30-funcs-tbl-upper-de]]
.`UPPER`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs
|===

Gibt das Äquivalent der Eingabezeichenfolge in Großbuchstaben zurück.
Das genaue Ergebnis hängt vom Zeichensatz ab.
Bei `ASCII` oder `NONE` beispielsweise werden nur ASCII-Zeichen groß geschrieben;
mit `OCTETS` wird der gesamte String unverändert zurückgegeben.
Seit Firebird 2.1 unterstützt diese Funktion auch Text-``BLOB``s beliebiger Länge und beliebigem Zeichensatz.

[[fblangref30-scalarfuncs-upper-exmpl-de]]
==== `UPPER`-Beispiele

[source]
----
select upper(_iso8859_1 'Débâcle')
from rdb$database
-- Ergebnis 'DÉBÂCLE' (vor Firebird 2.0: 'DéBâCLE')

select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
-- Ergebnis 'DEBACLE', nach französischen Großbuchstabenregeln
----

.Siehe auch
<<fblangref30-scalarfuncs-lower-de>>

[[fblangref30-functions-datetime-de]]
== Datums- und Zeitfunktionen

[[fblangref30-scalarfuncs-dateadd-de]]
=== `DATEADD()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DATE`, `TIME` oder `TIMESTAMP`

.Syntax
[listing,subs=+quotes]
----
DATEADD (<args>)

<args> ::=
    <amount> <unit> TO <datetime>
  | <unit>, <amount>, <datetime>

<amount> ::= _ein ganzzahliger Ausdruck (negativ zum Subtrahieren)_
<unit> ::=
    YEAR | MONTH | WEEK | DAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<datetime> ::= _ein DATE-, TIME- oder TIMESTAMP-Ausdruck_
----

[[fblangref30-funcs-tbl-dateadd]]
.`DATEADD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|amount
|Ein ganzzahliger Ausdruck vom Typ `SMALLINT`, `INTEGER` oder `BIGINT`.
Für die Einheit `MILLISECOND` ist der Typ `NUMERIC(18, 1)`.
Ein negativer Wert wird abgezogen.

|unit
|Datum/Uhrzeit-Einheit

|datetime
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`
|===

Addiert die angegebene Anzahl von Jahren, Monaten, Wochen, Tagen, Stunden, Minuten, Sekunden oder Millisekunden zu einem Datums-/Uhrzeitwert.

* Der Ergebnistyp wird durch das dritte Argument bestimmt.
* Mit den Argumenten `TIMESTAMP` und `DATE` können alle Einheiten verwendet werden.
* Bei `TIME`-Argumenten können nur `HOUR`, `MINUTE`, `SECOND` und `MILLISECOND` verwendet werden.

[[fblangref30-funcs-tbl-dateadd-exmpl-de]]
==== Beispiele of `DATEADD`

[source]
----
dateadd (28 day to current_date)
dateadd (-6 hour to current_time)
dateadd (month, 9, DateOfConception)
dateadd (-38 week to DateOfBirth)
dateadd (minute, 90, time 'now')
dateadd (? year to date '11-Sep-1973')
----

[source]
----
select
  cast(dateadd(-1 * extract(millisecond from ts) millisecond to ts) as varchar(30)) as t,
  extract(millisecond from ts) as ms
from (
  select timestamp '2014-06-09 13:50:17.4971' as ts
  from rdb$database
) a
----

[listing]
----
T                        MS
------------------------ ------
2014-06-09 13:50:17.0000  497.1
----

.Siehe auch
<<fblangref30-scalarfuncs-datediff-de>>, <<fblangref30-datatypes-datetimeops-de,Operationen mit Datums- und Uhrzeitwerten>>

[[fblangref30-scalarfuncs-datediff-de]]
=== `DATEDIFF()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
DATEDIFF (<args>)

<args> ::=
    <unit> FROM <moment1> TO <moment2>
  | <unit>, <moment1>, <moment2>

<unit> ::=
    YEAR | MONTH | WEEK | DAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<momentN> ::= _ein DATE-, TIME- oder TIMESTAMP-Ausdruck_
----

[[fblangref30-funcs-tbl-datediff-de]]
.`DATEDIFF`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|unit
|Datum/Uhrzeit-Einheit

|moment1
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`

|moment2
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`
|===

Gibt die Anzahl der Jahre, Monate, Wochen, Tage, Stunden, Minuten, Sekunden oder Millisekunden zurück, die zwischen zwei Datums-/Uhrzeitwerten verstrichen sind.
(Die Einheit `WOCHE` ist neu in 2.5.)

* Die Argumente `DATE` und `TIMESTAMP` können kombiniert werden.
Andere Mischungen sind nicht erlaubt.
* Mit den Argumenten `TIMESTAMP` und `DATE` können alle Einheiten verwendet werden.
(Vor Firebird 2.5 waren Einheiten, die kleiner als `DAY` waren, für ``DATE``s nicht zulässig.)
* Bei `TIME`-Argumenten können nur `HOUR`, `MINUTE`, `SECOND` und `MILLISECOND` verwendet werden.

.Berechnung
* `DATEDIFF` betrachtet keine kleineren Einheiten als die im ersten Argument angegebene.
Als Ergebnis,
** `datediff (Jahr, Datum '1-Jan-2009', Datum '31-Dez-2009')` gibt 0 zurück, aber
** `datediff (Jahr, Datum '31-Dez-2009', Datum '1-Jan-2010')' gibt 1 zurück
* Es betrachtet jedoch alle _größeren_ Einheiten. So:
** `datediff (Tag, Datum '26-Jun-1908', Datum '11-Sep-1973')' gibt 23818 zurück
* Ein negativer Ergebniswert bedeutet, dass _moment2_ vor _moment1_ liegt.

[[fblangref30-scalarfuncs-datediff-exmpl-de]]
==== `DATEDIFF`-Beispiele

[source]
----
datediff (hour from current_timestamp to timestamp '12-Jun-2059 06:00')
datediff (minute from time '0:00' to current_time)
datediff (month, current_date, date '1-1-1900')
datediff (day from current_date to cast(? as date))
----

.Siehe auch
<<fblangref30-scalarfuncs-dateadd-de>>, <<fblangref30-datatypes-datetimeops-de,Operationen mit Datums- und Uhrzeitwerten>>

[[fblangref30-scalarfuncs-extract-de]]
=== `EXTRACT()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
`SMALLINT` or `NUMERIC`

.Syntax
[listing,subs=+quotes]
----
EXTRACT (<part> FROM <datetime>)

<part> ::=
    YEAR | MONTH | WEEK
  | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<datetime> ::= _ein DATE-, TIME- oder TIMESTAMP-Ausdruck_
----

[[fblangref30-funcs-tbl-extract-de]]
.`EXTRACT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|part
|Datum/Uhrzeit-Einheit

|datetime
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`
|===

Extrahiert ein Element aus einem `DATE`, `TIME` oder `TIMESTAMP` Ausdruck und gibt es zurück.
Diese Funktion wurde bereits in InterBase 6 hinzugefügt, aber zu diesem Zeitpunkt nicht in der _Sprachreferenz_ dokumentiert.

[[fblangref30-scalarfuncs-extract-types-de]]
==== Zurückgegebene Datentypen und Bereiche

Die zurückgegebenen Datentypen und möglichen Bereiche sind in der folgenden Tabelle aufgeführt.
Wenn Sie versuchen, einen Teil zu extrahieren, der nicht im Datum/Uhrzeit-Argument vorhanden ist (z. B. `SECOND` aus einem `DATE` oder `YEAR` aus einer `TIME`), tritt ein Fehler auf.

[[fblangref30-tbl-extractranges-de]]
.Arten und Bereiche von `EXTRACT`-Ergebnissen
[cols="<1m,<1m,<1,<2", options="header"]
|===
| Teil
| Typ
| Bereich
| Anmerkung

|YEAR
|SMALLINT
|1-9999
|{nbsp}

|MONTH
|SMALLINT
|1-12
|{nbsp}

|WEEK
|SMALLINT
|1-53
|{nbsp}

|DAY
|SMALLINT
|1-31
|{nbsp}

|WEEKDAY
|SMALLINT
|0-6
|0 = Sonntag

|YEARDAY
|SMALLINT
|0-365
|0 = 1. Januar

|HOUR
|SMALLINT
|0-23
|{nbsp}

|MINUTE
|SMALLINT
|0-59
|{nbsp}

|SECOND
|NUMERIC(9,4)
|0.0000-59.9999
|beinhaltet Millisekunden als Bruch

|MILLISECOND
|NUMERIC(9,1)
|0.0-999.9
|fehlerhaft in 2.1, 2.1.1
|===

[[fblangref30-scalarfuncs-extract-millisecond-de]]
==== `MILLISECOND`

Firebird 2.1 und höher unterstützen die Extraktion der Millisekunde aus einer `TIME` oder `TIMESTAMP`.
Der zurückgegebene Datentyp ist `NUMERIC(9,1)`.

[NOTE]
====
Wenn Sie die Millisekunde aus <<fblangref30-contextvars-current-time-de>> extrahieren, beachten Sie, dass diese Variable standardmäßig auf die Sekundengenauigkeit eingestellt ist, sodass das Ergebnis immer 0 ist.
Extrahieren Sie aus `CURRENT_TIME(3)` oder <<fblangref30-contextvars-current-timestamp-de>>, um eine Genauigkeit in Millisekunden zu erhalten.
====

[[fblangref30-scalarfuncs-extract-week-de]]
==== `WEEK`

Firebird 2.1 und höher unterstützen die Extraktion der ISO-8601-Wochennummer aus einem "DATE" oder "TIMESTAMP".
ISO-8601-Wochen beginnen an einem Montag und haben immer die vollen sieben Tage.
Woche 1 ist die erste Woche mit einem Großteil (mindestens 4) der Tage im neuen Jahr.
Die ersten 1-3 Tage des Jahres können zur letzten Woche (52 oder 53) des Vorjahres gehören.
Ebenso können die letzten 1-3 Tage eines Jahres zur ersten Woche des Folgejahres gehören.

[CAUTION]
====
Seien Sie vorsichtig, wenn Sie die Ergebnisse von `WOCHE` und `JAHR` kombinieren.
Zum Beispiel liegt der 30. Dezember 2008 in Woche 1 von 2009, also gibt `extract(week from date '30 Dec 2008')' 1 zurück.
Das Extrahieren von `YEAR` ergibt jedoch immer das Kalenderjahr, das 2008 ist.
In diesem Fall sind "WOCHE" und "JAHR" uneins.
Das gleiche passiert, wenn die ersten Januartage zur letzten Woche des Vorjahres gehören.

Bitte beachten Sie auch, dass `WEEKDAY` _nicht_ ISO-8601-kompatibel ist: Es gibt 0 für Sonntag zurück, während ISO-8601 7 angibt.
====

.Siehe auch
<<fblangref30-datatypes-datetime-de,Datentypen für Datum und Uhrzeit>>

[[fblangref30-functions-casting-de]]
== Typ-Casting-Funktionen

[[fblangref30-scalarfuncs-cast-de]]
=== `CAST()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
Wie von _target_type_ angegeben

.Syntax
[listing,subs="+quotes,macros"]
----
CAST (<expression> AS <target_type>)

<target_type> ::= <domain_or_non_array_type> | <array_datatype>

<domain_or_non_array_type> ::=
  !! Siehe auch <<fblangref30-datatypes-syntax-scalar-syntax-de,Syntax für skalare Datentypen>> !!

<array_datatype> ::=
  !! Siehe auch <<fblangref30-datatypes-syntax-array-de,Syntax der Array-Datentypen>> !!
----

[[fblangref30-funcs-tbl-cast-de]]
.`CAST`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|expression
|SQL-Ausdruck

|sql_datatype
|SQL-Datentyp
|===

`CAST` wandelt einen Ausdruck in den gewünschten Datentyp oder die gewünschte Domäne um.
Wenn die Konvertierung nicht möglich ist, wird ein Fehler ausgegeben.

.Casting ``BLOB``s
Erfolgreiches Casting zu und von ``BLOB``s ist seit Firebird 2.1 möglich.

[[fblangref30-scalarfuncs-shortcast-de]]
==== Syntax für "`Kurzschreibweise`"

Alternative Syntax, die nur unterstützt wird, wenn ein Stringliteral in ein `DATE`, `TIME` oder `TIMESTAMP` umgewandelt wird:

[source]
----
datatype 'date/timestring'
----

Diese Syntax war bereits in InterBase verfügbar, wurde jedoch nie richtig dokumentiert.
Im SQL-Standard heißt diese Funktion "`datetime literals`".

[NOTE]
====
Die kurze Syntax wird sofort beim Parsen ausgewertet, wodurch der Wert unverändert bleibt, bis die Anweisung unvorbereitet ist.
Für Datetime-Literale wie `'12-Oct-2012'` macht dies keinen Unterschied.
Für die Pseudovariablen `'NOW'`, `'YESTERDAY'`, `'TODAY'` und `'TOMORROW'` ist dies möglicherweise nicht das, was Sie wollen.
Wenn der Wert bei jedem Aufruf ausgewertet werden soll, verwenden Sie die vollständige `CAST()`-Syntax.

Firebird 4 verbietet die Verwendung von `'NOW'', `'YESTERDAY'` und `'TOMORROW'` in der Kurzform und erlaubt nur Literale, die einen festen Zeitpunkt definieren.
====

[[fblangref30-scalarfuncs-cast-conv-de]]
==== Zulässige Typumwandlungen

Die folgende Tabelle zeigt die mit `CAST` möglichen Typkonvertierungen.

[[fblangref30-tbl-cast-de]]
.Mögliche Type-Castings mit `CAST`
[%autowidth,cols="2*", options="header", stripes="none"]
|===
| Von
| Nach

|Numerische Typen
|Numerische Typen +
`[VAR]CHAR` +
`BLOB`

|`[VAR]CHAR` +
`BLOB`
| `[VAR]CHAR` +
`BLOB` +
Numerische Typen +
`DATE` +
`TIME` +
`TIMESTAMP`

|`DATE` +
`TIME`
|`[VAR]CHAR` +
`BLOB` +
`TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR` +
`BLOB` +
`DATE` +
`TIME`
|===

Denken Sie daran, dass manchmal Informationen verloren gehen, zum Beispiel wenn Sie einen `TIMESTAMP` in ein `DATE` umwandeln.
Auch die Tatsache, dass Typen ``CAST``-kompatibel sind, ist noch keine Garantie dafür, dass eine Konvertierung erfolgreich ist.
"```CAST(123456789 as SMALLINT)```" führt definitiv zu einem Fehler, ebenso wie "```CAST('Judgement Day' as DATE)```".

[[fblangref30-scalarfuncs-cast-params-de]]
==== Casting-Parameter

Seit Firebird 2.0 können Sie Anweisungsparameter in einen Datentyp umwandeln:

[source]
----
cast (? as integer)
----

Dies gibt Ihnen die Kontrolle über den Typ des Parameters, der von der Engine eingerichtet wird.
Bitte beachten Sie, dass Sie bei Anweisungsparametern immer eine vollständige Syntaxumwandlung benötigen – Kurzformumwandlungen werden nicht unterstützt.

[[fblangref30-scalarfuncs-cast-domain-de]]
==== Casting in eine Domain oder deren Typ

Firebird 2.1 und höher unterstützen das Casting in eine Domäne oder deren Basistyp.
Beim Casting in eine Domain müssen alle für die Domain deklarierten Constraints (`NOT NULL` und/oder `CHECK`) erfüllt sein, sonst schlägt das Casting fehl.
Bitte beachten Sie, dass ein `CHECK` erfolgreich ist, wenn es als `TRUE` _oder_ `NULL` ausgewertet wird!
Also folgende Aussagen gegeben:

[source]
----
create domain quint as int check (value >= 5000);
select cast (2000 as quint) from rdb$database;     -- <1>
select cast (8000 as quint) from rdb$database;     -- <2>
select cast (null as quint) from rdb$database;     -- <3>
----

nur die Besetzungsnummer _1_ führt zu einem Fehler.

Wenn der Modifikator `TYPE OF` verwendet wird, wird der Ausdruck in den Basistyp der Domäne umgewandelt, wobei alle Einschränkungen ignoriert werden.
Mit der oben definierten Domain 'quint' sind die folgenden beiden Casts äquivalent und werden beide erfolgreich sein:

[source]
----
select cast (2000 as type of quint) from rdb$database;
select cast (2000 as int) from rdb$database;
----

Wenn `TYPE OF` mit einem `(VAR)CHAR`-Typ verwendet wird, werden sein Zeichensatz und seine Kollatierung beibehalten:

[source]
----
create domain iso20 varchar(20) character set iso8859_1;
create domain dunl20 varchar(20) character set iso8859_1 collate du_nl;
create table zinnen (zin varchar(20));
commit;
insert into zinnen values ('Deze');
insert into zinnen values ('Die');
insert into zinnen values ('die');
insert into zinnen values ('deze');

select cast(zin as type of iso20) from zinnen order by 1;
-- Ergebnis Deze -> Die -> deze -> die

select cast(zin as type of dunl20) from zinnen order by 1;
-- Ergebnis deze -> Deze -> die -> Die
----

[WARNING]
====
Wenn die Definition einer Domain geändert wird, können bestehende ``CAST``s für diese Domain oder ihr Typ ungültig werden.
Wenn diese ``CAST``s in PSQL-Modulen vorkommen, kann ihre Ungültigkeit erkannt werden.
Siehe Hinweis <<fblangref30-appx01-supp-rdb-validblr-de,[ref]_Das RDB$VALID_BLR-Feld_>> in Anhang A.
====

[[fblangref30-scalarfuncs-cast-coltype-de]]
==== Umwandeln in den Typ einer Spalte

In Firebird 2.5 und höher ist es möglich, Ausdrücke in den Typ einer vorhandenen Tabelle oder Ansichtsspalte umzuwandeln.
Nur der Typ selbst wird verwendet;
bei String-Typen umfasst dies den Zeichensatz, aber nicht die Kollatierung.
Einschränkungen und Standardwerte der Quellspalte werden nicht angewendet.

[source]
----
create table ttt (
  s varchar(40) character set utf8 collate unicode_ci_ai
);
commit;

select cast ('Jag har många vänner' as type of column ttt.s)
from rdb$database;
----

.Warnungen
[WARNING]
====
Wenn die Definition einer Spalte geändert wird, können vorhandene ``CAST``s für den Typ dieser Spalte ungültig werden.
Wenn diese ``CAST``s in PSQL-Modulen vorkommen, kann ihre Ungültigkeit erkannt werden.
Siehe den Hinweis <<fblangref30-appx01-supp-rdb-validblr-de,[ref]_Das RDB$VALID_BLR-Feld_>> in Anhang A.
====

[[fblangref30-scalarfuncs-cast-exmpl-de]]
==== Cast-Beispiele

Ein Vollsyntax Cast:

[source]
----
select cast ('12' || '-June-' || '1959' as date) from rdb$database
----

Eine Kurzschreibweise zur Umwandlung von String zu Datum:

[source]
----
update People set AgeCat = 'Old'
  where BirthDate < date '1-Jan-1943'
----

Beachten Sie, dass Sie sogar die Kurzform aus dem obigen Beispiel weglassen können, da die Engine aus dem Kontext (Vergleich mit einem `DATE`-Feld) versteht, wie die Zeichenfolge zu interpretieren ist:

[source]
----
update People set AgeCat = 'Old'
  where BirthDate < '1-Jan-1943'
----

Aber das ist nicht immer möglich.
Der folgende Cast kann nicht weggelassen werden, sonst würde sich die Engine mit einer Ganzzahl wiederfinden, die von einer Zeichenfolge subtrahiert werden soll:

[source]
----
select date 'today' - 7 from rdb$database
----

[[fblangref30-functions-bitwise-de]]
== Bitweise Funktionen

[[fblangref30-scalarfuncs-bin-and-de]]
=== `BIN_AND()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_AND (_number_, _number_ [, _number_ ...])
----

[[fblangref30-funcs-tbl-binand-de]]
.`BIN_AND`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skalierung 0)
|===

Gibt das Ergebnis der bitweisen _AND_-Operation für die Argumente zurück.

.Siehe auch
<<fblangref30-scalarfuncs-bin-or-de>>, <<fblangref30-scalarfuncs-bin-xor-de>>

[[fblangref30-scalarfuncs-bin-not-de]]
=== `BIN_NOT()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_NOT (_number_)
----

[[fblangref30-funcs-tbl-binnot-de]]
.`BIN_NOT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skala 0)
|===

Gibt das Ergebnis der bitweisen _NOT_-Operation für das Argument zurück, d.h. das _Einser-Komplement_.

.Siehe auch
<<fblangref30-scalarfuncs-bin-or-de>>, <<fblangref30-scalarfuncs-bin-xor-de>> und weitere.

[[fblangref30-scalarfuncs-bin-or-de]]
=== `BIN_OR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_OR (_number_, _number_ [, _number_ ...])
----

[[fblangref30-funcs-tbl-binor-de]]
.`BIN_OR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skalierung 0)
|===

Gibt das Ergebnis der bitweisen _OR_-Operation für die Argumente zurück.

.Siehe auch
<<fblangref30-scalarfuncs-bin-and-de>>, <<fblangref30-scalarfuncs-bin-xor-de>>

[[fblangref30-scalarfuncs-bin-shl-de]]
=== `BIN_SHL()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
BIN_SHL (_number_, _shift_)
----

[[fblangref30-funcs-tbl-binshl-de]]
.`BIN_SHL`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines ganzzahligen Typs

|shift
|Die Anzahl der Bits, um die der Zahlenwert verschoben wird
|===

Gibt das erste Argument bitweise linksverschoben um das zweite Argument zurück, d. h. `a << b` oder `a·2^b^`.

.Siehe auch
<<fblangref30-scalarfuncs-bin-shr-de>>

[[fblangref30-scalarfuncs-bin-shr-de]]
=== `BIN_SHR()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
BIN_SHR (_number_, _shift_)
----

[[fblangref30-funcs-tbl-binshr-de]]
.`BIN_SHR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines ganzzahligen Typs

|shift
|Die Anzahl der Bits, um die der Zahlenwert verschoben wird
|===

Gibt das erste Argument bitweise nach rechts verschoben um das zweite Argument zurück, d. h. `a >> b` oder `a/2^b^`.

* Die ausgeführte Operation ist eine arithmetische Rechtsverschiebung (SAR), dh das Vorzeichen des ersten Operanden bleibt immer erhalten.

.Siehe auch
<<fblangref30-scalarfuncs-bin-shl-de>>

[[fblangref30-scalarfuncs-bin-xor-de]]
=== `BIN_XOR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref30-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_XOR (_number_, _number_ [, _number_ ...])
----

[[fblangref30-funcs-tbl-binxor]]
.`BIN_XOR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skalierung 0)
|===

Gibt das Ergebnis der bitweisen _XOR_-Operation für die Argumente zurück.

.Siehe auch
<<fblangref30-scalarfuncs-bin-and-de>>, <<fblangref30-scalarfuncs-bin-or-de>>

[[fblangref30-functions-uuid-de]]
== UUID Functions

[[fblangref30-scalarfuncs-char-to-uuid-de]]
=== `CHAR_TO_UUID()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`CHAR(16) CHARACTER SET OCTETS`

.Syntax
[listing,subs=+quotes]
----
CHAR_TO_UUID (_ascii_uuid_)
----

[[fblangref30-funcs-tbl-char-to-uuid-de]]
.`CHAR_TO_UUID`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|ascii_uuid
|Eine 36-stellige Darstellung der UUID.
'```-```' (Bindestrich) in den Positionen 9, 14, 19 und 24;
gültige Hexadezimalziffern an beliebigen anderen Stellen, z.B. 'A0bF4E45-3029-2a44-D493-4998c9b439A3'
|===

Konvertiert eine für Menschen lesbare 36-stellige UUID-Zeichenfolge in die entsprechende 16-Byte-UUID.

[[fblangref30-scalarfuncs-char-to-uuid-exmpl-de]]
==== `CHAR_TO_UUID`-Beispiele

[source]
----
select char_to_uuid('A0bF4E45-3029-2a44-D493-4998c9b439A3') from rdb$database
-- Ergebnis A0BF4E4530292A44D4934998C9B439A3 (16-Byte String)

select char_to_uuid('A0bF4E45-3029-2A44-X493-4998c9b439A3') from rdb$database
-- Fehler: - Menschlich lesbares UUID-Argument für CHAR_TO_UUID 
             muss eine Hex-Ziffer an Position 20 anstelle von "X (ASCII 88)" haben
----

.Siehe auch
<<fblangref30-scalarfuncs-uuid-to-char-de>>, <<fblangref30-scalarfuncs-gen-uuid-de>>

[[fblangref30-scalarfuncs-gen-uuid-de]]
=== `GEN_UUID()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`CHAR(16) CHARACTER SET OCTETS`

.Syntax
[listing]
----
GEN_UUID ()
----

Gibt eine universell eindeutige ID als 16-Byte-Zeichenfolge zurück.

[[fblangref30-scalarfuncs-gen-uuid-exmpl-de]]
==== `GEN_UUID`-Beispiel

[source]
----
select gen_uuid() from rdb$database
-- Ergebnis e.g. 017347BFE212B2479C00FA4323B36320 (16-Byte String)
----

.Siehe auch
<<fblangref30-scalarfuncs-uuid-to-char-de>>, <<fblangref30-scalarfuncs-char-to-uuid-de>>

[[fblangref30-scalarfuncs-uuid-to-char-de]]
=== `UUID_TO_CHAR()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`CHAR(36)`

.Syntax
[listing,subs=+quotes]
----
UUID_TO_CHAR (_uuid_)
----

[[fblangref30-funcs-tbl-uuid-to-char-de]]
.`UUID_TO_CHAR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|uuid
|16-Byte UUID
|===

Konvertiert eine 16-Byte-UUID in ihre 36-stellige, für Menschen lesbare ASCII-Darstellung.

[[fblangref30-scalarfuncs-uuid-to-char-exmpl-de]]
==== `UUID_TO_CHAR`-Beispiele

[source]
----
select uuid_to_char(x'876C45F4569B320DBCB4735AC3509E5F') from rdb$database
-- Ergebnis '876C45F4-569B-320D-BCB4-735AC3509E5F'

select uuid_to_char(gen_uuid()) from rdb$database
-- Ergebnis e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

select uuid_to_char('Firebird swings!') from rdb$database
-- Ergebnis '46697265-6269-7264-2073-77696E677321'
----

.Siehe auch
<<fblangref30-scalarfuncs-char-to-uuid-de>>, <<fblangref30-scalarfuncs-gen-uuid-de>>

[[fblangref30-functions-generators-de]]
== Funktionen für Sequenzen (Generatoren)

[[fblangref30-scalarfuncs-gen-id-de]]
=== `GEN_ID()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
GEN_ID (_generator-name_, _step_)
----

[[fblangref30-funcs-tbl-gen-id-de]]
.`GEN_ID`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|generator-name
|Name eines vorhandenen Generators (Sequenz).
Wenn er in doppelten Anführungszeichen mit einem Bezeichner definiert wurde, bei dem die Groß-/Kleinschreibung beachtet wird, muss er in derselben Form verwendet werden, es sei denn, der Name wird ausschließlich in Großbuchstaben geschrieben.

|step
|Ein ganzzahliger Ausdruck
|===

Erhöht einen Generator oder eine Sequenz und gibt den neuen Wert zurück.
Wenn Schritt gleich 0 ist, lässt die Funktion den Wert des Generators unverändert und gibt seinen aktuellen Wert zurück.
 
* Ab Firebird 2.0 wird die SQL-kompatible Syntax <<fblangref30-commons-conditional-nxtvlufor-de,`NEXT VALUE FOR`>> bevorzugt, außer wenn eine andere Erhöhung als 1 benötigt wird.

[WARNING]
====
Wenn der Wert des Schrittparameters kleiner als Null ist, wird der Wert des Generators verringert.
Achtung! Bei solchen Manipulationen in der Datenbank sollten Sie äußerst vorsichtig sein, da sie die Datenintegrität beeinträchtigen könnten.
====

[[fblangref30-scalarfuncs-gen-id-exmpl-de]]
==== `GEN_ID`-Beispiel

[source]
----
new.rec_id = gen_id(gen_recnum, 1);
----

.Siehe auch
<<fblangref30-commons-conditional-nxtvlufor-de,`NEXT VALUE FOR`>>, <<fblangref30-ddl-sequence-create-de,`CREATE SEQUENCE (GENERATOR)`>>

[[fblangref30-functions-conditional-de]]
== Bedingte Funktionen

[[fblangref30-scalarfuncs-coalesce-de]]
=== `COALESCE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing]
----
COALESCE (<exp1>, <exp2> [, <expN> ... ])
----

[[fblangref30-funcs-tbl-coalesce]]
.`COALESCE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exp1, exp2 ... expN
|Eine Liste von Ausdrücken aller kompatiblen Typen
|===

Die Funktion `COALESCE` nimmt zwei oder mehr Argumente und gibt den Wert des ersten Nicht-``NULL``-Arguments zurück.
Wenn alle Argumente `NULL` ergeben, ist das Ergebnis `NULL`.

[[fblangref30-scalarfuncs-coalesce-exmpl-de]]
==== `COALESCE`-Beispiele

Dieses Beispiel wählt den `Nickname` aus der `Persons`-Tabelle.
Wenn es `NULL` ist, geht es weiter zu `FirstName`.
Ist auch dieser `NULL`, wird "```'Mr./Mrs.'```" verwendet.
Schließlich fügt es den Familiennamen hinzu.
Insgesamt wird versucht, aus den verfügbaren Daten einen möglichst informellen vollständigen Namen zusammenzustellen.
Beachten Sie, dass dieses Schema nur funktioniert, wenn fehlende Spitznamen und Vornamen wirklich `NULL` sind: Wenn einer von ihnen stattdessen ein leerer String ist, wird `COALESCE` diesen glücklich an den Aufrufer zurückgeben.

[source]
----
select
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
    as FullName
from Persons
----

.Siehe auch
<<fblangref30-scalarfuncs-iif-de>>, <<fblangref30-scalarfuncs-nullif-de>>, <<fblangref30-commons-conditional-case-de,`CASE`>>

[[fblangref30-scalarfuncs-decode-de]]
=== `DECODE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing]
----
DECODE(<testexpr>,
  <expr1>, <result1>
  [<expr2>, <result2> …]
  [, <defaultresult>])
----

Das äquivalente `CASE`-Konstrukt:

[listing]
----
CASE <testexpr>
  WHEN <expr1> THEN <result1>
  [WHEN <expr2> THEN <result2> …]
  [ELSE <defaultresult>]
END
----

[[fblangref30-funcs-tbl-decode-de]]
.`DECODE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|testexpr
|Ein Ausdruck eines beliebigen kompatiblen Typs, der mit den Ausdrücken expr1, expr2 ... exprN . verglichen wird

|expr1, expr2, ... exprN
|Ausdrücke beliebiger kompatibler Typen, mit denen der Ausdruck _testexpr_ verglichen wird

|result1, result2, ... resultN
|Rückgabewerte jeglichen Typs

|defaultresult
|Der Ausdruck, der zurückgegeben werden soll, wenn keine der Bedingungen erfüllt ist
|===

`DECODE` ist eine Abkürzung für das sogenannte <<fblangref30-commons-conditional-case-simple-de,"`Einfaches ``CASE```"-Konstrukt>>, in dem ein gegebener Ausdruck mit einer Anzahl von andere Ausdrücke, bis eine Übereinstimmung gefunden wird.
Das Ergebnis wird durch den Wert bestimmt, der nach dem übereinstimmenden Ausdruck aufgeführt ist.
Wenn keine Übereinstimmung gefunden wird, wird das Standardergebnis zurückgegeben, falls vorhanden.
Andernfalls wird `NULL` zurückgegeben.

[CAUTION]
====
Der Abgleich erfolgt mit dem Operator '```=```'. Wenn also _testexpr_ `NULL` ist, wird es mit keinem der __expr__s übereinstimmen, nicht einmal mit denen, die `NULL` sind.
====

[[fblangref30-scalarfuncs-decode-exmpl-de]]
==== `DECODE`-Beispiele

[source]
----
select name,
  age,
  decode(upper(sex),
         'M', 'Male',
         'F', 'Female',
         'Unknown'),
  religion
from people
----

.Siehe auch
<<fblangref30-commons-conditional-case-de,`CASE`>>, <<fblangref30-commons-conditional-case-simple-de,Einfaches `CASE`>>

[[fblangref30-scalarfuncs-iif-de]]
=== `IIF()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing,subs=+quotes]
----
IIF (<condition>, _ResultT_, _ResultF_)
----

[[fblangref30-funcs-tbl-iif-de]]
.`IIF`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|condition
|Ein wahrer{vbar}falscher Ausdruck

|resultT
|Der zurückgegebene Wert, wenn die Bedingung wahr ist

|resultF
|Der zurückgegebene Wert, wenn die Bedingung falsch ist
|===

`IIF` benötigt drei Argumente.
Wenn das erste Argument `true` ergibt, wird das zweite Argument zurückgegeben;
andernfalls wird die dritte zurückgegeben.

`IIF` könnte in C-ähnlichen Sprachen mit dem ternären Operator "```?:```" verglichen werden.

[NOTE]
====
`IIF(<Cond>, __Result1__, __Result2__)` ist eine Abkürzung für "```CASE WHEN <Cond> THEN __Result1__ ELSE __Result2__ END```".
====

[[fblangref30-scalarfuncs-iif-exmpl-de]]
==== `IIF`-Beispiele

[source]
----
select iif( sex = 'M', 'Sir', 'Madam' ) from Customers
----

.Siehe auch
<<fblangref30-commons-conditional-case-de,`CASE`>>, <<fblangref30-scalarfuncs-decode-de>>

[[fblangref30-scalarfuncs-maxvalue-de]]
=== `MAXVALUE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Variiert je nach Eingabe -- das Ergebnis hat denselben Datentyp wie der erste Ausdruck in der Liste (_expr1_).

.Syntax
[listing]
----
MAXVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref30-funcs-tbl-maxvalue]]
.`MAXVALUE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|expr1 ... exprN
|Liste der Ausdrücke kompatibler Typen
|===

Gibt den Höchstwert aus einer Liste von numerischen, Zeichenfolgen- oder Datums-/Uhrzeitausdrücken zurück.
Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

Wenn ein oder mehrere Ausdrücke in `NULL` aufgelöst werden, gibt `MAXVALUE` `NULL` zurück.
Dieses Verhalten unterscheidet sich von der Aggregatfunktion `MAX`.

[[fblangref30-scalarfuncs-maxvalue-exmpl-de]]
==== `MAXVALUE`-Beispiele

[source]
----
SELECT MAXVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
----

.Siehe auch
<<fblangref30-scalarfuncs-minvalue-de>>

[[fblangref30-scalarfuncs-minvalue-de]]
=== `MINVALUE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Variiert je nach Eingabe -- das Ergebnis hat denselben Datentyp wie der erste Ausdruck in der Liste (_expr1_).

.Syntax
[listing]
----
MINVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref30-funcs-tbl-minvalue-de]]
.`MINVALUE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|expr1 ... exprN
|Liste der Ausdrücke kompatibler Typen
|===

Gibt den Mindestwert aus einer Liste von numerischen, Zeichenfolgen- oder Datums-/Uhrzeitausdrücken zurück.
Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

Wenn ein oder mehrere Ausdrücke in `NULL` aufgelöst werden, gibt `MINVALUE` `NULL` zurück.
Dieses Verhalten unterscheidet sich von der Aggregatfunktion `MIN`.

[[fblangref30-scalarfuncs-minvalue-exmpl-de]]
==== `MINVALUE`-Beispiele

[source]
----
SELECT MINVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
----

.Siehe auch
<<fblangref30-scalarfuncs-maxvalue-de>>

[[fblangref30-scalarfuncs-nullif-de]]
=== `NULLIF()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing]
----
NULLIF (<exp1>, <exp2>)
----

[[fblangref30-funcs-tbl-nullif-de]]
.`NULLIF`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exp1
|Ein Ausdruck

|exp2
|Ein anderer Ausdruck eines Datentyps, der mit _exp1_ kompatibel ist
|===

`NULLIF` gibt den Wert des ersten Arguments zurück, es sei denn, es ist gleich dem zweiten.
In diesem Fall wird `NULL` zurückgegeben.


[[fblangref30-scalarfuncs-nullif-exmpl-de]]
==== `NULLIF`-Beispiel

[source]
----
select avg( nullif(Weight, -1) ) from FatPeople
----

Dadurch wird das durchschnittliche Gewicht der in FatPeople aufgelisteten Personen zurückgegeben, mit Ausnahme derer mit einem Gewicht von -1, da "AVG" "NULL"-Daten überspringt.
Vermutlich bedeutet -1 in dieser Tabelle "`Gewicht unbekannt`".
Ein einfaches `AVG(Weight)` würde die -1 Gewichte enthalten, wodurch das Ergebnis verzerrt wird.

.Siehe auch
<<fblangref30-scalarfuncs-coalesce-de>>, <<fblangref30-scalarfuncs-decode-de>>, <<fblangref30-scalarfuncs-iif-de>>, <<fblangref30-commons-conditional-case-de,`CASE`>>
