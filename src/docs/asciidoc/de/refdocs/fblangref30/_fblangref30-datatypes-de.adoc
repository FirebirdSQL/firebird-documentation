[[fblangref30-datatypes-de]]
= Datentypen und Untertypen

Daten verschiedener Art werden verwendet, um:

* Spalten in einer Datenbanktabelle in der `CREATE TABLE`-Anweisung definieren oder Spalten mit `ALTER TABLE` ändern
* deklarieren oder ändern Sie eine _Domäne_ mit den Anweisungen `CREATE DOMAIN` oder `ALTER DOMAIN`
* lokale Variablen in Stored Procedures, PSQL-Blöcken und Triggern deklarieren und Parameter in Stored Procedures angeben
* Argumente und Rückgabewerte indirekt angeben, wenn externe Funktionen deklariert werden (UDFs -- benutzerdefinierte Funktionen)
* Argumente für die Funktion `CAST()` bereitstellen, wenn Daten explizit von einem Typ in einen anderen konvertiert werden

[[fblangref30-dtyp-tbl-dtypinfo-de]]
.Übersicht der Datentypen
[cols="<1,<1,<1,<2", options="header",stripes="none"]
|===
^| Name
^| Größe
^| Präzision & Grenzen
^| Beschreibung

|`BIGINT`
|64 Bits
|Von -2^63^ bis (2^63^ - 1)
|Nur in Dialekt 3 verfügbar

|`BLOB`
|unterschiedlich
|Die Größe eines BLOB-Segments ist auf 64K begrenzt.
Die maximale Größe eines BLOB-Feldes sind 4GB.
|Ein Datentyp mit dynamisch unterschiedlicher Größe für die Ablage von großen Datenmengen, wie z.B. Bilder, Texte, Audiodaten.
Die strukturelle Basiseinheit is das Segment.
Der BLOB-Untertyp definiert dessen Inhalt.

|`BOOLEAN`
|8 Bits
|false, true, unknown
|Boolean-Datentyp

|`CHAR(__n__)`, `CHARACTER(__n__)`
|_n_ Zeichen.
Größe in Bytes abhängig von der Encodierung, der Anzahl Bytes pro Zeichen
|von 1 bis 32,767 Bytes
|Ein Datentyp mit fester Länge.
Bei Anzeige der Daten werden Leerzeichen an das Ende der Zeichenkette bis zur angegebenen Länge angefügt.
Die Leerzeichen werden nicht in der Datenbank gespeichert, jedoch wiederhergestellt, um die definierte Länge bei Anzeige am Client zu erreichen.
Die Leerzeichen werden nicht über das Netzwerk versendet, was den Datenverkehr reduziert.
Wurde kein Zeichenlänge angegeben, wird 1 als Standardwert verwendet.

|`DATE`
|32 Bits
|von 01.01.0001 AD bis 31.12.9999 AD
|`ISC_DATE`.
Nur Datum, kein Zeitelement

|`DECIMAL (__precision__, __scale__)`
|Varying (16, 32 or 64 bits)
|_precision_ = von 1 bis 18, legt die mindestmögliche Anzahl zu speichernder Ziffern fest;
_scale) = von 0 bis 18, gibt die Anzahl der Nachkommastellen an.
|Eine Kommazahl mit _scale_ Nachkommastellen.
_scale_ muss kleiner oder gleich -precision_ sein.
Beispiel: `NUMERIC(10,3)` ist eine Zahl im Format: `ppppppp.sss`

|`DOUBLE PRECISION`
|64 Bits
|2.225 * 10^-308^ bis 1.797 * 10^308^
|Doppelte Präzision nach IEEE, ~15 Stellen, zuverlässige Größe hängt von der Plattform ab.

|`FLOAT`
|32 bits
|1.175 * 10^-38^ bis 3.402 * 10^38^
|Einfache Präzision nach IEEE, ~7 Stellen

|`INTEGER`, `INT`
|32 Bits
|-2.147.483.648 up to 2.147.483.647
|Ganzzahlen mit Vorzeichen

|`NUMERIC (__precision__, __scale__)`
|Unterschiedlich (16, 32 oder 64 Bits)
|_precision_ = von 1 bis 18, legt die genaue Anzahl zu speichernder Stellen fest;
_scale_ = von 0 bis 18, legt die Anzahl der Nachkommastellen fest.
|Eine Kommazahl mit _scale_ Nachkommastellen.
_scale_ muss kleiner oder gleich -precision_ sein.
Beispiel: `NUMERIC(10,3)` ist eine Zahl im Format: `ppppppp.sss`

|`SMALLINT`
|16 Bits
|-32.768 bis 32.767
|Ganzzahlen mit Vorzeichen (word)

|`TIME`
|32 Bits
|0:00 to 23:59:59.9999
|`ISC_TIME`.
Tageszeit.
Kann nicht zum Spiechern von Zeitintervallen verwendet werden.

|`TIMESTAMP`
|64 Bits (2 X 32 Bits)
|Von Anfang des Tages 01.01.0001 AD bis Ende des Tages 31.12.9999 AD
|Datum und Uhrzeit eines Tages

|`VARCHAR(__n__)`, `CHAR VARYING`, `CHARACTER VARYING`
|_n_ Zeichen.
Größe in Bytes, abhängig von der Enkodierung, der Anzahl von Bytes für ein Zeichen
|von 1 bis 32,765 Bytes
|Zeichenkette mit variabler Länge.
Die Gesamtgröße der Zeichen darf (32KB-3) nicht übersteigen.
Dies berücksichtigt auch die hinterlegte Enkodierung.
Die beiden hinteren Bytes speichern die deklarierte Länge.
Es gibt keine Standardgröße.
Das Argument _n_ ist erforderlich.
Führende und abschließende Leerzeichen werden gespeichert und nicht abgeschnitten, außer den Leerzeichen, die hinter der definierten Länge liegen.
|===

.Hinweis zu Daten
[NOTE]
====
Beachten Sie, dass eine Zeitreihe, bestehend aus Daten der letzten Jahrhunderte, verarbeitet wird, ohne auf historische Gegebenheiten Rücksicht zu nehmen. Dennoch ist der Gregorianische Kalender komplett anwendbar.
====

[[fblangref30-datatypes-inttypes-de]]
== Ganzzahlen-Datentypen

Die Datentypen `SMALLINT`, `INTEGER` und `BIGINT` werden für Ganzzahlen verschiedener Präzisionen in Dialekt 3 verwendet.
Firebird unterstützt keine vorzeichenlosen (unsigned) Integer.

[[fblangref30-datatypes-smallint-de]]
=== `SMALLINT`

Der 16-Bit-Datentyp "SMALLINT" dient der kompakten Datenspeicherung von Integer-Daten, für die nur ein enger Bereich möglicher Werte benötigt wird.
Zahlen vom Typ `SMALLINT` liegen im Bereich von -2^16^ bis 2^16^ - 1, also von -32.768 bis 32.767.

.`SMALLINT`-Beispiele
[source]
----
CREATE DOMAIN DFLAG AS SMALLINT DEFAULT 0 NOT NULL
  CHECK (VALUE=-1 OR VALUE=0 OR VALUE=1);

CREATE DOMAIN RGB_VALUE AS SMALLINT;
----

[[fblangref30-datatypes-int-de]]
=== `INTEGER`

Der Datentyp `INTEGER` ist eine 32-Bit-Ganzzahl.
Die Kurzbezeichnung des Datentyps lautet 'INT'.
Zahlen vom Typ `INTEGER` liegen im Bereich von -2^32^ bis 2^32^ - 1, also von -2.147.483.648 bis 2.147.483.647.

.`INTEGER`-Beispiele
[source]
----
CREATE TABLE CUSTOMER (
  CUST_NO INTEGER NOT NULL,
  CUSTOMER VARCHAR(25) NOT NULL,
  CONTACT_FIRST VARCHAR(15),
  CONTACT_LAST VARCHAR(20),
  ...
    PRIMARY KEY (CUST_NO) )
----

[[fblangref30-datatypes-bigint-de]]
=== `BIGINT`

`BIGINT` ist ein SQL:99-kompatibler 64-Bit-Integer-Datentyp, der nur in Dialect 3 verfügbar ist.
Wenn ein Client Dialekt 1 verwendet, wird der vom Server gesendete Generatorwert auf eine 32-Bit-Ganzzahl (`INTEGER`) reduziert.
Wenn Dialekt 3 für die Verbindung verwendet wird, ist der Generatorwert vom Typ `BIGINT`.

Zahlen des Typs 'BIGINT' liegen im Bereich von -2^63^ bis 2^63^ - 1, oder von -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.807.

=== Hexadezimales Format für Integer-Zahlen

Ab Firebird 2.5 können Konstanten der drei Integer-Typen im hexadezimalen Format mit 9 bis 16 hexadezimalen Stellen für `BIGINT` bzw. 1 bis 8 Stellen für `INTEGER` angegeben werden.
Die Hex-Darstellung zum Schreiben in `SMALLINT` wird nicht explizit unterstützt, aber Firebird wandelt eine Hex-Zahl bei Bedarf transparent in `SMALLINT` um, sofern sie in den negativen und positiven `SMALLINT`-Bereich fällt.

Die Verwendung und die numerischen Wertebereiche der hexadezimalen Notation werden in der Diskussion zu <<fblangref30-commons-number-constant-de,Zahlenkonstanten>> im Kapitel [ref]_Allgemeine Sprachelemente_ genauer beschrieben.

.Beispiele mit Integer-Typen
[source]
----
CREATE TABLE WHOLELOTTARECORDS (
  ID BIGINT NOT NULL PRIMARY KEY,
  DESCRIPTION VARCHAR(32)
);

INSERT INTO MYBIGINTS VALUES (
  -236453287458723,
  328832607832,
  22,
  -56786237632476,
  0X6F55A09D42,       -- 478177959234
  0X7FFFFFFFFFFFFFFF, -- 9223372036854775807
  0XFFFFFFFFFFFFFFFF, -- -1
  0X80000000,         -- -2147483648, ein INTEGER
  0X080000000,        -- 2147483648, ein BIGINT
  0XFFFFFFFF,         -- -1, ein INTEGER
  0X0FFFFFFFF         -- 4294967295, ein BIGINT
);
----

Die hexadezimalen ``INTEGER``s im obigen Beispiel werden automatisch in `BIGINT` umgewandelt, bevor sie in die Tabelle eingefügt werden.
Dies geschieht jedoch _nach_ der Zahlenwert ermittelt wurde, also werden `0x80000000` (8 Stellen) und `0x080000000` (9 Stellen) als unterschiedliche `BIGINT` Werte gespeichert.

[[fblangref30-datatypes-floattypes-de]]
== Gleitkomma-Datentypen

Gleitkomma-Datentypen werden in einem binären IEEE 754-Format gespeichert, das Vorzeichen, Exponent und Mantisse umfasst.
Die Genauigkeit ist dynamisch und entspricht dem physischen Speicherformat des Werts, das genau 4 Byte für den Typ "FLOAT" und 8 Byte für "DOUBLE PRECISION" beträgt.

Angesichts der Besonderheiten beim Speichern von Gleitkommazahlen in einer Datenbank werden diese Datentypen nicht zum Speichern von Gelddaten empfohlen.
Aus den gleichen Gründen werden Spalten mit Gleitkommadaten nicht für die Verwendung als Schlüssel oder für die Anwendung von Eindeutigkeitsbeschränkungen empfohlen.

Zum Testen von Daten in Spalten mit Gleitkomma-Datentypen sollten Ausdrücke anhand eines Bereichs, beispielsweise `BETWEEN`, prüfen, anstatt nach genauen Übereinstimmungen zu suchen.

Bei der Verwendung dieser Datentypen in Ausdrücken ist bei der Rundung der Auswertungsergebnisse äußerste Vorsicht geboten.

[[fblangref30-datatypes-float-de]]
=== `FLOAT`

Der Datentyp `FLOAT` hat eine ungefähre Genauigkeit von 7 Stellen nach dem Komma.
Um die Sicherheit der Lagerung zu gewährleisten, verlassen Sie sich auf 6 Ziffern.

[[fblangref30-datatypes-double-de]]
=== `DOUBLE PRECISION`

Der Datentyp "DOUBLE PRECISION" wird mit einer ungefähren Genauigkeit von 15 Stellen gespeichert.

[[fblangref30-datatypes-fixedtypes-de]]
== Festkomma-Datentypen

Festkomma-Datentypen stellen die Vorhersagbarkeit von Multiplikations- und Divisionsoperationen sicher und machen sie zur ersten Wahl zum Speichern von Geldwerten.
Firebird implementiert zwei Festkomma-Datentypen: `NUMERIC` und `DECIMAL`.
Beide Typen begrenzen laut Norm die gespeicherte Zahl auf die angegebene Skala (die Anzahl der Nachkommastellen).

Unterschiedliche Behandlungen begrenzen die Genauigkeit für jeden Typ: Die Genauigkeit für `NUMERIC`-Spalten ist genau „`wie deklariert`“, während `DECIMAL`-Spalten Zahlen akzeptieren, deren Genauigkeit mindestens der Deklaration entspricht.

HINWEIS: Das Verhalten von `NUMERIC` und `DECIMAL` in Firebird entspricht dem SQL-Standard `DECIMAL`;
die Genauigkeit entspricht mindestens der Deklaration.

Beispielsweise definiert `NUMERIC(4, 2)` eine Zahl, die insgesamt aus vier Ziffern besteht, einschließlich zweier Nachkommastellen;
das heißt, er kann bis zu zwei Ziffern vor dem Punkt und nicht mehr als zwei Ziffern nach dem Punkt haben.
Wird in eine Spalte mit dieser Datentypdefinition die Zahl 3.1415 geschrieben, wird der Wert 3.14 in der Spalte `NUMERIC(4, 2)` gespeichert.

Die Deklarationsform für Festkommadaten, zB `NUMERIC(p, s)`, ist beiden Typen gemeinsam.
Es ist wichtig zu wissen, dass das Argument `s` in dieser Vorlage _scale_ ist und nicht "`eine Anzahl von Stellen nach dem Komma`".
Das Verständnis des Mechanismus zum Speichern und Abrufen von Festkommadaten sollte dabei helfen, zu veranschaulichen, warum: Zum Speichern wird die Zahl mit 10^s^ (10 hoch `s`) multipliziert und in eine ganze Zahl umgewandelt;
beim Lesen wird die ganze Zahl zurückkonvertiert.

Die Methode zum Speichern von Festkommadaten im DBMS hängt von mehreren Faktoren ab: Deklarierte Genauigkeit, Datenbankdialekt, Deklarationstyp.

[[fblangref30-dtyp-tbl-realnums-de]]
.Methode der physischen Speicherung für reelle Zahlen
[cols="<2,<3,<3,<3", options="header",stripes="none"]
|===
^| Skalierung
^| Datentyp
^| Dialekt 1
^| Dialekt 3

|1 - 4
|`NUMERIC`
|`SMALLINT`
|`SMALLINT`

|1 - 4
|`DECIMAL`
|`INTEGER`
|`INTEGER`

|5 - 9
|`NUMERIC` oder `DECIMAL`
|`INTEGER`
|`INTEGER`

|10 - 18
|`NUMERIC` oder `DECIMAL`
|`DOUBLE PRECISION`
|`BIGINT`
|===

[[fblangref30-datatypes-numeric-de]]
=== `NUMERIC`

.Datenformat für die Deklaration
[listing,subs=+quotes]
----
  NUMERIC
| NUMERIC(_precision_)
| NUMERIC(_precision_, _scale_)
----

[[fblangref30-datatypes-numerictbl-de]]
.`NUMERIC`-Typparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|precision
|Präzision zwischen 1 und 18.
Standardmäßig auf 9.

|scale
|Skala, zwischen 0 und _scale_.
Standardmäßig auf 0.
|===

.Speicherbeispiele
Zusätzlich zu der obigen Erläuterung speichert das DBMS "NUMERISCHE" Daten gemäß der deklarierten _Präzision_ und _Skala_.
Einige weitere Beispiele sind:

[listing,subs=+quotes]
----
NUMERIC(4) gespeichert als SMALLINT (genaue Daten)
NUMERIC(4,2)               SMALLINT (Daten * 10^2^)
NUMERIC(10,4) (Dialekt 1)  DOUBLE PRECISION
              (Dialekt 3)  BIGINT (Daten * 10^4^)
----

[CAUTION]
====
Denken Sie immer daran, dass das Speicherformat von der Genauigkeit abhängt.
Zum Beispiel definieren Sie den Spaltentyp als `NUMERIC(2,2)` unter der Annahme, dass sein Wertebereich -0,99...0,99 beträgt.
Der tatsächliche Wertebereich für die Spalte beträgt jedoch -327,68..327,67, was darauf zurückzuführen ist, dass der Datentyp `NUMERIC(2,2)` im `SMALLINT`-Format gespeichert ist.
Im Speicher sind die Datentypen `NUMERIC(4,2)`, `NUMERIC(3,2)` und `NUMERIC(2,2)` tatsächlich gleich.
Das heißt, wenn Sie wirklich Daten in einer Spalte mit dem Datentyp `NUMERIC(2,2)` speichern und den Bereich auf -0,99...0,99 begrenzen möchten, müssen Sie dafür eine Einschränkung erstellen.
====

[[fblangref30-datatypes-decimal-de]]
=== `DECIMAL`

.Datendeklarationsformat
[listing,subs=+quotes]
----
  DECIMAL
| DECIMAL(_precision_)
| DECIMAL(_precision_, _scale_)
----

[[fblangref30-datatypes-decimaltbl-de]]
.`DECIMAL`-Typparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|precision
|Präzision zwischen 1 und 18.
Standardmäßig auf 9.

|scale
|Skala, zwischen 0 und _scale_.
Standardmäßig auf 0.
|===

.Speicherbeispiele
Das Speicherformat in der Datenbank für `DECIMAL` ist `NUMERIC` sehr ähnlich, mit einigen Unterschieden, die anhand einiger weiterer Beispiele leichter zu erkennen sind:

[listing,subs=+quotes]
----
DECIMAL(4) gespeichert als INTEGER (exact data)
DECIMAL(4,2)               INTEGER (data * 10^2^)
DECIMAL(10,4) (Dialekt 1)  DOUBLE PRECISION
              (Dialekt 3)  BIGINT (data * 10^4^)
----

[[fblangref30-datatypes-datetime-de]]
== Datentypen für Datum und Uhrzeit

Die Datentypen `DATE`, `TIME` und `TIMESTAMP` werden verwendet, um mit Daten zu arbeiten, die Datums- und Uhrzeitangaben enthalten.
Dialekt 3 unterstützt alle drei Typen, während Dialekt 1 nur `DATUM` hat.
Der `DATE`-Typ in Dialekt 3 ist "`nur Datum`", während der `DATE`-Typ von Dialekt 1 sowohl Datum als auch Uhrzeit speichert, was `TIMESTAMP` in Dialekt 3 entspricht.
Dialekt 1 hat keinen Typ "`nur Datum`".

[NOTE]
====
Dialekt 1 `DATE` Daten können alternativ als `TIMESTAMP` definiert werden und dies wird für neue Definitionen in Dialekt 1 Datenbanken empfohlen.
====

. Sekundenbruchteile
Wenn Sekundenbruchteile in Datums- und Zeitdatentypen gespeichert sind, speichert Firebird sie auf Zehntausendstelsekunden.
Wenn eine niedrigere Granularität bevorzugt wird, kann der Bruchteil in Dialekt-3-Datenbanken von ODS 11 oder höher explizit als Tausendstel, Hundertstel oder Zehntelsekunden angegeben werden.

.Einige nützliche Informationen über die Genauigkeit im Sekundenbereich:
[NOTE]
====
Der Zeitteil von `TIME` oder `TIMESTAMP` ist ein 4-Byte-WORD, mit Platz für Dezimillisekunden-Genauigkeit und Zeitwerte werden als die Anzahl der seit Mitternacht verstrichenen Dezimillisekunden gespeichert.
Die tatsächliche Genauigkeit von Werten, die in Zeit(stempel)-Funktionen und -Variablen gespeichert oder daraus gelesen werden, beträgt:

* `CURRENT_TIME` ist standardmäßig auf Sekunden genau und kann mit `CURRENT_TIME (0|1|2|3)` bis auf Millisekunden genau angegeben werden
* `CURRENT_TIMESTAMP` Millisekunden-Genauigkeit.
Die Genauigkeit von Sekunden bis Millisekunden kann mit `CURRENT_TIMESTAMP (0|1|2|3)` specified angegeben werden
* Literal `'NOW'`: Millisekunden-Präzision
* Die Funktionen `DATEADD()` und `DATEDIFF()` unterstützen eine Genauigkeit von bis zu Millisekunden.
Dezi-Millisekunden können angegeben werden, sie werden jedoch auf die nächste ganze Zahl gerundet, bevor eine Operation ausgeführt wird
* Die Funktion `EXTRACT()` gibt mit den Argumenten `SECOND` und `MILLISECOND` eine Genauigkeit von Dezi-Millisekunden zurück
* Für _TIME- und TIMESTAMP-Literale_ akzeptiert Firebird gerne eine Genauigkeit von Dezi-Millisekunden, kürzt (nicht rundet) den Zeitteil jedoch auf die nächste kleinere oder gleiche Millisekunde.
Versuchen Sie zum Beispiel `SELECT TIME '14:37:54.1249' FROM rdb$database`
* die Operatoren '```{plus}```' und '```-```' arbeiten mit Dezimillisekunden-Genauigkeit, aber nur _innerhalb_ des Ausdrucks.
Sobald etwas gespeichert oder auch nur aus `RDB$DATABASE` ausgewählt wird, geht es auf Millisekunden genau zurück

Die Genauigkeit von Dezi-Millisekunden ist selten und wird derzeit nicht in Spalten oder Variablen gespeichert.
Die beste Annahme aus all dem ist, dass, obwohl Firebird `TIME` und die `TIMESTAMP`-Zeitteilwerte als die Anzahl der seit Mitternacht verstrichenen Dezi-Millisekunden (10^-4^ Sekunden) speichert, die tatsächliche Genauigkeit variieren kann von Sekunden bis Millisekunden.
====

[[fblangref30-datatypes-date-de]]
=== `DATE`

Der Datentyp `DATE` in Dialect 3 speichert nur das Datum ohne Uhrzeit.
Der verfügbare Bereich zum Speichern von Daten reicht vom 01. Januar bis zum 31. Dezember 9999.

Dialekt 1 hat keinen Typ "`Nur Datum`".

[TIP]
====
In Dialekt 1 erhalten Datumsliterale ohne Zeitteil sowie `'TODAY'`, `'YESTERDAY'` und `'TOMORROW'` automatisch einen Null-Zeitteil.

Wenn es Ihnen aus irgendeinem Grund wichtig ist, ein Dialekt-1-Zeitstempelliteral mit einem expliziten Zeitteil Null zu speichern, akzeptiert die Engine ein Literal wie `'2016-12-25 00:00:00.0000'`.
Allerdings hätte `'2016-12-25'` genau den gleichen Effekt, mit weniger Tastenanschlägen!
====

[[fblangref30-datatypes-time-de]]
=== `TIME`

Der Datentyp `TIME` ist nur in Dialekt 3 verfügbar.
Es speichert die Tageszeit im Bereich von 00:00:00.0000 bis 23:59:59,9999.

Wenn Sie den Zeitteil von `DATE` in Dialekt 1 benötigen, können Sie die `EXTRACT`-Funktion verwenden.

.Beispiele für die Verwendung von `EXTRACT()`
[source]
----
EXTRACT (HOUR FROM DATE_FIELD)
EXTRACT (MINUTE FROM DATE_FIELD)
EXTRACT (SECOND FROM DATE_FIELD)
----

Siehe auch <<fblangref30-scalarfuncs-extract-de,`EXTRACT()`-Funktion>> im Kapitel [ref]_Eingebaute Funktionen_.

[[fblangref30-datatypes-timestamp-de]]
=== `TIMESTAMP`

Der Datentyp `TIMESTAMP` ist in Dialekt 3 und Dialekt 1 verfügbar.
Es besteht aus zwei 32-Bit-Wörtern – einem Datumsteil und einem Zeitteil – um eine Struktur zu bilden, die sowohl Datum als auch Uhrzeit speichert.
Es ist das gleiche wie der Typ `DATE` in Dialekt 1.

Die Funktion `EXTRACT` funktioniert mit `TIMESTAMP` genauso gut wie mit dem Dialekt 1 `DATE`-Typ.

[[fblangref30-datatypes-datetimeops-de]]
=== Operationen mit Datums- und Uhrzeitwerten

Die Methode der Speicherung von Datums- und Uhrzeitwerten ermöglicht es, diese als Operanden in einige arithmetische Operationen einzubeziehen.
Im Speicher wird ein Datumswert oder ein Datumsteil eines Zeitstempels als die Anzahl von Tagen dargestellt, die seit "`Datum Null`" - 17. November 1898 - verstrichen sind, während ein Zeitwert oder der Zeitteil eines Zeitstempels dargestellt wird als Anzahl der Sekunden (mit Berücksichtigung von Sekundenbruchteilen) seit Mitternacht.

Ein Beispiel ist das Subtrahieren eines früheren Datums, einer früheren Zeit oder eines Zeitstempels von einem späteren, was zu einem Zeitintervall in Tagen und Bruchteilen von Tagen führt.

[[fblangref30-dtyp-tbl-dateops-de]]
.Arithmetische Operationen für Datums- und Uhrzeitdatentypen
[cols="<1,^1,<1,<2", options="header",stripes="none"]
|===
^| Operand 1
^| Operation
^| Operand 2
^| Ergebnis

|`DATE`
|`{plus}`
|`TIME`
|`TIMESTAMP`

|`DATE`
|`{plus}`
|Numerischer Wert `n`
|`DATE` um _n_ ganze Tage erhöht.
Gebrochene Werte werden auf die nächste Ganzzahl gerundet (nicht abgeschnitten).

|`TIME`
|`{plus}`
|`DATE`
|`TIMESTAMP`

|`TIME`
|`{plus}`
|Numerischer Wert `n`
|`TIME` um _n_ Sekunden erhöht.
Bruchteile werden berücksichtigt.

|`TIMESTAMP`
|{plus}
|Numerischer Wert `n`
|`TIMESTAMP`, wobei das Datum um die Anzahl der Tage und der Teil eines Tages durch die Zahl _n_ repräsentiert wird -- somit wird "```+ 2.75```" das Datum um 2 Tage und 18 Stunden weiterstellen wird

|`DATE`
|-
|`DATE`
|Anzahl der vergangenen Tage innerhalb des Bereichs `DECIMAL(9, 0)`

|`DATE`
|-
|Numerischer Wert `n`
|`DATE` um _n_ ganze Tage reduziert.
Gebrochene Werte werden auf die nächste Ganzzahl gerundet (nicht abgeschnitten).

|`TIME`
|-
|`TIME`
|Anzahl der vergangenen Sekunden, innerhalb des Bereichs `DECIMAL(9, 4)`

|`TIME`
|-
|Numerischer Wert `n`
|`TIME` um _n_ Sekunden reduziert.
Bruchteile werden berücksichtigt.

|`TIMESTAMP`
|-
|`TIMESTAMP`
|Anzahl der Tage und der Tageszeit, innerhalb des Bereichs `DECIMAL(18, 9)`

|`TIMESTAMP`
|-
|Numerischer Wert `n`
|`TIMESTAMP` wobei das Datum sich auf der Anzahl der Tage und der Tageszeit beruht, die durch die Zahl _n_ repräsentiert wird -- somit wird "```- 2.25```" das Datum um 2 Tage und 6 Stunden reduzieren.
|===

.Hinweise
[NOTE]
====
Der Typ `DATE` wird in Dialekt 1 als `TIMESTAMP` betrachtet.
====

.Siehe auch
<<fblangref30-scalarfuncs-dateadd-de,`DATEADD`>>, <<fblangref30-scalarfuncs-datediff-de,`DATEDIFF`>>

[[fblangref30-datatypes-chartypes-de]]
== Zeichendatentypen

Für die Arbeit mit Zeichendaten hat Firebird die Datentypen `CHAR` mit fester Länge und `VARCHAR` mit variabler Länge.
Die maximale Größe der in diesen Datentypen gespeicherten Textdaten beträgt 32.767 Byte für 'CHAR' und 32.765 Byte für 'VARCHAR'.
Die maximale Anzahl von _Zeichen_, die in diese Grenzen passt, hängt davon ab, welches `CHARACTER SET` für die betrachteten Daten verwendet wird.
Die Sortierreihenfolge hat keinen Einfluss auf dieses Maximum, kann sich jedoch auf die maximale Größe eines Index auswirken, der die Spalte umfasst.

Wenn beim Definieren eines Zeichenobjekts kein Zeichensatz explizit angegeben wird, wird der beim Erstellen der Datenbank angegebene Standardzeichensatz verwendet.
Wenn in der Datenbank kein Standardzeichensatz definiert ist, erhält das Feld den Zeichensatz `NONE`.

[[fblangref30-datatypes-chartypes-unicode-de]]
=== Unicode

Die meisten aktuellen Entwicklungstools unterstützen Unicode, implementiert in Firebird mit den Zeichensätzen `UTF8` und `UNICODE_FSS`. `UTF8` enthält Kollationen für viele Sprachen.
`UNICODE_FSS` ist eingeschränkter und wird hauptsächlich von Firebird intern zum Speichern von Metadaten verwendet.
Beachten Sie, dass ein `UTF8`-Zeichen bis zu 4 Byte belegt, wodurch die Größe von `CHAR`-Feldern auf 8.191 Zeichen (32.767/4) begrenzt ist.

[NOTE]
====
Der tatsächliche Wert von "`Bytes pro Zeichen`" hängt vom Bereich ab, zu dem das Zeichen gehört.
Lateinische Buchstaben ohne Akzent belegen 1 Byte, kyrillische Buchstaben der Codierung `WIN1251` belegen 2 Byte in `UTF8`, Zeichen anderer Codierungen können bis zu 4 Byte belegen.
====

Der in Firebird implementierte `UTF8`-Zeichensatz unterstützt die neueste Version des Unicode-Standards und empfiehlt daher seine Verwendung für internationale Datenbanken.

[[fblangref30-datatypes-chartypes-client-de]]
=== Client-Zeichensatz

Bei der Arbeit mit Strings ist es wichtig, den Zeichensatz der Client-Verbindung im Auge zu behalten.
Wenn die Zeichensätze der gespeicherten Daten nicht mit denen der Client-Verbindung übereinstimmen, werden die Ausgabeergebnisse für String-Spalten automatisch neu codiert, sowohl beim Senden der Daten vom Client an den Server als auch beim Zurücksenden von der Server an den Client.
Wenn die Datenbank beispielsweise in der Codierung `WIN1251` erstellt wurde, aber `KOI8R` oder `UTF8` in den Verbindungsparametern des Clients angegeben ist, ist die Abweichung transparent.

[[fblangref30-datatypes-chartypes-special-de]]
=== Sonderzeichensätze

.Zeichensatz `NONE`
Der Zeichensatz `NONE` ist ein _Sonderzeichensatz_ in Firebird.
Es kann so charakterisiert werden, dass jedes Byte Teil einer Zeichenkette ist, die Zeichenkette jedoch im System ohne Hinweise darauf gespeichert wird, was ein Zeichen darstellt: Zeichencodierung, Sortierung, Groß-/Kleinschreibung usw. sind einfach unbekannt.
Es liegt in der Verantwortung der Clientanwendung, mit den Daten umzugehen und die Mittel bereitzustellen, um die Bytefolge auf eine für die Anwendung und den menschlichen Benutzer sinnvolle Weise zu interpretieren.

.Zeichensatz `OCTETS`
Daten in der `OCTETS`-Kodierung werden als Bytes behandelt, die möglicherweise nicht wirklich als Zeichen interpretiert werden.
`OCTETS` bietet eine Möglichkeit, Binärdaten zu speichern, die das Ergebnis einiger Firebird-Funktionen sein können.
Die Datenbank-Engine hat keine Vorstellung davon, was sie mit einer Bitfolge in `OCTETS` tun soll, außer sie nur zu speichern und abzurufen.
Auch hier ist die Clientseite dafür verantwortlich, die Daten zu validieren, sie in für die Anwendung und ihre Benutzer sinnvollen Formaten darzustellen und alle Ausnahmen zu behandeln, die sich aus der Decodierung und Codierung ergeben.

[[fblangref30-datatypes-chartypes-collation-de]]
=== Sortierreihenfolge

Jeder Zeichensatz hat eine Standardkollatierungssequenz (`COLLATE`), die die Sortierreihenfolge angibt.
Normalerweise ist dies nichts anderes als eine Sortierung basierend auf dem numerischen Code der Zeichen und eine grundlegende Zuordnung von Groß- und Kleinbuchstaben.
Wenn für Strings ein Verhalten erforderlich ist, das nicht von der Standardsortierreihenfolge bereitgestellt wird, und eine geeignete alternative Kallation für diesen Zeichensatz unterstützt wird, kann eine `COLLATE [replaceable]``collation```-Klausel in der Spaltendefinition angegeben werden.

Eine `COLLATE __collation__`-Klausel kann neben der Spaltendefinition auch in anderen Kontexten angewendet werden.
Für Größer-als/Kleiner-Vergleichsoperationen kann es in der `WHERE`-Klausel einer `SELECT`-Anweisung hinzugefügt werden.
Wenn die Ausgabe in einer speziellen alphabetischen Reihenfolge oder ohne Beachtung der Groß-/Kleinschreibung sortiert werden muss und die entsprechende Sortierung vorhanden ist, kann eine `COLLATE`-Klausel in die `ORDER BY`-Klausel eingefügt werden, wenn Zeilen nach einem Zeichenfeld sortiert werden und mit die `GROUP BY`-Klausel bei Gruppierungsoperationen.

[[fblangref30-datatypes-chartypes-caseinsenstv-de]]
==== Suche ohne Berücksichtigung der Groß-/Kleinschreibung

Für eine Suche ohne Beachtung der Groß-/Kleinschreibung könnte die Funktion `UPPER` verwendet werden, um sowohl das Suchargument als auch die gesuchten Zeichenfolgen in Großbuchstaben umzuwandeln, bevor eine Übereinstimmung versucht wird:

[source]
----
…
where upper(name) = upper(:flt_name)
----

Bei Zeichenfolgen in einem Zeichensatz, der eine Sortierung ohne Beachtung der Groß-/Kleinschreibung zur Verfügung hat, können Sie einfach die Sortierung anwenden, um das Suchargument und die gesuchten Zeichenfolgen direkt zu vergleichen.
Wenn Sie beispielsweise den Zeichensatz `WIN1251` verwenden, ist die Sortierung `PXW_CYRL` zu diesem Zweck unabhängig von der Groß-/Kleinschreibung:

[source]
----
…
WHERE FIRST_NAME COLLATE PXW_CYRL >= :FLT_NAME
…
ORDER BY NAME COLLATE PXW_CYRL
----

.Siehe auch
<<fblangref30-commons-predcontaining-de,`CONTAINING`>>

[[fblangref30-datatypes-chartypes-utf8collations-de]]
==== `UTF8`-Sortierreihenfolgen

Die folgende Tabelle zeigt die möglichen Sortierfolgen für den Zeichensatz `UTF8`.

[[fblangref30-dtyp-tbl-utfcollats-de]]
.Sortierfolgen für Zeichensatz UTF8
[cols="<1,<3", options="header",stripes="none"]
|===
^| Kollation
^| Eigenschaften

|`UCS_BASIC`
|Die Sortierung funktioniert nach der Position des Zeichens in der Tabelle (binär).
In Firebird 2.0 hinzugefügt

|`UNICODE`
|Die Sortierung funktioniert nach dem UCA-Algorithmus (Unicode Collation Algorithm) (alphabetisch).
In Firebird 2.0 hinzugefügt

|`UTF8`
|Die standardmäßige, binäre Sortierung, identisch mit `UCS_BASIC`, die aus Gründen der SQL-Kompatibilität hinzugefügt wurde

|`UNICODE_CI`
|Sortierung ohne Berücksichtigung der Groß-/Kleinschreibung, funktioniert ohne Berücksichtigung der Groß-/Kleinschreibung.
Hinzugefügt in Firebird 2.1

|`UNICODE_CI_AI`
|Groß-/Kleinschreibung, akzentunabhängige Sortierung, arbeitet alphabetisch ohne Berücksichtigung von Groß-/Kleinschreibung oder Akzenten.
Hinzugefügt in Firebird 2.5
|===

.Beispiel
Ein Beispiel für die Sortierung für den UTF8-Zeichensatz ohne Berücksichtigung der Groß-/Kleinschreibung oder der Akzentuierung von Zeichen (ähnlich wie `COLLATE PXW_CYRL`).

[source]
----
...
ORDER BY NAME COLLATE UNICODE_CI_AI
----

[[fblangref30-datatypes-chartypes-charindxs-de]]
=== Zeichenindizes

In Firebird vor Version 2.0 kann ein Problem beim Erstellen eines Indexes für Zeichenspalten auftreten, die eine nicht standardmäßige Kollatierungssequenz verwenden: Die Länge eines indizierten Felds ist auf 252 Byte begrenzt, wenn `COLLATE` nicht angegeben ist, oder 84 Byte, wenn `COLLATE ` ist angegeben.
Multi-Byte-Zeichensätze und zusammengesetzte Indizes begrenzen die Größe noch weiter.

Ab Firebird 2.0 beträgt die maximale Länge für einen Index ein Viertel der Seitengröße, d.h.
von 1.024 -- für Seitengröße 4.096 -- bis 4.096 Bytes -- für Seitengröße 16.384.
Die maximale Länge einer indizierten Zeichenfolge beträgt 9 Byte weniger als diese Viertelseitenbegrenzung.

.Berechnen der maximalen Länge eines indizierten Zeichenfolgenfelds
Die folgende Formel berechnet die maximale Länge einer indizierten Zeichenfolge (in Zeichen):

[source]
----
max_char_length = FLOOR((page_size / 4 - 9) / N)
----

wobei N die Anzahl der Bytes pro Zeichen im Zeichensatz ist.

Die folgende Tabelle zeigt die maximale Länge einer indizierten Zeichenfolge (in Zeichen), je nach Seitengröße und Zeichensatz, berechnet mit dieser Formel.

[[fblangref30-dtyp-tbl-charindxsz-de]]
.Maximale Indexlängen nach Seitengröße und Zeichengröße
[cols=">1,>1,>1,>1,>1,>1",stripes="none"]
|===
.2+^h| Seitengröße
5+^h| Bytes je Zeichen

^h|1
^h|2
^h|3
^h|4
^h|6

|4.096
|1.015
|507
|338
|253
|169

|8.192
|2.039
|1.019
|679
|509
|339

|16.384
|4.087
|2.043
|1.362
|1.021
|682
|===

[NOTE]
====
Bei Sortierungen, bei denen die Groß-/Kleinschreibung nicht beachtet wird ("`++_CI++`"), belegt ein Zeichen im _index_ nicht 4, sondern 6 (sechs) Bytes, sodass die maximale Schlüssellänge für eine Seite von z 169 Zeichen.
====

.Siehe auch
<<fblangref30-ddl-db-create-de,`CREATE DATABASE`>>, <<fblangref30-datatypes-chartypes-collation-de,Sortierreihenfolge>>, <<fblangref30-dml-select-de,`SELECT`>>, <<fblangref30-dml-select-where-de,`WHERE`>>, <<fblangref30-dml-select-groupby-de,`GROUP BY`>>, <<fblangref30-dml-select-orderby-de,`ORDER BY`>>

[[fblangref30-datatypes-chartypes-detail-de]]
=== Zeichenarten im Detail

[[fblangref30-datatypes-chartypes-char-de]]
==== `CHAR`

`CHAR` ist ein Datentyp mit fester Länge.
Wenn die eingegebene Anzahl von Zeichen kleiner als die angegebene Länge ist, werden dem Feld abschließende Leerzeichen hinzugefügt.
Im Allgemeinen muss das Auffüllzeichen kein Leerzeichen sein: Es hängt vom Zeichensatz ab.
Das Füllzeichen für den Zeichensatz `OCTETS` ist beispielsweise null.

Der vollständige Name dieses Datentyps ist `CHARACTER`, aber es ist nicht erforderlich, vollständige Namen zu verwenden, und die Leute tun dies selten.

Zeichendaten mit fester Länge können verwendet werden, um Codes zu speichern, deren Länge Standard ist und eine bestimmte "Breite" in Verzeichnissen hat.
Ein Beispiel für einen solchen Code ist ein EAN13-Barcode – 13 Zeichen, alle ausgefüllt.

.Deklarationssyntax
[listing,subs=+quotes]
----
{CHAR | CHARACTER} [(_length_)]
  [CHARACTER SET <set>] [COLLATE <name>]
----

[NOTE]
====
Wenn keine Länge _length_ angegeben ist, wird sie mit 1 angenommen.

Eine gültige Länge _length_ reicht von 1 bis zur maximalen Anzahl von Zeichen, die innerhalb von 32.767 Bytes untergebracht werden können.

Formal ist die `COLLATE`-Klausel nicht Teil der Datentyp-Deklaration und ihre Position hängt von der Syntax der Anweisung ab.
====

[[fblangref30-datatypes-chartypes-varchar-de]]
==== `VARCHAR`

`VARCHAR` ist der grundlegende Stringtyp zum Speichern von Texten variabler Länge, bis maximal 32.765 Byte.
Die gespeicherte Struktur entspricht der tatsächlichen Größe der Daten plus 2 Byte, wobei die Länge der Daten aufgezeichnet wird.

Alle Zeichen, die von der Clientanwendung an die Datenbank gesendet werden, werden als aussagekräftig angesehen, einschließlich der führenden und abschließenden Leerzeichen.
Nachgestellte Leerzeichen werden jedoch nicht gespeichert: Sie werden beim Abrufen bis zur aufgezeichneten Länge der Zeichenfolge wiederhergestellt.

Der vollständige Name dieses Typs ist `CHARACTER VARYING`.
Eine andere Variante des Namens wird als `CHAR VARYING` geschrieben.

.Syntax
[listing,subs=+quotes]
----
{VARCHAR | {CHAR | CHARACTER} VARYING} (_length_)
  [CHARACTER SET <set>] [COLLATE <name>]
----

[NOTE]
====
Formal ist die `COLLATE`-Klausel nicht Teil der Datentyp-Deklaration und ihre Position hängt von der Syntax der Anweisung ab.
====

[[fblangref30-datatypes-chartypes-nchar-de]]
==== `NCHAR`

`NCHAR` ist ein Zeichendatentyp fester Länge mit dem vordefinierten Zeichensatz `ISO8859_1`.
Ansonsten ist es dasselbe wie `CHAR`.

.Syntax
[listing,subs=+quotes]
----
{NCHAR | NATIONAL {CHAR | CHARACTER}} [(_length_)]
----

[NOTE]
====
Wenn keine Länge _length_ angegeben ist, wird sie mit 1 angenommen.
====

Ein ähnlicher Datentyp ist für den String-Typ variabler Länge verfügbar: `NATIONAL {CHAR | CHARAKTER} VERSCHIEDLICH`.

[[fblangref30-datatypes-booleantypes-de]]
== Boolean-Datentyp

Firebird 3.0 führte einen vollwertigen booleschen Datentyp ein.

[[fblangref30-datatypes-boolean-de]]
=== `BOOLEAN`

Der SQL:2008-konforme Datentyp `BOOLEAN` (8 Bit) umfasst die unterschiedlichen Wahrheitswerte `TRUE` und `FALSE`.
Sofern nicht durch eine `NOT NULL`-Beschränkung verboten, unterstützt der `BOOLEAN`-Datentyp auch den Wahrheitswert `UNKNOWN` als Nullwert.
Die Spezifikation macht keinen Unterschied zwischen dem `NULL`-Wert dieses Datentyps und dem Wahrheitswert `UNKNOWN`, der das Ergebnis eines SQL-Prädikats, einer Suchbedingung oder eines booleschen Wertausdrucks ist: Sie sind austauschbar und bedeuten das gleiche.

Wie bei vielen Programmiersprachen können die `BOOLEAN`-Werte von SQL mit impliziten Wahrheitswerten getestet werden.
Beispielsweise sind `field1 OR field2` und `NOT field1` gültige Ausdrücke.

[[fblangref30-datatypes-boolean-is-de]]
==== Der IS-Operator

Prädikate können den Operator <<fblangref30-commons-isnotboolean-de,Boolean `IS [NOT]`>> zum Abgleich verwenden.
Zum Beispiel `field1 IS FALSE` oder `field1 IS NOT TRUE`.

[NOTE]
====
* Äquivalenzoperatoren ("```=```", "```!=```", "```<>```" und so weiter) sind in allen Vergleichen gültig.
====

[[fblangref30-datatypes-boolean-examples-de]]
==== `BOOLEAN`-Beispiele

. Einfügen und abfragen
+
[source]
----
CREATE TABLE TBOOL (ID INT, BVAL BOOLEAN);
COMMIT;

INSERT INTO TBOOL VALUES (1, TRUE);
INSERT INTO TBOOL VALUES (2, 2 = 4);
INSERT INTO TBOOL VALUES (3, NULL = 1);
COMMIT;

SELECT * FROM TBOOL;
          ID    BVAL
============ =======
           1 <true>
           2 <false>
           3 <null>
----
. Test auf Wert `TRUE`
+
[source]
----
SELECT * FROM TBOOL WHERE BVAL;
          ID    BVAL
============ =======
           1 <true>
----
. Test auf Wert `FALSE`
+
[source]
----
SELECT * FROM TBOOL WHERE BVAL IS FALSE;
          ID    BVAL
============ =======
           2 <false>
----
. Test auf Wert `UNKNOWN`
+
[source]
----
SELECT * FROM TBOOL WHERE BVAL IS UNKNOWN;
          ID    BVAL
============ =======
           3 <null>
----
. Boolean-Werte in `SELECT`-Anweisung
+
[source]
----
SELECT ID, BVAL, BVAL AND ID < 2
  FROM TBOOL;
          ID    BVAL
============ ======= =======
           1 <true>  <true>
           2 <false> <false>
           3 <null>  <false>
----
. PSQL-Deklaration mit Startwert
+
[source]
----
DECLARE VARIABLE VAR1 BOOLEAN = TRUE;
----
. Gültige Syntax, aber wie bei einem Vergleich mit `NULL`, wird nie ein Datensatz zurückgegeben
[source]
----
SELECT * FROM TBOOL WHERE BVAL = UNKNOWN;
SELECT * FROM TBOOL WHERE BVAL <> UNKNOWN;
----

[[fblangref30-datatypes-boolean-othertypes-de]]
===== Verwendung von Boolean gegen andere Datentypen

Obwohl `BOOLEAN` von Natur aus in keinen anderen Datentyp konvertierbar ist, werden ab Version 3.0.1 die Strings `'true'` und `'false'` (Groß-/Kleinschreibung nicht beachtet) in Wertausdrücken implizit in `BOOLEAN` umgewandelt, z.B.

[source]
----
if (true > 'false') then ...
----

`'false'` wird in `BOOLEAN` umgewandelt.
Jeder Versuch, die booleschen Operatoren `AND`, `NOT`, `OR` und `IS` zu verwenden, schlägt fehl.
`NOT 'False'` ist beispielsweise ungültig.

Ein `BOOLEAN` kann mit `CAST` explizit in und aus einem String umgewandelt werden.
`UNKNOWN` ist für keine Form des Castings verfügbar.

.Weitere Hinweise
[NOTE]
====
* Der Typ wird in der API mit dem Typ `FB_BOOLEAN` und den Konstanten `FB_TRUE` und `FB_FALSE` dargestellt.
* Der Wert `TRUE` ist größer als der Wert `FALSE`.
====

[[fblangref30-datatypes-bnrytypes-de]]
== Binärdatentypen

``BLOB``s (Binary Large Objects) sind komplexe Strukturen, die verwendet werden, um Text und binäre Daten undefinierter Länge, oft sehr groß, zu speichern.

.Syntax
[listing]
----
BLOB [SUB_TYPE <subtype>]
  [SEGMENT SIZE <segment size>]
  [CHARACTER SET <character set>]
  [COLLATE <collation name>]
----

.Verkürzte Syntax
[listing]
----
BLOB (<segment size>)
BLOB (<segment size>, <subtype>)
BLOB (, <subtype>)
----

[NOTE]
====
Formal ist die `COLLATE`-Klausel nicht Teil der Datentyp-Deklaration und ihre Position hängt von der Syntax der Anweisung ab.
====

[[fblangref30-datatypes-seg-size-de]]
.Segmentgröße
[sidebar]
Die Angabe der BLOB-Segmentgröße ist ein Rückfall in vergangene Zeiten, als Anwendungen zum Arbeiten mit BLOB-Daten in C (Embedded SQL) mit Hilfe des Pre-Compilers _gpre_ geschrieben wurden.
Heutzutage ist es praktisch irrelevant.
Die Segmentgröße für BLOB-Daten wird von der Clientseite bestimmt und ist in der Regel auf jeden Fall größer als die Datenseitengröße.

[[fblangref30-datatypes-bnrytypes-sub-de]]
=== `BLOB`-Untertypen

Der optionale Parameter `SUB_TYPE` gibt die Art der in die Spalte geschriebenen Daten an.
Firebird bietet zwei vordefinierte Untertypen zum Speichern von Benutzerdaten:

Subtyp 0: `BINARY`::
Wenn kein Subtyp angegeben wird, wird angenommen, dass die Spezifikation für nicht typisierte Daten gilt, und der Standardwert `SUB_TYPE 0` wird angewendet.
Der Alias ​​für den Subtyp null ist `BINARY`.
Dies ist der Untertyp, um anzugeben, ob es sich bei den Daten um eine Binärdatei oder einen Stream handelt: Bilder, Audio, Textverarbeitungsdateien, PDFs usw.

Untertyp 1: `TEXT`::
Subtyp 1 hat einen Alias, `TEXT`, der in Deklarationen und Definitionen verwendet werden kann.
Zum Beispiel `BLOB SUB_TYPE TEXT`.
Es ist ein spezialisierter Untertyp, der verwendet wird, um Nur-Text-Daten zu speichern, die zu groß sind, um in einen String-Typ zu passen.
Ein `CHARACTER SET` kann angegeben werden, wenn das Feld Text mit einer anderen Kodierung als der für die Datenbank angegebenen speichern soll.
Ab Firebird 2.0 wird auch eine `COLLATE`-Klausel unterstützt.
+
Die Angabe eines `CHARACTER SET` ohne `SUB_TYPE` impliziert `SUB_TYPE TEXT`.

.Benutzerdefinierte Untertypen
Es ist auch möglich, benutzerdefinierte Datenuntertypen hinzuzufügen, für die der Aufzählungsbereich von -1 bis -32.768 reserviert ist.
Benutzerdefinierte Subtypen, die mit positiven Zahlen aufgezählt werden, sind nicht zulässig, da die Firebird-Engine die Zahlen ab 2 aufwärts für einige interne Subtypen in Metadaten verwendet.

[[fblangref30-datatypes-bnrytypes-more-de]]
=== `BLOB`-Besonderheiten

.Größe
Die maximale Größe eines 'BLOB'-Feldes ist auf 4 GB begrenzt, unabhängig davon, ob der Server 32-Bit oder 64-Bit ist.
(Die internen Strukturen, die sich auf ``BLOB``s beziehen, unterhalten ihre eigenen 4-Byte-Zähler.)
Bei einer Seitengröße von 4 KB (4096 Byte) ist die maximale Größe geringer – etwas weniger als 2 GB.

.Operationen und Ausdrücke
Text-BLOBs beliebiger Länge und beliebiger Zeichensätze – auch Multibyte – können Operanden für praktisch jede Anweisung oder interne Funktion sein.
Die folgenden Operatoren werden vollständig unterstützt:

[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|=
|(Zuordnung)
|=, <>, <, <=, >, >=
|(Vergeleich)
|`{vbar}{vbar}`
|(Verkettung)
|`BETWEEN`,
|`IS [NOT] DISTINCT FROM`,
|`IN`,
|`ANY` {vbar} `SOME`,
|`ALL`
|{nbsp}
|===

Teilunterstützung:

* Bei diesen tritt ein Fehler auf, wenn das Suchargument größer oder gleich 32 KB ist:
+
[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|`STARTING [WITH]`,
|`LIKE`,
|`CONTAINING`
|{nbsp}
|===
* Aggregationsklauseln wirken sich nicht auf den Inhalt des Feldes selbst aus, sondern auf die BLOB-ID. Abgesehen davon gibt es einige Macken:
+
[%autowidth,cols="2*",frame=none,grid=none,stripes=none]
|===
|`SELECT DISTINCT`
|gibt fälschlicherweise mehrere NULL-Werte zurück, wenn sie vorhanden sind
|`ORDER BY`
|--
|`GROUP BY`
|verkettet dieselben Zeichenfolgen, wenn sie nebeneinander liegen, tut dies jedoch nicht, wenn sie voneinander entfernt sind
|===

.`BLOB`-Speicher
* Standardmäßig wird für jedes BLOB ein regulärer Datensatz erstellt und auf einer ihm zugeordneten Datenseite gespeichert.
Passt das gesamte `BLOB` auf diese Seite, wird es als _level 0 BLOB_ bezeichnet.
Die Nummer dieses Sondersatzes wird im Tabellensatz gespeichert und belegt 8 Byte.
* Wenn ein `BLOB` nicht auf eine Datenseite passt, wird sein Inhalt auf separate, ihm exklusiv zugeordnete Seiten (Blob-Seiten) gelegt, während die Nummern dieser Seiten im `BLOB`-Record gespeichert werden.
Dies ist ein _Level 1 BLOB_.
* Wenn das Array von Seitennummern, das die `BLOB`-Daten enthält, nicht auf eine Datenseite passt, wird das Array auf separate Blob-Seiten gelegt, während die Nummern dieser Seiten in den `BLOB`-Datensatz geschrieben werden.
Dies ist ein _Level-2-BLOB_.
* Level höher als 2 werden nicht unterstützt.

.Siehe auch
<<fblangref30-ddl-filter-de,`FILTER`>>, <<fblangref30-ddl-filter-declare-de,`DECLARE FILTER`>>

[[fblangref30-datatypes-array-de]]
=== `ARRAY`-Datentyp

Die Unterstützung von Arrays im Firebird DBMS ist eine Abkehr vom traditionellen relationalen Modell.
Die Unterstützung von Arrays im DBMS könnte die Lösung einiger Datenverarbeitungsaufgaben mit großen Mengen ähnlicher Daten erleichtern.

Arrays in Firebird werden in `BLOB` eines spezialisierten Typs gespeichert.
Arrays können eindimensional und mehrdimensional sein und jeden Datentyp außer `BLOB` und `ARRAY` haben.

.Beispiel
[source]
----
CREATE TABLE SAMPLE_ARR (
  ID INTEGER NOT NULL PRIMARY KEY,
  ARR_INT INTEGER [4]
);
----

In diesem Beispiel wird eine Tabelle mit einem Feld vom Typ Array erstellt, das aus vier ganzen Zahlen besteht.
Die Indizes dieses Arrays sind von 1 bis 4.

[[fblangref30-datatypes-array-bounds-de]]
==== Angeben von expliziten Grenzen für Bemaßungen

Standardmäßig sind Dimensionen 1-basiert – tiefgestellte Indizes werden ab 1 nummeriert.
Verwenden Sie die folgende Syntax, um explizite Ober- und Untergrenzen der tiefgestellten Werte anzugeben:

[listing]
----
'[' <lower>:<upper> ']'
----

[[fblangref30-datatypes-array-adddim-de]]
==== Hinzufügen weiterer Dimensionen

Eine neue Dimension wird mit einem Komma in der Syntax hinzugefügt.
In diesem Beispiel erstellen wir eine Tabelle mit einem zweidimensionalen Array, wobei die Untergrenze der Indizes in beiden Dimensionen bei Null beginnt:

[source]
----
CREATE TABLE SAMPLE_ARR2 (
  ID INTEGER NOT NULL PRIMARY KEY,
  ARR_INT INTEGER [0:3, 0:3]
);
----

Das DBMS bietet nicht viel an Sprache oder Werkzeugen, um mit dem Inhalt von Arrays zu arbeiten.
Die Datenbank [path]`employee.fdb`, die sich im Verzeichnis [path]`../examples/empbuild` eines Firebird-Distributionspakets befindet, enthält eine gespeicherte Beispielprozedur, die einige einfache Arbeiten mit Arrays zeigt:

==== PSQL-Quelle für `SHOW_LANGS`, eine Prozedur mit einem Array

[source]
----
CREATE OR ALTER PROCEDURE SHOW_LANGS (
  CODE VARCHAR(5),
  GRADE SMALLINT,
  CTY VARCHAR(15))
RETURNS (LANGUAGES VARCHAR(15))
AS
  DECLARE VARIABLE I INTEGER;
BEGIN
  I = 1;
  WHILE (I <= 5) DO
  BEGIN
    SELECT LANGUAGE_REQ[:I]
    FROM JOB
    WHERE (JOB_CODE = :CODE)
      AND (JOB_GRADE = :GRADE)
      AND (JOB_COUNTRY = :CTY)
      AND (LANGUAGE_REQ IS NOT NULL))
    INTO :LANGUAGES;

    IF (LANGUAGES = '') THEN
    /* 'NULL' ANSTELLE VON LEERZEICHEN AUSGEBEN */
      LANGUAGES = 'NULL';
    I = I +1;
    SUSPEND;
  END
END
----

Wenn die beschriebenen Funktionen für Ihre Aufgaben ausreichen, können Sie in Ihren Projekten Arrays verwenden.
Derzeit sind keine Verbesserungen geplant, um die Unterstützung für Arrays in Firebird zu verbessern.

[[fblangref30-datatypes-special-de]]
== Spezielle Datentypen

"`Spezielle`" Datentypen ...

[[fblangref30-datatypes-special-sqlnull-de]]
=== `SQL_NULL`-Datentypen

Der Typ `SQL_NULL` enthält keine Daten, sondern nur einen Zustand: `NULL` oder `NOT NULL`.
Als Datentyp zum Deklarieren von Tabellenfeldern, PSQL-Variablen oder Parameterbeschreibungen steht er nicht zur Verfügung.
Es wurde hinzugefügt, um die Verwendung nicht typisierter Parameter in Ausdrücken zu unterstützen, die das Prädikat `IS NULL` beinhalten.

Ein Auswertungsproblem tritt auf, wenn optionale Filter verwendet werden, um Abfragen des folgenden Typs zu schreiben:

[source]
----
WHERE col1 = :param1 OR :param1 IS NULL
----

Nach der Verarbeitung auf API-Ebene sieht die Abfrage wie folgt aus:

[source]
----
WHERE col1 = ? OR ? IS NULL
----

Dies ist ein Fall, in dem der Entwickler eine SQL-Abfrage schreibt und `:param1` als eine _Variable_ betrachtet, auf die er zweimal verweisen kann.
Auf API-Ebene enthält die Abfrage jedoch zwei separate und unabhängige __Parameter_.
Der Server kann den Typ des zweiten Parameters nicht bestimmen, da er mit `IS NULL` verknüpft ist.

Der Datentyp `SQL_NULL` löst dieses Problem.
Immer wenn die Engine in einer Abfrage auf ein Prädikat "```? IS NULL```" stößt, weist sie dem Parameter den Typ `SQL_NULL` zu, was anzeigt, dass es sich bei dem Parameter nur um "`Nulligkeit`" und den Datentyp handelt oder der Wert muss nicht angesprochen werden.

Das folgende Beispiel zeigt die Anwendung in der Praxis.
Es nimmt zwei benannte Parameter an -- sagen wir `:size` und ``:colour`` -- die zum Beispiel Werte aus Bildschirmtextfeldern oder Dropdown-Listen erhalten können.
Jeder benannte Parameter entspricht zwei Positionsparametern in der Abfrage.

[source]
----
SELECT
  SH.SIZE, SH.COLOUR, SH.PRICE
FROM SHIRTS SH
WHERE (SH.SIZE = ? OR ? IS NULL)
  AND (SH.COLOUR = ? OR ? IS NULL)
----

Um zu erklären, was hier passiert, wird davon ausgegangen, dass der Leser mit der Firebird-API und der Übergabe von Parametern in XSQLVAR-Strukturen vertraut ist -- was unter der Oberfläche passiert, ist für diejenigen nicht von Interesse, die keine Treiber oder Anwendungen schreiben, die mit der "nakten" API kommunizieren.

Die Anwendung übergibt die parametrisierte Anfrage an den Server in der üblichen positionellen `?`-Form.
Paare von "`identischen`" Parametern können nicht zu einem zusammengeführt werden, daher werden beispielsweise für zwei optionale Filter vier Positionsparameter benötigt: einer für jedes `?` in unserem Beispiel.

Nach dem Aufruf von `isc_dsql_describe_bind()` wird der SQLTYPE des zweiten und vierten Parameters auf `SQL_NULL` gesetzt.
Firebird hat keine Kenntnis von ihrer speziellen Beziehung zum ersten und dritten Parameter: Diese Verantwortung liegt vollständig auf der Anwendungsseite.

Nachdem die Werte für Größe und Farbe vom Benutzer festgelegt (oder nicht festgelegt) wurden und die Abfrage ausgeführt werden soll, muss jedes Paar von ``XSQLVAR`s` wie folgt gefüllt werden:

Der Benutzer hat einen Wert angegeben::
Erster Parameter (Wertvergleich): setze `{asterisk}sqldata` auf den angegebenen Wert und `{asterisk}sqlind` auf `0` (für `NOT NULL`)
+
Zweiter Parameter (`NULL` Test): setze `sqldata` auf `null` (Nullzeiger, nicht SQL `NULL`) und `{asterisk}sqlind` auf `0` (für `NOT NULL`)

Der Benutzer hat das Feld leer gelassen::
Beide Parameter: setze `sqldata` auf `null` (Nullzeiger, nicht SQL `NULL`) und `{asterisk}sqlind` auf `-1` (zeigt `NULL`)

Mit anderen Worten: Der Parameter Wertvergleich wird immer wie gewohnt gesetzt.
Der Parameter `SQL_NULL` wird gleich gesetzt, außer dass `sqldata` immer `null` bleibt.

[[fblangref30-datatypes-conversion-de]]
== Konvertierung von Datentypen

Beim Verfassen eines Ausdrucks oder der Angabe einer Operation sollte das Ziel sein, kompatible Datentypen für die Operanden zu verwenden.
Wenn eine Mischung von Datentypen verwendet werden muss, sollten Sie nach einer Möglichkeit suchen, inkompatible Operanden zu konvertieren, bevor Sie sie der Operation unterziehen.
Die Möglichkeit, Daten zu konvertieren, kann durchaus ein Problem darstellen, wenn Sie mit Dialekt-1-Daten arbeiten.

[[fblangref30-datatypes-convert-explicit-de]]
=== Explizite Datentypkonvertierung

Die `CAST`-Funktion ermöglicht die explizite Konvertierung zwischen vielen Paaren von Datentypen.

.Syntax
[listing,subs="+quotes,macros"]
----
CAST (<expression> AS <target_type>)

<target_type> ::= <domain_or_non_array_type> | <array_datatype>

<domain_or_non_array_type> ::=
  !! Vgl. <<fblangref30-datatypes-syntax-scalar-syntax-de,Syntax für Scalardatentypen>> !!

<array_datatype> ::=
  !! Vgl. <<fblangref30-datatypes-syntax-array-de,Syntax für Array-Datentypen>> !!
----

Siehe auch <<fblangref30-scalarfuncs-cast-de,`CAST()`>> im Abschnitt _Eingebaute Skalarfunktionen_.

[[fblangref30-datatypes-convert-domain-de]]
==== Casting auf eine Domain

Beim Casting in eine Domäne werden alle dafür deklarierten Constraints berücksichtigt, d. h. `NOT NULL`- oder `CHECK`-Constraints.
Wenn der _Wert_ die Prüfung nicht besteht, schlägt die Umwandlung fehl.

Wenn zusätzlich `TYPE OF` angegeben wird -- Umwandlung in seinen Basistyp -- werden alle Domäneneinschränkungen während der Umwandlung ignoriert.
Wird `TYPE OF` mit einem Zeichentyp (`CHAR/VARCHAR`) verwendet, bleiben Zeichensatz und Kollatierung erhalten.

[[fblangref30-datatypes-convert-typeof-de]]
==== Casting in `Spaltentyp`

Wenn Operanden in den Typ einer Spalte umgewandelt werden, kann die angegebene Spalte aus einer Tabelle oder einer Sicht stammen.

Es wird nur der Typ der Spalte selbst verwendet.
Bei Zeichentypen enthält die Besetzung den Zeichensatz, aber nicht die Sortierung.
Die Einschränkungen und Standardwerte der Quellspalte werden nicht angewendet.

.Beispiel
[source]
----
CREATE TABLE TTT (
  S VARCHAR (40)
  CHARACTER SET UTF8 COLLATE UNICODE_CI_AI
);
COMMIT;

SELECT
  CAST ('I have many friends' AS TYPE OF COLUMN TTT.S)
FROM RDB$DATABASE;
----

[[fblangref30-datatypes-convert-conversions-de]]
==== Konvertierungen für die `CAST`-Funktion möglich

[[fblangref30-dtyp-tbl-conversions-de]]
.Umwandlungen mit CAST
[cols="<1,<3", options="header",stripes="none"]
|===
^| Von Datentyp
<| Zu Datentyp

|Numerische Typen
|Numerische Typen, `[VAR]CHAR`, `BLOB`

|`[VAR]CHAR`
|`[VAR]CHAR`, `BLOB`, Numerische Typen, `DATE`, `TIME`, `TIMESTAMP`, `BOOLEAN`

|`BLOB`
|`[VAR]CHAR`, `BLOB`, Numerische Typen, `DATE`, `TIME`, `TIMESTAMP`, `BOOLEAN`

|`DATE`, `TIME`
|`[VAR]CHAR`, `BLOB`, `TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR`, `BLOB`, `DATE`, `TIME`

|`BOOLEAN`
|`BOOLEAN`, `[VAR]CHAR`, `BLOB`
|===

Um String-Datentypen in den Typ `BOOLEAN` zu konvertieren, muss der Wert (ohne Berücksichtigung der Groß-/Kleinschreibung) `'true'` oder `'false'` oder `NULL` sein.

[IMPORTANT]
====
Beachten Sie, dass ein teilweiser Informationsverlust möglich ist.
Wenn Sie beispielsweise den Datentyp `TIMESTAMP` in den Datentyp `DATE` umwandeln, geht der Zeitteil verloren.
====

[[fblangref30-datatypes-convert-literalformats-de]]
==== Literale Formate

Um String-Datentypen in die Datentypen `DATE`, `TIME` oder `TIMESTAMP` umzuwandeln, muss das String-Argument eines der vordefinierten Datums- und Uhrzeitliterale sein (siehe xref:fblangref30-dtyp-tbl-keydesc-de[xrefstyle="short"]) oder eine Darstellung des Datums in einem der zulässigen _Datum-Uhrzeit-Literal_-Formate:

 [listing,subs="+quotes,attributes"]
----
<timestamp_format> ::=
    { [__YYYY__<p>{endsb}__MM__<p>__DD__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]
    | __MM__<p>__DD__[<p>__YYYY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | __DD__<p>__MM__[<p>__YYYY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | __MM__<p>__DD__[<p>__YY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | __DD__<p>__MM__[<p>__YY__[<p>__HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]]]
    | NOW
    | TODAY
    | TOMORROW
    | YESTERDAY }

<date_format> ::=
    { [__YYYY__<p>{endsb}__MM__<p>__DD__
    | __MM__<p>__DD__[<p>__YYYY__]
    | __DD__<p>__MM__[<p>__YYYY__]
    | __MM__<p>__DD__[<p>__YY__]
    | __DD__<p>__MM__[<p>__YY__]
    | TODAY
    | TOMORROW
    | YESTERDAY }

<time_format> :=
    { __HH__[<p>__mm__[<p>__SS__[<p>__NNNN__]]]
    | NOW }

<p> ::= whitespace | . | : | , | - | /
----

[[fblangref30-dtyp-tbl-keydesc-de]]
.Datums- und Uhrzeit-Literalformatargumente
[cols="<2,<3", options="header",stripes="none"]
|===
^| Argument
^| Beschreibung

|timestamp_format
|Format des Zeitstempelliterals

|date_literal
|Format des Datumsliterals

|time_literal
|Format des Zeitliterals

|YYYY
|Vierstelliges Jahr

|YY
|Zweistelliges Jahr

|MM
|Monat
Kann 1 oder 2 Stellen enthalten (1-12 oder 01-12).
Sie können auch den aus drei Buchstaben bestehenden Kurznamen oder den vollständigen Namen eines Monats in Englisch angeben.
Groß-/Kleinschreibung nicht beachten

|DD
|Tag.
Es kann 1 oder 2 Stellen enthalten (1-31 oder 01-31)

|HH
|Stunde.
Es kann 1 oder 2 Stellen enthalten (0-23 oder 00-23)

|mm
|Minuten.
Es kann 1 oder 2 Stellen enthalten (0-59 oder 00-59)

|SS
|Sekunden.
Es kann 1 oder 2 Stellen enthalten (0-59 oder 00-59)

|NNNN
|Zehntausendstelsekunden.
Es kann 1 bis 4 Stellen (0-9999) enthalten.

|p
|Ein Trennzeichen, eines der zulässigen Zeichen.
Führende und nachgestellte Leerzeichen werden ignoriert
|===

[[fblangref30-dtyp-tbl-predliterals-de]]
.Literale mit vordefinierten Werten für Datum und Uhrzeit
[cols="<2,<3,<3,<2",stripes="none"]
|===
.2+^h|Literal
.2+^h|Beschreibung
2+^h|Datentyp

^h|Dialekt 1
^h|Dialekt 3

|`'NOW'`
|Aktuelles Datum und Zeit
|`DATE`
|`TIMESTAMP`

|`'TODAY'`
|Aktuelles Datum
|`DATE` mit Nullzeit-Teil
|`DATE`

|`'TOMORROW'`
|Aktualles Datum + 1 (Tag)
|`DATE` mit Nullzeit-Teil
|`DATE`

|`'YESTERDAY'`
|Aktualles Datum - 1 (Tag)
|`DATE` mit Nullzeit-Teil
|`DATE`
|===

[IMPORTANT]
====
Die Verwendung der vollständigen Jahresangabe in vierstelliger Form -- `YYYY` -- wird dringend empfohlen, um Verwirrung bei Datumsberechnungen und Aggregationen zu vermeiden.
====

.Beispielhafte Interpretationen der Datumsliterale
[source]
----
select
  cast('04.12.2014' as date) as d1, -- DD.MM.YYYY
  cast('04 12 2014' as date) as d2, -- MM DD YYYY
  cast('4-12-2014' as date) as d3,  -- MM-DD-YYYY
  cast('04/12/2014' as date) as d4, -- MM/DD/YYYY
  cast('04,12,2014' as date) as d5, -- MM,DD,YYYY
  cast('04.12.14' as date) as d6,   -- DD.MM.YY
  -- DD.MM mit aktuellem Jahr
  cast('04.12' as date) as d7,
  -- MM/DD mit aktuellem Jahr
  cast('04/12' as date) as d8,
  cast('2014/12/04' as date) as d9, -- YYYY/MM/DD
  cast('2014 12 04' as date) as d10, -- YYYY MM DD
  cast('2014.12.04' as date) as d11, -- YYYY.MM.DD
  cast('2014-12-04' as date) as d12, -- YYYY-MM-DD
  cast('4 Jan 2014' as date) as d13, -- DD MM YYYY
  cast('2014 Jan 4' as date) as dt14, -- YYYY MM DD
  cast('Jan 4, 2014' as date) as dt15, -- MM DD, YYYY
  cast('11:37' as time) as t1, -- HH:mm
  cast('11:37:12' as time) as t2, -- HH:mm:ss
  cast('11:31:12.1234' as time) as t3, -- HH:mm:ss.nnnn
  cast('11.37.12' as time) as t4, -- HH.mm.ss
  -- DD.MM.YYYY HH:mm
  cast('04.12.2014 11:37' as timestamp) as dt1,
  -- MM/DD/YYYY HH:mm:ss
  cast('04/12/2014 11:37:12' as timestamp) as dt2,
  -- DD.MM.YYYY HH:mm:ss.nnnn
  cast('04.12.2014 11:31:12.1234' as timestamp) as dt3,
  -- MM/DD/YYYY HH.mm.ss
  cast('04/12/2014 11.37.12' as timestamp) as dt4
from rdb$database
----

[[fblangref30-datatypes-convert-shortcasts-de]]
==== Kurzformumwandlungen für Datums- und Uhrzeitdatentypen

Firebird erlaubt die Verwendung einer abgekürzten Typsyntax im "C-Stil" für Umwandlungen von Strings in die Typen "DATE", "TIME" und "TIMESTAMP".
Der SQL-Standard ruft diese Datetime-Literale auf.

.Syntax
[listing,subs=+quotes]
----
<data_type> '__date_literal_string__'
----

.Beispiel
[source]
----
-- 1
  UPDATE PEOPLE
  SET AGECAT = 'SENIOR'
  WHERE BIRTHDATE < DATE '1-Jan-1943';
-- 2
  INSERT INTO APPOINTMENTS
  (EMPLOYEE_ID, CLIENT_ID, APP_DATE, APP_TIME)
  VALUES (973, 8804, DATE 'today' + 2, TIME '16:00');
-- 3
  NEW.LASTMOD = TIMESTAMP 'now';
----

[NOTE]
====
Diese Kurzausdrücke werden direkt beim Parsen ausgewertet, als ob die Anweisung bereits für die Ausführung vorbereitet wäre.
Selbst wenn die Abfrage mehrmals ausgeführt wird, bleibt der Wert von beispielsweise `timestamp 'now'` gleich, egal wie viel Zeit vergeht.

Wenn die Zeit bei jeder Ausführung ausgewertet werden soll, verwenden Sie die vollständige `CAST`-Syntax.
Ein Beispiel für die Verwendung eines solchen Ausdrucks in einem Trigger:

[source]
----
NEW.CHANGE_DATE = CAST('now' AS TIMESTAMP);
----

Firebird 4 lässt diese impliziten Datetime-Werte wie `'now'', ''today'' usw. in diesen Kurzformumsetzungen nicht mehr zu.
Es ist ratsam, für implizite Werte auf die Verwendung des vollständigen `CAST`-Ausdrucks umzusteigen.
====

[[fblangref30-datatypes-convert-implicit-de]]
=== Implizite Datentypkonvertierung

Eine implizite Datenkonvertierung ist in Dialekt 3 nicht möglich -- die `CAST`-Funktion wird fast immer benötigt, um Datentypkonflikte zu vermeiden.

In Dialekt 1 wird in vielen Ausdrücken ein Typ implizit in einen anderen umgewandelt, ohne dass die CAST-Funktion verwendet werden muss.
Zum Beispiel gilt die folgende Aussage in Dialekt 1:

[source]
----
UPDATE ATABLE
  SET ADATE = '25.12.2016' + 1
----

und das Datumsliteral wird implizit in den Datumstyp umgewandelt.

In Dialekt 3 wird diese Anweisung den Fehler 35544569 ausgeben, "``Dynamic SQL Error: expression evaluation not supported, Strings cannot be added or subtracted in dialect 3`" -- eine Umwandlung ist erforderlich:

[source]
----
UPDATE ATABLE
  SET ADATE = CAST ('25.12.2016' AS DATE) + 1
----

oder mit der kurzen Umwandlung:

[source]
----
UPDATE ATABLE
  SET ADATE = DATE '25.12.2016' + 1
----

In Dialekt 1 ist es normalerweise möglich, ganzzahlige Daten und numerische Zeichenfolgen zu mischen, da der Parser versucht, die Zeichenfolge implizit umzuwandeln.
Beispielsweise,

[source]
----
2 + '1'
----

wird korrekt ausgeführt.

In Dialekt 3 führt ein solcher Ausdruck zu einem Fehler, daher müssen Sie ihn als `CAST`-Ausdruck schreiben:

[source]
----
2 + CAST('1' AS SMALLINT)
----

Die Ausnahme von der Regel ist während der _String-Verkettung_.

[[fblangref30-datatypes-convert-implicit-concat-de]]
==== Implizite Konvertierung während der String-Verkettung

Wenn mehrere Datenelemente verkettet werden, werden alle Nicht-String-Daten nach Möglichkeit implizit in Strings umgewandelt.

.Beispiel
[source]
----
SELECT 30||' days hath September, April, June and November' CONCAT$
  FROM RDB$DATABASE;

CONCAT$
------------------------------------------------
30 days hath September, April, June and November
----

[[fblangref30-datatypes-custom-de]]
== Benutzerdefinierte Datentypen – Domains

In Firebird ist das Konzept eines "`benutzerdefinierten Datentyps`" in Form der _Domain_ implementiert.
Das Erstellen einer Domain erzeugt natürlich nicht wirklich einen neuen Datentyp.
Eine Domain bietet die Möglichkeit, einen vorhandenen Datentyp mit einem Satz von Attributen zu kapseln und diese "`Kapsel`" für die mehrfache Verwendung in der gesamten Datenbank verfügbar zu machen.
Wenn mehrere Tabellen Spalten mit identischen oder nahezu identischen Attributen benötigen, ist eine Domäne sinnvoll.

Die Domänenverwendung ist nicht auf Spaltendefinitionen für Tabellen und Ansichten beschränkt.
Domänen können verwendet werden, um Eingabe- und Ausgabeparameter und Variablen in PSQL-Code zu deklarieren.

[[fblangref30-datatypes-domainattribs-de]]
=== Domaineigenschaften

Eine Domaindefinition enthält erforderliche und optionale Attribute.
Der _Datentyp_ ist ein erforderliches Attribut.
Zu den optionalen Attributen gehören:

* ein Standardwert
* um `NULL` zu erlauben oder zu verbieten
* `CHECK`-Einschränkungen
* Zeichensatz (für Zeichendatentypen und Text-BLOB-Felder)
* Sortierung (für Zeichendatentypen)

.Beispieldomaindefinition
[source]
----
CREATE DOMAIN BOOL3 AS SMALLINT
  CHECK (VALUE IS NULL OR VALUE IN (0, 1));
----

.Siehe auch
<<fblangref30-datatypes-convert-typeof-de,Explizite Datentypumwandlung>> zur Beschreibung von Unterschieden im Datenkonvertierungsmechanismus, wenn Domänen für die Modifikatoren `TYPE OF` und `TYPE OF COLUMN` angegeben werden.

[[fblangref30-datatypes-domainoverride-de]]
=== Domain-Überschreibung

Beim Definieren einer Spalte mithilfe einer Domäne ist es möglich, einige der von der Domäne geerbten Attribute zu überschreiben.
Tabelle 3.9 fasst die Regeln für die Domänenüberschreibung zusammen.

[[fblangref30-dtyp-tbl-domoverride-de]]
.Regeln zum Überschreiben von Domänenattributen in der Spaltendefinition
[cols="<2,<1,<3", options="header",stripes="none"]
|===
^| Attribute
^| Überschreiben?
^| Hinweise

|Datentyp
|Nein
|{nbsp}

|Standardwert
|Ja
|{nbsp}

|Textzeichensatz
|Ja
|Es kann auch verwendet werden, um die Standarddatenbankwerte für die Spalte wiederherzustellen

|Reihenfolge der Textsortierung
|Ja
|{nbsp}

|`CHECK`-Constraints
|Ja
|Um der Prüfung neue Bedingungen hinzuzufügen, können Sie die entsprechenden `CHECK`-Klauseln in den Anweisungen CREATE und ALTER auf Tabellenebene verwenden.

|`NOT NULL`
|Nein
|Oft ist es besser, die Domain in ihrer Definition nullbar zu lassen und zu entscheiden, ob sie auf `NOT NULL` gesetzt werden soll, wenn die Domain zum Definieren von Spalten verwendet wird.
|===

[[fblangref30-datatypes-domaincreate-de]]
=== Erstellen und Verwalten von Domains

Eine Domain wird mit der DDL-Anweisung `CREATE DOMAIN` erstellt.

.Kurzschreibweise
[listing,subs=+quotes]
----
CREATE DOMAIN _name_ [AS] <type>
  [DEFAULT {<const> | <literal> | NULL | <context_var>}]
  [NOT NULL] [CHECK (<condition>)]
  [COLLATE <collation>]
----

.Siehe auch
<<fblangref30-ddl-domn-create-de,`CREATE DOMAIN`>> im Abschnitt Datendefinitionssprache (DDL).

[[fblangref30-datatypes-domainalter-de]]
==== Domain ändern

Um die Attribute einer Domain zu ändern, verwenden Sie die DDL-Anweisung `ALTER DOMAIN`.
Mit dieser Aussage können Sie:

* die Domain umbenennen
* den Datentyp ändern
* den aktuellen Standardwert löschen
* einen neuen Standardwert setzen
* lösche die `NOT NULL`-Beschränkung
* setze die `NOT NULL`-Beschränkung
* eine bestehende `CHECK`-Einschränkung löschen
* füge eine neue `CHECK`-Einschränkung hinzu

.Kurzsyntax
[listing,subs=+quotes]
----
ALTER DOMAIN _name_
  [{TO _new_name_}]
  [{SET DEFAULT { <literal> | NULL | <context_var> } |
    DROP DEFAULT}]
  [{SET | DROP} NOT NULL ]
  [{ADD [CONSTRAINT] CHECK (<dom_condition>) |
    DROP CONSTRAINT}]
  [{TYPE <datatype>}]
----

.Beispiel
[source]
----
ALTER DOMAIN STORE_GRP SET DEFAULT -1;
----

Beim Wechsel einer Domain müssen deren Abhängigkeiten berücksichtigt werden: ob Tabellenspalten, beliebige Variablen, Ein- und/oder Ausgabeparameter mit dem im PSQL-Code deklarierten Typ dieser Domain vorhanden sind.
Wenn Sie Domains in Eile ändern, ohne sie sorgfältig zu überprüfen, funktioniert Ihr Code möglicherweise nicht mehr!

[IMPORTANT]
====
Wenn Sie Datentypen in einer Domain konvertieren, dürfen Sie keine Konvertierungen durchführen, die zu Datenverlusten führen können.
Wenn Sie beispielsweise `VARCHAR` in `INTEGER` konvertieren, prüfen Sie sorgfältig, ob alle Daten, die diese Domain verwenden, erfolgreich konvertiert werden können.
====

.Siehe auch
<<fblangref30-ddl-domn-alter-de,`ALTER DOMAIN`>> im Abschnitt Datendefinitionssprache (DDL).

[[fblangref30-datatypes-domaindrop-de]]
==== Löschen (Dropping) einer Domain

Die DDL-Anweisung `DROP DOMAIN` löscht eine Domain aus der Datenbank, sofern sie nicht von anderen Datenbankobjekten verwendet wird.

.Syntax
[listing,subs=+quotes]
----
DROP DOMAIN _name_
----

[IMPORTANT]
====
Jeder mit der Datenbank verbundene Benutzer kann eine Domäne löschen.
====

.Beispiel
[source]
----
DROP DOMAIN Test_Domain
----

.Siehe auch
<<fblangref30-ddl-domn-drop-de,`DROP DOMAIN`>> im Abschnitt Datendefinitionssprache (DDL).

[[fblangref30-datatypes-syntax-de]]
== Syntax der Datentyp-Deklaration

In diesem Abschnitt wird die Syntax der Deklaration von Datentypen dokumentiert.
Die Datentypdeklaration erfolgt am häufigsten in <<fblangref30-ddl-de,DDL-Anweisungen>>, aber auch in <<fblangref30-datatypes-convert-explicit-de,`CAST`>> und <<fblangref30-dml-execblock-de,`EXECUTE BLOCK`> >.

Auf die unten dokumentierte Syntax wird von anderen Teilen dieser Sprachreferenz verwiesen.

[[fblangref30-datatypes-syntax-scalar-de]]
=== Syntax für Skalardatentypen

Die skalaren Datentypen sind einfache Datentypen, die einen einzelnen Wert enthalten.
Aus organisatorischen Gründen wird die Syntax der BLOB-Typen separat in <<fblangref30-datatypes-syntax-blob-de>> definiert.

[[fblangref30-datatypes-syntax-scalar-syntax-de]]
.Syntax für skalare Datentypen
[listing,subs=+quotes]
----
<domain_or_non_array_type> ::=
    <scalar_datatype>
  | <blob_datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN _rel_._col_

<scalar_datatype> ::=
    SMALLINT | INT[EGER] | BIGINT
  | FLOAT | DOUBLE PRECISION
  | BOOLEAN
  | DATE | TIME | TIMESTAMP
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {VARCHAR | {CHAR | CHARACTER} VARYING} (_length_)
    [CHARACTER SET _charset_]
  | {CHAR | CHARACTER} [(_length_)] [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} VARYING (_length_)
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [(_length_)]
----

[[fblangref30-datatypes-tbl-scalar-syntax-de]]
.Argumente für die Syntax der skalaren Datentypen
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Beschreibung

|domain
|Domain (nur Nicht-Array-Domains)

|rel
|Name einer Tabelle oder Ansicht (View)

|col
|Name einer Spalte in einer Tabelle oder Ansicht (nur Spalten eines Nicht-Array-Typs)

|precision
|Numerische Genauigkeit in Dezimalstellen.
Von 1 bis 18

|scale
|Skalierung oder Anzahl der Dezimalstellen.
Von 0 bis 18.
Sie muss kleiner oder gleich _precision_ sein.

|_length_
|Die maximale Länge einer Zeichenfolge in Zeichen

|charset
|Zeichensatz

|domain_or_non_array_type
|Nicht-Array-Typen, die in PSQL-Code und -Casts verwendet werden können
|===

[[fblangref30-datatypes-syntax-scalar-domns-de]]
==== Verwendung von Domains in Deklarationen

Ein Domainname kann als Typ eines PSQL-Parameters oder einer lokalen Variablen angegeben werden.
Der Parameter oder die Variable erbt alle Domänenattribute.
Wenn für den Parameter oder die Variable ein Standardwert angegeben wird, überschreibt er den in der Domaindefinition angegebenen Standardwert.

Wenn die `TYPE OF`-Klausel vor dem Domainnamen hinzugefügt wird, wird nur der Datentyp der Domain verwendet: alle anderen Attribute der Domain -- `NOT NULL`-Einschränkung, `CHECK`-Einschränkungen, Standardwert -- sind weder geprüft noch benutzt.
Handelt es sich bei der Domain jedoch um einen Texttyp, werden immer deren Zeichensatz und Kollatierungsreihenfolge verwendet.

[[fblangref30-ddl-func-paramscoltype-de]]
==== Verwendung des Spaltentyps in Deklarationen

Ein- und Ausgabeparameter oder lokale Variablen können auch über den Datentyp von Spalten in bestehenden Tabellen und Views deklariert werden.
Dafür wird die `TYPE OF COLUMN`-Klausel verwendet, die __relationname__.__columnname__ als Argument angibt.

Wenn `TYPE OF COLUMN` verwendet wird, erbt der Parameter oder die Variable nur den Datentyp und – bei String-Typen – den Zeichensatz und die Kollatierungssequenz.
Die Einschränkungen und der Standardwert der Spalte werden ignoriert.

[[fblangref30-datatypes-syntax-blob-de]]
=== Syntax der BLOB-Datentypen

Die BLOB-Datentypen enthalten Binär-, Zeichen- oder benutzerdefinierte Formatdaten unbestimmter Größe.
Weitere Informationen finden Sie unter <<fblangref30-datatypes-bnrytypes-de>>.

[[fblangref30-datatypes-syntax-blob-syntax-de]]
.Syntax der BLOB-Datentypen
[listing,subs=+quotes]
----
<blob_datatype> ::=
    BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]
----

[[fblangref30-datatypes-tbl-blob-syntax-de]]
.Argumente für die Syntax der Blob-Datentypen
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Beschreibung

|charset
|Zeichensatz (wird für andere Untertypen als `TEXT`/`1` ignoriert)

|subtype_num
|`BLOB`-Untertypnummer

|subtype_name
|mnemonischer Name des 'BLOB'-Untertyps;
dies kann `TEXT`, `BINARY` oder einer der (anderen) Standard- oder benutzerdefinierten Namen sein, die in `RDB$TYPES` für `RDB$FIELD_NAME = 'RDB$FIELD_SUB_TYPE'` definiert sind.

|seglen
|Segmentgröße, darf nicht größer als 65.535 sein, Standardwert 80, wenn nicht angegeben.
Siehe auch <<fblangref30-datatypes-seg-size>>
|===

[[fblangref30-datatypes-syntax-array-de]]
=== Syntax der Array-Datentypen

Die Array-Datentypen enthalten mehrere Skalarwerte in einem ein- oder mehrdimensionalen Array.
Weitere Informationen finden Sie unter <<fblangref30-datatypes-array>>

[[fblangref30-datatypes-syntax-array-syntax-de]]
.Syntax der Array-Datentypen
[listing,subs="+quotes,attributes"]
----
<array_datatype> ::=
    {SMALLINT | INT[EGER] | BIGINT} <array_dim>
  | {FLOAT | DOUBLE PRECISION} <array_dim>
  | BOOLEAN <array_dim>
  | {DATE | TIME | TIMESTAMP} <array_dim>
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] <array_dim>
  | {VARCHAR | {CHAR | CHARACTER} VARYING} (_length_)
    <array_dim> [CHARACTER SET _charset_]
  | {CHAR | CHARACTER} [(_length_)] <array_dim>
    [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} VARYING (_length_)
    <array_dim>
  | {NCHAR | NATIONAL {CHARACTER | CHAR}}
    [(_length_)] <array_dim>

<array_dim> ::= '[' [_m_:{endsb}__n__ [,[_m_:{endsb}__n__ ...] ']'
----

[[fblangref30-datatypes-tbl-array-syntax-de]]
.Argumente für die Syntax der Array-Datentypen
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Beschreibung

|array_dim
|Array-Dimensionen

|precision
|Numerische Genauigkeit in Dezimalstellen.
Von 1 bis 18

|scale
|Skala oder Anzahl der Dezimalstellen.
Von 0 bis 18.
Sie muss kleiner oder gleich _precision_ sein.

|_length_
|Die maximale Länge einer Zeichenfolge in Zeichen;
optional für Zeichentypen mit fester Breite, standardmäßig 1

|charset
|Zeichensatz

|m, n
|Ganzzahlen, die den Indexbereich einer Array-Dimension definieren
|===
