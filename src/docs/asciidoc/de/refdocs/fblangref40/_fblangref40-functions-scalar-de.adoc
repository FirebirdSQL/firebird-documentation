[[fblangref40-functions-de]]
= Eingebaute Skalarfunktionen

[[fblangref40-functions-nameclashes-de]]
.Upgrader: BITTE LESEN!
****
Eine große Anzahl von Funktionen, die in früheren Versionen von Firebird als externe Funktionen (UDFs) implementiert wurden, wurden schrittweise als interne (eingebaute) Funktionen neu implementiert.
Wenn eine externe Funktion mit dem gleichen Namen wie eine integrierte Funktion in Ihrer Datenbank deklariert ist,  bleibt sie dort und überschreibt alle internen Funktionen desselben Namens.

Um die internen Funktionen verfügbar sind, müssen Sie entweder ein <<fblangref40-ddl-extfunc-drop-de,`DROP`>> der UDF durchführen oder mittels <<fblangref40-ddl-extfunc-alter-de,`ALTER EXTERNAL FUNCTION`>> den Namen der UDF ändern.
****

[[fblangref40-functions-workcontext-de]]
== Kontextfunktionen

[[fblangref40-scalarfuncs-get-context-de]]
=== `RDB$GET_CONTEXT()`

.Verfügbar in
DSQL, PSQL{nbsp}* Als deklariertes UDF sollte es in ESQL verfügbar sein

.Ergebnistyp
`VARCHAR(255)`

.Syntax
[listing,subs=+quotes]
----
RDB$GET_CONTEXT ('<namespace>', <varname>)

<namespace> ::= SYSTEM | USER_SESSION | USER_TRANSACTION | DDL_TRIGGER
<varname>   ::= Eine Zeichenfolge in Anführungszeichen von max. 80 Zeichen
----

[[fblangref40-funcs-tbl-rdbgetcontext-de]]
.`RDB$GET_CONTEXT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|namespace
|Namespace

|varname
|Variablenname.
Groß-/Kleinschreibung beachten.
Die maximale Länge beträgt 80 Zeichen
|===

Ruft den Wert einer Kontextvariablen aus einem der Namespaces `SYSTEM`, `USER_SESSION` und `USER_TRANSACTION` ab.

.Die Namensräume
Die Namensräume `USER_SESSION` und `USER_TRANSACTION` sind zunächst leer.
Der Benutzer kann mit `RDB$SET_CONTEXT()` Variablen darin erstellen und setzen und mit `RDB$GET_CONTEXT()` abrufen.
Der Namespace `SYSTEM` ist schreibgeschützt.
Der Namespace `DDL_TRIGGER` ist nur in DDL-Triggern gültig und schreibgeschützt.
Es enthält eine Reihe vordefinierter Variablen (siehe unten).

.Rückgabewerte und Fehlerverhalten
Existiert die abgefragte Variable im angegebenen Namespace, wird ihr Wert als String von max. 255 Zeichen.
Existiert der Namespace nicht oder versucht man auf eine nicht vorhandene Variable im `SYSTEM`-Namespace zuzugreifen, wird ein Fehler ausgegeben.
Wenn Sie eine nicht vorhandene Variable in einem der anderen Namespaces anfordern, wird `NULL` zurückgegeben.
Sowohl Namespace- als auch Variablennamen müssen in einfachen Anführungszeichen angegeben werden, wobei die Groß-/Kleinschreibung beachtet werden muss, nicht ``NULL``-Strings.

[[fblangref40-funcs-tbl-rdbgetcontext-system-de]]
==== Der `SYSTEM`-Namespace

[[fblangref40-funcs-tbl-systemnamespace-de]]
.Kontextvariablen im SYSTEM-Namensraum
`CLIENT_ADDRESS`::
Für TCPv4 ist dies die IP-Adresse.
Für XNET die lokale Prozess-ID.
Für alle anderen Protokolle ist diese Variable `NULL`.

`CURRENT_ROLE`::
Wie die globale Variable <<fblangref40-contextvars-current-role-de>>.

`CURRENT_USER`::
Same als globale Variable <<fblangref40-contextvars-current-user-de>>.

`DB_NAME`::
Entweder der vollständige Pfad zur Datenbank oder – falls eine Verbindung über den Pfad nicht erlaubt ist – ihr Alias.

`ENGINE_VERSION`::
Die Firebird-Engine (Server)-Version.

`EXT_CONN_POOL_ACTIVE_COUNT`::
Anzahl der aktiven Verbindungen, die dem externen Verbindungspool zugeordnet sind

`EXT_CONN_POOL_IDLE_COUNT`::
Anzahl der derzeit inaktiven Verbindungen, die im Verbindungspool verfügbar sind

`EXT_CONN_POOL_LIFETIME`::
Verbindungsdauer im Leerlauf des externen Verbindungspools in Sekunden

`EXT_CONN_POOL_SIZE`::
Größe des externen Verbindungspools

`ISOLATION_LEVEL`::
Die Isolationsstufe der aktuellen Transaktion: `'READ COMMITTED'`, `'SNAPSHOT'` oder `'CONSISTENCY'`.

`NETZWERK_PROTOKOLL`::
Das für die Verbindung verwendete Protokoll: `'TCPv4'`, `'WNET'`, `'XNET'` oder `NULL`.

`SESSION_ID`::
Entspricht der globalen Variable <<fblangref40-contextvars-current-connection-de>>.

`SESSION_IDLE_TIMEOUT`::
Leerlaufzeitüberschreitung auf Verbindungsebene oder `0`, wenn keine Zeitüberschreitung festgelegt wurde.
Wenn `0` gemeldet wird, gilt die Datenbank `ConnectionIdleTimeout` aus `databases.conf` oder `firebird.conf`.

`SNAPSHOT_NUMBER`::
Aktuelle Snapshot-Nummer für die Transaktion, die diese Anweisung ausführt.
Für `SNAPSHOT` und `SNAPSHOT TABLE STABILITY` ist diese Zahl für die Dauer der Transaktion stabil;
für `READ COMMITTED` ändert sich diese Zahl (erhöht), wenn gleichzeitige Transaktionen festgeschrieben werden.

`STATEMENT_TIMEOUT`::
Zeitüberschreitung der Anweisung auf Verbindungsebene oder `0`, wenn keine Zeitüberschreitung festgelegt wurde.
Wenn `0` gemeldet wird, gilt die Datenbank `StatementTimeout` aus `databases.conf` oder `firebird.conf`.

`TRANSACTION_ID`::
Wie die globale Variable <<fblangref40-contextvars-current-transaction-de>>.

`WIRE_COMPRESSED`::
Komprimierungsstatus der aktuellen Verbindung.
Wenn die Verbindung komprimiert ist, wird `TRUE` zurückgegeben;
wenn es nicht komprimiert ist, wird `FALSE` zurückgegeben.
Gibt `NULL` zurück, wenn die Verbindung eingebettet ist.

`WIRE_ENCRYPTED`::
Verschlüsselungsstatus der aktuellen Verbindung.
Wenn die Verbindung verschlüsselt ist, wird `TRUE` zurückgegeben;
wenn es nicht verschlüsselt ist, wird `FALSE` zurückgegeben.
Gibt `NULL` zurück, wenn die Verbindung eingebettet ist.

[[fblangref40-funcs-tbl-rdbgetcontext-ddl-trigger-de]]
==== Der `DDL_TRIGGER`-Namespace

Der Namespace `DDL_TRIGGER` ist nur gültig, wenn ein DDL-Trigger ausgeführt wird.
Seine Verwendung ist auch in gespeicherten Prozeduren und Funktionen gültig, die von DDL-Triggern aufgerufen werden.

Der Kontext `DDL_TRIGGER` funktioniert wie ein Stack.
Bevor ein DDL-Trigger ausgelöst wird, werden die Werte relativ zum ausgeführten Befehl auf diesen Stack gelegt.
Nach Abschluss des Triggers werden die Werte ausgegeben.
Wenn also im Fall von kaskadierten DDL-Anweisungen ein Benutzer-DDL-Befehl einen DDL-Trigger auslöst und dieser Trigger einen anderen DDL-Befehl mit `EXECUTE STATEMENT` ausführt, sind die Werte des `DDL_TRIGGER`-Namensraums diejenigen relativ zu dem Befehl, der den letzten ausgelöst hat DDL-Trigger in der Aufrufliste.

.Kontextvariablen im DDL_TRIGGER-Namespace
`EVENT_TYPE`:: Ereignistyp (`CREATE`, `ALTER`, `DROP`)
`OBJECT_TYPE`:: Objekttyp (`TABLE`, `VIEW`, etc)
`DDL_EVENT`:: Ereignisname (`<ddl event item>`), wobei `<ddl_event_item>` `EVENT_TYPE || . ist ' ' || OBJECT_TYPE`
`OBJECT_NAME`:: Name des Metadatenobjekts
`OLD_OBJECT_NAME`:: zum Nachverfolgen der Umbenennung einer Domain (siehe Hinweis)
`NEW_OBJECT_NAME`:: zum Nachverfolgen der Umbenennung einer Domain (siehe Hinweis)
`SQL_TEXT`:: SQL-Anweisungstext

[NOTE]
====
`ALTER DOMAIN __old-name__ TO __new-name__` setzt `OLD_OBJECT_NAME` und `NEW_OBJECT_NAME` sowohl in den `BEFORE`- als auch `AFTER`-Triggern.
Für diesen Befehl hat `OBJECT_NAME` den alten Objektnamen in `BEFORE` Triggern und den neuen Objektnamen in `AFTER` Triggern.
====

[[fblangref40-funcs-tbl-rdbgetcontext-exmpl-de]]
==== Beispiele

[source]
----
select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database

New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');

insert into MyTable (TestField)
  values (rdb$get_context('USER_SESSION', 'MyVar'))
----

.Siehe auch
<<fblangref40-scalarfuncs-set-context-de>>

[[fblangref40-scalarfuncs-set-context-de]]
=== `RDB$SET_CONTEXT()`

.Verfügbar in
DSQL, PSQL{nbsp}* Als deklariertes UDF sollte es in ESQL verfügbar sein

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
RDB$SET_CONTEXT ('<namespace>', <varname>, <value> | NULL)

<namespace> ::= USER_SESSION | USER_TRANSACTION
<varname>   ::= Eine Zeichenfolge in Anführungszeichen von max. 80 Zeichen
<value>     ::= _Ein Wert beliebiger Art, solange er umsetzbar ist_
                _zu einem VARCHAR(255)_
----

[[fblangref40-funcs-tbl-rdbsetcontext-de]]
.`RDB$SET_CONTEXT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|namespace
|Namespace

|varname
|Variablenname.
Groß-/Kleinschreibung beachten.
Die maximale Länge beträgt 80 Zeichen

|value
|Daten eines beliebigen Typs, sofern sie in `VARCHAR(255)` umgewandelt werden können
|===

Erstellt, setzt oder hebt eine Variable in einem der vom Benutzer beschreibbaren Namensräume `USER_SESSION` und `USER_TRANSACTION` auf.

.Die Namensräume
Die Namensräume `USER_SESSION` und `USER_TRANSACTION` sind zunächst leer.
Der Benutzer kann mit `RDB$SET_CONTEXT()` Variablen darin erstellen und setzen und mit `RDB$GET_CONTEXT()` abrufen.
Der Kontext `USER_SESSION` ist an die aktuelle Verbindung gebunden.
Variablen in `USER_TRANSACTION` existieren nur in der Transaktion, in der sie gesetzt wurden.
Wenn die Transaktion endet, werden der Kontext und alle darin definierten Variablen zerstört.

.Rückgabewerte und Fehlerverhalten
Die Funktion gibt `1` zurück, wenn die Variable bereits vor dem Aufruf existierte und `0` wenn dies nicht der Fall war.
Um eine Variable aus einem Kontext zu entfernen, setzen Sie sie auf `NULL`.
Wenn der angegebene Namespace nicht existiert, wird ein Fehler ausgegeben.
Sowohl Namensraum- als auch Variablennamen müssen in einfachen Anführungszeichen eingegeben werden, wobei die Groß-/Kleinschreibung beachtet werden muss, nicht ``NULL``-Zeichenfolgen.

[NOTE]
====
* Die maximale Anzahl von Variablen in einem einzelnen Kontext beträgt 1000.
* Alle `USER_TRANSACTION`-Variablen überleben ein <<fblangref40-transacs-rollback-options-de,`ROLLBACK RETAIN`>> (siehe `ROLLBACK`-Optionen) oder <<fblangref40-transacs-rollback-tosavepoint-de,`ROLLBACK TO SAVEPOINT`>> unverändert, egal zu welchem Zeitpunkt der Transaktion sie gesetzt wurden.
* Aufgrund seiner UDF-ähnlichen Natur kann `RDB$SET_CONTEXT` -- nur in PSQL -- wie eine void-Funktion aufgerufen werden, ohne das Ergebnis zuzuweisen, wie im zweiten Beispiel oben.
Reguläre interne Funktionen erlauben diese Art der Nutzung nicht.
====

.Beispiele
[source]
----
select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database

rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);

select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
  from rdb$database
----

.Siehe auch
<<fblangref40-scalarfuncs-get-context-de>>

[[fblangref40-functions-math-de]]
== Mathematische Funktionen

[[fblangref40-scalarfuncs-abs-de]]
=== `ABS()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
Numerisch

.Syntax
[listing,subs=+quotes]
----
ABS (_number_)
----

[[fblangref40-funcs-tbl-abs-de]]
.`ABS`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den absoluten Wert des Arguments zurück.

[[fblangref40-scalarfuncs-acos-de]]
=== `ACOS()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ACOS (_number_)
----

[[fblangref40-funcs-tbl-acos-de]]
.`ACOS`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs im Bereich [-1, 1]
|===

Gibt den Arkuskosinus des Arguments zurück.

* Das Ergebnis ist ein Winkel im Bereich [0, pi].

.Siehe auch
<<fblangref40-scalarfuncs-cos-de>>, <<fblangref40-scalarfuncs-asin-de>>, <<fblangref40-scalarfuncs-atan-de>>

[[fblangref40-scalarfuncs-acosh-de]]
=== `ACOSH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ACOSH (_number_)
----

[[fblangref40-funcs-tbl-acosh-de]]
.`ACOSH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Jeder Nicht-``NULL``-Wert im Bereich [1, INF].
|===

Gibt den inversen hyperbolischen Kosinus des Arguments zurück.

* Das Ergebnis liegt im Bereich [0, INF].

.Siehe auch
<<fblangref40-scalarfuncs-cosh-de>>, <<fblangref40-scalarfuncs-asinh-de>>, <<fblangref40-scalarfuncs-atanh-de>>

[[fblangref40-scalarfuncs-asin-de]]
=== `ASIN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ASIN (_number_)
----

[[fblangref40-funcs-tbl-asin-de]]
.`ASIN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs im Bereich [-1, 1]
|===

Gibt den Arkussinus des Arguments zurück.

* Das Ergebnis ist ein Winkel im Bereich [-pi/2, pi/2].

.Siehe auch
<<fblangref40-scalarfuncs-sin-de>>, <<fblangref40-scalarfuncs-acos-de>>, <<fblangref40-scalarfuncs-atan-de>>

[[fblangref40-scalarfuncs-asinh-de]]
=== `ASINH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ASINH (_number_)
----

[[fblangref40-funcs-tbl-asinh-de]]
.`ASINH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Jeder Nicht-``NULL``-Wert im Bereich [-INF, INF].
|===

Gibt den inversen hyperbolischen Sinus des Arguments zurück.

* Das Ergebnis liegt im Bereich [-INF, INF].

.Siehe auch
<<fblangref40-scalarfuncs-sinh-de>>, <<fblangref40-scalarfuncs-acosh-de>>, <<fblangref40-scalarfuncs-atanh-de>>

[[fblangref40-scalarfuncs-atan-de]]
=== `ATAN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ATAN (_number_)
----

[[fblangref40-funcs-tbl-atan-de]]
.`ATAN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Die Funktion `ATAN` gibt den Arkustangens des Arguments zurück.
Das Ergebnis ist ein Winkel im Bereich ++<-pi/2, pi/2>++.

.Siehe auch
<<fblangref40-scalarfuncs-atan2-de>>, <<fblangref40-scalarfuncs-tan-de>>, <<fblangref40-scalarfuncs-acos-de>>, <<fblangref40-scalarfuncs-asin-de>>

[[fblangref40-scalarfuncs-atan2-de]]
=== `ATAN2()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

//Note for maintainers/editors: the argument names y and x (in that order!) are chosen on purpose, for geometrical reasons.
.Syntax
[listing,subs=+quotes]
----
ATAN2 (_y_, _x_)
----

[[fblangref40-funcs-tbl-atan2-de]]
.`ATAN2`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|y
|Ein Ausdruck eines numerischen Typs

|x
|Ein Ausdruck eines numerischen Typs
|===

Gibt den Winkel zurück, dessen Sinus-zu-Cosinus-_Verhältnis_ durch die beiden Argumente gegeben ist und dessen Sinus- und Kosinus-_Vorzeichen_ den Vorzeichen der Argumente entsprechen.
Dies ermöglicht Ergebnisse über den gesamten Kreis, einschließlich der Winkel -pi/2 und pi/2.

* Das Ergebnis ist ein Winkel im Bereich [-pi, pi].
* Wenn _x_ negativ ist, ist das Ergebnis pi, wenn _y_ 0 ist, und -pi, wenn _y_ -0 ist.
* Wenn sowohl _y_ als auch _x_ 0 sind, ist das Ergebnis bedeutungslos.
Ein Fehler wird ausgegeben, wenn beide Argumente 0 sind.

[NOTES]
====
* Eine vollständig äquivalente Beschreibung dieser Funktion ist die folgende: `ATAN2(__y__, __x__)` ist der Winkel zwischen der positiven X-Achse und der Linie vom Ursprung zum Punkt _(x, y)_.
Damit ist auch klar, dass `ATAN2(0, 0)` undefiniert ist.
* Wenn _x_ größer als 0 ist, ist `ATAN2(__y__, __x__)` dasselbe wie `ATAN(__y__/__x__)`.
* Wenn sowohl Sinus als auch Kosinus des Winkels bereits bekannt sind, gibt `ATAN2(__sin__, __cos__)` den Winkel an.
====

[[fblangref40-scalarfuncs-atanh-de]]
=== `ATANH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ATANH (_number_)
----

[[fblangref40-funcs-tbl-atanh-de]]
.`ATANH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Jeder Nicht-``NULL``-Wert im Bereich ++<-1, 1>++.
|===

Gibt den inversen hyperbolischen Tangens des Arguments zurück.

* Das Ergebnis ist eine Zahl im Bereich [-INF, INF].

.Siehe auch
<<fblangref40-scalarfuncs-tanh-de>>, <<fblangref40-scalarfuncs-acosh-de>>, <<fblangref40-scalarfuncs-asinh-de>>

[[fblangref40-scalarfuncs-ceil-de]]
=== `CEIL()`, `CEILING()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>> (Betrifft nur `CEILING`)

.Ergebnistyp
`BIGINT` für exakte numerische _Zahl_ oder `DOUBLE PRECISION` für Gleitkomma-_Zahl_

.Syntax
[listing,subs=+quotes]
----
CEIL[ING] (_number_)
----

[[fblangref40-funcs-tbl-ceil-de]]
.`CEIL[ING]`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt die kleinste ganze Zahl zurück, die größer oder gleich dem Argument ist.

.Siehe auch
<<fblangref40-scalarfuncs-floor-de>>, <<fblangref40-scalarfuncs-round-de>>, <<fblangref40-scalarfuncs-trunc-de>>

[[fblangref40-scalarfuncs-cos-de]]
=== `COS()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COS (_angle_)
----

[[fblangref40-funcs-tbl-cos-de]]
.`COS`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Kosinus eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

* Jedes Ergebnis, das nicht ``NULL`` ist, liegt -- offensichtlich -- im Bereich [-1, 1].

.Siehe auch
<<fblangref40-scalarfuncs-acos-de>>, <<fblangref40-scalarfuncs-cot-de>>, <<fblangref40-scalarfuncs-sin-de>>, <<fblangref40-scalarfuncs-tan-de>>

[[fblangref40-scalarfuncs-cosh-de]]
=== `COSH()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COSH (_number_)
----

[[fblangref40-funcs-tbl-cosh-de]]
.`COSH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines numerischen Typs
|===

Gibt den hyperbolischen Kosinus des Arguments zurück.

* Jedes Ergebnis, das nicht ``NULL`` ist, liegt im Bereich [1, INF].

.Siehe auch
<<fblangref40-scalarfuncs-acosh-de>>, <<fblangref40-scalarfuncs-sinh-de>>, <<fblangref40-scalarfuncs-tanh-de>>

[[fblangref40-scalarfuncs-cot-de]]
=== `COT()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COT (_angle_)
----

[[fblangref40-funcs-tbl-cot-de]]
.`COT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Kotangens eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

.Siehe auch
<<fblangref40-scalarfuncs-cos-de>>, <<fblangref40-scalarfuncs-sin-de>>, <<fblangref40-scalarfuncs-tan-de>>

[[fblangref40-scalarfuncs-exp-de]]
=== `EXP()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
EXP (_number_)
----

[[fblangref40-funcs-tbl-exp-de]]
.`EXP`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines numerischen Typs
|===

Gibt die natürliche Exponentialfunktion zurück, _e_^`number`^

.Siehe auch
<<fblangref40-scalarfuncs-ln-de>>

[[fblangref40-scalarfuncs-floor-de]]
=== `FLOOR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`BIGINT` für genaue numerische _number_, oder `DOUBLE PRECISION` für fließkommagenaue _number_

.Syntax
[listing,subs=+quotes]
----
FLOOR (_number_)
----

[[fblangref40-funcs-tbl-floor-de]]
.`FLOOR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt die größte ganze Zahl zurück, die kleiner oder gleich dem Argument ist.

.Siehe auch
<<fblangref40-scalarfuncs-ceil-de>>, <<fblangref40-scalarfuncs-round-de>>, <<fblangref40-scalarfuncs-trunc-de>>

[[fblangref40-scalarfuncs-ln-de]]
=== `LN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LN (_number_)
----

[[fblangref40-funcs-tbl-ln-de]]
.`LN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den natürlichen Logarithmus des Arguments zurück.

* Ein Fehler wird ausgegeben, wenn das Argument negativ oder 0 ist.

.Siehe auch
<<fblangref40-scalarfuncs-exp-de>>, <<fblangref40-scalarfuncs-log-de>>, <<fblangref40-scalarfuncs-log10-de>>

[[fblangref40-scalarfuncs-log-de]]
=== `LOG()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LOG (_x_, _y_)
----

[[fblangref40-funcs-tbl-log-de]]
.`LOG`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|x
|Basis.
Ein Ausdruck eines numerischen Typs

|y
|Ein Ausdruck eines numerischen Typs
|===

Gibt den __x__-basierten Logarithmus von _y_ zurück.

* Wenn eines der Argumente 0 oder kleiner ist, wird ein Fehler ausgegeben.
(Vor 2.5 würde dies `NaN`, `+/-INF` oder 0 ergeben, abhängig von den genauen Werten der Argumente.)
* Wenn beide Argumente 1 sind, wird `NaN` zurückgegeben.
* Wenn _x_ = 1 und _y_ < 1 ist, wird `-INF` zurückgegeben.
* Wenn _x_ = 1 und _y_ > 1 ist, wird `INF` zurückgegeben.

.Siehe auch
<<fblangref40-scalarfuncs-power-de>>, <<fblangref40-scalarfuncs-ln-de>>, <<fblangref40-scalarfuncs-log10-de>>

[[fblangref40-scalarfuncs-log10-de]]
=== `LOG10()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LOG10 (_number_)
----

[[fblangref40-funcs-tbl-log10-de]]
.`LOG10`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den 10-basierten Logarithmus des Arguments zurück.

* Ein Fehler wird ausgegeben, wenn das Argument negativ oder 0 ist.
(In Versionen vor 2.5 würden solche Werte zu `NaN` bzw. `-INF` führen.)

.Siehe auch
<<fblangref40-scalarfuncs-power-de>>, <<fblangref40-scalarfuncs-ln-de>>, <<fblangref40-scalarfuncs-log-de>>

[[fblangref40-scalarfuncs-mod-de]]
=== `MOD()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT` je nach Typ von _a_.
Wenn _a_ ein Gleitkommatyp ist, ist das Ergebnis ein `BIGINT`.

.Syntax
[listing,subs=+quotes]
----
MOD (_a_, _b_)
----

[[fblangref40-funcs-tbl-mod-de]]
.`MOD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|a
|Ein Ausdruck eines numerischen Typs

|b
|Ein Ausdruck eines numerischen Typs
|===

Gibt den Rest einer ganzzahligen Division zurück.

* Nicht ganzzahlige Argumente werden vor der Division gerundet.
"```mod(7.5, 2.5)```" ergibt also 2 ("```mod(8, 3)```"), nicht 0.

[[fblangref40-scalarfuncs-pi-de]]
=== `PI()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing]
----
PI ()
----

Gibt eine Annäherung an den Wert von _pi_ zurück.

[[fblangref40-scalarfuncs-power-de]]
=== `POWER()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
POWER (_x_, _y_)
----

[[fblangref40-funcs-tbl-power]]
.`POWER`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|x
|Ein Ausdruck eines numerischen Typs

|y
|Ein Ausdruck eines numerischen Typs
|===

Gibt _x_ hoch _y_ (_x^y^_) zurück.

.Siehe auch
<<fblangref40-scalarfuncs-exp-de>>, <<fblangref40-scalarfuncs-log-de>>, <<fblangref40-scalarfuncs-log10-de>>, <<fblangref40-scalarfuncs-sqrt-de>>

[[fblangref40-scalarfuncs-rand-de]]
=== `RAND()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing]
----
RAND ()
----

Gibt eine Zufallszahl zwischen 0 und 1 zurück.

[[fblangref40-scalarfuncs-round-de]]
=== `ROUND()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`INTEGER`, (skaliert) `BIGINT` oder `DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ROUND (_number_ [, _scale_])
----

[[fblangref40-funcs-tbl-round-de]]
.`ROUND`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^|Parameter
^|Description

|number
|Ein Ausdruck eines numerischen Typs

|scale
a|Eine ganze Zahl, die die Anzahl der Nachkommastellen angibt, auf die gerundet werden soll, z. B.:

* {nbsp}2 zum Runden auf das nächste Vielfache von 0,01
* {nbsp}1 zum Runden auf das nächste Vielfache von 0,1
* {nbsp}0 zum Runden auf die nächste ganze Zahl
* -1 zum Runden auf das nächste Vielfache von 10
* -2 zum Runden auf das nächste Vielfache von 100
|===

Rundet eine Zahl auf die nächste ganze Zahl.
Wenn der Bruchteil genau '0,5' ist, wird bei positiven Zahlen nach oben und bei negativen Zahlen nach unten gerundet.
Mit dem optionalen Argument _scale_ kann die Zahl auf Zehnerpotenzen (Zehner, Hunderter, Zehntel, Hundertstel usw.) statt auf ganze Zahlen gerundet werden.

[IMPORTANT]
====
Wenn Sie an das Verhalten der externen Funktion `ROUND` gewöhnt sind, beachten Sie bitte, dass die Funktion _internal_ von Null immer auf Hälften rundet, d.h. bei negativen Zahlen nach unten.
====

[[fblangref40-scalarfuncs-round-exmpl-de]]
==== `ROUND`-Beispiele

Wenn das Argument _scale_ vorhanden ist, hat das Ergebnis normalerweise die gleiche Skalierung wie das erste Argument:

[source]
----
ROUND(123.654, 1) -- Ergebnis 123.700 (not 123.7)
ROUND(8341.7, -3) -- Ergebnis 8000.0 (not 8000)
ROUND(45.1212, 0) -- Ergebnis 45.0000 (not 45)
----

Andernfalls ist die Ergebnisskalierung 0:

[source]
----
ROUND(45.1212) -- Ergebnis 45
----

.Siehe auch
<<fblangref40-scalarfuncs-ceil-de>>, <<fblangref40-scalarfuncs-floor-de>>, <<fblangref40-scalarfuncs-trunc-de>>

[[fblangref40-scalarfuncs-sign-de]]
=== `SIGN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
SIGN (_number_)
----

[[fblangref40-funcs-tbl-sign-de]]
.`SIGN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt das Vorzeichen des Arguments zurück: -1, 0 oder 1.

[[fblangref40-scalarfuncs-sin-de]]
=== `SIN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SIN (_angle_)
----

[[fblangref40-funcs-tbl-sin]]
.`SIN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Sinus eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

* Jedes Ergebnis, das nicht `NULL` ist, liegt -- offensichtlich -- im Bereich [-1, 1].

.Siehe auch
<<fblangref40-scalarfuncs-asin-de>>, <<fblangref40-scalarfuncs-cos-de>>, <<fblangref40-scalarfuncs-cot-de>>, <<fblangref40-scalarfuncs-tan-de>>

[[fblangref40-scalarfuncs-sinh-de]]
=== `SINH()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SINH (_number_)
----

[[fblangref40-funcs-tbl-sinh-de]]
.`SINH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den hyperbolischen Sinus des Arguments zurück.

.Siehe auch
<<fblangref40-scalarfuncs-asinh-de>>, <<fblangref40-scalarfuncs-cosh-de>>, <<fblangref40-scalarfuncs-tanh-de>>

[[fblangref40-scalarfuncs-sqrt-de]]
=== `SQRT()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SQRT (_number_)
----

[[fblangref40-funcs-tbl-sqrt-de]]
.`SQRT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt die Quadratwurzel des Arguments zurück.

* Wenn _number_ negativ ist, wird ein Fehler ausgegeben.

.Siehe auch
<<fblangref40-scalarfuncs-power-de>>

[[fblangref40-scalarfuncs-tan-de]]
=== `TAN()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TAN (_angle_)
----

[[fblangref40-funcs-tbl-tan-de]]
.`TAN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|angle
|Ein Winkel im Bogenmaß
|===

Gibt den Tangens eines Winkels zurück.
Das Argument muss im Bogenmaß angegeben werden.

.Siehe auch
<<fblangref40-scalarfuncs-atan-de>>, <<fblangref40-scalarfuncs-atan2-de>>, <<fblangref40-scalarfuncs-cos-de>>, <<fblangref40-scalarfuncs-cot-de>>, <<fblangref40-scalarfuncs-sin-de>>, <<fblangref40-scalarfuncs-tan-de>>

[[fblangref40-scalarfuncs-tanh-de]]
=== `TANH()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TANH (_number_)
----

[[fblangref40-funcs-tbl-tanh]]
.`TANH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Ein Ausdruck eines numerischen Typs
|===

Gibt den hyperbolischen Tangens des Arguments zurück.

* Aufgrund von Rundungen liegt jedes Ergebnis, das nicht `NULL` ist, im Bereich [-1, 1] (mathematisch ist es ++<-1, 1>++).

.Siehe auch
<<fblangref40-scalarfuncs-atanh-de>>, <<fblangref40-scalarfuncs-cosh-de>>, <<fblangref40-scalarfuncs-tanh-de>>

[[fblangref40-scalarfuncs-trunc-de]]
=== `TRUNC()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`, (scaled) `BIGINT` or `DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TRUNC (_number_ [, _scale_])
----

[[fblangref40-funcs-tbl-trunc-de]]
.`TRUNC`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^|Parameter
^|Description

|number
|Ein Ausdruck eines numerischen Typs

|scale
a|Eine ganze Zahl, die die Anzahl der Dezimalstellen angibt, auf die abgeschnitten werden soll, z. B.:

* {nbsp}2 zum Abschneiden auf das nächste Vielfache von 0,01
* {nbsp}1 zum Abschneiden auf das nächste Vielfache von 0,1
* {nbsp}0 zum Abschneiden auf die nächste ganze Zahl
* -1 zum Abschneiden auf das nächste Vielfache von 10
* -2 zum Abschneiden auf das nächste Vielfache von 100
|===

Gibt den ganzzahligen Teil einer Zahl zurück.
Mit dem optionalen Argument _scale_ kann die Zahl auf Zehnerpotenzen (Zehner, Hunderter, Zehntel, Hundertstel usw.) statt auf ganze Zahlen gekürzt werden.

[NOTE]
====
* Wenn das Argument _scale_ vorhanden ist, hat das Ergebnis normalerweise die gleiche Skala wie das erste Argument, z.
** `TRUNC(789.2225, 2)` gibt 789.2200 (nicht 789.22) zurück
** `TRUNC(345.4, -2)` gibt 300.0 (nicht 300) zurück
** `TRUNC(-163.41, 0)` gibt -163.00 (nicht -163) zurück
* Andernfalls ist die Ergebnisskala 0:
** `TRUNC(-163.41)` gibt -163 zurück
====

[IMPORTANT]
====
Wenn Sie an das Verhalten der https://www.firebirdsql.org/file/documentation/reference_manuals/reference_material/html/langrefupd25-udf-truncate.html[externen Funktion `TRUNCATE`] gewöhnt sind, beachten Sie bitte, dass die _interne_ Funktion `TRUNC` immer gegen Null abschneidet, d.h. für negative Zahlen nach oben.
====

.Siehe auch
<<fblangref40-scalarfuncs-ceil-de>>, <<fblangref40-scalarfuncs-floor-de>>, <<fblangref40-scalarfuncs-round-de>>

[[fblangref40-functions-string-de]]
== String- und Binärfunktionen

[[fblangref40-scalarfuncs-ascii-char-de]]
=== `ASCII_CHAR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`CHAR(1) CHARACTER SET NONE`

.Syntax
[listing,subs=+quotes]
----
ASCII_CHAR (_code_)
----

[[fblangref40-funcs-tbl-asciichar-de]]
.`ASCII_CHAR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|code
|Eine ganze Zahl im Bereich von 0 bis 255
|===

Gibt das ASCII-Zeichen zurück, das der im Argument übergebenen Zahl entspricht.

[IMPORTANT]
====
* Wenn Sie das Verhalten des `ASCII_CHAR`-UDF gewohnt sind, das einen leeren String zurückgibt, wenn das Argument 0 ist, beachten Sie bitte, dass die interne Funktion hier korrekt ein Zeichen mit dem ASCII-Code 0 zurückgibt.
====

[[fblangref40-scalarfuncs-ascii-val-de]]
=== `ASCII_VAL()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
ASCII_VAL (_ch_)
----

[[fblangref40-funcs-tbl-asciival-de]]
.`ASCII_VAL`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|ch
|Ein String vom Datentyp `[VAR]CHAR` oder ein Text `BLOB` mit der maximalen Größe von 32.767 Bytes
|===

Gibt den ASCII-Code des übergebenen Zeichens zurück.

* Wenn das Argument ein String mit mehr als einem Zeichen ist, wird der ASCII-Code des ersten Zeichens zurückgegeben.
* Wenn das Argument ein leerer String ist, wird 0 zurückgegeben.
* Wenn das Argument `NULL` ist, wird `NULL` zurückgegeben.
* Wenn das erste Zeichen der Argumentzeichenfolge aus mehreren Byte besteht, wird ein Fehler ausgegeben.
(Ein Fehler in Firebird 2.1 - 2.1.3 und 2.5.0 führt zu einem Fehler, wenn _beliebiges_ Zeichen in der Zeichenfolge aus mehreren Byte besteht.
Dies ist in den Versionen 2.1.4 und 2.5.1 behoben.)

[[fblangref40-scalarfuncs-base64decode-de]]
=== `BASE64_DECODE()`

.Verfügbar in
DSQL, PSQL

.Egebnistyp
`VARBINARY` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
BASE64_DECODE (_base64_data_)
----

[[fblangref40-scalarfuncs-tbl-base64decode]]
.`BASE64_DECODE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|base64_data
|Base64-codierte Daten, aufgefüllt mit `=` auf Vielfaches von 4
|===

`BASE64_DECODE` decodiert einen String mit base64-codierten Daten und gibt den decodierten Wert je nach Eingabe als `VARBINARY` oder `BLOB` zurück.
Wenn die Länge des Typs von _base64_data_ kein Vielfaches von 4 ist, wird zur Vorbereitungszeit ein Fehler ausgegeben.
Wenn die Länge des Werts von _base64_data_ kein Vielfaches von 4 ist, wird zur Ausführungszeit ein Fehler ausgegeben.

Wenn die Eingabe nicht `BLOB` ist, wird die Länge des resultierenden Typs als `__type_length__ * 3 / 4` berechnet, wobei _type_length_ die maximale Länge in Zeichen des Eingabetyps ist.

[[fblangref40-scalarfuncs-base64decode-exmpl-de]]
==== Beispiel für `BASE64_DECODE`

[source]
----
select cast(base64_decode('VGVzdCBiYXNlNjQ=') as varchar(12))
from rdb$database;

CAST
============
Test base64
----

.Siehe auch
<<fblangref40-scalarfuncs-base64encode-de>>, <<fblangref40-scalarfuncs-hexdecode-de>>

[[fblangref40-scalarfuncs-base64encode-de]]
=== `BASE64_ENCODE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR CHARACTER SET ASCII` oder `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`

.Syntax
[listing,subs=+quotes]
----
BASE64_ENCODE (_binary_data_)
----

[[fblangref40-scalarfuncs-tbl-base64encode]]
.`BASE64_ENCODE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|binary_data
|Binäre Daten (oder anderweitig in Binär umwandelbar) zum Codieren
|===

`BASE64_ENCODE` codiert _binary_data_ mit base64 und gibt den codierten Wert je nach Eingabe als `VARCHAR CHARACTER SET ASCII` oder `BLOB SUB_TYPE TEXT CHARACTER SET ASCII` zurück.
Der zurückgegebene Wert wird mit '```=```' aufgefüllt, sodass seine Länge ein Vielfaches von 4 ist.

Wenn die Eingabe nicht 'BLOB' ist, wird die Länge des resultierenden Typs berechnet als '__type_length__ * 4 / 3', aufgerundet auf ein Vielfaches von vier, wobei _type_length_ die maximale Länge in Bytes des Eingabetyps ist.
Überschreitet diese Länge die maximale Länge von `VARCHAR`, gibt die Funktion ein `BLOB` zurück.

[[fblangref40-scalarfuncs-base64encode-exmpl-de]]
==== Beispiel für `BASE64_ENCODE`

[source]
----
select base64_encode('Test base64')
from rdb$database;

BASE64_ENCODE
================
VGVzdCBiYXNlNjQ=
----

.Siehe auch
<<fblangref40-scalarfuncs-base64decode-de>>, <<fblangref40-scalarfuncs-hexencode-de>>

[[fblangref40-scalarfuncs-bit-length-de]]
=== `BIT_LENGTH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
BIT_LENGTH (_string_)
----

[[fblangref40-funcs-tbl-bitlength-de]]
.`BIT_LENGTH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt die Länge des Eingabestrings in Bits an.
Bei Mehrbyte-Zeichensätzen kann dies kleiner sein als die Anzahl der Zeichen mal 8 mal die "`formale`" Anzahl von Bytes pro Zeichen wie in `RDB$CHARACTER_SETS` gefunden.

[NOTE]
====
Bei Argumenten vom Typ `CHAR` berücksichtigt diese Funktion die gesamte formale Stringlänge (d.h. die deklarierte Länge eines Feldes oder einer Variablen).
Wenn Sie die "`logische`" Bitlänge erhalten möchten, ohne die abschließenden Leerzeichen zu zählen, rechts-<<fblangref40-scalarfuncs-trim-de,`TRIM`>> das Argument vor der Übergabe an `BIT_LENGTH`.
====

.`BLOB`-Unterstützung
Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[[fblangref40-scalarfuncs-bit-length-exmpl-de]]
==== `BIT_LENGTH`-Beispiele

[source]
----
select bit_length('Hello!') from rdb$database
-- Ergebnis 48

select bit_length(_iso8859_1 'Grüß di!') from rdb$database
-- Ergebnis 64: ü und ß belegen in ISO8859_1 jeweils ein Byte

select bit_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- Ergebnis 80: ü und ß belegen in ISO8859_1 jeweils ein Byte

select bit_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- Ergebnis 208: alle 24 CHAR-Positionen zählen, und zwei davon sind 16-Bit
----

.Siehe auch
<<fblangref40-scalarfuncs-octet-length-de>>, <<fblangref40-scalarfuncs-char-length-de>>

[[fblangref40-scalarfuncs-char-length-de]]
=== `CHAR_LENGTH()`, `CHARACTER_LENGTH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
  CHAR_LENGTH (_string_)
| CHARACTER_LENGTH (_string_)
----

[[fblangref40-funcs-tbl-charlength-de]]
.`CHAR[ACTER]_LENGTH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt die Länge des Eingabestrings in Zeichen an.

[NOTE]
====
* Bei Argumenten vom Typ `CHAR` liefert diese Funktion die formale Stringlänge (d.h. die deklarierte Länge eines Feldes oder einer Variablen).
Wenn Sie die "`logische`" Länge erhalten möchten, ohne die abschließenden Leerzeichen zu zählen, rechts-<<fblangref40-scalarfuncs-trim-de,`TRIM`>> das Argument vor der Übergabe an `CHAR[ACTER]_LENGTH`.
* *``BLOB``-Unterstützung*: Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
====

[[fblangref40-scalarfuncs-char-length-exmpl-de]]
==== `CHAR_LENGTH`-Beispiele
[source]
----
select char_length('Hello!') from rdb$database
-- Ergebnis 6

select char_length(_iso8859_1 'Grüß di!') from rdb$database
-- Ergebnis 8

select char_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- Ergebnis 8; dass ü und ß jeweils zwei Bytes belegen ist irrelevant

select char_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- Ergebnis 24: alle 24 CHAR-Positionen zählen
----

.Siehe auch
<<fblangref40-scalarfuncs-bit-length-de>>, <<fblangref40-scalarfuncs-octet-length-de>>

[[fblangref40-scalarfuncs-crypthash-de]]
=== `CRYPT_HASH()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
CRYPT_HASH (_value_ USING <hash>)

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref40-scalarfuncs-tbl-crypthash-de]]
.`CRYPT_HASH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|value
|Ausdruck von Werten jeglicher Art;
Nicht-String- oder Nicht-Binär-Typen werden in Strings konvertiert

|hash
|Anzuwendender kryptografischer Hash-Algorithmus
|===

`CRYPT_HASH` gibt einen kryptografischen Hash zurück, der aus dem Eingabeargument mit dem angegebenen Algorithmus berechnet wurde.
Wenn das Eingabeargument kein String- oder Binärtyp ist, wird es vor dem Hashing in einen String konvertiert.

Diese Funktion gibt ein `VARBINARY` mit der Länge abhängig vom angegebenen Algorithmus zurück.

[NOTE]
====
* Die Algorithmen 'MD5' und 'SHA1' werden aus Sicherheitsgründen nicht empfohlen, da bekannte Angriffe Hash-Kollisionen erzeugen.
Diese beiden Algorithmen werden nur aus Gründen der Abwärtskompatibilität bereitgestellt.

* Beim Hashing von String- oder Binärwerten ist es wichtig, die Auswirkungen von abschließenden Leerzeichen (Leerzeichen oder NULs) zu berücksichtigen.
Der Wert `'ab'` in einem `CHAR(5)` (3 nachgestellte Leerzeichen) hat einen anderen Hash als wenn er in einem `VARCHAR(5)` (keine nachgestellten Leerzeichen) oder `CHAR(6)` gespeichert ist ( 4 nachgestellte Leerzeichen).
+
Um dies zu vermeiden, stellen Sie sicher, dass Sie immer einen Datentyp mit variabler Länge oder denselben Datentyp mit fester Länge verwenden oder Werte vor dem Hashing normalisieren, zum Beispiel mit <<fblangref40-scalarfuncs-trim-de,`TRIM(TRAILING FROM _value_)`>> .
====

[[fblangref40-scalarfuncs-crypthash-exmpl-de]]
==== Beispiele für `CRYPT_HASH`

.Hashing `x` mit dem SHA512-Algorithmus
[source]
----
select crypt_hash(x using sha512) from y;
----

.Siehe auch
<<fblangref40-scalarfuncs-hash-de>>

[[fblangref40-scalarfuncs-hash-de]]
=== `HASH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`,`BIGINT`

.Syntax
[listing,subs=+quotes]
----
HASH (_value_ [USING <hash>])

<hash> ::= CRC32
----

[[fblangref40-funcs-tbl-hash-de]]
.`HASH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|value
|Ausdruck von Werten jeglicher Art;
Nicht-String- oder Nicht-Binär-Typen werden in Strings konvertiert

|hash
|Anzuwendender nicht-kryptografischer Hash-Algorithmus
|===

`HASH` gibt einen Hash-Wert für das Eingabeargument zurück.
Wenn das Eingabeargument kein String- oder Binärtyp ist, wird es vor dem Hashing in einen String konvertiert.

Die optionale `USING`-Klausel gibt den anzuwendenden nicht-kryptografischen Hash-Algorithmus an.
Wenn die `USING`-Klausel fehlt, wird der Legacy-PJW-Algorithmus angewendet;
dies ist identisch mit dem Verhalten in früheren Firebird-Versionen.

Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

.Unterstützte Algorithmen
_not specified_::
Wenn kein Algorithmus angegeben ist, wendet Firebird die 64-Bit-Variante der nicht-kryptografischen https://en.wikipedia.org/wiki/PJW_hash_function[PJW-Hash-Funktion^] (auch bekannt als ELF64) an.
Dies ist ein sehr schneller Algorithmus für allgemeine Zwecke (Hash-Tabellen usw.), aber seine Kollisionsqualität ist nicht optimal.
Andere Hashfunktionen – die explizit in der `USING`-Klausel angegeben sind, oder kryptografische Hashes durch <<fblangref40-scalarfuncs-crypthash-de>> – sollten für zuverlässigeres Hashing verwendet werden.
+
Die Funktion `HASH` gibt `BIGINT` für diesen Algorithmus zurück

`CRC32`::
Mit `CRC32` wendet Firebird den CRC32-Algorithmus unter Verwendung des Polynoms 0x04C11DB7 an.
+
Die Funktion `HASH` gibt `INTEGER` für diesen Algorithmus zurück.

[[fblangref40-scalarfuncs-hash-exmpl-de]]
==== Beispiele für `HASH`

. Hashing `x` mit dem CRC32-Algorithmus
+
[source]
----
select hash(x using crc32) from y;
----

. Hashing `x` mit dem Legacy-PJW-Algorithmus
+
[source]
----
select hash(x) from y;
----


.Siehe auch
<<fblangref40-scalarfuncs-crypthash-de>>

[[fblangref40-scalarfuncs-hexdecode-de]]
=== `HEX_DECODE()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
HEX_DECODE (_hex_data_)
----

[[fblangref40-scalarfuncs-tbl-hexdecode-de]]
.`HEX_DECODE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|hex_data
|Hex-kodierte Daten
|===

`HEX_DECODE` decodiert einen String mit Hex-codierten Daten und gibt den decodierten Wert als `VARBINARY` oder `BLOB` entsprechend der Eingabe zurück.
Wenn die Länge des Typs von _hex_data_ kein Vielfaches von 2 ist, wird zur Vorbereitungszeit ein Fehler ausgegeben.
Wenn die Länge des Wertes von _hex_data_ kein Vielfaches von 2 ist, wird zur Ausführungszeit ein Fehler ausgegeben.

Wenn die Eingabe nicht 'BLOB' ist, wird die Länge des resultierenden Typs als '__type_length__ / 2' berechnet, wobei _type_length_ die maximale Länge in Zeichen des Eingabetyps ist.

[[fblangref40-scalarfuncs-hexdecode-exmpl-de]]
==== Beispiel für `HEX_DECODE`

[source]
----
select cast(hex_decode('48657861646563696D616C') as varchar(12))
from rdb$database;

CAST
============
Hexadecimal
----

.Siehe auch
<<fblangref40-scalarfuncs-hexencode-de>>, <<fblangref40-scalarfuncs-base64decode-de>>

[[fblangref40-scalarfuncs-hexencode-de]]
=== `HEX_ENCODE()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARCHAR CHARACTER SET ASCII` oder `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`

.Syntax
[listing,subs=+quotes]
----
HEX_ENCODE (_binary_data_)
----

[[fblangref40-scalarfuncs-tbl-hexencode-de]]
.`HEX_ENCODE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibug

|binary_data
|Binäre Daten (oder anderweitig in Binär umwandelbar) zum Codieren
|===

`HEX_ENCODE` codiert _binary_data_ mit Hex und gibt den codierten Wert als `VARCHAR CHARACTER SET ASCII` oder `BLOB SUB_TYPE TEXT CHARACTER SET ASCII` entsprechend der Eingabe zurück.

Wenn die Eingabe nicht 'BLOB' ist, wird die Länge des resultierenden Typs als '__type_length__ * 2' berechnet, wobei _type_length_ die maximale Länge in Bytes des Eingabetyps ist.
Überschreitet diese Länge die maximale Länge von `VARCHAR`, gibt die Funktion ein `BLOB` zurück.

[[fblangref40-scalarfuncs-hexencode-exmpl-de]]
==== Beispiel für `HEX_ENCODE`

[source]
----
select hex_encode('Hexadecimal')
from rdb$database;

HEX_ENCODE
======================
48657861646563696D616C
----

.Siehe auch
<<fblangref40-scalarfuncs-hexdecode-de>>, <<fblangref40-scalarfuncs-base64encode-de>>

[[fblangref40-scalarfuncs-left-de]]
=== `LEFT()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
LEFT (_string_, _length_)
----

[[fblangref40-funcs-tbl-left-de]]
.`LEFT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs

|length
|Ganzzahliger Ausdruck.
Definiert die Anzahl der zurückzugebenden Zeichen
|===

Gibt den äußersten linken Teil der Argumentzeichenfolge zurück.
Die Anzahl der Zeichen wird im zweiten Argument angegeben.

* Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge, einschließlich solcher mit einem Multi-Byte-Zeichensatz.
* Wenn _string_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_ der Länge des Eingabestrings.
* Wenn das Argument _length_ die Stringlänge überschreitet, wird der Eingabestring unverändert zurückgegeben.
* Wenn das Argument _length_ keine ganze Zahl ist, wird Banker-Rundung (auf gerade) angewendet, d. h. 0,5 wird zu 0, 1,5 wird zu 2, 2,5 wird zu 2, 3,5 wird zu 4 usw.

.Siehe auch
<<fblangref40-scalarfuncs-right-de>>

[[fblangref40-scalarfuncs-lower-de]]
=== `LOWER()`

.Verfügbar in
DSQL, ESQL, PSQL

.Möglicher Namenskonflikt
YES -> <<lowernote,Lesen Sie die Details unten>>

.Ergebnistyp
`(VAR)CHAR`, `(VAR)BINARY` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
LOWER (_string_)
----

[[fblangref40-funcs-tbl-lower-de]]
.`LOWER`-FunktionsparameterS
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt das Äquivalent der Eingabezeichenfolge in Kleinbuchstaben zurück.
Das genaue Ergebnis hängt vom Zeichensatz ab.
Bei `ASCII` oder `NONE` beispielsweise werden nur ASCII-Zeichen kleingeschrieben;
mit `OCTETS` wird der gesamte String unverändert zurückgegeben.
Seit Firebird 2.1 unterstützt diese Funktion auch Text-``BLOB``s beliebiger Länge und beliebigem Zeichensatz.

[[lowernote]]
.Namenskonflikt
[NOTE]
====
Da `LOWER` ein reserviertes Wort ist, hat die interne Funktion Vorrang, auch wenn die externe Funktion mit diesem Namen ebenfalls deklariert wurde.
Um die (minderwertige!) externe Funktion aufzurufen, verwenden Sie doppelte Anführungszeichen und die genaue Großschreibung, wie in `"LOWER"(__string__)`.
====

[[fblangref40-scalarfuncs-lower-exmpl-de]]
==== `LOWER`-Beispiele

[source]
----
select Sheriff from Towns
  where lower(Name) = 'cooper''s valley'
----

.Siehe auch
<<fblangref40-scalarfuncs-upper-de>>

[[fblangref40-scalarfuncs-lpad-de]]
=== `LPAD()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
LPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref40-funcs-tbl-lpad-de]]
.`LPAD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|endlen
|Länge der Ausgabezeichenfolge

|padstr
|Das Zeichen oder die Zeichenfolge, die verwendet werden soll, um die Quellzeichenfolge bis zur angegebenen Länge aufzufüllen.
Standard ist Leerzeichen ("```' '```")
|===

Füllt eine Zeichenfolge mit der linken Maustaste mit Leerzeichen oder mit einer vom Benutzer angegebenen Zeichenfolge auf, bis eine bestimmte Länge erreicht ist.

* Diese Funktion unterstützt vollständig Text ``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
* Wenn _str_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__endlen__)`.
* Wenn _padstr_ angegeben ist und gleich `''` (leerer String) ist, findet kein Auffüllen statt.
* Wenn _endlen_ kleiner als die aktuelle Stringlänge ist, wird der String auf _endlen_ gekürzt, auch wenn _padstr_ der leere String ist.

[NOTE]
====
In Firebird 2.1-2.1.3 waren alle Nicht-``BLOB``-Ergebnisse vom Typ `VARCHAR(32765)`, was es ratsam machte, sie auf eine bescheidenere Größe umzuwandeln.
Dies ist nicht mehr der Fall.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Obwohl es versucht, den Speicherverbrauch zu begrenzen, kann dies die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-lpad-exmpl-de]]
==== `LPAD`-Beispiele

[source]
----
lpad ('Hello', 12)               -- Ergebnis '       Hello'
lpad ('Hello', 12, '-')          -- Ergebnis '-------Hello'
lpad ('Hello', 12, '')           -- Ergebnis 'Hello'
lpad ('Hello', 12, 'abc')        -- Ergebnis 'abcabcaHello'
lpad ('Hello', 12, 'abcdefghij') -- Ergebnis 'abcdefgHello'
lpad ('Hello', 2)                -- Ergebnis 'He'
lpad ('Hello', 2, '-')           -- Ergebnis 'He'
lpad ('Hello', 2, '')            -- Ergebnis 'He'
----

.Siehe auch
<<fblangref40-scalarfuncs-rpad-de>>

[[fblangref40-scalarfuncs-octet-length-de]]
=== `OCTET_LENGTH()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
OCTET_LENGTH (_string_)
----

[[fblangref40-funcs-tbl-octetlength-de]]
.`OCTET_LENGTH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt die Länge des Eingabestrings in Bytes (Oktetts) an.
Bei Mehrbyte-Zeichensätzen kann dies kleiner sein als die Anzahl der Zeichen mal der "`formalen`" Anzahl von Bytes pro Zeichen, wie in `RDB$CHARACTER_SETS` gefunden.

[NOTE]
====
Bei Argumenten vom Typ `CHAR`  oder `BINARY` berücksichtigt diese Funktion die gesamte formale Stringlänge (d.h. die deklarierte Länge eines Feldes oder einer Variablen).
Wenn Sie die "`logische`" Bytelänge erhalten möchten, ohne die abschließenden Leerzeichen zu zählen, rechts-<<fblangref40-scalarfuncs-trim-de,`TRIM`>> das Argument vor der Übergabe an `OCTET_LENGTH`.
====

.`BLOB`-Unterstützung
Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[[fblangref40-scalarfuncs-octet-length-exmpl-de]]
==== `OCTET_LENGTH`-Beispiele

[source]
----
select octet_length('Hello!') from rdb$database
-- Ergebnis 6

select octet_length(_iso8859_1 'Grüß di!') from rdb$database
-- Ergebnis 8: ü und ß belegen in ISO8859_1 jeweils ein Byte

select octet_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- Ergebnis 10: ü und ß belegen in UTF8 jeweils zwei Byte

select octet_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- Ergebnis 26: alle 24 CHAR-Positionen zählen, und zwei davon sind 2-Byte
----

.Siehe auch
<<fblangref40-scalarfuncs-bit-length-de>>, <<fblangref40-scalarfuncs-char-length-de>>

[[fblangref40-scalarfuncs-overlay-de]]
=== `OVERLAY()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
OVERLAY (_string_ PLACING _replacement_ FROM _pos_ [FOR _length_])
----

[[fblangref40-funcs-tbl-overlay-de]]
.`OVERLAY`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Die Zeichenfolge, in die die Ersetzung erfolgt

|replacement
|Ersetzende Zeichenkette

|pos
|Die Position, von der aus ersetzt wird (Ausgangsposition)

|length
|Die Anzahl der zu überschreibenden Zeichen
|===

`OVERLAY()` überschreibt einen Teil eines Strings mit einem anderen String.
Standardmäßig entspricht die Anzahl der aus der Hostzeichenfolge entfernten (überschriebenen) Zeichen der Länge der Ersetzungszeichenfolge.
Mit dem optionalen vierten Argument kann eine andere Anzahl von Zeichen zum Entfernen angegeben werden.

* Diese Funktion unterstützt ``BLOB``s beliebiger Länge.
* Wenn _string_ oder _replacement_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_ der Summe der Längen von _string_ und _replacement_.
* Wie bei SQL-Stringfunktionen üblich, ist _pos_ 1-basiert.
* Wenn _pos_ hinter dem Ende von _string_ steht, wird _replacement_ direkt nach _string_ platziert.
* Wenn die Anzahl der Zeichen von _pos_ bis zum Ende von _string_ kleiner ist als die Länge von _replacement_ (oder als das _length_-Argument, falls vorhanden), wird _string_ an _pos_ abgeschnitten und _replacement_ dahinter platziert.
* Eine "```FOR 0```"-Klausel bewirkt, dass _replacement_ einfach in _string_ eingefügt wird.
* Wenn ein Argument `NULL` ist, ist das Ergebnis `NULL`.
* Wenn _pos_ oder _length_ keine ganze Zahl ist, wird Banker-Rundung (auf-gerade) angewendet, d. h. 0,5 wird zu 0, 1,5 wird zu 2, 2,5 wird zu 2, 3,5 wird zu 4 usw.

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-overlay-exmpl-de]]
==== `OVERLAY`-Beispiele

[source]
----
overlay ('Goodbye' placing 'Hello' from 2)   -- Ergebnis 'GHelloe'
overlay ('Goodbye' placing 'Hello' from 5)   -- Ergebnis 'GoodHello'
overlay ('Goodbye' placing 'Hello' from 8)   -- Ergebnis 'GoodbyeHello'
overlay ('Goodbye' placing 'Hello' from 20)  -- Ergebnis 'GoodbyeHello'

overlay ('Goodbye' placing 'Hello' from 2 for 0) -- Ergebnis 'GHellooodbye'
overlay ('Goodbye' placing 'Hello' from 2 for 3) -- Ergebnis 'GHellobye'
overlay ('Goodbye' placing 'Hello' from 2 for 6) -- Ergebnis 'GHello'
overlay ('Goodbye' placing 'Hello' from 2 for 9) -- Ergebnis 'GHello'

overlay ('Goodbye' placing '' from 4)        -- Ergebnis 'Goodbye'
overlay ('Goodbye' placing '' from 4 for 3)  -- Ergebnis 'Gooe'
overlay ('Goodbye' placing '' from 4 for 20) -- Ergebnis 'Goo'

overlay ('' placing 'Hello' from 4)          -- Ergebnis 'Hello'
overlay ('' placing 'Hello' from 4 for 0)    -- Ergebnis 'Hello'
overlay ('' placing 'Hello' from 4 for 20)   -- Ergebnis 'Hello'
----

.Siehe auch
<<fblangref40-scalarfuncs-replace-de>>

[[fblangref40-scalarfuncs-position-de]]
=== `POSITION()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
  POSITION (_substr_ IN _string_)
| POSITION (_substr_, _string_ [, _startpos_])
----

[[fblangref40-funcs-tbl-position-de]]
.`POSITION`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|substr
|Der Teilstring, dessen Position gesucht werden soll

|string
|Der zu suchende String

|startpos
|Die Position in _string_, an der die Suche beginnen soll
|===

Gibt die (1-basierte) Position des ersten Vorkommens einer Teilzeichenfolge in einer Hostzeichenfolge zurück.
Mit dem optionalen dritten Argument beginnt die Suche an einem bestimmten Offset, wobei alle Übereinstimmungen ignoriert werden, die früher in der Zeichenfolge auftreten können.
Wenn keine Übereinstimmung gefunden wird, ist das Ergebnis 0.

[NOTE]
====
* Das optionale dritte Argument wird nur in der zweiten Syntax (Komma-Syntax) unterstützt.
* Die leere Zeichenfolge wird als Teilzeichenfolge jeder Zeichenfolge betrachtet.
Wenn also _substr_ `''` (leerer String) ist und _string_ nicht `NULL` ist, ist das Ergebnis:
+
--
** 1 wenn _startpos_ nicht angegeben ist;
** _startpos_ wenn _startpos_ innerhalb von _string_ liegt;
** 0, wenn _startpos_ hinter dem Ende von _string_ liegt.
--
+
**Hinweis:** Ein Fehler in Firebird 2.1 - 2.1.3 und 2.5.0 führt dazu, dass `POSITION` _immer_ 1 zurückgibt, wenn _substr_ der leere String ist.
Dies ist in 2.1.4 und 2.5.1 behoben.
* Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Größe und jedes Zeichensatzes.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-position-exmpl-de]]
==== `POSITION`-Beispiele

[source]
----
position ('be' in 'To be or not to be')   -- Ergebnis 4
position ('be', 'To be or not to be')     -- Ergebnis 4
position ('be', 'To be or not to be', 4)  -- Ergebnis 4
position ('be', 'To be or not to be', 8)  -- Ergebnis 17
position ('be', 'To be or not to be', 18) -- Ergebnis 0
position ('be' in 'Alas, poor Yorick!')   -- Ergebnis 0
----

.Siehe auch
<<fblangref40-scalarfuncs-substring-de>>

[[fblangref40-scalarfuncs-replace-de]]
=== `REPLACE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
REPLACE (_str_, _find_, _repl_)
----

[[fblangref40-funcs-tbl-replace]]
.`REPLACE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Die Zeichenfolge, in der die Ersetzung erfolgen soll

|find
|Die Zeichenfolge, nach der gesucht werden soll

|repl
|Die Ersatzzeichenfolge
|===

Ersetzt alle Vorkommen einer Teilzeichenfolge in einer Zeichenfolge.

* Diese Funktion unterstützt vollständig Text ``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
* Wenn ein Argument ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_, das aus den Längen von _str_, _find_ und _repl_ so berechnet wird, dass auch die maximal mögliche Anzahl von Ersetzungen das Feld nicht überläuft.
* Wenn _find_ der leere String ist, wird _str_ unverändert zurückgegeben.
* Wenn _repl_ der leere String ist, werden alle Vorkommen von _find_ aus _str_ gelöscht.
* Wenn ein Argument `NULL` ist, ist das Ergebnis immer `NULL`, auch wenn nichts ersetzt worden wäre.

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-replace-exmpl-de]]
==== `REPLACE`-Beispiele

[source]
----
replace ('Billy Wilder',  'il', 'oog') -- Ergebnis 'Boogly Woogder'
replace ('Billy Wilder',  'il',    '') -- Ergebnis 'Bly Wder'
replace ('Billy Wilder',  null, 'oog') -- Ergebnis NULL
replace ('Billy Wilder',  'il',  null) -- Ergebnis NULL
replace ('Billy Wilder', 'xyz',  null) -- Ergebnis NULL (!)
replace ('Billy Wilder', 'xyz', 'abc') -- Ergebnis 'Billy Wilder'
replace ('Billy Wilder',    '', 'abc') -- Ergebnis 'Billy Wilder'
----

.Siehe auch
<<fblangref40-scalarfuncs-overlay-de>>, <<fblangref40-scalarfuncs-substring-de>>, <<fblangref40-scalarfuncs-position-de>>, <<fblangref40-scalarfuncs-char-length-de>>

[[fblangref40-scalarfuncs-reverse-de]]
=== `REVERSE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR`

.Syntax
[listing,subs=+quotes]
----
REVERSE (_string_)
----

[[fblangref40-funcs-tbl-reverse-de]]
.`REVERSE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs
|===

Gibt eine Zeichenfolge rückwärts zurück.

[[fblangref40-scalarfuncs-reverse-exmpl-de]]
==== `REVERSE`-Beispiele
[source]
----
reverse ('spoonful')            -- Ergebnis 'lufnoops'
reverse ('Was it a cat I saw?') -- Ergebnis '?was I tac a ti saW'
----

[TIP]
====
Diese Funktion ist sehr praktisch, wenn Sie nach String-Endungen gruppieren, suchen oder sortieren möchten, z.B. beim Umgang mit Domainnamen oder E-Mail-Adressen:

[source]
----
create index ix_people_email on people
  computed by (reverse(email));

select * from people
  where reverse(email) starting with reverse('.br');
----
====

[[fblangref40-scalarfuncs-right-de]]
=== `RIGHT()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
RIGHT (_string_, _length_)
----

[[fblangref40-funcs-tbl-right-de]]
.`RIGHT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|string
|Ein Ausdruck eines String-Typs

|length
|Integer.
Definiert die Anzahl der zurückzugebenden Zeichen
|===

Gibt den ganz rechten Teil der Argumentzeichenfolge zurück.
Die Anzahl der Zeichen wird im zweiten Argument angegeben.

* Diese Funktion unterstützt Text ``BLOB`s' beliebiger Länge, hat aber einen Fehler in den Versionen 2.1 - 2.1.3 und 2.5.0, der dazu führt, dass es bei Text ``BLOB``s fehlschlägt, die größer als 1024 Bytes sind, die ein Multi haben -Byte-Zeichensatz.
Dies wurde in den Versionen 2.1.4 und 2.5.1 behoben.
* Wenn _string_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(__n__)` mit _n_ der Länge des Eingabestrings.
* Wenn das Argument _length_ die Stringlänge überschreitet, wird der Eingabestring unverändert zurückgegeben.
* Wenn das Argument _Länge_ keine ganze Zahl ist, wird Banker-Rundung (auf-gerade) angewendet, d. h. 0,5 wird zu 0, 1,5 wird zu 2, 2,5 wird zu 2, 3,5 wird zu 4 usw.

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

.Siehe auch
<<fblangref40-scalarfuncs-left-de>>, <<fblangref40-scalarfuncs-substring-de>>

[[fblangref40-scalarfuncs-rpad-de]]
=== `RPAD()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
RPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref40-funcs-tbl-rpad-de]]
.`RPAD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|endlen
|Länge der Ausgabezeichenfolge

|endlen
|Das Zeichen oder die Zeichenfolge, die verwendet werden soll, um die Quellzeichenfolge bis zur angegebenen Länge aufzufüllen.
Standard ist Leerzeichen (`' '`)
|===

Füllt eine Zeichenfolge mit der rechten Maustaste mit Leerzeichen oder mit einer vom Benutzer angegebenen Zeichenfolge auf, bis eine bestimmte Länge erreicht ist.

* Diese Funktion unterstützt vollständig Text ``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.
* Wenn _str_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist das Ergebnis ein `VARCHAR(_endlen_)`.
* Wenn _padstr_ angegeben ist und gleich `''` (leerer String) ist, findet kein Auffüllen statt.
* Wenn _endlen_ kleiner als die aktuelle Stringlänge ist, wird der String auf _endlen_ gekürzt, auch wenn _padstr_ der leere String ist.

[NOTE]
====
In Firebird 2.1-2.1.3 waren alle Nicht-``BLOB``-Ergebnisse vom Typ `VARCHAR(32765)`, was es ratsam machte, sie auf eine bescheidenere Größe umzuwandeln.
Dies ist nicht mehr der Fall.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Obwohl es versucht, den Speicherverbrauch zu begrenzen, kann dies die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-rpad-exmpl-de]]
==== `RPAD`-Beispiele

[source]
----
rpad ('Hello', 12)               -- Ergebnis 'Hello       '
rpad ('Hello', 12, '-')          -- Ergebnis 'Hello-------'
rpad ('Hello', 12, '')           -- Ergebnis 'Hello'
rpad ('Hello', 12, 'abc')        -- Ergebnis 'Helloabcabca'
rpad ('Hello', 12, 'abcdefghij') -- Ergebnis 'Helloabcdefg'
rpad ('Hello', 2)                -- Ergebnis 'He'
rpad ('Hello', 2, '-')           -- Ergebnis 'He'
rpad ('Hello', 2, '')            -- Ergebnis 'He'
----

.Siehe auch
<<fblangref40-scalarfuncs-lpad-de>>

[[fblangref40-scalarfuncs-substring-de]]
=== `SUBSTRING()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyps
`VARCHAR` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
SUBSTRING ( <substring-args> )

<substring-args> ::=
    _str_ FROM _startpos_ [FOR _length_]
  | _str_ SIMILAR <similar-pattern> ESCAPE <escape>

<similar-pattern> ::=
  <similar-pattern-R1>
  <escape> " <similar-pattern-R2> <escape> "
  <similar-pattern-R3>
----

[[fblangref40-funcs-tbl-substring-de]]
.`SUBSTRING`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|startpos
|Ganzzahliger Ausdruck, die Position, von der aus mit dem Abrufen der Teilzeichenfolge begonnen werden soll

|length
|Die Anzahl der abzurufenden Zeichen nach dem _startpos_

|similar-pattern
|Muster für reguläre SQL-Ausdrücke, um nach der Teilzeichenfolge zu suchen

|escape
|Escape-Zeichen
|===

Gibt die Teilzeichenfolge einer Zeichenfolge beginnend an der angegebenen Position zurück, entweder bis zum Ende der Zeichenfolge oder mit einer bestimmten Länge, oder extrahiert eine Teilzeichenfolge mithilfe eines Musters für reguläre SQL-Ausdrücke.

Wenn ein Argument `NULL` ist, ist das Ergebnis auch `NULL`.

[WARNING]
====
Bei Verwendung auf einem `BLOB` muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Obwohl es versucht, den Speicherverbrauch zu begrenzen, kann dies die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-substring-pos-de]]
==== Positionsbezogener `SUBSTRING`

In ihrer einfachen Positionsform (mit `FROM`) gibt diese Funktion den Teilstring ab der Zeichenposition _startpos_ zurück (das erste Zeichen ist 1).
Ohne das Argument `FOR` gibt es alle verbleibenden Zeichen in der Zeichenfolge zurück.
Bei `FOR` gibt es _length_ Zeichen oder den Rest des Strings zurück, je nachdem welcher kürzer ist.

Seit Firebird 4.0 kann _startpos_ kleiner als 1 sein.
Wenn _startpos_ kleiner als 1 ist, verhält sich Teilzeichenfolge so, als ob die Zeichenfolge `1 - __startpos__` zusätzliche Positionen vor dem eigentlichen ersten Zeichen an Position `1` hätte.
Die _Länge_ wird von diesem imaginären Anfang der Zeichenfolge aus betrachtet, sodass die resultierende Zeichenfolge kürzer als die angegebene _Länge_ oder sogar leer sein kann.

Die Funktion unterstützt vollständig binäre und Text ``BLOB``s beliebiger Länge und mit jedem Zeichensatz.
Wenn _str_ ein `BLOB` ist, ist das Ergebnis auch ein `BLOB`.
Bei jedem anderen Argumenttyp ist das Ergebnis ein `VARCHAR`.

Bei Nicht-``BLOB``-Argumenten entspricht die Breite des Ergebnisfelds immer der Länge von _str_, unabhängig von _startpos_ und _length_.
`substring('pinhead' from 4 for 2)` gibt also ein `VARCHAR(7)` zurück, das den String `'he'` enthält.

.Beispiele
[source]
----
insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames;

select substring('abcdef' from 1 for 2) from rdb$database;
-- Ergebnis: 'ab'

select substring('abcdef' from 2) from rdb$database;
-- Ergebnis: 'bcdef'

select substring('abcdef' from 0 for 2) from rdb$database;
-- Ergebnis: 'a'
-- und NICHT 'ab', da "nichts" an Position 0 existiert

select substring('abcdef' from -5 for 2) from rdb$database;
-- Egebnis: ''
-- length endet vor dem eigentlichen Anfang des Strings
----

[[fblangref40-scalarfuncs-substring-regexp-de]]
==== Regulärer Ausdruck `SUBSTRING`

In der Form des regulären Ausdrucks (mit `SIMILAR`) gibt die Funktion `SUBSTRING` einen Teil des Strings zurück, der einem Muster eines regulären SQL-Ausdrucks entspricht.
Wenn keine Übereinstimmung gefunden wird, wird `NULL` zurückgegeben.

Das Muster "SIMILAR" wird aus drei Mustern für reguläre SQL-Ausdrücke gebildet, _R1_, _R2_ und _R3_.
Das gesamte Muster hat die Form `R1 || '__<Escape>__"' || R2 || '__<Escape>__"' || R3`, wobei _<escape>_ das in der `ESCAPE`-Klausel definierte Escape-Zeichen ist.
_R2_ ist das Muster, das mit der zu extrahierenden Teilzeichenfolge übereinstimmt, und wird zwischen doppelten Anführungszeichen mit Escapezeichen eingeschlossen (`__<escape>__"`, zB "```++#"++```" mit Escape-Zeichen '``` +##++```').
_R1_ entspricht dem Präfix des Strings und _R3_ dem Suffix des Strings.
Sowohl _R1_ als auch _R3_ sind optional (sie können leer sein), aber das Muster muss mit der gesamten Zeichenfolge übereinstimmen.
Mit anderen Worten, es reicht nicht aus, ein Muster anzugeben, das nur die zu extrahierende Teilzeichenfolge findet.

[TIP]
====
Die mit Escapezeichen versehenen doppelten Anführungszeichen um _R2_ können mit der Definition einer einzelnen Erfassungsgruppe in einer gängigeren Syntax für reguläre Ausdrücke wie PCRE verglichen werden.
Das heißt, das vollständige Muster entspricht `__R1__(__R2__)__R3__`, das mit der gesamten Eingabezeichenfolge übereinstimmen muss, und die Erfassungsgruppe ist die zurückzugebende Teilzeichenfolge.
====

[NOTE]
====
Wenn einer von _R1_, _R2_ oder _R3_ keine Zeichenfolge der Länge Null ist und nicht das Format eines regulären SQL-Ausdrucks hat, wird eine Ausnahme ausgelöst.
====

Das vollständige Format für reguläre SQL-Ausdrücke wird in <<fblangref40-commons-syntaxregex-de,Syntax: Reguläre SQL-Ausdrücke>> beschrieben

.Beispiele
[source]
----
substring('abcabc' similar 'a#"bcab#"c' escape '#')  -- bcab
substring('abcabc' similar 'a#"%#"c' escape '#')     -- bcab
substring('abcabc' similar '_#"%#"_' escape '#')     -- bcab
substring('abcabc' similar '#"(abc)*#"' escape '#')  -- abcabc
substring('abcabc' similar '#"abc#"' escape '#')     -- <null>
----

.Siehe auch
<<fblangref40-scalarfuncs-position-de>>, <<fblangref40-scalarfuncs-left-de>>, <<fblangref40-scalarfuncs-right-de>>, <<fblangref40-scalarfuncs-char-length-de>>, <<fblangref40-commons-predsimilarto-de,`SIMILAR TO`>>

[[fblangref40-scalarfuncs-trim-de]]
=== `TRIM()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
TRIM ([<adjust>] _str_)

<adjust> ::=  {[<where>] [_what_]} FROM

<where> ::=  BOTH | LEADING | TRAILING
----

[[fblangref40-funcs-tbl-trim-de]]
.`TRIM`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs

|where
|Die Position, aus der der Teilstring entfernt werden soll -- `BOTH` {vbar} `LEADING` {vbar} `TRAILING`.
`BOTH` ist die Standardeinstellung

|what
|Die Teilzeichenfolge, die am Anfang, am Ende oder auf beiden Seiten der Eingabezeichenfolge _str_ entfernt werden soll (mehrmals bei mehreren Übereinstimmungen).
Standardmäßig ist es Leerzeichen (`' '`)
|===

Entfernt führende und/oder nachgestellte Leerzeichen (oder optional andere Zeichenfolgen) aus der Eingabezeichenfolge.
Seit Firebird 2.1 unterstützt diese Funktion vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

[NOTE]
====
Wenn _str_ ein `BLOB` ist, ist das Ergebnis ein `BLOB`.
Andernfalls ist es ein `VARCHAR(__n__)` mit _n_ der formalen Länge von _str_.
====

[WARNING]
====
Bei Verwendung auf einem 'BLOB' muss diese Funktion möglicherweise das gesamte Objekt in den Speicher laden.
Dies kann die Leistung beeinträchtigen, wenn es um große ``BLOB``s geht.
====

[[fblangref40-scalarfuncs-trim-exmpl-de]]
==== `TRIM`-Beispiele
[source]
----
select trim ('  Waste no space   ') from rdb$database
-- Ergebnis 'Waste no space'

select trim (leading from '  Waste no space   ') from rdb$database
-- Ergebnis 'Waste no space   '

select trim (leading '.' from '  Waste no space   ') from rdb$database
-- Ergebnis '  Waste no space   '

select trim (trailing '!' from 'Help!!!!') from rdb$database
-- Ergebnis 'Help'

select trim ('la' from 'lalala I love you Ella') from rdb$database
-- Ergebnis ' I love you El'

select trim ('la' from 'Lalala I love you Ella') from rdb$database
-- Ergebnis 'Lalala I love you El'
----

[[fblangref40-scalarfuncs-upper-de]]
=== `UPPER()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
`(VAR)CHAR`, `(VAR)BINARY` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
UPPER (_str_)
----

[[fblangref40-funcs-tbl-upper-de]]
.`UPPER`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|str
|Ein Ausdruck eines String-Typs
|===

Gibt das Äquivalent der Eingabezeichenfolge in Großbuchstaben zurück.
Das genaue Ergebnis hängt vom Zeichensatz ab.
Bei `ASCII` oder `NONE` beispielsweise werden nur ASCII-Zeichen groß geschrieben;
mit dem Zeichensatz `OCTETS`/`(VAR)BINARY` wird der gesamte String unverändert zurückgegeben.
Seit Firebird 2.1 unterstützt diese Funktion auch Text-``BLOB``s beliebiger Länge und beliebigem Zeichensatz.

[[fblangref40-scalarfuncs-upper-exmpl-de]]
==== `UPPER`-Beispiele

[source]
----
select upper(_iso8859_1 'Débâcle')
from rdb$database
-- Ergebnis 'DÉBÂCLE' (vor Firebird 2.0: 'DéBâCLE')

select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
-- Ergebnis 'DEBACLE', nach französischen Großbuchstabenregeln
----

.Siehe auch
<<fblangref40-scalarfuncs-lower-de>>

[[fblangref40-functions-datetime-de]]
== Datums- und Zeitfunktionen

[[fblangref40-scalarfuncs-dateadd-de]]
=== `DATEADD()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`DATE`, `TIME` oder `TIMESTAMP`

.Syntax
[listing,subs=+quotes]
----
DATEADD (<args>)

<args> ::=
    <amount> <unit> TO <datetime>
  | <unit>, <amount>, <datetime>

<amount> ::= _ein ganzzahliger Ausdruck (negativ zum Subtrahieren)_
<unit> ::=
    YEAR | MONTH | WEEK | DAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<datetime> ::= _ein DATE-, TIME- oder TIMESTAMP-Ausdruck_
----

[[fblangref40-funcs-tbl-dateadd]]
.`DATEADD`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|amount
|Ein ganzzahliger Ausdruck vom Typ `SMALLINT`, `INTEGER` oder `BIGINT`.
Für die Einheit `MILLISECOND` ist der Typ `NUMERIC(18, 1)`.
Ein negativer Wert wird abgezogen.

|unit
|Datum/Uhrzeit-Einheit

|datetime
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`
|===

Addiert die angegebene Anzahl von Jahren, Monaten, Wochen, Tagen, Stunden, Minuten, Sekunden oder Millisekunden zu einem Datums-/Uhrzeitwert.

* Der Ergebnistyp wird durch das dritte Argument bestimmt.
* Mit den Argumenten `TIMESTAMP` und `DATE` können alle Einheiten verwendet werden.
* Bei `TIME`-Argumenten können nur `HOUR`, `MINUTE`, `SECOND` und `MILLISECOND` verwendet werden.

[[fblangref40-funcs-tbl-dateadd-exmpl-de]]
==== Beispiele of `DATEADD`

[source]
----
dateadd (28 day to current_date)
dateadd (-6 hour to current_time)
dateadd (month, 9, DateOfConception)
dateadd (-38 week to DateOfBirth)
dateadd (minute, 90, cast('now' as time))
dateadd (? year to date '11-Sep-1973')
----

[source]
----
select
  cast(dateadd(-1 * extract(millisecond from ts) millisecond to ts) as varchar(30)) as t,
  extract(millisecond from ts) as ms
from (
  select timestamp '2014-06-09 13:50:17.4971' as ts
  from rdb$database
) a
----

[listing]
----
T                        MS
------------------------ ------
2014-06-09 13:50:17.0000  497.1
----

.Siehe auch
<<fblangref40-scalarfuncs-datediff-de>>, <<fblangref40-datatypes-datetimeops-de,Operationen mit Datums- und Uhrzeitwerten>>

[[fblangref40-scalarfuncs-datediff-de]]
=== `DATEDIFF()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
DATEDIFF (<args>)

<args> ::=
    <unit> FROM <moment1> TO <moment2>
  | <unit>, <moment1>, <moment2>

<unit> ::=
    YEAR | MONTH | WEEK | DAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<momentN> ::= _ein DATE-, TIME- oder TIMESTAMP-Ausdruck_
----

[[fblangref40-funcs-tbl-datediff-de]]
.`DATEDIFF`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|unit
|Datum/Uhrzeit-Einheit

|moment1
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`

|moment2
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`
|===

Gibt die Anzahl der Jahre, Monate, Wochen, Tage, Stunden, Minuten, Sekunden oder Millisekunden zurück, die zwischen zwei Datums-/Uhrzeitwerten verstrichen sind.
(Die Einheit `WOCHE` ist neu in 2.5.)

* Die Argumente `DATE` und `TIMESTAMP` können kombiniert werden.
Andere Mischungen sind nicht erlaubt.
* Mit den Argumenten `TIMESTAMP` und `DATE` können alle Einheiten verwendet werden.
(Vor Firebird 2.5 waren Einheiten, die kleiner als `DAY` waren, für ``DATE``s nicht zulässig.)
* Bei `TIME`-Argumenten können nur `HOUR`, `MINUTE`, `SECOND` und `MILLISECOND` verwendet werden.

.Berechnung
* `DATEDIFF` betrachtet keine kleineren Einheiten als die im ersten Argument angegebene.
Als Ergebnis,
** `datediff (Jahr, Datum '1-Jan-2009', Datum '31-Dez-2009')` gibt 0 zurück, aber
** `datediff (Jahr, Datum '31-Dez-2009', Datum '1-Jan-2010')' gibt 1 zurück
* Es betrachtet jedoch alle _größeren_ Einheiten. So:
** `datediff (Tag, Datum '26-Jun-1908', Datum '11-Sep-1973')' gibt 23818 zurück
* Ein negativer Ergebniswert bedeutet, dass _moment2_ vor _moment1_ liegt.

[[fblangref40-scalarfuncs-datediff-exmpl-de]]
==== `DATEDIFF`-Beispiele

[source]
----
datediff (hour from current_timestamp to timestamp '12-Jun-2059 06:00')
datediff (minute from time '0:00' to current_time)
datediff (month, current_date, date '1-1-1900')
datediff (day from current_date to cast(? as date))
----

.Siehe auch
<<fblangref40-scalarfuncs-dateadd-de>>, <<fblangref40-datatypes-datetimeops-de,Operationen mit Datums- und Uhrzeitwerten>>

[[fblangref40-scalarfuncs-extract-de]]
=== `EXTRACT()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
`SMALLINT` or `NUMERIC`

.Syntax
[listing,subs=+quotes]
----
EXTRACT (<part> FROM <datetime>)

<part> ::=
    YEAR | MONTH | WEEK
  | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
  | TIMEZONE_HOUR | TIMEZONE_MINUTE
<datetime> ::= _ein DATE-, TIME- oder TIMESTAMP-Ausdruck_
----

[[fblangref40-funcs-tbl-extract-de]]
.`EXTRACT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|part
|Datum/Uhrzeit-Einheit

|datetime
|Ein Ausdruck vom Typ `DATE`, `TIME` oder `TIMESTAMP`
|===

Extrahiert ein Element aus einem `DATE`, `TIME` oder `TIMESTAMP` Ausdruck und gibt es zurück.

[[fblangref40-scalarfuncs-extract-types-de]]
==== Zurückgegebene Datentypen und Bereiche

Die zurückgegebenen Datentypen und möglichen Bereiche sind in der folgenden Tabelle aufgeführt.
Wenn Sie versuchen, einen Teil zu extrahieren, der nicht im Datum/Uhrzeit-Argument vorhanden ist (z. B. `SECOND` aus einem `DATE` oder `YEAR` aus einer `TIME`), tritt ein Fehler auf.

[[fblangref40-tbl-extractranges-de]]
.Arten und Bereiche von `EXTRACT`-Ergebnissen
[cols="<1m,<1m,<1,<2", options="header"]
|===
| Teil
| Typ
| Bereich
| Anmerkung

|YEAR
|SMALLINT
|1-9999
|{nbsp}

|MONTH
|SMALLINT
|1-12
|{nbsp}

|WEEK
|SMALLINT
|1-53
|{nbsp}

|DAY
|SMALLINT
|1-31
|{nbsp}

|WEEKDAY
|SMALLINT
|0-6
|0 = Sonntag

|YEARDAY
|SMALLINT
|0-365
|0 = 1. Januar

|HOUR
|SMALLINT
|0-23
|{nbsp}

|MINUTE
|SMALLINT
|0-59
|{nbsp}

|SECOND
|NUMERIC(9,4)
|0.0000-59.9999
|beinhaltet Millisekunden als Bruch

|MILLISECOND
|NUMERIC(9,1)
|0.0-999.9
|fehlerhaft in 2.1, 2.1.1

|TIMEZONE_HOUR
|SMALLINT
|-23 - {plus}23
|{nbsp}

|TIMEZONE_MINUTE
|SMALLINT
|-59 - {plus}59
|{nbsp}
|===

[[fblangref40-scalarfuncs-extract-millisecond-de]]
===== `MILLISECOND`

Firebird 2.1 und höher unterstützen die Extraktion der Millisekunde aus einer `TIME` oder `TIMESTAMP`.
Der zurückgegebene Datentyp ist `NUMERIC(9,1)`.

[NOTE]
====
Wenn Sie die Millisekunde aus <<fblangref40-contextvars-current-time-de>> extrahieren, beachten Sie, dass diese Variable standardmäßig auf die Sekundengenauigkeit eingestellt ist, sodass das Ergebnis immer 0 ist.
Extrahieren Sie aus `CURRENT_TIME(3)` oder <<fblangref40-contextvars-current-timestamp-de>>, um eine Genauigkeit in Millisekunden zu erhalten.
====

[[fblangref40-scalarfuncs-extract-week-de]]
===== `WEEK`

Firebird 2.1 und höher unterstützen die Extraktion der ISO-8601-Wochennummer aus einem "DATE" oder "TIMESTAMP".
ISO-8601-Wochen beginnen an einem Montag und haben immer die vollen sieben Tage.
Woche 1 ist die erste Woche mit einem Großteil (mindestens 4) der Tage im neuen Jahr.
Die ersten 1-3 Tage des Jahres können zur letzten Woche (52 oder 53) des Vorjahres gehören.
Ebenso können die letzten 1-3 Tage eines Jahres zur ersten Woche des Folgejahres gehören.

[CAUTION]
====
Seien Sie vorsichtig, wenn Sie die Ergebnisse von `WOCHE` und `JAHR` kombinieren.
Zum Beispiel liegt der 30. Dezember 2008 in Woche 1 von 2009, also gibt `extract(week from date '40 Dec 2008')' 1 zurück.
Das Extrahieren von `YEAR` ergibt jedoch immer das Kalenderjahr, das 2008 ist.
In diesem Fall sind "WOCHE" und "JAHR" uneins.
Das gleiche passiert, wenn die ersten Januartage zur letzten Woche des Vorjahres gehören.

Bitte beachten Sie auch, dass `WEEKDAY` _nicht_ ISO-8601-kompatibel ist: Es gibt 0 für Sonntag zurück, während ISO-8601 7 angibt.
====

.Siehe auch
<<fblangref40-datatypes-datetime-de,Datentypen für Datum und Uhrzeit>>

[[fblangref40-scalarfuncs-firstday-de]]
=== `FIRST_DAY()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`DATE`, `TIMESTAMP` (mit oder ohne Zeitzone)

.Syntax
[listing,subs=+quotes]
----
FIRST_DAY(OF <period> FROM _date_or_timestamp_)

<period> ::= YEAR | MONTH | WEEK
----

[[fblangref40-scalarfuncs-tbl-firstday-de]]
.`FIRST_DAY`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|date_or_timestamp
|Ausdruck vom Typ `DATE`, `TIMESTAMP WITHOUT TIME ZONE` oder `TIMESTAMP WITH TIME ZONE`
|===

`FIRST_DAY` gibt ein Datum oder einen Zeitstempel (gleich dem Typ von _date_or_timestamp_) mit dem ersten Tag des Jahres, des Monats oder der Woche eines gegebenen Datums- oder Zeitstempelwerts zurück.

[NOTE]
====
* Der erste Tag der Woche gilt als Sonntag, nach den gleichen Regeln wie für <<fblangref40-scalarfuncs-extract-de>> mit `WEEKDAY`.
* Wenn ein Zeitstempel übergeben wird, behält der Rückgabewert den Zeitteil bei.
====

[[fblangref40-scalarfuncs-firstday-exmpl-de]]
==== Beispiel für `FIRST_DAY`

[source]
----
select first_day(of month from current_date) from rdb$database;
select first_day(of year from current_timestamp) from rdb$database;
select first_day(of week from date '2017-11-01') from rdb$database;
----

[[fblangref40-scalarfuncs-lastday-de]]
=== `LAST_DAY()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`DATE`, `TIMESTAMP` (mit oder ohne Zeitzone)

.Syntax
[listing,subs=+quotes]
----
LAST_DAY(OF <period> FROM _date_or_timestamp_)

<period> ::= YEAR | MONTH | WEEK
----

[[fblangref40-scalarfuncs-tbl-lastday-de]]
.`LAST_DAY`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|date_or_timestamp
|Ausdruck vom Typ `DATE`, `TIMESTAMP WITHOUT TIME ZONE` oder `TIMESTAMP WITH TIME ZONE`
|===

`LAST_DAY` gibt ein Datum oder einen Zeitstempel (gleich dem Typ von _date_or_timestamp_) mit dem letzten Tag des Jahres, des Monats oder der Woche eines gegebenen Datums- oder Zeitstempelwerts zurück.

[NOTE]
====
* Der letzte Tag der Woche gilt als Samstag, nach den gleichen Regeln wie für <<fblangref40-scalarfuncs-extract-de>> mit `WEEKDAY`.
* Wenn ein Zeitstempel übergeben wird, behält der Rückgabewert den Zeitteil bei.
====

[[fblangref40-scalarfuncs-lastday-lastday-de]]
==== Beispiele für `LAST_DAY`

[source]
----
select last_day(of month from current_date) from rdb$database;
select last_day(of year from current_timestamp) from rdb$database;
select last_day(of week from date '2017-11-01') from rdb$database;
----

[[fblangref40-functions-casting-de]]
== Typ-Casting-Funktionen

[[fblangref40-scalarfuncs-cast-de]]
=== `CAST()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
Wie von _target_type_ angegeben

.Syntax
[listing,subs="+quotes,macros"]
----
CAST (<expression> AS <target_type>)

<target_type> ::= <domain_or_non_array_type> | <array_datatype>

<domain_or_non_array_type> ::=
  !! Siehe auch <<fblangref40-datatypes-syntax-scalar-syntax-de,Syntax für skalare Datentypen>> !!

<array_datatype> ::=
  !! Siehe auch <<fblangref40-datatypes-syntax-array-de,Syntax der Array-Datentypen>> !!
----

[[fblangref40-funcs-tbl-cast-de]]
.`CAST`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|expression
|SQL-Ausdruck

|sql_datatype
|SQL-Datentyp
|===

`CAST` wandelt einen Ausdruck in den gewünschten Datentyp oder die gewünschte Domäne um.
Wenn die Konvertierung nicht möglich ist, wird ein Fehler ausgegeben.

.Casting ``BLOB``s
Erfolgreiches Casting zu und von ``BLOB``s ist seit Firebird 2.1 möglich.

[[fblangref40-scalarfuncs-shortcast-de]]
==== Syntax für "`Kurzschreibweise`"

Alternative Syntax, die nur unterstützt wird, wenn ein Stringliteral in ein `DATE`, `TIME` oder `TIMESTAMP` umgewandelt wird:

[source]
----
datatype 'date/timestring'
----

Diese Syntax war bereits in InterBase verfügbar, wurde jedoch nie richtig dokumentiert.
Im SQL-Standard heißt diese Funktion "`datetime literals`".

[NOTE]
====
Seit Firebird 4.0 ist die Verwendung von `'NOW'`, `'YESTERDAY'` und `'TOMORROW'` in der Kurzform nicht mehr erlaubt; nur Literale, die einen festen Zeitpunkt definieren, werden unterstützt.
====

[[fblangref40-scalarfuncs-cast-conv-de]]
==== Zulässige Typumwandlungen

Die folgende Tabelle zeigt die mit `CAST` möglichen Typkonvertierungen.

[[fblangref40-tbl-cast-de]]
.Mögliche Type-Castings mit `CAST`
[%autowidth,cols="2*", options="header", stripes="none"]
|===
| Von
| Nach

|Numerische Typen
|Numerische Typen +
`[VAR]CHAR` +
`BLOB`

|`[VAR]CHAR` +
`BLOB`
| `[VAR]CHAR` +
`BLOB` +
Numerische Typen +
`DATE` +
`TIME` +
`TIMESTAMP`

|`DATE` +
`TIME`
|`[VAR]CHAR` +
`BLOB` +
`TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR` +
`BLOB` +
`DATE` +
`TIME`
|===

Denken Sie daran, dass manchmal Informationen verloren gehen, zum Beispiel wenn Sie einen `TIMESTAMP` in ein `DATE` umwandeln.
Auch die Tatsache, dass Typen ``CAST``-kompatibel sind, ist noch keine Garantie dafür, dass eine Konvertierung erfolgreich ist.
"```CAST(123456789 as SMALLINT)```" führt definitiv zu einem Fehler, ebenso wie "```CAST('Judgement Day' as DATE)```".

[[fblangref40-scalarfuncs-cast-params-de]]
==== Casting-Parameter

Seit Firebird 2.0 können Sie Anweisungsparameter in einen Datentyp umwandeln:

[source]
----
cast (? as integer)
----

Dies gibt Ihnen die Kontrolle über den Typ des Parameters, der von der Engine eingerichtet wird.
Bitte beachten Sie, dass Sie bei Anweisungsparametern immer eine vollständige Syntaxumwandlung benötigen – Kurzformumwandlungen werden nicht unterstützt.

[[fblangref40-scalarfuncs-cast-domain-de]]
==== Casting in eine Domain oder deren Typ

Firebird 2.1 und höher unterstützen das Casting in eine Domäne oder deren Basistyp.
Beim Casting in eine Domain müssen alle für die Domain deklarierten Constraints (`NOT NULL` und/oder `CHECK`) erfüllt sein, sonst schlägt das Casting fehl.
Bitte beachten Sie, dass ein `CHECK` erfolgreich ist, wenn es als `TRUE` _oder_ `NULL` ausgewertet wird!
Also folgende Aussagen gegeben:

[source]
----
create domain quint as int check (value >= 5000);
select cast (2000 as quint) from rdb$database;     -- <1>
select cast (8000 as quint) from rdb$database;     -- <2>
select cast (null as quint) from rdb$database;     -- <3>
----

nur die Besetzungsnummer _1_ führt zu einem Fehler.

Wenn der Modifikator `TYPE OF` verwendet wird, wird der Ausdruck in den Basistyp der Domäne umgewandelt, wobei alle Einschränkungen ignoriert werden.
Mit der oben definierten Domain 'quint' sind die folgenden beiden Casts äquivalent und werden beide erfolgreich sein:

[source]
----
select cast (2000 as type of quint) from rdb$database;
select cast (2000 as int) from rdb$database;
----

Wenn `TYPE OF` mit einem `(VAR)CHAR`-Typ verwendet wird, werden sein Zeichensatz und seine Kollatierung beibehalten:

[source]
----
create domain iso20 varchar(20) character set iso8859_1;
create domain dunl20 varchar(20) character set iso8859_1 collate du_nl;
create table zinnen (zin varchar(20));
commit;
insert into zinnen values ('Deze');
insert into zinnen values ('Die');
insert into zinnen values ('die');
insert into zinnen values ('deze');

select cast(zin as type of iso20) from zinnen order by 1;
-- Ergebnis Deze -> Die -> deze -> die

select cast(zin as type of dunl20) from zinnen order by 1;
-- Ergebnis deze -> Deze -> die -> Die
----

[WARNING]
====
Wenn die Definition einer Domain geändert wird, können bestehende ``CAST``s für diese Domain oder ihr Typ ungültig werden.
Wenn diese ``CAST``s in PSQL-Modulen vorkommen, kann ihre Ungültigkeit erkannt werden.
Siehe Hinweis <<fblangref40-appx01-supp-rdb-validblr-de,[ref]_Das RDB$VALID_BLR-Feld_>> in Anhang A.
====

[[fblangref40-scalarfuncs-cast-coltype-de]]
==== Umwandeln in den Typ einer Spalte

In Firebird 2.5 und höher ist es möglich, Ausdrücke in den Typ einer vorhandenen Tabelle oder Ansichtsspalte umzuwandeln.
Nur der Typ selbst wird verwendet;
bei String-Typen umfasst dies den Zeichensatz, aber nicht die Kollatierung.
Einschränkungen und Standardwerte der Quellspalte werden nicht angewendet.

[source]
----
create table ttt (
  s varchar(40) character set utf8 collate unicode_ci_ai
);
commit;

select cast ('Jag har många vänner' as type of column ttt.s)
from rdb$database;
----

.Warnungen
[WARNING]
====
Wenn die Definition einer Spalte geändert wird, können vorhandene ``CAST``s für den Typ dieser Spalte ungültig werden.
Wenn diese ``CAST``s in PSQL-Modulen vorkommen, kann ihre Ungültigkeit erkannt werden.
Siehe den Hinweis <<fblangref40-appx01-supp-rdb-validblr-de,[ref]_Das RDB$VALID_BLR-Feld_>> in Anhang A.
====

[[fblangref40-scalarfuncs-cast-exmpl-de]]
==== Cast-Beispiele

Ein Vollsyntax Cast:

[source]
----
select cast ('12' || '-June-' || '1959' as date) from rdb$database
----

Eine Kurzschreibweise zur Umwandlung von String zu Datum:

[source]
----
update People set AgeCat = 'Old'
  where BirthDate < date '1-Jan-1943'
----

Beachten Sie, dass Sie sogar die Kurzform aus dem obigen Beispiel weglassen können, da die Engine aus dem Kontext (Vergleich mit einem `DATE`-Feld) versteht, wie die Zeichenfolge zu interpretieren ist:

[source]
----
update People set AgeCat = 'Old'
  where BirthDate < '1-Jan-1943'
----

Jedoch ist dies nicht immer möglich.
Der folgende Cast kann nicht weggelassen werden, sonst würde sich die Engine mit einer Ganzzahl wiederfinden, die von einer Zeichenfolge subtrahiert werden soll:

[source]
----
select cast('today' as date) - 7 from rdb$database
----

[[fblangref40-functions-bitwise-de]]
== Bitweise Funktionen

[[fblangref40-scalarfuncs-bin-and-de]]
=== `BIN_AND()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_AND (_number_, _number_ [, _number_ ...])
----

[[fblangref40-funcs-tbl-binand-de]]
.`BIN_AND`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skalierung 0)
|===

Gibt das Ergebnis der bitweisen _AND_-Operation für die Argumente zurück.

.Siehe auch
<<fblangref40-scalarfuncs-bin-or-de>>, <<fblangref40-scalarfuncs-bin-xor-de>>

[[fblangref40-scalarfuncs-bin-not-de]]
=== `BIN_NOT()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_NOT (_number_)
----

[[fblangref40-funcs-tbl-binnot-de]]
.`BIN_NOT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skala 0)
|===

Gibt das Ergebnis der bitweisen _NOT_-Operation für das Argument zurück, d.h. das _Einser-Komplement_.

.Siehe auch
<<fblangref40-scalarfuncs-bin-or-de>>, <<fblangref40-scalarfuncs-bin-xor-de>> und weitere.

[[fblangref40-scalarfuncs-bin-or-de]]
=== `BIN_OR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_OR (_number_, _number_ [, _number_ ...])
----

[[fblangref40-funcs-tbl-binor-de]]
.`BIN_OR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skalierung 0)
|===

Gibt das Ergebnis der bitweisen _OR_-Operation für die Argumente zurück.

.Siehe auch
<<fblangref40-scalarfuncs-bin-and-de>>, <<fblangref40-scalarfuncs-bin-xor-de>>

[[fblangref40-scalarfuncs-bin-shl-de]]
=== `BIN_SHL()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
BIN_SHL (_number_, _shift_)
----

[[fblangref40-funcs-tbl-binshl-de]]
.`BIN_SHL`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines ganzzahligen Typs

|shift
|Die Anzahl der Bits, um die der Zahlenwert verschoben wird
|===

Gibt das erste Argument bitweise linksverschoben um das zweite Argument zurück, d. h. `a << b` oder `a·2^b^`.

.Siehe auch
<<fblangref40-scalarfuncs-bin-shr-de>>

[[fblangref40-scalarfuncs-bin-shr-de]]
=== `BIN_SHR()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
BIN_SHR (_number_, _shift_)
----

[[fblangref40-funcs-tbl-binshr-de]]
.`BIN_SHR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Eine Zahl eines ganzzahligen Typs

|shift
|Die Anzahl der Bits, um die der Zahlenwert verschoben wird
|===

Gibt das erste Argument bitweise nach rechts verschoben um das zweite Argument zurück, d. h. `a >> b` oder `a/2^b^`.

* Die ausgeführte Operation ist eine arithmetische Rechtsverschiebung (SAR), dh das Vorzeichen des ersten Operanden bleibt immer erhalten.

.Siehe auch
<<fblangref40-scalarfuncs-bin-shl-de>>

[[fblangref40-scalarfuncs-bin-xor-de]]
=== `BIN_XOR()`

.Verfügbar in
DSQL, PSQL

.Möglicher Namenskonflikt
YES -> <<fblangref40-functions-nameclashes-de,Details lesen>>

.Ergebnistyp
`SMALLINT`, `INTEGER` oder `BIGINT`

[NOTE]
====
Das Ergebnis `SMALLINT` wird nur zurückgegeben, wenn alle Argumente explizit ``SMALLINT``s oder `NUMERIC(__n__, 0)` mit _n_ +<=+ 4 sind;
andernfalls geben kleine Ganzzahlen ein `INTEGER`-Ergebnis zurück.
====

.Syntax
[listing,subs=+quotes]
----
BIN_XOR (_number_, _number_ [, _number_ ...])
----

[[fblangref40-funcs-tbl-binxor]]
.`BIN_XOR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|number
|Beliebige ganze Zahl (literal, smallint/integer/bigint, numerisch/dezimal mit Skalierung 0)
|===

Gibt das Ergebnis der bitweisen _XOR_-Operation für die Argumente zurück.

.Siehe auch
<<fblangref40-scalarfuncs-bin-and-de>>, <<fblangref40-scalarfuncs-bin-or-de>>

[[fblangref40-functions-uuid-de]]
== UUID-Funktionen

[[fblangref40-scalarfuncs-char-to-uuid-de]]
=== `CHAR_TO_UUID()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BINARY(16)`

.Syntax
[listing,subs=+quotes]
----
CHAR_TO_UUID (_ascii_uuid_)
----

[[fblangref40-funcs-tbl-char-to-uuid-de]]
.`CHAR_TO_UUID`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|ascii_uuid
|Eine 36-stellige Darstellung der UUID.
'```-```' (Bindestrich) in den Positionen 9, 14, 19 und 24;
gültige Hexadezimalziffern an beliebigen anderen Stellen, z.B. 'A0bF4E45-3029-2a44-D493-4998c9b439A3'
|===

Konvertiert eine für Menschen lesbare 36-stellige UUID-Zeichenfolge in die entsprechende 16-Byte-UUID.

[[fblangref40-scalarfuncs-char-to-uuid-exmpl-de]]
==== `CHAR_TO_UUID`-Beispiele

[source]
----
select char_to_uuid('A0bF4E45-3029-2a44-D493-4998c9b439A3') from rdb$database
-- Ergebnis A0BF4E4530292A44D4934998C9B439A3 (16-Byte String)

select char_to_uuid('A0bF4E45-3029-2A44-X493-4998c9b439A3') from rdb$database
-- Fehler: - Menschlich lesbares UUID-Argument für CHAR_TO_UUID 
             muss eine Hex-Ziffer an Position 20 anstelle von "X (ASCII 88)" haben
----

.Siehe auch
<<fblangref40-scalarfuncs-uuid-to-char-de>>, <<fblangref40-scalarfuncs-gen-uuid-de>>

[[fblangref40-scalarfuncs-gen-uuid-de]]
=== `GEN_UUID()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`BINARY(16)`

.Syntax
[listing]
----
GEN_UUID ()
----

Gibt eine universell eindeutige ID als 16-Byte-Zeichenfolge zurück.

[[fblangref40-scalarfuncs-gen-uuid-exmpl-de]]
==== `GEN_UUID`-Beispiel

[source]
----
select gen_uuid() from rdb$database
-- Ergebnis e.g. 017347BFE212B2479C00FA4323B36320 (16-Byte String)
----

.Siehe auch
<<fblangref40-scalarfuncs-uuid-to-char-de>>, <<fblangref40-scalarfuncs-char-to-uuid-de>>

[[fblangref40-scalarfuncs-uuid-to-char-de]]
=== `UUID_TO_CHAR()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
`CHAR(36)`

.Syntax
[listing,subs=+quotes]
----
UUID_TO_CHAR (_uuid_)
----

[[fblangref40-funcs-tbl-uuid-to-char-de]]
.`UUID_TO_CHAR`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|uuid
|16-Byte UUID
|===

Konvertiert eine 16-Byte-UUID in ihre 36-stellige, für Menschen lesbare ASCII-Darstellung.

[[fblangref40-scalarfuncs-uuid-to-char-exmpl-de]]
==== `UUID_TO_CHAR`-Beispiele

[source]
----
select uuid_to_char(x'876C45F4569B320DBCB4735AC3509E5F') from rdb$database
-- Ergebnis '876C45F4-569B-320D-BCB4-735AC3509E5F'

select uuid_to_char(gen_uuid()) from rdb$database
-- Ergebnis e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

select uuid_to_char('Firebird swings!') from rdb$database
-- Ergebnis '46697265-6269-7264-2073-77696E677321'
----

.Siehe auch
<<fblangref40-scalarfuncs-char-to-uuid-de>>, <<fblangref40-scalarfuncs-gen-uuid-de>>

[[fblangref40-functions-generators-de]]
== Funktionen für Sequenzen (Generatoren)

[[fblangref40-scalarfuncs-gen-id-de]]
=== `GEN_ID()`

.Verfügbar in
DSQL, ESQL, PSQL

.Ergebnistyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
GEN_ID (_generator-name_, _step_)
----

[[fblangref40-funcs-tbl-gen-id-de]]
.`GEN_ID`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|generator-name
|Name eines vorhandenen Generators (Sequenz).
Wenn er in doppelten Anführungszeichen mit einem Bezeichner definiert wurde, bei dem die Groß-/Kleinschreibung beachtet wird, muss er in derselben Form verwendet werden, es sei denn, der Name wird ausschließlich in Großbuchstaben geschrieben.

|step
|Ein ganzzahliger Ausdruck
|===

Erhöht einen Generator oder eine Sequenz und gibt den neuen Wert zurück.
Wenn Schritt gleich 0 ist, lässt die Funktion den Wert des Generators unverändert und gibt seinen aktuellen Wert zurück.
 
* Ab Firebird 2.0 wird die SQL-kompatible Syntax <<fblangref40-commons-nxtvlufor-de,`NEXT VALUE FOR`>> bevorzugt, außer wenn eine andere Erhöhung als 1 benötigt wird.

[WARNING]
====
Wenn der Wert des Schrittparameters kleiner als Null ist, wird der Wert des Generators verringert.
Achtung! Bei solchen Manipulationen in der Datenbank sollten Sie äußerst vorsichtig sein, da sie die Datenintegrität beeinträchtigen könnten.
====

[[fblangref40-scalarfuncs-gen-id-exmpl-de]]
==== `GEN_ID`-Beispiel

[source]
----
new.rec_id = gen_id(gen_recnum, 1);
----

.Siehe auch
<<fblangref40-commons-nxtvlufor-de,`NEXT VALUE FOR`>>, <<fblangref40-ddl-sequence-create-de,`CREATE SEQUENCE (GENERATOR)`>>

[[fblangref40-functions-conditional-de]]
== Bedingte Funktionen

[[fblangref40-scalarfuncs-coalesce-de]]
=== `COALESCE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing]
----
COALESCE (<exp1>, <exp2> [, <expN> ... ])
----

[[fblangref40-funcs-tbl-coalesce]]
.`COALESCE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exp1, exp2 ... expN
|Eine Liste von Ausdrücken aller kompatiblen Typen
|===

Die Funktion `COALESCE` nimmt zwei oder mehr Argumente und gibt den Wert des ersten Nicht-``NULL``-Arguments zurück.
Wenn alle Argumente `NULL` ergeben, ist das Ergebnis `NULL`.

[[fblangref40-scalarfuncs-coalesce-exmpl-de]]
==== `COALESCE`-Beispiele

Dieses Beispiel wählt den `Nickname` aus der `Persons`-Tabelle.
Wenn es `NULL` ist, geht es weiter zu `FirstName`.
Ist auch dieser `NULL`, wird "```'Mr./Mrs.'```" verwendet.
Schließlich fügt es den Familiennamen hinzu.
Insgesamt wird versucht, aus den verfügbaren Daten einen möglichst informellen vollständigen Namen zusammenzustellen.
Beachten Sie, dass dieses Schema nur funktioniert, wenn fehlende Spitznamen und Vornamen wirklich `NULL` sind: Wenn einer von ihnen stattdessen ein leerer String ist, wird `COALESCE` diesen glücklich an den Aufrufer zurückgeben.

[source]
----
select
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
    as FullName
from Persons
----

.Siehe auch
<<fblangref40-scalarfuncs-iif-de>>, <<fblangref40-scalarfuncs-nullif-de>>, <<fblangref40-commons-conditional-case-de,`CASE`>>

[[fblangref40-scalarfuncs-decode-de]]
=== `DECODE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing]
----
DECODE(<testexpr>,
  <expr1>, <result1>
  [<expr2>, <result2> …]
  [, <defaultresult>])
----

Das äquivalente `CASE`-Konstrukt:

[listing]
----
CASE <testexpr>
  WHEN <expr1> THEN <result1>
  [WHEN <expr2> THEN <result2> …]
  [ELSE <defaultresult>]
END
----

[[fblangref40-funcs-tbl-decode-de]]
.`DECODE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|testexpr
|Ein Ausdruck eines beliebigen kompatiblen Typs, der mit den Ausdrücken expr1, expr2 ... exprN . verglichen wird

|expr1, expr2, ... exprN
|Ausdrücke beliebiger kompatibler Typen, mit denen der Ausdruck _testexpr_ verglichen wird

|result1, result2, ... resultN
|Rückgabewerte jeglichen Typs

|defaultresult
|Der Ausdruck, der zurückgegeben werden soll, wenn keine der Bedingungen erfüllt ist
|===

`DECODE` ist eine Abkürzung für das sogenannte <<fblangref40-commons-conditional-case-simple-de,"`Einfaches ``CASE```"-Konstrukt>>, in dem ein gegebener Ausdruck mit einer Anzahl von andere Ausdrücke, bis eine Übereinstimmung gefunden wird.
Das Ergebnis wird durch den Wert bestimmt, der nach dem übereinstimmenden Ausdruck aufgeführt ist.
Wenn keine Übereinstimmung gefunden wird, wird das Standardergebnis zurückgegeben, falls vorhanden.
Andernfalls wird `NULL` zurückgegeben.

[CAUTION]
====
Der Abgleich erfolgt mit dem Operator '```=```'. Wenn also _testexpr_ `NULL` ist, wird es mit keinem der __expr__s übereinstimmen, nicht einmal mit denen, die `NULL` sind.
====

[[fblangref40-scalarfuncs-decode-exmpl-de]]
==== `DECODE`-Beispiele

[source]
----
select name,
  age,
  decode(upper(sex),
         'M', 'Male',
         'F', 'Female',
         'Unknown'),
  religion
from people
----

.Siehe auch
<<fblangref40-commons-conditional-case-de,`CASE`>>, <<fblangref40-commons-conditional-case-simple-de,Einfaches `CASE`>>

[[fblangref40-scalarfuncs-iif-de]]
=== `IIF()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing,subs=+quotes]
----
IIF (<condition>, _ResultT_, _ResultF_)
----

[[fblangref40-funcs-tbl-iif-de]]
.`IIF`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|condition
|Ein wahrer{vbar}falscher Ausdruck

|resultT
|Der zurückgegebene Wert, wenn die Bedingung wahr ist

|resultF
|Der zurückgegebene Wert, wenn die Bedingung falsch ist
|===

`IIF` benötigt drei Argumente.
Wenn das erste Argument `true` ergibt, wird das zweite Argument zurückgegeben;
andernfalls wird die dritte zurückgegeben.

`IIF` könnte in C-ähnlichen Sprachen mit dem ternären Operator "```?:```" verglichen werden.

[NOTE]
====
`IIF(<Cond>, __Result1__, __Result2__)` ist eine Abkürzung für "```CASE WHEN <Cond> THEN __Result1__ ELSE __Result2__ END```".
====

[[fblangref40-scalarfuncs-iif-exmpl-de]]
==== `IIF`-Beispiele

[source]
----
select iif( sex = 'M', 'Sir', 'Madam' ) from Customers
----

.Siehe auch
<<fblangref40-commons-conditional-case-de,`CASE`>>, <<fblangref40-scalarfuncs-decode-de>>

[[fblangref40-scalarfuncs-maxvalue-de]]
=== `MAXVALUE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Variiert je nach Eingabe -- das Ergebnis hat denselben Datentyp wie der erste Ausdruck in der Liste (_expr1_).

.Syntax
[listing]
----
MAXVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref40-funcs-tbl-maxvalue]]
.`MAXVALUE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|expr1 ... exprN
|Liste der Ausdrücke kompatibler Typen
|===

Gibt den Höchstwert aus einer Liste von numerischen, Zeichenfolgen- oder Datums-/Uhrzeitausdrücken zurück.
Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

Wenn ein oder mehrere Ausdrücke in `NULL` aufgelöst werden, gibt `MAXVALUE` `NULL` zurück.
Dieses Verhalten unterscheidet sich von der Aggregatfunktion `MAX`.

[[fblangref40-scalarfuncs-maxvalue-exmpl-de]]
==== `MAXVALUE`-Beispiele

[source]
----
SELECT MAXVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
----

.Siehe auch
<<fblangref40-scalarfuncs-minvalue-de>>

[[fblangref40-scalarfuncs-minvalue-de]]
=== `MINVALUE()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Variiert je nach Eingabe -- das Ergebnis hat denselben Datentyp wie der erste Ausdruck in der Liste (_expr1_).

.Syntax
[listing]
----
MINVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref40-funcs-tbl-minvalue-de]]
.`MINVALUE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|expr1 ... exprN
|Liste der Ausdrücke kompatibler Typen
|===

Gibt den Mindestwert aus einer Liste von numerischen, Zeichenfolgen- oder Datums-/Uhrzeitausdrücken zurück.
Diese Funktion unterstützt vollständig Text-``BLOB``s jeder Länge und jedes beliebigen Zeichensatzes.

Wenn ein oder mehrere Ausdrücke in `NULL` aufgelöst werden, gibt `MINVALUE` `NULL` zurück.
Dieses Verhalten unterscheidet sich von der Aggregatfunktion `MIN`.

[[fblangref40-scalarfuncs-minvalue-exmpl-de]]
==== `MINVALUE`-Beispiele

[source]
----
SELECT MINVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
----

.Siehe auch
<<fblangref40-scalarfuncs-maxvalue-de>>

[[fblangref40-scalarfuncs-nullif-de]]
=== `NULLIF()`

.Verfügbar in
DSQL, PSQL

.Ergebnistyp
Abhängig von der Eingabe

.Syntax
[listing]
----
NULLIF (<exp1>, <exp2>)
----

[[fblangref40-funcs-tbl-nullif-de]]
.`NULLIF`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|exp1
|Ein Ausdruck

|exp2
|Ein anderer Ausdruck eines Datentyps, der mit _exp1_ kompatibel ist
|===

`NULLIF` gibt den Wert des ersten Arguments zurück, es sei denn, es ist gleich dem zweiten.
In diesem Fall wird `NULL` zurückgegeben.


[[fblangref40-scalarfuncs-nullif-exmpl-de]]
==== `NULLIF`-Beispiel

[source]
----
select avg( nullif(Weight, -1) ) from FatPeople
----

Dadurch wird das durchschnittliche Gewicht der in FatPeople aufgelisteten Personen zurückgegeben, mit Ausnahme derer mit einem Gewicht von -1, da "AVG" "NULL"-Daten überspringt.
Vermutlich bedeutet -1 in dieser Tabelle "`Gewicht unbekannt`".
Ein einfaches `AVG(Weight)` würde die -1 Gewichte enthalten, wodurch das Ergebnis verzerrt wird.

.Siehe auch
<<fblangref40-scalarfuncs-coalesce-de>>, <<fblangref40-scalarfuncs-decode-de>>, <<fblangref40-scalarfuncs-iif-de>>, <<fblangref40-commons-conditional-case-de,`CASE`>>

[[fblangref40-scalarfuncs-decfloat-de]]
== Spezialfunktionen für `DECFLOAT`

[[fblangref40-scalarfuncs-comparedecfloat-de]]
=== `COMPARE_DECFLOAT()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`SMALLINT`

.Syntax
[listings,subs=+quotes]
----
COMPARE_DECFLOAT (_decfloat1_, _decfloat2_)
----

[[fblangref40-scalarfuncs-tbl-comparedecfloat-de]]
.`COMPARE_DECFLOAT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|decfloat__n__
|Wert oder Ausdruck vom Typ `DECFLOAT`, oder Cast-kompatibel mit `DECFLOAT`
|===

`COMPARE_DECFLOAT` vergleicht zwei `DECFLOAT`-Werte als gleich, unterschiedlich oder ungeordnet.
Das Ergebnis ist ein `SMALLINT`-Wert wie folgt:

[horizontal]
`0`:: Werte sind identisch
`1`:: Erster Wert ist kleiner als der zweite Wert
`2`:: Erster Wert ist größer als der zweite Wert
`3`:: Die Werte sind ungeordnet, d. h. einer oder beide sind `NaN`/`sNaN`

Im Gegensatz zu den Vergleichsoperatoren ('```<```', '```=```', '```>```' usw.) ist der Vergleich exakt: `COMPARE_DECFLOAT(2.17, 2.170) ` gibt `2` zurück, nicht `0`.

.Siehe auch
<<fblangref40-scalarfuncs-totalorder-de>>

[[fblangref40-scalarfuncs-normalizedecfloat-de]]
=== `NORMALIZE_DECFLOAT()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`DECFLOAT`

.Syntax
[listing,subs=+quotes]
----
NORMALIZE_DECFLOAT (_decfloat_value_)
----

[[fblangref40-scalarfuncs-tbl-normalizedecfloat-de]]
.`NORMALIZE_DECFLOAT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|decfloat_value
|Wert oder Ausdruck vom Typ `DECFLOAT`, oder Cast-kompatibel mit `DECFLOAT`
|===

`NORMALIZE_DECFLOAT` nimmt ein einzelnes `DECFLOAT`-Argument und gibt es in seiner einfachsten Form zurück.
Das bedeutet, dass für jeden Wert ungleich Null nachfolgende Nullen mit entsprechender Exponentenkorrektur entfernt werden.

[[fblangref40-scalarfuncs-normalizedecfloat-exmpl-de]]
==== Beispiele für `NORMALIZE_DECFLOAT`

[source]
----
-- Gibt 12 zurück
select normalize_decfloat(12.00)
from rdb$database;

-- Gibt 1.2E+2 zurück
select normalize_decfloat(120)
from rdb$database;
----

[[fblangref40-scalarfuncs-quantize-de]]
=== `QUANTIZE()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp

.Syntax
[listing,subs=+quotes]
----
QUANTIZE (_decfloat_value_, _exp_value_)
----

[[fblangref40-scalarfuncs-tbl-quantize]]
.`QUANTIZE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|decfloat_value
|Wert oder Ausdruck zum Quantisieren;
muss vom Typ `DECFLOAT` sein oder Cast-kompatibel mit `DECFLOAT`

|exp_value
|Wert oder Ausdruck, der für seinen Exponenten verwendet werden soll;
muss vom Typ `DECFLOAT` sein oder Cast-kompatibel mit `DECFLOAT`
|===

`QUANTIZE` gibt einen `DECFLOAT`-Wert zurück, der in Wert und Vorzeichen (außer Rundung) gleich _decfloat_value_ ist und der einen Exponenten hat, der gleich dem Exponenten von _exp_value_ ist.
Der Rückgabewert ist `DECFLOAT(16)`, wenn beide Argumente `DECFLOAT(16)` sind, andernfalls ist der Ergebnistyp `DECFLOAT(34)`.

[NOTE]
====
Der Zielexponent ist der Exponent, der im Speicherformat `Decimal64` oder `Decimal128` von `DECFLOAT` von _exp_value_ verwendet wird.
Dies ist nicht unbedingt dasselbe wie der Exponent, der in Tools wie _isql_ angezeigt wird.
Zum Beispiel ist der Wert '1.23E+2' Koeffizient '123' und Exponent '0', während '1.2' Koeffizient '12' und Exponent '-1' ist.
====

Wenn der Exponent von _decfloat_value_ größer als der von _exp_value_ ist, wird der Koeffizient von _decfloat_value_ mit einer Zehnerpotenz multipliziert und sein Exponent verringert, ist der Exponent kleiner, dann wird sein Koeffizient mit dem aktuellen decfloat-Rundungsmodus gerundet, und seine Exponent wird erhöht.

Wenn es nicht möglich ist, den Zielexponenten zu erreichen, weil der Koeffizient die Zielgenauigkeit (16 oder 34 Dezimalstellen) überschreiten würde, wird entweder ein Fehler "`__Decfloat float invalid operation__`" ausgegeben oder `NaN` zurückgegeben (je nach aktuellem) Konfiguration der decfloat Traps).

Es gibt fast keine Einschränkungen für den _exp_value_.
In fast allen Anwendungen erzeugt `NaN`/`sNaN`/`Infinity` jedoch eine Ausnahme (sofern dies nicht durch die aktuelle decfloat-Traps-Konfiguration erlaubt ist), `NULL` lässt die Funktion `NULL` zurückgeben und so weiter.

[[fblangref40-scalarfuncs-quantize-exmpl-de]]
==== Beispiele für `QUANTIZE`

[source]
----
select v, pic, quantize(v, pic) from examples;

     V    PIC QUANTIZE
====== ====== ========
  3.16  0.001    3.160
  3.16   0.01     3.16
  3.16    0.1      3.2
  3.16      1        3
  3.16   1E+1     0E+1
  -0.1      1       -0
     0   1E+5     0E+5
   316    0.1    316.0
   316      1      316
   316   1E+1   3.2E+2
   316   1E+2     3E+2
----

[[fblangref40-scalarfuncs-totalorder-de]]
=== `TOTALORDER()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
TOTALORDER (_decfloat1_, _decfloat2_)
----

[[fblangref40-scalarfuncs-tbl-totalorder-de]]
.`TOTALORDER`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|decfloat__n__
|Wert oder Ausdruck vom Typ `DECFLOAT`, oder Cast-kompatibel mit `DECFLOAT`
|===

`TOTALORDER` vergleicht zwei `DECFLOAT`-Werte einschließlich aller Sonderwerte.
Der Vergleich ist genau und gibt ein `SMALLINT` zurück, eines der folgenden:

[horizontal]
`-1`:: Erster Wert is kleiner als der zweite
`0`:: Werte sind identisch
`1`:: Erster Wert ist größer als der zweite

Für `TOTALORDER`-Vergleiche werden die `DECFLOAT`-Werte wie folgt geordnet:

[listing]
----
-NaN < -sNaN < -INF < -0.1 < -0.10 < -0 < 0 < 0.10 < 0.1 < INF < sNaN < NaN
----

.Siehe auch
<<fblangref40-scalarfuncs-comparedecfloat-de>>

[[fblangref40-scalarfuncs-crypto-de]]
== Kryptografische Funktionen

[[fblangref40-scalarfuncs-decrypt-de]]
=== `DECRYPT()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY` oder `BLOB`

.Syntax
[listing,subs=+quotes]
----
DECRYPT ( _encrypted_input_
  USING <algorithm> [MODE <mode>]
  KEY _key_
  [IV _iv_] [<ctr_type>] [CTR_LENGTH _ctr_length_]
  [COUNTER _initial_counter_] )

!! Vgl. auch die Syntax von <<fblangref40-scalarfuncs-encrypt-de,`ENCRYPT`>> für weitere Details !!
----

[[fblangref40-scalarfuncs-tbl-decrypt-de]]
.`DECRYPT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|encrypted_input
|Verschlüsselte Eingabe als Blob oder (binärer) String

2+| Siehe auch <<fblangref40-scalarfuncs-tbl-encrypt-de>> für weitere Parameter
|===

`DECRYPT` entschlüsselt Daten mit einer symmetrischen Verschlüsselung.

[NOTE]
====
* Größen von Datenstrings (wie _encrypted_input_, _key_ und _iv_) müssen die Anforderungen des ausgewählten Algorithmus und Modus erfüllen.
* Diese Funktion gibt `BLOB SUB_TYPE BINARY` zurück, wenn das erste Argument ein `BLOB` ist, und `VARBINARY` für alle anderen Text- und Binärtypen.
* Wenn es sich bei den verschlüsselten Daten um Text handelte, müssen sie explizit in einen Stringtyp mit entsprechendem Zeichensatz umgewandelt werden.
* Die Besonderheiten der verschiedenen Algorithmen werden außerhalb des Rahmens dieser Sprachreferenz betrachtet.
Wir empfehlen, im Internet nach weiteren Details zu den Algorithmen zu suchen.
====

[[fblangref40-scalarfuncs-decrypt-exmpl-de]]
==== `DECRYPT`-Beispiele

[source]
----
select decrypt(x'0154090759DF' using sober128 key 'AbcdAbcdAbcdAbcd' iv '01234567')
  from rdb$database;
select decrypt(secret_field using aes mode ofb key '0123456701234567' iv init_vector)
  from secure_table;
----

.Siehe auch
<<fblangref40-scalarfuncs-encrypt-de>>, <<fblangref40-scalarfuncs-rsadecrypt-de>>

[[fblangref40-scalarfuncs-encrypt-de]]
=== `ENCRYPT()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY` oder `BLOB`

.Syntax
[listing,subs="+quotes,macros"]
----
ENCRYPT ( _input_
  USING <algorithm> [MODE <mode>]
  KEY _key_
  [IV _iv_] [<ctr_type>] [CTR_LENGTH _ctr_length_]
  [COUNTER _initial_counter_] )

<algorithm> ::= <block_cipher> | <stream_cipher>

<block_cipher> ::=
    AES | ANUBIS | BLOWFISH | KHAZAD | RC5
  | RC6 | SAFER+ | TWOFISH | XTEA

<stream_cipher> ::= CHACHA20 | RC4 | SOBER128

<mode> ::= CBC | CFB | CTR | ECB | OFB

<ctr_type> ::= CTR_BIG_ENDIAN | CTR_LITTLE_ENDIAN
----

[[fblangref40-scalarfuncs-tbl-encrypt-de]]
.`ENCRYPT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|input
|Eingabe zum Verschlüsseln als Blob oder (binäre) Zeichenfolge

|algorithm
|Der für die Entschlüsselung zu verwendende Algorithmus

|mode
|Der Algorithmusmodus;
nur für Blockchiffren

|key
|Der Verschlüsselungs-/Entschlüsselungsschlüssel

|iv
|Initialisierungsvektor oder Nonce;
sollte für Blockchiffren in allen Modi außer „ECB“ und für alle Stromchiffren außer „RC4“ angegeben werden

|ctr_type
|Endianität des Zählers;
nur für `CTR`-Modus.
Der Standardwert ist "CTR_LITTLE_ENDIAN".

|ctr_length
|Zählerlänge;
nur für `CTR`-Modus.
Standard ist die Größe _iv_.

|initial_counter
|Anfangszählerwert;
nur für `CHACHA20`.
Der Standardwert ist `0`.
|===

`ENCRYPT` kann Daten mit einer symmetrischen Verschlüsselung verschlüsseln.

[NOTE]
====
* Diese Funktion gibt `BLOB SUB_TYPE BINARY` zurück, wenn das erste Argument ein `BLOB` ist, und `VARBINARY` für alle anderen Text- und Binärtypen.
* Größen von Datenstrings (wie _key_ und _iv_) müssen die Anforderungen des ausgewählten Algorithmus und Modus erfüllen, siehe Tabelle <<fblangref40-scalarfuncs-tbl-encrypt-req-de>>.
** Im Allgemeinen muss die Größe von _iv_ der Blockgröße des Algorithmus entsprechen
** Für den ECB- und CBC-Modus muss _input_ ein Vielfaches der Blockgröße sein, Sie müssen gegebenenfalls manuell mit Nullen oder Leerzeichen auffüllen.
* Die Besonderheiten der verschiedenen Algorithmen und Modi werden außerhalb des Rahmens dieser Sprachreferenz betrachtet.
Wir empfehlen, im Internet nach weiteren Details zu den Algorithmen zu suchen.
* Obwohl in dieser Sprachreferenz als separate Optionen angegeben, sind `CTR_LENGTH` und `COUNTER` in der aktuellen Firebird 4.0-Syntax Aliase.
====

[[fblangref40-scalarfuncs-tbl-encrypt-req-de]]
.Anforderungen für den Verschlüsselungsalgorithmus
[cols="<1m,<3,<3,<5",options="header",stripes="none"]
|===
|Algorithm
|Schlüsselgröße (Bytes)
|Blockgröße (Bytes)
|Hinweise

4+h|Blockchiffren

|AES
|16, 24, 32
|16
|{nbsp}

|ANUBIS
|16 - 40, in 4er-Schritten
|16
|{nbsp}

|BLOWFISH
|8 - 56
|8
|{nbsp}

|KHAZAD
|16
|8
|{nbsp}

|RC5
|8 - 128
|8
|{nbsp}

|RC6
|8 - 128
|16
|{nbsp}

|SAFER+
|16, 24, 32
|16
|{nbsp}

|TWOFISH
|16, 24, 32
|16
|{nbsp}

|XTEA
|16
|8
|{nbsp}

4+h|Stream-Chiffren

|CHACHA20
|16, 32
|1
|Die Nonce-Größe (IV) beträgt 8 oder 12 Byte.
Für Nonce-Größe 8 ist _initial_counter_ eine 64-Bit-Ganzzahl, für Größe 12 32-Bit.

|RC4
|5 - 256
|1
|{nbsp}

|SOBER128
|4__x__
|1
|Nonce-Größe (IV) beträgt 4__y__ Byte, die Länge ist unabhängig von der Schlüsselgröße.
|===

[[fblangref40-scalarfuncs-encrypt-exmpl-de]]
==== `ENCRYPT`-Beispiele

[source]
----
select encrypt('897897' using sober128 key 'AbcdAbcdAbcdAbcd' iv '01234567')
  from rdb$database;
----

.Siehe auch
<<fblangref40-scalarfuncs-decrypt-de>>, <<fblangref40-scalarfuncs-rsaencrypt-de>>

[[fblangref40-scalarfuncs-rsadecrypt-de]]
=== `RSA_DECRYPT()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_DECRYPT (_encrypted_input_ KEY _private_key_
  [LPARAM _tag_string_] [HASH <hash>] [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref40-scalarfuncs-tbl-rsadecrypt]]
.`RSA_DECRYPT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|encrypted_input
|Input data to decrypt

|private_key
|Anzuwendender privater Schlüssel, PKCS#1-Format

|tag_string
|Ein zusätzliches systemspezifisches Tag, um zu identifizieren, welches System die Nachricht verschlüsselt hat;
Standard ist `NULL`.
Wenn das Tag nicht mit dem übereinstimmt, was während der Verschlüsselung verwendet wurde, wird `RSA_DECRYPT` die Daten nicht entschlüsseln.

|hash
|Der für OAEP-Padding verwendete Hash;
Standard ist `SHA256`.
|===

`RSA_DECRYPT` entschlüsselt _encrypted_input_ mit dem privaten RSA-Schlüssel und dann entpackt OAEP die resultierenden Daten.

Standardmäßig wird OAEP-Padding verwendet.
Die Option „PKCS_1_5“ wechselt zum weniger sicheren PKCS 1.5-Padding.
Diese Option wurde in Firebird 4.0.1 eingeführt.

[WARNING]
====
Die Option `PKCS_1_5` dient nur der Abwärtskompatibilität mit Systemen, die PKCS 1.5-Padding verwenden.
Aus Sicherheitsgründen sollte es *nicht* in neuen Projekten verwendet werden.
====

[NOTE]
====
* Diese Funktion gibt VARBINARY` zurück.
* Wenn es sich bei den verschlüsselten Daten um Text handelte, müssen sie explizit in einen Stringtyp mit entsprechendem Zeichensatz umgewandelt werden.
====

[[fblangref40-scalarfuncs-rsadecrypt-exmpl]]
==== `RSA_DECRYPT`-Beispiele

[TIP]
====
Führen Sie die Beispiele <<fblangref40-scalarfuncs-rsaprivate-exmpl-de,`RSA_PRIVATE`>> und <<fblangref40-scalarfuncs-rsapublic-exmpl-de,`RSA_PUBLIC`>>, <<fblangref40-scalarfuncs-rsaencrypt-exmpl-de>>-Funktionen zuerst aus.
====

[source]
----
select cast(rsa_decrypt(rdb$get_context('USER_SESSION', 'msg')
  key rdb$get_context('USER_SESSION', 'private_key')) as varchar(128))
from rdb$database;
----

.Siehe auch
<<fblangref40-scalarfuncs-rsaencrypt-de>>, <<fblangref40-scalarfuncs-rsaprivate-de>>, <<fblangref40-scalarfuncs-decrypt-de>>

[[fblangref40-scalarfuncs-rsaencrypt-de]]
=== `RSA_ENCRYPT()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_ENCRYPT (_input_ KEY _public_key_
  [LPARAM _tag_string_] [HASH <hash>] [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref40-scalarfuncs-tbl-rsaencrypt-de]]
.`RSA_ENCRYPT`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|input
|Eingabedaten zum Verschlüsseln

|public_key
|Öffentlicher Schlüssel zum Anwenden, PKCS#1-Format

|tag_string
|Ein zusätzliches systemspezifisches Tag, um zu identifizieren, welches System die Nachricht verschlüsselt hat;
Standard ist `NULL`.

|hash
|Der für OAEP-Padding verwendete Hash;
Standard ist `SHA256`.
|===

`RSA_ENCRYPT` füllt _input_ mit dem https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding[OAEP-Padding-Schema^] auf und verschlüsselt es dann mit dem angegebenen öffentlichen RSA-Schlüssel.
Diese Funktion wird normalerweise verwendet, um kurze symmetrische Schlüssel zu verschlüsseln, die dann in Blockchiffren verwendet werden, um eine Nachricht zu verschlüsseln.

Standardmäßig wird OAEP-Padding verwendet.
Die Option `PKCS_1_5` wechselt zum weniger sicheren PKCS 1.5-Padding.
Diese Option wurde in Firebird 4.0.1 eingeführt.

[WARNING]
====
Die Option `PKCS_1_5` dient nur der Abwärtskompatibilität mit Systemen, die PKCS 1.5-Padding verwenden.
Aus Sicherheitsgründen sollte es *nicht* in neuen Projekten verwendet werden.
====

[[fblangref40-scalarfuncs-rsaencrypt-exmpl-de]]
==== `RSA_ENCRYPT`-Beispiele

[TIP]
====
Führen Sie zuerst die Beispiele der Funktionen <<fblangref40-scalarfuncs-rsaprivate-exmpl-de,`RSA_PRIVATE`>> und <<fblangref40-scalarfuncs-rsapublic-exmpl-de,`RSA_PUBLIC`>> aus.
====

[source]
----
select rdb$set_context('USER_SESSION', 'msg', rsa_encrypt('Some message'
  key rdb$get_context('USER_SESSION', 'public_key'))) from rdb$database;
----

.Siehe auch
<<fblangref40-scalarfuncs-rsadecrypt-de>>, <<fblangref40-scalarfuncs-rsapublic-de>>, <<fblangref40-scalarfuncs-encrypt-de>>

[[fblangref40-scalarfuncs-rsaprivate-de]]
=== `RSA_PRIVATE()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_PRIVATE (_key_length_)
----

[[fblangref40-scalarfuncs-tbl-rsaprivate-de]]
.`RSA_PRIVATE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|key_length
|Schlüssellänge in Byte;
mindestens 4, maximal 1024.
Eine Größe von 256 Byte (2048 Bit) oder größer wird empfohlen.
|===

`RSA_PRIVATE` generiert einen privaten RSA-Schlüssel der angegebenen Länge (in Bytes) im PKCS#1-Format.

[NOTE]
====
Je größer die angegebene Länge, desto länger dauert es, bis die Funktion einen privaten Schlüssel generiert.
====

[[fblangref40-scalarfuncs-rsaprivate-exmpl-de]]
==== `RSA_PRIVATE`-Beispiel

[source]
----
select rdb$set_context('USER_SESSION', 'private_key', rsa_private(256))
  from rdb$database;
----

[WARNING]
====
Das Einfügen privater Schlüssel in die Kontextvariablen ist nicht sicher.
SYSDBA und Benutzer mit der Rolle `RDB$ADMIN` oder dem Systemprivileg `MONITOR_ANY_ATTACHMENT` können alle Kontextvariablen aus allen Anhängen sehen.
====

.Siehe auch
<<fblangref40-scalarfuncs-rsapublic-de>>, <<fblangref40-scalarfuncs-rsadecrypt-de>>

[[fblangref40-scalarfuncs-rsapublic-de]]
=== `RSA_PUBLIC()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_PUBLIC (_private_key_)
----

[[fblangref40-scalarfuncs-tbl-rsapublic-de]]
.`RSA_PUBLIC`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|private_key
|Privater RSA-Schlüssel im PKCS#1-Format
|===

`RSA_PUBLIC` gibt den öffentlichen RSA-Schlüssel im PKCS#1-Format für den bereitgestellten privaten RSA-Schlüssel (auch PKCS#1-Format) zurück.

[[fblangref40-scalarfuncs-rsapublic-exmpl-de]]
==== `RSA_PUBLIC`-Beispiele

[TIP]
====
Führen Sie zuerst das Beispiel der Funktion <<fblangref40-scalarfuncs-rsaprivate-exmpl-de,`RSA_PRIVATE`>> aus.
====

[source]
----
select rdb$set_context('USER_SESSION', 'public_key',
  rsa_public(rdb$get_context('USER_SESSION', 'private_key'))) from rdb$database;
----

.Siehe auch
<<fblangref40-scalarfuncs-rsaprivate-de>>, <<fblangref40-scalarfuncs-rsaencrypt-de>>

[[fblangref40-scalarfuncs-rsasignhash-de]]
=== `RSA_SIGN_HASH()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_SIGN_HASH (_message_digest_
  KEY _private_key_
  [HASH <hash>] [SALT_LENGTH _salt_length_]
  [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref40-scalarfuncs-tbl-rsasign-de]]
.`RSA_SIGN_HASH`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|message_digest
|Hash der zu unterschreibenden Nachricht.
Der verwendete Hash-Algorithmus sollte mit _hash_ übereinstimmen.

|private_key
|Privater RSA-Schlüssel im PKCS#1-Format

|hash
|Hash zum Generieren von PSS-Codierung;
Standard ist `SHA256`.
Dies sollte der gleiche Hash sein, der zum Generieren von _message_digest_ verwendet wird.

|salt_length
|Länge des gewünschten Salts in Bytes;
Standard ist 8;
mindestens 1, maximal 32.
Der empfohlene Wert liegt zwischen 8 und 16.
|===

`RSA_SIGN_HASH` führt die PSS-Kodierung des zu signierenden _message_digest_ durch und signiert mit dem privaten RSA-Schlüssel.

[CAUTION]
====
Diese Funktion erwartet den Hash einer Nachricht (oder Message Digest), nicht die eigentliche Nachricht.
Das Argument _hash_ sollte den Algorithmus angeben, der auch verwendet wurde, um diesen Hash zu generieren.

Eine Funktion, die die eigentliche Nachricht zum Hash akzeptiert, könnte in einer zukünftigen Version von Firebird eingeführt werden.
====

.PSS-Enkodierung
****
Probabilistic Signature Scheme (PSS) ist ein kryptografisches Signaturschema, das speziell entwickelt wurde, um moderne Methoden der Sicherheitsanalyse zu ermöglichen, um zu beweisen, dass seine Sicherheit direkt mit der des RSA-Problems zusammenhängt.
Es gibt keinen solchen Beweis für das traditionelle PKCS#1 v1.5-Schema.
****

[[fblangref40-scalarfuncs-rsasignhash-exmpl-de]]
==== `RSA_SIGN_HASH`-Beispiele

[TIP]
====
Führen Sie zuerst das Beispiel der Funktion <<fblangref40-scalarfuncs-rsaprivate-exmpl-de,`RSA_PRIVATE`>> aus.
====

[source]
----
select rdb$set_context('USER_SESSION', 'msg',
  rsa_sign_hash(crypt_hash('Test message' using sha256)
    key rdb$get_context('USER_SESSION', 'private_key'))) from rdb$database;
----

.Siehe auch
<<fblangref40-scalarfuncs-rsaverifyhash-de>>, <<fblangref40-scalarfuncs-rsaprivate-de>>, <<fblangref40-scalarfuncs-crypthash-de>>

[[fblangref40-scalarfuncs-rsaverifyhash-de]]
=== `RSA_VERIFY_HASH()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`BOOLEAN`

.Syntax
[listing,subs=+quotes]
----
RSA_VERIFY_HASH (_message_digest_
  SIGNATURE _signature_ KEY _public_key_
  [HASH <hash>] [SALT_LENGTH _salt_length_]
  [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref40-scalarfuncs-tbl-rsaverify-de]]
.`RSA_VERIFY`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|message_digest
|Hash der zu überprüfenden Nachricht.
Der verwendete Hash-Algorithmus sollte mit _hash_ übereinstimmen.

|signature
|Erwartete Signatur von _input_ generiert von `RSA_SIGN_HASH`

|public_key
|öffentlicher RSA-Schlüssel im PKCS#1-Format, der dem zum Signieren verwendeten privaten Schlüssel entspricht

|hash
|Hash für den Message Digest;
Standard ist `SHA256`.
Dies sollte derselbe Hash sein, der zum Generieren von _message_digest_ und in `RSA_SIGN_HASH` verwendet wird

|salt_length
|Länge des Salts in Bytes;
Standard ist 8;
mindestens 1, maximal 32.
Der Wert muss der in `RSA_SIGN_HASH` verwendeten Länge entsprechen.
|===

`RSA_VERIFY_HASH` führt die PSS-Kodierung des zu verifizierenden _message_digest_ durch und verifiziert die digitale Signatur unter Verwendung des bereitgestellten öffentlichen RSA-Schlüssels.

Standardmäßig wird OAEP-Padding verwendet.
Die Option `PKCS_1_5` wechselt zum weniger sicheren PKCS 1.5-Padding.
Diese Option wurde in Firebird 4.0.1 eingeführt.

[WARNING]
====
Die Option `PKCS_1_5` dient nur der Abwärtskompatibilität mit Systemen, die PKCS 1.5-Padding verwenden.
Aus Sicherheitsgründen sollte es *nicht* in neuen Projekten verwendet werden.
====

[CAUTION]
====
Diese Funktion erwartet den Hash einer Nachricht (oder Message Digest), nicht die eigentliche Nachricht.
Das Argument _hash_ sollte den Algorithmus angeben, der auch verwendet wurde, um diesen Hash zu generieren.

Eine Funktion, die die eigentliche Nachricht zum Hash akzeptiert, könnte in einer zukünftigen Version von Firebird eingeführt werden.
====

[[fblangref40-scalarfuncs-rsaverifyhash-exmpl-de]]
==== `RSA_VERIFY_HASH`-Beispiele

[TIP]
====
Führen Sie die Beispiele <<fblangref40-scalarfuncs-rsaprivate-exmpl-de,`RSA_PRIVATE`>>-, <<fblangref40-scalarfuncs-rsapublic-exmpl-de,`RSA_PUBLIC`>>- und <<fblangref40-scalarfuncs-rsasignhash-exmpl-de>>-Funktionen zuerst aus.
====

[source]
----
select rsa_verify_hash(
  crypt_hash('Test message' using sha256)
  signature rdb$get_context('USER_SESSION', 'msg')
  key rdb$get_context('USER_SESSION', 'public_key'))
from rdb$database
----

.Siehe auch
<<fblangref40-scalarfuncs-rsasignhash-de>>, <<fblangref40-scalarfuncs-rsapublic-de>>, <<fblangref40-scalarfuncs-crypthash-de>>

[[fblangref40-scalarfuncs-other-de]]
== Weitere Funktionen

Funktionen, die in keine andere Kategorie passen.

[[fblangref40-scalarfuncs-makedbkey-de]]
=== `MAKE_DBKEY()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`BINARY(8)`

.Syntax
[listing,subs=+quotes]
----
MAKE_DBKEY (_relation_, _recnum_ [, _dpnum_ [, _ppnum_]])
----

[[fblangref40-scalarfuncs-tbl-makedbkey-de]]
.`RDB$GET_TRANSACTION_CN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|relation
|Relationsname oder Relations-ID

|recnum
|Datensatznummer.
Entweder absolut (wenn _dpnum_ und _ppnum_ fehlen) oder relativ (wenn _dpnum_ vorhanden)

|dpnum
|Datenseitennummer.
Entweder absolut (wenn _ppnum_ nicht vorhanden ist) oder relativ (wenn _ppnum_ vorhanden ist)

|ppnum
|Seitennummer des Zeigers.
|===

`MAKE_DBKEY` erstellt einen DBKEY-Wert unter Verwendung eines Beziehungsnamens oder einer ID, einer Datensatznummer und (optional) einer logischen Nummer der Datenseite und der Zeigerseite.

[NOTE]
====
. Wenn _relation_ ein Zeichenfolgenausdruck oder ein Literal ist, wird es als Beziehungsname behandelt und die Engine sucht nach der entsprechenden Beziehungs-ID.
Bei der Suche wird die Groß-/Kleinschreibung beachtet.
Im Fall eines Zeichenfolgenliterals wird die Beziehungs-ID zum Zeitpunkt der Abfragevorbereitung ausgewertet.
Im Fall von expression wird die Beziehungs-ID zur Ausführungszeit ausgewertet.
Wenn die Relation nicht gefunden werden kann, wird der Fehler `isc_relnotdef` ausgegeben.
. Wenn _relation_ ein numerischer Ausdruck oder ein Literal ist, dann wird es als Relations-ID behandelt und "wie besehen" verwendet, ohne Prüfung gegen bestehende Beziehungen.
Wenn der Argumentwert negativ oder größer als die maximal zulässige Beziehungs-ID (derzeit 65535) ist, wird `NULL` zurückgegeben.
. Das Argument _recnum_ stellt eine absolute Datensatznummer in der Relation dar (wenn die nächsten Argumente _dpnum_ und _ppnum_ fehlen) oder eine Datensatznummer relativ zum ersten Datensatz, angegeben durch die nächsten Argumente.
. Das Argument _dpnum_ ist eine logische Nummer der Datenseite in der Relation (wenn das nächste Argument _ppnum_ fehlt) oder die Anzahl der Datenseiten relativ zur ersten Datenseite, die durch die angegebene _ppnum_ adressiert wird.
. Argument _ppnum_ ist eine logische Nummer der Zeigerseite in der Relation.
. Alle Zahlen sind nullbasiert.
Der maximal zulässige Wert für _dpnum_ und _ppnum_ ist 2^32^ (4294967296).
Wenn _dpnum_ angegeben ist, kann _recnum_ negativ sein.
Wenn _dpnum_ fehlt und _recnum_ negativ ist, wird `NULL` zurückgegeben.
Wenn _ppnum_ angegeben ist, kann _dpnum_ negativ sein.
Wenn _ppnum_ fehlt und _dpnum_ negativ ist, wird `NULL` zurückgegeben.
. Wenn eines der angegebenen Argumente `NULL` ist, ist das Ergebnis ebenfalls `NULL`.
. Das Argument _relation_ wird während der Abfragevorbereitung als `INTEGER` beschrieben, kann aber von einer Client-Anwendung als `VARCHAR` oder `CHAR` überschrieben werden.
Die Argumente _recnum_, _dpnum_ und _ppnum_ werden als `BIGINT` beschrieben.
====

[[fblangref40-scalarfuncs-makedbkey-exmpl-de]]
==== Beispiele für `MAKE_DBKEY`

. Wählen Sie den Datensatz mit dem Beziehungsnamen aus (beachten Sie, dass der Beziehungsname in Großbuchstaben geschrieben ist)
+
[source]
----
select *
from rdb$relations
where rdb$db_key = make_dbkey('RDB$RELATIONS', 0)
----

. Datensatz mit Beziehungs-ID auswählen
+
[source]
----
select *
from rdb$relations
where rdb$db_key = make_dbkey(6, 0)
----

. Wählen Sie alle Datensätze aus, die sich physisch auf der ersten Datenseite befinden
+
[source]
----
select *
from rdb$relations
where rdb$db_key >= make_dbkey(6, 0, 0)
and rdb$db_key < make_dbkey(6, 0, 1)
----

. Wählen Sie alle Datensätze aus, die sich physisch auf der ersten Datenseite der 6. Zeigerseite befinden
+
[source]
----
select *
from SOMETABLE
where rdb$db_key >= make_dbkey('SOMETABLE', 0, 0, 5)
and rdb$db_key < make_dbkey('SOMETABLE', 0, 1, 5)
----

[[fblangref40-scalarfuncs-rdberror-de]]
=== `RDB$ERROR()`

.Verfügbar in
PSQL

.Rückgabetyp
Variiert (siehe Tabelle unten)

.Syntax
[listing]
----
RDB$ERROR (<context>)

<context> ::=
  GDSCODE | SQLCODE | SQLSTATE | EXCEPTION | MESSAGE
----

[[fblangref40-scalarfuncs-rdberror-contexts-de]]
.Kontexte
[cols="1m,1m,3", options="header", frame="none", stripes="none", grid="rows"]
|===
| Kontext
| Rückgabetyp
| Beschreibung

|GDSCODE
|INTEGER
|Firebird-Fehlercode, siehe auch <<fblangref40-contextvars-gdscode-de,`GDSCODE`>>

|SQLCODE
|INTEGER
|(veraltet) SQL-Code, siehe auch <<fblangref40-contextvars-sqlcode-de,`SQLCODE`>>

|SQLSTATE
|CHAR(5) CHARACTER SET ASCII
|SQLstate, siehe auch <<fblangref40-contextvars-sqlstate-de,`SQLSTATE`>>

|EXCEPTION
|VARCHAR(63) CHARACTER SET UTF8
|Name der aktiven benutzerdefinierten Ausnahme oder `NULL`, wenn die aktive Ausnahme eine Systemausnahme ist

|MESSAGE
|VARCHAR(1024) CHARACTER SET UTF8
|Nachrichtentext der aktiven Ausnahme
|===

`RDB$ERROR` gibt Daten des angegebenen Kontexts über die aktive PSQL-Ausnahme zurück.
Sein Geltungsbereich ist auf Ausnahmebehandlungsblöcke in PSQL beschränkt (<<fblangref40-psql-when-de,`WHEN ... DO`>>).
Außerhalb der Ausnahmebehandlungsblöcke gibt `RDB$ERROR` immer `NULL` zurück.
Diese Funktion kann nicht aus DSQL aufgerufen werden.

[[fblangref40-scalarfuncs-rdberror-exmpl-de]]
==== Beispiel für RDB$ERROR

[source]
----
BEGIN
  ...
WHEN ANY DO
  EXECUTE PROCEDURE P_LOG_EXCEPTION(RDB$ERROR(MESSAGE));
END
----

.Siehe auch
<<fblangref40-psql-handleexceptions-de,Abfangen und Behandeln von Fehlern>>, <<fblangref40-contextvars-gdscode-de,`GDSCODE`>>, <<fblangref40-contextvars-sqlcode-de,`SQLCODE`>>, <<fblangref40-contextvars-sqlstate-de,`SQLSTATE`>>

[[fblangref40-scalarfuncs-gettransactioncn-de]]
=== `RDB$GET_TRANSACTION_CN()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
RDB$GET_TRANSACTION_CN (_transaction_id_)
----

[[fblangref40-scalarfuncs-tbl-gettransactioncn-de]]
.`RDB$GET_TRANSACTION_CN`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|transaction_id
|Transaktions-ID
|===

`RDB$GET_TRANSACTION_CN` gibt die Commit-Nummer ("`CN`") der übergebenen Transaktion zurück.

Wenn der Rückgabewert größer als 1 ist, ist dies der tatsächliche _CN_ der Transaktion, wenn sie nach dem Start der Datenbank festgeschrieben wurde.

Die Funktion kann auch eines der folgenden Ergebnisse zurückgeben, das den Commit-Status der Transaktion angibt:

[horizontal]
`-2`:: Transaktion ist tot (zurückgerollt)
`-1`:: Transaktion ist in der Schwebe
`{nbsp}0`:: Transaktion ist aktiv
`{nbsp}1`:: Transaktion, die vor dem Start der Datenbank festgeschrieben wurde oder weniger als die älteste interessante Transaktion für die Datenbank ist
`NULL`:: Die angegebene Transaktionsnummer ist NULL oder größer als Nächste Transaktion für die Datenbank

[NOTE]
====
Weitere Informationen zu _CN_ finden Sie in den _Firebird 4.0 Release Notes_.
====

[[fblangref40-scalarfuncs-gettransactioncn-exmpl-de]]
==== `RDB$GET_TRANSACTION_CN`-Beispiele

[source]
----
select rdb$get_transaction_cn(current_transaction) from rdb$database;
select rdb$get_transaction_cn(123) from rdb$database;
----

[[fblangref40-scalarfuncs-roleinuse-de]]
=== `RDB$ROLE_IN_USE()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`BOOLEAN`

.Syntax
[listing,subs=+quotes]
----
RDB$ROLE_IN_USE (_role_name_)
----

[[fblangref40-scalarfuncs-tbl-roleinuse-de]]
.`RDB$ROLE_IN_USE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|role_name
|Zeichenfolgenausdruck für die zu prüfende Rolle.
Groß-/Kleinschreibung muss mit dem in `RDB$ROLES` gespeicherten Rollennamen übereinstimmen
|===

`RDB$ROLE_IN_USE` gibt TRUE zurück, wenn die angegebene Rolle für die aktuelle Verbindung aktiv ist, andernfalls FALSE.
Im Gegensatz zu <<fblangref40-contextvars-current-role-de,`CURRENT_ROLE`>> -- das nur die explizit angegebene Rolle zurückgibt -- kann diese Funktion verwendet werden, um nach Rollen zu suchen, die standardmäßig aktiv sind, oder auf kumulative Rollen, die von einem explizit aktiviert wurden angegebene Rolle.

[[fblangref40-scalarfuncs-roleinuse-exmpl-de]]
==== `RDB$ROLE_IN_USE`-Beispiel

.Aktuell aktive Rollen auflisten
[source]
----
select rdb$role_name
from rdb$database
where rdb$role_in_use(rdb$role_name);
----

.Siehe auch
<<fblangref40-contextvars-current-role-de,`CURRENT_ROLE`>>

[[fblangref40-scalarfuncs-syspriv-de]]
=== `RDB$SYSTEM_PRIVILEGE()`

.Verfügbar in
DSQL, PSQL

.Rückgabetyp
`BOOLEAN`

.Syntax
[listing,subs="+quotes,macros"]
----
RDB$SYSTEM_PRIVILEGE (<sys_privilege>)

<sys_privilege> ::=
  !! Siehe auch <<fblangref40-security-role-create-de,`CREATE ROLE`>> !!
----

[[fblangref40-scalarfuncs-tbl-syspriv-de]]
.`RDB$SYSTEM_PRIVILEGE`-Funktionsparameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Beschreibung

|sys_privilege
|Systemprivileg
|===

`RDB$SYSTEM_PRIVILEGE` akzeptiert einen Systemprivilegnamen und gibt TRUE zurück, wenn der aktuelle Anhang das angegebene Systemprivileg hat, andernfalls FALSE.

[[fblangref40-scalarfuncs-syspriv-exmpl-de]]
==== `RDB$SYSTEM_PRIVILEGE`-Beispiel

[source]
----
select rdb$system_privilege(user_management) from rdb$database;
----

.Siehe auch
<<fblangref40-security-sys-privs-de,Fein abgestufte Systemprivilegien>>