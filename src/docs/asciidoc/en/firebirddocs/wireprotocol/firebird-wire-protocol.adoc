[[wireprotocol]]
= Firebird Wire Protocol
Carlos Guzman Alvarez; Mark Rotteveel
0.17, TBD
:doctype: book
:sectnums:
:sectanchors:
:toc: left
:toclevels: 3
:outlinelevels: 6:0
:icons: font
:experimental:
:imagesdir: ../../images
:jaybird-url: https://github.com/FirebirdSQL/jaybird
:jaybird-repo: {jaybird-url}[Jaybird]
:net-provider-url: https://github.com/FirebirdSQL/NETProvider
:net-provider-repo: {net-provider-url}[Firebird .NET Data Provider]
:firebird-site: https://firebirdsql.org

toc::[]

[[wireprotocol-introduction]]
== Introduction

This document describes the Firebird wire protocol.
Most of the information was obtained by studying the Firebird source code and implementing the wire protocol in the {net-provider-url}[Firebird .NET provider] and {jaybird-url}[Jaybird (Firebird JDBC driver)].

The protocol is described in the form of the message sent by the client and received from the server.
The described protocol is Firebird/InterBase protocol version 10.
Earlier (InterBase) versions of the protocol are not in scope for this document.
Changes in later protocol versions are described in notes below the description of the relevant version 10 message (currently higher versions are only partially described).

This document is not complete.
It is advisable to consult the _InterBase 6 API Guide_ for additional information on subjects like parsing the status vector, information request items, and the meaning of operations.
You can find this manual under "`InterBase 6.0 Manuals`" in the {firebird-site}/en/reference-manuals/[Reference Manuals] section of the Firebird website.

Unless otherwise indicated, a client request must be flushed to the server for processing.
For some operations the flush can be deferred, so it is sent together with a different operation.
Versions 11 and higher of the wire protocol explicitly support (or even require) deferring of operations, including deferring the read of the response.

In the protocol descriptions below, we include the names of the fields of the structs used in the Firebird sources;
this can make it easier to search for how it's used in Firebird itself.

[#wireprotocol-versions]
== Protocol versions

Below is a high-level overview of the changes per protocol versions.

[#wireprotocol-versions-10]
=== Protocol 10

The "`baseline`" protocol of this document.
It was introduced in InterBase 6.0, and available in Firebird 1.0 and higher.

[#wireprotocol-versions-11]
=== Protocol 11

Protocol 11 was introduced in Firebird 2.1, and introduces support for batching of messages, and lazy responses.

Specifically, it allows you to batch a message creating an object (e.g. a statement or blob), with subsequent operations on that object (e.g. information request, statement prepare, blob get, etc.) by using the _invalid object_ handle (`0xFFFF`) instead of the actual handle.
This reduces latency, as you don't have to wait for the server response to the create operation -- containing the actual handle -- before you can use the object.

In some cases, with `ptype_lazy_send`, the server will defer the response to an operation until a subsequent operation is performed.
For example, the response to statement allocation (`op_allocate`) is withheld, in the expectation that a prepare (`op_prepare`) follows immediately.

Similarly, freeing a statement (`op_free_statement`) will not send its response immediately.
This means that processing the response to a free can only be done later, after sending another operation, and before processing the response to that other operation.

[CAUTION]
====
The _invalid object_ handle refers to the latest object created.
So, while you can batch multiple create operations with use of those objects in a single send, you cannot interleave operations on different objects.

That is, "`__create object1, use object1, create object2, use object2__`" will work, but "`__create object1, create object2, use object1, use object2__`" will not work or result in unwanted effects, as after _create object2_ handle `0xFFFF` refers to _object2_, not _object1_.
====

Protocol 11 also introduced "`trusted`" authentication, which is not (yet) documented.

[#wireprotocol-versions-12]
=== Protocol 12

Protocol 12 was introduced in Firebird 2.5, and provides asynchronous <<wireprotocol-databases-cancel,cancellation>> support.

[[wireprotocol-responses]]
== Responses

The wire protocol has a limited set of responses.
Some operations have a specific response, which is described together with the operation.
Most operation however use one (or more) of the responses described in this section.
The meaning and content depend on the operation that initiated the response.

[[wireprotocol-responses-generic]]
=== Generic response

`Int32` -- `p_operation`::
Operation code

If operation equals `op_response`:

`Int32` -- `p_resp_object`::
Object handle
+
Although 32-bit, valid handle values are always between 0 and 65535 (0xFFFF), with the "`normal`" range between 0 and 65000, where `0` either represents the connection itself, or means "`no value`".

`Int64` -- `p_resp_blob_id`::
Object ID

`Buffer` -- `p_resp_data`::
Data (meaning depends on the operation).

`Byte[]` -- `p_resp_status_vector`::
Status vector
+
The format of the status vector is basically `++<tag><value>[{tag><value>} ...]<end>++`, with `<tag>` an `Int32`, and where parsing of `<value>` depends on `<tag>`;
`<end>` is `Int32` `isc_arg_end` -- `0`.
The length can only be determined by correctly parsing the status vector.
The first 8 bytes are always an `Int32` tag (`isc_arg_gds` or `isc_arg_warning`) and an `Int32` value.
+
--
* If the status vector starts with `Int32` `isc_arg_gds` -- `1` *and* the second `Int32` is non-zero, it is a failure response.
* If it starts with `Int32` `isc_arg_warning` -- `18` *and* the second `Int32` is non-zero, it is a success response with warning(s).
* Otherwise, if the second `Int32` is zero, it is a success response
--
+
[IMPORTANT]
====
Information about parsing the status vector can be found in the _Interbase 6 API Guide_ in the documentation set.
It might also be advantageous to look at the sources of {net-provider-repo} or {jaybird-repo}.
====

[[wireprotocol-responses-sql]]
=== SQL response

Success response to `op_execute2` (see <<wireprotocol-statements-execute>>) or `op_executeimmediate2` (not yet documented).

`Int32` -- `p_operation`::
Operation code

If operation equals `op_sql_response`:

`Int32` -- `p_sqldata_messages`::
Count of rows following response (in practice, only `1` or `0`)

Row data::
The row data is not in a buffer like described in <<wireprotocol-appendix-types>>, but as a sequence (0..1) of data rows with a special format, see <<wireprotocol-reading-row-data>>.
+
You can also consider the row data not a part of the SQL response, but something that is sent *after* the SQL response.

[[wireprotocol-responses-fetch]]
=== Fetch response

Success response to `op_fetch` (see <<wireprotocol-statements-fetch>>) and `op_fetch_scroll` (not yet documented).

`Int32` -- `p_operation`::
Operation code

If operation equals `op_fetch_response`:

`Int32` -- `p_sqldata_status`::
Status
+
--
* `0` -- success
* `100` -- end of cursor
--

`Int32` -- `p_sqldata_messages`::
Count of rows following response (in practice, only `1` or `0`)
+
A value of `0` indicates end-of-batch (fetch complete).
Together with status `100`, it also means end-of-cursor, otherwise there are more rows available for a next fetch.

Row data::
The row data is not in a buffer like described in <<wireprotocol-appendix-types>>, but as a sequence (0..1) of data rows with a special format, see <<wireprotocol-reading-row-data>>.
+
You can also consider the row data not a part of the fetch response, but something that is sent *after* the fetch response.

The success response to <<wireprotocol-statements-fetch>> is not a single of `op_fetch_response`, but a sequence of `op_fetch_response` and row data.
That is:

----
<op-fetch-response (status = 0, count = 1)>
<row-data>
<op-fetch-response (status = 0, count = 1)>
<row-data>
...
if end-of-cursor:
  <op-fetch-response (status = 100, count = 0)>
else:
  <op-fetch-response (status = 0, count = 0)>
----

Firebird may return fewer rows than requested in <<wireprotocol-statements-fetch>>.

[[wireprotocol-responses-slice]]
=== Slice response

// TODO Move to get slice description?

Success response to <<wireprotocol-arrays-getslice>>.

[CAUTION]
====
This documentation might not reflect actual encoding in the protocol.
====

Response to <<wireprotocol-arrays-getslice>>.

`Int32` -- `p_operation`::
Operation code

If operation equals `op_slice`:

`Int32` -- `p_slr_length`::
Slice length

`Int32`::
Slice length (possibly a buffer?, needs verification)

`Buffer`::
Slice data

[[wireprotocol-responses-dummy]]
=== Dummy response

The server may occasionally send a "`dummy`" response.
This is intended as a keep-alive feature, and is related to the `DummyPacketInterval` server setting and/or `isc_dpb_dummy_packet_interval`/`isc_spb_dummy_packet_interval` connection setting.

Though Firebird normally uses `SO_KEEPALIVE` (which is transparent to the client), clients must be able to handle the dummy response.
The appropriate action is to read and ignore this response, and continue with the next response.

`Int32` -- `p_operation`::
Operation code (`op_dummy`)

[[wireprotocol-responses-exit]]
=== Exit or disconnect command (aux connection)

[NOTE]
====
As far as we're aware, this is only sent on the aux connection.
It is similar to the <<wireprotocol-databases-disconnect,disconnect request>> from client to server for the main connection.
====

Instructs the client to close the aux connection.

`Int32` -- `p_operation`::
Operation code (`op_exit` or `op_disconnect`)

After receiving this message, the client should close the aux connection.
It's generally only sent just before the main connection is closed.

[[wireprotocol-databases]]
== Databases

[[wireprotocol-databases-attach]]
=== Attach

Attachments to a database are done in two steps, first identification (connect) to the server, then attach to a database.

[[wireprotocol-databases-attach-identification]]
==== Identification

[CAUTION]
====
The identification and attach handshake changed significantly in protocol 13 (Firebird 3.0), and is not yet documented.
====

Performs the initial handshake and protocol selection.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_connect`)

`Int32` -- `p_cnct_operation`::
Operation code;
unused in practice, can always be `0`.
Some implementations use `op_attach` (`19`) for historic(?) reasons.

`Int32` -- `p_cnct_cversion`::
Connect version:
+
--
[horizontal]
`CONNECT_VERSION2` -- `2`:: user identification encoding is undefined (Firebird 1.0 -- Firebird 2.5)
`CONNECT_VERSION3` -- `3`:: user identification is UTF-8 encoded (since Firebird 3.0 and higher, but backwards compatible as the version wasn't checked before Firebird 3.0)
--

`Int32` -- `p_cnct_client`::
Architecture type (e.g. `arch_generic` = `1`).

`String` -- `p_cnct_file`::
Database path or alias
+
The encoding of this is undefined, which can lead to problems with non-ASCII paths if the server and client use a different encoding.

`Int32` -- `p_cnct_count`::
Count of protocol versions understood (e.g. `1`).

`Buffer` -- `p_cnct_user_id`::
User identification
+
TODO: Needs further description

[IMPORTANT]
====
The next block of data declares the protocol(s) that the client is willing or able to support.
It should be sent as many times as protocols are supported (and specified in `p_cnct_count` above).
Values depend on the protocol.

If a client sends more than 10 (Firebird 5.0 and older) or 11 (Firebird 6.0) protocols, the surplus are ignored.
====

`Int32` -- `p_cnct_version`::
Protocol version (`PROTOCOL_VERSION10`)

`Int32` -- `p_cnct_architecture`::
Architecture type (e.g. `arch_generic` = `1`)
+
It is possible to use a different architecture value, but then connection is only possible with a server of the same architecture.
In addition, it changes how responses and/or data needs to be parsed or encoded (the authors don't know the exact details).
In short, use `arch_generic`.

`Int32` -- `p_cnct_min_type`::
Minimum type (e.g. `ptype_batch_send` = `3`)
+
Possible values:
+
--
[horizontal]
`ptype_page` -- `1`:: Page server protocol (never supported in Firebird)
`ptype_rpc` -- `2` :: Simple remote procedure call (not supported since Firebird 3.0)
`ptype_batch_send` -- `3`:: Batch sends, no asynchrony
`ptype_out_of_band` -- `4`:: Batch sends w/ out of band notification (semantics not documented in this manual)
`ptype_lazy_send` -- `5`:: Deferred packets delivery
--

`Int32` -- `p_cnct_max_type`::
Maximum type (e.g. `ptype_lazy_send` -- `5`)
+
If the client wants to set up wire compression, this `ptype`-code must be OR'ed with `pflag_compress` (`0x100`).
See also discussion below for server response.

`Int32` -- `p_cnct_weight`::
Preference weight (e.g. `2`).
Higher values have higher preference.
For equal weights, the last supported occurrence will be selected.

[float]
===== Server

Success response:

`Int32` -- `p_operation`::
Operation code

If operation equals `op_accept`:

`Int32` -- `p_acpt_version`::
Protocol version number accepted by server

`Int32` -- `p_acpt_architecture`::
Architecture for protocol

`Int32` -- `p_acpt_type`::
Accepted type and additional flags.
Obtain the type by masking with `0xFF`.
+
Known flags:
+
--
[horizontal]
`pflag_compress` -- `0x100`:: Turn on compression
+
In the request from client to server, it signals a request to use wire compression. +
In the response from the server to client, it is an acknowledgement, and wire compression *must* be enabled _after_ processing this response.

`pflag_win_sspi_nego` -- `0x200`:: Win_SSPI supports Negotiate security package
+
Only sent from server to client.
--

Failure response: <<wireprotocol-responses-generic>>

[[wireprotocol-databases-attach-attachment]]
==== Attachment

// TODO Write a common section for attach/create database and attach service and point to it

Attaches to a database.
Attach is the same as <<wireprotocol-databases-create>> (`op_create`), but using `op_attach` instead of `op_create`.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_attach`)

`Int32` -- `p_atch_database`::
Database object id;
unused in practice, can always be `0`.

`String` -- `p_atch_file`::
Database path or alias
+
If `isc_dpb_utf8_filename` is present in the database parameter buffer below, the encoding is UTF-8;
otherwise, the encoding is undefined.
The `isc_dpb_utf8_filename` item is supported since Firebird 2.5.

`Buffer` -- `p_atch_dpb`::
Database parameter buffer
+
[[wireprotocol-databases-attach-attachment-dpb-content]]
.Example of parameters sent in the DPB
[cols="3m,2,1,1", frame="bottom", options="header", stripes="none"]
|===
| Parameter
| Description
| Value
| Optional

|isc_dpb_version1
|Version (must be first item!)
|{nbsp}
|{nbsp}

|isc_dpb_dummy_packet_interval
|Dummy packet interval
|120
|*

|isc_dpb_sql_dialect
|SQL dialect
|3
|{nbsp}

|isc_dpb_lc_ctype
|Character set
|UTF8
|{nbsp}

|isc_dpb_sql_role_name
|User role
|RDB$ADMIN
|*

|isc_dpb_connect_timeout
|Connection timeout
|10
|*

|isc_dpb_user_name
|User name
|SYSDBA
|{nbsp}

|isc_dpb_password
|User password
|masterkey
|{nbsp}
|===

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-databases-detach]]
=== Detach

Detaches from the database.
After detach the connection is still open, to disconnect use <<wireprotocol-databases-disconnect>> (`op_disconnect`).

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_detach`)

`Int32` -- `p_rlse_object`::
Database handle (always `0`)

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-databases-create]]
=== Create

// TODO Write a common section for attach/create database and attach service and point to it

Create a database.
Create is the same as <<wireprotocol-databases-attach-attachment>> (`op_attach`), but using `op_create` instead of `op_attach`.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_create`)

`Int32` -- `p_atch_database`::
Database object id;
unused in practice, can always be `0`.

`String` -- `p_atch_file`::
Database path or alias
+
If `isc_dpb_utf8_filename` is present in the database parameter buffer below, the encoding is UTF-8;
otherwise, the encoding is undefined.
The `isc_dpb_utf8_filename` item is supported since Firebird 2.5.
+
There are a number of DPB items to configure the newly created database, including page size (`isc_dpb_page_size`) -- which cannot be modified after creation.

`Buffer` -- `p_atch_dpb`::
Database parameter buffer

[float]
===== Server

<<wireprotocol-responses-generic>>

[float]
===== The `CREATE DATABASE` statement

Although Firebird has a https://firebirdsql.org/file/documentation/chunk/en/refdocs/fblangref50/fblangref50-ddl.html#fblangref50-ddl-db-create[`CREATE DATABASE`] statement, the documented syntax is not fully supported by Firebird server.
Part of the syntax (e.g. database name, user, password, page size) are parsed by _fbclient_ to execute the `op_create` (or equivalent for embedded).

After the database is successfully created, _fbclient_ then uses execute immediate (`op_execute_immediate`) without transaction to execute a reduced `CREATE DATABASE` statement for additional configuration of the database.

[[wireprotocol-databases-drop]]
=== Drop

Drops the currently attached database.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_drop_database`)

`Int32` -- `p_rlse_object`::
Database handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-databases-information]]
=== Database information request

// TODO Write a common section for info requests and point to it

Requests database or server information.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_info_database`)

`Int32` -- `p_info_object`::
Database handle;
unused in practice, can always be `0`.

`Int32` -- `p_info_incarnation`::
Incarnation of object (`0`)
+
TODO: Usage and meaning?

`Buffer` -- `p_info_items`::
Requested information items
+
Values of enum `db_info_types` in Firebird's `inf_pub.h`.

`Int32` -- `p_info_buffer_length`::
Length of buffer available for receiving response
+
Too small may lead to receiving a truncated buffer, which necessitates requesting information again with a larger size.
+
The buffer in the response is sized to the actual length of the response (upto the declared available length), so specifying a larger than necessary size does not inflate the response on the wire.

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_data` holds the requested information.

A truncated response is considered a success, and can only be determined by parsing `p_resp_data`.

[[wireprotocol-databases-disconnect]]
=== Disconnect

[float]
==== Client

`Int32` -- `p_operation`::
Operation code (`op_disconnect`)

[float]
==== Server

No response, remote socket close.

Closing the connection (socket) without sending an `op_disconnect` will result in "`Connection reset by peer`" (error `10054` (Windows) or `104` (Linux)) in `firebird.log`.

[#wireprotocol-databases-cancel]
=== Cancellation

Protocol 12 and higher.

Cancels a running operation on the server.

[NOTE#wireprotocol-note-cancel-abort]
====
Operation `fb_cancel_abort` -- `4` should not be sent to the server, but instead simply close the socket connection.
====

[float]
==== Client

`Int32` -- `p_operation`::
Operation code (`op_cancel`)

`Int32` -- `p_co_kind`::
Cancellation kind, one of:
+
--
`fb_cancel_disable` -- `1`::
disable cancellation until `fb_cancel_enable` is sent

`fb_cancel_enable` -- `2`::
enable cancellation if it was disabled previously

`fb_cancel_raise` -- `3`::
cancel current operation

`fb_cancel_abort` -- `4`::
See <<wireprotocol-note-cancel-abort,note>> above, this _kind_ should not be sent to the server.
--

As cancellation is generally performed asynchronously to be effective, the client implementation must take special care how the operation is sent.

For example, if you use a lock for socket operations, this operation will need to ignore it (running the risk of interfering/corrupting another send operation), or you need to split your locks in a lock for writing, and a lock for reading, or have some other way of detecting that another thread is not currently sending data.

[float]
==== Server

No formal response, cancellation is signalled as a <<wireprotocol-responses-generic>> with a failure for the cancelled operation.

[[wireprotocol-transactions]]
== Transactions

[[wireprotocol-transactions-start]]
=== Start transaction

Starts a transaction with the transaction options specified in the transaction parameter buffer.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_transaction`)

`Int32` -- `p_sttr_database`::
Database handle;
unused in practice, can always be `0`.

`Buffer` -- `p_sttr_tpb`::
Transaction parameter buffer

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_object` is the new transaction handle.

[float]
===== The `SET TRANSACTION` statement

Instead of using `op_transaction` to start a transaction, it is also possible to use the https://firebirdsql.org/file/documentation/chunk/en/refdocs/fblangref50/fblangref50-transacs.html#fblangref50-transacs-settransac[`SET TRANSACTION`] statement.

This statement needs to be executed with execute immediate (`op_execute_immediate`) without transaction.
On success, the `p_resp_object` holds the transaction handle.

[#wireprotocol-transactions-start-v11]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, other transaction operations can be sent immediately after starting the transaction.
They can use the _invalid object_ handle (`0xFFFF`) instead of the -- not yet received -- transaction handle.
This probably only makes sense for <<wireprotocol-transactions-info>>.

[[wireprotocol-transactions-commit]]
=== Commit transaction

Commits an active or prepared transaction.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_commit`)

`Int32` -- `p_rlse_object`::
Transaction handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-transactions-rollback]]
=== Rollback transaction

Rolls back an active or prepared transaction.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_rollback`)

`Int32` -- `p_rlse_object`::
Transaction handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-transactions-commitretain]]
=== Commit retaining

Commits an active or prepared transaction, retaining the transaction context.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_commit_retaining`)

`Int32` -- `p_rlse_object`::
Transaction handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-transactions-rollbackretain]]
=== Rollback retaining

Rolls back an active or prepared transaction, retaining the transaction context.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_rollback_retaining`)

`Int32` -- `p_rlse_object`::
Transaction handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-transactions-prepare]]
=== Prepare

Performs the first stage of a two-phase commit.
After prepare, a transaction is _in-limbo_ until committed or rolled back.

[[wireprotocol-transactions-prepare-simple]]
==== Simple prepare

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_prepare`)

`Int32` -- `p_rlse_object`::
Transaction handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-transactions-prepare-message]]
==== Prepare with message

Associates a message (byte data) with the prepared transaction.
This information is stored in `RDB$TRANSACTIONS` and can be used for recovery purposes.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_prepare2`)

`Int32` -- `p_prep_transaction`::
Transaction handle

`Buffer` -- `p_prep_data`::
Recovery information

[float]
===== Server

<<wireprotocol-responses-generic>>

[#wireprotocol-transactions-reconnect]
=== Reconnect transaction

Reconnects a prepared ("`in-limbo`") transaction for 2-phase commit or rollback.

This operation can be used for recovery operations if a connection was closed or killed after preparing a transaction, but not yet committing or rolling it back.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_reconnect`)

`Int32` -- `p_sttr_database`::
Database handle;
unused in practice, can always be `0`.

`Buffer` -- `p_sttr_tpb`::
Transaction id to reconnect, encoded in little-endian.
+
For Firebird 2.5 and lower, always 4 bytes (`Int32` little-endian).
+
For Firebird 3.0 and higher, transaction ids greater than 0x7FFF_FFFF (2^31^ - 1) must be encoded in 8 bytes (`Int64` little-endian), while smaller ids may be encoded in 4 bytes (`Int32` little-endian).
+
This encoding is atypical, as it's essentially a transaction parameter buffer without version or item tags.

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_object` holds the transaction handle.

[#wireprotocol-transactions-reconnect-v11]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, other transaction operations can be sent immediately after reconnecting the transaction.
They can use the _invalid object_ handle (`0xFFFF`) instead of the -- not yet received -- transaction handle.

[[wireprotocol-transactions-info]]
=== Transaction information request

// TODO Write a common section for info requests and point to it

This is similar to <<wireprotocol-databases-information>>.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_info_transaction`)

`Int32` -- `p_info_object`::
Transaction handle

`Int32` -- `p_info_incarnation`::
Incarnation of object (`0`)
+
TODO: Usage and meaning?

`Buffer` -- `p_info_items`::
Requested information items
+
Values of constants in Firebird's `inf_pub.h` starting with `isc_info_tra_` or `fbinfo_tra_`.

`Int32` -- `p_info_buffer_length`::
Length of buffer available for receiving response
+
Too small may lead to receiving a truncated buffer, which necessitates requesting information again with a larger size.
+
The buffer in the response is sized to the actual length of the response (upto the declared available length), so specifying a larger than necessary size does not inflate the response on the wire.

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_data` holds the requested information.

A truncated response is considered a success, and can only be determined by parsing `p_resp_data`.

[[wireprotocol-statements]]
== Statements

[[wireprotocol-statements-allocate]]
=== Allocate

Allocates a statement handle on the server.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_allocate_statement`)

`Int32` -- `p_rlse_object`::
Database handle

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_object` is the allocated statement handle.

[[wireprotocol-statements-allocate-v11]]
==== Deviations for protocol version 11

In protocol 11 and higher with `ptype_lazy_send`, the response to `op_allocate_statement` is deferred;
it requires another operation on the connection before the response is sent.

In general, this means the _allocate_ operation should be sent together with a <<wireprotocol-statements-prepare,_prepare_>> operation using the _invalid object_ handle (`0xFFFF`).

[[wireprotocol-statements-free]]
=== Free

Frees resources held by the statement.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_free_statement`)

`Int32` -- `p_sqlfree_statement`::
Statement handle

`Int32` -- `p_sqlfree_option`:: {empty}
+
[%autowidth,cols="1m,1", options="header", frame="none", grid="none", stripes="none", role="segmentedlist"]
|===
|Option
|Description

|DSQL_close -- `1`
|Closes the cursor opened after statement execute.

|DSQL_drop -- `2`
|Releases the statement handle.

|DSQL_unprepare -- `4`
a|_Firebird 2.5 or higher_ +
Close resources associated with statement handle, and unprepares the currently allocated statement text.
The statement handle itself is retained.
+
It is not necessary to unprepare before preparing a new statement on the same handle.
|===

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-statements-free-v11]]
==== Deviations for protocol version 11

Request flushing can be deferred for `ptype_batch_send` or higher.
For `ptype_lazy_send`, the response to `op_free_statement` is deferred;
it requires another operation on the connection before the response is sent.

For `DSQL_drop` and `DSQL_unprepare`, we recommend flushing immediately so the server at least processes the request, which will prevent longer than necessary retention of metadata locks.

[[wireprotocol-statements-prepare]]
=== Prepare

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_prepare_statement`)

`Int32` -- `p_sqlst_transaction`::
Transaction handle

`Int32` -- `p_sqlst_statement`::
Statement handle

`Int32` -- `p_sqlst_SQL_dialect`::
SQL dialect (`1` or `3`)
+
This should generally match the connection dialect.

`String` -- `p_sqlst_SQL_str`::
Statement to be prepared

`Buffer` -- `p_sqlst_items`::
Describe and describe bind information items
+
--
.Example of requested information items
* `isc_info_sql_select`
* `isc_info_sql_describe_vars`
* `isc_info_sql_sqlda_seq`
* `isc_info_sql_type`
* `isc_info_sql_sub_type`
* `isc_info_sql_length`
* `isc_info_sql_scale`
* `isc_info_sql_field`
* `isc_info_sql_relation`
--

`Int32` -- `p_sqlst_buffer_length`::
Target buffer length (`32768`)

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_data` holds the statement description (matching the requested information items)

For statements with a lot of columns and/or parameters, it may be necessary to handle truncation of the buffer by repeating the describe and/or describe bind information request using <<wireprotocol-statements-information>> and using `isc_info_sql_sqlda_start` to inform the server from which column or parameter to continue.

For an example, see Jaybird's https://github.com/FirebirdSQL/jaybird/blob/c152a12d8dec10a3f7bf4013b4b39ad5dfed85b6/src/main/org/firebirdsql/gds/ng/StatementInfoProcessor.java#L71[`StatementInfoProcessor.handleTruncatedInfo(...)`].

[[wireprotocol-statements-prepare-v11]]
==== Deviations for protocol version 11

The statement handle can no longer be allocated separately.
The initial <<wireprotocol-statements-allocate>> operation *must* be sent together with the first prepare operation.
When allocating and preparing together, the value of the statement handle of the _prepare_ must be `0xFFFF` (invalid object handle).
The responses must be processed in order: first _allocate_ response, then _prepare_ response.

Once a statement handle has been allocated, it can be reused by sending a _prepare_ with the obtained statement handle.

[[wireprotocol-statements-describe]]
=== Describe

Requesting a description of output parameters (columns) of a query is done using the <<wireprotocol-statements-information,statement information request message>>

.Example of requested information items
* `isc_info_sql_select`
* `isc_info_sql_describe_vars`
* `isc_info_sql_sqlda_seq`
* `isc_info_sql_type`
* `isc_info_sql_sub_type`
* `isc_info_sql_length`
* `isc_info_sql_scale`
* `isc_info_sql_field`
* `isc_info_sql_relation`

The initial request can be done as part of <<wireprotocol-statements-prepare>>.
The information can be requested together with <<wireprotocol-statements-describe-bind>>.

[[wireprotocol-statements-describe-bind]]
=== Describe bind (input parameters)

Describe of input parameters of a query is done using the <<wireprotocol-statements-information,statement information request message>>

.Example of requested information items
* `isc_info_sql_select`
* `isc_info_sql_describe_vars`
* `isc_info_sql_sqlda_seq`
* `isc_info_sql_type`
* `isc_info_sql_sub_type`
* `isc_info_sql_length`
* `isc_info_sql_scale`
* `isc_info_sql_field`
* `isc_info_sql_relation`

The initial request can be done as part of <<wireprotocol-statements-prepare>>.
The information can be requested together with <<wireprotocol-statements-describe>>.

[[wireprotocol-statements-execute]]
=== Execute

[float]
===== Client

`Int32` -- `p_operation`::
Operation code
+
[%autowidth,cols="1m,1", options="header", frame="none", grid="none", stripes="none", role="segmentedlist"]
|===
|Operation
|Usage

|op_execute
|DDL and DML statements

|op_execute2
|Executable stored procedures, or singleton `RETURNING` (i.e. statements described as `isc_info_sql_stmt_exec_procedure`)
|===

`Int32` -- `p_sqldata_statement`::
Statement handle

`Int32` -- `p_sqldata_transaction`::
Transaction handle

`Buffer` -- `p_sqldata_blr`::
Parameters in BLR format
+
If there are no parameters, send a zero-length buffer.

`Int32` -- `p_sqldata_message_number`::
Message number;
unused, always use `0`

`Int32` -- `p_sqldata_messages`::
Number of messages -- `1` if there are parameters, `0` if there are no parameters

`Buffer` -- _no name_::
Parameter values
+
If `p_sqldata_messages` is `0`, this buffer must not be sent (not even as a zero-length buffer)
+
TODO: Might not even be a buffer, verify.

If using `op_execute2` (the statement is a stored procedure and there are output parameters):

`Buffer` -- `p_sqldata_out_blr`::
Output parameters in BLR format

`Int32` -- `p_sqldata_out_message_number`::
Output message number (0) ??

[float]
====== Additions in protocol 16 and higher

`UInt32` -- `p_sqldata_timeout`::
Statement timeout value in milliseconds (`0` -- use connection-level statement timeout)

[float]
====== Additions in protocol 18 and higher

`UInt32` -- `p_sqldata_cursor_flags`::
Cursor flags
+
--
[horizontal]
`CURSOR_TYPE_SCROLLABLE` -- `0x01`:: request scrollable cursor
--

[float]
====== Additions in protocol 19 and higher

`UInt32`-- `p_sqldata_inline_blob_size`::
Maximum inline blob size
+
A value of `0` disables inline blobs.
The server may use a lower limit than requested.
In the Firebird 5.0.3 and Firebird 6 implementation at the time of writing, the server has a maximum of 65535 bytes.
+
TODO: Describe `op_inline_blob` somewhere

[float]
===== Server

For `op_execute`:

<<wireprotocol-responses-generic>>

For `op_execute2`:

Success response: <<wireprotocol-responses-sql>> followed by <<wireprotocol-responses-generic>>

Failure response: only <<wireprotocol-responses-generic>>

[[wireprotocol-statements-rowsaffected]]
=== Rows affected by query execution

Obtaining the rows affected by a query is done using the <<wireprotocol-statements-information,statement information request message>>

.List of requested information items
* `isc_info_sql_records`

[[wireprotocol-statements-fetch]]
=== Fetch

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_fetch`)

`Int32` -- `p_sqldata_statement`::
Statement handle

`Buffer` -- `p_sqldata_blr`::
Output parameters in BLR format
+
Only needs to be sent on first fetch;
subsequent fetches can send a zero-length buffer.

`Int32` -- `p_sqldata_message_number`::
Message number (always `0`)

`Int32` -- `p_sqldata_messages`::
Message count/fetch size (e.g. `200`)
+
The server may decide to return fewer rows than requested, even if the end-of-cursor wasn't reached yet.

[float]
===== Server

Success response: one or more <<wireprotocol-responses-fetch>>

Failure response: <<wireprotocol-responses-generic>> -- with an error in `p_resp_status_vector`

It is possible to receive <<wireprotocol-responses-generic>> with an error in the status vector after one or more fetch responses.

[[wireprotocol-statements-cursorname]]
=== Set cursor name

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_set_cursor`)

`Int32` -- `p_sqlcur_statement`::
Statement handle

`String` -- `p_sqlcur_cursor_name`::
Cursor name (null terminated!)

`Int32` -- `p_sqlcur_type`::
Cursor type
+
Reserved for future use, always use `0`.

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-statements-information]]
=== Information request

// TODO Write a common section for info requests and point to it

This is similar to <<wireprotocol-databases-information>>.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_info_sql`)

`Int32` -- `p_info_object`::
Statement handle

`Int32` -- `p_info_incarnation`::
Incarnation of object (`0`)
+
TODO: Usage and meaning?

`Buffer` -- `p_info_items`::
Requested information items
+
Values of constants in Firebird's `inf_pub.h` starting with `isc_info_sql_`.

`Int32` -- `p_info_buffer_length`::
Length of buffer available for receiving response
+
Too small may lead to receiving a truncated buffer, which necessitates requesting information again with a larger size.
+
The buffer in the response is sized to the actual length of the response (upto the declared available length), so specifying a larger than necessary size does not inflate the response on the wire.

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_data` holds the requested information.

A truncated response is considered a success, and can only be determined by parsing `p_resp_data`.

[IMPORTANT]
====
Information about how to parse the information buffer sent by the Firebird server can be found in the InterBase 6.0 documentation set
====

[[wireprotocol-blobs]]
== Blobs

[[wireprotocol-blobs-create]]
=== Create/Open

[float]
===== Client

`Int32` -- `p_operation`::
Operation code
+
[%autowidth,cols="1m,1", options="header", frame="none", grid="none", stripes="none", role="segmentedlist"]
|===
|Operation
|Description

|op_create_blob
|Creates a new blob

|op_create_blob2
|Creates a new blob with a blob parameter buffer

|op_open_blob
|Opens an existing blob

|op_open_blob2
|Opens an existing blob with a blob parameter buffer
|===

`Buffer` -- `p_blob_bpb`::
Blob parameter buffer
+
Only sent for `op_create_blob2` and `op_open_blob2`

`Int32` -- `p_blob_transaction`::
Transaction handle

`Int64` -- `p_blob_id`::
Blob ID

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success
+
[loweralpha]
. `p_resp_object` is the blob handle
. `p_resp_blob_id` is the blob id (for `op_create_blob` / `op_create_blob2` only)

[[wireprotocol-blobs-create-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, other blob operations can be sent immediately after the open/create.
They can use the _invalid object_ handle (`0xFFFF`) instead of the -- not yet received -- blob handle.

[[wireprotocol-blobs-getsegment]]
=== Get segment

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_get_segment`)

`Int32` -- `p_sgmt_blob`::
Blob handle

`Int32` -- `p_sgmt_length`::
Segment length
+
Maximum length is 32767 for Firebird 2.5 and older, 65535 for Firebird 3.0 and higher.

`Buffer` -- `p_sgmt_segment`::
Always a zero-length buffer

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success,  `p_resp_data` is the blob segment

The response buffer in `p_resp_data` contains zero or more segments.
Each segment starts with 2-bytes for the length (little-endian), followed by that length of data.

[[wireprotocol-blobs-getsegment-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, `op_get_segment` can be batched with <<wireprotocol-blobs-create>> (and other blob operations) by using the _invalid object_ handle (`0xFFFF`).

[[wireprotocol-blobs-putsegment]]
=== Put segment

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_put_segment`)

`Int32` -- `p_sgmt_blob`::
Blob handle

`Int32` -- `p_sgmt_length`::
Length of segment data (effectively ignored; possibly only in recent Firebird versions)

`Buffer` -- `p_sgmt_segment`::
Blob segment
+
If the blob was created as a segmented blob, the maximum length is 32765 (Firebird 2.5 and older) or 65533 (Firebird 3.0 and higher).
+
For stream blobs, there is no length limitation other than the maximum buffer length (TODO: verify, might only be for recent versions).

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-blobs-putsegment-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, `op_put_segment` can be batched with <<wireprotocol-blobs-create>> (and other blob operations) by using the _invalid object_ handle (`0xFFFF`).

[[wireprotocol-blobs-batchsegment]]
=== Batch segments

Similar to <<wireprotocol-blobs-putsegment>>, but allows to send multiple segments.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_segments`)

`Int32` -- `p_sgmt_blob`::
Blob handle

`Int32` -- `p_sgmt_length`::
Length of segment data (effectively ignored; possibly only in recent Firebird versions)

`Buffer` -- `p_sgmt_segment`::
Blob segments
+
The buffer can contain one or more segments, which are prefixed with 2 bytes of length (little-endian), followed by the data.
The maximum length per segment is 32765 (Firebird 2.5 and older) or 65533 (Firebird 3.0 and higher).

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-blobs-batchsegment-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, `op_batch_segment` can be batched with <<wireprotocol-blobs-create>> (and other blob operations) by using the _invalid object_ handle (`0xFFFF`).

[[wireprotocol-blobs-seek]]
=== Seek

Seek is only supported for blobs that were created as a stream blob.
Seek is not fully supported for blobs longer than 2 GiB (4 GiB?).

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_seek_blob`)

`Int32` -- `p_seek_blob`::
Blob handle

`Int32` -- `p_seek_mode`::
Seek mode
+
--
[horizontal]
`blb_seek_from_head` -- `0`:: absolute seek from start of blob
`blb_seek_relative` -- `1`:: relative seek from current position
`blb_seek_from_tail` -- `2`:: absolute seek from end of blob
--

`Int32` -- `p_seek_offset`::
Offset

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_object` is the current position.

[[wireprotocol-blobs-seek-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, `op_seek_blob` can be batched with <<wireprotocol-blobs-create>> (and other blob operations) by using the _invalid object_ handle (`0xFFFF`).

[[wireprotocol-blobs-cancel]]
=== Cancel

Cancels and invalidates the blob handle.
If this was a newly created blob, the blob is disposed.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_cancel_blob`)

`Int32` -- `p_rlse_object`::
Blob handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-blobs-cancel-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, `op_cancel_blob` can be batched with <<wireprotocol-blobs-create>> (and other blob operations) by using the _invalid object_ handle (`0xFFFF`).
Though doing this probably makes little sense for `op_cancel_blob`.

[[wireprotocol-blobs-close]]
=== Close

Closes and invalidates the blob handle.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_close_blob`)

`Int32` -- `p_rlse_object`::
Blob handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-blobs-close-v11]]
==== Deviations for protocol version 11

Request flushing and response processing can be deferred.

If `ptype_batch_send` or higher is used, `op_close_blob` can be batched with <<wireprotocol-blobs-create>> (and other blob operations) by using the _invalid object_ handle (`0xFFFF`).

[[wireprotocol-arrays]]
== Arrays

[[wireprotocol-arrays-getslice]]
=== Get slice

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_get_slice`)

`Int32` -- `p_slc_transaction`::
Transaction handle

`Int64` -- `p_slc_id`::
Array handle

`Int32` -- `p_slc_length`::
Slice length

`Buffer` -- `p_slc_sdl`::
Slice descriptor (SDL)

`Buffer` -- `p_slc_parameters`::
Slice parameters (always empty?, needs verification)

`Buffer` -- `p_slc_slice`::
Slice data (always empty)

[float]
===== Server

Success response: <<wireprotocol-responses-slice>>

Failure response: <<wireprotocol-responses-generic>>

[[wireprotocol-arrays-putslice]]
=== Put slice

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_put_slice`)

`Int32` -- `p_slc_transaction`::
transaction handle

`Int64` -- `p_slc_id`::
Array handle

`Int32` -- `p_slc_length`::
Slice length

`Buffer` -- `p_slc_sdl`::
Slice descriptor (SDL)

`Buffer` -- `p_slc_parameters`::
Slice parameters (always empty?, needs verification)

`Buffer`` -- `p_slc_slice`::
Slice data

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_blob_id` is the array handle.

[[wireprotocol-batches]]
== Batches

Statement batches were introduced in protocol 16 (Firebird 4.0).

[[wireprotocol-batches-create]]
=== Create

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_create`)

`Int32` -- `p_batch_statement`::
Statement handle

`Buffer` -- `p_batch_blr`::
BLR format of batch messages

`UInt32` -- `p_batch_msglen`::
Message length

`Buffer` -- `p_batch_pb`::
Batch parameters buffer

If `ptype_lazy` or higher, flushing and response processing can be deferred.

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-msg]]
=== Send messages

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_msg`)

`Int32` -- `p_batch_statement`::
Statement handle

`UInt32` -- `p_batch_messages`::
Number of messages

`Buffer` -- `p_batch_data`::
Batched values (formatted message repeats 'Number of messages' times)

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-execute]]
=== Execute batch

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_exec`)

`Int32` -- `p_batch_statement`::
Statement handle

`Int32` -- `p_batch_transaction`::
Transaction handle

[float]
===== Server

Success response:

`Int32` -- `p_operation`::
Operation code

If operation equals `op_batch_cs`:

*Batch completion state*

`Int32` -- `p_batch_statement`::
Statement handle

`UInt32` -- `p_batch_reccount`::
Total records count

`UInt32` -- `p_batch_updates`::
Number of update counters (records updated per each message)

`UInt32` -- `p_batch_vectors`::
Number of per-message error blocks (message number in batch and status vector of an error processing it)

`UInt32` -- `p_batch_errors`::
Number of simplified per-message error blocks (message number in batch without status vector)

`Byte[]`::
Update counters (records updated per each message), array of `Int32`, length is equal to `p_batch_updates`
+
Length is `p_batch_updates * 4` bytes long.

`Byte[]`::
Detailed info about errors in batch (for each error server sends number of message (`Int32`) and status vector in standard way (exactly like in op_response).
Number of such pairs is equal to `p_batch_vectors`.
+
Length can only be determined by correctly parsing the `<Int32><statusvector>` pairs.

`Byte[]`::
Simplified error blocks (for each error server sends number of message (`Int32`) w/o status vector).
Used when too many errors took place.
Number of elements is equal to `p_batch_errors`.
+
Length is `p_batch_errors * 4` bytes.

Failure response: <<wireprotocol-responses-generic>>

[[wireprotocol-batches-release]]
=== Release batch

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_rls`)

`Int32` -- `p_batch_statement`::
Statement handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-cancel]]
=== Cancel batch

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_cancel`)

`Int32` -- `p_batch_statement`::
Statement handle

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-sync]]
=== Sync batch

Introduced in protocol 17 (Firebird 4.0.2).

Used to force the server to acknowledge previously sent lazy intermediate operations (e.g. `op_batch_msg`, `op_batch_regblob`, `op_batch_blob_stream` and possibly others).

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_sync`)

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-bpb]]
=== Set default blob parameters

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_set_bpb`)

`Int32` -- `p_batch_statement`::
Statement handle

`Buffer` -- `p_batch_blob_bpb`::
Default BLOB parameter buffer

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-regblob]]
=== Register existing blob

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_regblob`)

`Int32` -- `p_batch_statement`::
Statement handle

`Int64` -- `p_batch_exist_id`::
Existing BLOB ID

`Int64` -- `p_batch_blob_id`::
Batch temporary BLOB ID

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-batches-blobstream]]
=== Stream of BLOB data

[CAUTION]
====
This description needs further verification and possibly correction.
For example, it seems to mix up Buffer and Byte[].
We're also not able to match some fields to the implementation.
For example, the repeated "Record length" seems to be absent, or may actually refer to the `p_batch_blob_data` buffer length.
====

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_batch_blob_stream`)

`Int32` -- `p_batch_statement`::
Statement handle

`Buffer[]` -- `p_batch_blob_data`::
BLOB stream
+
This stream is a sequence of blob records.
Each blob records contains:
+
--
`UInt32`::
Record length
+
The following three fields are called *BLOB header*

`Int64`::
Batch temporary BLOB ID

`UInt32`::
BLOB size

`UInt32`::
BLOB parameters buffer size

`Buffer`::
BLOB parameters buffer

`Buffer`::
BLOB data (length - BLOB size bytes) (_what does this mean?_)
+
BLOB headers and records in a stream need not match, i.e. one record may contain many BLOBs and BLOB may stretch from one record to next.
--

[float]
===== Server

<<wireprotocol-responses-generic>>

// TODO Document op_info_batch (v17)

[[wireprotocol-services]]
== Services

[[wireprotocol-services-attach]]
=== Attach

// TODO Write a common section for attach/create database and attach service and point to it

This is essentially the same as <<wireprotocol-databases-attach-attachment,database attach>>, but with `op_service_attach`.

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_service_attach`)

`Int32` -- `p_atch_database`::
Database object id;
currently always `0`

`String` -- `p_atch_file`::
Service name
+
Current Firebird versions only support one service: `service_mgr`.
Since Firebird 3.0, this can also be an empty string (empty buffer) with the same meaning.
+
The encoding is unspecified, but given the only valid name is either ASCII or empty, use of ASCII or an ASCII-compatible encoding (e.g. UTF-8 or extended ANSI code pages) should always work.

`Buffer` -- `p_atch_dpb`::
Service parameter buffer
+
Similar to the database parameter buffer of database attach/create, but using `isc_spb_` tags instead of `isc_dpb_`.

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-services-detach]]
=== Detach

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_service_detach`)

`Int32` -- `p_rlse_object`::
Services manager attachment handle (always `0`)

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-services-start]]
=== Start

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_service_start`)

`Int32` -- `p_info_object`::
Services manager attachment handle (always `0`)

`Int32` -- `p_info_incarnation`::
Incarnation of object (`0`)
+
TODO: Usage and meaning?

`Buffer` -- `p_info_items`::
Service parameter buffer

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-services-query]]
=== Query service

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_service_info`)

`Int32` -- `p_info_object`::
Services manager attachment handle

`Int32` -- `p_info_incarnation`::
Incarnation of object (`0`)
+
TODO: Usage and meaning?

`Buffer` -- `p_info_items`::
Service parameter buffer

`Buffer` -- `p_info_recv_items`::
Requested information items

`Int32` -- `p_info_buffer_length`::
Requested information items buffer length

[float]
===== Server

<<wireprotocol-responses-generic>> -- on success, `p_resp_data` contains the requested information.

[[wireprotocol-events]]
== Events

[[wireprotocol-events-connect-request]]
=== Connection request

[float]
===== Client

`Int32` -- `p_operation`::
Operation code (`op_connect_request`)

`Int32` -- `p_req_type`::
Unused, but always use `P_REQ_async` (`1`) for backwards compatibility

`Int32` -- `p_req_object`::
Unused, always use `0`

`Int32` -- `p_req_partner`::
Unused, always use `0`

[float]
===== Server

<<wireprotocol-responses-generic>> -- with on success:

`p_resp_data`::
Aux connection information
+
[IMPORTANT]
====
This is part of the `sockaddr_in` structure.

It is not in XDR format
====
+
--
`Int16`::
Socket family (can be ignored)
`Int16`::
Aux connection port
Remaining bytes::
To be ignored: always use the hostname or IP address of the original connection.
--

After a successful response, the client needs to create a connection to the specified port (the "`aux connection`" or auxiliary connection).
The server uses this aux connection for asynchronous notification of events.

[[wireprotocol-events-que-events]]
=== Queue events

Each queued event is notified at most once.
After notification, the event needs to be requeued if the client is still interested.

If a queued event was not notified, but the client is no longer interested, it can be <<wireprotocol-events-cancel-events,cancelled>>.

Notification of the queued events happens on the aux connection.
See <<wireprotocol-events-notification>> for further details.

[float]
===== Client

Must be sent on the main (database) connection.

`Int32` -- `p_operation`::
Operation code (`op_que_events`)

`Int32` -- `p_event_database`::
Database handle

`Buffer` -- `p_event_items`::
Event parameter buffer
+
--
`Byte`::
Version (`EPB_version1` -- `1`)
+
The following fields are dependent on the version tag.

`Byte`::
Length of event name

`Byte[]`::
Event name

`Int32` (little-endian)::
Current known event count (`0` when first queueing, for requeueing use the count of the previous notification)
--

`Int32` -- `p_event_ast`::
Unused, always set `0`

`Int32` -- `p_event_arg`::
Unused, always set `0`

`Int32` -- `p_event_rid`::
Local event id -- generated by the client

[float]
===== Server

<<wireprotocol-responses-generic>>

[[wireprotocol-events-cancel-events]]
=== Cancel events

[float]
===== Client

Must be sent on the main (database) connection.

`Int32` -- `p_operation`::
Operation code (`op_cancel_events`)

`Int32` -- `p_event_database`::
Database handle (always `0`)

`Int32` -- `p_event_rid`::
Local event id -- same id as used to <<wireprotocol-events-que-events,queue>> the event

[float]
===== Server

<<wireprotocol-responses-generic>>

[#wireprotocol-events-notification]
=== Event notification

Event notification happens on the aux connection.

`Int32` -- `p_operation`::
Operation code (`op_event`)

`Int32` -- `p_event_database`::
Database handle (always `0`)

`Buffer` -- `p_event_items`::
Event data
+
--
`Byte`::
Version tag (`EPB_version1` -- `1`)
+
The following fields are dependent on the version tag.

`Byte`::
Length of event name

`Byte[]`::
Name of the event

`Int32` (little-endian)::
Event count
--

`Int32` -- `p_event_ast`::
Unused

`Int32` -- `p_event_arg`::
Unused

`Int32` -- `p_event_rid`::
Local event id -- same id as used to <<wireprotocol-events-que-events,queue>> the event

[[wireprotocol-reading-row-data]]
== Reading row data

TODO: Processing row data

:sectnums!:

[appendix]
[[wireprotocol-appendix-xdr]]
== External Data Representation (XDR)

The Firebird wire protocol uses XDR for exchange of messages between client and server.
The encoding of integers is big-endian (network order).

However, some data *inside* the messages may be little-endian (also known as VAX encoding within Firebird sources).

[appendix]
[[wireprotocol-appendix-types]]
== Data types

`Int32`::
Integer 32-bits
+
In some cases -- e.g. object handles, and _some_ lengths -- this is actually a 16-bit short encoded as a 32-bit int with the high bits zero.

`UInt32`::
Unsigned integer 32-bits

`Int64`::
Integer 64-bits
+
Alternatively, especially for blob and arrays ids, can be interpreted as two `Int32`, a.k.a. a "`quad`".
Interpretation as a 64-bit integer -- even for blob and array ids -- is generally simpler, and should not make a difference.

`Buffer`::
Composed of
+
--
`Int32`::
Length of buffer data *without* padding

`Byte[]`::
Buffer data

`Byte[]`::
Padding of 0 to 3 bytes to align the message to a multiple of 4 (e.g. calculated as `(4 - length) & 3)`).
+
That is, for some `N >= 0`, when the buffer length is:
+
* `N * 4` bytes -> no padding
* `N * 4 + 1` bytes -> 3 bytes padding
* `N * 4 + 2` bytes -> 2 bytes padding
* `N * 4 + 3` bytes -> 1 byte padding
--

`Byte[]`::
An array of bytes
+
Length follows from another field in the message, from correct parsing of the value, or from other specifics of the message.

`String`::
A text string, read or written as a Buffer, encoded in the connection character set or some message or context specific character set

[appendix]
[[wireprotocol-appendix-revhistory]]
== Revision history

[%autowidth, width="100%", cols="4", options="header", frame="none", grid="none", role="revhistory"]
|===
4+|Revision History

|0.17
|TBD
|MR
a|* Reordered revision history, so latest change is at the top
* Documented `op_dummy`
* Documented `op_event`
* Documented `op_exit`/`op_disconnect` on aux connection
* Documented `op_reconnect`
* Improved protocol 11 descriptions
* Documented protocol 12 (`op_cancel`)

|0.16
|13 Apr 2025
|MR
a|* Added Firebird struct field names to message descriptions for reference
* Updated, corrected and expanded field descriptions
* Documented `op_put_segment`
* Added missing field in `p_sgmt_length` in `op_batch_segments`
* Documented protocol 11 batching of operations for blobs
* Documented protocol 16 timeout (`p_sqldata_timeout`) for `op_execute`/`op_execute2`
* Documented protocol 18 cursor flags (`p_sqldata_cursor_flags`) for `op_execute`/`op_execute2`
* Documented protocol 19 inline blob size (`p_sqldata_inline_blob_size`) for `op_execute`/`op_execute2` (but not yet `op_inline_blob`!)

|0.15
|26 Dec 2021
|AP
|Document batch execution

|0.14
|04 Aug 2020
|MR
|Conversion to AsciiDoc, minor copy-editing

|0.13
|13 Sep 2014
|{nbsp}
|Updated and expanded protocol information

|0.12
|21 Jun 2004
|{nbsp}
|Updated services information.

|0.11
|20 Jun 2004
|{nbsp}
a|* Added new segmentedlist.
* Updated Statements.Prepare documentation.
* Updated Statements.Execute documentation.
* Updated Blobs.GetSegment documentation.
* Updated Blobs.Seek documentation.

|0.10
|19 Jun 2004
|{nbsp}
|Changed rendering of important tags using Paul Vinkenoog fix.

|0.9
|18 Jun 2004
|{nbsp}
a|
* Improved segmentedlist usage.
* Fixed rendering of important tags.

|0.8
|17 Jun 2004
|{nbsp}
|Added two new segmented lists.

|0.7
|16 Jun 2004
|{nbsp}
|Modified document ID to wireprotocol.

|0.6
|07 Jun 2004
|{nbsp}
|Added events system documentation.

|0.5
|06 Jun 2004
|{nbsp}
|Fixed issues reported by Paul Vinkenoog.

|0.4
|05 Jun 2004
|{nbsp}
|Fixed issues reported by Paul Vinkenoog.

|0.3
|03 Jun 2004
|{nbsp}
|Added new subsections to the Statements section.

|0.2
|02 Jun 2004
|{nbsp}
|Fixed issues reported by Paul Vinkenoog.

|0.1
|31 May 2004
|{nbsp}
|First draft for review.

|===
