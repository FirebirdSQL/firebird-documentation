[[fbdevgd30-firedac]]
= Developing Firebird Applications in Delphi

This chapter will describe the process of developing applications for  Firebird databases with the FireDac(TM) data access components in the Embarcadero  Delphi(TM) XE5 environment.
FireDac(TM) is a standard set of components for  accessing various databases in Delphi XE3 and higher versions. 

[[fbdg30-firedac-proj-start]]
== Starting a Project

Create a new project using menu:File[New > VCL Forms Application > Delphi].

Add a new data module using menu:File[New > Other] and selecting menu:Delphi{sp}Projects[Delphi Files > Data Module] in the wizard.
This will be the main data module in our project.
It will contain some instances of global access components that must be accessible to all forms that are intended to work with data.
`TFDConnection` is an example of this kind of component.

[[fbdg30-firedac-tfdconnection]]
== TFDConnection Component

The `TFDConnection` component provides connectivity to various types of databases.
We will specify an instance of this component in the `Connection` properties of other FireDac components.
The particular type of the database to which the connection will be established depends on the value of the `DriverName` property.
To access Firebird, you need to set this property to `FB`.

For the connection to know exactly which access library it should work with, place the `TFBPhysFBDriverLink` component in the main data module.
Its `VendorLib` property enables the path to the client library to be specified precisely.
If it is not specified, the component will attempt to establish a connection via libraries registered in the system, for example, in `system32`, which might not be what you want at all.

[[fbdg30-firedac-libpath]]
== Path to the Client Library

We will place the necessary library in the `fbclient` folder located in the application folder and use the following code for the OnCreate event of the data module:

[source]
----
xAppPath := ExtractFileDir(Application.ExeName) + PathDelim;
FDPhysFBDriverLink.VendorLib := xAppPath + 'fbclient' + PathDelim + 'fbclient.dll';
----

.Important notes about "`bitness`"
[IMPORTANT]
====
If you compile a 32-bit application, you should use the 32-bit `fbclient.dll` library.
For a 64-bit application, it should be the 64-bit library.

Along with the file `fbclient.dll`, it is advisable to place the following libraries in the same folder: `msvcp80.dll` and `msvcr80.dll` (for Firebird 2.5) as well as `msvcp100.dll` and `msvcr100.dll` (for Firebird 3.0).
These libraries are located either in the `bin` subfolder (Firebird 2.5) or in the root folder of the server (Firebird 3.0).

For the application to show internal firebird errors correctly, it is necessary to copy the file `firebird.msg` as well. 

* For Firebird 2.5 or earlier, the libraries must be one level up from the folder with the client library, i.e., in the application folder for our purposes.
* For Firebird 3, they must be in the same folder as the client library, i.e. in the `fbclient` folder.
====

[[fbdg30-firedac-embedded]]
=== Developing for Embedded Applications

If you need your application to run without the installed Firebird server, i.e. in the Embedded mode, for Firebird 2.5 you should replace `fbclient.dll` with `fbembed.dll`.
Make sure the width of the CPU register (64-bit or 32-bit) matches the application.
If necessary, the name of the library can be placed in the configuration file of your application. 

It is not necessary to change anything for Firebird 3.0, in which the working mode depends on the connection string and the value of the `Providers` parameter in the file `firebird.conf/databases.conf`.

.TIP
[NOTE]
====
Even if your application is intended to work with Firebird in the Embedded mode, it is advisable to attach to the full server during development.
The reason is that embedded Firebird runs in the same address space as the application and any application connecting to a database in embedded mode must be able to obtain exclusive access to that database.
Once that connection succeeds, no other embedded connections are possible.
When you are connected to your database in the Delphi IDE, the established connection is in Delphi's application space, thus preventing your application from being run successfully from the IDE.

Note, Firebird 3 embedded still requires exclusive access if the installed full server is in Super (Superserver) mode.
====

[[fbdg30-firedac-connparams]]
== Connection parameters

The `Params` property of the `TFDConnection` component contains the database connection parameters (username, password, connection character set, etc.).
If you invoke the `TFDConnection` property editor by double-clicking on the component, you will see that those properties have been filled automatically.
The property set depends on the database type.

[#tfdcon-prop-ed.text-center]
.TFDConnection property editor
image::{docimagepath}/fbdevgd30_delphi_001.png[align="center",pdfwidth="85%",scaledwidth=415px]

[[fbdg30-firedac-tbl-connprops]]
.TFDConnection component main properties
[cols="<1m,<3", frame="all", options="header",stripes="none"]
|===
^| Property
^| Purpose

|Pooled
|Whether a connection pool is used

|Database
|The path to the database or its alias as defined in the `aliases.conf` configuration file (or in `databases.conf`) of the Firebird server

|User_Name
|Firebird user name.
Not used if `OSAuthent` is True.

|Password
|Firebird password.
Not used if `OSAuthent` is True.

|OSAuthent
|Whether operating system authentication is used

|Protocol
a|Connection protocol.
Possible values:

* `Local` -- local protocol
* `NetBEUI` -- named pipes, WNET
* `SPX` -- This property is for Novell's IPX/SPX protocol, which has never been supported in Firebird
* `TCPIP` -- TCP/IP

|Server
|Server name or its IP address.
If the server is run on a non-standard port, you also need to append the port number after a slash, e.g., `localhost/3051`

|SQLDialect
|SQL Dialect.
It must match that of the database

|RoleName
|Role name, if required

|CharacterSet
|Connection character set name

2+<d|Additional Properties:

|Connected
|Used to manage the database connection or check the connection status.
This property must be set to True in order for the wizards of other FireDac components to work.
If your application needs to request authentication data, it is important to remember to reset this property to False before compiling your application.

|LoginPrompt
|Whether to request the username and password during a connection attempt

|Transaction
|The `TFDTransaction` component that will be used as default to conduct various `TFDConnection` transactions.
If this property is not explicitly specified, `TFDConnection` will create its own `TFDTransaction` instance.
Its parameters can be configured in the `TxOptions` property.

|UpdateTransaction
|The `TFDTransaction` component that is to be used as default for the `UpdateTransaction` property of `TFDQuery` components, unless explicitly specified for the dataset.
If this property is not specified explicitly, the value from the `Transaction` property of the connection will be used, unless it is explicitly specified for the dataset.
|===

[[fbdg30-firedac-connparams-ini]]
=== Connection Parameters in a Configuration File

Since the connection parameters, except for the username and password and possibly the role, are usually common to all instances the application, we will read them from the configuration file:

[source]
----
xIniFile := TIniFile.Create(xAppPath + 'config.ini');
try
  xIniFile.ReadSectionValues('connection', FDConnection.Params);
finally
  xIniFile.Free;
end;
----

[[fbdg30-firedac-config-ini]]
==== A Typical Configuration File

Typically, the `config.ini` file contains the following lines: 

----
[connection]
DriverID=FB
Protocol=TCPIP
Server=localhost/3051
Database=examples
OSAuthent=No
RoleName=
CharacterSet=UTF8
----

You can get the contents of the connection section by copying the contents of the `Params` property of the `TFDConnection` component after the wizard finishes its work.

[NOTE]
====
Actually, the common settings are usually located in `%AppData%\Manufacturer\AppName` and are saved to that location by the application installation software.
However, it is convenient for the configuration file to be stored somewhere closer during the development, for instance, in the application folder.

Note that if your application is installed into the `Program Files` folder and the configuration file is located there as well, it is likely that the file will be virtualized in `Program Data` and issues could arise with modifying it and reading the  new settings subsequently.
====

[[fbdg30-firedac-connecting]]
=== Connecting to the database

To connect to the database, it is necessary to change the `Connected` property of the `TFDConnection` component to True or call the `Open` method.
You can use the `Open` method to pass the username and password as parameters.

[[fbdg30-firedac-auth-modification]]
==== A Little Modification

We will replace the standard database connection dialog box in our application and allow users to make three mistakes while entering the authentication information.
After three failures, the application will be closed.

To implement it, we will write the following code in the `OnCreate` event handler of the main data module.

[source]
----
// After three unsuccessful login attempts, we close the application.
xLoginCount := 0;
xLoginPromptDlg := TLoginPromptForm.Create(Self);
while (xLoginCount < MAX_LOGIN_COUNT) and
      (not FDConnection.Connected) do
begin
  try
    if xLoginPromptDlg.ShowModal = mrOK then
      FDConnection.Open(
        xLoginPromptDlg.UserName, xLoginPromptDlg.Password)
    else
      xLoginCount := MAX_LOGIN_COUNT;
  except
    on E: Exception do
    begin
      Inc(xLoginCount);
      Application.ShowException(E);
    end
  end;
end;
xLoginPromptDlg.Free;
if not FDConnection.Connected then
  Halt;
----

[[fbdg30-firedac-transactions]]
== Working with Transactions

The Firebird client allows any operations to be made only in the context of a transaction so, if you manage to access data without explicitly calling `TFDTransaction.StartTransaction`, it means that it was called automatically somewhere deep in FireDac.
It is highly recommended to avoid this practice.
For applications to work correctly with databases, it is advisable to manage transactions manually, which means starting and committing them or rolling them back with explicit calls.

The `TFDTransaction` component is used to manage transactions explicitly.

[[fbdg30-firedac-tfdtransaction]]
=== TFDTransaction Component

`TFDTransaction` has three methods for managing a transaction explicitly: `StartTransaction`, `Commit` and `Rollback`.
The following table summarises the properties available to configure this component.

[[fbdg30-firedac-tbl-transprops]]
.TFDTransaction component main properties
[cols="<1m,<3", frame="all", options="header",stripes="none"]
|===
^| Property
^| Purpose

|Connection
|Reference to the `FDConnection` component

|Options.AutoCommit
|Controls the automatic start and end of a transaction, emulating Firebird's own transaction management.
The default value is True.
See note (1) below for more details about behaviour if the `Autocommit` option is True.

|Options.AutoStart
|Controls the automatic start of a transaction.
The default value is True.

|Options.AutoStop
|Controls the automatic end of a transaction.
The default value is True.

|Options.DisconnectAction
|The action that will be performed when the connection is closed while the transaction is active.
The default value is `xdCommit` -- the transaction will be committed.
See note (2) below for details of the other options.

|Options.EnableNested
|Controls nested transactions.
The default value is True.
Firebird does not support nested transactions as such but FireDac can emulate them using savepoints.
For more details, see note(3) below.

|Options.Isolation
|Specifies the transaction isolation level.
It is the most important transaction property.
The default value is `xiReadCommitted`.
The other values that Firebird supports are `xiSnapshot` and `xiUnspecified`;
also `xiSerializable`, to some degree.
For more details about the available isolation levels, see note (4) below.

|Options.Params
|Firebird-specific transaction attributes that can be applied to refine the transaction parameters, overriding attributes applied by the standard implementation of the selected isolation level.
For the attributes that can be set and the "`legal`" combinations, see note (5) below.

|Options.ReadOnly
|Indicates whether it is a read-only transaction.
The default value is False.
Setting it to True disables any write activity.
Long-running read-only transactions in `READ COMMITTED` isolation are recommended for activities that do not change anything in the database because they use fewer resources and do not interfere with garbage collection.
|===

.Note 1: AutoCommit=True
[NOTE]
====
If the value of `AutoCommit` is set to True, FireDAC  behaves as follows: 

* Starts a transaction (if required) before each SQL command and ends the transaction after the SQL command completes execution
* If the command is successfully executed, the transaction will be ended by `COMMIT`.
Otherwise, it will be ended  by `ROLLBACK`.
* If the application calls the StartTransaction method, automatic transaction management will be disabled until that transaction is ended by Commit or Rollback.
====

.Note 2: DisconnectAction
[NOTE]
====
The following values are possible: 

`xdNone`::
nothing will be done.
The DBMS will perform its default action.

`xdCommit`::
the transaction will be committed

`xdRollback`::
the transaction will be rolled back

Note that, in some other data access components, the default value for the `DisconnectAction` property is `xdRollback` and will need to be set manually with Firebird to match the `FDTransaction` setting.
====

.Note 3: EnableNested
[NOTE]
====
If `StartTransaction` is called from within an active transaction, FireDac will emulate a nested transaction by creating a savepoint.
Unless you are very confident in the effect of enabling nested transactions, set `EnableNested` to False.
With this setting, calling `StartTransaction` inside the transaction will raise an exception.
====

.Note 4: Isolation
[NOTE]
====
FireBird has three isolation levels: `READ COMMITTED`, `SNAPSHOT` ("`concurrency`") and `SNAPSHOT TABLE STABILITY` ("`consistency`", rarely used).
FireDac supports some but not all configurations for `READ COMMITTED` and `SNAPSHOT`.
It uses the third level partially to emulate the `SERIALIZABLE` isolation that Firebird does not support.

`xiReadCommitted`::
the `READ COMMITTED` isolation level.
FireDac starts ReadCommitted transactions in Firebird with the following parameters: read/write, rec_version, nowait

`xiSnapshot`::
the `SNAPSHOT` (concurrency) isolation level.
FireDac starts Snapshot transactions in Firebird with the following parameters: read/write, wait

`xiUnspecified`::
Firebird's default isolation level (`SNAPSHOT`) with the following parameters: read/write, wait

`xiSerializable`::
the `SERIALIZABLE` isolation level.
Firebird does not support serializable isolation, but FireDac emulates it by starting a `SNAPSHOT TABLE STABILITY` ("`consistency`") transaction with the following parameters: read/write, wait.

Other parameters, not supported by Firebird at all, are: 

`xiDirtyRead`::
if this is selected (not a good idea!) `READ COMMITTED` will be used instead

`xiRepeatableRead`::
if this is selected, `SNAPSHOT` will be used instead
====

.Note 5: Firebird-specific Transaction Attributes
[NOTE]
====
Attributes that can be customised in Options.Params are: 

* `read write`, the default read mode for all of the options.isolation selections -- see note (4) above.
Set `write` off if you want read-only mode.
Alternatively, you can set `Options.ReadOnly` to True to achieve the same thing.
There is no such thing as a "`write-only`" transaction.
* `read_committed`, `concurrency` and `consistency` are isolation levels.
* `wait` and `nowait` are conflict resolution settings, determining whether the transaction is to wait for a conflict to resolve
* `rec_version` and `no rec_version` provide an option that is applicable only to `READ COMMITTED` transactions.
The default `rec_version` lets this transaction read the latest committed version of a record and overwrite it if the transaction ID of the latest committed version is newer (higher) than the ID of this transaction.
The `no rec_version` setting will block this transaction from reading the latest committed version if an update is pending from any other transaction.
====

[[fbdg30-firedac-multitransaction]]
==== Multiple Transactions

Unlike many other DBMSs, Firebird allows as many `TFDTransaction` objects as you need to associate with the same connection.
In our application, we will use one common read transaction for all primary and secondary modules and one read/write transaction for each dataset.

We do not want to rely on starting and ending transactions automatically: we want to have full control.
That is why `Options.AutoCommit=False`, `Options.AutoStart=False` and `Options.AutoStop=False` are set in all of our transactions.

[[fbdg30-firedac-datasets]]
== Datasets

The components `TFDQuery`, `TFDTable`,  `TFDStoredProc` and `TFDCommand` are the components for working with data in FireDac.
`TFDCommand` does not deliver a dataset and, when TFDStoredProc is used with an executable stored procedure, rather than a selectable one, it does not deliver a dataset, either.

`TFDQuery`, `TFDTable` and  `TFDStoredProc` are inherited  from `TFDRdbmsDataSet`.

Apart from datasets for working with the database directly, FireDac also has the `TFDMemTable` component for working with in-memory datasets.
It is functionally equivalent to `TClientDataSet`.

The main component for working with datasets, `TFDQuery`, can be used for practically any purpose.
The `TFDTable` and `TFDStoredProc` components are just variants, expanded or reduced to meet differences in functionality.
No more will be said about them and we will not be using them in our application.
If you wish, you can learn about them in the FireDac documentation.

The purpose of a dataset component is to buffer records retrieved by the `SELECT` statement, commonly for displaying in a grid and providing for the current record in the buffer (grid) to be editable.
Unlike the IBX `TIBDataSet` component, `TFDQuery` component does not have the properties `RefreshSQL`, `InsertSQL`, `UpdateSQL` and `DeleteSQL`.
Instead, a separate `TFDUpdateSQL` object specifies the statement for dataset modifications and the dataset component carries a reference to that component in its `UpdateObject` property.

.RequestLive Property
[NOTE]
====
Sometimes it is possible to make an `FDQuery` object editable without referring, through the `UpdateObject` property, to an `FDUpdateSQL` object that specifies queries for insert, update and delete.
The property `UpdateOptions.RequestLive` can be set to True for sets that are naturally updatable and the object will generate the modification queries for you.
However, because this approach puts strict limitations on the `SELECT` query, it is not always useful to rely on it.
====

[[fbdg30-firedac-tfdquery]]
=== TFDQuery Component

[[fbdg30-firedac-tbl-queryprops]]
.TFDQuery component main properties
[cols="<1m,<3", frame="all", options="header",stripes="none"]
|===
^| Property
^| Purpose

|Connection
|Reference to the `FDConnection` object

|MasterSource
|If the dataset is to be used as detail to a master dataset, this property refers to the data source (`TDataSource`) of the master set

|Transaction
|If specified, refers to the transaction within which the query will be executed.
If not specified, the default transaction for the connection will be used.

|UpdateObject
|Reference to the `FDUpdateSQL` object providing for the dataset to be editable when the `SELECT` query does not meet the requirements for automatic generation of modification queries with `UpdateOptions.RequestLive=True`.

|UpdateTransaction
|The transaction within which modification queries will be executed.
If the property is not specified the transaction from the `Transaction` property of the connection will be used.

|UpdateOptions.CheckRequired
|If set to True (the default) FireDac controls the `Required` property of the corresponding `NOT NULL` fields.
If you keep it True and a field with the `Required=True` has no value assigned to it, an exception will be raised when the `Post` method is called.
This might not be what you want if a value is going to be assigned to this field later in `BEFORE` triggers.

|UpdateOptions.EnableDelete
|Specifies whether a record can be deleted from the dataset.
If `EnableDelete=False`, an exception will be raised when the `Delete` method is called.

|UpdateOptions.EnableInsert
|Specifies whether a record can be inserted into the dataset.
If `EnableInsert=False`, an exception will be raised when the `Insert`/`Append` method is called.

|UpdateOptions.EnableUpdate
|Specifies whether a record can be edited in the dataset.
If `EnableUpdate=False`, an exception will be raised when the `Edit` method is called.

|UpdateOptions.FetchGeneratorPoint
|Controls the moment when the next value is fetched from the generator specified in the `UpdateOptions.GeneratorName` property or in the `GeneratorName` property of the auto-incremental field `AutoGenerateValue=arAutoInc`.
The default is `gpDeferred`, causing the next value to be fetched from the generator before a new record is posted in the database, i.e., during `Post` or `ApplyUpdates`.
For the full set of possible values, see note (1) below.

|UpdateOptions.GeneratorName
|The name of the generator from which the next value for an auto-incremental field is to be fetched.

|UpdateOptions.ReadOnly
|Specifies whether it is a read-only dataset.
The default value is False.
If the value of this property is set to True, the `EnableDelete`, `EnableInsert` and `EnableUpdate` properties will be automatically set to False.

|UpdateOptions.RequestLive
|Setting `RequestLive` to True makes a query editable, if possible.
Queries for insert, update and delete will be generated automatically.
This setting imposes strict limitations on the `SELECT` query.
It is supported for backward compatibility with the ancient BDE and is not recommended.

|UpdateOptions.UpdateMode
|Controls how to check whether a record has been modified.
This property allows control over possible overwriting of updates in cases where one user is taking a long time to edit a record while another user has been editing the same record simultaneously and completes the update earlier.
The default is `upWhereKeyOnly`.
For information about the available modes, see note (2) below.

|CachedUpdates
|Specifies whether the dataset cache defers changes in the dataset buffer.
If this property is set to True, any changes (`Insert`/`Post`, `Update`/`Post`, `Delete`) are saved to a special log and the application must apply them explicitly by calling the `ApplyUpdates` method.
All changes will be made within a small period of time and within one short transaction.
The default value of this property is False.

|SQL
|Contains the text of the SQL query.
If this property is a `SELECT` statement, execute it by calling the `Open` method.
Use the `Execute` or `ExecSQL` for executing a statement that does not return a dataset.
|===

.Note 1: UpdateOptions.FetchGeneratorPoint
[NOTE]
====
The property `UpdateOptions.FetchGeneratorPoint` can take the following values:

`gpNone`::
no value is fetched from the generator

`gpImmediate`::
the next value is fetched from the generator right after the `Insert`/`Append` method is called

`gpDeferred`::
the next value is fetched during `Post` or `ApplyUpdates`
====

.Note 2: UpdateOptions.UpdateMode
[NOTE]
====
The user in a lengthy editing session could be unaware that a record has been updated one or more times during his editing session, perhaps causing his own changes to overwrite someone else's updates.
The `UpdateOptions.UpdateMode` property allows a choice of behaviours to lessen or avoid this risk: 

`upWhereAll`::
check whether a record exists by its primary key + check all columns for old values, e.g.,
+
----
update table set ...
where pkfield = :old_ pkfield and
          client_name =  :old_client_name and
         info = :old_info ...
----
+
With `upWhereAll` set, the update query will change content in a record only if the record has not been edited by anyone else since our transaction started.
It is especially important if there are dependencies between values in columns, such as minimum and maximum wages, etc. 

`upWhereChanged`::
check whether a record exists by its primary key + check for old values only in the columns being edited.
+
----
update table set ...
where pkfield = :old_pkfield and
    client_name = :old_client
----

`upWhereKeyOnly`::
check whether a record exists by its primary key.
This check corresponds to the automatically generated `UpdateSQL` query.
+ 
To avoid (or handle) update conflicts in a multi-user environment, typically you need to add `WHERE` conditions manually.
You would need a similar tactic, of course, to implement a process that emulates `upWhereChanged`, removing the unused column modifications from the update table set, leaving in the update list only the columns that are actually modified.
The update query could otherwise overwrite someone else's updates of this record.
+ 
Obviously, the `UpdateSQL` needs to be created dynamically.
+ 
If you want to specify the settings for detecting update conflicts individually for each field, you can use the `ProviderFlags` property for each field.
====

[[fbdg30-firedac-tupdatesql]]
=== TFDUpdateSQL component

The `TFDUpdateSQL` component enables you to refine or redefine the SQL command that Delphi generates automatically for updating a dataset.
It can be used to update an `FDQuery` object, an `FDTable` object or data underlying an `FDStoredProc` object.

Using `TFDUpdateSQL` is optional for `TFDQuery` and `TFDTable` because these components can generate statements automatically, that can sometimes be used for posting updates from a dataset to the database.
For updating a dataset that is delivered into an `FDStoredProc` object, use of the `TFDUpdateSQL` is not optional.
The developer must figure out a statement that will result in the desired updates.
If only one table is updated, a direct DML statement might be sufficient.
Where multiple tables are affected, an executable stored procedure will be unavoidable.

We recommend that you always use it, even in the simplest cases, to give yourself full control over the queries that are requested from your application.

[[fbdg30-firedac-tupdatesql-props]]
==== TFDUpdateSQL Properties

To specify the SQL DML statements at design time, double-click on the `TFDUpdateSQL` component in your data module to open the property editor. 

[IMPORTANT]
====
Each component has its own design-time property editor.
For multiple data-aware editors to run, FireDac needs an active connection to the database (`TFDConnection.Connected = True`) and a transaction in the autostart mode (`TFDTransaction.Options.AutoStart = True`) for each one.

Design-time settings could interfere with the way the application is intended to work.
For instance, the user is supposed to log in to the program using his username, but the `FDConnection` object connects to the database as SYSDBA.

It is advisable to check the `Connected` property of the `FDConnection` object and reset it each time you use the data-aware editors.
`AutoStart` will have to be enabled and disabled for a read-only transaction as well.
====

[#tfdupdsql-prop-ed.text-center]
.TFDUpdateSQL property editor
image::{docimagepath}/fbdevgd30_delphi_002.png[align="center",pdfwidth="90%",scaledwidth=454px]

You can use the Generate tab to make writing Insert/Update/Delete/Refresh queries easier for yourself.
Select the table to be updated, its key fields, the fields to be updated and the fields that will be reread after the update and click the Generate SQL button to have Delphi generate the queries automatically.
You will be switched to the SQL Commands tab where you can correct each query.

[#updsql-cmd-editor.text-center]
.TFDUpdateSQL SQL command editor
image::{docimagepath}/fbdevgd30_delphi_003.png[align="center",pdfwidth="90%",scaledwidth=454px]

[NOTE]
====
Since `product_id` is not included in `Updating Fields`, it is absent from the generated Insert query.
It is assumed that this column is filled automatically by a generator call in a `BEFORE INSERT` trigger or, from Firebird 3.0 forward, it could be an `IDENTITY` column.
When a value is fetched from the generator for this column at the server side, it is recommended to add the `PRODUCT_ID` column manually to the `RETURNING` clause of the `INSERT` statement.
====

[[fbdg30-firedac-tupdatesql-options]]
===== The Options Tab

The Options tab contains some properties that can affect the process of query generation.
These properties are not related to the `TFDUpdateSQL` component itself.
Rather, for convenience, they are references to the `UpdateOptions` properties of the dataset that has the current `TFDUpdateSQL` specified in its `UpdateObject` property.

[[fbdg30-firedac-tbl-updsqlprops]]
.TFDUpdateSQL component main properties
[cols="<1m,<3", frame="all", options="header",stripes="none"]
|===
^| Property
^| Purpose

|Connection
|Reference to the `TFDConnection` component

|DeleteSQL
|The SQL query for deleting a record

|FetchRowSQL
|The SQL query for returning a current record after it has been updated or inserted -- "`RefreshSQL`"

|InsertSQL
|The SQL query for inserting a record

|LockSQL
|The SQL query for locking a current record.
(`FOR UPDATE WITH LOCK`)

|ModifySQL
|The SQL query for modifying a record

|UnlockSQL
|The SQL query for unlocking a current record.
It is not used in Firebird.
|===

Notice that, because the `TFDUpdateSQL` component  does not execute modification queries directly, it has no `Transaction` property.
It acts as a replacement for queries automatically generated in the parent `TFDRdbmsDataSet`.

[[fbdg30-firedac-tfdcommand]]
== TFDCommand component

The `TFDCommand` component is used to execute SQL queries.
It is not descended from `TDataSet` so it is valid to use only for executing SQL queries that do not return datasets.

[[fbdg30-firedac-tbl-tfdcommand]]
.TFDCommand component main properties
[cols="<1m,<3", frame="all", options="header",stripes="none"]
|===
^| Property
^| Purpose

|Connection
|Reference to the `TFDConnection` component

|Transaction
|The transaction within which the SQL command will be executed

|CommandKind
|Type of command.
The types are described in the section below.

|CommandText
|SQL query text
|===

[[fbdg30-firedac-commandkind]]
=== Types of Command

Usually, the command type is determined automatically from the text of the SQL statement.
The following values are available for the property `TFDCommand.CommandKind` to cater for cases where the internal parser might be unable to make correct, unambiguous assumptions based on the statement text alone:

`skUnknown`::
unknown.
Tells the internal parser to determine the command type automatically from its analysis of the text of the command

`skStartTransaction`::
a command for starting a transaction

`skCommit`::
a command for ending and committing a transaction

`skRollback`::
a command for ending and rolling back a transaction

`skCreate`::
a `CREATE ...` command for creating a new metadata object

`skAlter`::
an `ALTER ...` command for altering a metadata object

`skDrop`::
a `DROP ...` command for deleting a metadata object

`skSelect`::
a `SELECT` command for retrieving data

`skSelectForLock`::
a `SELECT ... WITH LOCK` command for locking the selected rows

`skInsert`::
an `INSERT ...` command for inserting a new record

`skUpdate`::
an `UPDATE ...` command for modifying records

`skDelete`::
a `DELETE ...` command for deleting records

`skMerge`::
a `MERGE INTO ...` command

`skExecute`::
an `EXECUTE PROCEDURE` or `EXECUTE BLOCK` command

`skStoredProc`::
a stored procedure call

`skStoredProcNoCrs`::
a call to a stored procedure that does not return a cursor

`skStoredProcWithCrs`::
a call to a stored procedure that returns a cursor

[[fbdg30-firedac-primary-modules]]
== Creating the Primary Modules

We will create two  primary modules in our application: a product module and a customer module.
Each primary dataset is displayed on a form by means of a `TDBGrid` grid and a toolbar with buttons.
The business logic of working with the dataset will be located in a separate DataModule that contains a `TDataSource` data source, a `TFDQuery` dataset, and two `TFDTransaction` transactions, one read-only  and one read/write.

As our model for creating datasets, we will create the Customer dataset on the dCustomers datamodule:

[#dcust-datamodule.text-center]
.dCustomers datamodule
image::{docimagepath}/fbdevgd30_delphi_004.png[align="center",pdfwidth="85%",scaledwidth=435px]

On tabbing to the Customers form, this is the initial view.
The DataSource component is not visible on the form because it is located in the dCustomers datamodule.

[#cust-form-init.text-center]
.Customers form, initial view
image::{docimagepath}/fbdevgd30_delphi_005.png[align="center",pdfwidth="100%",scaledwidth=492px]

We have placed the `TFDQuery` component in the `dCustomers` datamodule and named it `qryCustomers`.
This dataset will be referred to in the `DataSet` property of the `DataSource` data source in `DCustomers`.
We specify the read-only transaction `trRead` in the `Transaction` property, the `trWritetransaction` in the  `UpdateTransaction` property and, for the `Connection` property, the connection located in the main data module.
We populate the `SQL` property with the following query:

[source]
----
SELECT
  customer_id,
  name,
  address,
  zipcode,
  phone
FROM
  customer
ORDER BY name
----

[[fbdg30-firedac-modules-readtransaction]]
=== The Read-only Transaction

The `trRead` read transaction is started when the dataset form is displayed (the `OnActivate` event) and is ended when the form is closed.
`READ COMMITTED` isolation level (`Options.Isolation = xiReadCommitted`) is usually used to show data in grids because it allows the transaction to see changes committed in the database by other users by just repeating queries (rereading data) without the transaction being restarted.

Since this transaction is used only to read data, we set the `Options.ReadOnly` property to True.
Thus, our transaction will have the following parameters: `read read_committed rec_version`.

.Why?
[NOTE]
====
A transaction with exactly these parameters can remain open in Firebird as long as necessary (days, weeks, months) without locking other transactions or affecting the accumulation of garbage in the database because, with these parameters, a transaction is started on the server as committed.
====

We set the property `Options.DisconnectAction` to `xdCommit`, which perfectly fits a read-only transaction.
Finally, the read transaction will have  the following properties: 

----
Options.AutoStart = False
Options.AutoCommit = False
Options.AutoStop = False
Options.DisconnectAction = xdCommit
Options.Isolations = xiReadCommitted
Options.ReadOnly = True
----

[IMPORTANT]
====
Although we do not discuss reporting in this manual, be aware that you should not use such a transaction for reports, especially if they use several queries in sequence.
A transaction with `READ COMMITTED` isolation will see all new committed changes when rereading data.
The recommended configuration for reports is a short read-only transaction with `SNAPSHOT` isolation  (`Options.Isolation = xiSnapshot and Options.ReadOnly= True`).
====

[[fbdg30-firedac-modules-writetransaction]]
=== The Read/Write Transaction

The write transaction `trWrite` that we use for our `FDUpdateSQL` object must be as short as possible to prevent the oldest active transaction from getting "`stuck`" and inhibiting garbage collection.
High levels of uncollected garbage will lead to lower performance.
Since the write transaction is very short, we can use the `SNAPSHOT` isolation level.
The default value of the `Options.DisconnectAction` property, `xdCommit`, is not appropriate for write transactions, so it should be set to `xdRollback`.
We will not rely on starting and ending transactions automatically.
Instead, we will start and end a transaction explicitly.
Thus, our transaction should have the following properties:  

----
Options.AutoStart = False
Options.AutoCommit = False
Options.AutoStop = False
Options.DisconnectAction = xdRollback
Options.Isolations = xiSnapshot
Options.ReadOnly = False
----

[[fbdg30-firedac-modules-whichlevel]]
==== SNAPSHOT vs READ COMMITTED Isolation

It is not absolutely necessary to specify `SNAPSHOT` isolation for simple `INSERT`/`UPDATE`/`DELETE` operations.
However, if a table has complex triggers or a stored procedure is executed instead of a simple `INSERT`/`UPDATE`/`DELETE` query, it is advisable to use `SNAPSHOT`.
The reason is that `READ COMMITTED` isolation does not ensure the read consistency of the statement within one transaction, since the `SELECT` statement in this isolation can return data that were committed to the database after the transaction began.
In principle, `SNAPSHOT` isolation is recommended for short-running transactions.

[[fbdg30-firedac-modules-customer-config]]
=== Configuring the Customer Module for Editing

In this section, we will configure some properties in the `qryCustomer` and `FDUpdateCustomer` objects to make the `Customer` dataset editable.

[[fbdg30-firedac-modules-editing]]
==== The TFDUpdateSQL Settings

To make the dataset editable, the `InsertSQL`, `ModifySQL`, `DeleteSQL` and `FetchRowSQL` properties  should be specified in the `FDUpdateSQL` object that is linked to the dataset.
The wizard can generate these statements but it may be necessary to correct some things afterwards.
For example, you can add a `RETURNING` clause, remove some columns from the update list or cancel an automatically generated stored procedure call entirely.

[[fbdg30-firedac-modules-insertsql]]
===== InsertSQL

[source]
----
INSERT INTO customer (
  customer_id,
  name,
  address,
  zipcode,
  phone)
VALUES (:new_customer_id,
  :new_name,
  :new_address,
  :new_zipcode,
  :new_phone)
----

[[fbdg30-firedac-modules-modifysql]]
===== ModifySQL

[source]
----
UPDATE customer
SET name = :new_name,
    address = :new_address,
    zipcode = :new_zipcode,
    phone = :new_phone
WHERE (customer_id = :old_customer_id)
----

[[fbdg30-firedac-modules-deletesql]]
===== DeleteSQL

[source]
----
DELETE FROM customer
WHERE (customer_id = :old_customer_id)
----

[[fbdg30-firedac-modules-fetchrowsql]]
===== FetchRowSQL

[source]
----
SELECT
  customer_id,
  name,
  address,
  zipcode,
  phone
FROM
  customer
WHERE customer_id = :old_customer_id
----

[[fbdg30-firedac-modules-getgenerator]]
==== Getting a Generator Value

In this project, we will get the value from the generator before making an insert into the table.
To enable that, specify the following values for the properties of the `TFDQuery` component: 

----
UpdateOptions.GeneratorName = GEN_CUSTOMER_ID
----

and

----
UpdateOptions.AutoIncFields = CUSTOMER_ID
----

[NOTE]
====
This method works only for autoinc fields that are populated by explicit generators (sequences).
It is not applicable to the `IDENTITY` type of autoinc key introduced in Firebird 3.0.
====

Another way to get the value from the generator is to return it after the `INSERT` is executed by means of a `RETURNING` clause.
This method, which works for `IDENTITY` fields as well, will be shown later, in the topic <<fbdg30-firedac-modules-returningclause>>.

[[fbdg30-firedac-modules-customer-impl]]
=== Implementing the Customer Module

Modal forms are often used to add a new record or to edit an existing one.
Once the modal form is closed by the `mrOK` result, the changes are posted to the database.
Database-aware visual components are usually used to create this kind of form.
These components enable you to display the values of some fields from the current record and immediately accept the user's changes in the corresponding fields if the dataset is in the Insert/Edit mode, i.e. before `Post`.

The only way to switch the dataset to Insert/Edit mode is by starting a write transaction.
So, if somebody opens a form for adding a new record and leaves for a lunch break, we will have an active transaction hanging until the user comes back from lunch and closes the form.
This uncommitted edit can inhibit garbage collection, which will reduce performance.
There are two ways to solve this problem: 

. Use the `CachedUpdates` mode, which enables the transaction to be active just for a very short period (to be exact, just for the time it takes for the changes to be applied to the database).
. Give up using visual components that are data-aware.
This approach requires some additional effort from you to activate the data source and pass user input to it.

We will show how both methods are implemented.
The first method is much  more convenient to use.
Let's examine the code for editing a customer record:

[source]
----
procedure TCustomerForm.actEditRecordExecute(Sender: TObject);
var 
  xEditorForm: TEditCustomerForm; 
begin 
  xEditorForm := TEditCustomerForm.Create(Self); 
  try 
    xEditorForm.OnClose := CustomerEditorClose; 
    xEditorForm.DataSource := Customers.DataSource;
    xEditorForm.Caption := 'Edit customer'; 
    Customers.Edit; 
    xEditorForm.ShowModal; 
  finally 
    xEditorForm.Free; 
  end; 
end;
The Customers property is initiated in the OnCreate event:
procedure TCustomerForm.FormCreate(Sender: TObject); 
begin 
  FCustomers := TDMCustomers.Create(Self); 
  DBGrid.DataSource := Customers.DataSource; 
end;
----

We set the `CachedUpdates` mode for the dataset in the Edit method of the `dCustomers` module before switching it to the edit mode:

[source]
----
procedure TdmCustomers.Edit;
begin 
  qryCustomer.CachedUpdates := True; 
  qryCustomer.Edit; 
end;
----

The logic of handling the process of editing and adding a record is implemented in the `OnClose` event handler for the modal edit form:

[source]
----
procedure TCustomerForm.CustomerEditorClose(Sender: TObject;
  var Action: TCloseAction); 
begin 
  if TEditCustomerForm(Sender).ModalResult <> mrOK then
  begin 
    Customers.Cancel; 
    Action := caFree; 
    Exit; 
  end; 
  try 
    Customers.Post; 
    Customers.Save; 
    Action := caFree; 
  except 
    on E: Exception do 
    begin 
      Application.ShowException(E); 
      // It does not close the window give the user correct the error 
      Action := caNone; 
    end; 
  end;
end;
----

To understand the internal processes, we can study the code for the `Cancel`, `Post` and `Save` methods of the `dCustomer` data module:

[source]
----
procedure TdmCustomers.Cancel;
begin 
  qryCustomer.Cancel; 
  qryCustomer.CancelUpdates; 
  qryCustomer.CachedUpdates := False; 
end;

procedure TdmCustomers.Post; 
begin 
  qryCustomer.Post; 
end;
 
procedure TdmCustomers.Save; 
begin 
  // We do everything in a short transaction 
  // In CachedUpdates mode an error does not interrupt the running code. 
  // The ApplyUpdates method returns the number of errors. 
  // The error can be obtained from the property RowError 
  try 
    trWrite.StartTransaction; 
    if (qryCustomer.ApplyUpdates = 0) then 
    begin 
      qryCustomer.CommitUpdates; 
      trWrite.Commit; 
    end 
    else 
      raise Exception.Create(qryCustomer.RowError.Message); 
    qryCustomer.CachedUpdates := False; 
  except 
    on E: Exception do 
    begin 
      if trWrite.Active then 
        trWrite.Rollback; 
      raise; 
    end; 
  end; 
end;
----

Observe that the write transaction is not started at all until the btn:[OK] button is clicked.
Thus, the write transaction is active only while the data are being transferred from the dataset buffer to the database.
Since we access not more than one record in the buffer, the transaction will be active for a very short  time, which is exactly what we want.

[[fbdg30-firedac-modules-returningclause]]
=== Using a RETURNING Clause to Acquire an Autoinc Value

Creating the product is similar to creating the customer one.
We will use it to demonstrate the method of getting an auto-incremented value by means of a `RETURNING` clause.

The main query: 
[source]
----
SELECT
  product_id,
  name,
  price,
  description
FROM product
ORDER BY name
----

The `TFDUpdateSQL.InsertSQL` property will contain the following statement:

[source]
----
INSERT INTO PRODUCT (NAME, PRICE, DESCRIPTION)
VALUES (:NEW_NAME, :NEW_PRICE, :NEW_DESCRIPTION)
RETURNING PRODUCT_ID
----

The `RETURNING` clause in this statement will return the value of the `PRODUCT_ID` field after it has been populated by the `BEFORE INSERT` trigger.
The client side in this case has no need to know the name of the generator, since it all happens on the server.
Leave the `UpdateOptions.GeneratorName` property as nil.

To acquire the autoinc value by this method also requires filling a couple of properties for the `PRODUCT_ID` field because the value is being entered indirectly:

----
Required = False
----

and

----
ReadOnly = True
----

Everything else is set up similarly to the way it was done for the Customer module.

[[fbdg30-firedac-secondary-modules]]
== Creating a Secondary Module

Secondary datasets typically contain larger numbers of records than primary datasets and new records are added frequently.
Our application will have only one secondary module, named "`Invoices`".

An invoice consists of a header where some general attributes are described (number, date, customer ...) and invoice lines with the list of products, their quantities, prices, etc.
It is convenient to have two grids for such documents: the main one (master) showing the data invoice header data and the detail one showing the invoice lines.

We want to place two `TDBGrid` components on the invoice form and link a separate `TDataSource` to each of them that will be linked to its respective `TFDQuery`.
In our project, the dataset with the invoice headers (the master set) will be called `qryInvoice`, and the one with the invoice lines (the detail set) will be called `qryInvoiceLine`.

[[fbdg30-firedac-secondary-modules-txread]]
=== The Transactions for Invoice Data

The `Transaction` property of each dataset will specify the read-only transaction `trRead` that is located in the `dmInvoicedata` module.
Use the `UpdateTransaction` property to specify the `trWrite` transaction and the `Connection` property to specify the connection located in the main data module.

[[fbdg30-firedac-secondary-modules-workperiod]]
=== A Filter for the Data

Secondary datasets usually contain a field with the record creation date.
In order to reduce the amount of retrieved data, a notion such as "`a work period`" is commonly incorporated in the application to filter the set of data sent to the client.
A work period is a range of dates for which the records are required.

Since the application could have more than one secondary dataset, it makes sense to add variables containing the start and end dates of a work period to the global `dmMain` data module that is used by all modules working with the database in one way or another.
Once the application is started, the work period could be defined by the start and end dates of the current quarter, or some other appropriate start/end date pair.
The application could allow the user to change the work period while working with the application.

[[fbdg30-firedac-secondary-modules-configuring]]
=== Configuring the Module

[#inv-module-config.text-center]
.The Invoice form tab
image::{docimagepath}/fbdevgd30_delphi_006.png[align="center",pdfwidth="100%",scaledwidth=495px]


[#inv-datamodule.text-center]
.The Invoice data module tab
image::{docimagepath}/fbdevgd30_delphi_007.png[align="center",pdfwidth="100%",scaledwidth=480px]

Since the latest invoices are the most requested ones, it makes sense to sort them by date in reverse order.
The query will look like this in the SQL property of the `qryInvoice` dataset:

[source]
----
SELECT
  invoice.invoice_id AS invoice_id,
  invoice.customer_id AS customer_id,
  customer.NAME AS customer_name,
  invoice.invoice_date AS invoice_date,
  invoice.total_sale AS total_sale,
  IIF(invoice.payed=1, 'Yes', 'No') AS payed
FROM
  invoice
  JOIN customer ON customer.customer_id = invoice.customer_id
WHERE invoice.invoice_date BETWEEN :date_begin AND :date_end
ORDER BY invoice.invoice_date DESC
----

To open this dataset, it will be necessary to initialise the query parameters:

[source]
----
qryInvoice.ParamByName('date_begin').AsSqlTimeStamp := dmMain.BeginDateSt;
qryInvoice.ParamByName('date_end').AsSqlTimeStamp := dmMain.EndDateSt;
qryInvoice.Open;
----

For the purpose of illustration, we will use stored procedures to perform all operations on an invoice.
Regular `INSERT`/`UPDATE`/`DELETE` queries can be used when operations are simple and involve writing to only one table in the database.
We will execute each stored procedure as a separate query in `TFDCommand` objects.
This component is not descended from `TFDRdbmsDataSet`, does not buffer data and returns not more than one result row.
We are using it because it consumes fewer resources for queries that do not return data.

Since our stored procedures modify data, it is necessary to point the `Transaction` property of each `TFDCommand` object to the `trWrite` transaction.

.Tip
[NOTE]
====
Another alternative is to place the stored procedure calls for inserting, editing and adding a record in the corresponding properties of a `TFDUpdateSQL` object.
====

[[fbdg30-firedac-secondary-modules-operations]]
=== Doing the Work

Four operations are provided for working with the invoice header: adding, editing, deleting and setting the "`paid`" attribute.
Once an invoice is paid, we prevent any modifications to either the header or the lines.
The rule is implemented at stored procedure level.
Let's examine the query strings in the `CommandText` property for calling the stored procedures.

.qryAddInvoice.CommandText [[fbdg30-firedac-secondary-proc-addinvoice]]
----
EXECUTE PROCEDURE sp_add_invoice(
  NEXT VALUE FOR gen_invoice_id,
  :CUSTOMER_ID,
  :INVOICE_DATE
)
----

.qryEditInvoice.CommandText [[fbdg30-firedac-secondary-proc-editinvoice]]
----
EXECUTE PROCEDURE sp_edit_invoice(
  :INVOICE_ID,
  :CUSTOMER_ID,
  :INVOICE_DATE
)
----

.qryDeleteInvoice.CommandText [[fbdg30-firedac-secondary-proc-dltinvoice]]
----
EXECUTE PROCEDURE sp_delete_invoice(:INVOICE_ID)
----

.qryPayForInvoice.CommandText [[fbdg30-firedac-secondary-proc-payinvoice]]
----
EXECUTE PROCEDURE sp_pay_for_invoice(:invoice_id)
----

Since our stored procedures are not called from a `TFDUpdateSQL` object, we need to call `qryInvoice.Refresh` after they are executed, in order to update the data in the grid.

Stored procedures that do not require input data from the user are called as follows:

[source]
----
procedure TdmInvoice.DeleteInvoice;
begin
  // We do everything in a short transaction
  trWrite.StartTransaction;
  try
    qryDeleteInvoice.ParamByName('INVOICE_ID').AsInteger :=
      Invoice.INVOICE_ID.Value;
    qryDeleteInvoice.Execute;
    trWrite.Commit;
    qryInvoice.Refresh;
  except
    on E: Exception do
    begin
      if trWrite.Active then
        trWrite.Rollback;
      raise;
    end;
  end;
end;
----

[[fbdg30-firedac-secondary-usrconfirm]]
==== Getting User Confirmation

Before performing some operations, such as deleting an invoice, we want to get confirmation from the user:

[source]
----
procedure TInvoiceForm.actDeleteInvoiceExecute(Sender: TObject);
begin
  if MessageDlg('Are you sure you want to delete an invoice?',
                mtConfirmation,
                [mbYes, mbNo], 0) = mrYes then
  begin
    Invoices.DeleteInvoice;
  end;
end;
----

[[fbdg30-firedac-secondary-add-or-edit]]
==== Adding or Editing Records

As with the primary modules, we will use modal forms to add a new record or edit an existing one.
We will not use data-aware visual components in this implementation.
As another variation, we will use a `TButtonedEdit` component to select a customer.
It will display the name of the current customer and open a modal form with a grid for selecting a customer on the click of the embedded button.
We could use something like `TDBLookupCombobox`, of course, but it has drawbacks: first, the customer list may be too large for scrolling comfortably through the drop-down list; secondly, the name alone may not be enough to find the customer you want.

[#cust-input-form.text-center]
.The Customer input form
image::{docimagepath}/fbdevgd30_delphi_008.png[align="center",pdfwidth="75%",scaledwidth=380px]

As the window for selecting a customer, we will use the same modal form that was created for adding customers.
The code for the button click handler for the `TButtonedEdit` component is as follows:

[source]
----
procedure TEditInvoiceForm.edtCustomerRightButtonClick(Sender: TObject);
var
  xSelectForm: TCustomerForm;
begin
  xSelectForm := TCustomerForm.Create(Self);
  try
    xSelectForm.Visible := False;
    if xSelectForm.ShowModal = mrOK then
    begin
      FCustomerId := xSelectForm.Customers.Customer.CUSTOMER_ID.Value;
      edtCustomer.Text := xSelectForm.Customers.Customer.NAME.Value;
    end;
  finally
    xSelectForm.Free;
  end;
end;
----

Since we are not using data-aware visual components, we need to initialize the customer code and name for displaying during the call to the edit form:

[source]
----
procedure TInvoiceForm.actEditInvoiceExecute(Sender: TObject);
var
  xEditorForm: TEditInvoiceForm;
begin
  xEditorForm := TEditInvoiceForm.Create(Self);
  try
    xEditorForm.OnClose := EditInvoiceEditorClose;
    xEditorForm.Caption := 'Edit invoice';
    xEditorForm.InvoiceId := Invoices.Invoice.INVOICE_ID.Value;
    xEditorForm.SetCustomer(
      Invoices.Invoice.CUSTOMER_ID.Value,
      Invoices.Invoice.CUSTOMER_NAME.Value);
    xEditorForm.InvoiceDate := Invoices.Invoice.INVOICE_DATE.AsDateTime;
    xEditorForm.ShowModal;
  finally
    xEditorForm.Free;
  end;
end;

procedure TEditInvoiceForm.SetCustomer(ACustomerId: Integer;
  const ACustomerName: string);
begin
  FCustomerId := ACustomerId;
  edtCustomer.Text := ACustomerName;
end;
----

Adding a new invoice and editing an existing one will be handled in the `Close` event of the modal form  as it is for the primary modules.
However, we will not switch the dataset to `CachedUpdates` mode for these because the updates carried out by stored procedures and we are not using data-aware visual components to capture input.

[source]
----
procedure TInvoiceForm.actAddInvoiceExecute(Sender: TObject);
var
  xEditorForm: TEditInvoiceForm;
begin
  xEditorForm := TEditInvoiceForm.Create(Self);
  try
    xEditorForm.Caption := 'Add invoice';
    xEditorForm.OnClose := AddInvoiceEditorClose;
    xEditorForm.InvoiceDate := Now;
    xEditorForm.ShowModal;
  finally
    xEditorForm.Free;
  end;
end;

procedure TInvoiceForm.AddInvoiceEditorClose(Sender: TObject;
  var Action: TCloseAction);
var
  xEditorForm: TEditInvoiceForm;
begin
  xEditorForm := TEditInvoiceForm(Sender);
  if xEditorForm.ModalResult <> mrOK then
  begin
    Action := caFree;
    Exit;
  end;
  try
    Invoices.AddInvoice(xEditorForm.CustomerId, xEditorForm.InvoiceDate);
    Action := caFree;
  except
    on E: Exception do
    begin
      Application.ShowException(E);
// It does not close the window give the user correct the error
      Action := caNone;
    end;
  end;
end;

procedure TdmInvoice.AddInvoice(ACustomerId: Integer; AInvoiceDate: TDateTime);
begin
  // We do everything in a short transaction
  trWrite.StartTransaction;
  try
    qryAddInvoice.ParamByName('CUSTOMER_ID').AsInteger := ACustomerId;
    qryAddInvoice.ParamByName('INVOICE_DATE').AsSqlTimeStamp :=
    DateTimeToSQLTimeStamp(AInvoiceDate);
    qryAddInvoice.Execute();
    trWrite.Commit;
    qryInvoice.Refresh;
  except
    on E: Exception do
    begin
      if trWrite.Active then
        trWrite.Rollback;
      raise;
    end;
  end;
end;
----

[[fbdg30-firedac-secondary-inv-detail]]
=== The Invoice Details

Next, we move on to the details of an invoice.
For the qryInvoiceLine dataset, we set the `MasterSource` property to the datasource that is linked to `qryInvoice` and the `MasterFields` property to `INVOICE_ID`.
We specify the following query in the `SQL` property:

[source]
----
SELECT
  invoice_line.invoice_line_id AS invoice_line_id,
  invoice_line.invoice_id AS invoice_id,
  invoice_line.product_id AS product_id,
  product.name AS productname,
  invoice_line.quantity AS quantity,
  invoice_line.sale_price AS sale_price,
  invoice_line.quantity * invoice_line.sale_price AS total
FROM
  invoice_line
  JOIN product ON product.product_id = invoice_line.product_id
WHERE invoice_line.invoice_id = :invoice_id
----

As with the invoice header, we will use stored procedures to perform all modifications.
Let's examine the query strings in the `CommandText` property of the commands that call the stored procedures.

.qryAddInvoiceLine.CommandText [[fbdg30-firedac-secondary-inv-line-add]]
----
EXECUTE PROCEDURE sp_add_invoice_line(
  :invoice_id,
  :product_id,
  :quantity
)
----

.qryEditInvoiceLine.CommandText [[fbdg30-firedac-secondary-inv-line-edit]]
----
EXECUTE PROCEDURE sp_edit_invoice_line(
  :invoice_line_id,
  :quantity
)
----

.qryDeleteInvoiceLine.CommandText [[fbdg30-firedac-secondary-inv-line-dlt]]
----
EXECUTE PROCEDURE sp_delete_invoice_line(
  :invoice_line_id
)
----

As with the header, the form for adding a new record and editing an existing one does not use data-aware visual components.
To select a product, we use the `TButtonedEdit` component again.
The code for the on-click handler for the button on the `TButtonedEdit` object is as follows:

[source]
----
procedure TEditInvoiceLineForm.edtProductRightButtonClick(Sender: TObject);
var
  xSelectForm: TGoodsForm;
begin
  if FEditMode = emInvoiceLineEdit then
    Exit;
  xSelectForm := TGoodsForm.Create(Self);
  try
    xSelectForm.Visible := False;
    if xSelectForm.ShowModal = mrOK then
    begin
      FProductId := xSelectForm.Goods.Product.PRODUCT_ID.Value;
      edtProduct.Text := xSelectForm.Goods.Product.NAME.Value;
      edtPrice.Text := xSelectForm.Goods.Product.PRICE.AsString;
    end;
  finally
    xSelectForm.Free;
  end;
end;
----

Since we are not using data-aware visual components, again we will need to initialize the product code and name and its price for displaying on the edit form.

[source]
----
procedure TInvoiceForm.actEditInvoiceLineExecute(Sender: TObject);
var
  xEditorForm: TEditInvoiceLineForm;
begin
  xEditorForm := TEditInvoiceLineForm.Create(Self);
  try
    xEditorForm.EditMode := emInvoiceLineEdit;
    xEditorForm.OnClose := EditInvoiceLineEditorClose;
    xEditorForm.Caption := 'Edit invoice line';
    xEditorForm.InvoiceLineId := Invoices.InvoiceLine.INVOICE_LINE_ID.Value;
    xEditorForm.SetProduct(
      Invoices.InvoiceLine.PRODUCT_ID.Value,
      Invoices.InvoiceLine.PRODUCTNAME.Value,
      Invoices.InvoiceLine.SALE_PRICE.AsCurrency);
    xEditorForm.Quantity := Invoices.InvoiceLine.QUANTITY.Value;
    xEditorForm.ShowModal;
  finally
    xEditorForm.Free;
  end;
end;

procedure TEditInvoiceLineForm.SetProduct(AProductId: Integer;
  AProductName: string; APrice: Currency);
begin
  FProductId := AProductId;
  edtProduct.Text := AProductName;
  edtPrice.Text := CurrToStr(APrice);
end;
----

We handle adding a new item and editing an existing one in the Close event of the modal form.

[source]
----
procedure TInvoiceForm.actAddInvoiceLineExecute(Sender: TObject);
var
  xEditorForm: TEditInvoiceLineForm;
begin
  xEditorForm := TEditInvoiceLineForm.Create(Self);
  try
xEditorForm.EditMode := emInvoiceLineAdd;
xEditorForm.OnClose := AddInvoiceLineEditorClose;
    xEditorForm.Caption := 'Add invoice line';
    xEditorForm.Quantity := 1;
    xEditorForm.InvoiceId := Invoices.Invoice.INVOICE_ID.Value;
    xEditorForm.ShowModal;
  finally
    xEditorForm.Free;
  end;
end;

procedure TInvoiceForm.actEditInvoiceLineExecute(Sender: TObject);
var
  xEditorForm: TEditInvoiceLineForm;
begin
  xEditorForm := TEditInvoiceLineForm.Create(Self);
  try
    xEditorForm.EditMode := emInvoiceLineEdit;
    xEditorForm.OnClose := EditInvoiceLineEditorClose;
    xEditorForm.Caption := 'Edit invoice line';
    xEditorForm.InvoiceLineId := Invoices.InvoiceLine.INVOICE_LINE_ID.Value;
    xEditorForm.SetProduct(
      Invoices.InvoiceLine.PRODUCT_ID.Value,
      Invoices.InvoiceLine.PRODUCTNAME.Value,
      Invoices.InvoiceLine.SALE_PRICE.AsCurrency);
    xEditorForm.Quantity := Invoices.InvoiceLine.QUANTITY.Value;
    xEditorForm.ShowModal;
  finally
    xEditorForm.Free;
  end;
end;

procedure TInvoiceForm.AddInvoiceLineEditorClose(Sender: TObject;
  var Action: TCloseAction);
var
  xEditorForm: TEditInvoiceLineForm;
  xCustomerId: Integer;
begin
  xEditorForm := TEditInvoiceLineForm(Sender);
  if xEditorForm.ModalResult <> mrOK then
  begin
    Action := caFree;
    Exit;
  end;
  try
    Invoices.AddInvoiceLine(xEditorForm.ProductId, xEditorForm.Quantity);
    Action := caFree;
  except
    on E: Exception do
    begin
      Application.ShowException(E);
      // It does not close the window give the user correct the error
      Action := caNone;
    end;
  end;
end;

procedure TInvoiceForm.EditInvoiceLineEditorClose(Sender: TObject;
  var Action: TCloseAction);
var
  xCustomerId: Integer;
  xEditorForm: TEditInvoiceLineForm;
begin
  xEditorForm := TEditInvoiceLineForm(Sender);
  if xEditorForm.ModalResult <> mrOK then
  begin
    Action := caFree;
    Exit;
  end;
  try
    Invoices.EditInvoiceLine(xEditorForm.Quantity);
    Action := caFree;
  except
    on E: Exception do
    begin
      Application.ShowException(E);
      // It does not close the window give the user correct the error
      Action := caNone;
    end;
  end;
end;
----

Now let's take a look at the code for the `AddInvoiceLine` and `EditInvoiceLine` procedures of the `dmInvoice` data module:

[source]
----
procedure TdmInvoice.AddInvoiceLine(AProductId: Integer; AQuantity: Integer);
begin
  // We do everything in a short transaction
  trWrite.StartTransaction;
  try
    qryAddInvoiceLine.ParamByName('INVOICE_ID').AsInteger :=
      Invoice.INVOICE_ID.Value;
    if AProductId = 0 then
      raise Exception.Create('Not selected product');
    qryAddInvoiceLine.ParamByName('PRODUCT_ID').AsInteger := AProductId;
    qryAddInvoiceLine.ParamByName('QUANTITY').AsInteger := AQuantity;
    qryAddInvoiceLine.Execute();
    trWrite.Commit;
    qryInvoice.Refresh;
    qryInvoiceLine.Refresh;
  except
    on E: Exception do
    begin
      if trWrite.Active then
        trWrite.Rollback;
      raise;
    end;
  end;
end;

procedure TdmInvoice.EditInvoiceLine(AQuantity: Integer);
begin
  // We do everything in a short transaction
  trWrite.StartTransaction;
  try
    qryEditInvoiceLine.ParamByName('INVOICE_LINE_ID').AsInteger :=
      InvoiceLine.INVOICE_LINE_ID.Value;
    qryEditInvoiceLine.ParamByName('QUANTITY').AsInteger := AQuantity;
    qryEditInvoiceLine.Execute();
    trWrite.Commit;
    qryInvoice.Refresh;
    qryInvoiceLine.Refresh;
  except
    on E: Exception do
    begin
      if trWrite.Active then
        trWrite.Rollback;
      raise;
    end;
  end;
end;
----

[[fbdg30-firedac-proj-result]]
== The Result

[#delphi-project-result.text-center]
.Screenshot of the sample application
image::{docimagepath}/fbdevgd30_delphi_009.png[align="center",pdfwidth="100%",scaledwidth=502px]

[[fbdg30-firedac-conclusion]]
== Conclusion

FireDac(TM) is a standard set of data-access and data-aware visual components for developing with various database systems, including Firebird, starting from Delphi(TM) XE3.
FireDac(TM) ships with the higher-end versions of Delphi.
Many independent sets of data access and data-aware visual components are available for working with Firebird, some commercial, others distributed under a variety of licences, including open source  and freeware.
They include FibPlus, IBObjects, UIB, UniDAC, IBDac, Interbase Express (IBX) and more.
The principles for developing Firebird applications in Delphi(TM) are the same, regardless of the components you choose.

All queries to a database are executed within a transaction.
To guarantee that  applications will work correctly and efficiently with Firebird databases, it is advisable to manage transactions manually, by explicit calls to the `StartTransaction`, `Commit` and `Rollback` methods of the `TFDTransaction` component.
Transactions should be as short as possible and you can use as many as the logic of your application requires.

The recommended configuration for a long-running, read-only transaction to view datasets is to use `READ COMMITTED` isolation with `REC_VERSION` for conflict resolution.
An application can run many datasets in one such transaction or one for each dataset, according to the requirements of the design.

To avoid holding an uncommitted transaction during an editing session, either use visual components that are not data-aware or use the `CachedUpdates` mode.
With `CachedUpdates` you can restrict writes to short bursts of activity, keeping the read/write transaction active only for as long as it takes to post the most recent changes to the database.

The `TFDUpdateSQL` component is necessary for editing most datasets.
Update queries are governed by its `InsertSQL`, `ModifySQL`, `DeleteSQL` and `FetchRowSQL` properties.
The queries for those properties can be generated automatically by a wizard but manual corrections or adjustments are often required.

Acquiring values for auto-incrementing primary keys can be handled in one of two ways: 

* Getting the value from the generator beforehand by specifying the `UpdateOptions.GeneratorName` and  `UpdateOptions.AutoIncFields` properties for the `TFDQuery` component.
This method cannot be used for auto-incrementing fields of the `IDENTITY` type that was introduced in Firebird 3.
* Getting the value by adding a `RETURNING` clause to the `InsertSQL` query.
For this method you need to specify `Required=False` and `ReadOnly=True` for the field because the value is not entered directly.

It is convenient and sometimes necessary to implement more complex business logic with stored procedures.
Using the `TFDCommand` component to execute stored procedures that do not return data reduces resource consumption.

[[fbdevgd30-firedac-source-code]]
== Source Code

ObjectPascal source code for the sample project is available for download using the following link: https://www.firebirdsql.org/file/documentation/examples/en/fbdevgd30/FireDacEx.zip[FireDacEx.zip].

For links to the database scripts and ready-to-use databases, refer to the <<fbdevg30-db-run-script,final sections of the database chapter>>.
