[[fblangref25-psql]]
= Procedural SQL (PSQL) Statements

Procedural SQL (PSQL) is a procedural extension of SQL.
This language subset is used for writing stored procedures, triggers, and PSQL blocks.

PSQL provides all the basic constructs of traditional structured programming languages, and also includes DML statements (`SELECT`, `INSERT`, `UPDATE`, `DELETE`, etc.), with slight modifications to syntax in some cases.

[[fblangref25-psql-elements]]
== Elements of PSQL

A procedural extension may contain declarations of local variables and cursors, assignments, conditional statements, loops, statements for raising custom exceptions, error handling and sending messages (events) to client applications.
Triggers have access to special context variables, two arrays that store, respectively, the `NEW` values for all columns during insert and update activity, and the `OLD` values during update and delete work.

Statements that modify metadata (DDL) are not available in PSQL.

[[fblangref25-psql-elements-dml]]
=== DML Statements with Parameters

If DML statements (`SELECT`, `INSERT`, `UPDATE`, `DELETE`, etc.) in the body of the module (procedure, trigger or block) use parameters, only named parameters can be used and they must "`exist`" before the statements can use them.
They can be made available by being declared either as input or output parameters in the module's header or as local variables, in `DECLARE [VARIABLE]` statements at the bottom of the header.

When a DML statement with parameters is included in PSQL code, the parameter name must be prefixed by a colon ('```:```') in most situations.
The colon is optional in statement syntax that is specific to PSQL, such as assignments and conditionals.
The colon prefix on parameters is not required when calling stored procedures from within another PSQL module or in DSQL.

[[fblangref25-psql-elements-transacs]]
=== Transactions

Stored procedures are executed in the context of the transaction in which they are called.
Triggers are executed as an intrinsic part of the operation of the DML statement: thus, their execution is within the same transaction context as the statement itself.
Individual transactions are launched for database event triggers.

Statements that start and end transactions are not available in PSQL, but it is possible to run a statement or a block of statements in an autonomous transaction.

[[fblangref25-psql-elements-structure]]
=== Module Structure

PSQL code modules consist of a header and a body.
The DDL statements for defining them are __complex statements__;
that is, they consist of a single statement that encloses blocks of multiple statements.
These statements begin with a verb (`CREATE`, `ALTER`, `DROP`, `RECREATE`, `CREATE OR ALTER`) and end with the last `END` statement of the body.

[[fblangref25-psql-elements-header]]
==== The Module Header

The header provides the module name and defines any parameters and variables that are used in the body.
Stored procedures and PSQL blocks may have input and output parameters.
Triggers do not have either input or output parameters.

The header of a trigger indicates the database event (insert, update or delete, or a combination) and the phase of operation (`BEFORE` or `AFTER` that event) that will cause it to "`fire`".

[[fblangref25-psql-elements-body]]
==== The Module Body

The body of a PSQL module is a block of statements that run in a logical sequence, like a program.
A block of statements is contained within a `BEGIN` and an `END` statement.
The main `BEGIN...END` block may contain any number of other `BEGIN...END` blocks, both embedded and sequential.
All statements except `BEGIN` and `END` are terminated by semicolons ('```;```').
No other character is valid for use as a terminator for PSQL statements.

[[fblangref25-sidebar01]]
.Switching the Terminator in _isql_
****
Here we digress a little, to explain how to switch the terminator character in the _isql_ utility to make it possible to define PSQL modules in that environment without conflicting with _isql_ itself, which uses the same character, semicolon ('```;```'), as its own statement terminator.

[[fblangref25-psql-isql-setterm]]
[float]
==== isql Command `SET TERM`

.Used for
Changing the terminator character[s] to avoid conflict with the terminator character in PSQL statements

.Available in
ISQL only

.Syntax
[listing,subs=+quotes]
----
SET TERM _new_terminator_ _old_terminator_
----

[[fblangref25-psql-tbl-setterm]]
.`SET TERM` Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|new_terminator
|New terminator

|old_terminator
|Old terminator
|===

When you write your triggers and stored procedures in _isql_ -- either in the interactive interface or in scripts -- running a `SET TERM` statement is needed to switch the normal _isql_ statement terminator from the semicolon to some other character or short string, to avoid conflict with the non-changeable semicolon terminator in PSQL.
The switch to an alternative terminator needs to be done before you begin defining PSQL objects or running your scripts.

The alternative terminator can be any string of characters except for a space, an apostrophe or the current terminator character[s].
Any letter character[s] used will be case-sensitive.

.Example
Changing the default semicolon to '```^```' (caret) and using it to submit a stored procedure definition: character as an alternative terminator character:

[source]
----
SET TERM ^;

CREATE OR ALTER PROCEDURE SHIP_ORDER (
  PO_NUM CHAR(8))
AS
BEGIN
  /* Stored procedure body */
END^

/* Other stored procedures and triggers */

SET TERM ;^

/* Other DDL statements */
----
****

[[fblangref25-psql-storedprocs]]
== Stored Procedures

A stored procedure is a program stored in the database metadata for execution on the server.
A stored procedure can be called by stored procedures (including itself), triggers and client applications.
A procedure that calls itself is known as __recursive__.

[[fblangref25-psql-storedprocs-benefits]]
=== Benefits of Stored Procedures

Stored procedures have the following advantages: 

[horizontal]
Modularity:: applications working with the database can use the same stored procedure, thereby reducing the size of the application code and avoiding code duplication.

Simpler Application Support:: when a stored procedure is modified, changes appear immediately to all host applications, without the need to recompile them if the parameters were unchanged.

Enhanced Performance:: since stored procedures are executed on a server instead of at the client, network traffic is reduced, which improves performance.

[[fblangref25-psql-storedprocs-types]]
=== Types of Stored Procedures

Firebird supports two types of stored procedures: _executable_ and _selectable_.

[[fblangref25-psql-storedprocs-executable]]
==== Executable Procedures

Executable procedures usually modify data in a database.
They can receive input parameters and return a single set of output (`RETURNS`) parameters.
They are called using the `EXECUTE PROCEDURE` statement.
See <<create-procedure-examples,an example of an executable stored procedure>> at the end of the <<fblangref25-ddl-proc-create,`CREATE PROCEDURE` section>> of Chapter 5.

[[fblangref25-psql-storedprocs-selectable]]
==== Selectable Procedures

Selectable stored procedures usually retrieve data from a database, returning an arbitrary number of rows to the caller.
The caller receives the output one row at a time from a row buffer that the database engine prepares for it.

Selectable procedures can be useful for obtaining complex sets of data that are often impossible or too difficult or too slow to retrieve using regular DSQL `SELECT` queries.
Typically, this style of procedure iterates through a looping process of extracting data, perhaps transforming it before filling the output variables (parameters) with fresh data at each iteration of the loop.
A `SUSPEND` statement at the end of the iteration fills the buffer and waits for the caller to fetch the row.
Execution of the next iteration of the loop begins when the buffer has been cleared.

Selectable procedures may have input parameters and the output set is specified by the `RETURNS` clause in the header.

A selectable stored procedure is called with a SELECT statement.
See <<create-procedure-examples,an example of a selectable stored procedure>> at the end of the <<fblangref25-ddl-proc-create,`CREATE PROCEDURE` section>> of Chapter 5.

[[fblangref25-psql-storedprocs-creating]]
=== Creating a Stored Procedure

The syntax for creating executable stored procedures and selectable stored procedures is exactly the same.
The difference comes in the logic of the program code.

.Syntax (partial)
[listing,subs=+quotes]
----
CREATE PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

The header of a stored procedure must contain the procedure name, and it must be unique among the names of stored procedures, tables, and views.
It may also define some input and output parameters.
Input parameters are listed after the procedure name inside a pair of brackets.
Output parameters, which are mandatory for selectable procedures, are bracketed inside one `RETURNS` clause.

The final item in the header (or the first item in the body, depending on your opinion of where the border lies) is one or more declarations of any local variables and/or named cursors that your procedure might require.

Following the declarations is the main `BEGIN...END` block that delineates the procedure's PSQL code.
Within that block could be PSQL and DML statements, flow-of-control blocks, sequences of other `BEGIN...END` blocks, including embedded blocks.
Blocks, including the main block, may be empty and the procedure will still compile.
It is not unusual to develop a procedure in stages, from an outline.

.For more information about creating stored procedures
See <<fblangref25-ddl-proc-create,`CREATE PROCEDURE`>> in Chapter 5, [ref]_Data Definition (DDL) Statements_. 

[[fblangref25-psql-storedprocs-modifying]]
=== Modifying a Stored Procedure

An existing stored procedure can be altered, to change the sets of input and output parameters and anything in the procedure body.

.Syntax (partial)
[listing,subs=+quotes]
----
ALTER PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

.For more information about modifying stored procedures
See <<fblangref25-ddl-proc-alter,`ALTER PROCEDURE`>>, <<fblangref25-ddl-proc-crtoralter,`CREATE OR ALTER PROCEDURE`>>, <<fblangref25-ddl-proc-recreate,`RECREATE PROCEDURE`>>, in Chapter 5, [ref]_Data Definition (DDL) Statements_. 

[[fblangref25-psql-storedprocs-deleting]]
=== Deleting a Stored Procedure

The `DROP PROCEDURE` statement is used to delete stored procedures.

.Syntax (complete)
[source,subs=+quotes]
----
DROP PROCEDURE _procname_
----

.For more information about deleting stored procedures
See <<fblangref25-ddl-proc-drop,`DROP PROCEDURE`>> in Chapter 5, [ref]_Data Definition (DDL) Statements_.

[[fblangref25-psql-storedfuncs]]
== Stored Functions

Stored PSQL scalar functions are not supported in this version but they are coming in Firebird 3.
In Firebird 2.5 and below, you can instead write a selectable stored procedure that returns a scalar result and `SELECT` it from your DML query or subquery.

.Example
[source]
----
SELECT
  PSQL_FUNC(T.col1, T.col2) AS col3,
  col3
FROM T
----

can be replaced with:

[source]
----
SELECT
  (SELECT output_column FROM  PSQL_PROC(T.col1)) AS col3,
  col2
FROM T
----

or

[source]
----
SELECT
  output_column AS col3,
  col2,
FROM T
LEFT JOIN PSQL_PROC(T.col1)
----

[[fblangref25-psql-dynblocks]]
== PSQL Blocks

A self-contained, unnamed ("`anonymous`") block of PSQL code can be executed dynamically in DSQL, using the `EXECUTE BLOCK` syntax.
The header of an anonymous PSQL block may optionally contain input and output parameters.
The body may contain local variable and cursor declarations;
and a block of PSQL statements follows.

An anonymous PSQL block is not defined and stored as an object, unlike stored procedures and triggers.
It executes in run-time and cannot reference itself.

Just like stored procedures, anonymous PSQL blocks can be used to process data and to retrieve data from the database.

.Syntax (incomplete)
[listing]
----
EXECUTE BLOCK
  [(<inparam> = ? [, <inparam> = ? ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

[[fblangref25-psql-tbl-dynblock]]
.PSQL Block Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|inparam
|Input parameter description

|outparam
|Output parameter description

|declarations
|A section for declaring local variables and named cursors

|PSQL statements
|PSQL and DML statements
|===

.Read more
See <<fblangref25-dml-execblock,`EXECUTE BLOCK`>> for details. 

[[fblangref25-psql-triggers]]
== Triggers

A trigger is another form of executable code that is stored in the metadata of the database for execution by the server.
A trigger cannot be called directly.
It is called automatically ("`fired`") when data-changing events involving one particular table or view occur.

One trigger applies to exactly one table or view and only one _phase_ in an event (`BEFORE` or `AFTER` the event).
A single trigger might be written to fire only when one specific data-changing event occurs (`INSERT`, `UPDATE` or `DELETE`) or it might be written to apply to more than one of those.

A DML trigger is executed in the context of the transaction in which the data-changing DML statement is running.
For triggers that respond to database events, the rule is different: for some of them, a default transaction is started.

[[fblangref25-psql-firingorder]]
=== Firing Order (Order of Execution)

More than one trigger can be defined for each phase-event combination.
The order in which they are executed (known as "`firing order`" can be specified explicitly with the optional `POSITION` argument in the trigger definition.
You have 32,767 numbers to choose from.
Triggers with the lowest position numbers fire first.

If a `POSITION` clause is omitted, the position is `0`.
If multiple triggers have the same position and phase, those triggers will be executed in an undefined order, while respecting the total order by position and phase.

[[fblangref25-psql-dmltriggers]]
=== DML Triggers

DML triggers are those that fire when a DML operation changes the state of data: modifies rows in tables, inserts new rows or deletes rows.
They can be defined for both tables and views.

[[fblangref25-psql-triggeroptions]]
==== Trigger Options

Six base options are available for the event-phase combination for tables and views: 

[[fblangref25-psql-tbl-dmltriggers]]
[%autowidth,cols="<1,<1m", frame="none", grid="none", stripes="none"]
|===
|Before a new row is inserted
|BEFORE INSERT

|After a new row is inserted
|AFTER INSERT

|Before a row is updated
|BEFORE UPDATE

|After a row is updated
|AFTER UPDATE

|Before a row is deleted
|BEFORE DELETE

|After a row is deleted
|AFTER DELETE
|===

These base forms are for creating single phase/single-event triggers.
Firebird also supports forms for creating triggers for one phase and multiple-events, `BEFORE INSERT OR UPDATE OR DELETE`, for example, or `AFTER UPDATE OR DELETE`: the combinations are your choice.

[NOTE]
====
"`Multi-phase`" triggers, such as `BEFORE OR AFTER ...`, are not possible.
====

[[fblangref25-psql-oldnew]]
==== `OLD` and `NEW` Context Variables

For DML triggers, the Firebird engine provides access to sets of `OLD` and `NEW` context variables.
Each is an array of the values of the entire row: one for the values as they are before the data-changing event (the `BEFORE` phase) and one for the values as they will be after the event (the `AFTER` phase).
They are referenced in statements using the form `NEW.__column_name__` and `OLD.__column_name__`, respectively.
The _column_name_ can be any column in the table's definition, not just those that are being updated.

The `NEW` and `OLD` variables are subject to some rules:

* In all triggers, the `OLD` value is read-only
* In `BEFORE UPDATE` and `BEFORE INSERT` code, the `NEW` value is read/write, unless it is a `COMPUTED BY` column
* In `INSERT` triggers, references to the `OLD` variables are invalid and will throw an exception
* In `DELETE` triggers, references to the `NEW` variables are invalid and will throw an exception
* In all `AFTER` trigger code, the `NEW` variables are read-only

[[fblangref25-psql-dbtriggers]]
=== Database Triggers

A trigger associated with a database or transaction event can be defined for the following events: 

[[fblangref25-psql-tbl-dbtriggers]]
[%autowidth,cols="<4,<3m,<5", frame="none", grid="none", stripes="none"]
|===
|Connecting to a database
|ON CONNECT
|Before the trigger is executed, a default transaction is automatically started

|Disconnecting from a database
|ON DISCONNECT
|Before the trigger is executed, a default transaction is automatically started

|When a transaction is started
|ON TRANSACTION START
|The trigger is executed in the current transaction context

|When a transaction is committed
|ON TRANSACTION COMMIT
|The trigger is executed in the current transaction context

|When a transaction is cancelled
|ON TRANSACTION ROLLBACK
|The trigger is executed in the current transaction context
|===

[[fblangref25-psql-triggercreate]]
=== Creating Triggers

.Syntax
[listing,subs=+quotes]
----
CREATE TRIGGER _trigname_ {
    <relation_trigger_legacy>
  | <relation_trigger_sql2003>
  | <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<relation_trigger_legacy> ::=
  FOR {_tablename_ | _viewname_}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <mutation_list>
  [POSITION _number_]

<relation_trigger_sql2003> ::=
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <mutation_list>
  [POSITION _number_]
  ON {_tablename_ | _viewname_}

<database_trigger> ::=
  [ACTIVE | INACTIVE]
  ON <db_event>
  [POSITION _number_]

<mutation_list> ::=
  <mutation> [OR <mutation> [OR <mutation>]]

<mutation> ::= { INSERT | UPDATE | DELETE }

<db_event> ::=
    CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK
----

The header must contain a name for the trigger that is unique among trigger names.
It must include the event or events that will fire the trigger.
Also, for a DML trigger it is mandatory to specify the event phase and the name of the table or view that is to "`own`" the trigger.

The body of the trigger can be headed by the declarations of local variables and cursors, if any.
Within the enclosing main `BEGIN...END` wrapper will be one or more blocks of PSQL statements, which may be empty.

.For more information about creating triggers
See <<fblangref25-ddl-trgr-create,">``CREATE TRIGGER``>> in Chapter 5, [ref]_Data Definition (DDL) Statements_. 

[[fblangref25-psql-triggermodify]]
=== Modifying Triggers

Altering the status, phase, table or view event(s), firing position and code in the body of a DML trigger are all possible.
However, you cannot modify a DML trigger to convert it to a database trigger, nor vice versa.
Any element not specified is left unchanged by `ALTER TRIGGER`.
The alternative statements `CREATE OR ALTER TRIGGER` and `RECREATE TRIGGER` will replace the original trigger definition entirely.

.Syntax
[listing,subs=+quotes]
----
ALTER TRIGGER _trigname_
  [ACTIVE | INACTIVE]
  [{BEFORE | AFTER} <mutation_list> | ON <db_event>]
  [POSITION _number_]
  [
    AS
      [<declarations>]
    BEGIN
      [<PSQL_statements>]
    END
  ]

<mutation_list> ::=
  <mutation> [OR <mutation> [OR <mutation>]]

<mutation> ::= { INSERT | UPDATE | DELETE }

<db_event> ::=
  { CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK }
----

.For more information about modifying triggers
See <<fblangref25-ddl-trgr-alter,`ALTER TRIGGER`>>, <<fblangref25-ddl-trgr-crtalter,`CREATE OR ALTER TRIGGER`>>, <<fblangref25-ddl-trgr-recreate,`RECREATE TRIGGER`>> in Chapter 5, [ref]_Data Definition (DDL) Statements_. 

[[fblangref25-psql-triggerdelete]]
=== Deleting a Trigger

The `DROP TRIGGER` statement is used to delete  triggers.

.Syntax (complete)
[listing,subs=+quotes]
----
DROP TRIGGER _trigname_
----

.For more information about deleting triggers
See <<fblangref25-ddl-trgr-drop,`DROP TRIGGER`>> in Chapter 5, [ref]_Data Definition (DDL) Statements_.

[[fblangref25-psql-coding]]
== Writing the Body Code

This section takes a closer look at the procedural SQL language constructs and statements that are available for coding the body of a stored procedure, trigger or anonymous PSQL block.

[sidebar]
.Colon Marker ('```:```')
The colon marker prefix ('```:```') is used in PSQL to mark a reference to a variable in a DML statement.
The colon marker is not required before variable names in other code and it should never be applied to context variables.

[[fblangref25-psql-coding-assign]]
=== Assignment Statements

.Used for
Assigning a value to a variable

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
_varname_ = <value_expr>
----

[[fblangref25-psql-tbl-assign]]
.Assignment Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|varname
|Name of a parameter or local variable

|value_expr
|An expression, constant or variable whose value resolves to the same data type as _varname_
|===

PSQL uses the equivalence symbol ('```=```') as its assignment operator.
The assignment statement assigns an SQL expression value on the right to the variable on the left of the operator.
The expression can be any valid SQL expression: it may contain literals, internal variable names, arithmetic, logical and string operations, calls to internal functions or to external functions (UDFs).

.Example using assignment statements
[source]
----
CREATE PROCEDURE MYPROC (
  a INTEGER,
  b INTEGER,
  name VARCHAR (30)
)
RETURNS (
  c INTEGER,
  str VARCHAR(100))
AS
BEGIN
  -- assigning a constant
  c = 0;
  str = '';
  SUSPEND;
  -- assigning expression values
  c = a + b;
  str = name || CAST(b AS VARCHAR(10));
  SUSPEND;
  -- assigning expression value
  -- built by a query
  c = (SELECT 1 FROM rdb$database);
  -- assigning a value from a context variable
  str = CURRENT_USER;
  SUSPEND;
END
----

.See also
<<fblangref25-psql-declare-variable>>

[[fblangref25-psql-declare-cursor]]
=== `DECLARE CURSOR`

.Used for
Declaring a named cursor

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
DECLARE [VARIABLE] _cursorname_ CURSOR FOR (<select>) [FOR UPDATE]
----

[[fblangref25-psql-tbl-declare-cursor]]
.`DECLARE CURSOR` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|cursorname
|Cursor name

|select
|`SELECT` statement
|===

The `DECLARE CURSOR ... FOR` statement binds a named cursor to the result set obtained in the `SELECT` statement specified in the `FOR` clause.
In the body code, the cursor can be opened, used to walk row-by-row through the result set and closed.
While the cursor is open, the code can perform positioned updates and deletes using the `WHERE CURRENT OF` in the `UPDATE` or `DELETE` statement.

[[fblangref25-psql-idio-cursor]]
==== Cursor Idiosyncrasies

* The optional `FOR UPDATE` clause can be included in the SELECT statement but its absence does not prevent successful execution of a positioned update or delete
* Care should be taken to ensure that the names of declared cursors do not conflict with any names used subsequently in statements for `AS CURSOR` clauses
* If the cursor is needed only to walk the result set, it is nearly always easier and less error-prone to use a `FOR SELECT` statement with the `AS CURSOR` clause.
Declared cursors must be explicitly opened, used to fetch data and closed.
The context variable `ROW_COUNT` has to be checked after each fetch and, if its value is zero, the loop has to be terminated.
A `FOR SELECT` statement checks it automatically.
+ 
Nevertheless, declared cursors provide a high level of control over sequential events and allow several cursors to be managed in parallel.
* The `SELECT` statement may contain parameters. For instance:
+
[source]
----
SELECT NAME || :SFX FROM NAMES WHERE NUMBER = :NUM
----
+
Each parameter has to have been declared beforehand as a PSQL variable, even if they originate as input and output parameters.
When the cursor is opened, the parameter is assigned the current value of the variable.

.Attention!
[WARNING]
====
If the value of a PSQL variable used in the `SELECT` statement changes during the loop, its new value may (but not always) be used for the remaining rows.
It is better to avoid having such situations arise unintentionally.
If you really need this behaviour, you should test your code carefully to be certain that you know exactly how changes in the variable affect the result.

Note particularly that the behaviour may depend on the query plan, specifically on the indexes being used.
No strict rules are in place for situations like this currently, but that could change in future versions of Firebird.
====

[[fblangref25-psql-cursor-examples]]
==== Examples Using Named Cursors

. Declaring a named cursor in the trigger.
+
[source]
----
CREATE OR ALTER TRIGGER TBU_STOCK
  BEFORE UPDATE ON STOCK
AS
  DECLARE C_COUNTRY CURSOR FOR (
    SELECT
      COUNTRY,
      CAPITAL
    FROM COUNTRY
  );
BEGIN
  /* PSQL statements */
END
----
. A collection of scripts for creating views with a PSQL block using named cursors.
+
[source]
----
EXECUTE BLOCK
RETURNS (
  SCRIPT BLOB SUB_TYPE TEXT)
AS
  DECLARE VARIABLE FIELDS VARCHAR(8191);
  DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
  DECLARE VARIABLE RELATION RDB$RELATION_NAME;
  DECLARE VARIABLE SOURCE TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
  DECLARE VARIABLE CUR_R CURSOR FOR (
    SELECT
      RDB$RELATION_NAME,
      RDB$VIEW_SOURCE
    FROM
      RDB$RELATIONS
    WHERE
      RDB$VIEW_SOURCE IS NOT NULL);
-- Declaring a named cursor where
-- a local variable is used
  DECLARE CUR_F CURSOR FOR (
    SELECT
      RDB$FIELD_NAME
    FROM
      RDB$RELATION_FIELDS
    WHERE
      -- It is important that the variable must be declared earlier
      RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SOURCE;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
    -- The CUR_F cursor will use the value
    -- of the RELATION variable initiated above
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SOURCE;

    SUSPEND;
  END
  CLOSE CUR_R;
END
----

.See also
<<fblangref25-psql-open>>, <<fblangref25-psql-fetch>>, <<fblangref25-psql-close>>

[[fblangref25-psql-declare-variable]]
=== `DECLARE VARIABLE`

.Used for
Declaring a local variable

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
DECLARE [VARIABLE] _varname_
  {<datatype> | _domain_ | TYPE OF {_domain_ | COLUMN _rel_._col_}
    [NOT NULL]  [CHARACTER SET _charset_] [COLLATE _collation_]
    [{DEFAULT | = } <initvalue>];

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<initvalue> ::= <literal> | <context_var>
----

[[fblangref25-psql-tbl-declare-variable]]
.`DECLARE VARIABLE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|varname
|Name of the local variable

|datatype
|An SQL data type

|domain
|The name of an existing domain in this database

|rel.col
|Relation name (table or view) in this database and the name of a column in that relation

|precision
|Precision.
From 1 to 18

|scale
|Scale.
From 0 to 18, it must be less than or equal to precision

|size
|The maximum size of a string in characters

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size, not greater than 65,535

|initvalue
|Initial value for this variable

|literal
|Literal of a type compatible with the type of the local variable

|context_var
|Any context variable whose type is compatible with the type of the local variable

|charset
|Character set

|collation
|Collation sequence
|===

The statement `DECLARE [VARIABLE]` is used for declaring a local variable.
The keyword `VARIABLE` can be omitted.
One `DECLARE [VARIABLE]` statement is required for each local variable.
Any number of `DECLARE [VARIABLE]` statements can be included and in any order.
The name of a local variable must be unique among the names of local variables and input and output parameters declared for the module.

[[fblangref25-psql-variable-type]]
==== Data Type for Variables

A local variable can be of any SQL type other than an array. 

* A domain name can be specified as the type and the variable will inherit all of its attributes.
* If the `TYPE OF __domain__` clause is used instead, the variable will inherit only the domain's data type, and, if applicable, its character set and collation attributes.
Any default value or constraints such as `NOT NULL` or `CHECK` constraints are not inherited.
* If the `TYPE OF COLUMN __relation__.__column__>` option is used to "`borrow`" from a column in a table or view, the variable will inherit only the column's data type, and, if applicable, its character set and collation attributes.
Any other attributes are ignored.

[[fblangref25-psql-variable-notnull]]
==== `NOT NULL` Constraint

The variable can be constrained `NOT NULL` if required.
If a domain has been specified as the data type and already carries the `NOT NULL` constraint, it will not be necessary.
With the other forms, including use of a domain that is nullable, the `NOT NULL` attribute should be included if needed.

[[fblangref25-psql-variable-charsetcollate]]
==== `CHARACTER SET` and `COLLATE` clauses

Unless specified, the character set and collation sequence of a string variable will be the database defaults.
A `CHARACTER SET` clause can be included, if required, to handle string data that is going to be in a different character set.
A valid collation sequence (`COLLATE` clause) can also be included, with or without the character set clause.

==== Initializing a Variable

Local variables are `NULL` when execution of the module begins.
They can be initialized so that a starting or default value is available when they are first referenced.
The `DEFAULT <initvalue>` form can be used, or just the assignment operator, '```=```': `= <initvalue>`.
The value can be any type-compatible literal or context variable.

[IMPORTANT]
====
Be sure to use this clause for any variables that are constrained to be `NOT NULL` and do not otherwise have a default value available.
====

==== Examples of various ways to declare local variables

[source]
----
CREATE OR ALTER PROCEDURE SOME_PROC
AS
  -- Declaring a variable of the INT type
  DECLARE I INT;
  -- Declaring a variable of the INT type that does not allow NULL
  DECLARE VARIABLE J INT NOT NULL;
  -- Declaring a variable of the INT type with the default value of 0
  DECLARE VARIABLE K INT DEFAULT 0;
  -- Declaring a variable of the INT type with the default value of 1
  DECLARE VARIABLE L INT = 1;
  -- Declaring a variable based on the COUNTRYNAME domain
  DECLARE FARM_COUNTRY COUNTRYNAME;
  -- Declaring a variable of the type equal to the COUNTRYNAME domain
  DECLARE FROM_COUNTRY TYPE OF COUNTRYNAME;
  -- Declaring a variable with the type of the CAPITAL column in the COUNTRY table
  DECLARE CAPITAL TYPE OF COLUMN COUNTRY.CAPITAL;
BEGIN
  /* PSQL statements */
END
----

.See also
<<fblangref25-datatypes,Data Types and Subtypes>>, <<fblangref25-datatypes-custom,Custom Data Types -- Domains>>, <<fblangref25-ddl-domn,`CREATE DOMAIN`>>

[[fblangref25-psql-beginend]]
=== `BEGIN ... END`

.Used for
Delineating a block of statements

.Available in
PSQL

.Syntax
[listing,subs="+quotes,macros"]
----
<block> ::=
  BEGIN
    [<compound_statement> ...]
    [<when_do> ...]
  END

<compound_statement> ::= {<block> | <statement>}

<when_do> ::=
  !! See <<fblangref25-psql-when,WHEN ... DO>> !!
----

The `BEGIN ... END` construct is a two-part statement that wraps a block of statements that are executed as one unit of code.
Each block starts with the half-statement `BEGIN` and ends with the other half-statement `END`.
Blocks can be nested to unlimited depth.
They may be empty, allowing them to act as stubs, without the need to write dummy statements.

For <<fblangref25-psql-handleexceptions,error handling>>, you can add one or more <<fblangref25-psql-when>> statements immediately before `END`.
Other statements are not allowed after `WHEN ... DO`.

The `BEGIN ... END` itself should not be followed by a statement terminator (semicolon).
However, when defining or altering a PSQL module in the _isql_ utility, that application requires that the last `END` statement be followed by its own terminator character, that was previously switched, using `SET TERM`, to some string other than a semicolon.
That terminator is not part of the PSQL syntax.

The final, or outermost, `END` statement in a trigger terminates the trigger.
What the final `END` statement does in a stored procedure depends on the type of procedure: 

* In a selectable procedure, the final `END` statement returns control to the caller, returning SQLCODE 100, indicating that there are no more rows to retrieve
* In an executable procedure, the final `END` statement returns control to the caller, along with the current values of any output parameters defined.

.Example
A sample procedure from the `employee.fdb` database, showing simple usage of `BEGIN...END` blocks:

[source]
----
SET TERM ^;
CREATE OR ALTER PROCEDURE DEPT_BUDGET (
  DNO CHAR(3))
RETURNS (
  TOT DECIMAL(12,2))
AS
  DECLARE VARIABLE SUMB DECIMAL(12,2);
  DECLARE VARIABLE RDNO CHAR(3);
  DECLARE VARIABLE CNT  INTEGER;
BEGIN
  TOT = 0;

  SELECT
    BUDGET
  FROM
    DEPARTMENT
  WHERE DEPT_NO = :DNO
  INTO :TOT;

  SELECT
    COUNT(BUDGET)
  FROM
    DEPARTMENT
  WHERE HEAD_DEPT = :DNO
  INTO :CNT;

  IF (CNT = 0) THEN
    SUSPEND;

  FOR
    SELECT
      DEPT_NO
    FROM
      DEPARTMENT
    WHERE HEAD_DEPT = :DNO
    INTO :RDNO
  DO
  BEGIN
    EXECUTE PROCEDURE DEPT_BUDGET(:RDNO)
    RETURNING_VALUES :SUMB;
    TOT = TOT + SUMB;
  END

  SUSPEND;
END^
SET TERM ;^
----

.See also
<<fblangref25-psql-exit>>, <<fblangref25-psql-leave>>, <<fblangref25-sidebar01,`SET TERM`>>, <<fblangref25-psql-when>>

[[fblangref25-psql-ifthen]]
=== `IF ... THEN ... ELSE`

.Used for
Conditional jumps

.Available in
PSQL

.Syntax
[listing]
----
IF (<condition>)
  THEN <compound_statement>
  [ELSE <compound_statement>]
----

[[fblangref25-psql-tbl-ifthen]]
.`IF ... THEN ... ELSE` Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|condition
|A logical condition returning TRUE, FALSE or UNKNOWN

|single_statement
|A single statement terminated with a semicolon

|compound_statement
|Two or more statements wrapped in `BEGIN ... END`
|===

The conditional jump statement `IF ... THEN` is used to branch the execution process in a PSQL module.
The condition is always enclosed in parentheses.
If it returns the value TRUE, execution branches to the statement or the block of statements after the keyword `THEN`.
If an `ELSE` is present and the condition returns FALSE or UNKNOWN, execution branches to the statement or the block of statements after it.

[[multijump]]
.Multi-branch Jumps
****
PSQL does not provide multi-branch jumps, such as `CASE` or `SWITCH`.
Nevertheless, the `CASE` search statement from DSQL is available in PSQL and is able to satisfy at least some use cases in the manner of a switch:

[listing]
----
CASE <test_expr>
  WHEN <expr> THEN <result>
  [WHEN <expr> THEN <result> ...]
  [ELSE <defaultresult>]
END

CASE
  WHEN <bool_expr> THEN <result>
  [WHEN <bool_expr> THEN <result> ...]
  [ELSE <defaultresult>]
END
----

.Example in PSQL
[source]
----
...
C = CASE
      WHEN A=2 THEN 1
      WHEN A=1 THEN 3
      ELSE 0
    END;
...
----
****

.Example
An example using the `IF` statement.
Assume that the `FIRST`, `LINE2` and `LAST` variables were declared earlier.

[source]
----
...
IF (FIRST IS NOT NULL) THEN
  LINE2 = FIRST || ' ' || LAST;
ELSE
  LINE2 = LAST;
...
----

.See also
<<fblangref25-psql-while>>, <<fblangref25-commons-conditional-case,`CASE`>>

[[fblangref25-psql-while]]
=== `WHILE ... DO`

.Used for
Looping constructs

.Available in
PSQL

.Syntax
[listing]
----
WHILE <condition> DO
  <compound_statement>
----

[[fblangref25-psql-tbl-while]]
.`WHILE ... DO` Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|condition
|A logical condition returning TRUE, FALSE or UNKNOWN

|single_statement
|A single statement terminated with a semicolon

|compound_statement
|Two or more statements wrapped in `BEGIN ... END`
|===

A `WHILE` statement implements the looping construct in PSQL.
The statement or the block of statements will be executed until the condition returns TRUE.
Loops can be nested to any depth.

.Example
A procedure calculating the sum of numbers from 1 to I shows how the looping construct is used.

[source]
----
CREATE PROCEDURE SUM_INT (I INTEGER)
RETURNS (S INTEGER)
AS
BEGIN
  s = 0;
  WHILE (i > 0) DO
  BEGIN
    s = s + i;
    i = i - 1;
  END
END
----

Executing the procedure in __isql__:

[source]
----
EXECUTE PROCEDURE SUM_INT(4);
----

the result is:

[source]
----
S
==========
10
----

.See also
<<fblangref25-psql-ifthen>>, <<fblangref25-psql-leave>>, <<fblangref25-psql-exit>>, <<fblangref25-psql-forselect>>, <<fblangref25-psql-forexec>>

[[fblangref25-psql-leave]]
=== `LEAVE`

.Used for
Terminating a loop

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
[_label_:]
<loop_stmt>
BEGIN
  ...
  LEAVE [_label_];
  ...
END

<loop_stmt> ::=
    FOR <select_stmt> INTO <var_list> DO
  | FOR EXECUTE STATEMENT ... INTO <var_list> DO
  | WHILE (<condition>)} DO
----

[[fblangref25-psql-tbl-leave]]
.`LEAVE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|label
|Label

|select_stmt
|`SELECT` statement

|condition
|A logical condition returning TRUE, FALSE or UNKNOWN
|===

A `LEAVE` statement immediately terminates the inner loop of a `WHILE` or `FOR` looping statement.
The _label_ parameter is optional.

`LEAVE` can cause an exit from outer loops as well.
Code continues to be executed from the first statement after the termination of the outer loop block.

.Examples
. Leaving a loop if an error occurs on an insert into the `NUMBERS` table.
The code continues to be executed from the line `C = 0`.
+
[source]
----
...
WHILE (B < 10) DO
BEGIN
  INSERT INTO NUMBERS(B)
  VALUES (:B);
  B = B + 1;
  WHEN ANY DO
  BEGIN
    EXECUTE PROCEDURE LOG_ERROR (
      CURRENT_TIMESTAMP,
      'ERROR IN B LOOP');
    LEAVE;
  END
END
C = 0;
...
----
. An example using labels in the `LEAVE` statement.
`LEAVE LOOPA` terminates the outer loop and `LEAVE LOOPB` terminates the inner loop.
Note that the plain `LEAVE` statement would be enough to terminate the inner loop.
+
[source]
----
...
STMT1 = 'SELECT NAME FROM FARMS';
LOOPA:
FOR EXECUTE STATEMENT :STMT1
INTO :FARM DO
BEGIN
  STMT2 = 'SELECT NAME ' || 'FROM ANIMALS WHERE FARM = ''';
  LOOPB:
  FOR EXECUTE STATEMENT :STMT2 || :FARM || ''''
  INTO :ANIMAL DO
  BEGIN
    IF (ANIMAL = 'FLUFFY') THEN
      LEAVE LOOPB;
    ELSE IF (ANIMAL = FARM) THEN
      LEAVE LOOPA;
    ELSE
      SUSPEND;
  END
END
...
----

.See also
<<fblangref25-psql-exit>>

[[fblangref25-psql-exit]]
=== `EXIT`

.Used for
Terminating module execution

.Available in
PSQL

.Syntax
[listing]
----
EXIT
----

The `EXIT` statement causes execution of the procedure or trigger to jump to the final `END` statement from any point in the code, thus terminating the program.

.Example
Using the `EXIT` statement in a selectable procedure:

[source]
----
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END
----

.See also
<<fblangref25-psql-leave>>, <<fblangref25-psql-suspend>>

[[fblangref25-psql-suspend]]
=== `SUSPEND`

.Used for
Passing output to the buffer and suspending execution while waiting for caller to fetch it

.Available in
PSQL

.Syntax
[listing]
----
SUSPEND
----

The `SUSPEND` statement is used in a selectable stored procedure to pass the values of output parameters to a buffer and suspend execution.
Execution remains suspended until the calling application fetches the contents of the buffer.
Execution resumes from the statement directly after the `SUSPEND` statement.
In practice, this is likely to be a new iteration of a looping process. 

.Important Notes
[IMPORTANT]
====
. Applications using interfaces that wrap the API perform the fetches from selectable procedures transparently.
. When a `SUSPEND` statement is executed in an executable stored procedure, it is the same as executing the `EXIT` statement, resulting in immediate termination of the procedure.
. `SUSPEND`"`breaks`" the atomicity of the block in which it is located.
If an error occurs in a selectable procedure, statements executed after the final `SUSPEND` statement will be rolled back.
Statements that executed before the final `SUSPEND` statement will not be rolled back unless the transaction is rolled back.
====

.Example
Using the `SUSPEND` statement in a selectable procedure:

[source]
----
CREATE PROCEDURE GEN_100
RETURNS (
  I INTEGER
)
AS
BEGIN
  I = 1;
  WHILE (1=1) DO
  BEGIN
    SUSPEND;
    IF (I=100) THEN
      EXIT;
    I = I + 1;
  END
END
----

.See also
<<fblangref25-psql-exit>>

[[fblangref25-psql-execstmt]]
=== `EXECUTE STATEMENT`

.Used for
Executing dynamically created SQL statements

.Available in
PSQL

.Syntax
[listing,subs="+quotes,attributes"]
----
<execute_statement> ::= EXECUTE STATEMENT <argument>
  [<option> …]
  [INTO <variables>]

<argument> ::= <paramless_stmt>
            | (<paramless_stmt>)
            | (<stmt_with_params>) (<param_values>)

<param_values> ::= <named_values> | <positional_values>

<named_values> ::= _paramname_ := <value_expr>
   [, _paramname_ := <value_expr> ...]

<positional_values> ::= <value_expr> [, <value_expr> ...]

<option> ::= WITH {AUTONOMOUS | COMMON} TRANSACTION
           | WITH CALLER PRIVILEGES
           | AS USER _user_
           | PASSWORD _password_
           | ROLE _role_
           | ON EXTERNAL [DATA SOURCE] <connect_string>

<connect_string> ::= [<hostspec>] {_filepath_ | _db_alias_}

<hostspec> ::= <tcpip_hostspec> | <NamedPipes_hostspec>

<tcpip_hostspec> ::= _hostname_[/_port_]:

<NamePipes_hostspec> ::= {backslash}{backslash}__hostname__\

<variables> ::= [:{endsb}__varname__ [, [:{endsb}__varname__ ...]
----

[[fblangref25-psql-tbl-execstmt]]
.`EXECUTE STATEMENT` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|paramless_stmt
|Literal string or variable containing a non-parameterized SQL query

|stmt_with_params
|Literal string or variable containing a parameterized SQL query

|paramname
|SQL query parameter name

|value_expr
|SQL expression resolving to a value

|user
|User name.
It can be a string, `CURRENT_USER` or a string variable

|password
|Password.
It can be a string or a string variable

|role
|Role.
It can be a string, `CURRENT_ROLE` or a string variable

|connection_string
|Connection string.
It can be a string or a string variable

|filepath
|Path to the primary database file

|db_alias
|Database alias

|hostname
|Computer name or IP address

|varname
|Variable
|===

The statement `EXECUTE STATEMENT` takes a string parameter and executes it as if it were a DSQL statement.
If the statement returns data, it can be passed to local variables by way of an `INTO` clause.

[[fblangref25-psql-execstmt-wparams]]
==== Parameterized Statements

You can use parameters -- either named or positional -- in the DSQL statement string.
Each parameter must be assigned a value.

[[fblangref25-psql-execstmt-wparams01]]
===== Special Rules for Parameterized Statements

. Named and positional parameters cannot be mixed in one query
. If the statement has parameters, they must be enclosed in parentheses when `EXECUTE STATEMENT` is called, regardless of whether they come directly as strings, as variable names or as expressions
. Each named parameter must be prefixed by a colon ('```:```') in the statement string itself, but not when the parameter is assigned a value
. Positional parameters must be assigned their values in the same order as they appear in the query text
. The assignment operator for parameters is the special operator "```:=```", similar to the assignment operator in Pascal
. Each named parameter can be used in the statement more than once, but its value must be assigned only once
. With positional parameters, the number of assigned values must match the number of parameter placeholders (question marks) in the statement exactly
. A named parameter in the statement text can only be a regular identifier (it cannot be a quoted identifier)

===== Examples of `EXECUTE STATEMENT` with parameters

With named parameters:

[source]
----
...
DECLARE license_num VARCHAR(15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = :driver AND location = :loc';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  INTO connect_string;
  ...
  FOR
    SELECT id
    FROM drivers
    INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
        (driver := current_driver,
         loc := current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...
----

The same code with positional parameters:

[source]
----
DECLARE license_num VARCHAR (15);
DECLARE connect_string VARCHAR (100);
DECLARE stmt VARCHAR (100) =
  'SELECT license
   FROM cars
   WHERE driver = ? AND location = ?';
BEGIN
  ...
  SELECT connstr
  FROM databases
  WHERE cust_id = :id
  into connect_string;
  ...
  FOR
    SELECT id
    FROM drivers
    INTO current_driver
  DO
  BEGIN
    FOR
      SELECT location
      FROM driver_locations
      WHERE driver_id = :current_driver
      INTO current_location
    DO
    BEGIN
      ...
      EXECUTE STATEMENT (stmt)
        (current_driver, current_location)
      ON EXTERNAL connect_string
      INTO license_num;
      ...
----

[[fblangref25-psql-execstmt-wautonomous]]
==== `WITH {AUTONOMOUS | COMMON} TRANSACTION`

Traditionally, the executed SQL statement always ran within the current transaction, and this is still the default.
`WITH AUTONOMOUS TRANSACTION` causes a separate transaction to be started, with the same parameters as the current transaction.
It will be committed if the statement runs to completion without errors and rolled back otherwise.
`WITH COMMON TRANSACTION` uses the current transaction if possible.

If the statement must run in a separate connection, an already started transaction within that connection is used, if available.
Otherwise, a new transaction is started with the same parameters as the current transaction.
Any new transactions started under the "```COMMON```" regime are committed or rolled back with the current transaction.

[[fblangref25-psql-execstmt-wcaller]]
==== `WITH CALLER PRIVILEGES`

By default, the SQL statement is executed with the privileges of the current user.
Specifying `WITH CALLER PRIVILEGES` adds to this the privileges of the calling procedure or trigger, just as if the statement were executed directly by the routine.
`WITH CALLER PRIVILEGES` has no effect if the `ON EXTERNAL` clause is also present.

[[fblangref25-psql-execstmt-onexternal]]
==== `ON EXTERNAL [DATA SOURCE]`

With `ON EXTERNAL [DATA SOURCE]`, the SQL statement is executed in a separate connection to the same or another database, possibly even on another server.
If the connect string is NULL or "```''```" (empty string), the entire `ON EXTERNAL [DATA SOURCE]` clause is considered absent and the statement is executed against the current database.

[[fblangref25-psql-execstmt-onext-connpool]]
===== Connection Pooling

* External connections made by statements `WITH COMMON TRANSACTION` (the default) will remain open until the current transaction ends.
They can be reused by subsequent calls to `EXECUTE STATEMENT`, but only if the connect string is exactly the same, including case
* External connections made by statements `WITH AUTONOMOUS TRANSACTION` are closed as soon as the statement has been executed
* Notice that statements `WITH AUTONOMOUS TRANSACTION` can and will re-use connections that were opened earlier by statements `WITH COMMON TRANSACTION`.
If this happens, the reused connection will be left open after the statement has been executed.
(It must be, because it has at least one un-committed transaction!)

[[fblangref25-psql-execstmt-onext-transpool]]
===== Transaction Pooling

* If `WITH COMMON TRANSACTION` is in effect, transactions will be reused as much as possible.
They will be committed or rolled back together with the current transaction
* If `WITH AUTONOMOUS TRANSACTION` is specified, a fresh transaction will always be started for the statement.
This transaction will be committed or rolled back immediately after the statement's execution

[[fblangref25-psql-execstmt-onext-errhandling]]
===== Exception Handling

When `ON EXTERNAL` is used, the extra connection is always made via a so-called external provider, even if the connection is to the current database.
One of the consequences is that exceptions cannot be caught in the usual way.
Every exception caused by the statement is wrapped in either an `eds_connection` or an `eds_statement` error.
In order to catch them in your PSQL code, you have to use `WHEN GDSCODE eds_connection`, `WHEN GDSCODE eds_statement` or `WHEN ANY`.

[NOTE]
====
Without `ON EXTERNAL`, exceptions are caught in the usual way, even if an extra connection is made to the current database.
====

[[fblangref25-psql-execstmt-onext-morenotes]]
===== Miscellaneous Notes

* The character set used for the external connection is the same as that for the current connection
* Two-phase commits are not supported

[[fblangref25-psql-execstmt-asuser]]
==== `AS USER`, `PASSWORD` and `ROLE`

The optional `AS USER`, `PASSWORD` and `ROLE` clauses allow specificaton of which user will execute the SQL statement and with which role.
The method of user log-in and whether a separate connection is open depend on the presence and values of the `ON EXTERNAL [DATA SOURCE]`, `AS USER`, `PASSWORD` and `ROLE` clauses:

* If `ON EXTERNAL` is present, a new connection is always opened, and:
** If at least one of `AS USER`, `PASSWORD` and `ROLE` is present, native authentication is attempted with the given parameter values (locally or remotely, depending on the connect string).
No defaults are used for missing parameters
** If all three are absent and the connect string contains no hostname, then the new connection is established on the local host with the same user and role as the current connection.
The term 'local' means "`on the same machine as the server`" here.
This is not necessarily the location of the client
** If all three are absent and the connect string contains a hostname, then trusted authentication is attempted on the remote host (again, 'remote' from the perspective of the server).
If this succeeds, the remote operating system will provide the user name (usually the operating system account under which the Firebird process runs)
* If `ON EXTERNAL` is absent:
** If at least one of `AS USER`, `PASSWORD` and `ROLE` is present, a new connection to the current database is opened with the suppled parameter values.
No defaults are used for missing parameters
** If all three are absent, the statement is executed within the current connection

.Notice
[NOTE]
====
If a parameter value is NULL or "```''```" (empty string), the entire parameter is considered absent.
Additionally, `AS USER` is considered absent if its value is equal to `CURRENT_USER`, and `ROLE` if it is the same as `CURRENT_ROLE`.
====

[[fblangref25-psql-execstmt-caveats]]
==== Caveats with `EXECUTE STATEMENT`

. There is no way to validate the syntax of the enclosed statement
. There are no dependency checks to discover whether tables or columns have been dropped
. Even though the performance in loops has been significantly improved in Firebird 2.5, execution is still considerably slower than when the same statements are launched directly
. Return values are strictly checked for data type in order to avoid unpredictable type-casting exceptions.
For example, the string `'1234'` would convert to an integer, 1234, but `'abc'` would give a conversion error

All in all, this feature is meant to be used very cautiously and you should always take the caveats into account.
If you can achieve the same result with PSQL and/or DSQL, it will almost always be preferable.

.See also
<<fblangref25-psql-forexec>>

[[fblangref25-psql-forselect]]
=== `FOR SELECT`

.Used for
Looping row-by-row through a selected result set

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
FOR <select_stmt> [AS CURSOR _cursorname_]
  DO <compound_statement>
----

[[fblangref25-psql-tbl-forselect]]
.`FOR SELECT` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|select_stmt
|`SELECT` statement

|cursorname
|Cursor name.
It must be unique among cursor names in the PSQL module (stored procedure, trigger or PSQL block)

|single_statement
|A single statement, terminated with a colon, that performs all the processing for this `FOR` loop

|compound_statement
|A block of statements wrapped in `BEGIN...END`, that performs all the processing for this `FOR` loop
|===

A `FOR SELECT` statement

* retrieves each row sequentially from the result set and executes the statement or block of statements on the row.
In each iteration of the loop, the field values of the current row are copied into pre-declared variables.
+ 
Including the `AS CURSOR` clause enables positioned deletes and updates to be performed -- see notes below
* can embed other `FOR SELECT` statements
* can carry named parameters that must be previously declared in the `DECLARE VARIABLE` statement or exist as input or output parameters of the procedure
* requires an `INTO` clause that is located at the end of the `SELECT ... FROM ...` specification.
In each iteration of the loop, the field values in the current row are copied to the list of variables specified in the `INTO` clause.
The loop repeats until all rows are retrieved, after which it terminates
* can be terminated before all rows are retrieved by using a `LEAVE statement`

[[fblangref25-psql-undeclaredcursor]]
==== The Undeclared Cursor

The optional `AS CURSOR` clause surfaces the set in the `FOR SELECT` structure as an undeclared, named cursor that can be operated on using the `WHERE CURRENT OF` clause inside the statement or block following the `DO` command, in order to delete or update the current row before execution moves to the next iteration.

Other points to take into account regarding undeclared cursors: 

. the `OPEN`, `FETCH` and `CLOSE` statements cannot be applied to a cursor surfaced by the `AS CURSOR` clause
. the cursor name argument associated with an `AS CURSOR` clause must not clash with any names created by `DECLARE VARIABLE` or `DECLARE CURSOR` statements at the top of the body code, nor with any other cursors surfaced by an `AS CURSOR` clause
. The optional `FOR UPDATE` clause in the `SELECT` statement is not required for a positioned update

==== Examples using `FOR SELECT`

. A simple loop through query results:
+
[source]
----
CREATE PROCEDURE SHOWNUMS
RETURNS (
  AA INTEGER,
  BB INTEGER,
  SM INTEGER,
  DF INTEGER)
AS
BEGIN
  FOR SELECT DISTINCT A, B
      FROM NUMBERS
    ORDER BY A, B
    INTO AA, BB
  DO
  BEGIN
    SM = AA + BB;
    DF = AA - BB;
    SUSPEND;
  END
END
----
. Nested `FOR SELECT` loop:
+
[source]
----
CREATE PROCEDURE RELFIELDS
RETURNS (
  RELATION CHAR(32),
  POS INTEGER,
  FIELD CHAR(32))
AS
BEGIN
  FOR SELECT RDB$RELATION_NAME
      FROM RDB$RELATIONS
      ORDER BY 1
      INTO :RELATION
  DO
  BEGIN
    FOR SELECT
          RDB$FIELD_POSITION + 1,
          RDB$FIELD_NAME
        FROM RDB$RELATION_FIELDS
        WHERE
          RDB$RELATION_NAME = :RELATION
        ORDER BY RDB$FIELD_POSITION
        INTO :POS, :FIELD
    DO
    BEGIN
      IF (POS = 2) THEN
        RELATION = ' "';

      SUSPEND;
    END
  END
END
----
. Using the `AS CURSOR` clause to surface a cursor for the positioned delete of a record:
+
[source]
----
CREATE PROCEDURE DELTOWN (
  TOWNTODELETE VARCHAR(24))
RETURNS (
  TOWN VARCHAR(24),
  POP INTEGER)
AS
BEGIN
  FOR SELECT TOWN, POP
      FROM TOWNS
      INTO :TOWN, :POP AS CURSOR TCUR
  DO
  BEGIN
    IF (:TOWN = :TOWNTODELETE) THEN
      -- Positional delete
      DELETE FROM TOWNS
      WHERE CURRENT OF TCUR;
    ELSE
      SUSPEND;
  END
END
----

.See also
<<fblangref25-psql-declare-cursor>>, <<fblangref25-psql-leave>>, <<fblangref25-dml-select,`SELECT`>>, <<fblangref25-dml-update,`UPDATE`>>, <<fblangref25-dml-delete,`DELETE`>>

[[fblangref25-psql-forexec]]
=== `FOR EXECUTE STATEMENT`

.Used for
Executing dynamically created SQL statements that return a row set

.Available in
PSQL

.Syntax
[listing]
----
FOR <execute_statement> DO <compound_statement>
----

[[fblangref25-psql-tbl-forexec]]
.`FOR EXECUTE STATEMENT` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|execute_stmt
|An `EXECUTE STATEMENT` statement

|single_statement
|A single statement, terminated with a colon, that performs all the processing for this `FOR` loop

|compound_statement
|A block of statements wrapped in `BEGIN...END`, that performs all the processing for this `FOR` loop
|===

The statement `FOR EXECUTE STATEMENT` is used, in a manner analogous to `FOR SELECT`, to loop through the result set of a dynamically executed query that returns multiple rows.

.Example
Executing a dynamically constructed `SELECT` query that returns a data set:

[source]
----
CREATE PROCEDURE DynamicSampleThree (
   Q_FIELD_NAME VARCHAR(100),
   Q_TABLE_NAME VARCHAR(100)
) RETURNS(
  LINE VARCHAR(32000)
)
AS
  DECLARE VARIABLE P_ONE_LINE VARCHAR(100);
BEGIN
  LINE = '';
  FOR
    EXECUTE STATEMENT
      'SELECT T1.' || :Q_FIELD_NAME ||
      ' FROM ' || :Q_TABLE_NAME || ' T1 '
    INTO :P_ONE_LINE
  DO
    IF (:P_ONE_LINE IS NOT NULL) THEN
      LINE = :LINE || :P_ONE_LINE || ' ';
  SUSPEND;
END
----

.See also
<<fblangref25-psql-execstmt>>

[[fblangref25-psql-open]]
=== `OPEN`

.Used for
Opening a declared cursor

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
OPEN _cursorname_
----

[[fblangref25-psql-tbl-open]]
.`OPEN` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|cursorname
|Cursor name.
A cursor with this name must be previously declared with a `DECLARE CURSOR` statement
|===


An `OPEN` statement opens a previously declared cursor, executes the `SELECT` statement declared for it and makes the first record of the result data set ready to fetch.
`OPEN` can be applied only to cursors previously declared in a `DECLARE VARIABLE` statement.

[NOTE]
====
If the `SELECT` statement declared for the cursor has parameters, they must be declared as local variables or exist as input or output parameters before the cursor is declared.
When the cursor is opened, the parameter is assigned the current value of the variable.
====

.Examples
. Using the `OPEN` statement:
+
[source]
----
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^
----
. A collection of scripts for creating views using a PSQL block with named cursors:
+
[source]
----
EXECUTE BLOCK
RETURNS (
  SCRIPT BLOB SUB_TYPE TEXT)
AS
  DECLARE VARIABLE FIELDS VARCHAR(8191);
  DECLARE VARIABLE FIELD_NAME TYPE OF RDB$FIELD_NAME;
  DECLARE VARIABLE RELATION RDB$RELATION_NAME;
  DECLARE VARIABLE SOURCE TYPE OF COLUMN RDB$RELATIONS.RDB$VIEW_SOURCE;
  -- named cursor
  DECLARE VARIABLE CUR_R CURSOR FOR (
    SELECT
      RDB$RELATION_NAME,
      RDB$VIEW_SOURCE
    FROM
      RDB$RELATIONS
    WHERE
      RDB$VIEW_SOURCE IS NOT NULL);
  -- named cursor with local variable
  DECLARE CUR_F CURSOR FOR (
    SELECT
      RDB$FIELD_NAME
    FROM
      RDB$RELATION_FIELDS
    WHERE
      -- Important! The variable shall be declared earlier
      RDB$RELATION_NAME = :RELATION);
BEGIN
  OPEN CUR_R;
  WHILE (1 = 1) DO
  BEGIN
    FETCH CUR_R
    INTO :RELATION, :SOURCE;
    IF (ROW_COUNT = 0) THEN
      LEAVE;

    FIELDS = NULL;
    -- The CUR_F cursor will use
    -- variable value of RELATION initialized above
    OPEN CUR_F;
    WHILE (1 = 1) DO
    BEGIN
      FETCH CUR_F
      INTO :FIELD_NAME;
      IF (ROW_COUNT = 0) THEN
        LEAVE;
      IF (FIELDS IS NULL) THEN
        FIELDS = TRIM(FIELD_NAME);
      ELSE
        FIELDS = FIELDS || ', ' || TRIM(FIELD_NAME);
    END
    CLOSE CUR_F;

    SCRIPT = 'CREATE VIEW ' || RELATION;

    IF (FIELDS IS NOT NULL) THEN
      SCRIPT = SCRIPT || ' (' || FIELDS || ')';

    SCRIPT = SCRIPT || ' AS ' || ASCII_CHAR(13);
    SCRIPT = SCRIPT || SOURCE;

    SUSPEND;
  END
  CLOSE CUR_R;
END
----

.See also
<<fblangref25-psql-declare-cursor>>, <<fblangref25-psql-fetch>>, <<fblangref25-psql-close>>

[[fblangref25-psql-fetch]]
=== `FETCH`

.Used for
Fetching successive records from a data set retrieved by a cursor

.Available in
PSQL

.Syntax
[listing,subs="+quotes,attributes"]
----
FETCH _cursorname_ INTO [:{endsb}__varname__ [, [:{endsb}__varname__ ...]
----

[[fblangref25-psql-tbl-fetch]]
.`FETCH` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|cursorname
|Cursor name.
A cursor with this name must be previously declared with a `DECLARE CURSOR` statement and opened by an `OPEN` statement.

|varname
|Variable name
|===

A `FETCH` statement fetches the first and successive rows from the result set of the cursor and assigns the column values to PSQL variables.
The `FETCH` statement can be used only with a cursor declared with the `DECLARE CURSOR` statement.

The `INTO` clause gets data from the current row of the cursor  and loads them into PSQL variables.

For checking whether all of the the data set rows have been fetched, the context variable `ROW_COUNT` returns the number of rows fetched by the statement.
It is positive until all rows have been checked.
A `ROW_COUNT` of 1 indicates that the next fetch will be the last.

.Example
Using the `FETCH` statement:

[source]
----
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^

SET TERM ;^
----

.See also
<<fblangref25-psql-declare-cursor>>, <<fblangref25-psql-open>>, <<fblangref25-psql-close>>

[[fblangref25-psql-close]]
=== `CLOSE`

.Used for
Closing a declared cursor

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
CLOSE _cursorname_
----

[[fblangref25-psql-tbl-close]]
.`CLOSE` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|cursorname
|Cursor name.
A cursor with this name must be previously declared with a `DECLARE CURSOR` statement and opened by an `OPEN` statement
|===

A `CLOSE` statement closes an open cursor.
Any cursors that are still open will be automatically closed after the module code completes execution.
Only a cursor that was declared with `DECLARE CURSOR` can be closed with a `CLOSE` statement.

.Example
Using the `CLOSE` statement:

[source]
----
SET TERM ^;

CREATE OR ALTER PROCEDURE GET_RELATIONS_NAMES
RETURNS (
  RNAME CHAR(31)
)
AS
  DECLARE C CURSOR FOR (
    SELECT RDB$RELATION_NAME
    FROM RDB$RELATIONS);
BEGIN
  OPEN C;
  WHILE (1 = 1) DO
  BEGIN
    FETCH C INTO :RNAME;
    IF (ROW_COUNT = 0) THEN
      LEAVE;
    SUSPEND;
  END
  CLOSE C;
END^
----

.See also
<<fblangref25-psql-declare-cursor>>, <<fblangref25-psql-open>>, <<fblangref25-psql-fetch>>

[[fblangref25-psql-inauton]]
=== `IN AUTONOMOUS TRANSACTION`

.Used for
Executing a statement or a block of statements in an autonomous transaction

.Available in
PSQL

.Syntax
[listing]
----
IN AUTONOMOUS TRANSACTION DO <compound_statement>
----

[[fblangref25-psql-tbl-inauton]]
.`IN AUTONOMOUS TRANSACTION` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|compound_statement
|A statement or a block of statements
|===

An `IN AUTONOMOUS TRANSACTION` statement enables execution of a statement or a block of statements in an autonomous transaction.
Code running in an autonomous transaction will be committed right after its successful execution, regardless of the status of its parent transaction.
It might be needed when certain operations must not be rolled back, even if an error occurs in the parent transaction.

An autonomous transaction has the same isolation level as its parent transaction.
Any exception that is thrown in the block of the autonomous transaction code will result in the autonomous transaction being rolled back and all made changes being cancelled.
If the code executes successfully, the autonomous transaction will be committed.

.Example
Using an autonomous transaction in a trigger for the database `ON CONNECT` event, in order to log all connection attempts, including those that failed:

[source]
----
CREATE TRIGGER TR_CONNECT ON CONNECT
AS
BEGIN
  -- Logging all attempts to connect to the database
  IN AUTONOMOUS TRANSACTION DO
    INSERT INTO LOG(MSG)
    VALUES ('USER ' || CURRENT_USER || ' CONNECTS.');
  IF (CURRENT_USER IN (SELECT
                         USERNAME
                       FROM
                         BLOCKED_USERS)) THEN
  BEGIN
    -- Logging that the attempt to connect
    -- to the database failed and sending
    -- a message about the event
    IN AUTONOMOUS TRANSACTION DO
    BEGIN
      INSERT INTO LOG(MSG)
      VALUES ('USER ' || CURRENT_USER || ' REFUSED.');
      POST_EVENT 'CONNECTION ATTEMPT' || ' BY BLOCKED USER!';
    END
    -- now calling an exception
    EXCEPTION EX_BADUSER;
  END
END
----

.See also
<<fblangref25-transacs,`Transsaction Control`>>

[[fblangref25-psql-postevent]]
=== `POST_EVENT`

.Used for
Notifying listening clients about database events in a module

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
POST_EVENT _event_name_
----

[[fblangref25-psql-tbl-postevent]]
.`POST_EVENT` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|event_name
|Event name (message) limited to 127 bytes
|===

The `POST_EVENT` statement notifies the event manager about the event, which saves it to an event table.
When the transaction is committed, the event manager notifies applications that are signalling their interest in the event.

The event name can be some sort of code or a short message: the choice is open as it is just a string up to 127 bytes.

The content of the string can be a string literal, a variable or any valid SQL expression that resolves to a string.

.Example
Notifying the listening applications about inserting a record into the `SALES` table:

[source]
----
SET TERM ^;
CREATE TRIGGER POST_NEW_ORDER FOR SALES
ACTIVE AFTER INSERT POSITION 0
AS
BEGIN
  POST_EVENT 'new_order';
END^
SET TERM ;^
----

[[fblangref25-psql-handleexceptions]]
== Trapping and Handling Errors

Firebird has a useful lexicon of PSQL statements and resources for trapping errors in modules and for handling them.
Internally-implemented exceptions exist for stalling execution when every sort of standard error occurs in DDL, DSQL and the physical  environment.

In PSQL code, exceptions are handled by means of the <<fblangref25-psql-when>> statement.
Handling an exception in the code involves either fixing the problem in situ, or stepping past it;
either solution allows execution to continue without returning an exception message to the client.

An exception results in execution being terminated in the block.
Instead of passing the execution to the `END` statement, the procedure moves outward through levels of nested blocks, starting from the block where the exception is caught, searching for the code of the handler that "`knows`" about this exception.
It stops searching when it finds the first `WHEN` statement that can handle this exception.

[[fblangref25-ddl-sysexcept]]
=== System Exceptions

An exception is a message that is generated when an error occurs.

All exceptions handled by Firebird have predefined numeric values for context variables (symbols) and text messages associated with them.
Error messages are output in English by default.
Localized Firebird builds are available, where error messages are translated into other languages.

Complete listings of the system exceptions can be found in <<fblangref25-appx02-errorcodes,[ref]_Appendix B: Exception Codes and Messages_>>:

* <<fblangref25-appx02-sqlstates,SQLSTATE Error Codes and Descriptions>>
* <<fblangref25-appx02-sqlcodes,"GDSCODE Error Codes, SQLCODEs and Descriptions">>

[[fblangref25-ddl-customexcept]]
=== Custom Exceptions

Custom exceptions can be declared in the database as persistent objects and called in the PSQL code to signal specific errors;
for instance, to enforce certain business rules.
A custom exception consists of an identifier and a default message of approximately 1000 bytes.
For details, see <<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>.

[[fblangref25-psql-exception]]
=== `EXCEPTION`

.Used for
Throwing a user-defined exception or re-throwing an exception

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
EXCEPTION [_exception_name_ [_custom_message_]]
----

[[fblangref25-psql-tbl-exception]]
.`EXCEPTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

^|exception_name
<|Exception name

^|custom_message
<|Alternative message text to be returned to the caller interface when an exception is thrown.
Maximum length of the text message is 1,021 bytes
|===

An `EXCEPTION` statement throws the user-defined exception with the specified name.
An alternative message text of up to 1,021 bytes can optionally override the exception's default message text.

The exception can be handled in the statement, by just leaving it with no specific `WHEN ... DO` handler and allowing the trigger or stored procedure to terminate and roll back all operations.
The calling application gets the alternative message text, if any was specified;
otherwise, it receives the message originally defined for that exception.

Within the exception-handling block -- and only within it -- the caught exception can be re-thrown by executing the `EXCEPTION` statement without parameters.
If located outside the block, the re-thrown `EXCEPTION` call has no effect.

[NOTE]
====
Custom exceptions are stored in the system table <<fblangref-appx04-exceptions,`RDB$EXCEPTIONS`>>. 
====

.Examples
. Throwing an exception with dynamically generated text:
+
[source]
----
…
EXCEPTION EX_BAD_TYPE
  'Incorrect record type with id ' || new.id;
…
----
. Throwing an exception upon a condition in the `SHIP_ORDER` stored procedure:
+
[source]
----
CREATE OR ALTER PROCEDURE SHIP_ORDER (
  PO_NUM CHAR(8))
AS
  DECLARE VARIABLE ord_stat  CHAR(7);
  DECLARE VARIABLE hold_stat CHAR(1);
  DECLARE VARIABLE cust_no   INTEGER;
  DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
    s.order_status,
    c.on_hold,
    c.cust_no
  FROM
    sales s, customer c
  WHERE
    po_number = :po_num AND
    s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped;
  /* Other statements */
END
----
. Throwing an exception upon a condition and replacing the original message with an alternative message:
+
[source]
----
CREATE OR ALTER PROCEDURE SHIP_ORDER (
  PO_NUM CHAR(8))
AS
  DECLARE VARIABLE ord_stat  CHAR(7);
  DECLARE VARIABLE hold_stat CHAR(1);
  DECLARE VARIABLE cust_no   INTEGER;
  DECLARE VARIABLE any_po    CHAR(8);
BEGIN
  SELECT
    s.order_status,
    c.on_hold,
    c.cust_no
  FROM
    sales s, customer c
  WHERE
    po_number = :po_num AND
    s.cust_no = c.cust_no
  INTO :ord_stat,
       :hold_stat,
       :cust_no;

  IF (ord_stat = 'shipped') THEN
    EXCEPTION order_already_shipped
      'Order status is "' || ord_stat || '"';
  /* Other statements */
END
----
. Logging an error and re-throwing it in the `WHEN` block:
+
[source]
----
CREATE PROCEDURE ADD_COUNTRY (
  ACountryName COUNTRYNAME,
  ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
    -- write an error in log
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              GDSCODE,
              SQLCODE,
              SQLSTATE);
    -- Re-throw exception
    EXCEPTION;
  END
END
----

.See also
<<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>, <<fblangref25-psql-when>>

[[fblangref25-psql-when]]
=== `WHEN ... DO`

.Used for
Catching an exception and handling the error

.Available in
PSQL

.Syntax
[listing,subs=+quotes]
----
<block> ::=
  BEGIN
    [<compound_statement> ...]
    [<when_do> ...]
  END

<compound_statement> ::= {<block> | <statement>}

<<when_do>> ::=
  WHEN {<error> [, <error> …] | ANY}
  DO <compound_statement>

<error> ::=
  { EXCEPTION _exception_name_
  | SQLCODE _number_
  | GDSCODE _errcode_ }
----

[[fblangref25-psql-tbl-when]]
.`WHEN ... DO` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|exception_name
|Exception name

|number
|SQLCODE error code

|errcode
|Symbolic GDSCODE error name

|compound_statement
|A statement or a block of statements
|===

The `WHEN ... DO` statement is used to handle errors and user-defined exceptions.
The statement catches all errors and user-defined exceptions listed after the keyword `WHEN` keyword.
If `WHEN` is followed by the keyword `ANY`, the statement catches any error or user-defined exception, even if they have already been handled in a `WHEN` block located higher up.

The `WHEN ... DO` statements must be located at the end of a block of statements, before the block's `END` keyword, and after any other statement.

The keyword `DO` is followed by a statement, or a block of statements inside a `BEGIN ... END` block, that handle the exception.
The `SQLCODE`, `GDSCODE`, and `SQLSTATE` context variables are available in the context of this statement or block.
The `EXCEPTION` statement, without parameters, can also be used in this context to re-throw the error or exception.

[[fblangref25-psql-when-gdscode]]
.Targeting `GDSCODE`
****
The argument for the `WHEN GDSCODE` clause is the symbolic name associated with the internally-defined exception, such as `grant_obj_notfound` for GDS error 335544551.

After the `DO` clause, another `GDSCODE` context variable, containing the numeric code, becomes available for use in the statement or the block of statements that code the error handler.
That numeric code is required if you want to compare a `GDSCODE` exception with a targeted error.
****

The `WHEN ... DO` statement or block is never executed unless one of the events targeted by its conditions occurs in run-time.
If the statement is executed, even if it actually does nothing, execution will continue as if no error occurred: the error or user-defined exception neither terminates nor rolls back the operations of the trigger or stored procedure.

However, if the `WHEN ... DO` statement or block does nothing to handle or resolve the error, the DML statement (`SELECT`, `INSERT`, `UPDATE`, `DELETE`, `MERGE`) that caused the error will be rolled back and none of the statements below it in the same block of statements are executed.

[IMPORTANT]
====
. If the error is not caused by one of the DML statements (`SELECT`, `INSERT`, `UPDATE`, `DELETE`, `MERGE`), the entire block of statements will be rolled back, not just the one that caused an error.
Any operations in the `WHEN ... DO` statement will be rolled back as well.
The same limitation applies to the `EXECUTE PROCEDURE` statement.
Read an interesting discussion of the phenomenon in Firebird Tracker ticket http://tracker.firebirdsql.org/browse/CORE-4483[CORE-4483].
. In selectable stored procedures, output rows that were already passed to the client in previous iterations of a `FOR SELECT ... DO ... SUSPEND` loop remain available to the client if an exception is thrown subsequently in the process of retrieving rows.
====

[[fblangref25-psql-whendo-scope]]
==== Scope of a `WHEN ... DO` Statement

A `WHEN ... DO` statement catches errors and exceptions in the current block of statements.
It also catches similar exceptions in nested blocks, if those exceptions have not been handled in them.

All changes made before the statement that caused the error are visible to a `WHEN ... DO` statement.
However, if you try to log them in an autonomous transaction, those changes are unavailable, because the transaction where the changes took place is not committed at the point when the autonomous transaction is started.
Example 4, below, demonstrates this behaviour.

[TIP]
====
When handling exceptions, it is sometimes desirable to handle the exception by writing a log message to mark the fault and having execution continue past the faulty record.
Logs can be written to regular tables but there is a problem with that: the log records will "`disappear`" if an unhandled error causes the module to stop executing and a rollback ensues.
Use of <<fblangref25-ddl-tbl-external,external tables>> can be useful here, as data written to them is transaction-independent.
The linked external file will still be there, regardless of whether the overall process succeeds or not.
====

==== Examples using `WHEN...DO`

. Replacing the standard error with a custom one:
+
[source]
----
CREATE EXCEPTION COUNTRY_EXIST '';
SET TERM ^;
CREATE PROCEDURE ADD_COUNTRY (
  ACountryName COUNTRYNAME,
  ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country, currency)
  VALUES (:ACountryName, :ACurrency);

  WHEN SQLCODE -803 DO
    EXCEPTION COUNTRY_EXIST 'Country already exists!';
END^
SET TERM ^;
----
. Logging an error and re-throwing it in the `WHEN` block:
+
[source]
----
CREATE PROCEDURE ADD_COUNTRY (
  ACountryName COUNTRYNAME,
  ACurrency VARCHAR(10) )
AS
BEGIN
  INSERT INTO country (country,
                       currency)
  VALUES (:ACountryName,
          :ACurrency);
  WHEN ANY DO
  BEGIN
    -- write an error in log
    IN AUTONOMOUS TRANSACTION DO
      INSERT INTO ERROR_LOG (PSQL_MODULE,
                             GDS_CODE,
                             SQL_CODE,
                             SQL_STATE)
      VALUES ('ADD_COUNTRY',
              GDSCODE,
              SQLCODE,
              SQLSTATE);
    -- Re-throw exception
    EXCEPTION;
  END
END
----
. Handling several errors in one `WHEN` block
+
[source]
----
...
WHEN GDSCODE GRANT_OBJ_NOTFOUND,
	 GDSCODE GRANT_FLD_NOTFOUND,
	 GDSCODE GRANT_NOPRIV,
	 GDSCODE GRANT_NOPRIV_ON_BASE
DO
BEGIN
  EXECUTE PROCEDURE LOG_GRANT_ERROR(GDSCODE);
  EXIT;
END
...
----

.See also
<<fblangref25-psql-exception>>, <<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>, <<fblangref25-appx02-tbl-errcodes01,SQLCODE and GDSCODE Error Codes and Message Texts>> and <<fblangref25-appx02-tbl-sqlstates,SQLSTATE Codes and Message Texts>>
