[[fblangref25-commons]]
= Common Language Elements

This chapter covers the elements that are common throughout the implementation of the SQL language -- the [term]_expressions_ that are used to extract and operate on assertions about data and the [term]_predicates_ that test the truth of those assertions.

[[fblangref25-commons-expressions]]
== Expressions

SQL expressions provide formal methods for evaluating, transforming and comparing values.
SQL expressions may include table columns, variables, constants, literals, various statements and predicates and also other expressions.
The complete list of possible tokens in expressions follows.

[[fblangref25-dtyp-tbl-exprelements]]
.Description of Expression Elements
Column name::
Identifier of a column from a specified table used in evaluations or as a search condition.
A column of the array type cannot be an element in an expression except when used with the `IS [NOT] NULL` predicate.

Array element::
An expression may contain a reference to an array member i.e., `<array_name>[__s__]`, where _``s``_ is the subscript of the member in the array `<array_name>`

Arithmetic operators::
The `+`, `-`, `*`, `/` characters used to calculate values

Concatenation operator::
The `||` ("`double-pipe`") operator used to concatenate strings

Logical operators::
The reserved words `NOT`, `AND` and `OR`, used to combine simple search conditions in order to create complex assertions

Comparison operators::
The symbols `=`, `<>`, `!=`, `~=`, `^=`, `<`, `++<=++`, `>`, `>=`, `!<`, `~<`, `^<`, `!>`, `~>` and `^>`

Comparison predicates::
`LIKE`, `STARTING WITH`, `CONTAINING`, `SIMILAR TO`, `BETWEEN`, `IS [NOT] NULL` and `IS [NOT] DISTINCT FROM`

Existential predicates::
Predicates used to check the existence of values in a set.
The `IN` predicate can be used both with sets of comma-separated constants and with subqueries that return a single column.
The `EXISTS`, `SINGULAR`, `ALL`, `ANY` and `SOME` predicates can be used only with subqueries.

Constant::
A number or a string literal enclosed in apostrophes

Date/time literal::
An expression, similar to a string literal enclosed in apostrophes, that can be interpreted as a date, time or timestamp value.
Date literals can be predefined literals (`'TODAY'`, `'NOW'`, etc.) or strings of characters and numerals, such as `'25.12.2016 15:30:35'`, that can be resolved as date and/or time strings.

Context variable::
An internally-defined <<fblangref25-contextvars,context variable>>

Local variable::
Declared local variable, input or output parameter of a PSQL module (stored procedure, trigger, unnamed PSQL block in DSQL)

Positional parameter::
A member of in an ordered group of one or more unnamed parameters passed to a stored procedure or prepared query

Subquery::
A `SELECT` statement enclosed in parentheses that returns a single (scalar) value or, when used in existential predicates, a set of values

Function identifier::
The identifier of an internal or external function in a function expression

Type cast::
An expression explicitly converting data of one data type to another using the `CAST` function ( `CAST (<value> AS <datatype>)` ).
For date/time literals only, the shorthand syntax <datatype> <value> is also supported (`DATE '2016-12-25'`).

Conditional expression::
Expressions using CASE and related internal functions

Parentheses::
Bracket pairs `(...)` used to group expressions.
Operations inside the parentheses are performed before operations outside them.
When nested parentheses are used, the most deeply nested expressions are evaluated first and then the evaluations move outward through the levels of nesting.

COLLATE clause::
Clause applied to CHAR and VARCHAR types to specify the character-set-specific collation sequence to use in string comparisons

`NEXT VALUE FOR __sequence__`::
Expression for obtaining the next value of a specified generator (sequence).
The internal `GEN_ID()` function does the same.

[[fblangref25-commons-constants]]
=== Constants

A constant is a value that is supplied directly in an SQL statement, not derived from an expression, a parameter, a column reference nor a variable.
It can be a string or a number.

[[fblangref25-commons-string-constant]]
==== String Constants (Literals)

A string constant -- or string literal -- is a series of characters enclosed between a pair of apostrophes ("`single quotes`").
The maximum length of a string is 32,767 bytes;
the maximum character count will be determined by the number of bytes used to encode each character.

[NOTE]
====
* Double quotes are _NOT VALID_ for quoting strings.
SQL reserves a different purpose for them.
* If a literal apostrophe is required within a string constant, it is "`escaped`" by prefixing it with another apostrophe.
For example, `'Mother O''Reilly's home-made hooch'`.
* Care should be taken with the string length if the value is to be written to a `VARCHAR` column.
The maximum length for a `VARCHAR` is 32,765 bytes.
====

The character set of a string constant is assumed to be the same as the character set of its destined storage.

[[fblangref25-commons-hexstrings]]
===== String Constants in Hexadecimal Notation

From Firebird 2.5 forward, string literals can be entered in hexadecimal notation, so-called "`binary strings`".
Each pair of hex digits defines one byte in the string.
Strings entered this way will have character set `OCTETS` by default, but the <<fblangref25-commons-introducer-syntax,[term]_introducer syntax_>> can be used to force a string to be interpreted as another character set.

.Syntax
[listing,subs=+quotes]
----
{x|X}'<hexstring>'

<hexstring>  ::=  _an even number of <hexdigit>_
<hexdigit>   ::=  _one of 0..9, A..F, a..f_
----

.Examples
[source]
----
select x'4E657276656E' from rdb$database
-- returns 4E657276656E, a 6-byte 'binary' string

select _ascii x'4E657276656E' from rdb$database
-- returns 'Nerven' (same string, now interpreted as ASCII text)

select _iso8859_1 x'53E46765' from rdb$database
-- returns 'Säge' (4 chars, 4 bytes)

select _utf8 x'53C3A46765' from rdb$database
-- returns 'Säge' (4 chars, 5 bytes)
----

.Notes
[NOTE]
====
The client interface determines how binary strings are displayed to the user.
The _isql_ utility, for example, uses upper case letters A-F, while FlameRobin uses lower case letters.
Other client programs may use other conventions, such as displaying spaces between the byte pairs: `'4E 65 72 76 65 6E'`.

The hexadecimal notation allows any byte value (including 00) to be inserted at any position in the string.
However, if you want to coerce it to anything other than OCTETS, it is your responsibility to supply the bytes in a sequence that is valid for the target character set.
====

[[fblangref25-commons-introducer-syntax]]
===== Introducer Syntax for String Literals

If necessary, a string literal may be preceded by a character set name, itself prefixed with an underscore "`++_++`".
This is known as [term]_introducer syntax_.
Its purpose is to inform the engine about how to interpret and store the incoming string.

Example 
[source]
----
INSERT INTO People
VALUES (_ISO8859_1 'Hans-Jörg Schäfer')
----

[[fblangref25-commons-number-constant]]
==== Number Constants (Literals)

A number constant -- or number literal -- is any valid number in a supported notation:

* In SQL, for numbers in the standard decimal notation, the decimal point is always represented by period (`.`, full-stop, dot) character and thousands are not separated.
Inclusion of commas, blanks, etc. will cause errors.
* Exponential notation is supported.
For example, 0.0000234 can be expressed as `2.34e-5`.
* Hexadecimal notation is supported by Firebird 2.5 and higher versions -- see below.

[[fblangref25-commons-hexnumbers]]
===== Hexadecimal Notation for Numbers

From Firebird 2.5 forward, integer values can be entered in hexadecimal notation.
Numbers with 1-8 hex digits will be interpreted as type `INTEGER`;
numbers with 9-16 hex digits as type `BIGINT`.

.Syntax
[listing,subs=+quotes]
----
0{x|X}<hexdigits>

<hexdigits>  ::=  _1-16 of <hexdigit>_
<hexdigit>   ::=  _one of 0..9, A..F, a..f_
----

.Examples
[source]
----
select 0x6FAA0D3 from rdb$database           -- returns 117088467
select 0x4F9 from rdb$database               -- returns 1273
select 0x6E44F9A8 from rdb$database          -- returns 1850014120
select 0x9E44F9A8 from rdb$database          -- returns -1639646808 (an INTEGER)
select 0x09E44F9A8 from rdb$database         -- returns 2655320488 (a BIGINT)
select 0x28ED678A4C987 from rdb$database     -- returns 720001751632263
select 0xFFFFFFFFFFFFFFFF from rdb$database  -- returns -1
----

[[fblangref25-commons-hexranges]]
====== Hexadecimal Value Ranges

* Hex numbers in the range 0 .. 7FFF FFFF are positive ``INTEGER``s with values between 0 .. 2147483647 decimal.
To coerce a number to `BIGINT`, prepend enough zeroes to bring the total number of hex digits to nine or above.
That changes the type but not the value.
* Hex numbers between 8000 0000 .. FFFF FFFF require some attention:
+
--
** When written with eight hex digits, as in `0x9E44F9A8`, a value is interpreted as 32-bit `INTEGER`.
Since the leftmost bit (sign bit) is set, it maps to the negative range -2147483648 .. -1 decimal.
** With one or more zeroes prepended, as in `0x09E44F9A8`, a value is interpreted as 64-bit `BIGINT` in the range 0000 0000 8000 0000 .. 0000 0000 FFFF FFFF.
The sign bit is not set now, so they map to the positive range 2147483648 .. 4294967295 decimal.
--
+
Thus, in this range -- and only in this range -- prepending a mathematically insignificant 0 results in a totally different value.
This is something to be aware of. 
* Hex numbers between 1 0000 0000 .. 7FFF FFFF FFFF FFFF are all positive `BIGINT`.
* Hex numbers between 8000 0000 0000 0000 .. FFFF FFFF FFFF FFFF are all negative `BIGINT`.
* A SMALLINT cannot be written in hex, strictly speaking, since even `0x1` is evaluated as `INTEGER`.
However, if you write a positive integer within the 16-bit range `0x0000` (decimal zero) to `0x7FFF` (decimal 32767) it will be converted to `SMALLINT` transparently.
+ 
It is possible to write to a negative `SMALLINT` in hex, using a 4-byte hex number within the range `0xFFFF8000` (decimal -32768) to `0xFFFFFFFF` (decimal -1).

[[fblangref25-commons-sqloperators]]
=== SQL Operators

SQL operators comprise operators for comparing, calculating, evaluating and concatenating values.

[[fblangref25-commons-operpreced]]
==== Operator Precedence

SQL Operators are divided into four types.
Each operator type has a _precedence_, a ranking that determines the order in which operators and the values obtained with their help are evaluated in an expression.
The higher the precedence of the operator type is, the earlier it will be evaluated.
Each operator has its own precedence within its type, that determines the order in which they are evaluated in an expression.

Operators with the same precedence are evaluated from left to right.
To force a different evaluation order, operations can be grouped by means of parentheses.

[[fblangref25-dtyp-tbl-operpreced]]
.Operator Type Precedence
[cols="<1,<1,<3", options="header",stripes="none"]
|===
^| Operator Type
^| Precedence
^| Explanation

|Concatenation
|1
|Strings are concatenated before any other operations take place

|Arithmetic
|2
|Arithmetic operations are performed after strings are concatenated, but before comparison and logical operations

|Comparison
|3
|Comparison operations take place after string concatenation and arithmetic operations, but before logical operations

|Logical
|4
|Logical operators are executed after all other types of operators
|===

[[fblangref25-commons-concat]]
===== Concatenation Operator

The concatenation operator, two pipe characters known as "`double pipe`" -- '```||```' -- concatenates (connects together) two character strings to form a single string.
Character strings can be constants or values obtained from columns or other expressions.

.Example
[source]
----
SELECT LAST_NAME || ', ' || FIRST_NAME AS FULL_NAME
FROM EMPLOYEE
----

[[fblangref25-commons-arith]]
===== Arithmetic Operators

[[fblangref25-dtyp-tbl-arithpreced]]
.Arithmetic Operator Precedence
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Operator
^| Purpose
^| Precedence

|`{plus}signed_number`
|Unary plus
|1

|`-signed_number`
|Unary minus
|1

|`{asterisk}`
|Multiplication
|2

|`/`
|Division
|2

|`{plus}`
|Addition
|3

|`-`
|Subtraction
|3
|===

.Example
[source]
----
UPDATE T
    SET A = 4 + 1/(B-C)*D
----

[NOTE]
====
Where operators have the same precedence, they are evaluated in left-to-right sequence.
====

[[fblangref25-commons-compar]]
===== Comparison Operators

[[fblangref25-dtyp-tbl-comparpreced]]
.Comparison Operator Precedence
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Operator
^| Purpose
^| Precedence

|`=`
|Is equal to, is identical to
|1

|`<>`, `!=`, `~=`, `^=`
|Is not equal to
|1

|`>`
|Is greater than
|1

|`<`
|Is less than
|1

|`>=`
|Is greater than or equal to
|1

|`++<=++`
|Is less than or equal to
|1

|`!>`, `~>`, `^>`
|Is not greater than
|1

|`!<`, `~<`, `^<`
|Is not less than
|1
|===

This group also includes comparison predicates `BETWEEN`, `LIKE`, `CONTAINING`, `SIMILAR TO`, `IS` and others.

.Example
[source]
----
IF (SALARY > 1400) THEN
…
----

.See also
<<fblangref25-commons-othercomppreds,Other Comparison Predicates>>.

[[fblangref25-commons-logical]]
===== Logical Operators

[[fblangref25-dtyp-tbl-logical]]
.Logical Operator Precedence
[cols="<1,<2,<1", options="header",stripes="none"]
|===
^| Operator
^| Purpose
^| Precedence

|`NOT`
|Negation of a search condition
|1

|`AND`
|Combines two or more predicates, each of which must be true for the entire predicate to be true
|2

|`OR`
|Combines two or more predicates, of which at least one predicate must be true for the entire predicate to be true
|3
|===

.Example
[source]
----
IF (A < B OR (A > C AND A > D) AND NOT (C = D)) THEN …
----

[[fblangref25-commons-conditional-nxtvlufor]]
==== `NEXT VALUE FOR`

.Available
DSQL, PSQL

`NEXT VALUE FOR` returns the next value of a sequence.
`SEQUENCE` is an SQL-compliant term for a generator in Firebird and its ancestor, InterBase.
The `NEXT VALUE FOR` operator is equivalent to the legacy `GEN_ID (..., 1)` function and is the recommended syntax for retrieving the next sequence value.

.Syntax for NEXT VALUE FOR
[listing,subs=+quotes]
----
NEXT VALUE FOR _sequence-name_
----

.Example
[source]
----
NEW.CUST_ID = NEXT VALUE FOR CUSTSEQ;
----

[NOTE]
====
Unlike `GEN_ID (..., 1)`, the `NEXT VALUE FOR` variant does not take any parameters and thus, provides no way to retrieve the _current value_ of a sequence, nor to step the next value by more than 1.
`GEN_ID (..., <step value>)` is still needed for these tasks.
A _step value_ of 0 returns the current sequence value.
====

.See also
<<fblangref25-ddl-sequence,SEQUENCE (GENERATOR)>>, <<fblangref25-functions-scalarfuncs-gen-id,`GEN_ID()`>>

[[fblangref25-commons-conditional]]
=== Conditional Expressions

A conditional expression is one that returns different values according to how a certain condition is met.
It is composed by applying a conditional function construct, of which Firebird supports several.
This section describes only one conditional expression construct: `CASE`.
All other conditional expressions apply internal functions derived from `CASE` and are described in  <<fblangref25-functions-conditional,Conditional Functions>>.

[[fblangref25-commons-conditional-case]]
==== `CASE`

.Available
DSQL, PSQL

The `CASE` construct returns a single value from a number of possible ones.
Two syntactic variants are supported: 

* The _simple_{nbsp}``CASE``, comparable to a [term]_case construct_ in Pascal or a [term]_switch_ in C
* The _searched_{nbsp}``CASE``, which works like a series of "```if ... else if ... else if```"{nbsp}clauses.

[[fblangref25-commons-conditional-case-simple]]
===== Simple `CASE`

.Syntax
[listing]
----
…
CASE <test-expr>
  WHEN <expr> THEN <result>
  [WHEN <expr> THEN <result> ...]
  [ELSE <defaultresult>]
END
…
----

When this variant is used, _test-expr_ is compared _expr_ 1, _expr_ 2 etc., until a match is found and the corresponding result is returned.
If no match is found, _defaultresult_ from the optional `ELSE` clause is returned.
If there are no matches and no `ELSE` clause, `NULL` is returned.

The matching works identically to the "```=```" operator.
That is, if _test-expr_ is `NULL`, it does not match any _expr_, not even an expression that resolves to `NULL`.

The returned result does not have to be a literal value: it might be a field or variable name, compound expression or `NULL` literal.

.Example
[source]
----
SELECT
  NAME,
  AGE,
  CASE UPPER(SEX)
    WHEN 'M' THEN 'Male'
    WHEN 'F' THEN 'Female'
    ELSE 'Unknown'
  END GENDER,
RELIGION
    FROM PEOPLE
----

A short form of the simple `CASE` construct is the <<fblangref25-functions-scalarfuncs-decode,`DECODE`>>  function.

[[fblangref25-commons-conditional-case-srched]]
===== Searched `CASE`

.Syntax
[listing]
----
CASE
  WHEN <bool_expr> THEN <result>
  [WHEN <bool_expr> THEN <result> …]
  [ELSE <defaultresult>]
END
----

The _bool_expr_ expression is one that gives a ternary logical result: `TRUE`, `FALSE` or `NULL`.
The first expression to return `TRUE` determines the result.
If no expressions return `TRUE`, _defaultresult_ from the optional `ELSE` clause is returned as the result.
If no expressions return `TRUE` and there is no `ELSE` clause, the result will be `NULL`.

As with the simple `CASE` construct, the result need not be a literal value: it might be a field or variable name, a compound expression, or be `NULL`.

.Example
[source]
----
CANVOTE = CASE
  WHEN AGE >= 18 THEN 'Yes'
  WHEN AGE < 18 THEN 'No'
  ELSE 'Unsure'
END
----

[[fblangref25-commons-null-in-expr]]
=== `NULL` in Expressions

`NULL` is not a value in SQL, but a _state_ indicating that the value of the element either is _unknown_ or it does not exist.
It is not a zero, nor a void, nor an "`empty string`", and it does not act like any value.

When you use `NULL` in numeric, string or date/time expressions, the result will always be `NULL`.
When you use `NULL` in logical (Boolean) expressions, the result will depend on the type of the operation and on other participating values.
When you compare a value to `NULL`, the result will be _unknown_.

.Important to Note
[IMPORTANT]
====
`NULL` means `NULL` but, in Firebird, the logical result _unknown_ is also _represented by_ `NULL`.
====

[[fblangref25-commons-returningnull]]
==== Expressions Returning `NULL`

Expressions in this list will always return `NULL`:

[source]
----
1 + 2 + 3 + NULL
'Home ' || 'sweet ' || NULL
MyField = NULL
MyField <> NULL
NULL = NULL
not (NULL)
----

If it seems difficult to understand why, remember that `NULL` is a state that stands for "`unknown`".

[[fblangref25-commons-nullinlogical]]
==== `NULL` in Logical Expressions

It has already been shown that `NOT (NULL)` results in `NULL`.
The interaction is a bit more complicated for the logical `AND` and logical `OR` operators:

[source]
----
NULL or false = NULL
NULL or true = true
NULL or NULL = NULL
NULL and false = false
NULL and true = NULL
NULL and NULL = NULL
----

Up to and including Firebird 2.5.x, there is no implementation for a logical (Boolean) data type -- that is coming in Firebird 3.
However, there are logical expressions (predicates) that can return true, false or unknown.

.Examples
[source]
----
(1 = NULL) or (1 <> 1) -- returns NULL
(1 = NULL) or (1 = 1) -- returns TRUE
(1 = NULL) or (1 = NULL) -- returns NULL
(1 = NULL) and (1 <> 1) -- returns FALSE
(1 = NULL) and (1 = 1) -- returns NULL
(1 = NULL) and (1 = NULL) -- returns NULL
----

[[fblangref25-commons-subqueries]]
=== Subqueries

A subquery is a special form of expression that is actually a query embedded within another query.
Subqueries are written in the same way as regular `SELECT` queries, but they must be enclosed in parentheses.
Subquery expressions can be used in the following ways: 

* To specify an output column in the SELECT list
* To obtain values or conditions for search predicates (the `WHERE`, `HAVING` clauses).
* To produce a set that the enclosing query can select from, as though were a regular table or view.
Subqueries like this appear in the FROM clause (derived tables) or in a Common Table Expression (CTE)

[[fblangref25-commons-correlatedsq]]
==== Correlated Subqueries

A subquery can be _correlated_.
A query is correlated when the subquery and the main query are interdependent.
To process each record in the subquery, it is necessary to fetch a record in the main query;
i.e., the subquery fully depends on the main query.

.Sample Correlated Subquery
[source]
----
SELECT *
FROM Customers C
WHERE EXISTS
  (SELECT *
   FROM Orders O
   WHERE C.cnum = O.cnum
     AND O.adate = DATE '10.03.1990');
----

When subqueries are used to get the values of the output column in the SELECT list, a subquery must return a _scalar_ result.

[[fblangref25-commons-scalarsq]]
==== Scalar Results

Subqueries used in search predicates, other than existential and quantified predicates, must return a _scalar_ result;
that is, not more than one column from not more than one matching row or aggregation.
If the result would return more, a run-time error will occur ("`Multiple rows in a singleton select...`").

[NOTE]
====
Although it is reporting a genuine error, the message can be slightly misleading.
A "`singleton SELECT`" is a query that must not be capable of returning more than one row.
However, "`singleton`" and "`scalar`" are not synonymous: not all singleton SELECTS are required to be scalar;
and single-column selects can return multiple rows for existential and quantified predicates.
====

.Subquery Examples
. A subquery as the output column in a `SELECT` list:
+
[source]
----
SELECT
  e.first_name,
  e.last_name,
  (SELECT
       sh.new_salary
   FROM
       salary_history sh
   WHERE
       sh.emp_no = e.emp_no
   ORDER BY sh.change_date DESC ROWS 1) AS last_salary
FROM
  employee e
----
. A subquery in the `WHERE` clause for obtaining the employee's maximum salary and filtering by it:
+
[source]
----
SELECT
  e.first_name,
  e.last_name,
  e.salary
FROM
  employee e
WHERE
  e.salary = (
              SELECT MAX(ie.salary)
              FROM employee ie
             )
----

[[fblangref25-commons-predicates]]
== Predicates

A predicate is a simple expression asserting some fact, let's call it `P`.
If `P` resolves as TRUE, it succeeds.
If it resolves to FALSE or NULL (UNKNOWN), it fails.
A trap lies here, though: suppose the predicate, `P`, returns FALSE.
In this case `NOT(P)` will return TRUE.
On the other hand, if `P` returns NULL (unknown), then `NOT(P)` returns NULL as well.

In SQL, predicates can appear in `CHECK` constraints, `WHERE` and `HAVING` clauses, `CASE` expressions, the `IIF()` function and in the `ON` condition of `JOIN` clauses.

[[fblangref25-commons-assertions]]
=== Assertions

An assertion is a statement about the data that, like a predicate, can resolve to TRUE, FALSE or NULL.
Assertions consist of one or more predicates, possibly negated using `NOT` and connected by `AND` and `OR` operators.
Parentheses may be used for grouping predicates and controlling evaluation order.

A predicate may embed other predicates.
Evaluation sequence is in the outward direction, i.e., the innermost predicates are evaluated first.
Each "`level`" is evaluated in precedence order until the truth of the ultimate assertion is resolved.

[[fblangref25-commons-comppreds]]
=== Comparison Predicates

A comparison predicate consists of two expressions connected with a comparison operator.
There are six traditional comparison operators:

[listing]
----
=, >, <, >=, <=, <>
----

For the complete list of comparison operators with their variant forms, see <<fblangref25-commons-compar,Comparison Operators>>.

If one of the sides (left or right) of a comparison predicate has `NULL` in it, the value of the predicate will be UNKNOWN.

.Examples
. Retrieve information about computers with the CPU frequency not less than 500 MHz and the price lower than $800:
+
[source]
----
SELECT *
FROM Pc
WHERE speed >= 500 AND price < 800;
----
. Retrieve information about all dot matrix printers that cost less than $300:
+
[source]
----
SELECT *
FROM Printer
WHERE ptrtype = 'matrix' AND price < 300;
----
. The following query will return no data, even if there are printers with no type specified for them, because a predicate that compares `NULL` with `NULL` returns `NULL`:
+
[source]
----
SELECT *
FROM Printer
WHERE ptrtype = NULL AND price < 300;
----
+
On the other hand, [replaceable]`ptrtype` can be tested for `NULL` and return a result: it is just that it is not a _comparison_ test:
+
[source]
----
SELECT *
FROM Printer
WHERE ptrtype IS NULL AND price < 300;
----
+
-- see <<fblangref25-commons-isnotnull,`IS [NOT] NULL`>>.

.Note about String Comparison
[NOTE]
====
When `CHAR` and `VARCHAR` fields are compared for equality, trailing spaces are ignored in all cases.
====

[[fblangref25-commons-othercomppreds]]
==== Other Comparison Predicates

Other comparison predicates are marked by keyword symbols.

[[fblangref25-commons-predbetween]]
===== `BETWEEN`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] BETWEEN <value_1> AND <value_2>
----

The `BETWEEN` predicate tests whether a value falls within a specified range of two values.
(`NOT BETWEEN` tests whether the value does not fall within that range.)

The operands for `BETWEEN` predicate are two arguments of compatible data types.
Unlike in some other DBMS, the `BETWEEN` predicate in Firebird is not symmetrical -- if the lower value is not the first argument, the `BETWEEN` predicate will always return FALSE.
The search is inclusive (the values represented by both arguments are included in the search).
In other words, the `BETWEEN` predicate could be rewritten:

[listing]
----
<value> >= <value_1> AND <value> <= <value_2>
----

When `BETWEEN` is used in the search conditions of DML queries, the Firebird optimizer can use an index on the searched column, if it is available.

.Example
[source]
----
SELECT *
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN date '01.01.1992' AND CURRENT_DATE
----

[[fblangref25-commons-predlike]]
===== `LIKE`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
<match value> [NOT] LIKE <pattern>
   [ESCAPE <escape character>]

<match value>      ::= _character-type expression_
<pattern>          ::= _search pattern_
<escape character> ::= _escape character_
----

The `LIKE` predicate compares the character-type expression with the pattern defined in the second expression.
Case- or accent-sensitivity for the comparison is determined by the collation that is in use.
A collation can be specified for either operand, if required.

[[fblangref25-commons-wildcards]]
====== Wildcards

Two wildcard symbols are available for use in the search pattern: 

* the percentage symbol (`%`) will match any sequence of zero or more characters in the tested value
* the underscore character (`++_++`) will match any single character in the tested value

If the tested value matches the pattern, taking into account wildcard symbols, the predicate is TRUE.

[[fblangref25-commons-escapechar]]
====== Using the `ESCAPE` Character Option

If the search string contains either of the wildcard symbols, the `ESCAPE` clause can be used to specify an escape character.
The escape character must precede the '```%```' or '```++_++```'} symbol in the search string, to indicate that the symbol is to be interpreted as a literal character.

====== Examples using `LIKE`

. Find the numbers of departments whose names start with the word "`Software`":
+
[source]
----
SELECT DEPT_NO
FROM DEPT
WHERE DEPT_NAME LIKE 'Software%';
----
+
It is possible to use an index on the DEPT_NAME field if it exists.
+
.About `LIKE` and the Optimizer
[NOTE]
====
Actually, the `LIKE` predicate does not use an index.
However, if the predicate takes the form of `LIKE 'string%'`, it will be converted to the `STARTING WITH` predicate, which will use an index.

So, if you need to search for the beginning of a string, it is recommended to use the `STARTING WITH` predicate instead of the `LIKE` predicate.
====
. Search for employees whose names consist of 5 letters, start with the letters "`Sm`" and end with "`th`". The predicate will be true for such names as "`Smith`" and "`Smyth`".
+
[source]
----
SELECT
  first_name
FROM
  employee
WHERE first_name LIKE 'Sm_th'
----
. Search for all clients whose address contains the string "`Rostov`":
+
[source]
----
SELECT *
FROM CUSTOMER
WHERE ADDRESS LIKE '%Rostov%'
----
+
[NOTE]
====
If you need to do a case-insensitive search for something _enclosed inside_ a string (`LIKE '%Abc%'`), use of the `CONTAINING` predicate is recommended, in preference to the `LIKE` predicate.
====
. Search for tables containing the underscore character in their names.
The '```#```' character is used as the escape character:
+
[source]
----
SELECT
  RDB$RELATION_NAME
FROM RDB$RELATIONS
WHERE RDB$RELATION_NAME LIKE '%#_%' ESCAPE '#'
----

.See also
<<fblangref25-commons-predstartwith,`STARTING WITH`>>, <<fblangref25-commons-predcontaining,`CONTAINING`>>, <<fblangref25-commons-predsiimilarto,`SIMILAR TO`>>

[[fblangref25-commons-predstartwith]]
===== `STARTING WITH`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] STARTING WITH <value>
----

The `STARTING WITH` predicate searches for a string or a string-like type that starts with the characters in its _value_ argument.
The search is case-sensitive.

When `STARTING WITH` is used in the search conditions of DML queries, the Firebird optimizer can use an index on the searched column, if it exists.

.Example
Search for employees whose last names start with "`Jo`":

[source]
----
SELECT LAST_NAME, FIRST_NAME
FROM EMPLOYEE
WHERE LAST_NAME STARTING WITH 'Jo'
----

.See also
<<fblangref25-commons-predlike,`LIKE`>>

[[fblangref25-commons-predcontaining]]
===== `CONTAINING`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] CONTAINING <value>
----

The `CONTAINING` predicate searches for a string or a string-like type looking for the sequence of characters that matches its argument.
It can be used for an alphanumeric (string-like) search on numbers and dates.
A `CONTAINING` search is not case-sensitive.
However, if an accent-sensitive collation is in use then the search will be accent-sensitive.

When `CONTAINING` is used in the search conditions of DML queries, the Firebird optimizer can use an index on the searched column, if a suitable one exists.

.Examples
. Search for projects whose names contain the substring "`Map`":
+
[source]
----
SELECT *
FROM PROJECT
WHERE PROJ_NAME CONTAINING 'Map';
----
+
Two rows with the names "`AutoMap`" and "`MapBrowser port`" are returned.
. Search for changes in salaries with the date containing number 84 (in this case, it means changes that took place in 1984):
+
[source]
----
SELECT *
FROM SALARY_HISTORY
WHERE CHANGE_DATE CONTAINING 84;
----

.See also
<<fblangref25-commons-predlike,`LIKE`>>

[[fblangref25-commons-predsiimilarto]]
===== `SIMILAR TO`

.Available
DSQL, PSQL

.Syntax
[listing,subs=+quotes]
----
_string-expression_ [NOT] SIMILAR TO <pattern> [ESCAPE <escape-char>]

<pattern>     ::= _an SQL regular expression_
<escape-char> ::= _a single character_
----

`SIMILAR TO` matches a string against an SQL regular expression pattern.
Unlike in some other languages, the pattern must match the entire string in order to succeed -- matching a substring is not enough.
If any operand is `NULL`, the result is `NULL`.
Otherwise, the result is `TRUE` or `FALSE`.

[[fblangref25-commons-syntaxregex]]
====== Syntax: SQL Regular Expressions

The following syntax defines the SQL regular expression format.
It is a complete and correct top-down definition.
It is also highly formal, rather long and probably perfectly fit to discourage everybody who hasn't already some experience with regular expressions (or with highly formal, rather long top-down definitions).
Feel free to skip it and read the next section, <<fblangref25-commons-buildregex,Building Regular Expressions>>, which uses a bottom-up approach, aimed at the rest of us.

[listing,subs=+quotes]
----
<regular expression> ::= <regular term> ['|' <regular term> ...]

<regular term> ::= <regular factor> ...

<regular factor> ::= <regular primary> [<quantifier>]

<quantifier> ::= ? | * | + | '{' <m> [,[<n>]] '}'

<m>, <n> ::= _unsigned int, with <m> <= <n> if both present_

<regular primary> ::=
   <character> | <character class> | %
  | (<regular expression>)

<character> ::= <escaped character> | <non-escaped character>

<escaped character> ::=
  <escape-char> <special character> | <escape-char> <escape-char>

<special character> ::= __any of the characters []()|^-+*%\_?{}__

<non-escaped character> ::=
  __any character that is not a <special character>__
  __and not equal to <escape-char> (if defined)__

<character class> ::=
    '_' | '[' <member> ... ']' | '[^' <non-member> ... ']'
  | '[' <member> ... '^' <non-member> ... ']'

<member>, <non-member> ::= <character> | <range> | <predefined class>

<range> ::= <character>-<character>

<predefined class> ::= '[:' <predefined class name> ':]'

<predefined class name> ::=
  ALPHA | UPPER | LOWER | DIGIT | ALNUM | SPACE | WHITESPACE
----

[[fblangref25-commons-buildregex]]
====== Building Regular Expressions

In this section are the elements and rules for building SQL regular expressions.

[float]
[[fblangref25-commons-regexchar]]
====== Characters

Within regular expressions, most characters represent themselves.
The only exceptions are the special characters below:

[listing]
----
[ ] ( ) | ^ - + * % _ ? { }
----

$$...$$ and the _escape character_, if it is defined.

A regular expression that contains no special or escape characters matches only strings that are identical to itself (subject to the collation in use).
That is, it functions just like the '```=```' operator:

[source]
----
'Apple' similar to 'Apple'  -- true
'Apples' similar to 'Apple' -- false
'Apple' similar to 'Apples' -- false
'APPLE' similar to 'Apple'  -- depends on collation
----

[float]
[[fblangref25-commons-regexwildcards]]
====== Wildcards

The known SQL wildcards '```++_++```' and '```%```' match any single character and a string of any length, respectively:

[source]
----
'Birne' similar to 'B_rne'   -- true
'Birne' similar to 'B_ne'    -- false
'Birne' similar to 'B%ne'    -- true
'Birne' similar to 'Bir%ne%' -- true
'Birne' similar to 'Birr%ne' -- false
----

Notice how '```%```' also matches the empty string.

[float]
[[fblangref25-commons-regexcharclass]]
====== Character Classes

A bunch of characters enclosed in brackets define a character class.
A character in the string matches a class in the pattern if the character is a member of the class:

[source]
----
'Citroen' similar to 'Cit[arju]oen'     -- true
'Citroen' similar to 'Ci[tr]oen'        -- false
'Citroen' similar to 'Ci[tr][tr]oen'    -- true
----

As can be seen from the second line, the class only matches a single character, not a sequence.

Within a class definition, two characters connected by a hyphen define a range.
A range comprises the two endpoints and all the characters that lie between them in the active collation.
Ranges can be placed anywhere in the class definition without special delimiters to keep them apart from the other elements.

[source]
----
'Datte' similar to 'Dat[q-u]e'          -- true
'Datte' similar to 'Dat[abq-uy]e'       -- true
'Datte' similar to 'Dat[bcg-km-pwz]e'   -- false
----

[float]
[[fblangref25-commons-regexpredefclass]]
====== Predefined Character Classes

The following predefined character classes can also be used in a class definition:

`[:ALPHA:]`::
Latin letters a..z and A..Z.
With an accent-insensitive collation, this class also matches accented forms of these characters.

`[:DIGIT:]`::
Decimal digits 0..9.

`[:ALNUM:]`::
Union of `[:ALPHA:]` and `[:DIGIT:]`.

`[:UPPER:]`::
Uppercase Latin letters A..Z.
Also matches lowercase with case-insensitive collation and accented forms with accent-insensitive collation.

`[:LOWER:]`::
Lowercase Latin letters a..z.
Also matches uppercase with case-insensitive collation and accented forms with accent-insensitive collation.

`[:SPACE:]`::
Matches the space character (ASCII 32).

`[:WHITESPACE:]`::
Matches horizontal tab (ASCII 9), linefeed (ASCII 10), vertical tab (ASCII 11), formfeed (ASCII 12), carriage return (ASCII 13) and space (ASCII 32).

Including a predefined class has the same effect as including all its members.
Predefined classes are only allowed within class definitions.
If you need to match against a predefined class and nothing more, place an extra pair of brackets around it.

[source]
----
'Erdbeere' similar to 'Erd[[:ALNUM:]]eere'     -- true
'Erdbeere' similar to 'Erd[[:DIGIT:]]eere'     -- false
'Erdbeere' similar to 'Erd[a[:SPACE:]b]eere'   -- true
'Erdbeere' similar to [[:ALPHA:]]              -- false
'E'        similar to [[:ALPHA:]]              -- true
----

If a class definition starts with a caret, everything that follows is excluded from the class.
All other characters match:

[source]
----
'Framboise' similar to 'Fra[^ck-p]boise'       -- false
'Framboise' similar to 'Fr[^a][^a]boise'       -- false
'Framboise' similar to 'Fra[^[:DIGIT:]]boise'  -- true
----

If the caret is not placed at the start of the sequence, the class contains everything before the caret, except for the elements that also occur after the caret:

[source]
----
'Grapefruit' similar to 'Grap[a-m^f-i]fruit'   -- true
'Grapefruit' similar to 'Grap[abc^xyz]fruit'   -- false
'Grapefruit' similar to 'Grap[abc^de]fruit'    -- false
'Grapefruit' similar to 'Grap[abe^de]fruit'    -- false

'3' similar to '[[:DIGIT:]^4-8]'               -- true
'6' similar to '[[:DIGIT:]^4-8]'               -- false
----

Lastly, the already mentioned wildcard '```++_++```' is a character class of its own, matching any single character.

[float]
[[fblangref25-commons-regexquantifiers]]
====== Quantifiers

A question mark ('```?```') immediately following a character or class indicates that the preceding item may occur 0 or 1 times in order to match:

[source]
----
'Hallon' similar to 'Hal?on'                   -- false
'Hallon' similar to 'Hal?lon'                  -- true
'Hallon' similar to 'Halll?on'                 -- true
'Hallon' similar to 'Hallll?on'                -- false
'Hallon' similar to 'Halx?lon'                 -- true
'Hallon' similar to 'H[a-c]?llon[x-z]?'        -- true
----

An asterisk ('```{asterisk}```') immediately following a character or class indicates that the preceding item may occur 0 or more times in order to match:

[source]
----
'Icaque' similar to 'Ica*que'                  -- true
'Icaque' similar to 'Icar*que'                 -- true
'Icaque' similar to 'I[a-c]*que'               -- true
'Icaque' similar to '_*'                       -- true
'Icaque' similar to '[[:ALPHA:]]*'             -- true
'Icaque' similar to 'Ica[xyz]*e'               -- false
----

A plus sign ('```{plus}```') immediately following a character or class indicates that the preceding item must occur 1 or more times in order to match:

[source]
----
'Jujube' similar to 'Ju_+'                     -- true
'Jujube' similar to 'Ju+jube'                  -- true
'Jujube' similar to 'Jujuber+'                 -- false
'Jujube' similar to 'J[jux]+be'                -- true
'Jujube' sililar to 'J[[:DIGIT:]]+ujube'       -- false
----

If a character or class is followed by a number enclosed in braces ('```{```' and '```}```'), it must be repeated exactly that number of times in order to match:

[source]
----
'Kiwi' similar to 'Ki{2}wi'                    -- false
'Kiwi' similar to 'K[ipw]{2}i'                 -- true
'Kiwi' similar to 'K[ipw]{2}'                  -- false
'Kiwi' similar to 'K[ipw]{3}'                  -- true
----

If the number is followed by a comma ('```,```'), the item must be repeated at least that number of times in order to match:

[source]
----
'Limone' similar to 'Li{2,}mone'               -- false
'Limone' similar to 'Li{1,}mone'               -- true
'Limone' similar to 'Li[nezom]{2,}'            -- true
----

If the braces contain two numbers separated by a comma, the second number not smaller than the first, then the item must be repeated at least the first number and at most the second number of times in order to match:

[source]
----
'Mandarijn' similar to 'M[a-p]{2,5}rijn'       -- true
'Mandarijn' similar to 'M[a-p]{2,3}rijn'       -- false
'Mandarijn' similar to 'M[a-p]{2,3}arijn'      -- true
----

The quantifiers '```?```', '```{asterisk}```' and '```{plus}```' are shorthand for `{0,1}`, `{0,}` and `{1,}`, respectively.

[float]
[[fblangref25-commons-regexoring]]
====== OR-ing Terms

Regular expression terms can be OR'ed with the '```|```' operator.
A match is made when the argument string matches at least one of the terms:

[source]
----
'Nektarin' similar to 'Nek|tarin'              -- false
'Nektarin' similar to 'Nektarin|Persika'       -- true
'Nektarin' similar to 'M_+|N_+|P_+'            -- true
----

[float]
[[fblangref25-commons-regexsubexpr]]
====== Subexpressions

One or more parts of the regular expression can be grouped into subexpressions (also called subpatterns) by placing them between parentheses ('```(```' and '```)```').
A subexpression is a regular expression in its own right.
It can contain all the elements allowed in a regular expression, and can also have quantifiers added to it.

[source]
----
'Orange' similar to 'O(ra|ri|ro)nge'           -- true
'Orange' similar to 'O(r[a-e])+nge'            -- true
'Orange' similar to 'O(ra){2,4}nge'            -- false
'Orange' similar to 'O(r(an|in)g|rong)?e'      -- true
----

[float]
[[fblangref25-commons-regexescap]]
====== Escaping Special Characters

In order to match against a character that is special in regular expressions, that character has to be escaped.
There is no default escape character;
rather, the user specifies one when needed:

[source]
----
'Peer (Poire)' similar to 'P[^ ]+ \(P[^ ]+\)' escape '\'    -- true
'Pera [Pear]'  similar to 'P[^ ]+ #[P[^ ]+#]' escape '#'    -- true
'Päron-äppledryck' similar to 'P%$-ä%' escape '$'           -- true
'Pärondryck' similar to 'P%--ä%' escape '-'                 -- false
----

The last line demonstrates that the escape character can also escape itself, if needed. 

[[fblangref25-commons-isnotdistinct]]
===== `IS [NOT] DISTINCT FROM`

.Available
DSQL, PSQL

.Syntax
[listing]
----
<operand1> IS [NOT] DISTINCT FROM <operand2>
----

Two operands are considered _DISTINCT_ if they have a different value or if one of them is `NULL` and the other non-null.
They are _NOT DISTINCT_ if they have the same value or if both of them are `NULL`.

.See also
<<fblangref25-commons-isnotnull,`IS [NOT] NULL`>>

[[fblangref25-commons-isnotnull]]
===== `IS [NOT] NULL`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> IS [NOT] NULL
----

Since `NULL` is not a value, these operators are not comparison operators.
The `IS [NOT] NULL` predicate tests the assertion that the expression on the left side has a value (_IS NOT NULL_) or has no value (_IS NULL_).

.Example
Search for sales entries that have no shipment date set for them:

[source]
----
SELECT * FROM SALES
WHERE SHIP_DATE IS NULL;
----

.Note regarding the `IS` predicates
[NOTE]
====
Up to and including Firebird 2.5, the `IS` predicates, like the other comparison predicates, do not have precedence over the others.
In Firebird 3.0 and higher, these predicates take precedence above the others.
====

[[fblangref25-commons-existential]]
=== Existential Predicates

This group of predicates includes those that use subqueries to submit values for all kinds of assertions in search conditions.
Existential predicates are so called because they use various methods to test for the [term]_existence_ or [term]_non-existence_ of some assertion, returning `TRUE` if the existence or non-existence is confirmed or `FALSE` otherwise.

[[fblangref25-commons-exists]]
==== `EXISTS`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
[NOT] EXISTS (<select_stmt>)
----

The `EXISTS` predicate uses a subquery expression as its argument.
It returns `TRUE` if the subquery result would contain at least one row; otherwise it returns `FALSE`.

`NOT EXISTS` returns `FALSE` if the subquery result would contain at least one row; it returns `TRUE` otherwise.

[NOTE]
====
The subquery can specify multiple columns, or `SELECT {asterisk}`, because the evaluation is made on the number of rows that match its criteria, not on the data.
====

.Examples
. Find those employees who have projects.
+
[source]
----
SELECT *
FROM employee
WHERE EXISTS(SELECT *
             FROM  employee_project ep
             WHERE ep.emp_no = employee.emp_no)
----
. Find those employees who have no projects.
+
[source]
----
SELECT *
FROM employee
WHERE NOT EXISTS(SELECT *
                 FROM employee_project ep
                 WHERE ep.emp_no = employee.emp_no)
----

[[fblangref25-commons-in]]
==== `IN`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> [NOT] IN (<select_stmt> | <value_list>)

<value_list> ::= <value_1> [, <value_2> …]
----

The `IN` predicate tests whether the value of the expression on the left side is present in the set of values specified on the right side.
The set of values cannot have more than 1500 items.
The `IN` predicate can be replaced with the following equivalent forms:

[listing]
----
(<value> = <value_1> [OR <value> = <value_2> …])

<value> = { ANY | SOME } (<select_stmt>)
----

When the `IN` predicate is used in the search conditions of DML queries, the Firebird optimizer can use an index on the searched column, if a suitable one exists.

In its second form, the `IN` predicate tests whether the value of the expression on the left side is present -- or not present, if `NOT IN` is used -- in the result of the executed subquery on the right side.

The subquery must be specified to result in only one column, otherwise the error "`count of column list and variable list do not match`" will occur.

Queries specified using the `IN` predicate with a subquery can be replaced with a similar query using the `EXISTS` predicate.
For instance, the following query:

[source]
----
SELECT
  model, speed, hd
FROM PC
WHERE
model IN (SELECT model
          FROM product
          WHERE maker = 'A');
----

can be replaced with a similar one using the EXISTS predicate:

[source]
----
SELECT
  model, speed, hd
FROM PC
WHERE
 EXISTS (SELECT *
         FROM product
         WHERE maker = 'A'
           AND product.model = PC.model);
----

However, a query using `NOT IN` with a subquery does not always give the same result as its `NOT EXISTS` counterpart.
The reason is that `EXISTS` always returns TRUE or FALSE, whereas `IN` returns `NULL` in one of these two cases:

[loweralpha]
. when the test value is `NULL` and the `IN ()` list is not empty
. when the test value has no match in the `IN ()` list and at least one list element is `NULL`

It is in only these two cases that `IN ()` will return `NULL` while the corresponding `EXISTS` predicate will return `FALSE` ('no matching row found').
In a search or, for example, an `IF (...)` statement, both results mean "`failure`" and it makes no difference to the outcome.

But, for the same data, `NOT IN ()` will return `NULL`, while `NOT EXISTS` will return `TRUE`, leading to opposite results.

As an example, suppose you have the following query:

[source]
----
-- Looking for people who were not born
-- on the same day as any famous New York citizen
SELECT P1.name AS NAME
FROM Personnel P1
WHERE P1.birthday NOT IN (SELECT C1.birthday
                          FROM Celebrities C1
                          WHERE C1.birthcity = 'New York');
----

Now, assume that the NY celebrities list is not empty and contains at least one NULL birthday.
Then for every citizen who does not share his birthday with a NY celebrity, `NOT IN` will return `NULL`, because that is what `IN` does.
The search condition is thereby not satisfied and the citizen will be left out of the `SELECT` result, which is wrong.

For citizens whose birthday does match with a celebrity's birthday, `NOT IN` will correctly return `FALSE`, so they will be left out too, and no rows will be returned.

If the `NOT EXISTS` form is used:

[source]
----
-- Looking for people who were not born
-- on the same day as any famous New York citizen
SELECT P1.name AS NAME
FROM Personnel P1
WHERE NOT EXISTS (SELECT *
                  FROM Celebrities C1
                  WHERE C1.birthcity = 'New York'
                    AND C1.birthday = P1.birthday);
----

non-matches will have a `NOT EXISTS` result of `TRUE` and their records will be in the result set.

.Advice
[CAUTION]
====
If there is any chance of ``NULL``s being encountered when searching for a non-match, you will want to use `NOT EXISTS`.
====

.Examples of use
. Find employees with the names "`Pete`", "`Ann`" and "`Roger`":
+
[source]
----
SELECT *
FROM EMPLOYEE
WHERE FIRST_NAME IN ('Pete', 'Ann', 'Roger');
----
. Find all computers that have models whose manufacturer starts with the letter "`A`":
+
[source]
----
SELECT
  model, speed, hd
FROM PC
WHERE
  model IN (SELECT model
            FROM product
            WHERE maker STARTING WITH 'A');
----

.See also
<<fblangref25-commons-exists,EXISTS>>

[[fblangref25-commons-singular]]
==== `SINGULAR`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
[NOT] SINGULAR (<select_stmt>)
----

The `SINGULAR` predicate takes a subquery as its argument and evaluates it as TRUE if the subquery returns exactly one result row; otherwise the predicate is evaluated as FALSE.
The subquery may list several output columns since the rows are not returned anyway.
They are only tested for (singular) existence.
For brevity, people usually specify '```SELECT {asterisk}```'.
The `SINGULAR` predicate can return only two values: `TRUE` or `FALSE`.

.Example
Find those employees who have only one project.

[source]
----
SELECT *
FROM employee
WHERE SINGULAR(SELECT *
               FROM employee_project ep
               WHERE ep.emp_no = employee.emp_no)
----

[[fblangref25-commons-quantifiedsq]]
=== Quantified Subquery Predicates

A quantifier is a logical operator that sets the number of objects for which this assertion is true.
It is not a numeric quantity, but a logical one that connects the assertion with the full set of possible objects.
Such predicates are based on logical universal and existential quantifiers that are recognised in formal logic.

In subquery expressions, quantified predicates make it possible to compare separate values with the results of subqueries;
they have the following common form:

[source]
----
<value expression> <comparison operator> <quantifier> <subquery>
----

[[fblangref25-commons-quant-all]]
==== `ALL`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> <op> ALL (<select_stmt>)
----

When the `ALL` quantifier is used, the predicate is TRUE if every value returned by the subquery satisfies the condition in the predicate of the main query.

.Example
Show only those clients whose ratings are higher than the rating of every client in Paris.

[source]
----
SELECT c1.*
FROM Customers c1
WHERE c1.rating > ALL
      (SELECT c2.rating
       FROM Customers c2
       WHERE c2.city = 'Paris')
----

[IMPORTANT]
====
If the subquery returns an empty set, the predicate is TRUE for every left-side value, regardless of the operator.
This may appear to be contradictory, because every left-side value will thus be considered both smaller and greater than, both equal to and unequal to, every element of the right-side stream.

Nevertheless, it aligns perfectly with formal logic: if the set is empty, the predicate is true 0 times, i.e., for every row in the set.
====

[[fblangref25-commons-quant-anysome]]
==== `ANY` and `SOME`

.Available
DSQL, PSQL, ESQL

.Syntax
[listing]
----
<value> <op> {ANY | SOME} (<select_stmt>)
----

The quantifiers `ANY` and `SOME` are identical in their behaviour.
Apparently, both are present in the SQL standard so that they could be used interchangeably in order to improve the readability of operators.
When the `ANY` or the `SOME` quantifier is used, the predicate is TRUE if any of the values returned by the subquery satisfies the condition in the predicate of the main query.
If the subquery would return no rows at all, the predicate is automatically considered as FALSE.

.Example
Show only those clients whose ratings are higher than those of one or more clients in Rome.

[source]
----
SELECT *
FROM Customers
WHERE rating > ANY
      (SELECT rating
       FROM Customers
       WHERE city = 'Rome')
----
