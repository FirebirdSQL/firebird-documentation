[[fblangref25-ddl]]
= Data Definition (DDL) Statements

DDL is the data definition language subset of Firebird's SQL language.
DDL statements are used to create, modify and delete database objects that have been created by users.
When a DDL statement is committed, the metadata for the object are created, changed or deleted.

[[fblangref25-ddl-db]]
== `DATABASE`

This section describes how to create a database, connect to an existing database, alter the file structure of a database and how to delete one.
It also explains how to back up a database in two quite different ways and how to switch the database to the "`copy-safe`" mode for performing an external backup safely.

[[fblangref25-ddl-db-create]]
=== `CREATE DATABASE`

.Used for
Creating a new database

.Available in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
CREATE {DATABASE | SCHEMA} <filespec>
  [USER '_username_' [PASSWORD '_password_']]
  [PAGE_SIZE [=] _size_]
  [LENGTH [=] _num_ [PAGE[S]]
  [SET NAMES '_charset_']
  [DEFAULT CHARACTER SET _default_charset_
    [COLLATION _collation_]] -- _not supported in ESQL_
  [<sec_file> [<sec_file> ...]]
  [DIFFERENCE FILE '_diff_file_'] -- _not supported in ESQL_

<filespec> ::= "'" [_server_spec_]{_filepath_ | _db_alias_} "'"

<server_spec> ::= _servername_[/{_port_|_service_}]: | {backslash}{backslash}__servername__\

<sec_file> ::=
  FILE '_filepath_'
  [LENGTH [=] _num_ [PAGE[S]]
  [STARTING [AT [PAGE]] _pagenum_]
----

[[fblangref25-ddl-tbl-createdatabase]]
.`CREATE DATABASE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|filespec
|File specification for primary database file

|server_spec
|Remote server specification in TCP/IP or Windows Networking style.
Optionally includes a port number or service name

|filepath
|Full path and file name including its extension.
The file name must be specified according to the rules of the platform file system being used.

|db_alias
|Database alias previously created in the [path]`aliases.conf` file

|servername
|Host name or IP address of the server where the database is to be created

|username
|User name of the owner of the new database.
It may consist of up to 31 characters.
Case-insensitive

|password
|Password of the user name as the database owner.
The maximum length is 31 characters;
however only the first 8 characters are considered.
Case-sensitive

|size
|Page size for the database, in bytes.
Possible values are 4096 (the default), 8192 and 16384

|num
|Maximum size of the primary database file, or a secondary file, in pages

|charset
|Specifies the character set of the connection available to a client connecting after the database is successfully created.
Single quotes are required

|default_charset
|Specifies the default character set for string data types

|collation
|Default collation for the default character set

|sec_file
|File specificaton for a secondary file

|pagenum
|Starting page number for a secondary database file

|diff_file
|File path and name for DIFFERENCE files (.delta files)
|===

The `CREATE DATABASE` statement creates a new database.
You can use `CREATE DATABASE` or ``CREATE SCHEMA``.
They are synonymous.

A database may consist of one or several files.
The first (main) file is called the _primary file_, subsequent files are called _secondary file[s]_.

.Multi-file Databases
[NOTE]
====
Nowadays, multi-file databases are considered an anachronism.
It made sense to use multi-file databases on old file systems where the size of any file is limited.
For instance, you could not create a file larger than 4 GB on FAT32.
====

The primary file specification is the name of the database file and its extension with the full path to it according to the rules of the OS platform file system being used.
The database file must not exist at the moment when the database is being created.
If it does exist, you will get an error message and the database will not be created.

If the full path to the database is not specified, the database will be created in one of the system directories.
The particular directory depends on the operating system.
For this reason, unless you have a strong reason to prefer that situation, always specify the absolute path, when creating either the database or an _alias_ for it.

[[fblangref25-ddl-db-alias]]
==== Using a Database Alias

You can use aliases instead of the full path to the primary database file.
Aliases are defined in the [path]` aliases.conf` file in the following format:

[listing,subs=+quotes]
----
_alias_ = _filepath_
----

[[fblangref25-ddl-db-createremote]]
==== Creating a Database Remotely

If you create a database on a remote server, you should specify the remote server specification.
The remote server specification depends on the protocol being used.
If you use the TCP/IP protocol to create a database, the primary file specification should look like this:

[listing]
----
_servername_[/{_port_|_service_}]:{_filepath_ | _db_alias_}
----

If you use the Named Pipes protocol to create a database on a Windows server, the primary file specification should look like this:

[listing,subs="+quotes,attributes"]
----
{backslash}{backslash}__servername__\{_filepath_ | _db_alias_}
----

[[fblangref25-ddl-db-createdbopts]]
==== Optional Parameters for `CREATE DATABASE`

`USER` and `PASSWORD`::
Clauses for specifying the user name and the password, respectively, of an existing user in the security database [path]`security2.fdb`.
You do not have to specify the username and password if the `ISC_USER` and `ISC_PASSWORD` environment variables are set.
The user specified in the process of creating the database will be its owner.
This will be important when considering database and object privileges.

`PAGE_SIZE`::
Clause for specifying the database page size.
This size will be set for the primary file and all secondary files of the database.
If you specify the database page size less than 4,096, it will be changed automatically to the default page size, 4,096.
Other values not equal to either 4,096, 8,192 or 16,384 will be changed to the closest smaller supported value.
If the database page size is not specified, it is set to the default value of 4,096.

`LENGTH`::
Clause specifying the maximum size of the primary or secondary database file, in pages.
When a database is created, its primary and secondary files will occupy the minimum number of pages necessary to store the system data, regardless of the value specified in the `LENGTH` clause.
The `LENGTH` value does not affect the size of the only (or last, in a multi-file database) file.
The file will keep increasing its size automatically when necessary.

`SET NAMES`::
Clause specifying the character set of the connection available after the database is successfully created.
The character set `NONE` is used by default.
Notice that the character set should be enclosed in a pair of apostrophes (single quotes).

`DEFAULT CHARACTER SET`::
Clause specifying the default character set for creating data structures of string data types.
Character sets are applied to ``CHAR``, `VARCHAR` and  `BLOB TEXT` data types.
The character set `NONE` is used by default.
It is also possible to specify the default `COLLATION` for the default character set, making that collation sequence the default for the default character set.
The default will be used for the entire database except where an alternative character set, with or without a specified collation, is used explicitly for a field, domain, variable, cast expression, etc.

`STARTING AT`::
Clause that specifies the database page number at which the next secondary database file should start.
When the previous file is completely filled with data according to the specified page number, the system will start adding new data to the next database file.

`DIFFERENCE FILE`::
Clause specifying the path and name for the file delta that stores any mutations to the database file after it has been switched to the "`copy-safe`" mode by the `ALTER DATABASE BEGIN BACKUP` statement.
For the detailed description of this clause, see `ALTER DATABASE`.

`SET SQL DIALECT`::
Databases are created in Dialect 3 by default.
For the database to be created in SQL dialect 1, you will need to execute the statement `SET SQL DIALECT 1` from script or the client application, e.g. in _isql_, before the `CREATE DATABASE` statement.

[[fblangref25-ddl-db-createdbexamples]]
==== Examples Using `CREATE DATABASE`

. Creating a database in Windows, located on disk D with a page size of 8,192.
The owner of the database will be the user _wizard_.
The database will be in Dialect 1 and it will use `WIN1251` as its default character set.
+
[source]
----
SET SQL DIALECT 1;
CREATE DATABASE 'D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192 DEFAULT CHARACTER SET WIN1251;
----
. Creating a database in the Linux operating system with a page size of 4,096.
The owner of the database will be the user _wizard_.
The database will be in Dialect 3 and it will use `UTF8` as its default character set, with `UNICODE_CI_AI` as the default collation.
+
[source]
----
CREATE DATABASE '/home/firebird/test.fdb'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8 COLLATION UNICODE_CI_AI;
----
. Creating a database on the remote server "`baseserver`" with the path specified in the alias "`test`" that has been defined previously in the file [path]`aliases.conf`.
The TCP/IP protocol is used.
The owner of the database will be the user _wizard_.
The database will be in Dialect 3 and will use `UTF8` as its default character set.
+
[source]
----
CREATE DATABASE 'baseserver:test'
USER 'wizard' PASSWORD 'player'
DEFAULT CHARACTER SET UTF8;
----
. Creating a database in Dialect 3 with `UTF8` as its default character set.
The primary file will contain up to 10,000 pages with a page size of 8,192.
As soon as the primary file has reached the maximum number of pages, Firebird will start allocating pages to the secondary file [path]`test.fdb2`.
If that file is filled up to its maximum as well, [path]`test.fdb3` becomes the recipient of all new page allocations.
As the last file, it has no page limit imposed on it by Firebird.
New allocations will continue for as long as the file system allows it or until the storage device runs out of free space.
If a `LENGTH` parameter were supplied for this last file, it would be ignored.
+
[source]
----
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
STARTING AT PAGE 10001
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
----
. Creating a database in Dialect 3 with `UTF8` as its default character set.
The primary file will contain up to 10,000 pages with a page size of 8,192.
As far as file size and the use of secondary files are concerned, this database will behave exactly like the one in the previous example.
+
[source]
----
SET SQL DIALECT 3;
CREATE DATABASE 'baseserver:D:\test.fdb'
USER 'wizard' PASSWORD 'player'
PAGE_SIZE = 8192
LENGTH 10000 PAGES
DEFAULT CHARACTER SET UTF8
FILE 'D:\test.fdb2'
FILE 'D:\test.fdb3'
STARTING AT PAGE 20001;
----

.See also
<<fblangref25-ddl-db-alter,`ALTER DATABASE`>>, <<fblangref25-ddl-db-drop,`DROP DATABASE`>>

[[fblangref25-ddl-db-alter]]
=== `ALTER DATABASE`

.Used for
Altering the file organisation of a database or toggling its "`copy-safe`" state

.Available in
DSQL -- both functions.
ESQL -- file reorganisation only

.Syntax
[listing,subs=+quotes]
----
ALTER {DATABASE | SCHEMA}
  [<add_sec_clause> [<add_sec_clause> ...]]
  [ADD DIFFERENCE FILE '_diff_file_' | DROP DIFFERENCE FILE]
  [{BEGIN | END} BACKUP]

<add_sec_clause> ::= ADD <sec_file> [<sec_file> ...]

<sec_file> ::=
  FILE '_filepath_'
  [STARTING [AT [PAGE]] _pagenum_]
  [LENGTH [=] _num_ [PAGE[S]]
----

[NOTE]
====
Multiple files can be added in one ADD clause: 
[source]
----
ALTER DATABASE
  ADD FILE x LENGTH 8000
    FILE y LENGTH 8000
    FILE z
----

Multiple `ADD FILE` clauses are allowed;
and an `ADD FILE` clause that adds multiple files (as in the example above) can be mixed with others that add only one file.
The statement was documented incorrectly in the old [ref]_InterBase 6 Language Reference_.
====

[[fblangref25-ddl-tbl-alterdatabase]]
.`ALTER DATABASE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|add_sec_clause
|Adding a secondary database file

|sec_file
|File specification for secondary file

|filepath
|Full path and file name of the delta file or the secondary database file

|pagenum
|Page number from which the secondary database file is to start

|num
|Maximum size of the secondary file in pages

|diff_file
|File path and name of the .delta file (difference file)
|===

The `ALTER DATABASE` statement can:

* add secondary files to a database
* switch a single-file database into and out of the "`copy-safe`" mode (DSQL only)
* set or unset the path and name of the delta file for physical backups (DSQL only)

Only <<fblangref25-security-administrators,administrators>>  have the authority to use `ALTER DATABASE`.

[[fblangref25-ddl-db-alterdbopts]]
==== Parameters for `ALTER DATABASE`

`ADD FILE`::
Adds a secondary file to the database.
It is necessary to specify the full path to the file and the name of the secondary file.
The description for the secondary file is similar to the one given for the `CREATE DATABASE` statement.

`ADD DIFFERENCE FILE`::
specifies the path and name of the delta file that stores any mutations to the database whenever it is switched to the "`copy-safe`" mode.
This clause does not actually add any file.
It just overrides the default name and path of the .delta file.
To change the existing settings, you should delete the previously specified description of the .delta file using the `DROP DIFFERENCE FILE` clause before specifying the new description of the delta file.
If the path and name of the .delta file are not overridden, the file will have the same path and name as the database, but with the [path]`.delta` file extension.
+
[CAUTION]
====
If only a file name is specified, the .delta file will be created in the current directory of the server.
On Windows, this will be the system directory -- a very unwise location to store volatile user files and contrary to Windows file system rules.
====

`DROP DIFFERENCE FILE`::
This is the clause that deletes the description (path and name) of the .delta file specified previously in the `ADD DIFFERENCE FILE` clause.
The file is not actually deleted.
`DROP DIFFERENCE FILE` deletes the path and name of the .delta file from the database header.
Next time the database is switched to the "`copy-safe`" mode, the default values will be used (i.e. the same path and name as those of the database, but with the .delta extension).

`BEGIN BACKUP`::
This is the clause that switches the database to the "`copy-safe`" mode. `ALTER DATABASE` with this clause freezes the main database file, making it possible to back it up safely using file system tools, even if users are connected and performing operations with data.
Until the backup state of the database is reverted to ``NORMAL``, all changes made to the database will be written to the .delta (difference) file. 
+
[IMPORTANT]
====
Despite its syntax, a statement with the `BEGIN BACKUP` clause does not start a backup process but just creates the conditions for doing a task that requires the database file to be read-only temporarily.
====

`END BACKUP`::
This is the clause used to switch the database from the "`copy-safe`" mode to the normal mode.
A statement with this clause merges the .delta file with the main database file and restores the normal operation of the database.
Once the `END BACKUP` process starts, the conditions  no longer exist for creating safe backups by means of file system tools.

[WARNING]
====
Use of `BEGIN BACKUP` and `END BACKUP` and copying the database files with filesystem tools, is _not safe_ with multi-file databases!
Use this method only on single-file databases.

Making a safe backup with the _gbak_ utility remains possible at all times, although it is not recommended to run _gbak_ while the database is in _LOCKED_ or _MERGE_ state.
====

==== Examples of `ALTER DATABASE` Usage

. Adding a secondary file to the database.
As soon as 30000 pages are filled in the previous primary or secondary file, the Firebird engine will start adding data to the secondary file [path]`test4.fdb`.
+
[source]
----
ALTER DATABASE
  ADD FILE 'D:\test4.fdb'
    STARTING AT PAGE 30001;
----
. Specifying the path and name of the delta file:
+
[source]
----
ALTER DATABASE
  ADD DIFFERENCE FILE 'D:\test.diff';
----
. Deleting the description of the delta file:
+
[source]
----
ALTER DATABASE
  DROP DIFFERENCE FILE;
----
. Switching the database to the "`copy-safe`" mode:
+
[source]
----
ALTER DATABASE
  BEGIN BACKUP;
----
. Switching the database back from the "`copy-safe`" mode to the normal operation mode:
+
[source]
----
ALTER DATABASE
  END BACKUP;
----

.See also
<<fblangref25-ddl-db-create,`CREATE DATABASE`>>, <<fblangref25-ddl-db-drop,`DROP DATABASE`>>

[[fblangref25-ddl-db-drop]]
=== `DROP DATABASE`

.Used for
Deleting the database to which you are currently connected

.Available in
DSQL, ESQL

.Syntax
[listing]
----
DROP DATABASE
----

The `DROP DATABASE` statement deletes the current database.
Before deleting a database, you have to connect to it.
The statement deletes the primary file, all secondary files and all <<fblangref25-ddl-shadow,shadow files>>.

Only <<fblangref25-security-administrators,administrators>> have the authority to use `DROP DATABASE`.

.Example
Deleting the database the client is connected to.

[source]
----
DROP DATABASE;
----

.See also
<<fblangref25-ddl-db-create,`CREATE DATABASE`>>, <<fblangref25-ddl-db-alter,`ALTER DATABASE`>>

[[fblangref25-ddl-shadow]]
== SHADOW

A _shadow_ is an exact, page-by-page copy of a database.
Once a shadow is created, all changes made in the database are immediately reflected in the shadow.
If the primary database file becomes unavailable for some reason, the DBMS will switch to the shadow.

This section describes how to create and delete shadow files.

[[fblangref25-ddl-createshadow]]
=== `CREATE SHADOW`

.Used for
Creating a shadow for the current database

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE SHADOW <sh_num> [AUTO | MANUAL] [CONDITIONAL]
  '_filepath_' [LENGTH [=] _num_ [PAGE[S]]]
  [<secondary_file> ...]

<secondary_file> ::=
  FILE '_filepath_'
  [STARTING [AT [PAGE]] _pagenum_]
  [LENGTH [=] _num_ [PAGE[S]]]
----

[[fblangref25-ddl-tbl-createshadow]]
.`CREATE SHADOW` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|sh_num
|Shadow number -- a positive number identifying the shadow set

|filepath
|The name of the shadow file and the path to it, in accord with the rules of the operating system

|num
|Maximum shadow size, in pages

|secondary_file
|Secondary file specification

|page_num
|The number of the page at which the secondary shadow file should start
|===

The `CREATE SHADOW` statement creates a new shadow.
The shadow starts duplicating the database right at the moment it is created.
It is not possible for a user to connect to a shadow.

Like a database, a shadow may be multi-file.
The number and size of a shadow's files are not related to the number and size of the files of database it is shadowing.

The page size for shadow files is set to be equal to the database page size and cannot be changed.

If a calamity occurs involving the original database, the system converts the shadow to a copy of the database and switches to it.
The shadow is then _unavailable_.
What happens next depends on the `MODE` option.

[[fblangref25-ddl-createshadowmode]]
==== `AUTO | MANUAL` Modes

When a shadow is converted to a database, it becomes unavailable.
A shadow might alternatively become unavailable because someone accidentally deletes its file, or the disk space where the shadow files are stored is exhausted or is itself damaged. 

* If the AUTO mode is selected (the default value), shadowing ceases automatically, all references to it are deleted from the database header and the database continues functioning normally.
+ 
If the `CONDITIONAL` option was set, the system will attempt to create a new shadow to replace the lost one.
It does not always succeed, however, and a new one may need to be created manually.
* If the MANUAL mode attribute is set when the shadow becomes unavailable, all attempts to connect to the database and to query it will produce error messages.
The database will remain inaccessible until either the shadow again becomes available or the database administrator deletes it using the `DROP SHADOW` statement.
MANUAL should be selected if continuous shadowing is more important than uninterrupted operation of the database.

[[fblangref25-ddl-createshadowopts]]
==== Options for `CREATE SHADOW`

`LENGTH`::
Clause specifying the maximum size of the primary or secondary shadow file in pages.
The `LENGTH` value does not affect the size of the only shadow file, nor the last if it is a set.
The last (or only) file will keep automatically increasing in size as long as it is necessary.

`STARTING AT`::
Clause specifying the shadow page number at which the next shadow file should start.
The system will start adding new data to the next shadow file when the previous file is filled with data up to the specified page number.

Only <<fblangref25-security-administrators,administrators>> have the authority to use `CREATE SHADOW`.

[TIP]
====
You can verify the sizes, names and location of the shadow files by connecting to the database using _isql_ and running the command `SHOW DATABASE;`
====

==== Examples Using `CREATE SHADOW`

. Creating a shadow for the current database as "`shadow number 1`":
+
[source]
----
CREATE SHADOW 1 'g:\data\test.shd';
----
. Creating a multi-file shadow for the current database as "`shadow number 2`":
+
[source]
----
CREATE SHADOW 2 'g:\data\test.sh1'
  LENGTH 8000 PAGES
  FILE 'g:\data\test.sh2';
----

.See also
<<fblangref25-ddl-db-create,`CREATE DATABASE`>>, <<fblangref25-ddl-dropshadow,`DROP SHADOW`>>

[[fblangref25-ddl-dropshadow]]
=== `DROP SHADOW`

.Used for
Deleting a shadow from the current database

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP SHADOW _sh_num_
----

[[fblangref25-ddl-tbl-dropshadow]]
.`DROP SHADOW` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|sh_num
|Shadow number -- a positive number identifying the shadow set
|===

The `DROP SHADOW` statement deletes the specified shadow for the database one is connected to.
When a shadow is dropped, all files related to it are deleted and shadowing to the specified _sh_num_ ceases.

Only <<fblangref25-security-administrators,administrators>> have the authority to use `DROP SHADOW`.

.Example of Dropping a Shadow
Deleting "`shadow number 1`". 
[source]
----
DROP SHADOW 1;
----

.See also
<<fblangref25-ddl-createshadow,`CREATE SHADOW`>>

[[fblangref25-ddl-domn]]
== `DOMAIN`

`DOMAIN` is one of the object types in a relational database.
A domain is created as a specific data type with some attributes attached to it.
Once it has been defined in the database, it can be reused repeatedly to define table columns, PSQL arguments and PSQL local variables.
Those objects inherit all of the attributes of the domain.
Some attributes can be overridden when the new object is defined, if required.

This section describes the syntax of statements used to create, modify and delete domains.
A detailed description of domains and their usage can be found in <<fblangref25-datatypes-custom,Custom Data Types -- Domains>>.

[[fblangref25-ddl-domn-create]]
=== `CREATE DOMAIN`

.Used for
Creating a new domain

.Available in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
CREATE DOMAIN _name_ [AS] <datatype>
  [DEFAULT {<literal> | NULL | <context_var>}]
  [NOT NULL] [CHECK (<dom_condition>)]
  [COLLATE _collation_name_]

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT} [<array_dim>]
  | {FLOAT | DOUBLE PRECISION} [<array_dim>]
  | {DATE | TIME | TIMESTAMP} [<array_dim>]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] [<array_dim>]
  | {{CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [<array_dim>] [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)] [<array_dim>]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<array_dim> ::= '[' [_m_:{endsb}__n__ [,[_m_:{endsb}__n__ ...] ']'

<dom_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<dom_condition>)
  | NOT <dom_condition>
  | <dom_condition> OR <dom_condition>
  | <dom_condition> AND <dom_condition>

<operator> ::= 
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    VALUE
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-createdomn]]
.`CREATE DOMAIN` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|name
|Domain name consisting of up to 31 characters

|datatype
|SQL data type

|literal
|A literal value that is compatible with _datatype_

|context_var
|Any context variable whose type is compatible with _datatype_

|dom_condition
|Domain condition

|collation_name
|Name of a collation sequence that is valid for _charset_name_, if it is supplied with _datatype_ or, otherwise, is valid for the default character set of the database

|array_dim
|Array dimensions

|m, n
|Integer numbers defining the index range of an array dimension

|precision
|The total number of significant digits that a value of the _datatype_ can hold (1..18)

|scale
|The number of digits after the decimal point (0..__precision__)

|size
|The maximum size of a string in characters

|charset_name
|The name of a valid character set, if the character set of the domain is to be different to the default character set of the database

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size (max. 65535)

|select_one
|A scalar `SELECT` statement -- selecting one column and returning only one row

|select_list
|A `SELECT` statement selecting one column and returning zero or more rows

|select_expr
|A `SELECT` statement selecting one or more columns and returning zero or more rows

|expression
|An expression resolving to a value that is compatible with _datatype_

|genname
|Sequence (generator) name

|func
|Internal function or UDF
|===

The `CREATE DOMAIN` statement creates a new domain.

Any SQL data type can be specified as the domain type.

[[fblangref25-ddl-domn-typespec]]
==== Type-specific Details

`ARRAY` Types::
* If the domain is to be an array, the base type can be any SQL data type except `BLOB` and `ARRAY`.
* The dimensions of the array are specified between square brackets.
(In the Syntax block, these brackets appear in quotes to distinguish them from the square brackets that identify optional syntax elements.)
* For each array dimension, one or two integer numbers define the lower and upper boundaries of its index range:
** By default, arrays are 1-based.
The lower boundary is implicit and only the upper boundary need be specified.
A single number smaller than 1 defines the range __num__..1 and a number greater than 1 defines the range 1..__num__.
** Two numbers separated by a colon ('```:```') and optional whitespace, the second greater than the first, can be used to define the range explicitly.
One or both boundaries can be less than zero, as long as the upper boundary is greater than the lower.
* When the array has multiple dimensions, the range definitions for each dimension must be separated by commas and optional whitespace.
* Subscripts are validated _only_ if an array actually exists.
It means that no error messages regarding invalid subscripts will be returned if selecting a specific element returns nothing or if an array field is [constant]`NULL`.

`CHARACTER` Types::
You can use the `CHARACTER SET` clause to specify the character set for the `CHAR`, `VARCHAR` and `BLOB` (`SUB_TYPE TEXT`) types.
If the character set is not specified, the character set specified as `DEFAULT CHARACTER SET` in creating the database will be used.
If no character set was specified then, the character set `NONE` is applied by default when you create a character domain. 
+
[WARNING]
====
With character set `NONE`, character data are stored and retrieved the way they were submitted.
Data in any encoding can be added to a column based on such a domain, but it is impossible to add this data to a column with a different encoding.
Because no transliteration is performed between the source and destination encodings, errors may result.
====

`DEFAULT` Clause::
The optional `DEFAULT` clause allows you to specify a default value for the domain.
This value will be added to the table column that inherits this domain when the `INSERT` statement is executed, if no value is specified for it in the DML statement.
Local variables and arguments in PSQL modules that reference this domain will be initialized with the default value.
For the default value, use a literal of a compatible type or a context variable of a compatible type.

`NOT NULL` Constraint::
Columns and variables based on a domain with the `NOT NULL` constraint will be prevented from being written as `NULL`, i.e., a value is _required_.
+
[CAUTION]
====
When creating a domain, take care to avoid specifying limitations that would contradict one another.
For instance, `NOT NULL` and `DEFAULT NULL` are contradictory.
====

`CHECK` Constraint[s]::
The optional `CHECK` clause specifies constraints for the domain.
A domain constraint specifies conditions that must be satisfied by the values of table columns or variables that inherit from the domain.
A condition must be enclosed in parentheses.
A condition is a logical expression (also called a predicate) that can return the Boolean results `TRUE`, `FALSE` and `UNKNOWN`.
A condition is considered satisfied if the predicate returns the value `TRUE` or "`unknown value`" (equivalent to `NULL`). If the predicate returns `FALSE`, the condition for acceptance is not met.

`VALUE` Keyword::
The keyword `VALUE` in a domain constraint substitutes for the table column that is based on this domain or for a variable in a PSQL module.
It contains the value assigned to the variable or the table column. `VALUE` can be used anywhere in the `CHECK` constraint, though it is usually used in the left part of the condition.

`COLLATE`::
The optional `COLLATE` clause allows you to specify the collation sequence if the domain is based on one of the string data types, including ``BLOB``s with text subtypes.
If no collation sequence is specified, the collation sequence will be the one that is default for the specified character set at the time the domain is created.

Any user connected to the database can create a domain.

[[fblangref25-ddl-createdomnexmpls]]
==== `CREATE DOMAIN` Examples

. Creating a domain that can take values greater than 1,000, with a default value of 10,000.
+
[source]
----
CREATE DOMAIN CUSTNO AS
  INTEGER DEFAULT 10000
  CHECK (VALUE > 1000);
----
. Creating a domain that can take the values 'Yes' and 'No' in the default character set specified during the creation of the database.
+
[source]
----
CREATE DOMAIN D_BOOLEAN AS
  CHAR(3) CHECK (VALUE IN ('Yes', 'No'));
----
. Creating a domain with the `UTF8` character set and the `UNICODE_CI_AI` collation sequence.
+
[source]
----
CREATE DOMAIN FIRSTNAME AS
  VARCHAR(30) CHARACTER SET UTF8
  COLLATE UNICODE_CI_AI;
----
. Creating a domain of the `DATE` type that will not accept NULL and uses the current date as the default value.
+
[source]
----
CREATE DOMAIN D_DATE AS
  DATE DEFAULT CURRENT_DATE
  NOT NULL;
----
. Creating a domain defined as an array of 2 elements of the `NUMERIC(18, 3)` type. The starting array index is 1.
+
[source]
----
CREATE DOMAIN D_POINT AS
  NUMERIC(18, 3) [2];
----
+
NOTE: Domains defined over an array type may be used only to define table columns.
You cannot use array domains to define local variables in PSQL modules.
+
. Creating a domain whose elements can be only country codes defined in the `COUNTRY` table.
+
[source]
----
CREATE DOMAIN D_COUNTRYCODE AS CHAR(3)
  CHECK (EXISTS(SELECT * FROM COUNTRY
         WHERE COUNTRYCODE = VALUE));
----
+
NOTE: The example is given only to show the possibility of using predicates with queries in the domain test condition.
It is not recommended to create this style of domain in practice unless the lookup table contains data that are never deleted.

.See also
<<fblangref25-ddl-domn-alter,`ALTER DOMAIN`>>, <<fblangref25-ddl-domn-drop,`DROP DOMAIN`>>

[[fblangref25-ddl-domn-alter]]
=== `ALTER DOMAIN`

.Used for
Altering the current attributes of a domain or renaming it

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER DOMAIN _domain_name_
  [TO _new_name_]
  [TYPE <datatype>]
  [SET DEFAULT {<literal> | NULL | <context_var>} | DROP DEFAULT]
  [ADD [CONSTRAINT] CHECK (<dom_condition>) | DROP CONSTRAINT]

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING] [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<dom_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<dom_condition>)
  | NOT <dom_condition>
  | <dom_condition> OR <dom_condition>
  | <dom_condition> AND <dom_condition>

<operator> ::= 
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    VALUE
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-alterdomn]]
.`ALTER DOMAIN` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|new_name
|New name for domain, consisting of up to 31 characters

|datatype
|SQL data type

|literal
|A literal value that is compatible with _datatype_

|context_var
|Any context variable whose type is compatible with _datatype_

|precision
|The total number of significant digits that a value of the _datatype_ can hold (1..18)

|scale
|The number of digits after the decimal point (0..__precision__)

|size
|The maximum size of a string in characters

|charset_name
|The name of a valid character set, if the character set of the domain is to be changed

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size (max. 65535)

|select_one
|A scalar `SELECT` statement -- selecting one column and returning only one row

|select_list
|A `SELECT` statement selecting one column and returning zero or more rows

|select_expr
|A `SELECT` statement selecting one or more columns and returning zero or more rows

|expression
|An expression resolving to a value that is compatible with _datatype_

|genname
|Sequence (generator) name

|func
|Internal function or UDF
|===

The `ALTER DOMAIN` statement enables changes to the current attributes of a domain, including its name.
You can make any number of domain alterations in one `ALTER DOMAIN` statement.

`TO __name__`::
Use the `TO` clause to rename the domain, as long as there are no dependencies on the domain, i.e.
table columns, local variables or procedure arguments referencing it.

`SET DEFAULT`::
With the `SET DEFAULT` clause you can set a new default value.
If the domain already has a default value, there is no need to delete it first -- it will be replaced by the new one.

`DROP DEFAULT`::
Use this clause to delete a previously specified default value and replace it with `NULL`.

`ADD CONSTRAINT CHECK`::
Use the `ADD CONSTRAINT CHECK` clause to add a `CHECK` constraint to the domain.
If the domain already has a `CHECK` constraint, it will have to be deleted first, using an `ALTER DOMAIN` statement that includes a `DROP CONSTRAINT` clause.

`TYPE`::
The `TYPE` clause is used to change the data type of the domain to a different, compatible one.
The system will forbid any change to the type that could result in data loss.
An example would be if the number of characters in the new type were smaller than in the existing type.

[IMPORTANT]
====
When you alter the attributes of a domain, existing PSQL code may become invalid.
For information on how to detect it, read the piece entitled <<fblangref25-appx01-supp-rdb-validblr,[ref]_The RDB$VALID_BLR Field_>> in Appendix A.
====

Any user connected to the database can alter a domain, provided it is not prevented by dependencies from objects to which that user does not have sufficient privileges.

[[fblangref25-ddl-domn-cannotalter]]
==== What `ALTER DOMAIN` Cannot Alter

* If the domain was declared as an array, it is not possible to change its type or its dimensions;
nor can any other type be changed to an `ARRAY` type.
* In Firebird 2.5 and lower, the `NOT NULL` constraint can be neither enabled nor disabled for a domain.
* There is no way to change the default collation without dropping the domain and recreating it with the desired attributes.

[[fblangref25-ddl-domn-alterdomnexmpls]]
==== `ALTER DOMAIN` Examples

. Changing the data type to `INTEGER` and setting or changing the default value to 2,000:
+
[source]
----
ALTER DOMAIN CUSTNO
  TYPE INTEGER
  SET DEFAULT 2000;
----
. Renaming a domain.
+
[source]
----
ALTER DOMAIN D_BOOLEAN TO D_BOOL;
----
. Deleting the default value and adding a constraint for the domain:
+
[source]
----
ALTER DOMAIN D_DATE
  DROP DEFAULT
  ADD CONSTRAINT CHECK (VALUE >= date '01.01.2000');
----
. Changing the `CHECK` constraint:
+
[source]
----
ALTER DOMAIN D_DATE
  DROP CONSTRAINT;

ALTER DOMAIN D_DATE
  ADD CONSTRAINT CHECK
    (VALUE BETWEEN date '01.01.1900' AND date '31.12.2100');
----
. Changing the data type to increase the permitted number of characters:
+
[source]
----
ALTER DOMAIN FIRSTNAME
  TYPE VARCHAR(50) CHARACTER SET UTF8;
----

.See also
<<fblangref25-ddl-domn-create,`CREATE DOMAIN`>>, <<fblangref25-ddl-domn-drop,`DROP DOMAIN`>>

[[fblangref25-ddl-domn-drop]]
=== `DROP DOMAIN`

.Used for
Deleting an existing domain

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP DOMAIN _domain_name_
----

The `DROP DOMAIN` statement deletes a domain that exists in the database.
It is not possible to delete a domain if it is referenced by any database table columns or used in any PSQL module.
In order to delete a domain that is in use, all columns in all tables that refer to the domain will have to be dropped and all references to the domain will have to be removed from PSQL modules.

Any user connected to the database can drop a domain.

[float]
===== Example

Deleting the COUNTRYNAME domain:

[source]
----
DROP DOMAIN COUNTRYNAME;
----

.See also
<<fblangref25-ddl-domn-create,`CREATE DOMAIN`>>, <<fblangref25-ddl-domn-alter,`ALTER DOMAIN`>>

[[fblangref25-ddl-tbl]]
== `TABLE`

As a relational DBMS, Firebird stores data in tables.
A table is a flat, two-dimensional structure containing any number of rows.
Table rows are often called _records_.

All rows in a table have the same structure and consist of columns.
Table columns are often called _fields_.
A table must have at least one column.
Each column contains a single type of SQL data.

This section describes how to create, alter and delete tables in a database.

[[fblangref25-ddl-tbl-create]]
=== `CREATE TABLE`

.Used for
creating a new table (relation)

.Available in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
CREATE [GLOBAL TEMPORARY] TABLE _tablename_
  [EXTERNAL [FILE] '_filespec_']
  (<col_def> [, {<col_def> | <tconstraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]

<col_def> ::= <regular_col_def> | <computed_col_def>

<regular_col_def> ::=
  _colname_ {<datatype> | _domainname_}
  [DEFAULT {<literal> | NULL | <context_var>}]
  [NOT NULL]
  [<col_constraint>]
  [COLLATE _collation_name_]

<computed_col_def> ::=
  _colname_ [<datatype>]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT} [<array_dim>]
  | {FLOAT | DOUBLE PRECISION} [<array_dim>]
  | {DATE | TIME | TIMESTAMP} [<array_dim>]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] [<array_dim>]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [<array_dim>] [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)] [<array_dim>]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<array_dim> ::= '[' [_m_:{endsb}__n__ [, [_m_:{endsb}__n__ ...] ']'

<col_constraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY [<using_index>]
    | UNIQUE      [<using_index>]
    | REFERENCES _other_table_ [(_colname_)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }

<tconstraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY (<col_list>) [<using_index>]
    | UNIQUE      (<col_list>) [<using_index>]
    | FOREIGN KEY (<col_list>)
        REFERENCES _other_table_ [(<col_list>)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }"

<col_list> ::= _colname_ [, _colname_ ...]

<using_index> ::= USING
  [ASC[ENDING] | DESC[ENDING]] INDEX _indexname_

<check_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<check_condition>)
  | NOT <check_condition>
  | <check_condition> OR <check_condition>
  | <check_condition> AND <check_condition>

<operator> ::= 
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    _colname_ ['['_array_idx_ [, _array_idx_ ...]']']
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-createtbl]]
.`CREATE TABLE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|tablename
|Name (identifier) for the table.
It may consist of up to 31 characters and must be unique in the database.

|filespec
|File specification (only for external tables).
Full file name and path, enclosed in single quotes, correct for the local file system and located on a storage device that is physically connected to Firebird's host computer.

|colname
|Name (identifier) for a column in the table.
May consist of up to 31 characters and must be unique in the table.

|datatype
|SQL data type

|col_constraint
|Column constraint

|tconstraint
|Table constraint

|constr_name
|The name (identifier) of a constraint.
May consist of up to 31 characters.

|other_table
|The name of the table referenced by the foreign key constraint

|other_col
|The name of the column in _other_table_ that is referenced by the foreign key

|literal
|A literal value that is allowed in the given context

|context_var
|Any context variable whose data type is allowed in the given context

|check_condition
|The condition applied to a CHECK constraint, that will resolve as either true, false or `NULL`

|collation
|Collation

|array_dim
|Array dimensions

|m, n
|Integer numbers defining the index range of an array dimension

|precision
|The total number of significant digits that a value of the datatype can hold (1..18)

|scale
|The number of digits after the decimal point (0..__precision__)

|size
|The maximum size of a string in characters

|charset_name
|The name of a valid character set, if the character set of the column is to be different to the default character set of the database

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size (max. 65535)

|select_one
|A scalar `SELECT` statement -- selecting one column and returning only one row

|select_list
|A `SELECT` statement selecting one column and returning zero or more rows

|select_expr
|A `SELECT` statement selecting one or more columns and returning zero or more rows

|expression
|An expression resolving to a value that is is allowed in the given context

|genname
|Sequence (generator) name

|func
|Internal function or UDF
|===

The `CREATE TABLE` statement creates a new table.
Any user can create it and its name must be unique among the names of all tables, views and stored procedures in the database.

A table must contain at least one column that is not computed and the names of columns must be unique in the table.

A column must have either an explicit _SQL data type_, the name of a _domain_ whose attributes will be copied for the column, or be defined as `COMPUTED BY` an expression (a _calculated field_).

A table may have any number of table constraints, including none.

[[fblangref25-ddl-tbl-nonnull]]
==== Making a Column Non-nullable

In Firebird, columns are nullable by default.
The optional `NOT NULL` clause specifies that the column cannot take `NULL` in place of a value.

[[fblangref25-ddl-tbl-character]]
==== Character Columns

You can use the `CHARACTER SET` clause to specify the character set for the `CHAR`, `VARCHAR` and `BLOB` (text subtype) types.
If the character set is not specified, the character set specified during the creation of the database will be used by default.
If no character set was specified during the creation of the database, the `NONE` character set is applied by default.
In this case, data is stored and retrieved the way it was submitted.
Data in any encoding can be added to such a column, but it is not possible to add this data to a column with a different encoding.
No transliteration is performed between the source and destination encodings, which may result in errors.

The optional `COLLATE` clause allows you to specify the collation sequence for character data types, including `BLOB SUB_TYPE TEXT`.
If no collation sequence is specified, the collation sequence that is default for the specified character set during the creation of the column is applied by default.

[[fblangref25-ddl-tbl-default]]
==== Setting a `DEFAULT` Value

The optional `DEFAULT` clause allows you to specify the default value for the table column.
This value will be added to the column when an `INSERT` statement is executed if no value was specified for it _and_ that column was omitted from the `INSERT` command.

The default value can be a literal of a compatible type, a context variable that is type-compatible with the data type of the column, or `NULL`, if the column allows it.
If no default value is explicitly specified, `NULL` is implied.

An expression cannot be used as a default value.

[[fblangref25-ddl-tbl-domainbased]]
==== Domain-based Columns

To define a column, you can use a previously defined domain.
If the definition of a column is based on a domain, it may contain a new default value, additional `CHECK` constraints and a `COLLATE` clause that will override the values specified in the domain definition.
The definition of such a column may contain additional column constraints (for instance, `NOT NULL`), if the domain does not have it.

[IMPORTANT]
====
It is not possible to define a domain-based column that is nullable if the domain was defined with the `NOT NULL` attribute.
If you want to have a domain that might be used for defining both nullable and non-nullable columns and variables, it is better practice to make the domain nullable and apply `NOT NULL` in the downstream column definitions and variable declarations.
====

[[fblangref25-ddl-tbl-computedby]]
==== Calculated Fields

Calculated fields can be defined with the `COMPUTED [BY]` or `GENERATED ALWAYS AS` clause (according to the SQL:2003 standard).
They mean the same.
Describing the data type is not required (but possible) for calculated fields, as the DBMS calculates and stores the appropriate type as a result of the expression analysis.
Appropriate operations for the data types included in an expression must be specified precisely.

If the data type is explicitly specified for a calculated field, the calculation result is converted to the specified type.
This means, for instance, that the result of a numeric expression could be rendered as a string.

In a query that selects a `COMPUTED BY` column, the expression is evaluated for each row of the selected data.

[TIP]
====
Instead of a computed column, in some cases it makes sense to use a regular column whose value is evaluated in triggers for adding and updating data.
It may reduce the performance of inserting/updating records, but it will increase the performance of data selection.
====

[[fblangref25-ddl-tbl-array]]
==== Defining an `ARRAY` Column

* If the column is to be an array, the base type can be any SQL data type except `BLOB` and `ARRAY`.
* The dimensions of the array are specified between square brackets.
(In the <<fblangref25-ddl-tbl-create,Syntax block>> these brackets appear in quotes to distinguish them from the square brackets that identify optional syntax elements.)
* For each array dimension, one or two integer numbers define the lower and upper boundaries of its index range:
** By default, arrays are 1-based.
The lower boundary is implicit and only the upper boundary need be specified.
A single number smaller than 1 defines the range __num__..1 and a number greater than 1 defines the range 1..__num__.
** Two numbers separated by a colon ('```:```') and optional whitespace, the second greater than the first, can be used to define the range explicitly.
One or both boundaries can be less than zero, as long as the upper boundary is greater than the lower.
* When the array has multiple dimensions, the range definitions for each dimension must be separated by commas and optional whitespace.
* Subscripts are validated _only_ if an array actually exists.
It means that no error messages regarding invalid subscripts will be returned if selecting a specific element returns nothing or if an array field is [constant]`NULL`.

[[fblangref25-ddl-tbl-constraints]]
==== Constraints

Four types of constraints can be specified.
They are: 

* Primary key (`PRIMARY KEY`)
* Unique key (`UNIQUE`)
* Foreign key (`REFERENCES`)
* `CHECK` constraint (`CHECK`)

Constraints can be specified at column level ("`column constraints`") or at table level ("`table constraints`").
Table-level constraints are needed when keys (uniqueness constraint, Primary Key, Foreign Key) are to be formed across multiple columns and when a `CHECK` constraint involves other columns in the row besides the column being defined.
Syntax for some types of constraint may differ slightly according to whether the constraint is being defined at column or table level. 

* A column-level constraint is specified during a column definition, after all column attributes except `COLLATION` are specified, and can involve only the column specified in that definition
* Table-level constraints are specified after all of the column definitions.
They are a more flexible way to set constraints, since they can cater for constraints involving multiple columns
* You can mix column-level and table-level constraints in the same `CREATE TABLE` statement

The system automatically creates the corresponding index for a primary key (`PRIMARY KEY`), a unique key (`UNIQUE`) and a foreign key (`REFERENCES` for a column-level constraint, `FOREIGN KEY REFERENCES` for one at the table level).

[[fblangref25-ddl-tbl-constraints-names]]
===== Names for Constraints and Their Indexes

Column-level constraints and their indexes are named automatically: 

* The constraint name has the form `INTEG_n`, where _n_ represents one or more digits
* The index name has the form `RDB$PRIMARYn` (for a primary key index), `RDB$FOREIGNn` (for a foreign key index) or `RDB$n` (for a unique key index).
Again, _n_ represents one or more digits.

Automatic naming of table-level constraints and their indexes follows the same pattern, unless the names are supplied explicitly.

[[fblangref25-ddl-tbl-constraints-named]]
====== Named Constraints

A constraint can be named explicitly if the `CONSTRAINT` clause is used for its definition.
While the `CONSTRAINT` clause is optional for defining column-level constraints, it is mandatory for table-level.
By default, the constraint index will have the same name as the constraint.
If a different name is wanted for the constraint index, a `USING` clause can be included.

[[fblangref25-ddl-tbl-constraints-using]]
====== The `USING` Clause

The `USING` clause allows you to specify a user-defined name for the index that is created automatically and, optionally, to define the direction of the index -- either ascending (the default) or descending.

[[fblangref25-ddl-tbl-constraints-pk]]
===== `PRIMARY KEY`

The `PRIMARY KEY` constraint is built on one or more [term]_key columns_, each column having the `NOT NULL` constraint specified for it.
The values across the key columns in any row must be unique.
A table can have only one primary key. 

* A single-column Primary Key can be defined as a column level or a table-level constraint
* A multi-column Primary Key must be specified as a table-level constraint

[[fblangref25-ddl-tbl-constraints-uq]]
===== The `UNIQUE` Constraint

The `UNIQUE` constraint defines the requirement of content uniqueness for the values in a key throughout the table.
A table can contain any number of unique key constraints.

As with the Primary Key, the Unique constraint can be multi-column.
If so, it must be specified as a table-level constraint.

[[fblangref25-ddl-tbl-uqkey-nulls]]
====== `NULL` in Unique Keys

Firebird's SQL-99-compliant rules for `UNIQUE` constraints allow one or more ``NULL``s in a column with a `UNIQUE` constraint.
That makes it possible to define a `UNIQUE` constraint on a column that does not have the `NOT NULL` constraint.

For `UNIQUE` keys that span multiple columns, the logic is a little complicated: 

* Multiple rows having null in all the columns of the key are allowed
* Multiple rows having keys with different combinations of nulls and non-null values are allowed
* Multiple rows having the same key columns null and the rest filled with non-null values are allowed, provided the values differ in at least one column
* Multiple rows having the same key columns null and the rest filled with non-null values that are the same in every column will violate the constraint

The rules for uniqueness can be summarised thus: 

[quote]
In principle, all nulls are considered distinct.
However, if two rows have exactly the same key columns filled with non-null values, the `NULL` columns are ignored and the uniqueness is determined on the non-null columns as though they constituted the entire key.

.Illustration
[source]
----
RECREATE TABLE t( x int, y int, z int, unique(x,y,z));
INSERT INTO t values( NULL, 1, 1 );
INSERT INTO t values( NULL, NULL, 1 );
INSERT INTO t values( NULL, NULL, NULL );
INSERT INTO t values( NULL, NULL, NULL ); -- Permitted
INSERT INTO t values( NULL, NULL, 1 );    -- Not permitted
----

[[fblangref25-ddl-tbl-constraints-refs]]
===== `FOREIGN KEY`

A Foreign Key ensures that the participating column(s) can contain only values that also exist in the referenced column(s) in the master table.
These referenced columns are often called [term]_target columns_.
They must be the primary key or a unique key in the target table.
They need not have a `NOT NULL` constraint defined on them although, if they are the primary key, they will, of course, have that constraint.

The foreign key columns in the referencing table itself do not require a `NOT NULL` constraint.

A single-column Foreign Key can be defined in the column declaration, using the keyword `REFERENCES`:

[source]
----
... ,
  ARTIFACT_ID INTEGER REFERENCES COLLECTION (ARTIFACT_ID),
----

The column `ARTIFACT_ID` in the example references a column of the same name in the table `COLLECTIONS`.

Both single-column and multi-column foreign keys can be defined at the [term]_table level_.
For a multi-column Foreign Key, the table-level declaration is the only option.
This method also enables the provision of an optional name for the constraint:

[source]
----
...
  CONSTRAINT FK_ARTSOURCE FOREIGN KEY(DEALER_ID, COUNTRY)
    REFERENCES DEALER (DEALER_ID, COUNTRY),
----

Notice that the column names in the referenced ("`master`") table may differ from those in the Foreign Key.

[NOTE]
====
If no target columns are specified, the Foreign Key automatically references the target table's Primary Key.
====

[[fblangref25-ddl-tbl-constraints-fkactions]]
====== Foreign Key Actions

With the sub-clauses `ON UPDATE` and `ON DELETE` it is possible to specify an action to be taken on the affected foreign key column(s) when referenced values in the master table are changed:

`NO ACTION`:: (the default) - Nothing is done
`CASCADE`:: The change in the master table is propagated to the corresponding row(s) in the child table.
If a key value changes, the corresponding key in the child records changes to the new value;
if the master row is deleted, the child records are deleted.
`SET DEFAULT`:: The Foreign Key columns in the affected rows will be set to their default values _as they were when the foreign key constraint was defined_.
`SET NULL`:: The Foreign Key columns in the affected rows will be set to `NULL`.

The specified action, or the default `NO ACTION`, could cause a Foreign Key column to become invalid.
For example, it could get a value that is not present in the master table, or it could become `NULL` while the column has a `NOT NULL` constraint.
Such conditions will cause the operation on the master table to fail with an error message. 

.Example
[source]
----
...
  CONSTRAINT FK_ORDERS_CUST
    FOREIGN KEY (CUSTOMER) REFERENCES CUSTOMERS (ID)
      ON UPDATE CASCADE ON DELETE SET NULL
----

[[fblangref25-ddl-tbl-constraints-check]]
===== `CHECK` Constraint

The `CHECK` constraint defines the condition the values inserted in this column must satisfy.
A condition is a logical expression (also called a predicate) that can return the TRUE, FALSE and UNKNOWN values.
A condition is considered satisfied if the predicate returns TRUE or value UNKNOWN (equivalent to `NULL`).
If the predicate returns FALSE, the value will not be accepted.
This condition is used for inserting a new row into the table (the `INSERT` statement) and for updating the existing value of the table column (the `UPDATE` statement) and also for statements where one of these actions may take place (UPDATE OR INSERT, MERGE).

[IMPORTANT]
====
A `CHECK` constraint on a domain-based column does not replace an existing `CHECK` condition on the domain, but becomes an addition to it.
The Firebird engine has no way, during definition, to verify that the extra `CHECK` does not conflict with the existing one.
====

`CHECK` conditions -- whether defined at table level or column level -- refer to table columns _by their names_.
The use of the keyword `VALUE` as a placeholder, as in domain `CHECK` constraints, is not valid in the context of defining column constraints.

.Example
with two column-level constraints and one at table-level:

[source]
----
CREATE TABLE PLACES (
  ...
  LAT DECIMAL(9, 6) CHECK (ABS(LAT) <=  90),
  LON DECIMAL(9, 6) CHECK (ABS(LON) <= 180),
  ...
  CONSTRAINT CHK_POLES CHECK (ABS(LAT) < 90 OR LON = 0)
);
----

[[fblangref25-ddl-tbl-gtt]]
==== Global Temporary Tables (GTT)

Global temporary tables have persistent metadata, but their contents are transaction-bound (the default) or connection-bound.
Every transaction or connection has its own private instance of a GTT, isolated from all the others.
Instances are only created if and when the GTT is referenced.
They are destroyed when the transaction ends or on disconnection.
The metadata of a GTT can be modified or removed using ALTER TABLE and DROP TABLE, respectively.

.Syntax
[listing,subs=+quotes]
----
CREATE GLOBAL TEMPORARY TABLE _tablename_
  (<column_def> [, {<column_def> | <table_constraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
----

.Syntax notes
[NOTE]
====
* `ON COMMIT DELETE ROWS` creates a transaction-level GTT (the default), `ON COMMIT PRESERVE ROWS` a connection-level GTT
* An `EXTERNAL [FILE]` clause is not allowed in the definition of a global temporary table
====

[[fblangref25-ddl-tbl-gtt-restrictions]]
===== Restrictions on GTTs

GTTs can be "`dressed up`" with all the features and paraphernalia of ordinary tables (keys, references, indexes, triggers and so on) but there are a few restrictions: 

* GTTs and regular tables cannot reference one another
* A connection-bound ("```PRESERVE ROWS```") GTT cannot reference a transaction-bound ("```DELETE ROWS```") GTT
* Domain constraints cannot reference any GTT
* The destruction of a GTT instance at the end of its life cycle does not cause any `BEFORE`/`AFTER` delete triggers to fire

[TIP]
====
In an existing database, it is not always easy to distinguish a regular table from a GTT, or a transaction-level GTT from a connection-level GTT.
Use this query to find out what type of table you are looking at:

[source]
----
select t.rdb$type_name
from rdb$relations r
join rdb$types t on r.rdb$relation_type = t.rdb$type
where t.rdb$field_name = 'RDB$RELATION_TYPE'
and r.rdb$relation_name = 'TABLENAME'
----

For an overview of the types of all the relations in the database:

[source]
----
select r.rdb$relation_name, t.rdb$type_name
from rdb$relations r
join rdb$types t on r.rdb$relation_type = t.rdb$type
where t.rdb$field_name = 'RDB$RELATION_TYPE'
and coalesce (r.rdb$system_flag, 0) = 0
----

The `RDB$TYPE_NAME` field will show `PERSISTENT` for a regular table, `VIEW` for a view, `GLOBAL_TEMPORARY_PRESERVE` for a connection-bound GTT and `GLOBAL_TEMPORARY_DELETE` for a transaction_bound GTT.
====

[[fblangref25-ddl-tbl-external]]
==== External Tables

The optional `EXTERNAL [FILE]` clause specifies that the table is stored outside the database in an external text file of fixed-length records.
The columns of a table stored in an external file can be of any type except `BLOB` or `ARRAY`, although for most purposes, only columns of `CHAR` types would be useful.

All you can do with a table stored in an external file is insert new rows (`INSERT`) and query the data (``SELECT``).
Updating existing data (`UPDATE`) and deleting rows (`DELETE`) are not possible.

A file that is defined as an external table must be located on a storage device that is physically present on the machine where the Firebird server runs and, if the parameter _ExternalFileAccess_ in the [path]`firebird.conf` configuration file is `Restrict`, it must be in one of the directories listed there as the argument for `Restrict`.
If the file does not exist yet, Firebird will create it on first access.

[IMPORTANT]
====
The ability to use external files for a table depends on the value set for the _ExternalFileAccess_ parameter in [path]`firebird.conf`:

* If it is set to `None` (the default), any attempt to access an external file will be denied.
* The `Restrict` setting is recommended, for restricting external file access to directories created explicitly for the purpose by the server administrator.
For example:
** `ExternalFileAccess = Restrict externalfiles` will restrict access to a directory named `externalfiles` directly beneath the Firebird root directory
** `ExternalFileAccess = d:\databases\outfiles; e:\infiles` will restrict access to just those two directories on the Windows host server.
Note that any path that is a network mapping will not work.
Paths enclosed in single or double quotes will not work, either.
* If this parameter is set to `Full`, external files may be accessed anywhere on the host file system.
It creates a security vulnerability and is not recommended.
====

[[fblangref25-ddl-tbl-ext-format]]
===== External File Format

The "`row`" format of the external table is fixed length.
There are no field delimiters: both field and row boundaries are determined by maximum sizes, in bytes, of the field definitions.
It is important to keep this in mind, both when defining the structure of the external table and when designing an input file for an external table that is to import data from another application.
The ubiquitous "`.csv`" format, for example, is of no use as an input file and cannot be generated directly into an external file.

The most useful data type for the columns of external tables is the fixed-length `CHAR` type, of suitable lengths for the data they are to carry.
Date and number types are easily cast to and from strings whereas, unless the files are to be read by another Firebird database, the native data types will appear to external applications as unparseable "`alphabetti`".

Of course, there are ways to manipulate typed data so as to generate output files from Firebird that can be read directly as input files to other applications, using stored procedures, with or without employing external tables.
Such techniques are beyond the scope of a language reference.
Here, we provide some guidelines and tips for producing and working with simple text files, since the external table feature is often used as an easy way to produce or read transaction-independent logs that can be studied off-line in a text editor or auditing application.

[[fblangref25-ddl-tbl-ext-format-delimiter]]
====== Row Delimiters

Generally, external files are more useful if rows are separated by a delimiter, in the form of a "`newline`" sequence that is recognised by reader applications on the intended platform.
For most contexts on Windows, it is the two-byte 'CRLF' sequence, carriage return (ASCII code decimal 13) and line feed (ASCII code decimal 10).
On POSIX, LF on its own is usual;
for some MacOSX applications, it may be LFCR.
There are various ways to populate this delimiter column.
In our example below, it is done by using a `BEFORE INSERT` trigger and the internal function `ASCII_CHAR`.

====== External Table Example

For our example, we will define an external log table that might be used by an exception handler in a stored procedure or trigger.
The external table is chosen because the messages from any handled exceptions will be retained in the log, even if the transaction that launched the process is eventually rolled back because of another, unhandled exception.
For demonstration purposes, it has just two data columns, a time stamp and a message.
The third column stores the row delimiter:

[source]
----
CREATE TABLE ext_log
  EXTERNAL FILE 'd:\externals\log_me.txt' (
  stamp CHAR (24),
  message CHAR(100),
  crlf CHAR(2) -- for a Windows context
);
COMMIT;
----

Now, a trigger, to write the timestamp and the row delimiter each time a message is written to the file:

[source]
----
SET TERM ^;
CREATE TRIGGER bi_ext_log FOR ext_log
ACTIVE BEFORE INSERT
AS
BEGIN
  IF (new.stamp is NULL) then
    new.stamp = CAST (CURRENT_TIMESTAMP as CHAR(24));
  new.crlf = ASCII_CHAR(13) || ASCII_CHAR(10);
END ^
COMMIT ^
SET TERM ;^
----

Inserting some records (which could have been done by an exception handler or a fan of Shakespeare):

[source]
----
insert into ext_log (message)
values('Shall I compare thee to a summer''s day?');
insert into ext_log (message)
values('Thou art more lovely and more temperate');
----

The output:

[source]
----
2015-10-07 15:19:03.4110Shall I compare thee to a summer's day?
2015-10-07 15:19:58.7600Thou art more lovely and more temperate
----

[[fblangref25-ddl-tbl-exmpls]]
==== `CREATE TABLE` Examples

. Creating the COUNTRY table with the primary key specified as a column constraint.
+
[source]
----
CREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL
);
----
. Creating the STOCK table with the named primary key specified at the column level and the named unique key specified at the table level.
+
[source]
----
CREATE TABLE STOCK (
  MODEL     SMALLINT NOT NULL CONSTRAINT PK_STOCK PRIMARY KEY,
  MODELNAME CHAR(10) NOT NULL,
  ITEMID    INTEGER NOT NULL,
  CONSTRAINT MOD_UNIQUE UNIQUE (MODELNAME, ITEMID)
);
----
. Creating the JOB table with a primary key constraint spanning two columns, a foreign key constraint for the COUNTRY table and a table-level CHECK constraint.
The table also contains an array of 5 elements.
+
[source]
----
CREATE TABLE JOB (
  JOB_CODE        JOBCODE NOT NULL,
  JOB_GRADE       JOBGRADE NOT NULL,
  JOB_COUNTRY     COUNTRYNAME,
  JOB_TITLE       VARCHAR(25) NOT NULL,
  MIN_SALARY      NUMERIC(18, 2) DEFAULT 0 NOT NULL,
  MAX_SALARY      NUMERIC(18, 2) NOT NULL,
  JOB_REQUIREMENT BLOB SUB_TYPE 1,
  LANGUAGE_REQ    VARCHAR(15) [1:5],
  PRIMARY KEY (JOB_CODE, JOB_GRADE),
  FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY)
  ON UPDATE CASCADE
  ON DELETE SET NULL,
  CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY)
);
----
. Creating the PROJECT table with primary, foreign and unique key constraints with custom index names specified with the USING clause.
+
[source]
----
CREATE TABLE PROJECT (
  PROJ_ID     PROJNO NOT NULL,
  PROJ_NAME   VARCHAR(20) NOT NULL UNIQUE USING DESC INDEX IDX_PROJNAME,
  PROJ_DESC   BLOB SUB_TYPE 1,
  TEAM_LEADER EMPNO,
  PRODUCT     PRODTYPE,
  CONSTRAINT PK_PROJECT PRIMARY KEY (PROJ_ID) USING INDEX IDX_PROJ_ID,
  FOREIGN KEY (TEAM_LEADER) REFERENCES EMPLOYEE (EMP_NO)
    USING INDEX IDX_LEADER
);
----
. Creating the SALARY_HISTORY table with two computed fields.
The first one is declared according to the SQL:2003 standard, while the second one is declared according to the traditional declaration of computed fields in Firebird.
+
[source]
----
CREATE TABLE SALARY_HISTORY (
  EMP_NO         EMPNO NOT NULL,
  CHANGE_DATE    TIMESTAMP DEFAULT 'NOW' NOT NULL,
  UPDATER_ID     VARCHAR(20) NOT NULL,
  OLD_SALARY     SALARY NOT NULL,
  PERCENT_CHANGE DOUBLE PRECISION DEFAULT 0 NOT NULL,
  SALARY_CHANGE  GENERATED ALWAYS AS
    (OLD_SALARY * PERCENT_CHANGE / 100),
  NEW_SALARY     COMPUTED BY
    (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100)
);
----
. Creating a connection-scoped global temporary table.
+
[source]
----
CREATE GLOBAL TEMPORARY TABLE MYCONNGTT (
  ID  INTEGER NOT NULL PRIMARY KEY,
  TXT VARCHAR(32),
  TS  TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
ON COMMIT PRESERVE ROWS;
----
. Creating a transaction-scoped global temporary table that uses a foreign key to reference a connection-scoped global temporary table.
The `ON COMMIT` sub-clause is optional because `DELETE ROWS` is the default.
+
[source]
----
CREATE GLOBAL TEMPORARY TABLE MYTXGTT (
  ID        INTEGER NOT NULL PRIMARY KEY,
  PARENT_ID INTEGER NOT NULL REFERENCES MYCONNGTT(ID),
  TXT       VARCHAR(32),
  TS        TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ON COMMIT DELETE ROWS;
----

[[fblangref25-ddl-tbl-alter]]
=== `ALTER TABLE`

.Used for
altering the structure of a table.

.Available in
DSQL, ESQL

.Syntax
[listing,subs="+quotes,attributes"]
----
ALTER TABLE _tablename_
  <operation> [, <operation> ...]

<operation> ::=
    ADD <col_def>
  | ADD <tconstraint>
  | DROP _colname_
  | DROP CONSTRAINT _constr_name_
  | ALTER [COLUMN] _colname_ <col_mod>

<col_def> ::= <regular_col_def> | <computed_col_def>

<regular_col_def> ::=
  _colname_ {<datatype> | _domainname_}
  [DEFAULT {<literal> | NULL | <context_var>}]
  [NOT NULL]
  [<col_constraint>]
  [COLLATE _collation_name_]

<computed_col_def> ::=
  _colname_ [<datatype>]
  {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)

<col_mod> ::= <regular_col_mod> | <computed_col_mod>

<regular_col_mod> ::=
    TO _newname_
  | POSITION _newpos_
  | TYPE {<datatype> | _domainname_}
  | SET DEFAULT {<literal> | NULL | <context_var>}
  | DROP DEFAULT

<computed_col_mod> ::=
    TO _newname_
  | POSITION _newpos_
  | [TYPE <datatype>] {COMPUTED [BY] | GENERATED ALWAYS AS} (<expression>)

<datatype> ::=
    {SMALLINT | INTEGER | BIGINT} [<array_dim>]
  | {FLOAT | DOUBLE PRECISION} [<array_dim>]
  | {DATE | TIME | TIMESTAMP} [<array_dim>]
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])] [<array_dim>]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [<array_dim>] [CHARACTER SET _charset_name_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)] [<array_dim>]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_name_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<array_dim> ::= '[' [_m_:{endsb}__n__ [,[_m_:{endsb}__n__ ...] ']'

<col_constraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY [<using_index>]
    | UNIQUE      [<using_index>]
    | REFERENCES _other_table_ [(_colname_)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }

<tconstraint> ::=
  [CONSTRAINT _constr_name_]
    { PRIMARY KEY (<col_list>) [<using_index>]
    | UNIQUE      (<col_list>) [<using_index>]
    | FOREIGN KEY (<col_list>)
        REFERENCES _other_table_ [(<col_list>)] [<using_index>]
        [ON DELETE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
        [ON UPDATE {NO ACTION | CASCADE | SET DEFAULT | SET NULL}]
    | CHECK (<check_condition>) }

<col_list> ::= _colname_ [, _colname_ ...]

<using_index> ::= USING
  [ASC[ENDING] | DESC[ENDING]] INDEX _indexname_

<check_condition> ::=
    <val> <operator> <val>
  | <val> [NOT] BETWEEN <val> AND <val>
  | <val> [NOT] IN (<val> [, <val> ...] | <select_list>)
  | <val> IS [NOT] NULL
  | <val> IS [NOT] DISTINCT FROM <val>
  | <val> [NOT] CONTAINING <val>
  | <val> [NOT] STARTING [WITH] <val>
  | <val> [NOT] LIKE <val> [ESCAPE <val>]
  | <val> [NOT] SIMILAR TO <val> [ESCAPE <val>]
  | <val> <operator> {ALL | SOME | ANY} (<select_list>)
  | [NOT] EXISTS (<select_expr>)
  | [NOT] SINGULAR (<select_expr>)
  | (<search_condition>)
  | NOT <search_condition>
  | <search_condition> OR <search_condition>
  | <search_condition> AND <search_condition>

<operator> ::= 
    <> | != | ^= | ~= | = | < | > | <= | >=
  | !< | ^< | ~< | !> | ^> | ~>

<val> ::=
    _colname_ ['['_array_idx_ [, _array_idx_ ...]']']
  | <literal>
  | <context_var>
  | <expression>
  | NULL
  | NEXT VALUE FOR _genname_
  | GEN_ID(_genname_, <val>)
  | CAST(<val> AS <datatype>)
  | (<select_one>)
  | func([<val> [, <val> ...]])
----

[[fblangref25-ddl-tbl-altertbl]]
.`ALTER TABLE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|tablename
|Name (identifier) of the table

|operation
|One of the available operations altering the structure of the table

|colname
|Name (identifier) for a column in the table, max. 31 characters.
Must be unique in the table.

|newname
|New name (identifier) for the column, max. 31 characters.
Must be unique in the table.

|newpos
|The new column position (an integer between 1 and the number of columns in the table)

|col_constraint
|Column constraint

|tconstraint
|Table constraint

|constr_name
|The name (identifier) of a constraint.
May consist of up to 31 characters.

|other_table
|The name of the table referenced by the foreign key constraint

|literal
|A literal value that is allowed in the given context

|context_var
|A context variable whose type is allowed in the given context

|check_condition
|The condition of a `CHECK` constraint that will be satisfied if it evaluates to TRUE or UNKNOWN/NULL

|collation
|Name of a collation sequence that is valid for _charset_name_, if it is supplied with _datatype_ or, otherwise, is valid for the default character set of the database

|array_dim
|Array dimensions

|m, n
|Integer numbers defining the index range of an array dimension

|precision
|The total number of significant digits that a value of the _datatype_ can hold (1..18)

|scale
|The number of digits after the decimal point (0..__precision__)

|size
|The maximum size of a string in characters

|charset_name
|The name of a valid character set, if the character set of the column is to be different to the default character set of the database

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size (max. 65535)

|select_one
|A scalar `SELECT` statement -- selecting one column and returning only one row

|select_list
|A `SELECT` statement selecting one column and returning zero or more rows

|select_expr
|A `SELECT` statement selecting one or more columns and returning zero or more rows

|expression
|An expression resolving to a value that is is allowed in the given context

|genname
|Sequence (generator) name

|func
|Internal function or UDF
|===

The `ALTER TABLE` statement changes the structure of an existing table.
With one `ALTER TABLE` statement it is possible to perform multiple operations, adding/dropping columns and constraints and also altering column specifications.

Multiple operations in an `ALTER TABLE` statement are separated with commas.

[[fblangref25-ddl-tbl-altrvcount]]
==== Version Count Increments

Some changes in the structure of a table increment the metadata change counter ("`version count`") assigned to every table.
The number of metadata changes is limited to 255 for each table.
Once the counter reaches the 255 limit, you will not be able to make any further changes to the structure of the table without resetting the counter.

[sidebar]
.To reset the metadata change counter
You should back up and restore the database using the _gbak_ utility.

[[fblangref25-ddl-tbl-altradd]]
==== The `ADD` Clause

With the `ADD` clause you can add a new column or a new table constraint.
The syntax for defining the column and the syntax of defining the table constraint correspond with those described for `CREATE TABLE` statement.

.Effect on Version Count
* Each time a new column is added, the metadata change counter is increased by one
* Adding a new table constraint does not increase the metadata change counter

.Points to Be Aware of
[CAUTION]
====
. Be careful about adding a new column with the `NOT NULL` constraint set.
It may lead to breaking the logical integrity of data, since you will have existing records containing `NULL` in a non-nullable column.
When adding a non-nullable column, it is recommended either to set a default value for it or to update the column in existing rows with a non-null value.
. When a new `CHECK` constraint is added, existing data is not tested for compliance.
Prior testing of existing data against the new `CHECK` expression is recommended.
====

[[fblangref25-ddl-tbl-altrdropcol]]
==== The `DROP` Clause

The `DROP __<column name>__` clause deletes the specified column from the table.
An attempt to drop a column will fail if anything references it.
Consider the following items as sources of potential dependencies: 

* column or table constraints
* indexes
* stored procedures and triggers
* views

.Effect on Version Count
* Each time a column is dropped, the table's metadata change counter is increased by one.

[[fblangref25-ddl-tbl-altrdropconstr]]
==== The `DROP CONSTRAINT` Clause

The `DROP CONSTRAINT` clause deletes the specified column-level or table-level constraint.

A `PRIMARY KEY` or `UNIQUE` key constraint cannot be deleted if it is referenced by a `FOREIGN KEY` constraint in another table.
It will be necessary to drop that `FOREIGN KEY` constraint before attempting to drop the `PRIMARY KEY` or `UNIQUE` key constraint it references.

.Effect on Version Count
* Deleting a column constraint or a table constraint does not increase the metadata change counter.

[[fblangref25-ddl-tbl-altraltrcol]]
==== The `ALTER [COLUMN]` Clause

With the `ALTER [COLUMN]` clause, attributes of existing columns can be modified without the need to drop and re-add the column.
Permitted modifications are: 

* change the name (does not affect the metadata change counter)
* change the data type (increases the metadata change counter by one)
* change the column position in the column list of the table (does not affect the metadata change counter)
* delete the default column value (does not affect the metadata change counter)
* set a default column value or change the existing default (does not affect the metadata change counter)
* change the type and expression for a computed column (does not affect the metadata change counter)

[[fblangref25-ddl-tbl-altraltrto]]
==== Renaming a Column: the `TO` Keyword

The TO keyword with a new identifier renames an existing column.
The table must not have an existing column that has the same identifier.

It will not be possible to change the name of a column that is included in any constraint: `PRIMARY KEY`, `UNIQUE` key, `FOREIGN KEY`, column constraint or the `CHECK` constraint of the table.

Renaming a column will also be disallowed if the column is used in any trigger, stored procedure or view.

[[fblangref25-ddl-tbl-altraltrtyp]]
==== Changing the Data Type of a Column: the `TYPE` Keyword

The keyword `TYPE` changes the data type of an existing column to another, allowable type.
A type change that might result in data loss will be disallowed.
As an example, the number of characters in the new type for a `CHAR` or `VARCHAR` column cannot be smaller than the existing specification for it.

If the column was declared as an array, no change to its type or its number of dimensions is permitted.

The data type of a column that is involved in a foreign key, primary key or unique constraint cannot be changed at all.

[[fblangref25-ddl-tbl-altraltrpos]]
==== Changing the Position of a Column: the `POSITION` Keyword

The POSITION keyword changes the position of an existing column in the notional "`left-to-right`" layout of the record.

Numbering of column positions starts at 1. 

* If a position less than 1 is specified, an error message will be returned
* If a position number is greater than the number of columns in the table, its new position will be adjusted silently to match the number of columns.

[[fblangref25-ddl-tbl-altrdefault]]
==== The `DROP DEFAULT` and `SET DEFAULT` Clauses

The optional `DROP DEFAULT` clause deletes the default value for the column if it was put there previously by a `CREATE TABLE` or `ALTER TABLE` statement.

* If the column is based on a domain with a default value, the default value will revert to the domain default
* An execution error will be raised if an attempt is made to delete the default value of a column which has no default value or whose default value is domain-based

The optional `SET DEFAULT` clause sets a default value for the column.
If the column already has a default value, it will be replaced with the new one.
The default value applied to a column always overrides one inherited from a domain.

[[fblangref25-ddl-tbl-altrcmptd]]
==== The `COMPUTED [BY]` or `GENERATED ALWAYS AS` Clauses

The data type and expression underlying a computed column can be modified using a `COMPUTED [BY]` or `GENERATED ALWAYS AS` clause in the `ALTER TABLE ALTER [COLUMN]` statement.
Converting a regular column to a computed one and vice versa are not permitted.

[[fblangref25-ddl-tbl-altrtblnogo]]
==== Attributes that Cannot Be Altered

The following alterations are not supported: 

* Enabling or disabling the `NOT NULL` constraint on a column
* Changing the default collation for a character type column

Only the table owner and <<fblangref25-security-administrators,administrators>> have the authority to use `ALTER TABLE`.

[[fblangref25-ddl-tbl-altrtblexmpls]]
==== Examples Using `ALTER TABLE`

. Adding the `CAPITAL` column to the `COUNTRY` table.
+
[source]
----
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25);
----
. Adding the `CAPITAL` column with the `UNIQUE` constraint and deleting the `CURRENCY` column.
+
[source]
----
ALTER TABLE COUNTRY
  ADD CAPITAL VARCHAR(25) NOT NULL UNIQUE,
  DROP CURRENCY;
----
. Adding the `CHK_SALARY` check constraint and a foreign key to the `JOB` table.
+
[source]
----
ALTER TABLE JOB
  ADD CONSTRAINT CHK_SALARY CHECK (MIN_SALARY < MAX_SALARY),
  ADD FOREIGN KEY (JOB_COUNTRY) REFERENCES COUNTRY (COUNTRY);
----
. Setting default value for the `MODEL` field, changing the type of the `ITEMID` column and renaming the MODELNAME column.
+
[source]
----
ALTER TABLE STOCK
  ALTER COLUMN MODEL SET DEFAULT 1,
  ALTER COLUMN ITEMID TYPE BIGINT,
  ALTER COLUMN MODELNAME TO NAME;
----
. Changing the computed columns `NEW_SALARY` and `SALARY_CHANGE`.
+
[source]
----
ALTER TABLE SALARY_HISTORY
  ALTER NEW_SALARY GENERATED ALWAYS AS
    (OLD_SALARY + OLD_SALARY * PERCENT_CHANGE / 100),
  ALTER SALARY_CHANGE COMPUTED BY
    (OLD_SALARY * PERCENT_CHANGE / 100);
----

.See also
<<fblangref25-ddl-tbl-create,`CREATE TABLE`>>, <<fblangref25-ddl-tbl-drop,`DROP TABLE`>>, <<fblangref25-ddl-domn-create,`CREATE DOMAIN`>>

[[fblangref25-ddl-tbl-drop]]
=== `DROP TABLE`

.Used for
deleting a table

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP TABLE _tablename_
----

[[fblangref25-ddl-tbl-droptbl]]
.`DROP TABLE` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|tablename
|Name (identifier) of the table
|===

The `DROP TABLE` statement deletes an existing table.
If the table has dependencies, the `DROP TABLE` statement will fail with an execution error.

When a table is dropped, all triggers for its events and indexes built for its fields will be deleted as well.

Only the table owner and <<fblangref25-security-administrators,administrators>> have the authority to use `DROP TABLE`.

.Example
Deleting the `COUNTRY` table.

[source]
----
DROP TABLE COUNTRY;
----

.See also
<<fblangref25-ddl-tbl-create,`CREATE TABLE`>>, <<fblangref25-ddl-tbl-alter,`ALTER TABLE`>>, <<fblangref25-ddl-tbl-recreate,`RECREATE TABLE`>>

[[fblangref25-ddl-tbl-recreate]]
=== `RECREATE TABLE`

.Used for
creating a new table (relation) or recreating an existing one

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE [GLOBAL TEMPORARY] TABLE _tablename_
  [EXTERNAL [FILE] '_filespec_']
  (<col_def> [, {<col_def> | <tconstraint>} ...])
  [ON COMMIT {DELETE | PRESERVE} ROWS]
----

See the <<fblangref25-ddl-tbl-create,`CREATE TABLE` section>> for the full syntax of `CREATE TABLE` and descriptions of defining tables, columns and constraints.

`RECREATE TABLE` creates or recreates a table.
If a table with this name already exists, the `RECREATE TABLE` statement will try to drop it and create a new one.
Existing dependencies will prevent the statement from executing.

.Example
Creating or recreating the COUNTRY table. 
[source]
----
RECREATE TABLE COUNTRY (
  COUNTRY COUNTRYNAME NOT NULL PRIMARY KEY,
  CURRENCY VARCHAR(10) NOT NULL
);
----

.See also
<<fblangref25-ddl-tbl-create,`CREATE TABLE`>>, <<fblangref25-ddl-tbl-drop,`DROP TABLE`>>

[[fblangref25-ddl-idx]]
== `INDEX`

An index is a database object used for faster data retrieval from a table or for speeding up the sorting of query.
Indexes are used also to enforce the refererential integrity constraints `PRIMARY KEY`, `FOREIGN KEY` and `UNIQUE`.

This section describes how to create indexes, activate and deactivate them, delete them and collect statistics (recalculate selectivity) for them.

[[fblangref25-ddl-idx-create]]
=== `CREATE INDEX`

.Used for
Creating an index for a table

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE [UNIQUE] [ASC[ENDING] | DESC[ENDING]]
  INDEX _indexname_ ON _tablename_
  {(_col_ [, _col_ ]) | COMPUTED BY (<expression>)}
----

[[fblangref25-ddl-idx-createidx]]
.`CREATE INDEX` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|indexname
|Index name.
It may consist of up to 31 characters

|tablename
|The name of the table for which the index is to be built

|col
|Name of a column in the table.
Columns of the types `BLOB` and `ARRAY` and computed fields cannot be used in an index

|expression
|The expression that will compute the values for a computed index, also known as an "`expression index`"
|===

The `CREATE INDEX` statement creates an index for a table that can be used to speed up searching, sorting and grouping.
Indexes are created automatically in the process of defining constraints, such as primary key, foreign key or unique constraints.

An index can be built on the content of columns of any data type except for `BLOB` and arrays.
The name (identifier) of an index must be unique among all index names.

.Key Indexes
[NOTE]
====
When a primary key, foreign key or unique constraint is added to a table or column, an index with the same name is created automatically, without an explicit directive from the designer.
For example, the `PK_COUNTRY` index will be created automatically when you execute and commit the following statement:

[source]
----
ALTER TABLE COUNTRY ADD CONSTRAINT PK_COUNTRY
  PRIMARY KEY (ID);
----
====

[[fblangref25-ddl-idx-uq]]
==== Unique Indexes

Specifying the keyword `UNIQUE` in the index creation statement creates an index in which uniqueness will be enforced throughout the table.
The index is referred to as a "`unique index`".
A unique index is not a constraint.

Unique indexes cannot contain duplicate key values (or duplicate key value combinations, in the case of _compound_, or multi-column, or multi-segment) indexes.
Duplicated ``NULL``s are permitted, in accordance with the SQL:99 standard, in both single-segment and multi-segment indexes.

[[fblangref25-ddl-idx-drctn]]
==== Index Direction

All indexes in Firebird are uni-directional.
An index may be constructed from the lowest value to the highest (ascending order) or from the highest value to the lowest (descending order). The keywords `ASC[ENDING]` and `DESC[ENDING]` are used to specify the direction of the index.
The default index order is `ASC[ENDING]`.
It is quite valid to define both an ascending and a descending index on the same column or key set.

[TIP]
====
A descending index can be useful on a column that will be subjected to searches on the high values ("`newest`", maximum, etc.)
====

[[fblangref25-ddl-idx-exprssn]]
==== Computed (Expression) Indexes

In creating an index, you can use the `COMPUTED BY` clause to specify an expression instead of one or more columns.
Computed indexes are used in queries where the condition in a `WHERE`, `ORDER BY` or `GROUP BY` clause exactly matches the expression in the index definition.
The expression in a computed index may involve several columns in the table. 

[NOTE]
====
You can actually create a computed index on a computed field, but the index will never be used.
====

[[fblangref25-ddl-idx-limits]]
==== Limits on Indexes

Certain limits apply to indexes.

The maximum length of a key in an index is limited to  of the page size.

[[fblangref25-ddl-idx-maxno]]
===== Maximum Indexes per Table

The number of indexes that can be accommodated for each table is limited.
The actual maximum for a specific table depends on the page size and the number of columns in the indexes.

[[fblangref25-ddl-idx-idxpertbl]]
.Maximum Indexes per Table
[%autowidth,cols=">1,>1,>1,>1",stripes="none"]
|===
.2+^h|Page Size
3+^h|Number of Indexes Depending on Column Count

^h|Single
^h|2-Column
^h|3-Column

|4096
|203
|145
|113

|8192
|408
|291
|227

|16384
|818
|584
|454
|===

[[fblangref25-ddl-idx-maxstrnglgth]]
===== Character Index Limits

The maximum indexed string length is 9 bytes less than the maximum key length.
The maximum indexable string length depends on the page size and the character set.

[[fblangref25-ddl-idx-idxstrnglgth]]
.Maximum indexable (VAR)CHAR length
[%autowidth,cols=">1,>1,>1,>1,>1", stripes="none"]
|===
.2+^h|Page Size
4+^h|Maximum Indexable String Length by Charset Type

^h|1 byte/char
^h|2 byte/char
^h|3 byte/char
^h|4 byte/char

|4096
|1015
|507
|338
|253

|8192
|2039
|1019
|679
|509

|16384
|4087
|2043
|1362
|1021
|===

Only the table owner and <<fblangref25-security-administrators,administrators>> have the authority to use `CREATE INDEX`.

[[fblangref25-ddl-tbl-crtidxexmpls]]
==== Examples Using `CREATE INDEX`

. Creating an index for the `UPDATER_ID` column in the `SALARY_HISTORY` table
+
[source]
----
CREATE INDEX IDX_UPDATER
  ON SALARY_HISTORY (UPDATER_ID);
----
. Creating an index with keys sorted in the descending order for the `CHANGE_DATE` column in the `SALARY_HISTORY` table
+
[source]
----
CREATE DESCENDING INDEX IDX_CHANGE
  ON SALARY_HISTORY (CHANGE_DATE);
----
. Creating a multi-segment index for the `ORDER_STATUS`, `PAID` columns in the `SALES` table
+
[source]
----
CREATE INDEX IDX_SALESTAT
  ON SALES (ORDER_STATUS, PAID);
----
. Creating an index that does not permit duplicate values for the `NAME` column in the `COUNTRY` table
+
[source]
----
CREATE UNIQUE INDEX UNQ_COUNTRY_NAME
  ON COUNTRY (NAME);
----
. Creating a computed index for the `PERSONS` table
+
[source]
----
CREATE INDEX IDX_NAME_UPPER ON PERSONS
  COMPUTED BY (UPPER (NAME));
----
+
An index like this can be used for a case-insensitive search:
+
[source]
----
SELECT *
FROM PERSONS
WHERE UPPER(NAME) STARTING WITH UPPER('Iv');
----

.See also
<<fblangref25-ddl-idx-altridx,`ALTER INDEX`>>, <<fblangref25-ddl-idx-dropidx,`DROP INDEX`>>

[[fblangref25-ddl-idx-altridx]]
=== `ALTER INDEX`

.Used for
Activating or deactivating an index; rebuilding an index

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER INDEX _indexname_ {ACTIVE | INACTIVE}
----

[[fblangref25-ddl-idx-alteridx]]
.`ALTER INDEX` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|indexname
|Index name
|===

The `ALTER INDEX` statement activates or deactivates an index.
There is no facility on this statement for altering any attributes of the index. 

* With the `INACTIVE` option, the index is switched from the active to inactive state.
The effect is similar to the `DROP INDEX` statement except that the index definition remains in the database.
Altering a constraint index to the inactive state is not permitted.
+ 
An active index can be deactivated if there are no queries using that index;
otherwise, an "`object in use`" error is returned.
+ 
Activating an inactive index is also safe.
However, if there are active transactions modifying the table, the transaction containing the `ALTER INDEX` statement will fail if it has the `NOWAIT` attribute.
If the transaction is in `WAIT` mode, it will wait for completion of concurrent transactions.
+ 
On the other side of the coin, if our `ALTER INDEX` succeeds and starts to rebuild the index at `COMMIT`, other transactions modifying that table will fail or wait, according to their `WAIT`/`NO WAIT` attributes.
The situation is exactly the same for `CREATE INDEX`.
+
.How is it Useful?
NOTE: It might be useful to switch an index to the inactive state whilst inserting, updating or deleting a large batch of records in the table that owns the index.
* With the `ACTIVE` option, if the index is in the inactive state, it will be switched to active state and the system rebuilds the index.
+
.How is it Useful?
NOTE: Even if the index is _active_ when `ALTER INDEX ... ACTIVE` is executed, the index will be rebuilt.
Rebuilding indexes can be a useful piece of houskeeping to do, occasionally, on the indexes of a large table in a database that has frequent inserts, updates or deletes but is infrequently restored.

[[fblangref25-ddl-idx-altrcnstrntidx]]
==== Use of `ALTER INDEX` on a Constraint Index

Altering the enforcing index of a `PRIMARY KEY`, `FOREIGN KEY` or `UNIQUE` constraint to `INACTIVE` is not permitted.
However, `ALTER INDEX ... ACTIVE` works just as well with constraint indexes as it does with others, as an index rebuilding tool.

Only the table owner and <<fblangref25-security-administrators,administrators>> have the authority to use `ALTER INDEX`.

==== ALTER INDEX Examples

. Deactivating the `IDX_UPDATER` index
+
[source]
----
ALTER INDEX IDX_UPDATER INACTIVE;
----
. Switching the `IDX_UPDATER` index back to the active state and rebuilding it
+
[source]
----
ALTER INDEX IDX_UPDATER ACTIVE;
----

.See also
<<fblangref25-ddl-idx-create,`CREATE INDEX`>>, <<fblangref25-ddl-idx-dropidx,`DROP INDEX`>>, `SET STATISTICS`

[[fblangref25-ddl-idx-dropidx]]
=== `DROP INDEX`

.Used for
Deleting an index

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP INDEX _indexname_
----

[[fblangref25-ddl-tbl-idx-dropidx]]
.`DROP INDEX` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|indexname
|Index name
|===

The `DROP INDEX` statement deletes the named index from the database.

[NOTE]
====
A constraint index cannot deleted using `DROP INDEX`.
Constraint indexes are dropped during the process of executing the command `ALTER TABLE ... DROP CONSTRAINT ...`.
====

Only the table owner and <<fblangref25-security-administrators,administrators>> have the authority to use `DROP INDEX`.

.DROP INDEX Example
Deleting the `IDX_UPDATER` index

[source]
----
DROP INDEX IDX_UPDATER;
----

.See also
<<fblangref25-ddl-idx-create,`CREATE INDEX`>>, <<fblangref25-ddl-idx-altridx,`ALTER INDEX`>>

[[fblangref25-ddl-idx-setsttstcs]]
=== `SET STATISTICS`

.Used for
Recalculating the selectivity of an index

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
SET STATISTICS INDEX _indexname_
----

[[fblangref25-ddl-tbl-idx-setsttstcs]]
.`SET STATISTICS` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|indexname
|Index name
|===

The `SET STATISTICS` statement recalculates the selectivity of the specified index.

[[fblangref25-ddl-idx-selectivity]]
==== Index Selectivity

The selectivity of an index is the result of evaluating the number of rows that can be selected in a search on every index value.
A unique index has the maximum selectivity because it is impossible to select more than one row for each value of an index key if it is used.
Keeping the selectivity of an index up to date is important for the optimizer's choices in seeking the most optimal query plan.

Index statistics in Firebird are not automatically recalculated in response to large batches of inserts, updates or deletions.
It may be beneficial to recalculate the selectivity of an index after such operations because the selectivity tends to become outdated.

[NOTE]
====
The statements `CREATE INDEX` and `ALTER INDEX ACTIVE` both store index statistics that completely correspond to the contents of the newly-[re]built index.
====

The selectivity of an index can be recalculated by the owner of the table or an <<fblangref25-security-administrators,administrator>>.
It can be performed under concurrent load without risk of corruption.
However, be aware that, under concurrent load, the newly calculated statistics could become outdated as soon as `SET STATISTICS` finishes.

==== Example Using SET STATISTICS

Recalculating the selectivity of the index IDX_UPDATER

[source]
----
SET STATISTICS INDEX IDX_UPDATER;
----

.See also
<<fblangref25-ddl-idx-create,`CREATE INDEX`>>, <<fblangref25-ddl-idx-altridx,`ALTER INDEX`>>

[[fblangref25-ddl-view]]
== `VIEW`

A view is a virtual table that is actually a stored and named `SELECT` query for retrieving data of any complexity.
Data can be retrieved from one or more tables, from other views and also from selectable stored procedures.

Unlike regular tables in relational databases, a view is not an independent data set stored in the database.
The result is dynamically created as a data set when the view is selected.

The metadata of a view are available to the process that generates the binary code for stored procedures and triggers, just as though they were concrete tables storing persistent data.

[[fblangref25-ddl-view-create]]
=== `CREATE VIEW`

.Used for
Creating a view

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE VIEW _viewname_ [<full_column_list>]
  AS <select_statement>
  [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-createview]]
.`CREATE VIEW` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|viewname
|View name, maximum 31 characters

|select_statement
|SELECT statement

|full_column_list
|The list of columns in the view

|colname
|View column name.
Duplicate column names are not allowed.
|===

The `CREATE VIEW` statement creates a new view.
The identifier (name) of a view must be unique among the names of all views, tables and stored procedures in the database.

The name of the new view can be followed by the list of column names that should be returned to the caller when the view is invoked.
Names in the list do not have to be related to the names of the columns in the base tables from which they derive.

If the view column list is omitted, the system will use the column names and/or aliases from the `SELECT` statement.
If duplicate names or non-aliased expression-derived columns make this impossible to obtain a valid list, creation of the view fails with an error.

The number of columns in the view's list must exactly match the number of columns in the selection list of the underlying SELECT statement in the view definition.

.Additional Points
[NOTE]
====
* If the full list of columns is specified, it makes no sense to specify aliases in the `SELECT` statement because the names in the column list will override them
* The column list is optional if all the columns in the `SELECT` are explicitly named and are unique in the selection list
====

[[fblangref25-ddl-view-create-updatable]]
==== Updatable Views

A view can be updatable or read-only.
If a view is updatable, the data retrieved when this view is called can be changed by the DML statements `INSERT`, `UPDATE`, `DELETE`, `UPDATE OR INSERT` or `MERGE`.
Changes made in an updatable view are applied to the underlying table(s).

A read-only view can be made updateable with the use of triggers.
Once triggers have been defined on a view, changes posted to it will never be written automatically to the underlying table, even if the view was updateable to begin with.
It is the responsibility of the programmer to ensure that the triggers update (or delete from, or insert into) the base tables as needed.

A view will be automatically updatable if all the following conditions are met:

* the `SELECT` statement queries only one table or one updatable view
* the `SELECT` statement does not call any stored procedures
* each base table (or base view) column not present in the view definition is covered by one of the following conditions:
** it is nullable
** it has a non-``NULL`` default value
** it has a trigger that supplies a permitted value
* the `SELECT` statement contains no fields derived from subqueries or other expressions
* the `SELECT` statement does not contain fields defined through aggregate functions, such as `MIN`, `MAX`, `AVG`, `SUM`, `COUNT`, `LIST`
* the `SELECT` statement contains no `ORDER BY` or `GROUP BY` clause
* the `SELECT` statement does not include the keyword `DISTINCT` or row-restrictive keywords such as `ROWS`, `FIRST`, `SKIP`

[[fblangref25-ddl-view-create-chkopt]]
==== `WITH CHECK OPTION`

The optional `WITH CHECK OPTION` clause requires an updatable view to check whether new or updated data meet the condition specified in the `WHERE` clause of the `SELECT` statement.
Every attempt to insert a new record or to update an existing one is checked whether the new or updated record would meet the `WHERE` criteria.
If they fail the check, the operation is not performed and an appropriate error message is returned.

`WITH CHECK OPTION` can be specified only in a `CREATE VIEW` statement in which a `WHERE` clause is present to restrict the output of the main `SELECT` statement.
An error message is returned otherwise.

.Please note:
[IMPORTANT]
====
If `WITH CHECK OPTION` is used, the engine checks the input against the `WHERE` clause before passing anything to the base relation.
Therefore, if the check on the input fails, any default clauses or triggers on the base relation that might have been designed to correct the input will never come into action.

Furthermore, view fields omitted from the `INSERT` statement are passed as ``NULL``s to the base relation, regardless of their presence or absence in the `WHERE` clause.
As a result, base table defaults defined on such fields will not be applied.
Triggers, on the other hand, will fire and work as expected.

For views that do not have `WITH CHECK OPTION`, fields omitted from the `INSERT` statement are not passed to the base relation at all, so any defaults will be applied.
====

[[fblangref25-ddl-view-createwho]]
==== Ownership of a View

The creator of a view becomes its owner.

To create a view, a non-admin user needs at least `SELECT` access to the underlying table(s) and/or view(s), and the `EXECUTE` privilege on any selectable stored procedures involved.

To enable insertions, updates and deletions through the view, the creator/owner must also possess the corresponding `INSERT`,  `UPDATE` and `DELETE` rights on the base object(s).

Granting other users privileges on the view is only possible if the view owner himself has these privileges on the underlying objects `WITH GRANT OPTION`.
It will always be the case if the view owner is also the owner of  the underlying objects.

==== Examples of Creating Views

. Creating view returning the `JOB_CODE` and `JOB_TITLE` columns only for those jobs where `MAX_SALARY` is less than $15,000.
+
[source]
----
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY < 15000;
----
. Creating a view returning the `JOB_CODE` and `JOB_TITLE` columns only for those jobs where `MAX_SALARY` is less than $15,000.
Whenever a new record is inserted or an existing record is updated, the `MAX_SALARY < 15000` condition will be checked.
If the condition is not true, the insert/update operation will be rejected.
+
[source]
----
CREATE VIEW ENTRY_LEVEL_JOBS AS
SELECT JOB_CODE, JOB_TITLE
FROM JOB
WHERE MAX_SALARY < 15000
WITH CHECK OPTION;
----
. Creating a view with an explicit column list.
+
[source]
----
CREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1
FROM PRICE;
----
. Creating a view with the help of aliases for fields in the `SELECT` statement (the same result as in Example 3).
+
[source]
----
CREATE VIEW PRICE_WITH_MARKUP AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.1 AS COST_WITH_MARKUP
FROM PRICE;
----
. Creating a read-only view based on two tables and a stored procedure.
+
[source]
----
CREATE VIEW GOODS_PRICE AS
SELECT
  goods.name AS goodsname,
  price.cost AS cost,
  b.quantity AS quantity
FROM
  goods
  JOIN price ON goods.code_goods = price.code_goods
  LEFT JOIN sp_get_balance(goods.code_goods) b ON 1 = 1;
----

.See also
<<fblangref25-ddl-view-alter,`ALTER VIEW`>>, <<fblangref25-ddl-view-crtoralter,`CREATE OR ALTER VIEW`>>, <<fblangref25-ddl-view-recreate,`RECREATE VIEW`>>, <<fblangref25-ddl-view-drop,`DROP VIEW`>>

[[fblangref25-ddl-view-alter]]
=== `ALTER VIEW`

.Used for
Modifying an existing view

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER VIEW _viewname_ [<full_column_list>]
    AS <select_statement>
    [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-alterview]]
.`ALTER VIEW` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|viewname
|Name of an existing view

|select_statement
|SELECT statement

|full_column_list
|The list of columns in the view

|colname
|View column name.
Duplicate column names are not allowed.
|===

Use the `ALTER VIEW` statement for changing the definition of an existing view.
Privileges for views remain intact and dependencies are not affected.

The syntax of the `ALTER VIEW` statement corresponds completely with that of ``CREATE VIEW``. 

[CAUTION]
====
Be careful when you change the number of columns in a view.
Existing application code and PSQL modules that access the view may become invalid.
For information on how to detect this kind of problem in stored procedures and trigger, see <<fblangref25-appx01-supp-rdb-validblr,[ref]_The RDB$VALID_BLR Field_>> in the Appendix.
====

Only the view owner and <<fblangref25-security-administrators,administrators>> have the authority to use `ALTER VIEW`.

.Example using `ALTER VIEW`
Altering the view `PRICE_WITH_MARKUP`

[source]
----
ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
----

.See also
<<fblangref25-ddl-view-create,`CREATE VIEW`>>, <<fblangref25-ddl-view-crtoralter,`CREATE OR ALTER VIEW`>>, <<fblangref25-ddl-view-recreate,`RECREATE VIEW`>>

[[fblangref25-ddl-view-crtoralter]]
=== `CREATE OR ALTER VIEW`

.Used for
Creating a new view or altering an existing view.

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER VIEW _viewname_ [<full_column_list>]
  AS <select_statement>
  [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-crtalterview]]
.`CREATE OR ALTER VIEW` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|viewname
|Name of a view which may or may not exist

|select_statement
|SELECT statement

|full_column_list
|The list of columns in the view

|colname
|View column name.
Duplicate column names are not allowed.
|===

Use the `CREATE OR ALTER VIEW` statement for changing the definition of an existing view or creating it if it does not exist.
Privileges for an existing view remain intact and dependencies are not affected.

The syntax of the `CREATE OR ALTER VIEW` statement corresponds completely with that of `CREATE VIEW`.

.Example
Creating the new view `PRICE_WITH_MARKUP` view or altering it if it already exists:

[source]
----
CREATE OR ALTER VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
----

.See also
<<fblangref25-ddl-view-create,`CREATE VIEW`>>, <<fblangref25-ddl-view-alter,`ALTER VIEW`>>, <<fblangref25-ddl-view-recreate,`RECREATE VIEW`>>

[[fblangref25-ddl-view-drop]]
=== `DROP VIEW`

.Used for
Deleting (dropping) a view

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
DROP VIEW _viewname_
----

[[fblangref25-ddl-tbl-view-dropview]]
.`DROP VIEW` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|viewname
|View name
|===

The `DROP VIEW` statement deletes an existing view.
The statement will fail if the view has dependencies.

Only the view owner and <<fblangref25-security-administrators,administrators>> have the authority to use `DROP VIEW`.

.Example
Deleting the PRICE_WITH_MARKUP view. 
[source]
----
DROP VIEW PRICE_WITH_MARKUP;
----

.See also
<<fblangref25-ddl-view-create,`CREATE VIEW`>>, <<fblangref25-ddl-view-recreate,`RECREATE VIEW`>>, <<fblangref25-ddl-view-crtoralter,`CREATE OR ALTER VIEW`>>

[[fblangref25-ddl-view-recreate]]
=== `RECREATE VIEW`

.Used for
Creating a new view or recreating an existing view

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE VIEW _viewname_ [<full_column_list>]
  AS <select_statement>
  [WITH CHECK OPTION]

<full_column_list> ::= (_colname_ [, _colname_ ...])
----

[[fblangref25-ddl-tbl-view-recreate]]
.`RECREATE VIEW` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|viewname
|View name, maximum 31 characters

|select_statement
|SELECT statement

|full_column_list
|The list of columns in the view

|colname
|View column name.
Duplicate column names are not allowed.
|===

Creates or recreates a view.
If there is a view with this name already, the engine will try to drop it before creating the new instance.
If the existing view cannot be dropped, because of dependencies or insufficient rights, for example, `RECREATE VIEW` fails with an error.

.Example
Creating the new view `PRICE_WITH_MARKUP` view or recreating it, if it already exists.

[source]
----
RECREATE VIEW PRICE_WITH_MARKUP (
  CODE_PRICE,
  COST,
  COST_WITH_MARKUP
) AS
SELECT
  CODE_PRICE,
  COST,
  COST * 1.15
FROM PRICE;
----

.See also
<<fblangref25-ddl-view-create,`CREATE VIEW`>>, <<fblangref25-ddl-view-drop,`DROP VIEW`>>, <<fblangref25-ddl-view-crtoralter,`CREATE OR ALTER VIEW`>>

[[fblangref25-ddl-trgr]]
== `TRIGGER`

A trigger is a special type of stored procedure that is not called directly, instead being executed when a specified event occurs in the associated table or view.
A trigger is specific to one and only one relation (table or view) and one phase in the timing of the event (_BEFORE_ or _AFTER_).
It can be specified to execute for one specific event (insert, update, delete) or for some combination of two or three of those events.

Another form of trigger -- known as a "`database trigger`" -- can be specified to fire in association with the start or end of a user session (connection) or a user transaction.

[[fblangref25-ddl-trgr-create]]
=== `CREATE TRIGGER`

.Used for
Creating a new trigger

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE TRIGGER _trigname_
  { <relation_trigger_legacy>
  | <relation_trigger_sql2003>
  | <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<relation_trigger_legacy> ::=
  FOR {_tablename_ | _viewname_}
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <mutation_list>
  [POSITION _number_]

<relation_trigger_sql2003> ::=
  [ACTIVE | INACTIVE]
  {BEFORE | AFTER} <mutation_list>
  [POSITION _number_]
  ON {_tablename_ | _viewname_}

<database_trigger> ::=
  [ACTIVE | INACTIVE] ON <db_event> [POSITION _number_]

<mutation_list> ::=
  <mutation> [OR <mutation> [OR <mutation>]]

<mutation> ::= { INSERT | UPDATE | DELETE }

<db_event> ::=
  { CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK }

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; ]
----

[[fblangref25-ddl-trgr-createtrigger]]
.`CREATE TRIGGER` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|trigname
|Trigger name consisting of up to 31 characters.
It must be unique among all trigger names in the database.

|relation_trigger_legacy
|Legacy style of trigger declaration for a relation trigger

|relation_trigger_sql2003
|Relation trigger declaration compliant with the SQL:2003 standard

|database_trigger
|Database trigger declaration

|tablename
|Name of the table with which the relation trigger is associated

|viewname
|Name of the view with which the relation trigger is associated

|mutation_list
|List of relation (table {vbar} view) events

|number
|Position of the trigger in the firing order.
From 0 to 32,767

|db_event
|Connection or transaction event

|declarations
|Section for declaring local variables and named cursors

|declare_var
|Local variable declaration

|declare_cursor
|Named cursor declaration

|PSQL_statements
|Statements in Firebird's programming language (PSQL)
|===

The `CREATE TRIGGER` statement is used for creating a new trigger.
A trigger can be created either for a _relation (table | view) event_ (or a combination of events), or for a _database event_.

`CREATE TRIGGER`, along with its associates `ALTER TRIGGER`, `CREATE OR ALTER TRIGGER` and `RECREATE TRIGGER`, is a _compound statement_, consisting of a header and a body.
The header specifies the name of the trigger, the name of the relation (for a relation trigger), the phase of the trigger and the event[s] it applies to.
The body consists of optional declarations of local variables and named cursors followed by one or more statements, or blocks of statements, all enclosed in an outer block that begins with the keyword `BEGIN` and ends with the keyword `END`.
Declarations and embedded statements are terminated with semi-colons ('```;```').

The name of the trigger must be unique among all trigger names.

[[fblangref25-ddl-terminators01]]
==== Statement Terminators

Some SQL statement editors -- specifically the _isql_ utility that comes with Firebird and possibly some third-party editors -- employ an internal convention that requires all statements to be terminated with a semi-colon.
This creates a conflict with PSQL syntax when coding in these environments.
If you are unacquainted with this problem and its solution, please study the details in the PSQL chapter in the section entitled <<fblangref25-sidebar01,Switching the Terminator in _isql_>>.

[[fblangref25-ddl-trgr-relntrigger]]
==== Relation Triggers (on Tables or Views)

Relation triggers are executed at the row (record) level every time the row image changes.
A trigger can be either `ACTIVE` or `INACTIVE`.
Only active triggers are executed.
Triggers are created `ACTIVE` by default.

[[fblangref25-ddl-trgr-relntrigger-form]]
===== Forms of Declaration

Firebird supports two forms of declaration for relation triggers: 

* The original, legacy syntax
* The SQL:2003 standard-compliant form (recommended)

The SQL:2003 standard-compliant form is the recommended one.

A relation trigger specifies -- among other things -- a _phase_ and one or more _events_.

[[fblangref25-ddl-trgr-relntrigger-rowphase]]
===== Phase

Phase concerns the timing of the trigger with regard to the change-of-state event in the row of data: 

* A `BEFORE` trigger is fired before the specified database operation (insert, update or delete) is carried out
* An `AFTER` trigger is fired after the database operation has been completed

[[fblangref25-ddl-trgr-relntrigger-rowevent]]
===== Row Events

A relation trigger definition specifies at least one of the DML operations `INSERT`, `UPDATE` and `DELETE`, to indicate one or more events on which the trigger should fire.
If multiple operations are specified, they must be separated by the keyword `OR`.
No operation may occur more than once.

Within the statement block, the Boolean context variables <<fblangref25-contextvars-inserting,`INSERTING`>>, <<fblangref25-contextvars-updating,`UPDATING`>> and <<fblangref25-contextvars-deleting,`DELETING`>> can be used to test which operation is currently executing.

[[fblangref25-ddl-trgr-relntrigger-position]]
===== Firing Order of Triggers

The keyword `POSITION` allows an optional execution order ("`firing order`") to be specified for a series of triggers that have the same phase and event as their target.
The default position is 0.
If no positions are specified, or if several triggers have a single position number, the triggers will be executed in the alphabetical order of their names.

[[fblangref25-ddl-trgr-relntrigger-declrtns]]
===== Variable Declarations

The optional declarations section beneath the keyword `AS` in the header of the trigger is for defining variables and named cursors that are local to the trigger.
For more details, see <<fblangref25-psql-declare-variable,`DECLARE VARIABLE`>> and <<fblangref25-psql-declare-cursor,`DECLARE CURSOR`>> in the <<fblangref25-psql,Procedural SQL>> chapter.

[[fblangref25-ddl-trgr-relntrigger-body]]
===== The Trigger Body

The local declarations (if any) are the final part of a trigger's header section.
The trigger body follows, where one or more blocks of PSQL statements are enclosed in a structure that starts with the keyword `BEGIN` and terminates with the keyword `END`.

Only the owner of the view or table and <<fblangref25-security-administrators,administrators>> have the authority to use `CREATE TRIGGER`.

===== Examples of CREATE TRIGGER for Tables and Views

. Creating a trigger in the "`legacy`" form, firing before the event of inserting a new record into the `CUSTOMER` table occurs.
+
[source]
----
CREATE TRIGGER SET_CUST_NO FOR CUSTOMER
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.CUST_NO IS NULL) THEN
    NEW.CUST_NO = GEN_ID(CUST_NO_GEN, 1);
END
----
. Creating a trigger firing before the event of inserting a new record into the `CUSTOMER` table in the SQL:2003 standard-compliant form.
+
[source]
----
CREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
----
. Creating a trigger that will file after either inserting, updating or deleting a record in the `CUSTOMER` table.
+
[source]
----
CREATE TRIGGER TR_CUST_LOG
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 10
ON CUSTOMER
AS
BEGIN
  INSERT INTO CHANGE_LOG (LOG_ID,
                          ID_TABLE,
                          TABLE_NAME,
                          MUTATION)
  VALUES (NEXT VALUE FOR SEQ_CHANGE_LOG,
          OLD.CUST_NO,
          'CUSTOMER',
          CASE
            WHEN INSERTING THEN 'INSERT'
            WHEN UPDATING  THEN 'UPDATE'
            WHEN DELETING  THEN 'DELETE'
          END);
END
----

[[fblangref25-ddl-trgr-dbtrigger]]
==== Database Triggers

Triggers can be defined to fire upon "`database events`", which really refers to a mixture of events that act across the scope of a session (connection) and events that act across the scope of an individual transaction:

* `CONNECT`
* `DISCONNECT`
* `TRANSACTION START`
* `TRANSACTION COMMIT`
* `TRANSACTION ROLLBACK`

[[fblangref25-ddl-trgr-dbtrigger-exec]]
===== Execution of Database Triggers and Exception Handling

`CONNECT` and `DISCONNECT` triggers are executed in a transaction created specifically for this purpose.
If all goes well, the transaction is committed.
Uncaught exceptions cause the transaction to roll back, and 

* for a `CONNECT` trigger, the connection is then broken and the exception is returned to the client
* for a `DISCONNECT` trigger, exceptions are not reported.
The connection is broken as intended

`TRANSACTION` triggers are executed within the transaction whose start, commit or rollback evokes them.
The action taken after an uncaught exception depends on the event: 

* In a `TRANSACTION START` trigger, the exception is reported to the client and the transaction is rolled back
* In a `TRANSACTION COMMIT` trigger, the exception is reported, the trigger's actions so far are undone and the commit is cancelled
* In a `TRANSACTION ROLLBACK` trigger, the exception is not reported and the transaction is rolled back as intended.

[[fblangref25-ddl-trgr-dbtrigger-traps]]
====== Traps

Obviously there is no direct way of knowing if a `DISCONNECT` or `TRANSACTION ROLLBACK` trigger caused an exception.
It also follows that the connection to the database cannot happen if a `CONNECT` trigger causes an exception and a transaction cannot start if a `TRANSACTION START` trigger causes one, either.
Both phenomena effectively lock you out of your database until you get in there with database triggers suppressed and fix the  bad code.

[float]
[[fblangref25-ddl-trgr-dbtrigger-notrgr]]
====== Trigger Suppression

Some Firebird command-line tools have been supplied with switches that an administrator can use to suppress the automatic firing of database triggers.
So far, they are:

[source]
----
gbak -nodbtriggers
isql -nodbtriggers
nbackup -T
----

[[fblangref25-ddl-trgr-dbtrigger-2pc]]
====== Two-phase Commit

In a two-phase commit scenario, `TRANSACTION COMMIT` triggers fire in the prepare phase, not at the commit.

[[fblangref25-ddl-trgr-dbtrigger-caveats]]
====== Some Caveats

. The use of the `IN AUTONOMOUS TRANSACTION DO` statement in the database event triggers related to transactions (`TRANSACTION START`, `TRANSACTION ROLLBACK`, `TRANSACTION COMMIT`) may cause the autonomous transaction to enter an infinite loop
. The `DISCONNECT` and `TRANSACTION ROLLBACK` event triggers will not be executed when clients are disconnected via monitoring tables (`DELETE FROM MON$ATTACHMENTS`)

Only the database owner and <<fblangref25-security-administrators,administrators>> have the authority to create database triggers.

===== Examples of CREATE TRIGGER for "`Database Triggers`"

. Creating a trigger for the event of connecting to the database that logs users logging into the system.
The trigger is created as inactive.
+
[source]
----
CREATE TRIGGER tr_log_connect
INACTIVE ON CONNECT POSITION 0
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_TIMESTAMP);
END
----
. Creating a trigger for the event of connecting to the database that does not permit any users, except for SYSDBA, to log in during off hours.
+
[source]
----
CREATE EXCEPTION E_INCORRECT_WORKTIME 'The working day has not started yet.';

CREATE TRIGGER TR_LIMIT_WORKTIME ACTIVE
ON CONNECT POSITION 1
AS
BEGIN
  IF ((CURRENT_USER <> 'SYSDBA') AND
      NOT (CURRENT_TIME BETWEEN time '9:00' AND time '17:00')) THEN
    EXCEPTION E_INCORRECT_WORKTIME;
END
----

.See also
<<fblangref25-ddl-trgr-alter,`ALTER TRIGGER`>>, <<fblangref25-ddl-trgr-crtalter,`CREATE OR ALTER TRIGGER`>>, <<fblangref25-ddl-trgr-recreate,`RECREATE TRIGGER`>>, <<fblangref25-ddl-trgr-drop,`DROP TRIGGER`>>

[[fblangref25-ddl-trgr-alter]]
=== `ALTER TRIGGER`

.Used for
Modifying and deactivating an existing trigger 

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER TRIGGER _trigname_
  [ACTIVE | INACTIVE]
  [{BEFORE | AFTER} <mutation_list> | ON <db_event>]
  [POSITION _number_]
  [
    AS
      [<declarations>]
    BEGIN
      [<PSQL_statements>]
    END
  ]

<mutation_list> ::=
  <mutation> [OR <mutation> [OR <mutation>]]

<mutation> ::= { INSERT | UPDATE | DELETE }

<db_event> ::=
  { CONNECT
  | DISCONNECT
  | TRANSACTION START
  | TRANSACTION COMMIT
  | TRANSACTION ROLLBACK }

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; ]
----

[[fblangref25-ddl-tbl-altertrigger]]
.`ALTER TRIGGER` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|trigname
|Name of an existing trigger

|mutation_list
|List of relation (table {vbar} view) events

|number
|Position of the trigger in the firing order.
From 0 to 32,767

|declarations
|Section for declaring local variables and named cursors

|declare_var
|Local variable declaration

|declare_cursor
|Named cursor declaration

|PSQL_statements
|Statements in Firebird's programming language (PSQL)
|===

The `ALTER TRIGGER` statement allows certain changes to the header and body of a trigger.

[[fblangref25-ddl-trgr-alterwhat]]
==== Permitted Changes to Triggers

* Status (`ACTIVE | INACTIVE`)
* Phase (`BEFORE | AFTER`)
* Events;
but relation trigger events cannot be changed to database trigger events, nor vice versa
* Position in the firing order
* Modifications to code in the trigger body

If some element was not specified, it remains unchanged.

.Reminders
[NOTE]
====
The `BEFORE` keyword directs that the trigger be executed before the associated event occurs;
the `AFTER` keyword directs that it be executed after the event.

More than one relation event -- `INSERT`, `UPDATE`, `DELETE` -- can be covered in a single trigger.
The events should be separated with the keyword `OR`.
No event should be mentioned more than once.

The keyword `POSITION` allows an optional execution order ("`firing order`") to be specified for a series of triggers that have the same phase and event as their target.
The default position is 0.
If no positions are specified, or if several triggers have a single position number, the triggers will be executed in the alphabetical order of their names.
====

<<fblangref25-security-administrators,Administrators>> and the following users have the authority to use `ALTER TRIGGER`:

* For relation triggers, the owner of the table
* For database triggers, the owner of the database

==== Examples using ALTER TRIGGER

. Deactivating the `set_cust_no` trigger (switching it to the inactive status).
+
[source]
----
ALTER TRIGGER set_cust_no INACTIVE;
----
. Changing the firing order position of the `set_cust_no` trigger.
+
[source]
----
ALTER TRIGGER set_cust_no POSITION 14;
----
. Switching the `TR_CUST_LOG` trigger to the inactive status and modifying the list of events.
+
[source]
----
ALTER TRIGGER TR_CUST_LOG
INACTIVE AFTER INSERT OR UPDATE;
----
. Switching the `tr_log_connect trigger` to the active status, changing its position and body.
+
[source]
----
ALTER TRIGGER tr_log_connect
ACTIVE POSITION 1
AS
BEGIN
  INSERT INTO LOG_CONNECT (ID,
                           USERNAME,
                           ROLENAME,
                           ATIME)
  VALUES (NEXT VALUE FOR SEQ_LOG_CONNECT,
          CURRENT_USER,
          CURRENT_ROLE,
          CURRENT_TIMESTAMP);
END
----

.See also
<<fblangref25-ddl-trgr-create,`CREATE TRIGGER`>>, <<fblangref25-ddl-trgr-crtalter,`CREATE OR ALTER TRIGGER`>>, <<fblangref25-ddl-trgr-recreate,`RECREATE TRIGGER`>>, <<fblangref25-ddl-trgr-drop,`DROP TRIGGER`>>

[[fblangref25-ddl-trgr-crtalter]]
=== `CREATE OR ALTER TRIGGER`

.Used for
Creating a new trigger or altering an existing trigger

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER TRIGGER _trigname_  {
  <relation_trigger_legacy> |
  <relation_trigger_sql2003> |
  <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

For the full detail of the syntax, see <<fblangref25-ddl-trgr-create,`CREATE TRIGGER`>>.

The `CREATE OR ALTER TRIGGER` statement creates a new trigger if it does not exist;
otherwise it alters and recompiles it with the privileges intact and dependencies unaffected.

.Example using CREATE OR ALTER TRIGGER
Creating a new trigger if it does not exist or altering it if it does exist.

[source]
----
CREATE OR ALTER TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
----

.See also
<<fblangref25-ddl-trgr-create,`CREATE TRIGGER`>>, <<fblangref25-ddl-trgr-alter,`ALTER TRIGGER`>>, <<fblangref25-ddl-trgr-recreate,`RECREATE TRIGGER`>>

[[fblangref25-ddl-trgr-drop]]
=== `DROP TRIGGER`

.Used for
Deleting an existing trigger

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP TRIGGER _trigname_
----

[[fblangref25-ddl-tbl-droptrigger]]
.`DROP TRIGGER` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|trigname
|Trigger name
|===

The `DROP TRIGGER` statement deletes an existing trigger.

<<fblangref25-security-administrators,Administrators>> and the following users have the authority to use `DROP TRIGGER`:

* For relation triggers, the owner of the table
* For database triggers, the owner of the database

.Example using DROP TRIGGER
Deleting the `set_cust_no` trigger.

[source]
----
DROP TRIGGER set_cust_no;
----

.See also
<<fblangref25-ddl-trgr-create,`CREATE TRIGGER`>>, <<fblangref25-ddl-trgr-recreate,`RECREATE TRIGGER`>>

[[fblangref25-ddl-trgr-recreate]]
=== `RECREATE TRIGGER`

.Used for
Creating a new trigger or recreating an existing trigger

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE TRIGGER _trigname_ {
  <relation_trigger_legacy> |
  <relation_trigger_sql2003> |
  <database_trigger> }
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

For the full detail of the syntax, see <<fblangref25-ddl-trgr-create,`CREATE TRIGGER`>>.

The `RECREATE TRIGGER` statement creates a new trigger if no trigger with the specified name exists;
otherwise the `RECREATE TRIGGER` statement tries to delete the existing trigger and create a new one.
The operation will fail on `COMMIT` if the trigger is in use.

[WARNING]
====
Be aware that dependency errors are not detected until the `COMMIT` phase of this operation.
====

.Example using RECREATE TRIGGER
Creating or recreating the `set_cust_no` trigger.

[source]
----
RECREATE TRIGGER set_cust_no
ACTIVE BEFORE INSERT POSITION 0 ON customer
AS
BEGIN
  IF (NEW.cust_no IS NULL) THEN
    NEW.cust_no = GEN_ID(cust_no_gen, 1);
END
----

.See also
<<fblangref25-ddl-trgr-create,`CREATE TRIGGER`>>, <<fblangref25-ddl-trgr-drop,`DROP TRIGGER`>>, <<fblangref25-ddl-trgr-crtalter,`CREATE OR ALTER TRIGGER`>>

[[fblangref25-ddl-procedure]]
== `PROCEDURE`

A stored procedure is a software module that can be called from a client, another procedure, an executable block or a trigger.
Stored procedures, executable blocks and triggers are written in procedural SQL (PSQL).
Most SQL statements are available in PSQL as well, sometimes with limitations or extensions.
Among notable exceptions are DDL and transaction control statements.

Stored procedures can have many input and output parameters.

[[fblangref25-ddl-proc-create]]
=== `CREATE PROCEDURE`

.Used for
Creating a new stored procedure

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<inparam> ::= <param_decl> [{= | DEFAULT} <value>]

<outparam> ::= <param_decl>

<value> ::= {<literal> | NULL | <context_var>}

<param_decl> ::= _paramname_ <type> [NOT NULL]
  [COLLATE _collation_]

<type> ::=
    <datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN __rel__.__col__

<datatype> ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR}} [VARYING]
    [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; ]
----

[[fblangref25-ddl-proc-createproc]]
.`CREATE PROCEDURE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|procname
|Stored procedure name consisting of up to 31 characters.
Must be unique among all table, view and procedure names in the database

|inparam
|Input parameter description

|outparam
|Output parameter description

|declarations
|Section for declaring local variables and named cursors

|declare_var
|Local variable declaration

|declare_cursor
|Named cursor declaration

|PSQL_statements
|Procedural SQL statements

|literal
|A literal value that is assignment-compatible with the data type of the parameter

|context_var
|Any context variable whose type is compatible with the data type of the parameter

|paramname
|The name of an input or output parameter of the procedure.
It may consist of up to 31 characters.
The name of the parameter must be unique among input and output parameters of the procedure and its local variables

|datatype
|SQL data type

|collation
|Collation sequence

|domain
|Domain name

|rel
|Table or view name

|col
|Table or view column name

|precision
|The total number of significant digits that the parameter should be able to hold (1..18)

|scale
|The number of digits after the decimal point (0..__precision__)

|size
|The maximum size of a string type parameter or variable, in characters

|charset
|Character set of a string type parameter or variable

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size (max. 65535)
|===

The `CREATE PROCEDURE` statement creates a new stored procedure.
The name of the procedure must be unique among the names of all stored procedures, tables and views in the database.

`CREATE PROCEDURE` is a _compound statement_, consisting of a header and a body.
The header specifies the name of the procedure and declares input parameters and the output parameters, if any, that are to be returned by the procedure.

The procedure body consists of declarations for any local variables and named cursors that will be used by the procedure, followed by one or more statements, or blocks of statements, all enclosed in an outer block that begins with the keyword `BEGIN` and ends with the keyword `END`.
Declarations and embedded statements are terminated with semi-colons ('```;```').

[[fblangref25-ddl-terminators02]]
==== Statement Terminators

Some SQL statement editors -- specifically the _isql_ utility that comes  with Firebird and possibly some third-party editors -- employ an internal convention that requires all statements to be terminated with a semi-colon.
This creates a conflict with PSQL syntax when coding in these environments.
If you are unacquainted with this problem and its solution, please study the details in the PSQL chapter in the section entitled <<fblangref25-sidebar01,Switching the Terminator in _isql_>>.

[[fblangref25-ddl-proc-params]]
==== Parameters

Each parameter has a data type specified for it.
The `NOT NULL` constraint can also be specified for any parameter, to prevent `NULL` being passed or assigned to it.

A collation sequence can be specified for string-type parameters, using the `COLLATE` clause.

Input Parameters::
Input parameters are presented as a parenthesized list following the name of the procedure.
They are passed into the procedure as values, so anything that changes them inside the procedure has no effect on the parameters in the calling program.
Input parameters may have default values.
Those that do have values specified for them must be located at the end of the list of parameters.

Output Parameters::
The optional `RETURNS` clause is for specifying a parenthesised list of output parameters for the stored procedure.

[[fblangref25-ddl-proc-paramsdomns]]
===== Use of Domains in Declarations

A domain name can be specified as the type of a parameter.
The parameter will inherit all domain attributes.
If a default value is specified for the parameter, it overrides the default value specified in the domain definition.

If the `TYPE OF` clause is added before the domain name, only the data type of the domain is used: any of the other attributes of the domain -- `NOT NULL` constraint, `CHECK` constraints, default value -- are neither checked nor used.
However, if the domain is of a text type, its character set and collation sequence are always used.

[[fblangref25-ddl-proc-paramscoltype]]
===== Use of Column Type in Declarations

Input and output parameters can also be declared using the data type of columns in existing tables and views.
The `TYPE OF COLUMN` clause is used for that, specifying [replaceable]`relationname.columnname` as its argument.

When `TYPE OF COLUMN` is used, the parameter inherits only the data type and -- for string types -- the character set and collation sequence.
The constraints and default value of the column are ignored.

.Bug warning for pre-Firebird 3 versions:
[WARNING]
====
For input parameters, the collation that comes with the column's type is ignored in comparisons (e.g.
equality tests).
For local variables, the behaviour varies.

The bug was fixed for Firebird 3.
====

[[fblangref25-ddl-proc-declarations]]
==== Variable and Cursor Declarations

The optional declarations section, located last in the header section of the procedure definition, defines variables local to the procedure and its named cursors.
Local variable declarations follow the same rules as parameters regarding specification of the data type.
See details in the <<fblangref25-psql,PSQL chapter>> for <<fblangref25-psql-declare-variable,`DECLARE VARIABLE`>> and <<fblangref25-psql-declare-cursor,`DECLARE CURSOR`>>.

[[fblangref25-ddl-proc-procbody]]
==== Procedure Body

The header section is followed by the procedure body, consisting of one or more PSQL statements enclosed between the outer keywords `BEGIN` and `END`.
Multiple `BEGIN ... END` blocks of terminated statements may be embedded inside the procedure body.

Any user connected to the database can create a new stored procedure.
The user who creates a stored procedure becomes its owner.

[[create-procedure-examples]]
==== Examples

Creating a stored procedure that inserts a record into the `BREED` table and returns the code of the inserted record:

[source]
----
CREATE PROCEDURE ADD_BREED (
  NAME D_BREEDNAME, /* Domain attributes are inherited */
  NAME_EN TYPE OF D_BREEDNAME, /* Only the domain type is inherited */
  SHORTNAME TYPE OF COLUMN BREED.SHORTNAME,
    /* The table column type is inherited */
  REMARK VARCHAR(120) CHARACTER SET WIN1251 COLLATE PXW_CYRL,
  CODE_ANIMAL INT NOT NULL DEFAULT 1
)
RETURNS (
  CODE_BREED INT
)
AS
BEGIN
  INSERT INTO BREED (
    CODE_ANIMAL, NAME, NAME_EN, SHORTNAME, REMARK)
  VALUES (
    :CODE_ANIMAL, :NAME, :NAME_EN, :SHORTNAME, :REMARK)
  RETURNING CODE_BREED INTO CODE_BREED;
END
----

Creating a selectable stored procedure that generates data for mailing labels (from `employee.fdb`):

[source]
----
CREATE PROCEDURE mail_label (cust_no INTEGER)
RETURNS (line1 CHAR(40), line2 CHAR(40), line3 CHAR(40),
         line4 CHAR(40), line5 CHAR(40), line6 CHAR(40))
AS
  DECLARE VARIABLE customer VARCHAR(25);
  DECLARE VARIABLE first_name VARCHAR(15);
  DECLARE VARIABLE last_name VARCHAR(20);
  DECLARE VARIABLE addr1 VARCHAR(30);
  DECLARE VARIABLE addr2 VARCHAR(30);
  DECLARE VARIABLE city VARCHAR(25);
  DECLARE VARIABLE state VARCHAR(15);
  DECLARE VARIABLE country VARCHAR(15);
  DECLARE VARIABLE postcode VARCHAR(12);
  DECLARE VARIABLE cnt INTEGER;
BEGIN
  line1 = '';
  line2 = '';
  line3 = '';
  line4 = '';
  line5 = '';
  line6 = '';

  SELECT customer, contact_first, contact_last, address_line1,
    address_line2, city, state_province, country, postal_code
  FROM CUSTOMER
  WHERE cust_no = :cust_no
  INTO :customer, :first_name, :last_name, :addr1, :addr2,
    :city, :state, :country, :postcode;

  IF (customer IS NOT NULL) THEN
    line1 = customer;
  IF (first_name IS NOT NULL) THEN
    line2 = first_name || ' ' || last_name;
  ELSE
    line2 = last_name;
  IF (addr1 IS NOT NULL) THEN
    line3 = addr1;
  IF (addr2 IS NOT NULL) THEN
    line4 = addr2;

  IF (country = 'USA') THEN
  BEGIN
    IF (city IS NOT NULL) THEN
  	  line5 = city || ', ' || state || '  ' || postcode;
  	ELSE
      line5 = state || '  ' || postcode;
  END
  ELSE
  BEGIN
    IF (city IS NOT NULL) THEN
  	  line5 = city || ', ' || state;
  	ELSE
      line5 = state;
    line6 = country || '    ' || postcode;
  END

  SUSPEND; -- the statement that sends an output row to the buffer
           -- and makes the procedure "selectable"
END
----

.See also
<<fblangref25-ddl-proc-crtoralter,`CREATE OR ALTER PROCEDURE`>>, <<fblangref25-ddl-proc-alter,`ALTER PROCEDURE`>>, <<fblangref25-ddl-proc-recreate,`RECREATE PROCEDURE`>>, <<fblangref25-ddl-proc-drop,`DROP PROCEDURE`>>

[[fblangref25-ddl-proc-alter]]
=== `ALTER PROCEDURE`

.Used for
Modifying an existing stored procedure

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END

<inparam> ::= <param_decl> [{= | DEFAULT} <value>]

<outparam> ::= <param_decl>

<param_decl> ::= _paramname_ <type> [NOT NULL]
  [COLLATE _collation_]

<type> ::=
    <datatype>
  | [TYPE OF] _domain_
  | TYPE OF COLUMN __rel__.__col__

<datatype> ::=
    {SMALLINT | INT[EGER] | BIGINT}
  | {FLOAT | DOUBLE PRECISSION}
  | {DATE | TIME | TIMESTAMP}
  | {DECIMAL | NUMERIC} [(_precision_ [, _scale_])]
  | {CHAR | CHARACTER} [VARYING] | VARCHAR} [(_size_)]
    [CHARACTER SET _charset_]
  | {NCHAR | NATIONAL {CHARACTER | CHAR} [VARYING]
    [(_size_)]
  | BLOB [SUB_TYPE {_subtype_num_ | _subtype_name_}]
    [SEGMENT SIZE _seglen_] [CHARACTER SET _charset_]
  | BLOB [(_seglen_ [, _subtype_num_])]

<declarations> ::= {<declare_var> | <declare_cursor>};
  [{<declare_var> | <declare_cursor>}; ]
----

[[fblangref25-ddl-proc-alterproc]]
.`ALTER PROCEDURE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|procname
|Name of an existing stored procedure

|inparam
|Input parameter description

|outparam
|Output parameter description

|declarations
|Section for declaring local variables and named cursors

|declare_var
|Local variable declaration

|declare_cursor
|Named cursor declaration

|PSQL_statements
|Procedural SQL statements

|literal
|A literal value that is assignment-compatible with the data type of the parameter

|context_var
|Any context variable whose type is compatible with the data type of the parameter

|paramname
|The name of an input or output parameter of the procedure.
It may consist of up to 31 characters.
The name of the parameter must be unique among input and output parameters of the procedure and its local variables

|datatype
|SQL data type

|collation
|Collation sequence

|domain
|Domain name

|rel
|Table or view name

|col
|Table or view column name

|precision
|The total number of significant digits that the parameter should be able to hold (1..18)

|scale
|The number of digits after the decimal point (0..__precision__)

|size
|The maximum size of a string type parameter or variable, in characters

|charset
|Character set of a string type parameter or variable

|subtype_num
|`BLOB` subtype number

|subtype_name
|`BLOB` subtype mnemonic name

|seglen
|Segment size (max. 65535)
|===

The `ALTER PROCEDURE` statement allows the following changes to a stored procedure definition: 

* the set and characteristics of input and output parameters
* local variables
* code in the body of the stored procedure

After `ALTER PROCEDURE` executes, existing privileges remain intact and dependencies are not affected.

[CAUTION]
====
Take care about changing the number and type of input and output parameters in stored procedures.
Existing application code and procedures and triggers that call it could become invalid because the new  description of the parameters is incompatible with the old calling format.
For information on how to troubleshoot such a situation, see the article <<fblangref25-appx01-supp-rdb-validblr,The `RDB$VALID_BLR` Field>> in the Appendix.
====

The procedure owner and <<fblangref25-security-administrators,Administrators>> have the authority to use `ALTER PROCEDURE`.

.ALTER PROCEDURE Example
Altering the `GET_EMP_PROJ` stored procedure.

[source]
----
ALTER PROCEDURE GET_EMP_PROJ (
  EMP_NO SMALLINT)
RETURNS (
  PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
      PROJ_ID
    FROM
      EMPLOYEE_PROJECT
    WHERE
      EMP_NO = :emp_no
    INTO :proj_id
  DO
    SUSPEND;
END
----

.See also
<<fblangref25-ddl-proc-create,`CREATE PROCEDURE`>>, <<fblangref25-ddl-proc-crtoralter,`CREATE OR ALTER PROCEDURE`>>, <<fblangref25-ddl-proc-recreate,`RECREATE PROCEDURE`>>, <<fblangref25-ddl-proc-drop,`DROP PROCEDURE`>>

[[fblangref25-ddl-proc-crtoralter]]
=== `CREATE OR ALTER PROCEDURE`

.Used for
Creating a new stored procedure or altering an existing one

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

For the full syntax detail, see <<fblangref25-ddl-proc-create,`CREATE DATABASE`>>.

The `CREATE OR ALTER PROCEDURE` statement creates a new stored procedure or alters an existing one.
If the stored procedure does not exist, it will be created by invoking a `CREATE PROCEDURE` statement transparently.
If the procedure already exists, it will be altered and compiled without affecting its existing privileges and dependencies.

.Example
Creating or altering the `GET_EMP_PROJ` procedure.

[source]
----
CREATE OR ALTER PROCEDURE GET_EMP_PROJ (
    EMP_NO SMALLINT)
RETURNS (
    PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
      PROJ_ID
    FROM
      EMPLOYEE_PROJECT
    WHERE
      EMP_NO = :emp_no
    INTO :proj_id
  DO
    SUSPEND;
END
----

.See also
<<fblangref25-ddl-proc-create,`CREATE PROCEDURE`>>, <<fblangref25-ddl-proc-alter,`ALTER PROCEDURE`>>, <<fblangref25-ddl-proc-recreate,`RECREATE PROCEDURE`>>

[[fblangref25-ddl-proc-drop]]
=== `DROP PROCEDURE`

.Used for
Deleting a stored procedure

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP PROCEDURE _procname_
----

[[fblangref25-ddl-tbl-procdrop]]
.`DROP PROCEDURE` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|procname
|Name of an existing stored procedure
|===

The `DROP PROCEDURE` statement deletes an existing stored procedure.
If the stored procedure has any dependencies, the attempt to delete it will fail and the appropriate error will be raised.

The procedure owner and <<fblangref25-security-administrators,Administrators>> have the authority to use `DROP PROCEDURE`.

.Example
Deleting the `GET_EMP_PROJ` stored procedure.

[source]
----
DROP PROCEDURE GET_EMP_PROJ;
----

.See also
<<fblangref25-ddl-proc-create,`CREATE PROCEDURE`>>, <<fblangref25-ddl-proc-recreate,`RECREATE PROCEDURE`>>

[[fblangref25-ddl-proc-recreate]]
=== `RECREATE PROCEDURE`

.Used for
Creating a new stored procedure or recreating an existing one

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE PROCEDURE _procname_
  [(<inparam> [, <inparam> ...])]
  [RETURNS (<outparam> [, <outparam> ...])]
AS
  [<declarations>]
BEGIN
  [<PSQL_statements>]
END
----

For the full syntax detail, see <<fblangref25-ddl-proc-create,`CREATE PROCEDURE`>>.

The `RECREATE PROCEDURE` statement creates a new stored procedure  or recreates an existing one.
If there is a procedure with this name already, the engine will try to delete it and create a new one.
Recreating an existing procedure will fail at the `COMMIT` request if the procedure has dependencies.

[WARNING]
====
Be aware that dependency errors are not detected until the `COMMIT` phase of this operation.
====

After a procedure is successfully recreated, privileges to execute the stored procedure and the privileges of the stored procedure itself are dropped.

.Example
Creating the new `GET_EMP_PROJ` stored procedure or recreating the existing `GET_EMP_PROJ` stored procedure.

[source]
----
RECREATE PROCEDURE GET_EMP_PROJ (
  EMP_NO SMALLINT)
RETURNS (
  PROJ_ID VARCHAR(20))
AS
BEGIN
  FOR SELECT
      PROJ_ID
    FROM
      EMPLOYEE_PROJECT
    WHERE
      EMP_NO = :emp_no
    INTO :proj_id
  DO
    SUSPEND;
END
----

.See also
<<fblangref25-ddl-proc-create,`CREATE PROCEDURE`>>, <<fblangref25-ddl-proc-drop,`DROP PROCEDURE`>>, <<fblangref25-ddl-proc-crtoralter,`CREATE OR ALTER PROCEDURE`>>

[[fblangref25-ddl-extfunc]]
== `EXTERNAL FUNCTION`

.REVIEW STATUS
[IMPORTANT]
====
All sections from this point forward to the end of the chapter are awaiting technical and editorial review.
====

External functions, also known as "`user-defined functions`" (UDFs) are programs written in an external programming language and stored in dynamically loaded libraries.
Once declared to a database, they become available in dynamic and procedural statements as though they were implemented in the SQL language internally.

External functions extend the possibilities for processing data with SQL considerably.
To make a function available to a database, it is declared using the statement `DECLARE EXTERNAL FUNCTON`.

The library containing a function is loaded when any function included in it is called.

[NOTE]
====
External functions may be contained in more than one library -- or "`module`", as it is referred to in the syntax.
====

[[fblangref25-ddl-extfunc-declare]]
=== `DECLARE EXTERNAL FUNCTION`

.Used for
Declaring a user-defined function (UDF) to the database

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DECLARE EXTERNAL FUNCTION _funcname_
  [<arg_type_decl> [, <arg_type_decl> ...]]
  RETURNS {
    <sqltype> [BY {DESCRIPTOR | VALUE}] |
    CSTRING(_length_) |
    PARAMETER _param_num_ }
  [FREE_IT]
  ENTRY_POINT '_entry_point_' MODULE_NAME '_library_name_'

<arg_type_decl> ::=
    <sqltype> [{BY DESCRIPTOR} | NULL]
  | CSTRING(_length_) [NULL]
----

[[fblangref25-ddl-tbl-declarefunc]]
.`DECLARE EXTERNAL FUNCTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|funcname
|Function name in the database.
It may consist of up to 31 characters.
It should be unique among all internal and external function names in the database and need not be the same name as the name exported from the UDF library via `ENTRY_POINT`.

|entry_point
|The exported name of the function

|library_name
|The name of the module (`MODULE_NAME` from which the function is exported).
This will be the name of the file, without the "`.dll`" or "`.so`" file extension.

|sqltype
|SQL data type.
It cannot be an array or an array element

|length
|The maximum length of a null-terminated string, specified in bytes

|param_num
|The number of the input parameter, numbered from 1 in the list of input parameters in the declaration, describing the data type that will be returned by the function
|===

The `DECLARE EXTERNAL FUNCTION` statement makes a user-defined function available in the database.
UDF declarations must be made in _each database_ that is going to use them.
There is no need to declare UDFs that will never be used.

The name of the external function must be unique among all function names.
It may be different from the exported name of the function, as specified in the `ENTRY_POINT` argument.

[[fblangref25-ddl-extfunc-inp]]
==== `DECLARE EXTERNAL FUNCTION` Input Parameters

The input parameters of the function follow the name of the function and are separated with commas.
Each parameter has an SQL data type specified for it.
Arrays cannot be used as function parameters.
As well as the SQL types, the `CSTRING` type is available for specifying a null-terminated string with a maximum length of `LENGTH` bytes.

By default, input parameters are passed _by reference_.
The `BY DESCRIPTOR` clause may be specified instead, if the input parameter is passed by descriptor.
Passing a parameter by descriptor makes it possible to process `NULLs`.

[[fblangref25-ddl-extfunc-keywords]]
===== Clauses and Keywords

`RETURNS` clause::
(Required) specifies the output parameter returned by the function.
A function is scalar: it returns one and only one parameter.
The output parameter can be of any SQL type (except an array or an array element) or a null-terminated string (`CSTRING`).
The output parameter can be passed by reference (the default), by descriptor or by value.
If the `BY DESCRIPTOR` clause is specified, the output parameter is passed by descriptor.
If the `BY VALUE` clause is specified, the output parameter is passed by value.

`PARAMETER` keyword::
specifies that the function returns the value from the parameter under number _param_num_.
It is necessary if you need to return a value of data type `BLOB`.

`FREE_IT` keyword::
means that the memory allocated for storing the return value will be freed after the function is executed.
It is used only if the memory was allocated dynamically in the UDF.
In such a UDF, the memory must be allocated with the help of the `ib_util_malloc` function from the [path]`ib_util` module, a requirement for compatibility with the functions used in Firebird code and in the code of the shipped UDF modules, for allocating and freeing memory.

`ENTRY_POINT` clause::
specifies the name of the entry point (the name of the imported function), as exported from the module.

`MODULE_NAME` clause::
defines the name of the module where the exported function is located.
The link to the module should not be the full path and extension of the file, if that can be avoided.
If the module is located in the default location (in the `../UDF` subdirectory of the Firebird server root) or in a location explicitly configured in [path]`firebird.conf`, it makes it easier to move the database between different platforms.
The `UDFAccess` parameter in the firebird.conf file allows access restrictions to external functions modules to be configured.

Any user connected to the database can declare an external function (UDF).

==== Examples using DECLARE EXTERNAL FUNCTION

. Declaring the `addDate` external function located in the `fbudf` module.
The input and output parameters are passed by reference.
+
[source]
----
DECLARE EXTERNAL FUNCTION addDay
  TIMESTAMP, INT
  RETURNS TIMESTAMP
  ENTRY_POINT 'addDay' MODULE_NAME 'fbudf';
----
. Declaring the `invl` external function located in the `fbudf` module.
The input and output parameters are passed by descriptor.
+
[source]
----
DECLARE EXTERNAL FUNCTION invl
  INT BY DESCRIPTOR, INT BY DESCRIPTOR
  RETURNS INT BY DESCRIPTOR
  ENTRY_POINT 'idNvl' MODULE_NAME 'fbudf';
----
. Declaring the `isLeapYear` external function located in the `fbudf` module.
The input parameter is passed by reference, while the output parameter is passed by value.
+
[source]
----
DECLARE EXTERNAL FUNCTION isLeapYear
  TIMESTAMP
  RETURNS INT BY VALUE
  ENTRY_POINT 'isLeapYear' MODULE_NAME 'fbudf';
----
. Declaring the `i64Truncate` external function located in the `fbudf` module.
The input and output parameters are passed by descriptor.
The second parameter of the function is used as the return value.
+
[source]
----
DECLARE EXTERNAL FUNCTION i64Truncate
  NUMERIC(18) BY DESCRIPTOR, NUMERIC(18) BY DESCRIPTOR
  RETURNS PARAMETER 2
  ENTRY_POINT 'fbtruncate' MODULE_NAME 'fbudf';
----

.See also
<<fblangref25-ddl-extfunc-alter,`ALTER EXTERNAL FUNCTION`>>, <<fblangref25-ddl-extfunc-drop,`DROP EXTERNAL FUNCTION`>>

[[fblangref25-ddl-extfunc-alter]]
=== `ALTER EXTERNAL FUNCTION`

.Used for
Changing the entry point and/or the module name for a user-defined function (UDF)

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER EXTERNAL FUNCTION _funcname_
  [ENTRY_POINT '_new_entry_point_']
  [MODULE_NAME '_new_library_name_']
----

[[fblangref25-ddl-tbl-alterfunc]]
.`ALTER EXTERNAL FUNCTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|funcname
|Function name in the database

|new_entry_point
|The new exported name of the function

|new_library_name
|The new name of the module (`MODULE_NAME` from which the function is exported).
This will be the name of the file, without the "`.dll`" or "`.so`" file extension.
|===

The `ALTER EXTERNAL FUNCTION` statement changes the entry point and/or the module name for a user-defined function (UDF).
Existing dependencies remain intact after the statement containing the change[s] is executed.

The `ENTRY_POINT` clause::
is for specifying the new entry point (the name of the function as exported from the module).

The `MODULE_NAME` clause::
is for specifying the new name of the module where the exported function is located.

Any user connected to the database can change the entry point and the module name.

.Examples using ALTER EXTERNAL FUNCTION
. Changing the entry point for an external function
+
[source]
----
ALTER EXTERNAL FUNCTION invl ENTRY_POINT 'intNvl';
----
. Changing the module name for an external function
+
[source]
----
ALTER EXTERNAL FUNCTION invl MODULE_NAME 'fbudf2';
----

.See also
<<fblangref25-ddl-extfunc-declare,`DECLARE EXTERNAL FUNCTION`>>, <<fblangref25-ddl-extfunc-drop,`DROP EXTERNAL FUNCTION`>>

[[fblangref25-ddl-extfunc-drop]]
=== `DROP EXTERNAL FUNCTION`

.Used for
Removing a user-defined function (UDF) from a database

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP EXTERNAL FUNCTION _funcname_
----

[[fblangref25-ddl-tbl-dropfunc]]
.`DROP EXTERNAL FUNCTION` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|funcname
|Function name in the database
|===

The `DROP EXTERNAL FUNCTION` statement deletes the declaration of a user-defined function from the database.
If there are any dependencies on the external function, the statement will fail and the appropriate error will be raised.

Any user connected to the database can delete the declaration of an internal function.

.Example using `DROP EXTERNAL FUNCTION`
Deleting the declaration of the addDay function.

[source]
----
DROP EXTERNAL FUNCTION addDay;
----

.See also
<<fblangref25-ddl-extfunc-declare,`DECLARE EXTERNAL FUNCTION`>>

[[fblangref25-ddl-filter]]
== `FILTER`

A `BLOB FILTER` filter is a database object that is actually a special type of external function, with the sole purpose of taking a `BLOB` object in one format and converting it to a `BLOB` object in another format.
The formats of the `BLOB` objects are specifed with user-defined `BLOB` subtypes.

External functions for converting `BLOB` types are stored in dynamic libraries and loaded when necessary.

For more details on `BLOB` subtypes, see <<fblangref25-datatypes-bnrytypes,Binary Data Types>>.

[[fblangref25-ddl-filter-declare]]
=== `DECLARE FILTER`

.Used for
Declaring a `BLOB` filter to the database

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DECLARE FILTER _filtername_
  INPUT_TYPE <sub_type> OUTPUT_TYPE <sub_type>
  ENTRY_POINT '_function_name_' MODULE_NAME '_library_name_'

<sub_type> ::= _number_ | <mnemonic>

<mnemonic> ::=
    BINARY | TEXT | BLR | ACL | RANGES
  | SUMMARY | FORMAT | TRANSACTION_DESCRIPTION
  | EXTERNAL_FILE_DESCRIPTION | _user_defined_
----

[[fblangref25-ddl-tbl-declarefiltr]]
.`DECLARE FILTER` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|filtername
|Filter name in the database.
It may consist of up to 31 characters.
It need not be the same name as the name exported from the filter library via `ENTRY_POINT`.

|sub_type
|`BLOB` subtype

|number
|`BLOB` subtype number (must be negative)

|mnemonic
|`BLOB` subtype mnemonic name

|function_name
|The exported name (entry point) of the function

|library_name
|The name of the module where the filter is located

|user_defined
|User-defined `BLOB` subtype mnemonic name
|===

The `DECLARE FILTER` statement makes a `BLOB` filter available to the database.
The name of the `BLOB` filter must be unique among the names of `BLOB` filters.

[[fblangref25-ddl-filter-subtype]]
==== Specifying the Subtypes

The subtypes can be specified as the subtype number or as the subtype mnemonic name.
Custom subtypes must be represented by negative numbers (from -1 to -32,768).
An attempt to declare more than one `BLOB` filter with the same combination of the input and output types will fail with an error.

`INPUT_TYPE`::
clause defining the `BLOB` subtype of the object to be converted

`OUTPUT_TYPE`::
clause defining the `BLOB` subtype of the object to be created.

[NOTE]
====
Mnemonic names can be defined for custom `BLOB` subtypes and inserted manually into the system table `RDB$TYPES` system table: 
[source]
----
INSERT INTO RDB$TYPES (RDB$FIELD_NAME, RDB$TYPE, RDB$TYPE_NAME)
VALUES ('RDB$FIELD_SUB_TYPE', -33, 'MIDI');
----

After the transaction is confirmed, the mnemonic names can be used in declarations when you create new filters.

The value of the column `RDB$FIELD_NAME` must always be 'RDB$FIELD_SUB_TYPE'.
If mnemonic names in upper case, they can be used case-insensitively and without quotation marks when a filter is declared.

.Warning
From Firebird 3 onward, the system tables will no longer be writable by users.
However, inserting custom types into `RDB$TYPES` is still possible.
====

[[fblangref25-ddl-filter-params]]
==== Parameters

`ENTRY_POINT`::
clause defining the name of the entry point (the name of the imported function) in the module.

`MODULE_NAME`::
The clause defining the name of the module where the exported function is located.
By default, modules must be located in the UDF folder of the root directory on the server.
The `UDFAccess` parameter in [path]`firebird.conf` allows editing of access restrictions to filter libraries.

Any user connected to the database can declare a BLOB filter.

==== Examples of FILTER

. Creating a BLOB filter using subtype numbers.
+
[source]
----
DECLARE FILTER DESC_FILTER
  INPUT_TYPE 1
  OUTPUT_TYPE -4
  ENTRY_POINT 'desc_filter'
  MODULE_NAME 'FILTERLIB';
----
. Creating a BLOB filter using subtype mnemonic names.
+
[source]
----
DECLARE FILTER FUNNEL
  INPUT_TYPE blr OUTPUT_TYPE text
  ENTRY_POINT 'blr2asc' MODULE_NAME 'myfilterlib';
----

.See also
<<fblangref25-ddl-extfunc-drop,`DROP FILTER`>>

[[fblangref25-ddl-filter-drop]]
=== `DROP FILTER`

.Used for
Removing a `BLOB` filter declaration from the database

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP FILTER _filtername_
----

[[fblangref25-ddl-tbl-dropfiltr]]
.`DROP FILTER` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|filtername
|Filter name in the database
|===

The `DROP FILTER` statement removes the declaration of a `BLOB` filter from the database.
Removing a `BLOB` filter from a database makes it unavailable for use from that database.
The dynamic library where the conversion function is located remains intact and the removal from one database does not affect other databases in which the same `BLOB` filter is still declared.

Any user connected to the database can drop a BLOB filter.

.Example
Deleting a BLOB filter.

[source]
----
DROP FILTER DESC_FILTER;
----

.See also
<<fblangref25-ddl-extfunc-declare,`DECLARE FILTER`>>

[[fblangref25-ddl-sequence]]
== `SEQUENCE` (`GENERATOR`)

A sequence or a generator is a database object used to get unique number values to fill a series.
"`Sequence`" is the SQL-compliant term for the same thing which, in Firebird, has traditionally been known as "`generator`".
Both terms are implemented in Firebird, which recognises and has syntax for both terms.

Sequences (or generators) are always stored as 64-bit integers, regardless of the SQL dialect of the database. 

[CAUTION]
====
If a client is connected using Dialect 1, the server sends sequence values to it as 32-bit integers.
Passing a sequence value to a 32-bit field or variable will not cause errors as long as the current value of the sequence does not exceed the limits of a 32-bit number.
However, as soon as the sequence value exceeds this limit, a database in Dialect 3 will produce an error.
A database in Dialect 1 will keep cutting the values, which will compromise the uniqueness of the series.
====

This section describes how to create, set and delete sequences.

[[fblangref25-ddl-sequence-create]]
=== `CREATE SEQUENCE`

.Used for
Creating a new `SEQUENCE` (`GENERATOR`)

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE {SEQUENCE | GENERATOR} _seq_name_
----

[[fblangref25-ddl-tbl-crtseq]]
.`CREATE SEQUENCE` | `CREATE GENERATOR` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|seq_name
|Sequence (generator) name.
It may consist of up to 31 characters
|===

The statements `CREATE SEQUENCE` and `CREATE GENERATOR` are synonymous -- both create a new sequence.
Either can be used but `CREATE SEQUENCE` is recommended if standards-compliant metadata management is important.

When a sequence is created, its value is set to 0.
Each time the `<<fblangref25-commons-conditional-nxtvlufor,NEXT VALUE FOR seq_name>>` operator is used with that sequence, its value increases by 1.
The `GEN_ID(seq_name, <step>)` function can be called instead, to "`step`" the series by a different integer number.

Any user connected to the database can create a sequence (generator).

.Examples
. Creating the `EMP_NO_GEN` series using `CREATE SEQUENCE`.
+
[source]
----
CREATE SEQUENCE EMP_NO_GEN;
----
. Creating the `EMP_NO_GEN` series using `CREATE GENERATOR`.
+
[source]
----
CREATE GENERATOR EMP_NO_GEN;
----

.See also
<<fblangref25-ddl-sequence-alter,`ALTER SEQUENCE`>>, <<fblangref25-ddl-sequence-setgen,`SET GENERATOR`>>, <<fblangref25-ddl-sequence-drop,`DROP SEQUENCE (GENERATOR)`>>, <<fblangref25-commons-conditional-nxtvlufor,`NEXT VALUE FOR`>>, <<fblangref25-functions-scalarfuncs-gen-id,`GEN_ID() function`>>

[[fblangref25-ddl-sequence-alter]]
=== `ALTER SEQUENCE`

.Used for
Setting the value of a sequence or generator to a specified value

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER SEQUENCE _seq_name_ RESTART WITH _new_val_
----

[[fblangref25-ddl-tbl-alterseq]]
.`ALTER SEQUENCE` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|seq_name
|Sequence (generator) name

|new_val
|New sequence (generator) value.
A 64-bit integer from -2^-63^ to 2^63^-1.
|===

The `ALTER SEQUENCE` statement sets the current value of a sequence or generator to the specified value. 

[WARNING]
====
Incorrect use of the `ALTER SEQUENCE` statement (changing the current value of the sequence or generator) is likely to break the logical integrity of data.
====

Any user connected to the database can set the sequence (generator) value.

.Examples
. Setting the value of the `EMP_NO_GEN` sequence to 145.
+
[source]
----
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
----
. Doing the same thing, using `SET GENERATOR`:
+
[source]
----
SET GENERATOR EMP_NO_GEN TO 145;
----

.See also
<<fblangref25-ddl-sequence-setgen,`SET GENERATOR`>>, <<fblangref25-ddl-sequence-create,`CREATE SEQUENCE (GENERATOR)`>>, <<fblangref25-ddl-sequence-drop,`DROP SEQUENCE (GENERATOR)`>>, <<fblangref25-commons-conditional-nxtvlufor,`NEXT VALUE FOR`>>, <<fblangref25-functions-scalarfuncs-gen-id,`GEN_ID() function`>>

[[fblangref25-ddl-sequence-setgen]]
=== `SET GENERATOR`

.Used for
Setting the value of a sequence or generator to a specified value

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
SET GENERATOR _seq_name_ TO _new_val_
----

[[fblangref25-ddl-tbl-setgen]]
.`SET GENERATOR` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|seq_name
|Generator (sequence) name

|new_val
|New sequence (generator) value.
A 64-bit integer from -2^-63^ to 2^63^-1.
|===

The `SET GENERATOR` statement sets the current value of a sequence or generator to the specified value.

[NOTE]
====
Although `SET GENERATOR` is considered outdated, it is retained for backward compatibility.
Using the standards-compliant `ALTER SEQUENCE` is current and is recommended.
====

Any user connected to the database can set the sequence (generator) value.

.Examples
. Setting the value of the `EMP_NO_GEN` sequence to 145:
+
[source]
----
SET GENERATOR EMP_NO_GEN TO 145;
----
. Doing the same thing, using `ALTER SEQUENCE`:
+
[source]
----
ALTER SEQUENCE EMP_NO_GEN RESTART WITH 145;
----

.See also
<<fblangref25-ddl-sequence-alter,`ALTER SEQUENCE`>>, <<fblangref25-ddl-sequence-create,`CREATE SEQUENCE (GENERATOR)`>>

[[fblangref25-ddl-sequence-drop]]
=== `DROP SEQUENCE`

.Used for
Deleting `SEQUENCE` (`GENERATOR`)

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP {SEQUENCE | GENERATOR} _seq_name_
----

[[fblangref25-ddl-tbl-dropseq]]
.`DROP SEQUENCE` | `DROP GENERATOR` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|seq_name
|Sequence (generator) name.
It may consist of up to 31 characters
|===

The statements `DROP SEQUENCE` and `DROP GENERATOR` statements are equivalent: both delete an existing sequence (generator).
Either is valid but `DROP SEQUENCE`, being current, is recommended.

The statements will fail if the sequence (generator) has dependencies.

Any user connected to the database can drop a sequence (generator).

.Example
Dropping the `EMP_NO_GEN` series:

[source]
----
DROP SEQUENCE EMP_NO_GEN;
----

.See also
<<fblangref25-ddl-sequence-create,`CREATE SEQUENCE (GENERATOR`>>, <<fblangref25-ddl-sequence-alter,`ALTER SEQUENCE`>>, <<fblangref25-ddl-sequence-setgen,`SET GENERATOR`>>

[[fblangref25-ddl-exception]]
== `EXCEPTION`

This section describes how to create, modify and delete [term]_custom exceptions_ for use in error handlers in PSQL modules.

[[fblangref25-ddl-exception-create]]
=== `CREATE EXCEPTION`

.Used for
Creating a new exception for use in PSQL modules

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-crtexcep]]
.`CREATE EXCEPTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exception_name
|Exception name.
The maximum length is 31 characters

|message
|Default error message.
The maximum length is 1,021 characters
|===

The statement `CREATE EXCEPTION` creates a new exception for use in PSQL modules.
If an exception of the same name exists, the statement will fail with an appropriate error message.

The exception name is a standard identifier.
In a Dialect 3 database, it can be enclosed in double quotes to make it case-sensitive and, if required, to use characters that are not valid in regular identifiers.
See <<fblangref25-structure-identifiers,Identifiers>> for more information.

The default message is stored in character set `NONE`, i.e., in characters of any single-byte character set.
The text can be overridden in the PSQL code when the exception is thrown.

Any user connected to the database can create an exception.

.Examples
. Creating an exception named `E_LARGE_VALUE`:
+
[source]
----
CREATE EXCEPTION E_LARGE_VALUE
  'The value is out of range';
----
. Creating an exception named `ERROR_REFIN_RATE`:
+
[source]
----
CREATE EXCEPTION ERROR_REFIN_RATE
  'Error detected in the spread of discount rates';
----

.Tips
[TIP]
====
Grouping `CREATE EXCEPTION` statements together in system update scripts will simplify working with them and documenting them.
A system of prefixes for naming and categorising groups of exceptions is recommended.

Custom exceptions are stored in the system table <<fblangref-appx04-exceptions,`RDB$EXCEPTIONS`>>. 
====

.See also
<<fblangref25-ddl-exception-alter,`ALTER EXCEPTION`>>, <<fblangref25-ddl-exception-crtalter,`CREATE OR ALTER EXCEPTION`>>, <<fblangref25-ddl-exception-drop,`DROP EXCEPTION`>>, <<fblangref25-ddl-exception-recreate,`RECREATE EXCEPTION`>>

[[fblangref25-ddl-exception-alter]]
=== `ALTER EXCEPTION`

.Used for
Modifying the message returned from a custom exception

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
ALTER EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-altrexcep]]
.`ALTER EXCEPTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exception_name
|Exception name

|message
|New default error message.
The maximum length is 1,021 characters
|===

The statement `ALTER EXCEPTION` can be used at any time, to modify the default text of the message.
Any user connected to the database can alter an exception message.

.Examples
. Changing the default message for the exception `E_LARGE_VALUE`:
+
[source]
----
ALTER EXCEPTION E_LARGE_VALUE
  'The value exceeds the prescribed limit of 32,765 bytes';
----
. Changing the default message for the exception `ERROR_REFIN_RATE`:
+
[source]
----
ALTER EXCEPTION ERROR_REFIN_RATE
  'Rate is outside the allowed range';
----

.See also
<<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>, <<fblangref25-ddl-exception-crtalter,`CREATE OR ALTER EXCEPTION`>>, <<fblangref25-ddl-exception-drop,`DROP EXCEPTION`>>, <<fblangref25-ddl-exception-recreate,`RECREATE EXCEPTION`>>

[[fblangref25-ddl-exception-crtalter]]
=== `CREATE OR ALTER EXCEPTION`

.Used for
Modifying the message returned from a custom exception, if the exception exists;
otherwise, creating a new exception

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE OR ALTER EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-crtaltrexcep]]
.`CREATE OR ALTER EXCEPTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exception_name
|Exception name

|message
|Error message.
The maximum length is limited to 1,021 characters
|===

The statement `CREATE OR ALTER EXCEPTION` is used to create the specified exception if it does not exist, or to modify the text of the error message returned from it if it exists already.
If an existing exception is altered by this statement, any existing dependencies will remain intact.

Any user connected to the database can use this statement to create an exception or alter the text of one that already exists.

.Example
Changing the message for the exception `E_LARGE_VALUE`:

[source]
----
CREATE OR ALTER EXCEPTION E_LARGE_VALUE
  'The value is higher than the permitted range 0 to 32,765';
----

.See also
<<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>, <<fblangref25-ddl-exception-alter,`ALTER EXCEPTION`>>, <<fblangref25-ddl-exception-recreate,`RECREATE EXCEPTION`>>

[[fblangref25-ddl-exception-drop]]
=== `DROP EXCEPTION`

.Used for
Deleting a custom exception

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP EXCEPTION _exception_name_
----

[[fblangref25-ddl-tbl-dropexcep]]
.`DROP EXCEPTION` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exception_name
|Exception name
|===

The statement `DROP EXCEPTION` is used to delete an exception.
Any dependencies on the exception will cause the statement to fail and the exception will not be deleted.

If an exception is used only in stored procedures, it can be deleted at any time.
If it is used in a trigger, it cannot be deleted.

In planning to delete an exception, all references to it should first be removed from the code of stored procedures, to avoid its absence causing errors.

Any user connected to the database can delete an exception.

.Examples
. Deleting exception `ERROR_REFIN_RATE`:
+
[source]
----
DROP EXCEPTION ERROR_REFIN_RATE;
----
. Deleting exception `E_LARGE_VALUE`:
+
[source]
----
DROP EXCEPTION E_LARGE_VALUE;
----

.See also
<<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>, <<fblangref25-ddl-exception-recreate,`RECREATE EXCEPTION`>>

[[fblangref25-ddl-exception-recreate]]
=== `RECREATE EXCEPTION`

.Used for
Creating a new custom exception or recreating an existing one

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
RECREATE EXCEPTION _exception_name_ '_message_'
----

[[fblangref25-ddl-tbl-recrtexcep]]
.`RECREATE EXCEPTION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exception_name
|Exception name.
The maximum length is 31 characters

|message
|Error message.
The maximum length is limited to 1,021 characters
|===

The statement `RECREATE EXCEPTION` creates a new exception for use in PSQL modules.
If an exception of the same name exists already, the `RECREATE EXCEPTION` statement will try to delete it and create a new one.
If there are any dependencies on the existing exception, the attempted deletion fails and `RECREATE EXCEPTION` is not executed.

Any user connected to the database can [re]create an exception.

.Example
Recreating the `E_LARGE_VALUE` exception:
[source]
----
RECREATE EXCEPTION E_LARGE_VALUE
  'The value exceeds its limit';
----

.See also
<<fblangref25-ddl-exception-create,`CREATE EXCEPTION`>>, <<fblangref25-ddl-exception-drop,`DROP EXCEPTION`>>, <<fblangref25-ddl-exception-crtalter,`CREATE OR ALTER EXCEPTION`>>

[[fblangref25-ddl-collation]]
== `COLLATION`

[[fblangref25-ddl-collation-create]]
=== `CREATE COLLATION`

.Used for
Making a new collation for a supported character set available to the database

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
CREATE COLLATION _collname_
    FOR _charset_
    [FROM _basecoll_ | FROM EXTERNAL ('_extname_')]
    [NO PAD | PAD SPACE]
    [CASE [IN]SENSITIVE]
    [ACCENT [IN]SENSITIVE]
    ['<specific-attributes>']

<specific-attributes> ::= <attribute> [; <attribute> ...]

<attribute> ::= _attrname_=_attrvalue_
----

[[fblangref25-ddl-tbl-collatcrt]]
.`CREATE COLLATION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|collname
|The name to use for the new collation.
The maximum length is 31 characters

|charset
|A character set present in the database

|basecoll
|A collation already present in the database

|extname
|The collation name used in the [path]`.conf` file
|===

The `CREATE COLLATION` statement does not "`create`" anything: its purpose is to make a collation known to a database.
The collation must already be present on the system, typically in a library file, and must be properly registered in a [path]`.conf` file in the [path]`intl` subdirectory of the Firebird installation.

The collation may alternatively be based on one that is already present in the database.

[[fblangref25-ddl-collation-createhow]]
==== How the Engine Detects the Collation

If no `FROM` clause is present, Firebird will scan the [path]`.conf` file(s) in the [path]`intl` subdirectory for a collation with the name specified as the object of `CREATE COLLATION`.
In other words, omitting the `FROM basecoll` clause is equivalent to specifying `FROM EXTERNAL ('collname')`.

The -- single-quoted -- _extname_ is case-sensitive and must correspond exactly with the collation name in the [path]`.conf` file.
The _collname_, _charset_ and _basecoll_ parameters are case-insensitive unless enclosed in double-quotes.

[[fblangref25-ddl-collation-specatt]]
==== Specific Attributes

The available specific attributes are listed in the table below.
Not all specific attributes apply to every collation, even if specifying them does not cause an error. 

[IMPORTANT]
====
Specific attributes are case sensitive.
====

In the table, "`1 bpc`" indicates that an attribute is valid for collations of character sets using 1 byte per character (so-called narrow character sets).
"`UNI`" stands for "`UNICODE collations`".

[[fblangref25-ddl-tbl-specific-colls]]
.Specific Collation Attributes
[cols="<2,<1,<1,<3", options="header"]
|===
^| Atrribute
^| Values
^| Valid for
^| Comment

|`DISABLE-COMPRESSIONS`
|`0`, `1`
|1 bpc
|Disables compressions (a.k.a. contractions).
Compressions cause certain character sequences to be sorted as atomic units, e.g. Spanish c+h as a single character ch

|`DISABLE-EXPANSIONS`
|`0`, `1`
|1 bpc
|Disables expansions.
Expansions cause certain characters (e.g. ligatures or umlauted vowels) to be treated as character sequences and sorted accordingly

|`ICU-VERSION`
|default or M.m
|UNI
|Specifies the ICU library version to use.
Valid values are the ones defined in the applicable <intl_module> element in [path]``intl/fbintl.conf``.
Format: either the string literal "`default`" or a major+minor version number like "`3.0`" (both unquoted).

|`LOCALE`
|xx_YY
|UNI
|Specifies the collation locale.
Requires complete version of ICU libraries.
Format: a locale string like "`du_NL`" (unquoted)

|`MULTI-LEVEL`
|`0`, `1`
|1 bpc
|Uses more than one ordering level

|`NUMERIC-SORT`
|`0`, `1`
|UNI
|Treats contiguous groups of decimal digits in the string as atomic units and sorts them numerically.
(This is also known as natural sorting)

|`SPECIALS-FIRST`
|`0`, `1`
|1 bpc
|Orders special characters (spaces, symbols etc.) before alphanumeric characters
|===

[TIP]
====
If you want to add a new character set with its default collation into your database, declare and run the stored procedure `sp_register_character_set(name, max_bytes_per_character)`, found in [path]`misc/intl.sql/` under the Firebird installation directory.

In order for this to work, the character set must be present on the system and registered in a [path]`.conf` file in the [path]`intl` subdirectory.
====

Any user connected to the database can use `CREATE COLLATION` to add a new collation.

==== Examples using CREATE COLLATION

. Creating a collation using the name found in the [path]`fbintl.conf` file (case-sensitive).
+
[source]
----
CREATE COLLATION ISO8859_1_UNICODE FOR ISO8859_1;
----
. Creating a collation using a special (user-defined) name (the "`external`" name must completely match the name in the [path]`fbintl.conf` file).
+
[source]
----
CREATE COLLATION LAT_UNI
  FOR ISO8859_1
  FROM EXTERNAL ('ISO8859_1_UNICODE');
----
. Creating a case-insensitive collation based on one already existing in the database.
+
[source]
----
CREATE COLLATION ES_ES_NOPAD_CI
  FOR ISO8859_1
  FROM ES_ES
  NO PAD
  CASE INSENSITIVE;
----
. Creating a case-insensitive collation based on one already existing in the database with specific attributes.
+
[source]
----
CREATE COLLATION ES_ES_CI_COMPR
  FOR ISO8859_1
  FROM ES_ES
  CASE INSENSITIVE
  'DISABLE-COMPRESSIONS=0';
----
. Creating a case-insensitive collation by the value of numbers (the so-called natural collation).
+
[source]
----
CREATE COLLATION nums_coll FOR UTF8
  FROM UNICODE
  CASE INSENSITIVE 'NUMERIC-SORT=1';

CREATE DOMAIN dm_nums AS varchar(20)
  CHARACTER SET UTF8 COLLATE nums_coll; -- original (manufacturer) numbers

CREATE TABLE wares(id int primary key, articul dm_nums ...);
----

.See also
<<fblangref25-ddl-collation-drop,`DROP COLLATION`>>

[[fblangref25-ddl-collation-drop]]
=== `DROP COLLATION`

.Used for
Removing a collation from the database

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
DROP COLLATION _collname_
----

[[fblangref25-ddl-tbl-collatdrp]]
.`DROP COLLATION` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|collname
|The name of the collation
|===

The `DROP COLLATION` statement removes the specified collation from the database, if it exists.
An error will be raised if the specified collation is not present.

[TIP]
====
If you want to remove an entire character set with all its collations from the database, declare and execute the stored procedure `sp_unregister_character_set(name)` from the [path]`misc/intl.sql` subdirectory of the Firebird installation.
====

Any user connected to the database can use `DROP COLLATION` to remove a collation.

.Example using `DROP COLLATION`
Deleting the `ES_ES_NOPAD_CI` collation.

[source]
----
DROP COLLATION ES_ES_NOPAD_CI;
----

.See also
<<fblangref25-ddl-tbl-collatcrt,`CREATE COLLATION`>>

[[fblangref25-ddl-charset]]
== `CHARACTER SET`

[[fblangref25-ddl-charset-alter]]
=== `ALTER CHARACTER SET`

.Used for
Setting the default collation for a character set

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
ALTER CHARACTER SET _charset_
  SET DEFAULT COLLATION _collation_
----

[[fblangref25-ddl-tbl-charsetalter]]
.`ALTER CHARACTER SET` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|charset
|Character set identifier

|collation
|The name of the collation
|===

The statement `ALTER CHARACTER SET` statement changes the default collation for the specified character set.
It will affect the future usage of the character set, except for cases where the `COLLATE` clause is explicitly overridden.
In that case, the collation sequence of existing domains, columns and PSQL variables will remain intact after the change to the default collation of the underlying character set.

[NOTE]
====
If you change the default collation for the database character set (the one defined when the database was created), it will change the default collation for the database.

If you change the default collation for the character set that was specified during the connection, string constants will be interpreted according to the new collation value, except in those cases where the character set and/or the collation have been overridden.
====

.Example of use
Setting the default `UNICODE_CI_AI` collation for the `UTF8` encoding.

[source]
----
ALTER CHARACTER SET UTF8
  SET DEFAULT COLLATION UNICODE_CI_AI;
----

[[fblangref25-ddl-role]]
== `ROLE`

A role is a database object that packages a set of <<fblangref25-security-privs,SQL privileges>>.
Roles implement the concept of access control at a group level.
Multiple privileges are granted to the role and then that role can be granted to or revoked from one or many users.

A user that is granted a role must supply that role in his login credentials in order to exercise the associated privileges.
Any other privileges granted to the user are not affected by his login with the role.
Logging in with multiple roles simultaneously is not supported.

In this section the tasks of creating and dropping roles are discussed.

[[fblangref25-ddl-createrole]]
=== `CREATE ROLE`

.Used for
Creating a new `ROLE` object

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
CREATE ROLE _rolename_
----

[[fblangref25-ddl-tbl-createrole]]
.`CREATE ROLE` Statement Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|rolename
|Role name.
The maximum length is 31 characters
|===

The statement `CREATE ROLE` creates a new role object, to which one or more privileges can be granted subsequently.
The name of a role must be unique among the names of roles in the current database. 

[WARNING]
====
It is advisable to make the name of a role unique among user names as well.
The system will not prevent the creation of a role whose name clashes with an existing user name but, if it happens, the user will be unable to connect to the database.
====

Any user connected to the database can create a role.
The user that creates a role becomes its owner.

.Example
Creating a role named `SELLERS`:

[source]
----
CREATE ROLE SELLERS;
----

.See also
<<fblangref25-ddl-droprole,`DROP ROLE`>>, <<fblangref25-security-privs-grant,`GRANT`>>, <<fblangref25-security-privs-revoke,`REVOKE`>>

[[fblangref25-ddl-alterrole]]
=== `ALTER ROLE`

`ALTER ROLE` has no place in the create-alter-drop paradigm for database objects since a role has no attributes that can be modified.
Its actual effect is to alter an attribute of the database: Firebird uses it to enable and disable the capability for Windows Adminstrators to assume <<fblangref25-security-administrators,administrator privileges>> automatically when logging in.

This procedure can affect only one role: the system-generated role `RDB$ADMIN` that exists in every database of ODS 11.2 or higher.
Several factors are involved in enabling this feature.

For details, see <<fblangref25-security-autoadminmapping,[ref]_AUTO ADMIN MAPPING_>> in the [ref]_Security_ chapter.

[[fblangref25-ddl-droprole]]
=== `DROP ROLE`

.Used for
Deleting a role

.Available in
DSQL, ESQL

.Syntax
[listing,subs=+quotes]
----
DROP ROLE _rolename_
----

The statement `DROP ROLE` deletes an existing role.
It takes just a single argument, the name of the role.
Once the role is deleted, the entire set of privileges is revoked from all users and objects that were  granted the role.

A role can be deleted by its owner or by an  <<fblangref25-security-administrators,administrator>>.

.Example
Deleting the role SELLERS: 
[source]
----
DROP ROLE SELLERS;
----

.See also
<<fblangref25-ddl-createrole,`CREATE ROLE`>>, <<fblangref25-security-privs-grant,`GRANT`>>, <<fblangref25-security-privs-revoke,`REVOKE`>>

[[fblangref25-ddl-comment]]
== `COMMENTS`

Database objects and a database itself may contain comments.
It is a convenient mechanism for documenting the development and maintenance of a database.
Comments created with `COMMENT ON` will survive a _gbak_ backup and restore.

[[fblangref25-ddl-comment-create]]
=== `COMMENT ON`

.Used for
Documenting metadata

.Available in
DSQL

.Syntax
[listing,subs=+quotes]
----
COMMENT ON <object> IS {'_sometext_' | NULL}

<object> ::=
    DATABASE
  | <basic-type> _objectname_
  | COLUMN _relationname_._fieldname_
  | PARAMETER _procname_._paramname_

<basic-type> ::=
    CHARACTER SET
  | COLLATION
  | DOMAIN
  | EXCEPTION
  | EXTERNAL FUNCTION
  | FILTER
  | GENERATOR
  | INDEX
  | PROCEDURE
  | ROLE
  | SEQUENCE
  | TABLE
  | TRIGGER
  | VIEW
----

[[fblangref25-ddl-tbl-commenton]]
.`COMMENT ON` Statement Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|sometext
|Comment text

|basic-type
|Metadata object type

|objectname
|Metadata object name

|relationname
|Name of table or view

|procname
|Name of stored procedure

|paramname
|Name of a stored procedure parameter
|===

The `COMMENT ON` statement adds comments for database objects (metadata).
Comments are saved to text fields of the `BLOB` type in the `RDB$DESCRIPTION` column of the corresponding system tables.
Client applications can view comments from these fields. 

[NOTE]
====
If you add an empty comment ("```''```"), it will be saved as `NULL` in the database.
====

The table or procedure owner and <<fblangref25-security-administrators,Administrators>> have the authority to use `COMMENT ON`.

.Examples using `COMMENT ON`
. Adding a comment for the current database
+
[source]
----
COMMENT ON DATABASE IS 'It is a test (''my.fdb'') database';
----
. Adding a comment for the `METALS` table
+
[source]
----
COMMENT ON TABLE METALS IS 'Metal directory';
----
. Adding a comment for the `ISALLOY` field in the `METALS` table
+
[source]
----
COMMENT ON COLUMN METALS.ISALLOY IS '0 = fine metal, 1 = alloy';
----
. Adding a comment for a parameter
+
[source]
----
COMMENT ON PARAMETER ADD_EMP_PROJ.EMP_NO IS 'Employee ID';
----
