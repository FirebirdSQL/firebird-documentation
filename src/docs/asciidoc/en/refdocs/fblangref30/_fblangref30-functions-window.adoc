[[fblangref30-windowfuncs]]
= Window (Analytical) Functions

According to the SQL specification, window functions (also known as analytical functions) are a kind of aggregation, but one that does not "`filter`" the result set of a query.
The rows of aggregated data are mixed with the query result set.

The window functions are used with the `OVER` clause.
They may appear only in the `SELECT` list or the `ORDER BY` clause of a query.

Besides the `OVER` clause, Firebird window functions may be partitioned and ordered.

.Syntax
[listing]
----
<window-function> ::=
  <window-function-name> ([<expr> [, <expr> ...]]) OVER <window-specification>

<window-function-name> ::=
    <aggregate-function>
  | <ranking-function>
  | <navigational-function>

<ranking-function> ::=
  RANK | DENSE_RANK | ROW_NUMBER

<navigational-function>
  LEAD | LAG | FIRST_VALUE | LAST_VALUE | NTH_VALUE

<window-specification> ::=
  ( [ <window-partition> ] [ <window-order> ] )

<window-partition> ::=
  [PARTITION BY <expr> [, <expr> ...]]

<window-order> ::=
  [ORDER BY
    <expr> [<direction>] [<nulls placement>]
    [, <expr> [<direction>] [<nulls placement>] ...]

<direction> ::= {ASC | DESC}

<nulls placement> ::= NULLS {FIRST | LAST}
----

[[fblangref30-windowfuncs-tbl]]
.Window Function Arguments
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|expr
|Expression.
May contain a table column, constant, variable, expression, scalar or aggregate function.
Window functions are not allowed as an expression.

|aggregate_function
|An <<#fblangref30-aggfuncs,aggregate function>> used as a window function
|===

[[fblangref30-windowfuncs-aggfuncs]]
== Aggregate Functions as Window Functions

All <<#fblangref30-aggfuncs,aggregate functions>> can be used as window functions, by adding the `OVER` clause.

Imagine a table `EMPLOYEE` with columns `ID`, `NAME` and `SALARY`, and the need to show each employee with his respective salary and the percentage of his salary over the payroll.

A normal query could achieve this, as follows:

[source]
----
select
    id,
    department,
    salary,
    salary / (select sum(salary) from employee) portion
  from employee
  order by id;
----

.Results
[source]
----
id  department  salary  portion
--  ----------  ------  ----------
1   R & D        10.00      0.2040
2   SALES        12.00      0.2448
3   SALES         8.00      0.1632
4   R & D         9.00      0.1836
5   R & D        10.00      0.2040
----

The query is repetitive and lengthy to run, especially if `EMPLOYEE` happens to be a complex view.

The same query could be specified in a much faster and more elegant way using a window function:

[source]
----
select
    id,
    department,
    salary,
    salary / sum(salary) OVER () portion
  from employee
  order by id;
----

Here, `sum(salary) over ()` is computed with the sum of all `SALARY` from the query (the `EMPLOYEE` table).

[[fblangref30-windowfuncs-partition]]
== Partitioning

Like aggregate functions, that may operate alone or in relation to a group, window functions may also operate on a group, which is called a "`partition`".

.Syntax
[listing]
----
<window function>(...) OVER (PARTITION BY <expr> [, <expr> ...])
----

Aggregation over a group could produce more than one row, so the result set generated by a partition is joined with the main query using the same expression list as the partition.

Continuing the `EMPLOYEE` example, instead of getting the portion of each employee's salary over the all-employees total, we would like to get the portion based on just the employees in the same department:

[source]
----
select
    id,
    department,
    salary,
    salary / sum(salary) OVER (PARTITION BY department) portion
  from employee
  order by id;
----

.Results
[source]
----
id  department  salary  portion
--  ----------  ------  ----------
1   R & D        10.00      0.3448
2   SALES        12.00      0.6000
3   SALES         8.00      0.4000
4   R & D         9.00      0.3103
5   R & D        10.00      0.3448
----

[[fblangref30-windowfuncs-order-by]]
== Ordering

The `ORDER BY` sub-clause can be used with or without partitions.
The `ORDER BY` clause within `OVER` specifies the order in which the window function will process rows.
This order does not have to be the same as the order rows appear in the output.

There is an important concept associated with window functions: for each row there is a set of rows in its partition called the _window frame_.
By default, when specifying `ORDER BY`, the frame consists of all lines from the beginning of the partition to the current row and rows equal to the current `ORDER BY` expression.
Without `ORDER BY`, the default frame consists of all rows in the partition.

As a result, for standard aggregate functions, the `ORDER BY` clause produces partial aggregation results as rows are processed.

.Example
[source]
----
select
    id,
    salary,
    sum(salary) over (order by salary) cumul_salary
  from employee
  order by salary;
----

.Results
[source]
----
id  salary  cumul_salary
--  ------  ------------
3     8.00          8.00
4     9.00         17.00
1    10.00         37.00
5    10.00         37.00
2    12.00         49.00
----

Then `cumul_salary` returns the partial/accumulated (or running) aggregation (of the `SUM` function).
It may appear strange that 37.00 is repeated for the ids 1 and 5, but that is how it should work.
The `ORDER BY` keys are grouped together and the aggregation is computed once (but summing the two 10.00).
To avoid this, you can add the `ID` field to the end of the `ORDER BY` clause.

It's possible to use multiple windows with different orders, and `ORDER BY` parts like `ASC`/`DESC` and `NULLS FIRST/LAST`.

With a partition, `ORDER BY` works the same way, but at each partition boundary the aggregation is reset.

All aggregation functions can use `ORDER BY`, except for `LIST()`.

[[fblangref30-windowfuncs-rankfuncs]]
== Ranking Functions

The ranking functions compute the ordinal rank of a row within the window partition.

These functions can be used with or without partioning and ordering.
However, using them without ordering almost never makes sense.

The ranking functions can be used to create different type of incremental counters.
Consider `SUM(1) OVER (ORDER BY SALARY)` as an example of what they can do, each of them in a different way.
Following is an example query, also comparing with the `SUM` behavior.

[source]
----
select
    id,
    salary,
    dense_rank() over (order by salary),
    rank() over (order by salary),
    row_number() over (order by salary),
    sum(1) over (order by salary)
  from employee
  order by salary;
----

.Results
[source]
----
id  salary  dense_rank  rank  row_number  sum
--  ------  ----------  ----  ----------  ---
3     8.00           1     1           1    1
4     9.00           2     2           2    2
1    10.00           3     3           3    4
5    10.00           3     3           4    4
2    12.00           4     5           5    5
----

The difference between `DENSE_RANK` and `RANK` is that there is a gap related to duplicate rows (relative to the window ordering) only in `RANK`.
`DENSE_RANK` continues assigning sequential numbers after the duplicate salary.
On the other hand, `ROW_NUMBER` always assigns sequential numbers, even when there are duplicate values.

[[fblangref30-windowfuncs-dense-rank]]
=== `DENSE_RANK`

.Available in
DSQL, PSQL

.Result type
`BIGINT`

.Syntax
[listing]
----
DENSE_RANK () OVER <window-specification>
----

Returns the rank of rows in a partition of a result set without ranking gaps.
Rows with the same _window-order_ values get the same rank within the partition _window-partition_, if specified.
The dense rank of a row is equal to the number of different rank values in the partition preceding the current row, plus one.

[[fblangref30-windowfuncs-dense-rank-exmpl]]
==== `DENSE_RANK` Examples

[source]
----
select
  id,
  salary,
  dense_rank() over (order by salary)
from employee
order by salary;
----

.Result
[listing]
----
id salary dense_rank
- ------ -----------
3   8.00           1
4   9.00           2
1  10.00           3
5  10.00           3
2  12.00           4
----

.See also <<fblangref30-windowfuncs-rank>>, <<fblangref30-windowfuncs-row-number>>

[[fblangref30-windowfuncs-rank]]
=== `RANK`

.Available in
DSQL, PSQL

.Result type
`BIGINT`

.Syntax
[listing]
----
RANK () OVER <window-specification>
----

Returns the rank of each row in a partition of the result set.
Rows with the same values of _window-order_ get the same rank with in the partition _window-partition, if specified.
The rank of a row is equal to the number of rank values in the partition preceding the current row, plus one.

[[fblangref30-windowfuncs-rank-exmpl]]
==== `RANK` Examples

[source]
----
select
  id,
  salary,
  rank() over (order by salary)
from employee
order by salary;
----

.Result
[listing]
----
id salary rank
- ------ -----
3   8.00     1
4   9.00     2
1  10.00     3
5  10.00     3
2  12.00     5
----

.See also
<<fblangref30-windowfuncs-dense-rank>>, <<fblangref30-windowfuncs-row-number>>

[[fblangref30-windowfuncs-row-number]]
=== `ROW_NUMBER`

.Available in
DSQL, PSQL

.Result type
`BIGINT`

.Syntax
[listing]
----
ROW_NUMBER () OVER <window-specification>
----

Returns the sequential row number in the partition of the result set, where `1` is the first row in each of the partitions.

[[fblangref30-windowfuncs-row-number-exmpl]]
==== `ROW_NUMBER` Examples

[source]
----
select
  id,
  salary,
  row_number() over (order by salary)
from employee
order by salary;
----

.Result
[listing]
----
id salary rank
- ------ -----
3   8.00     1
4   9.00     2
1  10.00     3
5  10.00     4
2  12.00     5
----

.See also
<<fblangref30-windowfuncs-dense-rank>>, <<fblangref30-windowfuncs-rank>>

[[fblangref30-windowfuncs-navfuncs]]
== Navigational Functions

The navigational functions get the simple (non-aggregated) value of an expression from another row of the query, within the same partition.

[[fblangref30-windowfuncs-navfuncs-frame-note]]
[IMPORTANT]
====
`FIRST_VALUE`, `LAST_VALUE` and `NTH_VALUE` also operate on a window frame.
Currently, Firebird always applies a frame from the first to the current row of the partition, not to the last.
This is equivalent to using the SQL standard syntax (currently not supported by Firebird):

[source]
----
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
----

This is likely to produce strange or unexpected results for `NTH_VALUE` and especially `LAST_VALUE`.

Firebird 4 will introduce support for specifying the window frame.
====

[float]
===== Example of Navigational Functions

[source]
----
select
    id,
    salary,
    first_value(salary) over (order by salary),
    last_value(salary) over (order by salary),
    nth_value(salary, 2) over (order by salary),
    lag(salary) over (order by salary),
    lead(salary) over (order by salary)
  from employee
  order by salary;
----

.Results
[listing]
----
id  salary  first_value  last_value  nth_value     lag    lead
--  ------  -----------  ----------  ---------  ------  ------
3     8.00         8.00        8.00     <null>  <null>    9.00
4     9.00         8.00        9.00       9.00    8.00   10.00
1    10.00         8.00       10.00       9.00    9.00   10.00
5    10.00         8.00       10.00       9.00   10.00   12.00
2    12.00         8.00       12.00       9.00   10.00  <null>
----

[[fblangref30-windowfuncs-first-value]]
=== `FIRST_VALUE`

.Available in
DSQL, PSQL

.Result type
The same as type as _expr_

.Syntax
[listing]
----
FIRST_VALUE ( <expr> ) OVER <window-specification>
----

[[fblangref30-windowfuncs-tbl-first-value]]
.Arguments of `FIRST_VALUE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|expr
|Expression.
May contain a table column, constant, variable, expression, scalar function.
Aggregate functions are not allowed as an expression.
|===

Returns the first value from the current partition.

.See also
<<fblangref30-windowfuncs-last-value>>, <<fblangref30-windowfuncs-nth-value>>

[[fblangref30-windowfuncs-lag]]
=== `LAG`

.Available in
DSQL, PSQL

.Result type
The same as type as _expr_

.Syntax
[listing]
----
LAG ( <expr> [, <offset [, <default>]])
  OVER <window-specification>
----

[[fblangref30-windowfuncs-tbl-lag]]
.Arguments of `LAG`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|expr
|Expression.
May contain a table column, constant, variable, expression, scalar function.
Aggregate functions are not allowed as an expression.

|offset
|The offset in rows before the current row to get the value identified by _expr_.
If _offset_ is not specified, the default is `1`.
_offset_ can be a column, subquery or other expression that results in a positive integer value, or another type that can be implicitly converted to `BIGINT`.
`offset` cannot be negative (use `LEAD` instead).

|default
|The default value to return if _offset_ points outside the partition.
Default is `NULL`.
|===

The `LAG` function provides access to the row in the current partition with a given _offset_ before the current row.

If _offset_ points outside the current partition, _default_ will be returned, or `NULL` if no default was specified.

[NOTE]
====
_offset_ can be a parameter, but explicit casting to `INTEGER` or `BIGINT` is currently required (eg `LAG(somecolumn, cast(? as bigint))`).
See http://tracker.firebirdsql.org/browse/CORE-6421[CORE-6421]
====

[[fblangref30-windowfuncs-lag-exmpl]]
==== `LAG` Examples

Suppose you have `RATE` table that stores the exchange rate for each day.
To trace the change of the exchange rate over the past five days you can use the following query.

[source]
----
select
  bydate,
  cost,
  cost - lag(cost) over (order by bydate) as change,
  100 * (cost - lag(cost) over (order by bydate)) /
    lag(cost) over (order by bydate) as percent_change
from rate
where bydate between dateadd(-4 day to current_date)
and current_date
order by bydate
----

.Result
[listing]
----
bydate     cost   change percent_change
---------- ------ ------ --------------
27.10.2014  31.00 <null>         <null>
28.10.2014  31.53   0.53         1.7096
29.10.2014  31.40  -0.13        -0.4123
30.10.2014  31.67   0.27         0.8598
31.10.2014  32.00   0.33         1.0419
----

.See also
<<fblangref30-windowfuncs-lead>>

[[fblangref30-windowfuncs-last-value]]
=== `LAST_VALUE`

.Available in
DSQL, PSQL

.Result type
The same as type as _expr_

.Syntax
[source]
----
LAST_VALUE ( <expr> ) OVER <window-specification>
----

[[fblangref30-windowfuncs-tbl-last-value]]
.Arguments of `LAST_VALUE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|expr
|Expression.
May contain a table column, constant, variable, expression, scalar function.
Aggregate functions are not allowed as an expression.
|===

Returns the last value from the current partition.

.See also
<<fblangref30-windowfuncs-first-value>>, <<fblangref30-windowfuncs-nth-value>>

[[fblangref30-windowfuncs-lead]]
=== `LEAD`

.Available in
DSQL, PSQL

.Result type
The same as type as _expr_

.Syntax
[listing]
----
LEAD ( <expr> [, <offset [, <default>]])
  OVER <window-specification>
----

[[fblangref30-windowfuncs-tbl-lead]]
.Arguments of `LEAD`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|expr
|Expression.
May contain a table column, constant, variable, expression, scalar function.
Aggregate functions are not allowed as an expression.

|offset
|The offset in rows after the current row to get the value identified by _expr_.
If _offset_ is not specified, the default is `1`.
_offset_ can be a column, subquery or other expression that results in a positive integer value, or another type that can be implicitly converted to `BIGINT`.
`offset` cannot be negative (use `LAG` instead).

|default
|The default value to return if _offset_ points outside the partition.
Default is `NULL`.
|===

The `LEAD` function provides access to the row in the current partition with a given _offset_ after the current row.

If _offset_ points outside the current partition, _default_ will be returned, or `NULL` if no default was specified.

[NOTE]
====
_offset_ can be a parameter, but explicit casting to `INTEGER` or `BIGINT` is currently required (eg `LEAD(somecolumn, cast(? as bigint))`).
See http://tracker.firebirdsql.org/browse/CORE-6421[CORE-6421]
====

.See also
<<fblangref30-windowfuncs-lag>>

[[fblangref30-windowfuncs-nth-value]]
=== `NTH_VALUE`

.Available in
DSQL, PSQL

.Result type
The same as type as _expr_

.Syntax
[listing]
----
NTH_VALUE ( <expr>, <offset> )
  [FROM {FIRST | LAST}]
  OVER <window-specification>
----

[[fblangref30-windowfuncs-tbl-nth-value]]
.Arguments of `NTH_VALUE`
[cols="<1,<3", options="header",stripes="none"]
|===
^| Argument
^| Description

|expr
|Expression.
May contain a table column, constant, variable, expression, scalar function.
Aggregate functions are not allowed as an expression.

|offset
|The offset in rows from the start (`FROM FIRST`) or the last (`FROM LAST`) to get the value identified by _expr_.
_offset_ can be a column, subquery or other expression that results in a positive integer value, or another type that can be implicitly converted to `BIGINT`.
`offset` cannot be zero or negative.
|===

The `NTH_VALUE` function returns the __N__th value starting from the first (`FROM FIRST`) or the last (`FROM LAST`) row of the current frame, see also <<fblangref30-windowfuncs-navfuncs-frame-note,note on frame for navigational functions>>.
Offset `1` with `FROM FIRST` is equivalent to `FIRST_VALUE`, and offset `1` with `FROM LAST` is equivalent to `LAST_VALUE`.

[NOTE]
====
_offset_ can be a parameter, but explicit casting to `INTEGER` or `BIGINT` is currently required (eg `LEAD(somecolumn, cast(? as bigint))`).
See http://tracker.firebirdsql.org/browse/CORE-6421[CORE-6421]
====

.See also
<<fblangref30-windowfuncs-first-value>>, <<fblangref30-windowfuncs-last-value>>

[[fblangref30-windowfuncs-aggfuncs-windowspec]]
== Aggregate Functions Inside Window Specification

It is possible to use aggregate functions (but not window functions) inside the `OVER` clause.
In that case, first the aggregate function is applied to determine the windows, and only then the window functions are applied on those windows.

[NOTE]
====
When using aggregate functions inside `OVER`, all columns not used in aggregate functions must be specified in the `GROUP BY` clause of the `SELECT`.
====

.Using an Aggregate Function in a Window Specification
[source]
----
select
  code_employee_group,
  avg(salary) as avg_salary,
  rank() over (order by avg(salary)) as salary_rank
from employee
group by code_employee_group
----
