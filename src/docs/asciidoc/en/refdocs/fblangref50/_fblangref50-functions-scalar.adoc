[[fblangref50-functions]]
= Built-in Scalar Functions

[[fblangref50-functions-workcontext]]
== Context Functions

[[fblangref50-scalarfuncs-get-context]]
=== `RDB$GET_CONTEXT()`

.Available in
DSQL, PSQL{nbsp}* As a declared UDF it should be available in ESQL

.Result type
`VARCHAR(255)`

.Syntax
[listing,subs=+quotes]
----
RDB$GET_CONTEXT ('<namespace>', <varname>)

<namespace> ::= SYSTEM | USER_SESSION | USER_TRANSACTION | DDL_TRIGGER
<varname>   ::= _A case-sensitive quoted string of max. 80 characters_
----

[[fblangref50-funcs-tbl-rdbgetcontext]]
.`RDB$GET_CONTEXT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|namespace
|Namespace

|varname
|Variable name.
Case-sensitive.
Maximum length is 80 characters
|===

Retrieves the value of a context variable from one of the namespaces `SYSTEM`, `USER_SESSION` and `USER_TRANSACTION`.

.The namespaces
The `USER_SESSION` and `USER_TRANSACTION` namespaces are initially empty.
The user can create and set variables in them with `RDB$SET_CONTEXT()` and retrieve them with `RDB$GET_CONTEXT()`.
The `SYSTEM` namespace is read-only.
The `DDL_TRIGGER` namespace is only valid in DDL triggers, and is read-only.
It contains a number of predefined variables, shown below.

.Return values and error behaviour
If the polled variable exists in the given namespace, its value will be returned as a string of max. 255 characters.
If the namespace doesn't exist or if you try to access a non-existing variable in the `SYSTEM` namespace, an error is raised.
If you request a non-existing variable in one of the other namespaces, `NULL` is returned.
Both namespace and variable names must be given as single-quoted, case-sensitive, non-``NULL`` strings.

[[fblangref50-funcs-tbl-rdbgetcontext-system]]
==== The `SYSTEM` Namespace

[[fblangref50-funcs-tbl-systemnamespace]]
.Context variables in the SYSTEM namespace
`CLIENT_ADDRESS`::
For TCPv4, this is the IP address.
For XNET, the local process ID.
For all other protocols this variable is `NULL`.

`CLIENT_HOST`::
The wire protocol host name of remote client.
Value is returned for all supported protocols.

`CLIENT_PID`::
Process ID of remote client application.

`CLIENT_PROCESS`::
Process name of remote client application.

`CURRENT_ROLE`::
Same as global <<fblangref50-contextvars-current-role>> variable.

`CURRENT_USER`::
Same as global <<fblangref50-contextvars-current-user>> variable.

`DB_FILE_ID`::
Unique filesystem-level ID of the current database.

`DB_GUID`::
GUID of the current database.

`DB_NAME`::
Canonical name of current database;
either the full path to the database or -- if connecting via the path is disallowed -- its alias.

`EFFECTIVE_USER`::
Effective user at the point `RDB$GET_CONTEXT` is called;
indicates privileges of which user is currently used to execute a function, procedure, trigger.

`ENGINE_VERSION`::
The Firebird engine (server) version.

`EXT_CONN_POOL_ACTIVE_COUNT`::
Count of active connections associated with the external connection pool.

`EXT_CONN_POOL_IDLE_COUNT`::
Count of currently inactive connections available in the connection pool.

`EXT_CONN_POOL_LIFETIME`::
External connection pool idle connection lifetime, in seconds.

`EXT_CONN_POOL_SIZE`::
External connection pool size.

`GLOBAL_CN`::
Most current value of global Commit Number counter.

`ISOLATION_LEVEL`::
The isolation level of the current transaction: ``'READ COMMITTED'``, ``'SNAPSHOT'`` or ``'CONSISTENCY'``.

`LOCK_TIMEOUT`::
Lock timeout of the current transaction.

`NETWORK_PROTOCOL`::
The protocol used for the connection: ``'TCPv4'``, ``'WNET'``, ``'XNET'`` or `NULL`.

`READ_ONLY`::
Returns ``'TRUE'`` if current transaction is read-only and ``'FALSE'`` otherwise.

`REPLICA_MODE`::
Replica mode of the database: ``'READ-ONLY'``, ``'READ-WRITE'`` and `NULL`.

`REPLICATION_SEQUENCE`::
Current replication sequence (number of the latest segment written to the replication journal).

`PARALLEL_WORKERS`::
The maximum number of parallel workers of the connection.

`SESSION_ID`::
Same as global <<fblangref50-contextvars-current-connection>> variable.

`SESSION_IDLE_TIMEOUT`::
Connection-level idle timeout, or `0` if no timeout was set.
When `0` is reported the database `ConnectionIdleTimeout` from `databases.conf` or `firebird.conf` applies.

`SESSION_TIMEZONE`::
Current session time zone.

`SNAPSHOT_NUMBER`::
Current snapshot number for the transaction executing this statement.
For `SNAPSHOT` and `SNAPSHOT TABLE STABILITY`, this number is stable for the duration of the transaction;
for `READ COMMITTED` this number will change (increment) as concurrent transactions are committed.

`STATEMENT_TIMEOUT`::
Connection-level statement timeout, or `0` if no timeout was set.
When `0` is reported the database `StatementTimeout` from `databases.conf` or `firebird.conf` applies.

`TRANSACTION_ID`::
Same as global <<fblangref50-contextvars-current-transaction>> variable.

`WIRE_COMPRESSED`::
Compression status of the current connection.
If the connection is compressed, returns `TRUE`;
if it is not compressed, returns `FALSE`.
Returns `NULL` if the connection is embedded.

`WIRE_ENCRYPTED`::
Encryption status of the current connection.
If the connection is encrypted, returns `TRUE`;
if it is not encrypted, returns `FALSE`.
Returns `NULL` if the connection is embedded.

`WIRE_CRYPT_PLUGIN`::
If connection is encrypted - returns name of current plugin, otherwise `NULL`.

[[fblangref50-funcs-tbl-rdbgetcontext-ddl-trigger]]
==== The `DDL_TRIGGER` Namespace

The `DDL_TRIGGER` namespace is valid only when a DDL trigger is running.
Its use is also valid in stored procedures and functions called by DDL triggers.

The `DDL_TRIGGER` context works like a stack.
Before a DDL trigger is fired, the values relative to the executed command are pushed onto this stack.
After the trigger finishes, the values are popped.
So in the case of cascade DDL statements, when a user DDL command fires a DDL trigger and this trigger executes another DDL command with `EXECUTE STATEMENT`, the values of the `DDL_TRIGGER` namespace are the ones relative to the command that fired the last DDL trigger on the call stack.

.Context variables in the DDL_TRIGGER namespace
`EVENT_TYPE`:: event type (`CREATE`, `ALTER`, `DROP`)
`OBJECT_TYPE`:: object type (`TABLE`, `VIEW`, etc)
`DDL_EVENT`:: event name (`<ddl event item>`), where `<ddl_event_item>` is `EVENT_TYPE || ' ' || OBJECT_TYPE`
`OBJECT_NAME`:: metadata object name
`OLD_OBJECT_NAME`:: for tracking the renaming of a domain (see note)
`NEW_OBJECT_NAME`:: for tracking the renaming of a domain (see note)
`SQL_TEXT`:: sql statement text

[NOTE]
====
`ALTER DOMAIN __old-name__ TO __new-name__` sets `OLD_OBJECT_NAME` and `NEW_OBJECT_NAME` in both `BEFORE` and `AFTER` triggers.
For this command, `OBJECT_NAME` will have the old object name in `BEFORE` triggers, and the new object name in `AFTER` triggers.
====

[[fblangref50-funcs-tbl-rdbgetcontext-exmpl]]
==== Examples

[source]
----
select rdb$get_context('SYSTEM', 'DB_NAME') from rdb$database

New.UserAddr = rdb$get_context('SYSTEM', 'CLIENT_ADDRESS');

insert into MyTable (TestField)
  values (rdb$get_context('USER_SESSION', 'MyVar'))
----

.See also
<<fblangref50-scalarfuncs-set-context>>

[[fblangref50-scalarfuncs-set-context]]
=== `RDB$SET_CONTEXT()`

.Available in
DSQL, PSQL{nbsp}* As a declared UDF it should be available in ESQL

.Result type
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
RDB$SET_CONTEXT ('<namespace>', <varname>, <value> | NULL)

<namespace> ::= USER_SESSION | USER_TRANSACTION
<varname>   ::= _A case-sensitive quoted string of max. 80 characters_
<value>     ::= _A value of any type, as long as it's castable_
                _to a VARCHAR(255)_
----

[[fblangref50-funcs-tbl-rdbsetcontext]]
.`RDB$SET_CONTEXT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|namespace
|Namespace

|varname
|Variable name.
Case-sensitive.
Maximum length is 80 characters

|value
|Data of any type provided it can be cast to `VARCHAR(255)`
|===

Creates, sets or unsets a variable in one of the user-writable namespaces `USER_SESSION` and `USER_TRANSACTION`.

.The namespaces
The `USER_SESSION` and `USER_TRANSACTION` namespaces are initially empty.
The user can create and set variables in them with `RDB$SET_CONTEXT()` and retrieve them with `RDB$GET_CONTEXT()`.
The `USER_SESSION` context is bound to the current connection.
Variables in `USER_TRANSACTION` only exist in the transaction in which they have been set.
When the transaction ends, the context and all the variables defined in it are destroyed.

.Return values and error behaviour
The function returns `1` when the variable already existed before the call and `0` when it didn't.
To remove a variable from a context, set it to `NULL`.
If the given namespace doesn't exist, an error is raised.
Both namespace and variable names must be entered as single-quoted, case-sensitive, non-``NULL`` strings.

[NOTE]
====
* The maximum number of variables in any single context is 1000.
* All `USER_TRANSACTION` variables will survive a <<fblangref50-transacs-rollback-options,`ROLLBACK RETAIN`>>  (see `ROLLBACK` Options) or <<fblangref50-transacs-rollback-tosavepoint,`ROLLBACK TO SAVEPOINT`>> unaltered, no matter at which point during the transaction they were set.
* Due to its UDF-like nature, `RDB$SET_CONTEXT` can -- in PSQL only -- be called like a void function, without assigning the result, as in the second example above.
Regular internal functions don't allow this type of use.
====

.Examples
[source]
----
select rdb$set_context('USER_SESSION', 'MyVar', 493) from rdb$database

rdb$set_context('USER_SESSION', 'RecordsFound', RecCounter);

select rdb$set_context('USER_TRANSACTION', 'Savepoints', 'Yes')
  from rdb$database
----

.See also
<<fblangref50-scalarfuncs-get-context>>

[[fblangref50-functions-math]]
== Mathematical Functions

[[fblangref50-scalarfuncs-abs]]
=== `ABS()`

.Available in
DSQL, PSQL

.Result type
Numerical

.Syntax
[listing,subs=+quotes]
----
ABS (_number_)
----

[[fblangref50-funcs-tbl-abs]]
.`ABS` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the absolute value of the argument.

[[fblangref50-scalarfuncs-acos]]
=== `ACOS()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ACOS (_number_)
----

[[fblangref50-funcs-tbl-acos]]
.`ACOS` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type within the range [-1, 1]
|===

Returns the arc cosine of the argument.

* The result is an angle in the range [0, pi].

.See also
<<fblangref50-scalarfuncs-cos>>, <<fblangref50-scalarfuncs-asin>>, <<fblangref50-scalarfuncs-atan>>

[[fblangref50-scalarfuncs-acosh]]
=== `ACOSH()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ACOSH (_number_)
----

[[fblangref50-funcs-tbl-acosh]]
.`ACOSH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any non-``NULL`` value in the range [1, INF].
|===

Returns the inverse hyperbolic cosine of the argument.

* The result is in the range [0, INF].

.See also
<<fblangref50-scalarfuncs-cosh>>, <<fblangref50-scalarfuncs-asinh>>, <<fblangref50-scalarfuncs-atanh>>

[[fblangref50-scalarfuncs-asin]]
=== `ASIN()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ASIN (_number_)
----

[[fblangref50-funcs-tbl-asin]]
.`ASIN` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type within the range [-1, 1]
|===

Returns the arc sine of the argument.

* The result is an angle in the range [-pi/2, pi/2].

.See also
<<fblangref50-scalarfuncs-sin>>, <<fblangref50-scalarfuncs-acos>>, <<fblangref50-scalarfuncs-atan>>

[[fblangref50-scalarfuncs-asinh]]
=== `ASINH()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ASINH (_number_)
----

[[fblangref50-funcs-tbl-asinh]]
.`ASINH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any non-``NULL`` value in the range [-INF, INF].
|===

Returns the inverse hyperbolic sine of the argument.

* The result is in the range [-INF, INF].

.See also
<<fblangref50-scalarfuncs-sinh>>, <<fblangref50-scalarfuncs-acosh>>, <<fblangref50-scalarfuncs-atanh>>

[[fblangref50-scalarfuncs-atan]]
=== `ATAN()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ATAN (_number_)
----

[[fblangref50-funcs-tbl-atan]]
.`ATAN` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

The function `ATAN` returns the arc tangent of the argument.
The result is an angle in the range ++<-pi/2, pi/2>++.

.See also
<<fblangref50-scalarfuncs-atan2>>, <<fblangref50-scalarfuncs-tan>>, <<fblangref50-scalarfuncs-acos>>, <<fblangref50-scalarfuncs-asin>>

[[fblangref50-scalarfuncs-atan2]]
=== `ATAN2()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

//Note for maintainers/editors: the argument names y and x (in that order!) are chosen on purpose, for geometrical reasons.
.Syntax
[listing,subs=+quotes]
----
ATAN2 (_y_, _x_)
----

[[fblangref50-funcs-tbl-atan2]]
.`ATAN2` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|y
|An expression of a numeric type

|x
|An expression of a numeric type
|===

Returns the angle whose sine-to-cosine _ratio_ is given by the two arguments, and whose sine and cosine _signs_ correspond to the signs of the arguments.
This allows results across the entire circle, including the angles -pi/2 and pi/2. 

* The result is an angle in the range [-pi, pi].
* If _x_ is negative, the result is pi if _y_ is 0, and -pi if _y_ is -0.
* If both _y_ and _x_ are 0, the result is meaningless.
An error will be raised if both arguments are 0.

[NOTES]
====
* A fully equivalent description of this function is the following: `ATAN2(__y__, __x__)` is the angle between the positive X-axis and the line from the origin to the point _(x, y)_.
This also makes it obvious that `ATAN2(0, 0)` is undefined.
* If _x_ is greater than 0, `ATAN2(__y__, __x__)` is the same as `ATAN(__y__/__x__)`.
* If both sine and cosine of the angle are already known, `ATAN2(__sin__, __cos__)` gives the angle.
====

[[fblangref50-scalarfuncs-atanh]]
=== `ATANH()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ATANH (_number_)
----

[[fblangref50-funcs-tbl-atanh]]
.`ATANH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any non-``NULL`` value in the range ++<-1, 1>++.
|===

Returns the inverse hyperbolic tangent of the argument.

* The result is a number in the range [-INF, INF].

.See also
<<fblangref50-scalarfuncs-tanh>>, <<fblangref50-scalarfuncs-acosh>>, <<fblangref50-scalarfuncs-asinh>>

[[fblangref50-scalarfuncs-ceil]]
=== `CEIL()`, `CEILING()`

.Available in
DSQL, PSQL

.Result type
`BIGINT` for exact numeric _number_, or `DOUBLE PRECISION` for floating point _number_

.Syntax
[listing,subs=+quotes]
----
CEIL[ING] (_number_)
----

[[fblangref50-funcs-tbl-ceil]]
.`CEIL[ING]` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the smallest whole number greater than or equal to the argument.

.See also
<<fblangref50-scalarfuncs-floor>>, <<fblangref50-scalarfuncs-round>>, <<fblangref50-scalarfuncs-trunc>>

[[fblangref50-scalarfuncs-cos]]
=== `COS()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COS (_angle_)
----

[[fblangref50-funcs-tbl-cos]]
.`COS` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|angle
|An angle in radians
|===

Returns an angle's cosine.
The argument must be given in radians. 

* Any non-``NULL`` result is in the range [-1, 1].

.See also
<<fblangref50-scalarfuncs-acos>>, <<fblangref50-scalarfuncs-cot>>, <<fblangref50-scalarfuncs-sin>>, <<fblangref50-scalarfuncs-tan>>

[[fblangref50-scalarfuncs-cosh]]
=== `COSH()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COSH (_number_)
----

[[fblangref50-funcs-tbl-cosh]]
.`COSH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|A number of a numeric type
|===

Returns the hyperbolic cosine of the argument.

* Any non-``NULL`` result is in the range [1, INF].

.See also
<<fblangref50-scalarfuncs-acosh>>, <<fblangref50-scalarfuncs-sinh>>, <<fblangref50-scalarfuncs-tanh>>

[[fblangref50-scalarfuncs-cot]]
=== `COT()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
COT (_angle_)
----

[[fblangref50-funcs-tbl-cot]]
.`COT` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|angle
|An angle in radians
|===

Returns an angle's cotangent.
The argument must be given in radians.

.See also
<<fblangref50-scalarfuncs-cos>>, <<fblangref50-scalarfuncs-sin>>, <<fblangref50-scalarfuncs-tan>>

[[fblangref50-scalarfuncs-exp]]
=== `EXP()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
EXP (_number_)
----

[[fblangref50-funcs-tbl-exp]]
.`EXP` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|A number of a numeric type
|===

Returns the natural exponential, _e_^`number`^

.See also
<<fblangref50-scalarfuncs-ln>>

[[fblangref50-scalarfuncs-floor]]
=== `FLOOR()`

.Available in
DSQL, PSQL

.Result type
`BIGINT` for exact numeric _number_, or `DOUBLE PRECISION` for floating point _number_

.Syntax
[listing,subs=+quotes]
----
FLOOR (_number_)
----

[[fblangref50-funcs-tbl-floor]]
.`FLOOR` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the largest whole number smaller than or equal to the argument.

.See also
<<fblangref50-scalarfuncs-ceil>>, <<fblangref50-scalarfuncs-round>>, <<fblangref50-scalarfuncs-trunc>>

[[fblangref50-scalarfuncs-ln]]
=== `LN()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LN (_number_)
----

[[fblangref50-funcs-tbl-ln]]
.`LN` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the natural logarithm of the argument.

* An error is raised if the argument is negative or 0.

.See also
<<fblangref50-scalarfuncs-exp>>, <<fblangref50-scalarfuncs-log>>, <<fblangref50-scalarfuncs-log10>>

[[fblangref50-scalarfuncs-log]]
=== `LOG()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LOG (_x_, _y_)
----

[[fblangref50-funcs-tbl-log]]
.`LOG` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|x
|Base.
An expression of a numeric type

|y
|An expression of a numeric type
|===

Returns the __x__-based logarithm of _y_.

* If either argument is 0 or below, an error is raised.
(Before 2.5, this would result in `NaN`, `+/-INF` or 0, depending on the exact values of the arguments.)
* If both arguments are 1, `NaN` is returned.
* If _x_ = 1 and _y_ < 1, `-INF` is returned.
* If _x_ = 1 and _y_ > 1, `INF` is returned.

.See also
<<fblangref50-scalarfuncs-power>>, <<fblangref50-scalarfuncs-ln>>, <<fblangref50-scalarfuncs-log10>>

[[fblangref50-scalarfuncs-log10]]
=== `LOG10()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
LOG10 (_number_)
----

[[fblangref50-funcs-tbl-log10]]
.`LOG10` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the 10-based logarithm of the argument.

* An error is raised if the argument is negative or 0.
(In versions prior to 2.5, such values would result in `NaN` and `-INF`, respectively.)

.See also
<<fblangref50-scalarfuncs-power>>, <<fblangref50-scalarfuncs-ln>>, <<fblangref50-scalarfuncs-log>>

[[fblangref50-scalarfuncs-mod]]
=== `MOD()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`, `INTEGER` or `BIGINT` depending on the type of _a_.
If _a_ is a floating-point type, the result is a `BIGINT`.

.Syntax
[listing,subs=+quotes]
----
MOD (_a_, _b_)
----

[[fblangref50-funcs-tbl-mod]]
.`MOD` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|a
|An expression of a numeric type

|b
|An expression of a numeric type
|===

Returns the remainder of an integer division.

* Non-integer arguments are rounded before the division takes place.
So, "```mod(7.5, 2.5)```" gives 2 ("```mod(8, 3)```"), not 0.

[[fblangref50-scalarfuncs-pi]]
=== `PI()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing]
----
PI ()
----

Returns an approximation of the value of _pi_.

[[fblangref50-scalarfuncs-power]]
=== `POWER()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
POWER (_x_, _y_)
----

[[fblangref50-funcs-tbl-power]]
.`POWER` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|x
|An expression of a numeric type

|y
|An expression of a numeric type
|===

Returns _x_ to the power of _y_ (_x^y^_).

.See also
<<fblangref50-scalarfuncs-exp>>, <<fblangref50-scalarfuncs-log>>, <<fblangref50-scalarfuncs-log10>>, <<fblangref50-scalarfuncs-sqrt>>

[[fblangref50-scalarfuncs-rand]]
=== `RAND()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing]
----
RAND ()
----

Returns a random number between 0 and 1.

[[fblangref50-scalarfuncs-round]]
=== `ROUND()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`, (scaled) `BIGINT` or `DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
ROUND (_number_ [, _scale_])
----

[[fblangref50-funcs-tbl-round]]
.`ROUND` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^|Parameter
^|Description

|number
|An expression of a numeric type

|scale
a|An integer specifying the number of decimal places toward which rounding is to be performed, e.g.:

* {nbsp}2 for rounding to the nearest multiple of 0.01
* {nbsp}1 for rounding to the nearest multiple of 0.1
* {nbsp}0 for rounding to the nearest whole number
* -1 for rounding to the nearest multiple of 10
* -2 for rounding to the nearest multiple of 100
|===

Rounds a number to the nearest integer.
If the fractional part is exactly `0.5`, rounding is upward for positive numbers and downward for negative numbers.
With the optional _scale_ argument, the number can be rounded to powers-of-ten multiples (tens, hundreds, tenths, hundredths, etc.).

[IMPORTANT]
====
If you are used to the behaviour of the external function `ROUND`, please notice that the _internal_ function always rounds halves away from zero, i.e. downward for negative numbers.
====

[[fblangref50-scalarfuncs-round-exmpl]]
==== `ROUND` Examples

If the _scale_ argument is present, the result usually has the same scale as the first argument:

[source]
----
ROUND(123.654, 1) -- returns 123.700 (not 123.7)
ROUND(8341.7, -3) -- returns 8000.0 (not 8000)
ROUND(45.1212, 0) -- returns 45.0000 (not 45)
----

Otherwise, the result scale is 0:

[source]
----
ROUND(45.1212) -- returns 45
----

.See also
<<fblangref50-scalarfuncs-ceil>>, <<fblangref50-scalarfuncs-floor>>, <<fblangref50-scalarfuncs-trunc>>

[[fblangref50-scalarfuncs-sign]]
=== `SIGN()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
SIGN (_number_)
----

[[fblangref50-funcs-tbl-sign]]
.`SIGN` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the sign of the argument: -1, 0 or 1.

[[fblangref50-scalarfuncs-sin]]
=== `SIN()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SIN (_angle_)
----

[[fblangref50-funcs-tbl-sin]]
.`SIN` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|angle
|An angle, in radians
|===

Returns an angle's sine.
The argument must be given in radians. 

* Any non-`NULL` result is in the range [-1, 1].

.See also
<<fblangref50-scalarfuncs-asin>>, <<fblangref50-scalarfuncs-cos>>, <<fblangref50-scalarfuncs-cot>>, <<fblangref50-scalarfuncs-tan>>

[[fblangref50-scalarfuncs-sinh]]
=== `SINH()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SINH (_number_)
----

[[fblangref50-funcs-tbl-sinh]]
.`SINH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the hyperbolic sine of the argument.

.See also
<<fblangref50-scalarfuncs-asinh>>, <<fblangref50-scalarfuncs-cosh>>, <<fblangref50-scalarfuncs-tanh>>

[[fblangref50-scalarfuncs-sqrt]]
=== `SQRT()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
SQRT (_number_)
----

[[fblangref50-funcs-tbl-sqrt]]
.`SQRT` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the square root of the argument.

* If _number_ is negative, an error is raised.

.See also
<<fblangref50-scalarfuncs-power>>

[[fblangref50-scalarfuncs-tan]]
=== `TAN()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TAN (_angle_)
----

[[fblangref50-funcs-tbl-tan]]
.`TAN` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|angle
|An angle, in radians
|===

Returns an angle's tangent.
The argument must be given in radians.

.See also
<<fblangref50-scalarfuncs-atan>>, <<fblangref50-scalarfuncs-atan2>>, <<fblangref50-scalarfuncs-cos>>, <<fblangref50-scalarfuncs-cot>>, <<fblangref50-scalarfuncs-sin>>, <<fblangref50-scalarfuncs-tan>>

[[fblangref50-scalarfuncs-tanh]]
=== `TANH()`

.Available in
DSQL, PSQL

.Result type
`DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TANH (_number_)
----

[[fblangref50-funcs-tbl-tanh]]
.`TANH` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|An expression of a numeric type
|===

Returns the hyperbolic tangent of the argument.

* Due to rounding, any non-`NULL` result is in the range [-1, 1] (mathematically, it's ++<-1, 1>++).

.See also
<<fblangref50-scalarfuncs-atanh>>, <<fblangref50-scalarfuncs-cosh>>, <<fblangref50-scalarfuncs-tanh>>

[[fblangref50-scalarfuncs-trunc]]
=== `TRUNC()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`, (scaled) `BIGINT` or `DOUBLE PRECISION`

.Syntax
[listing,subs=+quotes]
----
TRUNC (_number_ [, _scale_])
----

[[fblangref50-funcs-tbl-trunc]]
.`TRUNC` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^|Parameter
^|Description

|number
|An expression of a numeric type

|scale
a|An integer specifying the number of decimal places toward which truncating is to be performed, e.g.:

* {nbsp}2 for truncating to the nearest multiple of 0.01
* {nbsp}1 for truncating to the nearest multiple of 0.1
* {nbsp}0 for truncating to the nearest whole number
* -1 for truncating to the nearest multiple of 10
* -2 for truncating to the nearest multiple of 100
|===

Returns the integer part of a number.
With the optional _scale_ argument, the number can be truncated to powers-of-ten multiples (tens, hundreds, tenths, hundredths, etc.).

[NOTE]
====
* If the _scale_ argument is present, the result usually has the same scale as the first argument, e.g.
** `TRUNC(789.2225, 2)` returns 789.2200 (not 789.22)
** `TRUNC(345.4, -2)` returns 300.0 (not 300)
** `TRUNC(-163.41, 0)` returns -163.00 (not -163)
* Otherwise, the result scale is 0:
** `TRUNC(-163.41)` returns -163
====

[IMPORTANT]
====
If you are used to the behaviour of the https://www.firebirdsql.org/file/documentation/reference_manuals/reference_material/html/langrefupd25-udf-truncate.html[external function `TRUNCATE`], please notice that the _internal_ function `TRUNC` always truncates toward zero, i.e. upward for negative numbers.
====

.See also
<<fblangref50-scalarfuncs-ceil>>, <<fblangref50-scalarfuncs-floor>>, <<fblangref50-scalarfuncs-round>>

[[fblangref50-functions-string]]
== String and Binary Functions

[[fblangref50-scalarfuncs-ascii-char]]
=== `ASCII_CHAR()`

.Available in
DSQL, PSQL

.Result type
`CHAR(1) CHARACTER SET NONE`

.Syntax
[listing,subs=+quotes]
----
ASCII_CHAR (_code_)
----

[[fblangref50-funcs-tbl-asciichar]]
.`ASCII_CHAR` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|code
|An integer within the range from 0 to 255
|===

Returns the ASCII character corresponding to the number passed in the argument.

[IMPORTANT]
====
* If you are used to the behaviour of the `ASCII_CHAR` UDF, which returns an empty string if the argument is 0, please notice that the internal function correctly returns a character with ASCII code 0 here.
====

.See also
<<fblangref50-scalarfuncs-ascii-val>>, <<fblangref50-scalarfuncs-unicode-char>>

[[fblangref50-scalarfuncs-ascii-val]]
=== `ASCII_VAL()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
ASCII_VAL (_ch_)
----

[[fblangref50-funcs-tbl-asciival]]
.`ASCII_VAL` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|ch
|A string of the `[VAR]CHAR` data type or a text `BLOB` with the maximum size of 32,767 bytes
|===

Returns the ASCII code of the character passed in.

* If the argument is a string with more than one character, the ASCII code of the first character is returned.
* If the argument is an empty string, 0 is returned.
* If the argument is `NULL`, `NULL` is returned.
* If the first character of the argument string is multi-byte, an error is raised.
(A bug in Firebird 2.1 - 2.1.3 and 2.5.0 causes an error to be raised if _any_ character in the string is multi-byte.
This is fixed in versions 2.1.4 and 2.5.1.)

.See also
<<fblangref50-scalarfuncs-ascii-char>>, <<fblangref50-scalarfuncs-unicode-val>>

[[fblangref50-scalarfuncs-base64decode]]
=== `BASE64_DECODE()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
BASE64_DECODE (_base64_data_)
----

[[fblangref50-scalarfuncs-tbl-base64decode]]
.`BASE64_DECODE` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|base64_data
|Base64 encoded data, padded with `=` to multiples of 4
|===

`BASE64_DECODE` decodes a string with base64-encoded data, and returns the decoded value as `VARBINARY` or `BLOB` as appropriate for the input.
If the length of the type of _base64_data_ is not a multiple of 4, an error is raised at prepare time.
If the length of the value of _base64_data_ is not a multiple of 4, an error is raised at execution time.

When the input is not `BLOB`, the length of the resulting type is calculated as `__type_length__ * 3 / 4`, where _type_length_ is the maximum length in characters of the input type.

[[fblangref50-scalarfuncs-base64decode-exmpl]]
==== Example of `BASE64_DECODE`

[source]
----
select cast(base64_decode('VGVzdCBiYXNlNjQ=') as varchar(12))
from rdb$database;

CAST
============
Test base64
----

.See also
<<fblangref50-scalarfuncs-base64encode>>, <<fblangref50-scalarfuncs-hexdecode>>

[[fblangref50-scalarfuncs-base64encode]]
=== `BASE64_ENCODE()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR CHARACTER SET ASCII` or `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`

.Syntax
[listing,subs=+quotes]
----
BASE64_ENCODE (_binary_data_)
----

[[fblangref50-scalarfuncs-tbl-base64encode]]
.`BASE64_ENCODE` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|binary_data
|Binary data (or otherwise convertible to binary) to encode
|===

`BASE64_ENCODE` encodes _binary_data_ with base64, and returns the encoded value as a `VARCHAR CHARACTER SET ASCII` or `BLOB SUB_TYPE TEXT CHARACTER SET ASCII` as appropriate for the input.
The returned value is padded with '```=```' so its length is a multiple of 4.

When the input is not `BLOB`, the length of the resulting type is calculated as `__type_length__ * 4 / 3` rounded up to a multiple of four, where _type_length_ is the maximum length in bytes of the input type.
If this length exceeds the maximum length of `VARCHAR`, the function returns a `BLOB`.

[[fblangref50-scalarfuncs-base64encode-exmpl]]
==== Example of `BASE64_ENCODE`

[source]
----
select base64_encode('Test base64')
from rdb$database;

BASE64_ENCODE
================
VGVzdCBiYXNlNjQ=
----

.See also
<<fblangref50-scalarfuncs-base64decode>>, <<fblangref50-scalarfuncs-hexencode>>

[[fblangref50-scalarfuncs-bit-length]]
=== `BIT_LENGTH()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
BIT_LENGTH (_string_)
----

[[fblangref50-funcs-tbl-bitlength]]
.`BIT_LENGTH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type
|===

Gives the length in bits of the input string.
For multi-byte character sets, this may be less than the number of characters times 8 times the "`formal`" number of bytes per character as found in `RDB$CHARACTER_SETS`.

[NOTE]
====
With arguments of type `CHAR`, this function takes the entire formal string length (i.e. the declared length of a field or variable) into account.
If you want to obtain the "`logical`" bit length, not counting the trailing spaces, right-<<fblangref50-scalarfuncs-trim,`TRIM`>> the argument before passing it to `BIT_LENGTH`.
====

.`BLOB` support
Since Firebird 2.1, this function fully supports text ``BLOB``s of any length and character set.

[[fblangref50-scalarfuncs-bit-length-exmpl]]
==== `BIT_LENGTH` Examples

[source]
----
select bit_length('Hello!') from rdb$database
-- returns 48

select bit_length(_iso8859_1 'Grüß di!') from rdb$database
-- returns 64: ü and ß take up one byte each in ISO8859_1

select bit_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- returns 80: ü and ß take up two bytes each in UTF8

select bit_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- returns 208: all 24 CHAR positions count, and two of them are 16-bit
----

.See also
<<fblangref50-scalarfuncs-octet-length>>, <<fblangref50-scalarfuncs-char-length>>

[[fblangref50-scalarfuncs-blob-append]]
=== `BLOB_APPEND()`

.Available in
DSQL, PSQL

.Result type
`BLOB`

.Syntax
[listing,subs=+quotes]
----
BLOB_APPEND(_expr1_, _expr2_ [, _exprN_ ... ])
----

[[fblangref50-scalarfuncs-tbl-blob-append]]
.`BLOB_APPEND` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|expr__N__
|An expression of a type convertible to `BLOB`
|===

The `BLOB_APPEND` function concatenates blobs without creating intermediate ``BLOB``s, avoiding excessive memory consumption and growth of the database file.
The `BLOB_APPEND` function takes two or more arguments and adds them to a `BLOB` which remains open for further modification by a subsequent `BLOB_APPEND` call.

The resulting `BLOB` is left open for writing instead of being closed when the function returns.
In other words, the `BLOB` can be appended as many times as required.
The engine marks the `BLOB` returned by `BLOB_APPEND` with an internal flag, `BLB_close_on_read`, and closes it automatically when needed.

The first argument determines the behaviour of the function:

. `NULL`: new, empty `BLOB SUB_TYPE TEXT` is created, using the connection character set as the character set
. permanent `BLOB` (from a table) or temporary `BLOB` which was already closed: new `BLOB` is created with the same subtype and, if subtype is `TEXT` the same character set, populated with the content of the original `BLOB`.
. temporary unclosed `BLOB` with the `BLB_close_on_read` flag (e.g. created by another call to `BLOB_APPEND`): used as-is, remaining arguments are appended to this `BLOB`
. other data types: a new `BLOB SUB_TYPE TEXT` is created, populated with the original argument converted to string.
If the original value is a character type, its character set is used (for string literals, the connection character set), otherwise the connection character set.

Other arguments can be of any type.
The following behavior is defined for them:

. ``NULL``s are ignored (behaves as empty string)
. ``BLOB``s, if necessary, are transliterated to the character set of the first argument and their contents are appended to the result
. other data types are converted to strings (as usual) and appended to the result

The `BLOB_APPEND` function returns a temporary unclosed `BLOB` with the `BLB_close_on_read` flag.
If the first argument is such a temporary unclosed `BLOB` (e.g. created by a previous call to `BLOB_APPEND`), it will be used as-is, otherwise a new `BLOB` is created.
Thus, a series of operations like `blob = BLOB_APPEND (blob, ...)` will result in the creation of at most one `BLOB` (unless you try to append a `BLOB` to itself).
This blob will be automatically closed by the engine when the client reads it, assigns it to a table, or uses it in other expressions that require reading the content.

.Important caveats for `BLOB_APPEND`
[WARNING]
====
. The `NULL` behaviour of `BLOB_APPEND` is different from normal concatenation (using `||`).
Occurrence of `NULL` will behave as if an empty string was used.
In other words, `NULL` is effectively ignored.
+
In normal concatenation, concatenating with `NULL` results in `NULL`.
====

[NOTE]
====
Testing a blob for `NULL` using the `IS [NOT] NULL` operator does not read it and therefore a temporary blob with the `BLB_close_on_read` flag will not be closed after such a test.
====

[TIP]
====
Use `LIST` or `BLOB_APPEND` functions to concatenate blobs.
This reduces memory consumption and disk I/O, and also prevents database growth due to the creation of many temporary blobs when using the concatenation operator.
====

[[fblangref50-scalarfuncs-blob-append-exmpl]]
==== `BLOB_APPEND` Examples

[source]
----
execute block
returns (b blob sub_type text)
as
begin
  -- creates a new temporary not closed BLOB
  -- and writes the string from the 2nd argument into it
  b = blob_append(null, 'Hello ');

  -- adds two strings to the temporary BLOB without closing it
  b = blob_append(b, 'World', '!');

  -- comparing a BLOB with a string will close it, because the BLOB needs to be read
  if (b = 'Hello World!') then
  begin
  -- ...
  end

  -- creates a temporary closed BLOB by adding a string to it
  b = b || 'Close';

  suspend;
end
----

.See also
<<fblangref50-commons-concat,Concatenation Operator>>, <<fblangref50-aggfuncs-list,`LIST()`>>

[[fblangref50-scalarfuncs-char-length]]
=== `CHAR_LENGTH()`, `CHARACTER_LENGTH()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
  CHAR_LENGTH (_string_)
| CHARACTER_LENGTH (_string_)
----

[[fblangref50-funcs-tbl-charlength]]
.`CHAR[ACTER]_LENGTH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type
|===

Gives the length in characters of the input string.

[NOTE]
====
* With arguments of type `CHAR`, this function returns the formal string length (i.e. the declared length of a field or variable).
If you want to obtain the "`logical`" length, not counting the trailing spaces, right-<<fblangref50-scalarfuncs-trim,`TRIM`>> the argument before passing it to `CHAR[ACTER]_LENGTH`.
* *``BLOB`` support*: Since Firebird 2.1, this function fully supports text ``BLOB``s of any length and character set.
====

[[fblangref50-scalarfuncs-char-length-exmpl]]
==== `CHAR_LENGTH` Examples
[source]
----
select char_length('Hello!') from rdb$database
-- returns 6

select char_length(_iso8859_1 'Grüß di!') from rdb$database
-- returns 8

select char_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- returns 8; the fact that ü and ß take up two bytes each is irrelevant

select char_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- returns 24: all 24 CHAR positions count
----

.See also
<<fblangref50-scalarfuncs-bit-length>>, <<fblangref50-scalarfuncs-octet-length>>

[[fblangref50-scalarfuncs-crypthash]]
=== `CRYPT_HASH()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
CRYPT_HASH (_value_ USING <hash>)

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref50-scalarfuncs-tbl-crypthash]]
.`CRYPT_HASH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|value
|Expression of value of any type;
non-string or non-binary types are converted to string

|hash
|Cryptographic hash algorithm to apply
|===

`CRYPT_HASH` returns a cryptographic hash calculated from the input argument using the specified algorithm.
If the input argument is not a string or binary type, it is converted to string before hashing.

This function returns a `VARBINARY` with the length depending on the specified algorithm.

[NOTE]
====
* The `MD5` and `SHA1` algorithms are not recommended for security purposes due to known attacks to generate hash collisions.
These two algorithms are provided for backward-compatibility only.

* When hashing string or binary values, take into account the effects of trailing blanks (spaces or NULs).
The value ``'ab'`` in a `CHAR(5)` (3 trailing spaces) has a different hash than if it is stored in a `VARCHAR(5)` (no trailing spaces) or `CHAR(6)` (4 trailing spaces).
+
To avoid this, make sure you always use a variable length data type, or the same fixed length data type, or normalize values before hashing, for example using <<fblangref50-scalarfuncs-trim,`TRIM(TRAILING FROM _value_)`>>.
====

[[fblangref50-scalarfuncs-crypthash-exmpl]]
==== Examples of `CRYPT_HASH`

.Hashing `x` with the SHA512 algorithm
[source]
----
select crypt_hash(x using sha512) from y;
----

.See also
<<fblangref50-scalarfuncs-hash>>

[[fblangref50-scalarfuncs-hash]]
=== `HASH()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`,`BIGINT`

.Syntax
[listing,subs=+quotes]
----
HASH (_value_ [USING <hash>])

<hash> ::= CRC32
----

[[fblangref50-funcs-tbl-hash]]
.`HASH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|value
|Expression of value of any type;
non-string or non-binary types are converted to string

|hash
|Non-cryptographic hash algorithm to apply
|===

`HASH` returns a hash value for the input argument.
If the input argument is not a string or binary type, it is converted to string before hashing.

The optional `USING` clause specifies the non-cryptographic hash algorithm to apply.
When the `USING` clause is absent, the legacy PJW algorithm is applied;
this is identical to its behaviour in previous Firebird versions.

This function fully supports text ``BLOB``s of any length and character set.

.Supported algorithms
_not specified_::
When no algorithm is specified, Firebird applies the 64-bit variant of the non-cryptographic https://en.wikipedia.org/wiki/PJW_hash_function[PJW hash function^] (also known as ELF64).
This is a fast algorithm for general purposes (hash tables, etc.), but its collision quality is suboptimal.
Other hash functions -- specified explicitly in the `USING` clause, or cryptographic hashes through <<fblangref50-scalarfuncs-crypthash>> -- should be used for more reliable hashing.
+
The `HASH` function returns `BIGINT` for this algorithm

`CRC32`::
With `CRC32`, Firebird applies the CRC32 algorithm using the polynomial 0x04C11DB7.
+
The `HASH` function returns `INTEGER` for this algorithm.

[[fblangref50-scalarfuncs-hash-exmpl]]
==== Examples of `HASH`

. Hashing `x` with the CRC32 algorithm
+
[source]
----
select hash(x using crc32) from y;
----

. Hashing `x` with the legacy PJW algorithm
+
[source]
----
select hash(x) from y;
----


.See also
<<fblangref50-scalarfuncs-crypthash>>

[[fblangref50-scalarfuncs-hexdecode]]
=== `HEX_DECODE()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
HEX_DECODE (_hex_data_)
----

[[fblangref50-scalarfuncs-tbl-hexdecode]]
.`HEX_DECODE` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|hex_data
|Hex encoded data
|===

`HEX_DECODE` decodes a string with hex-encoded data, and returns the decoded value as `VARBINARY` or `BLOB` as appropriate for the input.
If the length of the type of _hex_data_ is not a multiple of 2, an error is raised at prepare time.
If the length of the value of _hex_data_ is not a multiple of 2, an error is raised at execution time.

When the input is not `BLOB`, the length of the resulting type is calculated as `__type_length__ / 2`, where _type_length_ is the maximum length in characters of the input type.

[[fblangref50-scalarfuncs-hexdecode-exmpl]]
==== Example of `HEX_DECODE`

[source]
----
select cast(hex_decode('48657861646563696D616C') as varchar(12))
from rdb$database;

CAST
============
Hexadecimal
----

.See also
<<fblangref50-scalarfuncs-hexencode>>, <<fblangref50-scalarfuncs-base64decode>>

[[fblangref50-scalarfuncs-hexencode]]
=== `HEX_ENCODE()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR CHARACTER SET ASCII` or `BLOB SUB_TYPE TEXT CHARACTER SET ASCII`

.Syntax
[listing,subs=+quotes]
----
HEX_ENCODE (_binary_data_)
----

[[fblangref50-scalarfuncs-tbl-hexencode]]
.`HEX_ENCODE` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|binary_data
|Binary data (or otherwise convertible to binary) to encode
|===

`HEX_ENCODE` encodes _binary_data_ with hex, and returns the encoded value as a `VARCHAR CHARACTER SET ASCII` or `BLOB SUB_TYPE TEXT CHARACTER SET ASCII` as appropriate for the input.

When the input is not `BLOB`, the length of the resulting type is calculated as `__type_length__ * 2`, where _type_length_ is the maximum length in bytes of the input type.
If this length exceeds the maximum length of `VARCHAR`, the function returns a `BLOB`.

[[fblangref50-scalarfuncs-hexencode-exmpl]]
==== Example of `HEX_ENCODE`

[source]
----
select hex_encode('Hexadecimal')
from rdb$database;

HEX_ENCODE
======================
48657861646563696D616C
----

.See also
<<fblangref50-scalarfuncs-hexdecode>>, <<fblangref50-scalarfuncs-base64encode>>

[[fblangref50-scalarfuncs-left]]
=== `LEFT()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
LEFT (_string_, _length_)
----

[[fblangref50-funcs-tbl-left]]
.`LEFT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type

|length
|Integer expression.
Defines the number of characters to return
|===

Returns the leftmost part of the argument string.
The number of characters is given in the second argument. 

* This function fully supports text ``BLOB``s of any length, including those with a multi-byte character set.
* If _string_ is a `BLOB`, the result is a `BLOB`.
Otherwise, the result is a `VARCHAR(__n__)` with _n_ the length of the input string.
* If the _length_ argument exceeds the string length, the input string is returned unchanged.
* If the _length_ argument is not a whole number, bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5 becomes 2, 3.5 becomes 4, etc.

.See also
<<fblangref50-scalarfuncs-right>>

[[fblangref50-scalarfuncs-lower]]
=== `LOWER()`

.Available in
DSQL, ESQL, PSQL

.Result type
`(VAR)CHAR`, `(VAR)BINARY` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
LOWER (_string_)
----

[[fblangref50-funcs-tbl-lower]]
.`LOWER` Function ParameterS
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type
|===

Returns the lower-case equivalent of the input string.
The exact result depends on the character set.
With `ASCII` or `NONE` for instance, only ASCII characters are lowercased;
with character set `OCTETS`/`(VAR)BINARY`, the entire string is returned unchanged.
Since Firebird 2.1 this function also fully supports text ``BLOB``s of any length and character set.

[[fblangref50-scalarfuncs-lower-exmpl]]
==== `LOWER` Examples

[source]
----
select Sheriff from Towns
  where lower(Name) = 'cooper''s valley'
----

.See also
<<fblangref50-scalarfuncs-upper>>

[[fblangref50-scalarfuncs-lpad]]
=== `LPAD()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
LPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref50-funcs-tbl-lpad]]
.`LPAD` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|str
|An expression of a string type

|endlen
|Output string length

|padstr
|The character or string to be used to pad the source string up to the specified length.
Default is space ("```' '```")
|===

Left-pads a string with spaces or with a user-supplied string until a given length is reached.

* This function fully supports text ``BLOB``s of any length and character set.
* If _str_ is a `BLOB`, the result is a `BLOB`.
Otherwise, the result is a `VARCHAR(__endlen__)`.
* If _padstr_ is given and equals `''` (empty string), no padding takes place.
* If _endlen_ is less than the current string length, the string is truncated to _endlen_, even if _padstr_ is the empty string.

[NOTE]
====
In Firebird 2.1-2.1.3, all non-``BLOB`` results were of type `VARCHAR(32765)`, which made it advisable to cast them to a more modest size.
This is no longer the case.
====

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
Although it does try to limit memory consumption, this may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-lpad-exmpl]]
==== `LPAD` Examples

[source]
----
lpad ('Hello', 12)               -- returns '       Hello'
lpad ('Hello', 12, '-')          -- returns '-------Hello'
lpad ('Hello', 12, '')           -- returns 'Hello'
lpad ('Hello', 12, 'abc')        -- returns 'abcabcaHello'
lpad ('Hello', 12, 'abcdefghij') -- returns 'abcdefgHello'
lpad ('Hello', 2)                -- returns 'He'
lpad ('Hello', 2, '-')           -- returns 'He'
lpad ('Hello', 2, '')            -- returns 'He'
----

.See also
<<fblangref50-scalarfuncs-rpad>>

[[fblangref50-scalarfuncs-octet-length]]
=== `OCTET_LENGTH()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
OCTET_LENGTH (_string_)
----

[[fblangref50-funcs-tbl-octetlength]]
.`OCTET_LENGTH` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type
|===

Gives the length in bytes (octets) of the input string.
For multi-byte character sets, this may be less than the number of characters times the "`formal`" number of bytes per character as found in `RDB$CHARACTER_SETS`.

[NOTE]
====
With arguments of type `CHAR` or `BINARY`, this function takes the entire formal string length (i.e. the declared length of a field or variable) into account.
If you want to obtain the "`logical`" byte length, not counting the trailing spaces, right-<<fblangref50-scalarfuncs-trim,`TRIM`>> the argument before passing it to `OCTET_LENGTH`.
====

.`BLOB` support
Since Firebird 2.1, this function fully supports text ``BLOB``s of any length and character set.

[[fblangref50-scalarfuncs-octet-length-exmpl]]
==== `OCTET_LENGTH` Examples

[source]
----
select octet_length('Hello!') from rdb$database
-- returns 6

select octet_length(_iso8859_1 'Grüß di!') from rdb$database
-- returns 8: ü and ß take up one byte each in ISO8859_1

select octet_length
  (cast (_iso8859_1 'Grüß di!' as varchar(24) character set utf8))
from rdb$database
-- returns 10: ü and ß take up two bytes each in UTF8

select octet_length
  (cast (_iso8859_1 'Grüß di!' as char(24) character set utf8))
from rdb$database
-- returns 26: all 24 CHAR positions count, and two of them are 2-byte
----

.See also
<<fblangref50-scalarfuncs-bit-length>>, <<fblangref50-scalarfuncs-char-length>>

[[fblangref50-scalarfuncs-overlay]]
=== `OVERLAY()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
OVERLAY (_string_ PLACING _replacement_ FROM _pos_ [FOR _length_])
----

[[fblangref50-funcs-tbl-overlay]]
.`OVERLAY` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|The string into which the replacement takes place

|replacement
|Replacement string

|pos
|The position from which replacement takes place (starting position)

|length
|The number of characters that are to be overwritten
|===

`OVERLAY()` overwrites part of a string with another string.
By default, the number of characters removed from (overwritten in) the host string equals the length of the replacement string.
With the optional fourth argument, a different number of characters can be specified for removal. 

* This function supports ``BLOB``s of any length.
* If _string_ or _replacement_ is a `BLOB`, the result is a `BLOB`.
Otherwise, the result is a `VARCHAR(__n__)` with _n_ the sum of the lengths of _string_ and _replacement_.
* As usual in SQL string functions, _pos_ is 1-based.
* If _pos_ is beyond the end of _string_, _replacement_ is placed directly after _string_.
* If the number of characters from _pos_ to the end of _string_ is smaller than the length of _replacement_ (or than the _length_ argument, if present), _string_ is truncated at _pos_ and _replacement_ placed after it.
* The effect of a "```FOR 0```" clause is that _replacement_ is inserted into _string_.
* If any argument is `NULL`, the result is `NULL`.
* If _pos_ or _length_ is not a whole number, bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5 becomes 2, 3.5 becomes 4, etc.

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
This may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-overlay-exmpl]]
==== `OVERLAY` Examples

[source]
----
overlay ('Goodbye' placing 'Hello' from 2)   -- returns 'GHelloe'
overlay ('Goodbye' placing 'Hello' from 5)   -- returns 'GoodHello'
overlay ('Goodbye' placing 'Hello' from 8)   -- returns 'GoodbyeHello'
overlay ('Goodbye' placing 'Hello' from 20)  -- returns 'GoodbyeHello'

overlay ('Goodbye' placing 'Hello' from 2 for 0) -- r. 'GHellooodbye'
overlay ('Goodbye' placing 'Hello' from 2 for 3) -- r. 'GHellobye'
overlay ('Goodbye' placing 'Hello' from 2 for 6) -- r. 'GHello'
overlay ('Goodbye' placing 'Hello' from 2 for 9) -- r. 'GHello'

overlay ('Goodbye' placing '' from 4)        -- returns 'Goodbye'
overlay ('Goodbye' placing '' from 4 for 3)  -- returns 'Gooe'
overlay ('Goodbye' placing '' from 4 for 20) -- returns 'Goo'

overlay ('' placing 'Hello' from 4)          -- returns 'Hello'
overlay ('' placing 'Hello' from 4 for 0)    -- returns 'Hello'
overlay ('' placing 'Hello' from 4 for 20)   -- returns 'Hello'
----

.See also
<<fblangref50-scalarfuncs-replace>>

[[fblangref50-scalarfuncs-position]]
=== `POSITION()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
  POSITION (_substr_ IN _string_)
| POSITION (_substr_, _string_ [, _startpos_])
----

[[fblangref50-funcs-tbl-position]]
.`POSITION` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|substr
|The substring whose position is to be searched for

|string
|The string which is to be searched

|startpos
|The position in _string_ where the search is to start
|===

Returns the (1-based) position of the first occurrence of a substring in a host string.
With the optional third argument, the search starts at a given offset, disregarding any matches that may occur earlier in the string.
If no match is found, the result is 0.

[NOTE]
====
* The optional third argument is only supported in the second syntax (comma syntax).
* The empty string is considered a substring of every string.
Therefore, if _substr_ is `''` (empty string) and _string_ is not `NULL`, the result is:
+
--
** 1 if _startpos_ is not given;
** _startpos_ if _startpos_ lies within _string_;
** 0 if _startpos_ lies beyond the end of _string_.
--
+ 
**Notice:** A bug in Firebird 2.1 - 2.1.3 and 2.5.0 causes `POSITION` to _always_ return 1 if _substr_ is the empty string.
This is fixed in 2.1.4 and 2.5.1.
* This function fully supports text ``BLOB``s of any size and character set.
====

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
This may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-position-exmpl]]
==== `POSITION` Examples

[source]
----
position ('be' in 'To be or not to be')   -- returns 4
position ('be', 'To be or not to be')     -- returns 4
position ('be', 'To be or not to be', 4)  -- returns 4
position ('be', 'To be or not to be', 8)  -- returns 17
position ('be', 'To be or not to be', 18) -- returns 0
position ('be' in 'Alas, poor Yorick!')   -- returns 0
----

.See also
<<fblangref50-scalarfuncs-substring>>

[[fblangref50-scalarfuncs-replace]]
=== `REPLACE()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
REPLACE (_str_, _find_, _repl_)
----

[[fblangref50-funcs-tbl-replace]]
.`REPLACE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|str
|The string in which the replacement is to take place

|find
|The string to search for

|repl
|The replacement string
|===

Replaces all occurrences of a substring in a string.

* This function fully supports text ``BLOB``s of any length and character set.
* If any argument is a `BLOB`, the result is a `BLOB`.
Otherwise, the result is a `VARCHAR(__n__)` with _n_ calculated from the lengths of _str_, _find_ and _repl_ in such a way that even the maximum possible number of replacements won't overflow the field.
* If _find_ is the empty string, _str_ is returned unchanged.
* If _repl_ is the empty string, all occurrences of _find_ are deleted from _str_.
* If any argument is `NULL`, the result is always `NULL`, even if nothing would have been replaced.

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
This may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-replace-exmpl]]
==== `REPLACE` Examples

[source]
----
replace ('Billy Wilder',  'il', 'oog') -- returns 'Boogly Woogder'
replace ('Billy Wilder',  'il',    '') -- returns 'Bly Wder'
replace ('Billy Wilder',  null, 'oog') -- returns NULL
replace ('Billy Wilder',  'il',  null) -- returns NULL
replace ('Billy Wilder', 'xyz',  null) -- returns NULL (!)
replace ('Billy Wilder', 'xyz', 'abc') -- returns 'Billy Wilder'
replace ('Billy Wilder',    '', 'abc') -- returns 'Billy Wilder'
----

.See also
<<fblangref50-scalarfuncs-overlay>>, <<fblangref50-scalarfuncs-substring>>, <<fblangref50-scalarfuncs-position>>, <<fblangref50-scalarfuncs-char-length>>

[[fblangref50-scalarfuncs-reverse]]
=== `REVERSE()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR`

.Syntax
[listing,subs=+quotes]
----
REVERSE (_string_)
----

[[fblangref50-funcs-tbl-reverse]]
.`REVERSE` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type
|===

Returns a string backwards.

[[fblangref50-scalarfuncs-reverse-exmpl]]
==== `REVERSE` Examples
[source]
----
reverse ('spoonful')            -- returns 'lufnoops'
reverse ('Was it a cat I saw?') -- returns '?was I tac a ti saW'
----

[TIP]
====
This function is useful if you want to group, search or order on string endings, e.g. when dealing with domain names or email addresses:

[source]
----
create index ix_people_email on people
  computed by (reverse(email));

select * from people
  where reverse(email) starting with reverse('.br');
----
====

[[fblangref50-scalarfuncs-right]]
=== `RIGHT()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
RIGHT (_string_, _length_)
----

[[fblangref50-funcs-tbl-right]]
.`RIGHT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|string
|An expression of a string type

|length
|Integer.
Defines the number of characters to return
|===

Returns the rightmost part of the argument string.
The number of characters is given in the second argument. 

* This function supports text ``BLOB``s of any length, but has a bug in versions 2.1 - 2.1.3 and 2.5.0 that makes it fail with text ``BLOB``s larger than 1024 bytes that have a multi-byte character set.
This has been fixed in versions 2.1.4 and 2.5.1.
* If _string_ is a `BLOB`, the result is a `BLOB`.
Otherwise, the result is a `VARCHAR(__n__)` with _n_ the length of the input string.
* If the _length_ argument exceeds the string length, the input string is returned unchanged.
* If the _length_ argument is not a whole number, bankers' rounding (round-to-even) is applied, i.e. 0.5 becomes 0, 1.5 becomes 2, 2.5 becomes 2, 3.5 becomes 4, etc.

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
This may affect performance if huge ``BLOB``s are involved.
====

.See also
<<fblangref50-scalarfuncs-left>>, <<fblangref50-scalarfuncs-substring>>

[[fblangref50-scalarfuncs-rpad]]
=== `RPAD()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
RPAD (_str_, _endlen_ [, _padstr_])
----

[[fblangref50-funcs-tbl-rpad]]
.`RPAD` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|str
|An expression of a string type

|endlen
|Output string length

|endlen
|The character or string to be used to pad the source string up to the specified length.
Default is space (`' '`)
|===

Right-pads a string with spaces or with a user-supplied string until a given length is reached.

* This function fully supports text ``BLOB``s of any length and character set.
* If _str_ is a `BLOB`, the result is a `BLOB`.
Otherwise, the result is a `VARCHAR(_endlen_)`.
* If _padstr_ is given and equals `''` (empty string), no padding takes place.
* If _endlen_ is less than the current string length, the string is truncated to _endlen_, even if _padstr_ is the empty string.

[NOTE]
====
In Firebird 2.1-2.1.3, all non-``BLOB`` results were of type `VARCHAR(32765)`, which made it advisable to cast them to a more modest size.
This is no longer the case.
====

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
Although it does try to limit memory consumption, this may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-rpad-exmpl]]
==== `RPAD` Examples

[source]
----
rpad ('Hello', 12)               -- returns 'Hello       '
rpad ('Hello', 12, '-')          -- returns 'Hello-------'
rpad ('Hello', 12, '')           -- returns 'Hello'
rpad ('Hello', 12, 'abc')        -- returns 'Helloabcabca'
rpad ('Hello', 12, 'abcdefghij') -- returns 'Helloabcdefg'
rpad ('Hello', 2)                -- returns 'He'
rpad ('Hello', 2, '-')           -- returns 'He'
rpad ('Hello', 2, '')            -- returns 'He'
----

.See also
<<fblangref50-scalarfuncs-lpad>>

[[fblangref50-scalarfuncs-substring]]
=== `SUBSTRING()`

.Available in
DSQL, PSQL

.Result types
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
SUBSTRING ( <substring-args> )

<substring-args> ::=
    _str_ FROM _startpos_ [FOR _length_]
  | _str_ SIMILAR <similar-pattern> ESCAPE <escape>

<similar-pattern> ::=
  <similar-pattern-R1>
  <escape> " <similar-pattern-R2> <escape> "
  <similar-pattern-R3>
----

[[fblangref50-funcs-tbl-substring]]
.`SUBSTRING` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|str
|An expression of a string type

|startpos
|Integer expression, the position from which to start retrieving the substring

|length
|The number of characters to retrieve after the _startpos_

|similar-pattern
|SQL regular expression pattern to search for the substring

|escape
|Escape character
|===

Returns a string's substring starting at the given position, either to the end of the string or with a given length, or extracts a substring using an SQL regular expression pattern.

If any argument is `NULL`, the result is also `NULL`.

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
Although it does try to limit memory consumption, this may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-substring-pos]]
==== Positional `SUBSTRING`

In its simple, positional form (with `FROM`), this function returns the substring starting at character position _startpos_ (the first character being 1).
Without the `FOR` argument, it returns all the remaining characters in the string.
With `FOR`, it returns _length_ characters or the remainder of the string, whichever is shorter.

Since Firebird 4.0, _startpos_ can be smaller than 1.
When _startpos_ is smaller than 1, substring behaves as if the string has `1 - __startpos__` extra positions before the actual first character at position `1`.
The _length_ is considered from this imaginary start of the string, so the resulting string could be shorter than the specified _length_, or even empty.

The function fully supports binary and text ``BLOB``s of any length, and with any character set.
If _str_ is a `BLOB`, the result is also a `BLOB`.
For any other argument type, the result is a `VARCHAR`.

For non-``BLOB`` arguments, the width of the result field is always equal to the length of _str_, regardless of _startpos_ and _length_.
So, `substring('pinhead' from 4 for 2)` will return a `VARCHAR(7)` containing the string `'he'`.

.Example
[source]
----
insert into AbbrNames(AbbrName)
  select substring(LongName from 1 for 3) from LongNames;

select substring('abcdef' from 1 for 2) from rdb$database;
-- result: 'ab'

select substring('abcdef' from 2) from rdb$database;
-- result: 'bcdef'

select substring('abcdef' from 0 for 2) from rdb$database;
-- result: 'a'
-- and NOT 'ab', because there is "nothing" at position 0

select substring('abcdef' from -5 for 2) from rdb$database;
-- result: ''
-- length ends before the actual start of the string
----

[[fblangref50-scalarfuncs-substring-regexp]]
==== Regular Expression `SUBSTRING`

In the regular expression form (with `SIMILAR`), the `SUBSTRING` function returns part of the string matching an SQL regular expression pattern.
If no match is found, `NULL` is returned.

The `SIMILAR` pattern is formed from three SQL regular expression patterns, _R1_, _R2_ and _R3_.
The entire pattern takes the form of `R1 || '__<escape>__"' || R2 || '__<escape>__"' || R3`, where _<escape>_ is the escape character defined in the `ESCAPE` clause.
_R2_ is the pattern that matches the substring to extract, and is enclosed between escaped double quotes (`__<escape>__"`, e.g. "```++#"++```" with escape character '```++#++```').
_R1_ matches the prefix of the string, and _R3_ the suffix of the string.
Both _R1_ and _R3_ are optional (they can be empty), but the pattern must match the entire string.
In other words, it is not sufficient to specify a pattern that only finds the substring to extract.

[TIP]
====
The escaped double quotes around _R2_ can be compared to defining a single capture group in more common regular expression syntax like PCRE.
That is, the full pattern is equivalent to `__R1__(__R2__)__R3__`, which must match the entire input string, and the capture group is the substring to be returned.
====

[NOTE]
====
If any one of _R1_, _R2_, or _R3_ is not a zero-length string and does not have the format of an SQL regular expression, then an exception is raised.
====

The full SQL regular expression format is described in <<fblangref50-commons-syntaxregex,Syntax: SQL Regular Expressions>>

.Examples
[source]
----
substring('abcabc' similar 'a#"bcab#"c' escape '#')  -- bcab
substring('abcabc' similar 'a#"%#"c' escape '#')     -- bcab
substring('abcabc' similar '_#"%#"_' escape '#')     -- bcab
substring('abcabc' similar '#"(abc)*#"' escape '#')  -- abcabc
substring('abcabc' similar '#"abc#"' escape '#')     -- <null>
----

.See also
<<fblangref50-scalarfuncs-position>>, <<fblangref50-scalarfuncs-left>>, <<fblangref50-scalarfuncs-right>>, <<fblangref50-scalarfuncs-char-length>>, <<fblangref50-commons-predsimilarto,`SIMILAR TO`>>

[[fblangref50-scalarfuncs-trim]]
=== `TRIM()`

.Available in
DSQL, PSQL

.Result type
`VARCHAR` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
TRIM ([<adjust>] _str_)

<adjust> ::=  {[<where>] [_what_]} FROM

<where> ::=  BOTH | LEADING | TRAILING
----

[[fblangref50-funcs-tbl-trim]]
.`TRIM` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|str
|An expression of a string type

|where
|The position the substring is to be removed from -- `BOTH` {vbar} `LEADING` {vbar} `TRAILING`.
`BOTH` is the default

|what
|The substring that should be removed (multiple times if there are several matches) from the beginning, the end, or both sides of the input string _str_.
By default it is space (`' '`)
|===

Removes leading and/or trailing spaces (or optionally other strings) from the input string.
Since Firebird 2.1 this function fully supports text ``BLOB``s of any length and character set.

[NOTE]
====
If _str_ is a `BLOB`, the result is a `BLOB`.
Otherwise, it is a `VARCHAR(__n__)` with _n_ the formal length of _str_.
====

[WARNING]
====
When used on a `BLOB`, this function may need to load the entire object into memory.
This may affect performance if huge ``BLOB``s are involved.
====

[[fblangref50-scalarfuncs-trim-exmpl]]
==== `TRIM` Examples
[source]
----
select trim ('  Waste no space   ') from rdb$database
-- returns 'Waste no space'

select trim (leading from '  Waste no space   ') from rdb$database
-- returns 'Waste no space   '

select trim (leading '.' from '  Waste no space   ') from rdb$database
-- returns '  Waste no space   '

select trim (trailing '!' from 'Help!!!!') from rdb$database
-- returns 'Help'

select trim ('la' from 'lalala I love you Ella') from rdb$database
-- returns ' I love you El'

select trim ('la' from 'Lalala I love you Ella') from rdb$database
-- returns 'Lalala I love you El'
----

[[fblangref50-scalarfuncs-unicode-char]]
=== `UNICODE_CHAR()`

.Available in
DSQL, PSQL

.Result type
`CHAR(1) CHARACTER SET UTF8`

.Syntax
[listing,subs=+quotes]
----
UNICODE_CHAR (_code_)
----

[[fblangref50-funcs-tbl-unicode-char]]
.`UNICODE_CHAR` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|code
|The Unicode code point (range 0...0x10FFFF)
|===

Returns the character corresponding to the Unicode code point passed in the argument.

.See also
<<fblangref50-scalarfuncs-unicode-val>>, <<fblangref50-scalarfuncs-ascii-char>>

[[fblangref50-scalarfuncs-unicode-val]]
=== `UNICODE_VAL()`

.Available in
DSQL, PSQL

.Result type
`INTEGER`

.Syntax
[listing,subs=+quotes]
----
UNICODE_VAL (_ch_)
----

[[fblangref50-funcs-tbl-unicode-val]]
.`UNICODE_VAL` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|ch
|A string of the `[VAR]CHAR` data type or a text `BLOB`
|===

Returns the Unicode code point (range 0...0x10FFFF) of the character passed in.

* If the argument is a string with more than one character, the Unicode code point of the first character is returned.
* If the argument is an empty string, 0 is returned.
* If the argument is `NULL`, `NULL` is returned.

.See also
<<fblangref50-scalarfuncs-unicode-char>>, <<fblangref50-scalarfuncs-ascii-val>>

[[fblangref50-scalarfuncs-upper]]
=== `UPPER()`

.Available in
DSQL, ESQL, PSQL

.Result type
`(VAR)CHAR`, `(VAR)BINARY` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
UPPER (_str_)
----

[[fblangref50-funcs-tbl-upper]]
.`UPPER` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|str
|An expression of a string type
|===

Returns the upper-case equivalent of the input string.
The exact result depends on the character set.
With `ASCII` or `NONE` for instance, only ASCII characters are uppercased;
with character set `OCTETS`/`(VAR)BINARY`, the entire string is returned unchanged.
Since Firebird 2.1 this function also fully supports text ``BLOB``s of any length and character set.

[[fblangref50-scalarfuncs-upper-exmpl]]
==== `UPPER` Examples

[source]
----
select upper(_iso8859_1 'Débâcle')
from rdb$database
-- returns 'DÉBÂCLE' (before Firebird 2.0: 'DéBâCLE')

select upper(_iso8859_1 'Débâcle' collate fr_fr)
from rdb$database
-- returns 'DEBACLE', following French uppercasing rules
----

.See also
<<fblangref50-scalarfuncs-lower>>

[[fblangref50-functions-datetime]]
== Date and Time Functions

[[fblangref50-scalarfuncs-dateadd]]
=== `DATEADD()`

.Available in
DSQL, PSQL

.Result type
`DATE`, `TIME` or `TIMESTAMP`

.Syntax
[listing,subs=+quotes]
----
DATEADD (<args>)

<args> ::=
    <amount> <unit> TO <datetime>
  | <unit>, <amount>, <datetime>

<amount> ::= _an integer expression (negative to subtract)_
<unit> ::=
    YEAR | MONTH | WEEK | DAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<datetime> ::= _a DATE, TIME or TIMESTAMP expression_
----

[[fblangref50-funcs-tbl-dateadd]]
.`DATEADD` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|amount
|An integer expression of the `SMALLINT`, `INTEGER` or `BIGINT` type.
For unit `MILLISECOND`, the type is `NUMERIC(18, 1)`.
A negative value is subtracted.

|unit
|Date/time unit

|datetime
|An expression of the `DATE`, `TIME` or `TIMESTAMP` type
|===

Adds the specified number of years, months, weeks, days, hours, minutes, seconds or milliseconds to a date/time value.

* The result type is determined by the third argument.
* With `TIMESTAMP` and `DATE` arguments, all units can be used.
* With `TIME` arguments, only `HOUR`, `MINUTE`, `SECOND` and `MILLISECOND` can be used.

[[fblangref50-funcs-tbl-dateadd-exmpl]]
==== Examples of `DATEADD`

[source]
----
dateadd (28 day to current_date)
dateadd (-6 hour to current_time)
dateadd (month, 9, DateOfConception)
dateadd (-38 week to DateOfBirth)
dateadd (minute, 90, cast('now' as time))
dateadd (? year to date '11-Sep-1973')
----

[source]
----
select
  cast(dateadd(-1 * extract(millisecond from ts) millisecond to ts) as varchar(30)) as t,
  extract(millisecond from ts) as ms
from (
  select timestamp '2014-06-09 13:50:17.4971' as ts
  from rdb$database
) a
----

[listing]
----
T                        MS
------------------------ ------
2014-06-09 13:50:17.0000  497.1
----

.See also
<<fblangref50-scalarfuncs-datediff>>, <<fblangref50-datatypes-datetimeops,Operations Using Date and Time Values>>

[[fblangref50-scalarfuncs-datediff]]
=== `DATEDIFF()`

.Available in
DSQL, PSQL

.Result type
`BIGINT`, or `NUMERIC(18,1)` for `MILLISECOND`

.Syntax
[listing,subs=+quotes]
----
DATEDIFF (<args>)

<args> ::=
    <unit> FROM <moment1> TO <moment2>
  | <unit>, <moment1>, <moment2>

<unit> ::=
    YEAR | MONTH | WEEK | DAY
  | HOUR | MINUTE | SECOND | MILLISECOND
<momentN> ::= _a DATE, TIME or TIMESTAMP expression_
----

[[fblangref50-funcs-tbl-datediff]]
.`DATEDIFF` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|unit
|Date/time unit

|moment1
|An expression of the `DATE`, `TIME` or `TIMESTAMP` type

|moment2
|An expression of the `DATE`, `TIME` or `TIMESTAMP` type
|===

Returns the number of years, months, weeks, days, hours, minutes, seconds or milliseconds elapsed between two date/time values.
(The `WEEK` unit is new in 2.5.) 

* `DATE` and `TIMESTAMP` arguments can be combined.
No other mixes are allowed.
* With `TIMESTAMP` and `DATE` arguments, all units can be used.
(Prior to Firebird 2.5, units smaller than `DAY` were disallowed for ``DATE``s.)
* With `TIME` arguments, only `HOUR`, `MINUTE`, `SECOND` and `MILLISECOND` can be used.

.Computation
* `DATEDIFF` doesn't look at any smaller units than the one specified in the first argument.
As a result,
** `datediff (year, date '1-Jan-2009', date '31-Dec-2009')` returns 0, but
** `datediff (year, date '31-Dec-2009', date '1-Jan-2010')` returns 1
* It does, however, look at all the _bigger_ units. So:
** `datediff (day, date '26-Jun-1908', date '11-Sep-1973')` returns 23818
* A negative result value indicates that _moment2_ lies before _moment1_.

[[fblangref50-scalarfuncs-datediff-exmpl]]
==== `DATEDIFF` Examples

[source]
----
datediff (hour from current_timestamp to timestamp '12-Jun-2059 06:00')
datediff (minute from time '0:00' to current_time)
datediff (month, current_date, date '1-1-1900')
datediff (day from current_date to cast(? as date))
----

.See also
<<fblangref50-scalarfuncs-dateadd>>, <<fblangref50-datatypes-datetimeops,Operations Using Date and Time Values>>

[[fblangref50-scalarfuncs-extract]]
=== `EXTRACT()`

.Available in
DSQL, ESQL, PSQL

.Result type
`SMALLINT` or `NUMERIC`

.Syntax
[listing,subs=+quotes]
----
EXTRACT (<part> FROM <datetime>)

<part> ::=
    YEAR | MONTH | WEEK
  | DAY | WEEKDAY | YEARDAY
  | HOUR | MINUTE | SECOND | MILLISECOND
  | TIMEZONE_HOUR | TIMEZONE_MINUTE
<datetime> ::= _a DATE, TIME or TIMESTAMP expression_
----

[[fblangref50-funcs-tbl-extract]]
.`EXTRACT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|part
|Date/time unit

|datetime
|An expression of the `DATE`, `TIME` or `TIMESTAMP` type
|===

Extracts and returns an element from a `DATE`, `TIME` or `TIMESTAMP` expression.

[[fblangref50-scalarfuncs-extract-types]]
==== Returned Data Types and Ranges

The returned data types and possible ranges are shown in the table below.
If you try to extract a part that isn't present in the date/time argument (e.g. `SECOND` from a `DATE` or `YEAR` from a `TIME`), an error occurs.

[[fblangref50-tbl-extractranges]]
.Types and ranges of `EXTRACT` results
[cols="<1m,<1m,<1,<2", options="header"]
|===
| Part
| Type
| Range
| Comment

|YEAR
|SMALLINT
|1-9999
|{nbsp}

|MONTH
|SMALLINT
|1-12
|{nbsp}

|WEEK
|SMALLINT
|1-53
|{nbsp}

|DAY
|SMALLINT
|1-31
|{nbsp}

|WEEKDAY
|SMALLINT
|0-6
|0 = Sunday

|YEARDAY
|SMALLINT
|0-365
|0 = January 1

|HOUR
|SMALLINT
|0-23
|{nbsp}

|MINUTE
|SMALLINT
|0-59
|{nbsp}

|SECOND
|NUMERIC(9,4)
|0.0000-59.9999
|includes millisecond as fraction

|MILLISECOND
|NUMERIC(9,1)
|0.0-999.9
|broken in 2.1, 2.1.1

|TIMEZONE_HOUR
|SMALLINT
|-23 - {plus}23
|{nbsp}

|TIMEZONE_MINUTE
|SMALLINT
|-59 - {plus}59
|{nbsp}
|===

[[fblangref50-scalarfuncs-extract-millisecond]]
===== `MILLISECOND`

Firebird 2.1 and up support extraction of the millisecond from a `TIME` or `TIMESTAMP`.
The data type returned is `NUMERIC(9,1)`.

[NOTE]
====
If you extract the millisecond from <<fblangref50-contextvars-current-time>>, be aware that this variable defaults to seconds precision, so the result will always be 0.
Extract from `CURRENT_TIME(3)` or <<fblangref50-contextvars-current-timestamp>> to get milliseconds precision.
====

[[fblangref50-scalarfuncs-extract-week]]
===== `WEEK`

Firebird 2.1 and up support extraction of the ISO-8601 week number from a `DATE` or `TIMESTAMP`.
ISO-8601 weeks start on a Monday and always have the full seven days.
Week 1 is the first week that has a majority (at least 4) of its days in the new year.
The first 1-3 days of the year may belong to the last week (52 or 53) of the previous year.
Likewise, a year's final 1-3 days may belong to week 1 of the following year.

[CAUTION]
====
Be careful when combining `WEEK` and `YEAR` results.
For instance, 30 December 2008 lies in week 1 of 2009, so `extract(week from date '30 Dec 2008')` returns 1.
However, extracting `YEAR` always gives the calendar year, which is 2008.
In this case, `WEEK` and `YEAR` are at odds with each other.
The same happens when the first days of January belong to the last week of the previous year.

Please also notice that `WEEKDAY` is _not_ ISO-8601 compliant: it returns 0 for Sunday, whereas ISO-8601 specifies 7.
====

.See also
<<fblangref50-datatypes-datetime,Data Types for Dates and Times>>

[[fblangref50-scalarfuncs-firstday]]
=== `FIRST_DAY()`

.Available in
DSQL, PSQL

.Result Type
`DATE`, `TIMESTAMP` (with or without time zone)

.Syntax
[listing,subs=+quotes]
----
FIRST_DAY(OF <period> FROM _date_or_timestamp_)

<period> ::= YEAR | MONTH | WEEK
----

[[fblangref50-scalarfuncs-tbl-firstday]]
.`FIRST_DAY` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|date_or_timestamp
|Expression of type `DATE`, `TIMESTAMP WITHOUT TIME ZONE` or `TIMESTAMP WITH TIME ZONE`
|===

`FIRST_DAY` returns a date or timestamp (same as the type of _date_or_timestamp_) with the first day of the year, month or week of a given date or timestamp value.

[NOTE]
====
* The first day of the week is considered as Sunday, following the same rules as for <<fblangref50-scalarfuncs-extract>> with `WEEKDAY`.
* When a timestamp is passed, the return value preserves the time part.
====

[[fblangref50-scalarfuncs-firstday-exmpl]]
==== Examples of `FIRST_DAY`

[source]
----
select first_day(of month from current_date) from rdb$database;
select first_day(of year from current_timestamp) from rdb$database;
select first_day(of week from date '2017-11-01') from rdb$database;
----

[[fblangref50-scalarfuncs-lastday]]
=== `LAST_DAY()`

.Available in
DSQL, PSQL

.Result Type
`DATE`, `TIMESTAMP` (with or without time zone)

.Syntax
[listing,subs=+quotes]
----
LAST_DAY(OF <period> FROM _date_or_timestamp_)

<period> ::= YEAR | MONTH | WEEK
----

[[fblangref50-scalarfuncs-tbl-lastday]]
.`LAST_DAY` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|date_or_timestamp
|Expression of type `DATE`, `TIMESTAMP WITHOUT TIME ZONE` or `TIMESTAMP WITH TIME ZONE`
|===

`LAST_DAY` returns a date or timestamp (same as the type of _date_or_timestamp_) with the last day of the year, month or week of a given date or timestamp value.

[NOTE]
====
* The last day of the week is considered as Saturday, following the same rules as for <<fblangref50-scalarfuncs-extract>> with `WEEKDAY`.
* When a timestamp is passed, the return value preserves the time part.
====

[[fblangref50-scalarfuncs-lastday-lastday]]
==== Examples of `LAST_DAY`

[source]
----
select last_day(of month from current_date) from rdb$database;
select last_day(of year from current_timestamp) from rdb$database;
select last_day(of week from date '2017-11-01') from rdb$database;
----

[[fblangref50-functions-casting]]
== Type Casting Functions

[[fblangref50-scalarfuncs-cast]]
=== `CAST()`

.Available in
DSQL, ESQL, PSQL

.Result type
As specified by _target_type_

.Syntax
[listing,subs="+quotes,macros"]
----
CAST (<expression> AS <target_type>)

<target_type> ::= <domain_or_non_array_type> | <array_datatype>

<domain_or_non_array_type> ::=
  !! See <<fblangref50-datatypes-syntax-scalar-syntax,Scalar Data Types Syntax>> !!

<array_datatype> ::=
  !! See <<fblangref50-datatypes-syntax-array,Array Data Types Syntax>> !!
----

[[fblangref50-funcs-tbl-cast]]
.`CAST` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|expression
|SQL expression

|sql_datatype
|SQL data type
|===

`CAST` converts an expression to the desired data type or domain.
If the conversion is not possible, an error is raised.

.Casting ``BLOB``s
Successful casting to and from ``BLOB``s is possible since Firebird 2.1.

[[fblangref50-scalarfuncs-shortcast]]
==== "`Shorthand`" Syntax

Alternative syntax, supported only when casting a string literal to a `DATE`, `TIME` or `TIMESTAMP`:

[source]
----
datatype 'date/timestring'
----

This syntax was already available in InterBase, but was never properly documented.
In the SQL standard, this feature is called "`datetime literals`".

[NOTE]
====
Since Firebird 4.0, the use of `'NOW'`, `'YESTERDAY'` and `'TOMORROW'` in the shorthand cast is no longer allowed;
only literals defining a fixed moment in time are supported.
====

[[fblangref50-scalarfuncs-cast-conv]]
==== Allowed Type Conversions

The following table shows the type conversions possible with `CAST`.

[[fblangref50-tbl-cast]]
.Possible Type-castings with `CAST`
[%autowidth,cols="2*", options="header", stripes="none"]
|===
| From
| To

|Numeric types
|Numeric types +
`[VAR]CHAR` +
`BLOB`

|`[VAR]CHAR` +
`BLOB`
| `[VAR]CHAR` +
`BLOB` +
Numeric types +
`DATE` +
`TIME` +
`TIMESTAMP`

|`DATE` +
`TIME`
|`[VAR]CHAR` +
`BLOB` +
`TIMESTAMP`

|`TIMESTAMP`
|`[VAR]CHAR` +
`BLOB` +
`DATE` +
`TIME`
|===

Keep in mind that sometimes information is lost, for instance when you cast a `TIMESTAMP` to a `DATE`.
Also, the fact that types are ``CAST``-compatible is in itself no guarantee that a conversion will succeed.
"```CAST(123456789 as SMALLINT)```" will definitely result in an error, as will "```CAST('Judgement Day' as DATE)```".

[[fblangref50-scalarfuncs-cast-params]]
==== Casting Parameters

Since Firebird 2.0, you can cast statement parameters to a data type:

[source]
----
cast (? as integer)
----

This gives you control over the type of the parameter set up by the engine.
Please notice that with statement parameters, you always need a full-syntax cast -- shorthand casts are not supported.

[[fblangref50-scalarfuncs-cast-domain]]
==== Casting to a Domain or its Type

Firebird 2.1 and above support casting to a domain or its base type.
When casting to a domain, any constraints (`NOT NULL` and/or `CHECK`) declared for the domain must be satisfied, or the cast will fail.
Please be aware that a `CHECK` passes if it evaluates to `TRUE` _or_ `NULL`!
So, given the following statements:

[source]
----
create domain quint as int check (value >= 5000);
select cast (2000 as quint) from rdb$database;     -- <1>
select cast (8000 as quint) from rdb$database;     -- <2>
select cast (null as quint) from rdb$database;     -- <3>
----

only cast number _1_ will result in an error.

When the `TYPE OF` modifier is used, the expression is cast to the base type of the domain, ignoring any constraints.
With domain `quint` defined as above, the following two casts are equivalent and will both succeed:

[source]
----
select cast (2000 as type of quint) from rdb$database;
select cast (2000 as int) from rdb$database;
----

If `TYPE OF` is used with a `(VAR)CHAR` type, its character set and collation are retained:

[source]
----
create domain iso20 varchar(20) character set iso8859_1;
create domain dunl20 varchar(20) character set iso8859_1 collate du_nl;
create table zinnen (zin varchar(20));
commit;
insert into zinnen values ('Deze');
insert into zinnen values ('Die');
insert into zinnen values ('die');
insert into zinnen values ('deze');

select cast(zin as type of iso20) from zinnen order by 1;
-- returns Deze -> Die -> deze -> die

select cast(zin as type of dunl20) from zinnen order by 1;
-- returns deze -> Deze -> die -> Die
----

[WARNING]
====
If a domain's definition is changed, existing ``CAST``s to that domain or its type may become invalid.
If these ``CAST``s occur in PSQL modules, their invalidation may be detected.
See the note <<fblangref50-appx01-supp-rdb-validblr,[ref]_The RDB$VALID_BLR field_>>, in Appendix A.
====

[[fblangref50-scalarfuncs-cast-coltype]]
==== Casting to a Column's Type

In Firebird 2.5 and above, it is possible to cast expressions to the type of an existing table or view column.
Only the type itself is used;
in the case of string types, this includes the character set but not the collation.
Constraints and default values of the source column are not applied.

[source]
----
create table ttt (
  s varchar(40) character set utf8 collate unicode_ci_ai
);
commit;

select cast ('Jag har många vänner' as type of column ttt.s)
from rdb$database;
----

.Warnings
[WARNING]
====
If a column's definition is altered, existing ``CAST``s to that column's type may become invalid.
If these ``CAST``s occur in PSQL modules, their invalidation may be detected.
See the note <<fblangref50-appx01-supp-rdb-validblr,[ref]_The RDB$VALID_BLR field_>>, in Appendix A.
====

[[fblangref50-scalarfuncs-cast-exmpl]]
==== Cast Examples

A full-syntax cast:

[source]
----
select cast ('12' || '-June-' || '1959' as date) from rdb$database
----

A shorthand string-to-date cast:

[source]
----
update People set AgeCat = 'Old'
  where BirthDate < date '1-Jan-1943'
----

Notice that you can drop even the shorthand cast from the example above, as the engine will understand from the context (comparison to a `DATE` field) how to interpret the string:

[source]
----
update People set AgeCat = 'Old'
  where BirthDate < '1-Jan-1943'
----

However, this is not always possible.
The cast below cannot be dropped, otherwise the engine would find itself with an integer to be subtracted from a string:

[source]
----
select cast('today' as date) - 7 from rdb$database
----

[[fblangref50-functions-bitwise]]
== Bitwise Functions

[[fblangref50-scalarfuncs-bin-and]]
=== `BIN_AND()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`, `INTEGER` or `BIGINT`

[NOTE]
====
`SMALLINT` result is returned only if all the arguments are explicit ``SMALLINT``s or `NUMERIC(__n__, 0)` with _n_ +<=+ 4;
otherwise small integers return an `INTEGER` result.
====

.Syntax
[listing,subs=+quotes]
----
BIN_AND (_number_, _number_ [, _number_ ...])
----

[[fblangref50-funcs-tbl-binand]]
.`BIN_AND` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any integer number (literal, smallint/integer/bigint, numeric/decimal with scale 0)
|===

Returns the result of the bitwise _AND_ operation on the argument(s).

.See also
<<fblangref50-scalarfuncs-bin-or>>, <<fblangref50-scalarfuncs-bin-xor>>

[[fblangref50-scalarfuncs-bin-not]]
=== `BIN_NOT()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`, `INTEGER` or `BIGINT`

[NOTE]
====
`SMALLINT` result is returned only if all the arguments are explicit ``SMALLINT``s or `NUMERIC(__n__, 0)` with _n_ +<=+ 4;
otherwise small integers return an `INTEGER` result.
====

.Syntax
[listing,subs=+quotes]
----
BIN_NOT (_number_)
----

[[fblangref50-funcs-tbl-binnot]]
.`BIN_NOT` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any integer number (literal, smallint/integer/bigint, numeric/decimal with scale 0)
|===

Returns the result of the bitwise _NOT_ operation on the argument, i.e. _one's complement_.

.See also
<<fblangref50-scalarfuncs-bin-or>>, <<fblangref50-scalarfuncs-bin-xor>> and others in this set.

[[fblangref50-scalarfuncs-bin-or]]
=== `BIN_OR()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`, `INTEGER` or `BIGINT`

[NOTE]
====
`SMALLINT` result is returned only if all the arguments are explicit ``SMALLINT``s or `NUMERIC(__n__, 0)` with _n_ +<=+ 4;
otherwise small integers return an `INTEGER` result.
====

.Syntax
[listing,subs=+quotes]
----
BIN_OR (_number_, _number_ [, _number_ ...])
----

[[fblangref50-funcs-tbl-binor]]
.`BIN_OR` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any integer number (literal, smallint/integer/bigint, numeric/decimal with scale 0)
|===

Returns the result of the bitwise _OR_ operation on the argument(s).

.See also
<<fblangref50-scalarfuncs-bin-and>>, <<fblangref50-scalarfuncs-bin-xor>>

[[fblangref50-scalarfuncs-bin-shl]]
=== `BIN_SHL()`

.Available in
DSQL, PSQL

.Result type
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
BIN_SHL (_number_, _shift_)
----

[[fblangref50-funcs-tbl-binshl]]
.`BIN_SHL` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|A number of an integer type

|shift
|The number of bits the number value is shifted by
|===

Returns the first argument bitwise left-shifted by the second argument, i.e. `a << b` or `a·2^b^`.

.See also
<<fblangref50-scalarfuncs-bin-shr>>

[[fblangref50-scalarfuncs-bin-shr]]
=== `BIN_SHR()`

.Available in
DSQL, PSQL

.Result type
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
BIN_SHR (_number_, _shift_)
----

[[fblangref50-funcs-tbl-binshr]]
.`BIN_SHR` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|A number of an integer type

|shift
|The number of bits the number value is shifted by
|===

Returns the first argument bitwise right-shifted by the second argument, i.e. `a >> b` or `a/2^b^`.

* The operation performed is an arithmetic right shift (SAR), meaning that the sign of the first operand is always preserved.

.See also
<<fblangref50-scalarfuncs-bin-shl>>

[[fblangref50-scalarfuncs-bin-xor]]
=== `BIN_XOR()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`, `INTEGER` or `BIGINT`

[NOTE]
====
`SMALLINT` result is returned only if all the arguments are explicit ``SMALLINT``s or `NUMERIC(__n__, 0)` with _n_ +<=+ 4;
otherwise small integers return an `INTEGER` result.
====

.Syntax
[listing,subs=+quotes]
----
BIN_XOR (_number_, _number_ [, _number_ ...])
----

[[fblangref50-funcs-tbl-binxor]]
.`BIN_XOR` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|number
|Any integer number (literal, smallint/integer/bigint, numeric/decimal with scale 0)
|===

Returns the result of the bitwise _XOR_ operation on the argument(s).

.See also
<<fblangref50-scalarfuncs-bin-and>>, <<fblangref50-scalarfuncs-bin-or>>

[[fblangref50-functions-uuid]]
== UUID Functions

[[fblangref50-scalarfuncs-char-to-uuid]]
=== `CHAR_TO_UUID()`

.Available in
DSQL, PSQL

.Result type
`BINARY(16)`

.Syntax
[listing,subs=+quotes]
----
CHAR_TO_UUID (_ascii_uuid_)
----

[[fblangref50-funcs-tbl-char-to-uuid]]
.`CHAR_TO_UUID` Function Parameter
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|ascii_uuid
|A 36-character representation of UUID.
'```-```' (hyphen) in positions 9, 14, 19 and 24;
valid hexadecimal digits in any other positions, e.g. 'A0bF4E45-3029-2a44-D493-4998c9b439A3'
|===

Converts a human-readable 36-char UUID string to the corresponding 16-byte UUID.

[[fblangref50-scalarfuncs-char-to-uuid-exmpl]]
==== `CHAR_TO_UUID` Examples

[source]
----
select char_to_uuid('A0bF4E45-3029-2a44-D493-4998c9b439A3') from rdb$database
-- returns A0BF4E4530292A44D4934998C9B439A3 (16-byte string)

select char_to_uuid('A0bF4E45-3029-2A44-X493-4998c9b439A3') from rdb$database
-- error: -Human readable UUID argument for CHAR_TO_UUID must
--         have hex digit at position 20 instead of "X (ASCII 88)"
----

.See also
<<fblangref50-scalarfuncs-uuid-to-char>>, <<fblangref50-scalarfuncs-gen-uuid>>

[[fblangref50-scalarfuncs-gen-uuid]]
=== `GEN_UUID()`

.Available in
DSQL, PSQL

.Result type
`BINARY(16)`

.Syntax
[listing]
----
GEN_UUID ()
----

Returns a universally unique ID as a 16-byte character string.

[[fblangref50-scalarfuncs-gen-uuid-exmpl]]
==== `GEN_UUID` Example

[source]
----
select gen_uuid() from rdb$database
-- returns e.g. 017347BFE212B2479C00FA4323B36320 (16-byte string)
----

.See also
<<fblangref50-scalarfuncs-uuid-to-char>>, <<fblangref50-scalarfuncs-char-to-uuid>>

[[fblangref50-scalarfuncs-uuid-to-char]]
=== `UUID_TO_CHAR()`

.Available in
DSQL, PSQL

.Result type
`CHAR(36)`

.Syntax
[listing,subs=+quotes]
----
UUID_TO_CHAR (_uuid_)
----

[[fblangref50-funcs-tbl-uuid-to-char]]
.`UUID_TO_CHAR` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|uuid
|16-byte UUID
|===

Converts a 16-byte UUID to its 36-character, human-readable ASCII representation.

[[fblangref50-scalarfuncs-uuid-to-char-exmpl]]
==== `UUID_TO_CHAR` Examples

[source]
----
select uuid_to_char(x'876C45F4569B320DBCB4735AC3509E5F') from rdb$database
-- returns '876C45F4-569B-320D-BCB4-735AC3509E5F'

select uuid_to_char(gen_uuid()) from rdb$database
-- returns e.g. '680D946B-45FF-DB4E-B103-BB5711529B86'

select uuid_to_char('Firebird swings!') from rdb$database
-- returns '46697265-6269-7264-2073-77696E677321'
----

.See also
<<fblangref50-scalarfuncs-char-to-uuid>>, <<fblangref50-scalarfuncs-gen-uuid>>

[[fblangref50-functions-generators]]
== Functions for Sequences (Generators)

[[fblangref50-scalarfuncs-gen-id]]
=== `GEN_ID()`

.Available in
DSQL, ESQL, PSQL

.Result type
`BIGINT` -- dialect 2 and 3 +
`INTEGER` -- dialect 1

.Syntax
[listing,subs=+quotes]
----
GEN_ID (_generator-name_, _step_)
----

[[fblangref50-funcs-tbl-gen-id]]
.`GEN_ID` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|generator-name
|Name of a generator (sequence) that exists.
If it has been defined in double quotes with a case-sensitive identifier, it must be used in the same form unless the name is all upper-case.

|step
|An integer expression
|===

Increments a generator or sequence and returns its new value.
If step equals 0, the function will leave the value of the generator unchanged and return its current value.
 
* From Firebird 2.0 onward, the SQL-compliant <<fblangref50-commons-nxtvlufor,`NEXT VALUE FOR`>> syntax is preferred, except when an increment other than 1 is needed.

[WARNING]
====
If the value of the step parameter is less than zero, it will decrease the value of the generator.
Attention! You should be cautious with such manipulations in the database, as they could compromise data integrity.
====

[NOTE]
====
In dialect 1, the result type is `INTEGER`, in dialect 2 and 3 it is `BIGINT`.
====

[[fblangref50-scalarfuncs-gen-id-exmpl]]
==== `GEN_ID` Example

[source]
----
new.rec_id = gen_id(gen_recnum, 1);
----

.See also
<<fblangref50-commons-nxtvlufor,`NEXT VALUE FOR`>>, <<fblangref50-ddl-sequence-create,`CREATE SEQUENCE (GENERATOR)`>>

[[fblangref50-functions-conditional]]
== Conditional Functions

[[fblangref50-scalarfuncs-coalesce]]
=== `COALESCE()`

.Available in
DSQL, PSQL

.Result type
Depends on input

.Syntax
[listing]
----
COALESCE (<exp1>, <exp2> [, <expN> ... ])
----

[[fblangref50-funcs-tbl-coalesce]]
.`COALESCE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exp1, exp2 ... expN
|A list of expressions of any compatible types
|===

The `COALESCE` function takes two or more arguments and returns the value of the first non-``NULL`` argument.
If all the arguments evaluate to `NULL`, the result is `NULL`.

[[fblangref50-scalarfuncs-coalesce-exmpl]]
==== `COALESCE` Examples

This example picks the `Nickname` from the `Persons` table.
If it happens to be `NULL`, it goes on to `FirstName`.
If that too is `NULL`, "```'Mr./Mrs.'```" is used.
Finally, it adds the family name.
All in all, it tries to use the available data to compose a full name that is as informal as possible.
This scheme only works if absent nicknames and first names are `NULL`: if one of them is an empty string, `COALESCE` will happily return that to the caller.

[source]
----
select
  coalesce (Nickname, FirstName, 'Mr./Mrs.') || ' ' || LastName
    as FullName
from Persons
----

.See also
<<fblangref50-scalarfuncs-iif>>, <<fblangref50-scalarfuncs-nullif>>, <<fblangref50-commons-conditional-case,`CASE`>>

[[fblangref50-scalarfuncs-decode]]
=== `DECODE()`

.Available in
DSQL, PSQL

.Result type
Depends on input

.Syntax
[listing]
----
DECODE(<testexpr>,
  <expr1>, <result1>
  [<expr2>, <result2> ...]
  [, <defaultresult>])
----

The equivalent `CASE` construct:

[listing]
----
CASE <testexpr>
  WHEN <expr1> THEN <result1>
  [WHEN <expr2> THEN <result2> ...]
  [ELSE <defaultresult>]
END
----

[[fblangref50-funcs-tbl-decode]]
.`DECODE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|testexpr
|An expression of any compatible type that is compared to the expressions expr1, expr2 ... exprN

|expr1, expr2, ... exprN
|Expressions of any compatible types, to which the _testexpr_ expression is compared

|result1, result2, ... resultN
|Returned values of any type

|defaultresult
|The expression to be returned if none of the conditions is met
|===

`DECODE` is a shorthand for the so-called <<fblangref50-commons-conditional-case-simple,"`simple ``CASE```" construct>>, in which a given expression is compared to a number of other expressions until a match is found.
The result is determined by the value listed after the matching expression.
If no match is found, the default result is returned, if present.
Otherwise, `NULL` is returned.

[CAUTION]
====
Matching is done with the '```=```' operator, so if _testexpr_ is `NULL`, it won't match any of the __expr__s, not even those that are `NULL`.
====

[[fblangref50-scalarfuncs-decode-exmpl]]
==== `DECODE` Examples

[source]
----
select name,
  age,
  decode(upper(sex),
         'M', 'Male',
         'F', 'Female',
         'Unknown'),
  religion
from people
----

.See also
<<fblangref50-commons-conditional-case,`CASE`>>, <<fblangref50-commons-conditional-case-simple,Simple `CASE`>>

[[fblangref50-scalarfuncs-iif]]
=== `IIF()`

.Available in
DSQL, PSQL

.Result type
Depends on input

.Syntax
[listing,subs=+quotes]
----
IIF (<condition>, _ResultT_, _ResultF_)
----

[[fblangref50-funcs-tbl-iif]]
.`IIF` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|condition
|A true{vbar}false expression

|resultT
|The value returned if the condition is true

|resultF
|The value returned if the condition is false
|===

`IIF` takes three arguments.
If the first evaluates to `true`, the second argument is returned;
otherwise the third is returned.

`IIF` could be likened to the ternary "```?:```" operator in C-like languages.

[NOTE]
====
`IIF(<Cond>, __Result1__, __Result2__)` is a shorthand for "```CASE WHEN <Cond> THEN __Result1__ ELSE __Result2__ END```".
====

[[fblangref50-scalarfuncs-iif-exmpl]]
==== `IIF` Examples

[source]
----
select iif( sex = 'M', 'Sir', 'Madam' ) from Customers
----

.See also
<<fblangref50-commons-conditional-case,`CASE`>>, <<fblangref50-scalarfuncs-decode>>

[[fblangref50-scalarfuncs-maxvalue]]
=== `MAXVALUE()`

.Available in
DSQL, PSQL

.Result type
Varies according to input -- result will be of the same data type as the first expression in the list (_expr1_).

.Syntax
[listing]
----
MAXVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref50-funcs-tbl-maxvalue]]
.`MAXVALUE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|expr1 ... exprN
|List of expressions of compatible types
|===

Returns the maximum value from a list of numerical, string, or date/time expressions.
This function fully supports text ``BLOB``s of any length and character set. 

If one or more expressions resolve to `NULL`, `MAXVALUE` returns `NULL`.
This behaviour differs from the aggregate function `MAX`.

[[fblangref50-scalarfuncs-maxvalue-exmpl]]
==== `MAXVALUE` Examples

[source]
----
SELECT MAXVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
----

.See also
<<fblangref50-scalarfuncs-minvalue>>

[[fblangref50-scalarfuncs-minvalue]]
=== `MINVALUE()`

.Available in
DSQL, PSQL

.Result type
Varies according to input -- result will be of the same data type as the first expression in the list (_expr1_).

.Syntax
[listing]
----
MINVALUE (<expr1> [, ... , <exprN> ])
----

[[fblangref50-funcs-tbl-minvalue]]
.`MINVALUE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|expr1 ... exprN
|List of expressions of compatible types
|===

Returns the minimum value from a list of numerical, string, or date/time expressions.
This function fully supports text ``BLOB``s of any length and character set. 

If one or more expressions resolve to `NULL`, `MINVALUE` returns `NULL`.
This behaviour differs from the aggregate function `MIN`.

[[fblangref50-scalarfuncs-minvalue-exmpl]]
==== `MINVALUE` Examples

[source]
----
SELECT MINVALUE(PRICE_1, PRICE_2) AS PRICE
  FROM PRICELIST
----

.See also
<<fblangref50-scalarfuncs-maxvalue>>

[[fblangref50-scalarfuncs-nullif]]
=== `NULLIF()`

.Available in
DSQL, PSQL

.Result type
Depends on input

.Syntax
[listing]
----
NULLIF (<exp1>, <exp2>)
----

[[fblangref50-funcs-tbl-nullif]]
.`NULLIF` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|exp1
|An expression

|exp2
|Another expression of a data type compatible with _exp1_
|===

`NULLIF` returns the value of the first argument, unless it is equal to the second.
In that case, `NULL` is returned.


[[fblangref50-scalarfuncs-nullif-exmpl]]
==== `NULLIF` Example

[source]
----
select avg( nullif(Weight, -1) ) from FatPeople
----

This will return the average weight of the persons listed in FatPeople, excluding those having a weight of -1, since `AVG` skips `NULL` data.
Presumably, -1 indicates "`weight unknown`" in this table.
A plain `AVG(Weight)` would include the -1 weights, thus skewing the result.

.See also
<<fblangref50-scalarfuncs-coalesce>>, <<fblangref50-scalarfuncs-decode>>, <<fblangref50-scalarfuncs-iif>>, <<fblangref50-commons-conditional-case,`CASE`>>

[[fblangref50-scalarfuncs-decfloat]]
== Special Functions for `DECFLOAT`

[[fblangref50-scalarfuncs-comparedecfloat]]
=== `COMPARE_DECFLOAT()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`

.Syntax
[listings,subs=+quotes]
----
COMPARE_DECFLOAT (_decfloat1_, _decfloat2_)
----

[[fblangref50-scalarfuncs-tbl-comparedecfloat]]
.`COMPARE_DECFLOAT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|decfloat__n__
|Value or expression of type `DECFLOAT`, or cast-compatible with `DECFLOAT`
|===

`COMPARE_DECFLOAT` compares two `DECFLOAT` values to be equal, different or unordered.
The result is a `SMALLINT` value, as follows:

[horizontal]
`0`:: Values are equal
`1`:: First value is less than second
`2`:: First value is greater than second
`3`:: Values are unordered, i.e. one or both is `NaN`/`sNaN`

Unlike the comparison operators ('```<```', '```=```', '```>```', etc.), comparison is exact: `COMPARE_DECFLOAT(2.17, 2.170)` returns `2` not `0`.

.See also
<<fblangref50-scalarfuncs-totalorder>>

[[fblangref50-scalarfuncs-normalizedecfloat]]
=== `NORMALIZE_DECFLOAT()`

.Available in
DSQL, PSQL

.Result type
`DECFLOAT`

.Syntax
[listing,subs=+quotes]
----
NORMALIZE_DECFLOAT (_decfloat_value_)
----

[[fblangref50-scalarfuncs-tbl-normalizedecfloat]]
.`NORMALIZE_DECFLOAT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|decfloat_value
|Value or expression of type `DECFLOAT`, or cast-compatible with `DECFLOAT`
|===

`NORMALIZE_DECFLOAT` takes a single `DECFLOAT` argument and returns it in its simplest form.
That means that for any non-zero value, trailing zeroes are removed with appropriate correction of the exponent.

[[fblangref50-scalarfuncs-normalizedecfloat-exmpl]]
==== Examples of `NORMALIZE_DECFLOAT`

[source]
----
-- will return 12
select normalize_decfloat(12.00)
from rdb$database;

-- will return 1.2E+2
select normalize_decfloat(120)
from rdb$database;
----

[[fblangref50-scalarfuncs-quantize]]
=== `QUANTIZE()`

.Available in
DSQL, PSQL

.Result type

.Syntax
[listing,subs=+quotes]
----
QUANTIZE (_decfloat_value_, _exp_value_)
----

[[fblangref50-scalarfuncs-tbl-quantize]]
.`QUANTIZE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|decfloat_value
|Value or expression to quantize;
needs to be of type `DECFLOAT`, or cast-compatible with `DECFLOAT`

|exp_value
|Value or expression to use for its exponent;
needs to be of type `DECFLOAT`, or cast-compatible with `DECFLOAT`
|===

`QUANTIZE` returns a `DECFLOAT` value that is equal in value and sign (except for rounding) to _decfloat_value_, and that has an exponent equal to the exponent of _exp_value_.
The type of the return value is `DECFLOAT(16)` if both arguments are `DECFLOAT(16)`, otherwise the result type is `DECFLOAT(34)`.

[NOTE]
====
The target exponent is the exponent used in the `Decimal64` or `Decimal128` storage format of `DECFLOAT` of _exp_value_.
This is not necessarily the same as the exponent displayed in tools like _isql_.
For example, the value `1.23E+2` is coefficient `123` and exponent `0`, while `1.2` is coefficient `12` and exponent `-1`.
====

If the exponent of _decfloat_value_ is greater than the one of _exp_value_, the coefficient of _decfloat_value_ is multiplied by a power of ten, and its exponent decreased, if the exponent is smaller, then its coefficient is rounded using the current decfloat rounding mode, and its exponent is increased.

When it is not possible to achieve the target exponent because the coefficient would exceed the target precision (16 or 34 decimal digits), either a "`__Decfloat float invalid operation__`" error is raised or `NaN` is returned (depending on the current decfloat traps configuration).

There are almost no restrictions on the _exp_value_.
However, in almost all usages, `NaN`/`sNaN`/`Infinity` will produce an exception (unless allowed by the current decfloat traps configuration), `NULL` will make the function return `NULL`, and so on.

[[fblangref50-scalarfuncs-quantize-exmpl]]
==== Examples of `QUANTIZE`

[source]
----
select v, pic, quantize(v, pic) from examples;

     V    PIC QUANTIZE
====== ====== ========
  3.16  0.001    3.160
  3.16   0.01     3.16
  3.16    0.1      3.2
  3.16      1        3
  3.16   1E+1     0E+1
  -0.1      1       -0
     0   1E+5     0E+5
   316    0.1    316.0
   316      1      316
   316   1E+1   3.2E+2
   316   1E+2     3E+2
----

[[fblangref50-scalarfuncs-totalorder]]
=== `TOTALORDER()`

.Available in
DSQL, PSQL

.Result type
`SMALLINT`

.Syntax
[listing,subs=+quotes]
----
TOTALORDER (_decfloat1_, _decfloat2_)
----

[[fblangref50-scalarfuncs-tbl-totalorder]]
.`TOTALORDER` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|decfloat__n__
|Value or expression of type `DECFLOAT`, or cast-compatible with `DECFLOAT`
|===

`TOTALORDER` compares two `DECFLOAT` values including any special values.
The comparison is exact, and returns a `SMALLINT`, one of:

[horizontal]
`-1`:: First value is less than second
`0`:: Values are equal
`1`:: First value is greater than second.

For `TOTALORDER` comparisons, `DECFLOAT` values are ordered as follows:

[listing]
----
-NaN < -sNaN < -INF < -0.1 < -0.10 < -0 < 0 < 0.10 < 0.1 < INF < sNaN < NaN
----

.See also
<<fblangref50-scalarfuncs-comparedecfloat>>

[[fblangref50-scalarfuncs-crypto]]
== Cryptographic Functions

[[fblangref50-scalarfuncs-decrypt]]
=== `DECRYPT()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY` or `BLOB`

.Syntax
[listing,subs=+quotes]
----
DECRYPT ( _encrypted_input_
  USING <algorithm> [MODE <mode>]
  KEY _key_
  [IV _iv_] [<ctr_type>] [CTR_LENGTH _ctr_length_]
  [COUNTER _initial_counter_] )

!! See syntax of <<fblangref50-scalarfuncs-encrypt,`ENCRYPT`>> for further rules !!
----

[[fblangref50-scalarfuncs-tbl-decrypt]]
.`DECRYPT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|encrypted_input
|Encrypted input as a blob or (binary) string

2+| See <<fblangref50-scalarfuncs-tbl-encrypt>> for other parameters
|===

`DECRYPT` decrypts data using a symmetric cipher.

[NOTE]
====
* Sizes of data strings (like _encrypted_input_, _key_ and _iv_) must meet the requirements of the selected algorithm and mode.
* This function returns `BLOB SUB_TYPE BINARY` when the first argument is a `BLOB`, and `VARBINARY` for all other text and binary types.
* When the encrypted data was text, it must be explicitly cast to a string type of appropriate character set.
* The ins and outs of the various algorithms are considered beyond the scope of this language reference.
We recommend searching the internet for further details on the algorithms.
====

[[fblangref50-scalarfuncs-decrypt-exmpl]]
==== `DECRYPT` Examples

[source]
----
select decrypt(x'0154090759DF' using sober128 key 'AbcdAbcdAbcdAbcd' iv '01234567')
  from rdb$database;
select decrypt(secret_field using aes mode ofb key '0123456701234567' iv init_vector)
  from secure_table;
----

.See also
<<fblangref50-scalarfuncs-encrypt>>, <<fblangref50-scalarfuncs-rsadecrypt>>

[[fblangref50-scalarfuncs-encrypt]]
=== `ENCRYPT()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY` or `BLOB`

.Syntax
[listing,subs="+quotes,macros"]
----
ENCRYPT ( _input_
  USING <algorithm> [MODE <mode>]
  KEY _key_
  [IV _iv_] [<ctr_type>] [CTR_LENGTH _ctr_length_]
  [COUNTER _initial_counter_] )

<algorithm> ::= <block_cipher> | <stream_cipher>

<block_cipher> ::=
    AES | ANUBIS | BLOWFISH | KHAZAD | RC5
  | RC6 | SAFER+ | TWOFISH | XTEA

<stream_cipher> ::= CHACHA20 | RC4 | SOBER128

<mode> ::= CBC | CFB | CTR | ECB | OFB

<ctr_type> ::= CTR_BIG_ENDIAN | CTR_LITTLE_ENDIAN
----

[[fblangref50-scalarfuncs-tbl-encrypt]]
.`ENCRYPT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|input
|Input to encrypt as a blob or (binary) string

|algorithm
|The algorithm to use for decryption

|mode
|The algorithm mode;
only for block ciphers

|key
|The encryption/decryption key

|iv
|Initialization vector or nonce;
should be specified for block ciphers in all modes except `ECB`, and all stream ciphers except `RC4`

|ctr_type
|Endianness of the counter;
only for `CTR` mode.
Default is `CTR_LITTLE_ENDIAN`.

|ctr_length
|Counter length;
only for `CTR` mode.
Default is size of _iv_.

|initial_counter
|Initial counter value;
only for `CHACHA20`.
Default is `0`.
|===

`ENCRYPT` can encrypt data using a symmetric cipher.

[NOTE]
====
* This function returns `BLOB SUB_TYPE BINARY` when the first argument is a `BLOB`, and `VARBINARY` for all other text and binary types.
* Sizes of data strings (like _key_ and _iv_) must meet the requirements of the selected algorithm and mode, see table <<fblangref50-scalarfuncs-tbl-encrypt-req>>.
** In general, the size of _iv_ must match the block size of the algorithm
** For ECB and CBC mode, _input_ must be multiples of the block size, you will need to manually pad with zeroes or spaces as appropriate.
* The ins and outs of the various algorithms and modes are considered beyond the scope of this language reference.
We recommend searching the internet for further details on the algorithms.
* Although specified as separate options in this Language Reference, in the actual syntax `CTR_LENGTH` and `COUNTER` are aliases.
====

[[fblangref50-scalarfuncs-tbl-encrypt-req]]
.Encryption Algorithm Requirements
[cols="<1m,<3,<3,<5",options="header",stripes="none"]
|===
|Algorithm
|Key size (bytes)
|Block size (bytes)
|Notes

4+h|Block Ciphers

|AES
|16, 24, 32
|16
|{nbsp}

|ANUBIS
|16 - 40, in steps of 4
|16
|{nbsp}

|BLOWFISH
|8 - 56
|8
|{nbsp}

|KHAZAD
|16
|8
|{nbsp}

|RC5
|8 - 128
|8
|{nbsp}

|RC6
|8 - 128
|16
|{nbsp}

|SAFER+
|16, 24, 32
|16
|{nbsp}

|TWOFISH
|16, 24, 32
|16
|{nbsp}

|XTEA
|16
|8
|{nbsp}

4+h|Stream Ciphers

|CHACHA20
|16, 32
|1
|Nonce size (IV) is 8 or 12 bytes.
For nonce size 8, _initial_counter_ is a 64-bit integer, for size 12, 32-bit.

|RC4
|5 - 256
|1
|{nbsp}

|SOBER128
|4__x__
|1
|Nonce size (IV) is 4__y__ bytes, the length is independent of key size.
|===

[[fblangref50-scalarfuncs-encrypt-exmpl]]
==== `ENCRYPT` Examples

[source]
----
select encrypt('897897' using sober128 key 'AbcdAbcdAbcdAbcd' iv '01234567')
  from rdb$database;
----

.See also
<<fblangref50-scalarfuncs-decrypt>>, <<fblangref50-scalarfuncs-rsaencrypt>>

[[fblangref50-scalarfuncs-rsadecrypt]]
=== `RSA_DECRYPT()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_DECRYPT (_encrypted_input_ KEY _private_key_
  [LPARAM _tag_string_] [HASH <hash>] [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref50-scalarfuncs-tbl-rsadecrypt]]
.`RSA_DECRYPT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|encrypted_input
|Input data to decrypt

|private_key
|Private key to apply, PKCS#1 format

|tag_string
|An additional system-specific tag to identify which system encrypted the message;
default is `NULL`.
If the tag does not match what was used during encryption, `RSA_DECRYPT` will not decrypt the data.

|hash
|The hash used for OAEP padding;
default is `SHA256`.
|===

`RSA_DECRYPT` decrypts _encrypted_input_ using the RSA private key and then OAEP de-pads the resulting data.

By default, OAEP padding is used.
The `PKCS_1_5` option will switch to the less secure PKCS 1.5 padding.

[WARNING]
====
The `PKCS_1_5` option is only for backward compatibility with systems applying PKCS 1.5 padding.
For security reasons, it should *not* be used in new projects.
====

[NOTE]
====
* This function returns VARBINARY`.
* When the encrypted data was text, it must be explicitly cast to a string type of appropriate character set.
====

[[fblangref50-scalarfuncs-rsadecrypt-exmpl]]
==== `RSA_DECRYPT` Examples

[TIP]
====
Run the examples of the <<fblangref50-scalarfuncs-rsaprivate-exmpl,`RSA_PRIVATE`>> and <<fblangref50-scalarfuncs-rsapublic-exmpl,`RSA_PUBLIC`>>, <<fblangref50-scalarfuncs-rsaencrypt-exmpl,`RSA_ENCRYPT`>> functions first.
====

[source]
----
select cast(rsa_decrypt(rdb$get_context('USER_SESSION', 'msg')
  key rdb$get_context('USER_SESSION', 'private_key')) as varchar(128))
from rdb$database;
----

.See also
<<fblangref50-scalarfuncs-rsaencrypt>>, <<fblangref50-scalarfuncs-rsaprivate>>, <<fblangref50-scalarfuncs-decrypt>>

[[fblangref50-scalarfuncs-rsaencrypt]]
=== `RSA_ENCRYPT()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_ENCRYPT (_input_ KEY _public_key_
  [LPARAM _tag_string_] [HASH <hash>] [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref50-scalarfuncs-tbl-rsaencrypt]]
.`RSA_ENCRYPT` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|input
|Input data to encrypt

|public_key
|Public key to apply, PKCS#1 format

|tag_string
|An additional system-specific tag to identify which system encrypted the message;
default is `NULL`.

|hash
|The hash used for OAEP padding;
default is `SHA256`.
|===

`RSA_ENCRYPT` pads _input_ using the https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding[OAEP padding scheme^] and then encrypts it using the specified RSA public key.
This function is normally used to encrypt short symmetric keys which are then used in block ciphers to encrypt a message.

By default, OAEP padding is used.
The `PKCS_1_5` option will switch to the less secure PKCS 1.5 padding.

[WARNING]
====
The `PKCS_1_5` option is only for backward compatibility with systems applying PKCS 1.5 padding.
For security reasons, it should *not* be used in new projects.
====

[[fblangref50-scalarfuncs-rsaencrypt-exmpl]]
==== `RSA_ENCRYPT` Examples

[TIP]
====
Run the examples of the <<fblangref50-scalarfuncs-rsaprivate-exmpl,`RSA_PRIVATE`>> and <<fblangref50-scalarfuncs-rsapublic-exmpl,`RSA_PUBLIC`>> functions first.
====

[source]
----
select rdb$set_context('USER_SESSION', 'msg', rsa_encrypt('Some message'
  key rdb$get_context('USER_SESSION', 'public_key'))) from rdb$database;
----

.See also
<<fblangref50-scalarfuncs-rsadecrypt>>, <<fblangref50-scalarfuncs-rsapublic>>, <<fblangref50-scalarfuncs-encrypt>>

[[fblangref50-scalarfuncs-rsaprivate]]
=== `RSA_PRIVATE()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_PRIVATE (_key_length_)
----

[[fblangref50-scalarfuncs-tbl-rsaprivate]]
.`RSA_PRIVATE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|key_length
|Key length in bytes;
minimum 4, maximum 1024.
A size of 256 bytes (2048 bits) or larger is recommended.
|===

`RSA_PRIVATE` generates an RSA private key of the specified length (in bytes) in PKCS#1 format.

[NOTE]
====
The larger the length specified, the longer it takes for the function to generate a private key.
====

[[fblangref50-scalarfuncs-rsaprivate-exmpl]]
==== `RSA_PRIVATE` Examples

[source]
----
select rdb$set_context('USER_SESSION', 'private_key', rsa_private(256))
  from rdb$database;
----

[WARNING]
====
Putting private keys in the context variables is not secure.
SYSDBA and users with the role `RDB$ADMIN` or the system privilege `MONITOR_ANY_ATTACHMENT` can see all context variables from all attachments.
====

.See also
<<fblangref50-scalarfuncs-rsapublic>>, <<fblangref50-scalarfuncs-rsadecrypt>>

[[fblangref50-scalarfuncs-rsapublic]]
=== `RSA_PUBLIC()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_PUBLIC (_private_key_)
----

[[fblangref50-scalarfuncs-tbl-rsapublic]]
.`RSA_PUBLIC` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|private_key
|RSA private key in PKCS#1 format
|===

`RSA_PUBLIC` returns the RSA public key in PKCS#1 format for the provided RSA private key (also PKCS#1 format).

[[fblangref50-scalarfuncs-rsapublic-exmpl]]
==== `RSA_PUBLIC` Examples

[TIP]
====
Run the example of the <<fblangref50-scalarfuncs-rsaprivate-exmpl,`RSA_PRIVATE`>> function first.
====

[source]
----
select rdb$set_context('USER_SESSION', 'public_key',
  rsa_public(rdb$get_context('USER_SESSION', 'private_key'))) from rdb$database;
----

.See also
<<fblangref50-scalarfuncs-rsaprivate>>, <<fblangref50-scalarfuncs-rsaencrypt>>

[[fblangref50-scalarfuncs-rsasignhash]]
=== `RSA_SIGN_HASH()`

.Available in
DSQL, PSQL

.Result type
`VARBINARY`

.Syntax
[listing,subs=+quotes]
----
RSA_SIGN_HASH (_message_digest_
  KEY _private_key_
  [HASH <hash>] [SALT_LENGTH _salt_length_]
  [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref50-scalarfuncs-tbl-rsasign]]
.`RSA_SIGN_HASH` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|message_digest
|Hash of message to sign.
The hash algorithm used should match _hash_

|private_key
|RSA private key in PKCS#1 format

|hash
|Hash to generate PSS encoding;
default is `SHA256`.
This should be the same hash as used to generate _message_digest_.

|salt_length
|Length of the desired salt in bytes;
default is 8;
minimum 1, maximum 32.
The recommended value is between 8 and 16.
|===

`RSA_SIGN_HASH` performs PSS encoding of the _message_digest_ to be signed, and signs using the RSA private key.

By default, OAEP padding is used.
The `PKCS_1_5` option will switch to the less secure PKCS 1.5 padding.

[WARNING]
====
The `PKCS_1_5` option is only for backward compatibility with systems applying PKCS 1.5 padding.
For security reasons, it should *not* be used in new projects.
====

[CAUTION]
====
This function expects the hash of a message (or message digest), not the actual message.
The _hash_ argument should specify the algorithm that was also used to generate that hash.

A function that accepts the actual message to hash might be introduced in a future version of Firebird.
====

.PSS encoding
****
Probabilistic Signature Scheme (PSS) is a cryptographic signature scheme specifically developed to allow modern methods of security analysis to prove that its security directly relates to that of the RSA problem.
There is no such proof for the traditional PKCS#1 v1.5 scheme.
****

[[fblangref50-scalarfuncs-rsasignhash-exmpl]]
==== `RSA_SIGN_HASH` Examples

[TIP]
====
Run the example of the <<fblangref50-scalarfuncs-rsaprivate-exmpl,`RSA_PRIVATE`>> function first.
====

[source]
----
select rdb$set_context('USER_SESSION', 'msg',
  rsa_sign_hash(crypt_hash('Test message' using sha256)
    key rdb$get_context('USER_SESSION', 'private_key'))) from rdb$database;
----

.See also
<<fblangref50-scalarfuncs-rsaverifyhash>>, <<fblangref50-scalarfuncs-rsaprivate>>, <<fblangref50-scalarfuncs-crypthash>>

[[fblangref50-scalarfuncs-rsaverifyhash]]
=== `RSA_VERIFY_HASH()`

.Available in
DSQL, PSQL

.Result type
`BOOLEAN`

.Syntax
[listing,subs=+quotes]
----
RSA_VERIFY_HASH (_message_digest_
  SIGNATURE _signature_ KEY _public_key_
  [HASH <hash>] [SALT_LENGTH _salt_length_]
  [PKCS_1_5])

<hash> ::= MD5 | SHA1 | SHA256 | SHA512
----

[[fblangref50-scalarfuncs-tbl-rsaverify]]
.`RSA_VERIFY` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|message_digest
|Hash of message to verify.
The hash algorithm used should match _hash_

|signature
|Expected signature of _input_ generated by `RSA_SIGN_HASH`

|public_key
|RSA public key in PKCS#1 format matching the private key used to sign

|hash
|Hash to use for the message digest;
default is `SHA256`.
This should be the same hash as used to generate _message_digest_, and as used in `RSA_SIGN_HASH`

|salt_length
|Length of the salt in bytes;
default is 8;
minimum 1, maximum 32.
Value must match the length used in `RSA_SIGN_HASH`.
|===

`RSA_VERIFY_HASH` performs PSS encoding of the _message_digest_ to be verified, and verifies the digital signature using the provided RSA public key.

By default, OAEP padding is used.
The `PKCS_1_5` option will switch to the less secure PKCS 1.5 padding.

[WARNING]
====
The `PKCS_1_5` option is only for backward compatibility with systems applying PKCS 1.5 padding.
For security reasons, it should *not* be used in new projects.
====

[CAUTION]
====
This function expects the hash of a message (or message digest), not the actual message.
The _hash_ argument should specify the algorithm that was also used to generate that hash.

A function that accepts the actual message to hash might be introduced in a future version of Firebird.
====

[[fblangref50-scalarfuncs-rsaverifyhash-exmpl]]
==== `RSA_VERIFY_HASH` Examples

[TIP]
====
Run the examples of the <<fblangref50-scalarfuncs-rsaprivate-exmpl,`RSA_PRIVATE`>>, <<fblangref50-scalarfuncs-rsapublic-exmpl,`RSA_PUBLIC`>> and <<fblangref50-scalarfuncs-rsasignhash-exmpl,`RSA_SIGN_HASH`>> functions first.
====

[source]
----
select rsa_verify_hash(
  crypt_hash('Test message' using sha256)
  signature rdb$get_context('USER_SESSION', 'msg')
  key rdb$get_context('USER_SESSION', 'public_key'))
from rdb$database
----

.See also
<<fblangref50-scalarfuncs-rsasignhash>>, <<fblangref50-scalarfuncs-rsapublic>>, <<fblangref50-scalarfuncs-crypthash>>

[[fblangref50-scalarfuncs-other]]
== Other Functions

Functions that don't fit in any other category.

[[fblangref50-scalarfuncs-makedbkey]]
=== `MAKE_DBKEY()`

.Available in
DSQL, PSQL

.Result type
`BINARY(8)`

.Syntax
[listing,subs=+quotes]
----
MAKE_DBKEY (_relation_, _recnum_ [, _dpnum_ [, _ppnum_]])
----

[[fblangref50-scalarfuncs-tbl-makedbkey]]
.`RDB$GET_TRANSACTION_CN` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|relation
|Relation name or relation id

|recnum
|Record number.
Either absolute (if _dpnum_ and _ppnum_ are absent), or relative (if _dpnum_ present)

|dpnum
|Data page number.
Either absolute (if _ppnum_ is absent) or relative (if _ppnum_ present)

|ppnum
|Pointer page number.
|===

`MAKE_DBKEY` creates a DBKEY value using a relation name or ID, record number, and (optionally) logical numbers of data page and pointer page.

[NOTE]
====
. If _relation_ is a string expression or literal, then it is treated as a relation name, and the engine searches for the corresponding relation ID.
The search is case-sensitive.
In the case of string literal, relation ID is evaluated at query preparation time.
In the case of expression, relation ID is evaluated at execution time.
If the relation cannot be found, then error `isc_relnotdef` is raised.
. If _relation_ is a numeric expression or literal, then it is treated as a relation ID and used "`as is`", without verification against existing relations.
If the argument value is negative or greater than the maximum allowed relation ID (65535 currently), then `NULL` is returned.
. Argument _recnum_ represents an absolute record number in the relation (if the next arguments _dpnum_ and _ppnum_ are missing), or a record number relative to the first record, specified by the next arguments.
. Argument _dpnum_ is a logical number of data page in the relation (if the next argument _ppnum_ is missing), or number of data pages relative to the first data page addressed by the given _ppnum_.
. Argument _ppnum_ is a logical number of pointer page in the relation.
. All numbers are zero-based.
Maximum allowed value for _dpnum_ and _ppnum_ is 2^32^ (4294967296).
If _dpnum_ is specified, then _recnum_ can be negative.
If _dpnum_ is missing and _recnum_ is negative, then `NULL` is returned.
If _ppnum_ is specified, then _dpnum_ can be negative.
If _ppnum_ is missing and _dpnum_ is negative, then `NULL` is returned.
. If any of specified arguments is `NULL`, the result is also `NULL`.
. Argument _relation_ is described as `INTEGER` during query preparation, but it can be overridden by a client application as `VARCHAR` or `CHAR`.
Arguments _recnum_, _dpnum_ and _ppnum_ are described as `BIGINT`.
====

[[fblangref50-scalarfuncs-makedbkey-exmpl]]
==== Examples of `MAKE_DBKEY`

. Select record using relation name (note that relation name is uppercase)
+
[source]
----
select *
from rdb$relations
where rdb$db_key = make_dbkey('RDB$RELATIONS', 0)
----

. Select record using relation ID
+
[source]
----
select *
from rdb$relations
where rdb$db_key = make_dbkey(6, 0)
----

. Select all records physically residing on the first data page
+
[source]
----
select *
from rdb$relations
where rdb$db_key >= make_dbkey(6, 0, 0)
and rdb$db_key < make_dbkey(6, 0, 1)
----

. Select all records physically residing on the first data page of 6th pointer page
+
[source]
----
select *
from SOMETABLE
where rdb$db_key >= make_dbkey('SOMETABLE', 0, 0, 5)
and rdb$db_key < make_dbkey('SOMETABLE', 0, 1, 5)
----

[[fblangref50-scalarfuncs-rdberror]]
=== `RDB$ERROR()`

.Available in
PSQL

.Result type
Varies (see table below)

.Syntax
[listing]
----
RDB$ERROR (<context>)

<context> ::=
  GDSCODE | SQLCODE | SQLSTATE | EXCEPTION | MESSAGE
----

[[fblangref50-scalarfuncs-rdberror-contexts]]
.Contexts
[cols="1m,1m,3", options="header", frame="none", stripes="none", grid="rows"]
|===
| Context
| Result type
| Description

|GDSCODE
|INTEGER
|Firebird error code, see also <<fblangref50-contextvars-gdscode,`GDSCODE`>>

|SQLCODE
|INTEGER
|(deprecated) SQL code, see also <<fblangref50-contextvars-sqlcode,`SQLCODE`>>

|SQLSTATE
|CHAR(5) CHARACTER SET ASCII
|SQLstate, see also <<fblangref50-contextvars-sqlstate,`SQLSTATE`>>

|EXCEPTION
|VARCHAR(63) CHARACTER SET UTF8
|Name of the active user-defined exception or `NULL` if the active exception is a system exception

|MESSAGE
|VARCHAR(1024) CHARACTER SET UTF8
|Message text of the active exception
|===

`RDB$ERROR` returns data of the specified context about the active PSQL exception.
Its scope is confined to exception-handling blocks in PSQL (<<fblangref50-psql-when,`WHEN ... DO`>>).
Outside the exception handling blocks, `RDB$ERROR` always returns `NULL`.
This function cannot be called from DSQL.

[[fblangref50-scalarfuncs-rdberror-exmpl]]
==== Example of RDB$ERROR

[source]
----
BEGIN
  ...
WHEN ANY DO
  EXECUTE PROCEDURE P_LOG_EXCEPTION(RDB$ERROR(MESSAGE));
END
----

.See also
<<fblangref50-psql-handleexceptions,Trapping and Handling Errors>>, <<fblangref50-contextvars-gdscode,`GDSCODE`>>, <<fblangref50-contextvars-sqlcode,`SQLCODE`>>, <<fblangref50-contextvars-sqlstate,`SQLSTATE`>>

[[fblangref50-scalarfuncs-gettransactioncn]]
=== `RDB$GET_TRANSACTION_CN()`

.Available in
DSQL, PSQL

.Result type
`BIGINT`

.Syntax
[listing,subs=+quotes]
----
RDB$GET_TRANSACTION_CN (_transaction_id_)
----

[[fblangref50-scalarfuncs-tbl-gettransactioncn]]
.`RDB$GET_TRANSACTION_CN` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|transaction_id
|Transaction id
|===

`RDB$GET_TRANSACTION_CN` returns the commit number ("`CN`") of the supplied transaction.

If the return value is greater than 1, it is the actual _CN_ of the transaction if it was committed after the database was started.

The function can also return one of the following results, indicating the commit status of the transaction:

[horizontal]
`-2`:: Transaction is dead (rolled back)
`-1`:: Transaction is in limbo
`{nbsp}0`:: Transaction is still active
`{nbsp}1`:: Transaction committed before the database started or less than the Oldest Interesting Transaction for the database
`NULL`:: Transaction number supplied is NULL or greater than Next Transaction for the database

[NOTE]
====
For more information about _CN_, consult the https://www.firebirdsql.org/file/documentation/release_notes/html/en/4_0/rlsnotes40.html[_Firebird 4.0 Release Notes_].
====

[[fblangref50-scalarfuncs-gettransactioncn-exmpl]]
==== `RDB$GET_TRANSACTION_CN` Examples

[source]
----
select rdb$get_transaction_cn(current_transaction) from rdb$database;
select rdb$get_transaction_cn(123) from rdb$database;
----

[[fblangref50-scalarfuncs-roleinuse]]
=== `RDB$ROLE_IN_USE()`

.Available in
DSQL, PSQL

.Result type
`BOOLEAN`

.Syntax
[listing,subs=+quotes]
----
RDB$ROLE_IN_USE (_role_name_)
----

[[fblangref50-scalarfuncs-tbl-roleinuse]]
.`RDB$ROLE_IN_USE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|role_name
|String expression for the role to check.
Case-sensitive, must match the role name as stored in `RDB$ROLES`
|===

`RDB$ROLE_IN_USE` returns TRUE if the specified role is active for the current connection, and FALSE otherwise.
Contrary to <<fblangref50-contextvars-current-role,`CURRENT_ROLE`>> --  which only returns the explicitly specified role -- this function can be used to check for roles that are active by default, or cumulative roles activated by an explicitly specified role.

[[fblangref50-scalarfuncs-roleinuse-exmpl]]
==== `RDB$ROLE_IN_USE` Examples

.List currently active roles
[source]
----
select rdb$role_name
from rdb$database
where rdb$role_in_use(rdb$role_name);
----

.See also
<<fblangref50-contextvars-current-role,`CURRENT_ROLE`>>

[[fblangref50-scalarfuncs-syspriv]]
=== `RDB$SYSTEM_PRIVILEGE()`

.Available in
DSQL, PSQL

.Result type
`BOOLEAN`

.Syntax
[listing,subs="+quotes,macros"]
----
RDB$SYSTEM_PRIVILEGE (<sys_privilege>)

<sys_privilege> ::=
  !! See <<fblangref50-security-role-create,`CREATE ROLE`>> !!
----

[[fblangref50-scalarfuncs-tbl-syspriv]]
.`RDB$SYSTEM_PRIVILEGE` Function Parameters
[cols="<1,<3", options="header",stripes="none"]
|===
^| Parameter
^| Description

|sys_privilege
|System privilege
|===

`RDB$SYSTEM_PRIVILEGE` accepts a system privilege name and returns TRUE if the current attachment has the given system privilege, and FALSE otherwise.

[[fblangref50-scalarfuncs-syspriv-exmpl]]
==== `RDB$SYSTEM_PRIVILEGE` Examples

[source]
----
select rdb$system_privilege(user_management) from rdb$database;
----

.See also
<<fblangref50-security-sys-privs,Fine-grained System Privileges>>
