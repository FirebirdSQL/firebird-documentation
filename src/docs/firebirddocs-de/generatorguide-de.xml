<?xml version="1.0" encoding="UTF-8"?>
<!-- For standalone validation, uncomment the following DOCTYPE declaration. -->
<!-- DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"> "file:../docs/docbookx/docbookx.dtd" -->
<article id="generatorguide-de">
  <articleinfo>
    <title>Firebird Generatoren-Ratgeber</title>

    <subtitle>Ein Ratgeber über Art und Zweck der Anwendung von Generatoren in
    Firebird</subtitle>

    <author>
      <firstname>Frank</firstname>

      <surname>Ingermann</surname>
    </author>

    <othercredit class="translator">
      <firstname>Frank</firstname>

      <surname>Ingermann</surname>

      <contrib>Übersetzung ins Deutsche</contrib>
    </othercredit>

    <edition>4. Dezember 2006 – Dokumentenversion 0.2-de</edition>
  </articleinfo>

  <section id="generatorguide-de-intro">
    <title>Einführung</title>

    <section id="generatorguide-de-intro-about">
      <title>Wovon handelt dieser Artikel?</title>

      <para>Dieser Artikel erklärt, was Firebird-Generatoren sind, und wie und
      warum man sie benutzen kann. Dies ist der Versuch, alle relevanten
      Informationen über Generatoren in einem Dokument
      zusammenzufassen.</para>
    </section>

    <section id="generatorguide-de-intro-forwhom">
      <title>Wer sollte ihn lesen?</title>

      <para>Lese diesen Artikel, wenn...</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>dir das Konzept von Generatoren neu ist;</para>
        </listitem>

        <listitem>
          <para>du Fragen zu ihrer Anwendung hast;</para>
        </listitem>

        <listitem>
          <para>du eine Integer-Spalte so verwenden willst wie ein
          "AutoInc"-Feld, wie man es aus anderen RDBMS kennt</para>
        </listitem>

        <listitem>
          <para>du Beispiele zur Anwendung von Generatoren für IDs und andere
          Zwecke suchst;</para>
        </listitem>

        <listitem>
          <para>du wissen möchtest, wie die Sequenzen aus Oracle in Firebird
          heißen</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="generatorguide-de-basics">
    <title>Generatoren: Grundlagen</title>

    <section id="generatorguide-de-basics-whatis">
      <title>Was ist ein Generator?</title>

      <para>Man stelle sich einen Generator vor wie einen "Thread-sicheren"
      Integer-Zähler, der in einer Firebird Datenbank existiert. Man kann
      einen Generator erzeugen, in dem man ihm einen Namen gibt:</para>

      <programlisting>CREATE GENERATOR GenTest;</programlisting>

      <para>Dann kann man seinen Wert abfragen, erhöhen oder verringern, so
      wie man es mit einem "var i:Integer" in Delphi tun kann. Es ist aber
      nicht immer einfach, ihn zuverlässig auf einen bestimmten Wert zu setzen
      und diesen dann abzufragen - er ist in der Datenbank, aber
      <emphasis>ausserhalb jeder Transaktionskontrolle.</emphasis></para>
    </section>

    <section id="generatorguide-de-basics-sequence">
      <title>Was ist eine Sequenz?</title>

      <para><quote>Sequence</quote> ist der offizielle SQL-Begriff für das,
      was Firebird einen Generator nennt. Da Firebird ständig in Richtung
      besserer Unterstützung des SQL-Standards entwickelt wird, kann man von
      Firebird 2 an den Begriff SEQUENCE als Synonym für GENERATOR benutzen.
      Es wird in der Tat empfohlen, in neuem SQL-Code die SEQUENCE-Syntax zu
      verwenden.</para>

      <para>Auch wenn das Schlüsselwort "SEQUENCE" die Betonung auf die
      Erzeugung einer Serie von Werten legt, während GENERATOR eher auf die
      "Fabrik" zur Erzeugung der Werte zu deuten scheint, gibt es
      <emphasis>keinerlei Unterschied</emphasis> in Firebird zwischen einer
      SEQUENCE und einem GENERATOR. Es sind einfach zwei Namen für das gleiche
      Datenbankobjekt. Man kann einen Generator erzeugen und dann mit der
      Sequenz-Syntax auf ihn zugreifen und umgekehrt.</para>

      <para>Dies ist die bevorzugte Syntax zur Erzeugung einer Sequenz bzw.
      eines Generators in Firebird 2:</para>

      <programlisting>CREATE SEQUENCE SeqTest;</programlisting>
    </section>

    <section id="generatorguide-de-basics-storage">
      <title>Wo werden Generatoren gespeichert?</title>

      <para>Die <emphasis>Deklarationen</emphasis> von Generatoren werden in
      der Systemtabelle RDB$GENERATORS abgelegt. Ihre aktuellen
      <emphasis>Werte</emphasis> hingegen liegen in speziell reservierten
      Seiten (Pages) in der Datenbank. Man bearbeitet diese Werte nie direkt,
      sondern durch eingebaute Funktionen und Befehle, die im Verlauf dieses
      Artikels besprochen werden.</para>

      <warning>
        <para>Die Informationen in diesem Abschnitt sind nur zu Lernzwecken
        angegeben. Grundsätzlich sollte man nie direkt mit den Systemtabellen
        arbeiten. Versuche nicht, Generatoren zu erzeugen oder zu ändern, in
        dem du direkt die Systemtabelle RDB$GENERATORS manipulierst. (Ein
        SELECT kann allerdings nicht schaden).</para>
      </warning>

      <para>Die Struktur der <database>RDB$GENERATORS</database> Systemtabelle
      sieht wie folgt aus:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>RDB$GENERATOR_NAME</database>
          <database>CHAR(31)</database></para>
        </listitem>

        <listitem>
          <para><database>RDB$GENERATOR_ID</database>
          <database>SMALLINT</database></para>
        </listitem>

        <listitem>
          <para><database>RDB$SYSTEM_FLAG</database>
          <database>SMALLINT</database></para>
        </listitem>
      </itemizedlist>

      <para>Und, von Firebird 2.0 an:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>RDB$DESCRIPTION</database> <database>BLOB subtype
          TEXT</database></para>
        </listitem>
      </itemizedlist>

      <para>Man beachte, dass die <database>GENERATOR_ID</database> – wie der
      Name schon sagt – ein IDentifizierer für jeden Generator ist, und
      <emphasis>nicht</emphasis> sein Wert. Man sollte auch nicht diese ID in
      seinen Anwendungen benutzen, um später auf Generatoren zuzugreifen.
      Abgesehen davon, dass dies wenig Sinn macht (der
      <emphasis>Name</emphasis> identifiziert den Generator), kann sich die
      GENERATOR_ID nach einem Backup und anschliessendem RESTORE ändern. Das
      SYSTEM_FLAG ist 1 für die in der Datenbank intern verwendeten
      Generatoren, und NULL oder 0 für alle selbsterzeugten.</para>

      <para>Werfen wir einen Blick auf die
      <database>RDB$GENERATORS</database>-Tabelle, hier mit einem einzigen
      selbstdefinierten Generator:</para>

      <informaltable>
        <tgroup cols="3">
          <colspec colname="colGenName" colwidth="5*" />

          <colspec align="center" colname="colGenID" colwidth="4*" />

          <colspec align="center" colname="colSysFlag" colwidth="4*" />

          <thead>
            <row>
              <entry align="center">RDB$GENERATOR_NAME</entry>

              <entry align="center">RDB$GENERATOR_ID</entry>

              <entry align="center">RDB$SYSTEM_FLAG</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>RDB$SECURITY_CLASS</entry>

              <entry>1</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>SQL$DEFAULT</entry>

              <entry>2</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$PROCEDURES</entry>

              <entry>3</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$EXCEPTIONS</entry>

              <entry>4</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$CONSTRAINT_NAME</entry>

              <entry>5</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$FIELD_NAME</entry>

              <entry>6</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$INDEX_NAME</entry>

              <entry>7</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$TRIGGER_NAME</entry>

              <entry>8</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>MY_OWN_GENERATOR</entry>

              <entry>9</entry>

              <entry><constant>NULL</constant></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <note>
        <title>Firebird 2 Anmerkungen</title>

        <itemizedlist>
          <listitem>
            <para>Firebird 2 hat einen neuen System-Generator eingeführt
            namens<database> RDB$BACKUP_HISTORY</database>. Dieser wird vom
            neuen NBackup-Feature verwendet.</para>
          </listitem>

          <listitem>
            <para>Auch wenn die <database>SEQUENCE</database>-Syntax jetzt
            bevorzugt wird, wurden die<database> RDB$GENERATORS</database>
            Systemtabelle und ihre Spalten in Firebird 2 nicht
            umbenannt.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>

    <section id="generatorguide-de-basics-maxval">
      <title>Was ist der maximale Wert eines Generators?</title>

      <para>Generatoren speichern und liefern 64-bit Integerwerte in allen
      Firebird-Versionen. Dies ergibt einen Wertebereich von:</para>

      <blockquote>
        <para>-2<superscript>63</superscript> ..
        2<superscript>63</superscript>-1 oder -9,223,372,036,854,775,808 ..
        9,223,372,036,854,775,807</para>
      </blockquote>

      <para>Würde man also einen Generator mit Startwert 0 benutzen, um damit
      eine NUMERIC(18) oder BIGINT-Spalte zu befüllen, und man würde 1000 neue
      Datensätze pro Sekunde anlegen, dann würde es etwa 300 Millionen Jahre
      (!) dauern bevor der Generator überläuft. Da es eher unwahrscheinlich
      ist, dass die Menschheit dann noch auf diesem Planeten herumläuft (und
      immer noch Firebird-Datenbanken einsetzt), braucht man sich darüber also
      nicht wirklich Gedanken machen.</para>

      <para>Hier aber ein Wort der Warnung: Firebird spricht zwei
      SQL-"Dialekte": Dialekt 1 und Dialekt 3. Neue Datenbanken sollten immer
      mit dem in vieler Hinsicht mächtigeren Dialekt 3 erstellt werden.
      Dialekt 1 dient nur der Abwärtskompatibilität für Datenbanken, die mit
      InterBase 5.6 und früheren Versionen erstellt wurden.</para>

      <para>Einer der Unterschiede zwischen den beiden liegt darin, dass
      Dialekt 1 keinen nativen 64bit-Integer-Typen kennt. NUMERIC(18)-Spalten
      beispielsweise werden intern als DOUBLE PRECISION abgespeichert, was
      aber ein Gleitkommawert ist. Der größte verfügbare Integer-Typ in
      Dialekt 1 ist der 32bit-Integer.</para>

      <para>In Dialekt 1 wie auch in Dialekt 3 haben Generatoren 64bit. Wenn
      man aber einen Generatorwert in einer Dialekt 1-Datenbank einer
      INTEGER-Spalte zuweist, werden die oberen 32bit abgeschnitten, so dass
      man einen effektiven Wertebereich erhält von:</para>

      <blockquote>
        <para>-2<superscript>31</superscript> ..
        2<superscript>31</superscript>-1 oder -2,147,483,648 ..
        2,147,483,647</para>
      </blockquote>

      <para>Auch wenn der Generator selbst von 2,147,483,647 zu 2,147,483,648
      und weiterläuft, würde der abgeschnittene Wert in der Spalte an dieser
      Stelle überlaufen und den <emphasis>Eindruck</emphasis> eines
      32bit-Generators erwecken.</para>

      <para>In der oben beschriebenen Situation mit 1000 Datensätzen pro
      Sekunde würde die vom Generator gefüllte Spalte nun nach 25
      <emphasis>Tagen</emphasis> (!!!) überlaufen, und dem sollte auf jeden
      Fall Beachtung geschenkt werden. 2<superscript>31</superscript> ist eine
      ganze Menge, aber je nach Situation auch wieder nicht so viel.</para>

      <note>
        <para>In Dialekt 3 geht die Zuweisung von Generator-Werten an
        INTEGER-Spalten solange gut, wie der Wert im 32bit-Integer-Bereich
        liegt. Sobald aber dieser Bereich überschritten wird, gibt es einen
        Numerischen Überlaufsfehler ("numeric overflow error"): Dialekt 3 ist
        viel strikter in der Bereichsüberprüfung als Dialekt 1!</para>
      </note>

      <section>
        <title>Client-Dialekte und Generatorwerte</title>

        <para>Clients, die mit einem Firebird-Server verbunden sind, können
        ihren Dialekt auf 1 oder 3 stellen, und zwar unabhängig von der
        verbundenen Datenbank. Es ist der Dialekt des Clients,
        <emphasis>nicht</emphasis> der der Datenbank, der entscheidet, wie
        Firebird Generatorwerte zum Client liefert:</para>

        <itemizedlist>
          <listitem>
            <para>Wenn der Client-Dialekt 1 ist, liefert der Server
            Generatorwerte als abgeschnittene 32bit-Werte zum Client. Aber
            innerhalb der Datenbank bleiben sie 64bit-Werte und laufen nach
            Erreichen von 2<superscript>31</superscript>-1 nicht über (auch
            wenn das für den Client so aussieht). Dies gilt sowohl für Dialekt
            1 wie für Dialekt 3-Datenbanken.</para>
          </listitem>

          <listitem>
            <para>Wenn der Client-Dialekt 3 ist, gibt der Server volle 64 Bit
            zum Client zurück. Auch dies gilt für beide
            Datenbank-Dialekte.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="generatorguide-de-basics-howmany">
      <title>Wie viele Generatoren sind in einer Datenbank verfügbar?</title>

      <para>Seit Firebird 1.0 ist die Anzahl der verfügbaren Generatoren nur
      durch den größtmöglichen Wert für die ID-Spalte in der
      RDB$GENERATORS-Systemtabelle limitiert. Da dies eine SMALLINT-Spalte
      ist, ist die max. Anzahl 2<superscript>15</superscript>-1 oder 32767.
      Die erste ID ist immer 1, d.h. die Gesamtanzahl der Generatoren kann
      32767 nicht überschreiten. Wie zuvor beschrieben, gibt es in jeder
      Datenbank 8 oder 9 Systemgeneratoren, so dass effektiv noch mindestens
      32758 für eigene Generatoren übrig bleiben. Dies sollte für jede
      praktische Anwendung bei weitem ausreichen. Da die Anzahl der
      Generatoren keine Auswirkung auf die Performanz hat, kann man nach
      Herzenslust so viele Generatoren benutzen wie man möchte.</para>

      <section>
        <title>Ältere InterBase- und Firebird-Versionen</title>

        <para>In den frühesten vor-1.0 Firebird-Versionen, so wie in
        InterBase, wurde nur eine Datenbankseite (Page) zur Speicherung der
        Generatorwerte benutzt. Dadurch war die Anzahl nutzbarer Generatoren
        durch die Seitengröße (Page Size) der Datenbank begrenzt. Die folgende
        Tabelle zeigt, wie viele Generatoren (inkl. der Systemgeneratoren) in
        den verschiedenen InterBase- und Firebird-Versionen zur Verfügung
        stehen (mit Dank an Paul Reeves für diese Informationen):</para>

        <informaltable>
          <tgroup cols="5">
            <colspec colname="colVersion" colwidth="2*" />

            <colspec align="center" colname="col1k" />

            <colspec align="center" colname="col2k" />

            <colspec align="center" colname="col4k" />

            <colspec align="center" colname="col8k" />

            <spanspec nameend="col8k" namest="col1k" spanname="spanpagesize" />

            <thead>
              <row>
                <entry align="center">Version</entry>

                <entry align="center" spanname="spanpagesize">Seitengrösse
                (Page size)</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry></entry>

                <entry align="center"><emphasis>1K</emphasis></entry>

                <entry align="center"><emphasis>2K</emphasis></entry>

                <entry align="center"><emphasis>4K</emphasis></entry>

                <entry align="center"><emphasis>8K</emphasis></entry>
              </row>

              <row>
                <entry><emphasis>InterBase &lt; v.6</emphasis></entry>

                <entry>247</entry>

                <entry>503</entry>

                <entry>1015</entry>

                <entry>2039</entry>
              </row>

              <row>
                <entry><emphasis>IB 6 und frühe Prä-1.0
                Firebird</emphasis></entry>

                <entry>123</entry>

                <entry>251</entry>

                <entry>507</entry>

                <entry>1019</entry>
              </row>

              <row>
                <entry><emphasis>Alle späteren
                Firebird-Vers.</emphasis></entry>

                <entry align="center" spanname="spanpagesize">32767</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>In InterBase-Versionen vor 6 waren Generatoren nur 32 Bit breit.
        Dies erklärt, warum diese früheren Versionen ungefähr die doppelte
        Anzahl an Generatoren in der selben Seitengrösse speichern
        konnten.</para>

        <warning>
          <para>InterBase, zumindest bis inklusive Version 6.01, ließ
          problemlos die Erzeugung von bis zu 32767 Generatoren zu. Was
          passierte, wenn man auf Generatoren mit einer ID grösser der oben
          angegeben Maximalzahl zugriff, hing von der Version ab:</para>

          <itemizedlist>
            <listitem>
              <para>InterBase 6 generierte einen <quote>invalid block
              type</quote>-Fehler da die berechnete Position ausserhalb der
              einen reservierten Generatoren-Seite lag.</para>
            </listitem>

            <listitem>
              <para>In früheren Versionen wurde ein Fehler gemeldet, wenn die
              berechnete Position ausserhalb der Datenbank lag. Ansonsten
              wurde beim <emphasis>Lesezugriff</emphasis> einfach der Wert
              geliefert, der sich zufällig an der berechneten Position befand.
              Wurde der "zu grosse" Generator verändert, dann
              <emphasis>überschrieb</emphasis> er einfach den Wert an der
              berechneten Position. Manchmal führte dies zu einem sofortigen
              Fehler, meistens aber einfach zu einer stillen Beschädigung der
              Datenbank.</para>
            </listitem>
          </itemizedlist>
        </warning>
      </section>
    </section>

    <section id="generatorguide-de-basics-transactions">
      <title>Generatoren und Transaktionen</title>

      <para>Wie gesagt leben Generatoren ausserhalb der Transaktionskontrolle.
      Dies bedeutet schlicht und ergreifend, dass es keinen sicheren Weg gibt,
      in einer Transaktion ein "Rollback" eines Generators durchzuführen.
      Andere, zeitgleich laufende Transkationen können den Wert verändern,
      während die eigene Transaktion läuft. Hat man also einen Generatorwert
      erzeugt, sollte man ihn als "auf ewig verbraucht" betrachten.</para>

      <para>Startet man also eine Transaktion und erzeugt darin einen
      Generatorwert von - sagen wir - 5, dann bleibt der Generator auf diesem
      Wert, <emphasis role="bold">selbst wenn man ein Rollback der Transaktion
      durchführt (!)</emphasis>. Man sollte nicht mal
      <emphasis>denken</emphasis> an etwas wie: "OK, wenn ich ein Rollback
      durchführe, setze ich den Generator mittels GEN_ID(mygen,-1) eben wieder
      auf 4 zurück". Dies kann meistens funktionieren, ist aber
      <emphasis>unsicher</emphasis>, da andere Transaktionen den Wert
      inzwischen wiederum verändert haben können. Aus dem gleichen Grund macht
      es keinen Sinn, den aktuellen Generatorwert mit GEN_ID(mygen,0) aus der
      Datenbank zu holen und ihn dann Client-seitig zu inkrementieren.</para>
    </section>
  </section>

  <section id="generatorguide-de-sqlsyntax">
    <title>SQL-Befehle für Generatoren</title>

    <section id="generatorguide-de-sqlsyntax-overview">
      <title>Befehlsüberblick</title>

      <para>Der Name des Generators muss ein üblicher Bezeichner für
      DB-Objekte sein: 31 Zeichen Maximallänge, keine Sonderzeichen mit
      Ausnahme des Unterstrichs <quote>_</quote> (es sei denn, man verwendet
      "delimited identifier", d.h. Bezeichner in Anführungsstrichen). Die
      SQL-Befehle für Generatoren sind unten aufgeführt. Ihre Verwendung wird
      detailliert im Abschnitt <citetitle><link
      linkend="generatorguide-de-sqlsyntax-use">Verwendung der
      Generator-Befehle </link></citetitle> beschrieben.</para>

      <para>DDL (Data Definition Language) - Befehle:</para>

      <programlisting>CREATE GENERATOR &lt;name&gt;;
SET GENERATOR &lt;name&gt; TO &lt;value&gt;;
DROP GENERATOR &lt;name&gt;;</programlisting>

      <para>DML (Data Manipulation Language) Befehle in Client-seitigem
      SQL:</para>

      <programlisting>SELECT GEN_ID( &lt;GeneratorName&gt;, &lt;increment&gt; ) FROM RDB$DATABASE;</programlisting>

      <para>DML Anweisungen in PSQL (Procedural SQL, verfügbar in Stored
      Procedures und Triggern):</para>

      <programlisting>&lt;intvar&gt; = GEN_ID( &lt;GeneratorName&gt;, &lt;increment&gt; );</programlisting>

      <section>
        <title>Für Firebird 2 empfohlene Syntax</title>

        <para>Auch wenn die traditionelle Syntax weiter unterstützt wird, sind
        dies die für Firebird 2 bevorzugten Äquivalente der
        DDL-Befehle:</para>

        <programlisting>CREATE SEQUENCE &lt;name&gt;;
ALTER SEQUENCE &lt;name&gt; RESTART WITH &lt;value&gt;;
DROP SEQUENCE &lt;name&gt;;</programlisting>

        <para>Und für die DML-Befehle:</para>

        <programlisting>SELECT NEXT VALUE FOR &lt;SequenceName&gt; FROM RDB$DATABASE;</programlisting>

        <programlisting>&lt;intvar&gt; = NEXT VALUE FOR &lt;SequenceName&gt;;</programlisting>

        <para>Derzeit unterstützt die neue Syntax ausschliesslich ein
        Inkrement von 1. Diese Einschränkung wird in einer zukünftigen Version
        aufgehoben. In der Zwischenzeit kann man die GEN_ID-Syntax nutzen,
        falls man einen anderen Inkrement benötigt.</para>
      </section>
    </section>

    <section id="generatorguide-de-sqlsyntax-use">
      <title>Verwendung der Generator-Befehle</title>

      <para>Die Verfügbarkeit der Befehle und Funktionen hängt davon ab, wo
      man sie benutzt:</para>

      <itemizedlist>
        <listitem>
          <para>In Client-seitigem SQL – die Sprache, in der der Client mit
          dem Firebird-Server kommuniziert.</para>
        </listitem>

        <listitem>
          <para>PSQL – Die Server-seitige Programmiersprache, die in Stored
          Procedures und Triggern verwendet wird.</para>
        </listitem>
      </itemizedlist>

      <section id="generatorguide-de-sqlsyntax-create">
        <title>Einen Generator erzeugen (<quote>Insert</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>CREATE GENERATOR &lt;GeneratorName&gt;;</programlisting>

              <para>Für Firebird 2 und höher bevorzugt:</para>

              <programlisting>CREATE SEQUENCE &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <para>Nicht möglich. Da man die Metadaten der Datanbank
              innerhalb von SPs und Triggern nicht ändern kann, kann man hier
              auch keine Generatoren erzeugen</para>

              <note>
                <para>Seit FB 1.5 und aufwärts kann man dies durch die
                Verwendung des<database> EXECUTE STATEMENT</database>-Features
                umgehen.</para>
              </note>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-de-sqlsyntax-getvalue">
        <title>Den aktuellen Wert abfragen (<quote>Select</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>SELECT GEN_ID( &lt;GeneratorName&gt;, 0 ) FROM RDB$DATABASE;</programlisting>

              <para>Diese Syntax ist auch in Firebird 2 derzeit die einzige
              Option.</para>

              <note>
                <para>In Firebird's Kommandozeilen-Werkzeug
                <emphasis>isql</emphasis> gibt es zwei weitere Befehle zum
                Auslesen der aktuellen Generatorwerte::</para>

                <blockquote>
                  <programlisting>SHOW GENERATOR &lt;GeneratorName&gt;;
SHOW GENERATORS;</programlisting>
                </blockquote>

                <para>Der erstere zeigt den aktuellen Wert des angegeben
                Generators, letzterer tut dies für alle
                Nicht-System-Generatoren in der Datenbank.</para>

                <para>Die für Firebird 2 bevorzugten Äquivalente sind, man
                ahnt es schon:</para>

                <blockquote>
                  <programlisting>SHOW SEQUENCE &lt;SequenceName&gt;;
SHOW SEQUENCES;</programlisting>
                </blockquote>

                <para>Nochmals der Hinweis: Diese SHOW-Befehle stehen nur in
                isql zur Verfügung. Anders als <database>GEN_ID</database>,
                können sie nicht in Client-seitigem SQL verwendet werden (es
                sei denn, die Client-Anwendung ist eine isql-Oberfläche oder
                Frontend).</para>
              </note>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>&lt;intvar&gt; = GEN_ID( &lt;GeneratorName&gt;, 0 );</programlisting>

              <para>Firebird 2: Gleiche Syntax.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-de-sqlsyntax-genvalue">
        <title>Den nächsten Wert generieren (<quote>Update</quote> +
        <quote>Select</quote>)</title>

        <para>Genau wie das Ermitteln des aktuellen Werts wird dies mittels
        GEN_ID errecicht, diesmal aber mit einem Inkrement von 1. Firebird
        wird:</para>

        <orderedlist spacing="compact">
          <listitem>
            <para>den aktuellen Generatorwert holen;</para>
          </listitem>

          <listitem>
            <para>ihn um 1 inkrementieren (und speichern);</para>
          </listitem>

          <listitem>
            <para>den inkrementierten Wert zurückliefern</para>
          </listitem>
        </orderedlist>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>SELECT GEN_ID( &lt;GeneratorName&gt;, 1 ) FROM RDB$DATABASE;</programlisting>

              <para>Die neue, für Firebird 2 empfohlene Syntax, ist völlig
              verschieden:</para>

              <programlisting>SELECT NEXT VALUE FOR &lt;SequenceName&gt; FROM RDB$DATABASE;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>&lt;intvar&gt; = GEN_ID( &lt;GeneratorName&gt;, 1 );</programlisting>

              <para>Für Firebird 2 und höher bevorzugte Syntax:</para>

              <programlisting>&lt;intvar&gt; = NEXT VALUE FOR &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-de-sqlsyntax-setvalue">
        <title>Einen Generator direkt auf einen bestimmten Wert setzen
        (<quote>Update</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>SET GENERATOR &lt;GeneratorName&gt; TO &lt;NewValue&gt;;</programlisting>

              <para>Dies ist nützlich, um einen Generator auf einen anderen
              als den Standardwert 0, nach der Erzeugung vorzubelegen, z.B. in
              einem Skript, um die Datenbank zu erzeugen. Genau wie CREATE
              GENERATOR ist dies ein DDL- und kein DML-Befehl.</para>

              <para>Für Firebird 2 und höher bevorzugte Syntax:</para>

              <programlisting>ALTER SEQUENCE &lt;SequenceName&gt; RESTART WITH &lt;NewValue&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>GEN_ID( &lt;GeneratorName&gt;, &lt;NewValue&gt; - GEN_ID( &lt;GeneratorName&gt;, 0 ) );</programlisting>

              <warning>
                <para>Dies ist mehr ein mieser kleiner Trick um etwas zu tun,
                was man in SPs und Triggern niemals tun sollte: Generatoren
                (über-)schreiben. Sie sind zum Generieren (Lesen) und nicht
                zum Setzen (Schreiben) da.</para>

                <!--It also seems unsafe to me, unless the entire operation is atomic!
What if another thread/client changes the generator after the first GEN_ID call?-->
              </warning>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-de-sqlsyntax-drop">
        <title>Einen Generator löschen (<quote>Delete</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Client SQL</term>

            <listitem>
              <programlisting>DROP GENERATOR &lt;GeneratorName&gt;;</programlisting>

              <para>Für Firebird 2 und höher bevorzugte Syntax:</para>

              <programlisting>DROP SEQUENCE &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <para>Nicht möglich, es sei denn... (Gleiche Erklärung wie bei
              CREATE: man kann - oder besser: <emphasis>sollte
              </emphasis>keine Änderung an den Metadaten in PSQL
              vornehmen).</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Einen Generator zu Löschen gibt den von ihm belegten Platz, für
        die Verwendung durch einen neuen Generator, nicht wieder frei. In der
        Praxis stört dies kaum, da kaum eine Datenbank die Zigtausend
        Generatoren braucht, die Firebird zulässt, so dass es immer noch
        genügend Platz für neue gibt. Sollte die Datenbank aber doch Gefahr
        laufen, die 32767er Grenze zu erreichen, kann man den verbrauchten
        Platz durch einen Backup-Restore-Zyklus wiedergewinnen. Dies wird die
        RDB$GENERATORS-Tabelle komprimieren, unter Zuweisung einer neuen,
        lückenlosen Reihe von IDs. Abhängig von der Situation kann die
        wiederhergestellte Datenbank unter Umständen auch weniger Seiten zur
        Speicherung der Generatorwerte brauchen.</para>

        <section>
          <title>Generatoren in älteren IB- und Firebird-Versionen
          löschen</title>

          <para>Sowohl InterBase 6 und frühere als auch frühe
          Prä-1.0-Firebird-Versionen kennen keinen <database>DROP
          GENERATOR</database>-Befehl. Die einzige Möglichkeit zum Löschen
          eines Generators in diesen Versionen ist:</para>

          <programlisting>DELETE FROM RDB$GENERATORS WHERE RDB$GENERATOR_NAME = '&lt;GeneratorName&gt;';</programlisting>

          <para>...gefolgt von einem Backup und Restore.</para>

          <para>In diesen Versionen war es durch die auf wenige hundert
          begrenzte Anzahl verfügbarer Generatoren wahrscheinlicher, dass man
          den Platz für gelöschte Generatoren durch Backup/Restore
          zurückgewinnen musste.</para>
        </section>
      </section>
    </section>
  </section>

  <section id="generatorguide-de-rowids">
    <title>Generatoren zum Erzeugen eindeutiger Datensatz-IDs</title>

    <section id="generatorguide-de-rowids-why">
      <title>Wozu überhaupt Datensatz-IDs?</title>

      <para>Die Beantwortung dieser Frage würde den Rahmen diese Artikels
      deutlich sprengen. Derjenige, der keinen Sinn darin sieht, eine
      eindeutige Identifikationsmöglichkeit jedes Datensatzes in jeder Tabelle
      zu haben, oder dem das Konzept von "bedeutungslosen" oder
      "Surrogat"-Schlüsseln im allgemeinen missfällt, sollte das folgende
      Kapitel wohl besser überspringen...</para>
    </section>

    <section id="generatorguide-de-rowids-howmanygens">
      <title>Einer für alle oder einer für jede?</title>

      <para>OK, du willst also Datensatz-IDs. { Anm.d.Autors: Glückwunsch! :-)
      }</para>

      <para>Eine grundsätzliche, weitreichende Entscheidung muss gefällt
      werden: Benutzt man einen einzelnen Generator für alle Tabellen, oder
      jeweils einen Generator pro Tabelle. Dies ist dir überlassen - man
      sollte aber folgendes in Betracht ziehen:</para>

      <para>Mit dem <quote>Einer für alle</quote>-Ansatz: <itemizedlist
          spacing="compact">
          <listitem>
            <para>+ braucht man nur einen einzlnen Generator für alle
            IDs</para>
          </listitem>

          <listitem>
            <para>+ hat man einen Integerwert, der den Datensatz nicht nur in
            seiner Tabelle, sondern in der gesamten Datenbank eindeutig
            identifiziert</para>
          </listitem>

          <listitem>
            <para>- hat man weniger verfügbare Generatorwerte pro Tabelle (das
            sollte mit 64bit-Generatoren nicht wirklich ein Problem
            sein)</para>
          </listitem>

          <listitem>
            <para>- bekommt man es bald mit unhandlich großen ID-Werten zu
            tun, selbst in z.B. kleinen Nachschlagetabellen mit nur einer
            Handvoll Einträgen</para>
          </listitem>

          <listitem>
            <para>- hat man höchstwahrscheinlich Lücken in den IDs einer
            Tabelle, da die ID-Werte über alle Tabellen verteilt werden</para>
          </listitem>
        </itemizedlist></para>

      <para>Mit dem <quote>Einer für jede</quote>-Ansatz:<itemizedlist
          spacing="compact">
          <listitem>
            <para>- muss man für jede ID-fähige Tabelle in der Datenbank einen
            eigenen Generator anlegen</para>
          </listitem>

          <listitem>
            <para>- braucht man immer die Kombination aus ID und Tabellenname
            zur eindeutigen Identifizierung des Satzes in der Datenbank</para>
          </listitem>

          <listitem>
            <para>+ hat man einen einfachen und robusten
            <quote>Einfügezähler</quote> pro Tabelle</para>
          </listitem>

          <listitem>
            <para>+ hat man eine chronologische Sequenz pro Tabelle: Findet
            man eine Lücke in den IDs, stammt sie entweder von einem DELETE
            oder einem schiefgegangenen INSERT</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section id="generatorguide-de-rowids-reusevals">
      <title>Kann man Generatorwerte wiederverwenden?</title>

      <para>Nun ja, technisch gesehen <emphasis>kann</emphasis> man das. Aber
      NEIN, man sollte es nicht. Niemals. NIE-NIE-NIEMALS. Nicht nur würde
      dies die schöne chronologische Reihenfolge der IDs zerstören (man kann
      das "Alter" eines Datansatzes nicht mehr an Hand der ID abschätzen), je
      mehr man darüber nachdenkt um so mehr Kopfschmerzen bereitet es.
      Abgesehen davon ist es ein völliger Widerspruch zum Konzept eindeutiger
      Datensatz-IDs.</para>

      <para>Solange man also keine wirklich guten Gründe hat, Generatorwerte
      zu "recyclen", und einen wohlüberlegten Mechanismus besitzt, um dies in
      Mehrbenutzer/Multi-Transaktionsumgebungen sicher zu machen, FINGER
      WEG!</para>
    </section>

    <section id="generatorguide-de-rowids-autoinc">
      <title>Generatoren für IDs oder Auto-Increment-Felder</title>

      <para>Einem neu eingefügten Datensatz eine ID (im Sinne einer
      eindeutigen "Seriennummer") zu geben ist einfach zu bewerkstelligen
      unter Verwendung eines Generators und eines BEFORE INSERT-Triggers, wie
      wir im Folgenden sehen werden. Wir starten mit einer Tabelle TTEST mit
      einer Spalte ID, deklariert als Integer. Unser Generator heisst
      GIDTEST.</para>

      <section>
        <title>Before Insert Trigger, Version 1</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V1 for TTEST
active before insert position 0
as
begin
  new.id = gen_id( gidTest, 1 );
end</programlisting>

        <para>Probleme mit Trigger Version 1:</para>

        <para>Dieser erledigt die Arbeit - aber er "verschwendet" auch jedes
        mal einen Generatorwert, wenn im INSERT-Befehl bereits ein generierter
        Wert für die ID übergeben wurde. Es wäre also effektiver, nur dann
        einen neuen Wert zu generieren, wenn nicht bereits einer im
        INSERT-Befehl enthalten war:</para>
      </section>

      <section>
        <title>Before Insert Trigger, Version 2</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V2 for TTEST
active before insert position 0
as
begin
  if (ne    w.idisnullthen
  begin
    new.id = gen_id( gidTest, 1 );
  end
end</programlisting>

        <para>Probleme mit Trigger Version 2:</para>

        <para>Manche Zugriffskomponenten haben die "dumme Angewohnheit", alle
        Spaltenwerte in einem Insert-Befehl vorzubelegen. Die Felder, die man
        nicht explizit setzt, bekommen Vorgabewerte - üblicherweise 0 für
        Integer-Spalten. In diesem Falle würde der obige Trigger nicht
        funktionieren: Er würde sehen, dass die ID-Spalte nicht den
        <emphasis>Zustand</emphasis> NULL, sondern den
        <emphasis>Wert</emphasis> 0 hat, und würde deshalb keine neue ID
        generieren. Man könnte den Satz dennoch speichern - aber nur einen...
        der zweite würde fehlschlagen. Es ist ohnehin eine gute Idee, die 0
        als normalen ID-Wert zu "verbannen", allein schon um Verwechslungen
        zwischen NULL und 0 zu vermeiden. Man könnte z.B. einen speziellen
        Datensatz mit einer ID von 0 zur Speicherung der eigenen Vorgabewerte
        jeder Spalte in der Tabelle verwenden.</para>
      </section>

      <section>
        <title>Before Insert Trigger, Version 3</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V3 for TTEST
active before insert position 0
as
begin
  if ((new.id is null) or (new.id = 0)) then
  begin
    new.id = gen_id( gidTest, 1 );
  end
end</programlisting>

        <para>Nun, da wir einen robust funktionierenden ID-Trigger haben,
        werden die folgenden Absätze erläutern, warum man den meistens gar
        nicht braucht:</para>

        <para>Das Grundproblem mit IDs, die in Before-Insert-Triggern
        zugewiesen werden, ist, dass sie die IDs serverseitig erzeugen,
        <emphasis>nachdem</emphasis> man den Insert-Befehl zum Server
        geschickt hat. Das heißt schlicht und ergreifend, dass es
        <emphasis>keinen</emphasis> sicheren Weg gibt, von der Client-Seite
        aus zu erfahren, welche ID für den gerade erzeugten Satz vergeben
        wurde.</para>

        <para>Man könnte nach dem INSERT den aktuellen Stand des Generators
        abfragen, aber im Mehrbenutzerbetrieb kann man nicht wirklich sicher
        sein, dass es die ID des eigenen Datensatzes ist (wegen der
        Transaktionskontrolle).</para>

        <para>Generiert man aber einen neuen Generatorwert
        <emphasis>vorher</emphasis>, und füllt die ID-Spalte im Insert-Befehl
        mit diesem Wert, dann kann man den Datensatz einfach mit einem "Select
        ... where ID=&lt;GenWert&gt;" aus der Datenbank holen, um z.B. zu
        sehen, welche Vorgabewert greifen oder welche Spalten durch
        Insert-Trigger verändert wurden. Dies funktioniert deshalb besonders
        gut, weil man üblicherweise einen eindeutigen Primärindex für die
        ID-Spalte hat, und das sind so ungefähr die schnellsten Indizes, die
        man kriegen kann - sie sind unschlagbar in punkto Selektivität, und
        meist auch kleiner als Indizes für Textfelder vom Typ CHAR(n) (gilt
        für n&gt;8, abhängig von Zeichensatz und Sortierreihenfolge)</para>

        <para>Fazit des Ganzen:</para>

        <para>Man sollte immer einen Before Insert-Trigger erzeugen, um
        absolut sicher zu sein, dass jeder neue Datensatz eine eindeutige ID
        erhält, selbst wenn im Insert-Befehl keine übergeben wurde.</para>

        <para>Hat man eine SQL-mäßig "geschlossene" Datenbank (d.h. die eigene
        Applikation ist die einzige Quelle neuer Datensätze), dann kann man
        den Trigger weglassen. Dann muss man aber IMMER einen Generatorwert
        vor dem Insert holen und ihn im Insert-Befehl mitübergeben. Das selbe
        gilt selbstverständlich für Inserts, die aus Stored Procedures oder
        Triggern heraus erfolgen.</para>
      </section>
    </section>
  </section>

  <section id="generatorguide-de-misc">
    <title>Was man sonst noch mit Generatoren machen kann</title>

    <para>Hier gibt es noch ein paar Anregungen für den Gebrauch von
    Generatoren für andere Zwecke als das Erzeugen von Datensatz-IDs.</para>

    <section id="generatorguide-de-misc-uniquenums">
      <title>Generatoren verwenden, um z.B. Transferdateien eindeutig zu
      kennzeichnen</title>

      <para>Eine "klassische" Anwendung von Generatoren ist es, eindeutige,
      aufeinanderfolgende Werte zu erzeugen für - na ja, alles in der
      Applikation, abgesehen von den oben diskutierten Datensatz-IDs.
      Exportiert die Anwendung z.B. Daten zu anderen Systemen, kann man
      Generatorwerte sicher zur eindeutigen Bezeichnung jedes Transfers
      benutzen. Dies hilft enorm bei der Fehlersuche in solchen
      Datenschnittstellen (und anders als die meisten der folgenden
      Anwendungen funktioniert es sicher und robust).</para>
    </section>

    <section id="generatorguide-de-misc-usagecount">
      <title>Generatoren als "Benutzungszähler" für StoredProcs als
      Statistikgrundlage</title>

      <para>Stelle dir vor, du hast gerade ein fantastisches neues Feature
      mittels einer Stored Procedure erstellt. Jetzt spielst du die neue
      Version beim Kunden ein und möchtest später wissen, ob und wie oft die
      Kunden dieses Feature wirklich benutzen. Simpel: man nehme einen
      speziellen Generator, der nur in dieser StoredProc hochgezählt wird, und
      das war`s... mit der kleinen Einschränkung, dass man nicht wissen kann,
      wie viele Transaktionen mit Aufrufen der SP durch ein Rollback nicht zu
      Ende gebracht wurden. In jedem Falle aber weiss man dann, wie oft
      Benutzer <emphasis>versucht</emphasis> haben, die SP zu benutzen.
      :-)</para>

      <para>Man könnte diese Methode noch verfeinern, in dem man zwei
      Generatoren benutzt: einer wird direkt am Start der Prozedur erhöht, der
      zweite ganz am Ende vor dem EXIT. Haben beide nach einer Zeit den selben
      Wert, dann ist innerhalb der SP nie etwas schiefgegangen etc. Natürlich
      weiss man immer noch nicht, wieviele SP-Aufrufe einem Rollback der
      aufrufenden Transaktion zum Opfer gefallen sind.</para>
    </section>

    <section id="generatorguide-de-misc-rowcount">
      <title>Generatoren zur Simulation von <quote>Select count(*)
      from...</quote></title>

      <para>Es ist ein bekanntes Problem von InterBase und Firebird, dass
      ein<database> SELECT COUNT(*)</database> (ohne Where-Klausel) bei einer
      wirklich grossen Tabelle eine ganze Weile zur Durchführung benötigt, da
      der Server "zu Fuss" durchzählen muss, wie viele Sätze sich zum
      Zeitpunkt des Aufrufs gerade in der Tabelle befinden (Stichwort:
      Multigenerationsarchitektur). <emphasis>Theoretisch</emphasis> liesse
      sich dieses Problem einfach durch den Einsatz von Generatoren
      umgehen:<itemizedlist spacing="compact">
          <listitem>
            <para>man nehme einen speziellen "Satzzähler"-Generator;</para>
          </listitem>

          <listitem>
            <para>man erzeuge einen Before Insert Trigger, der ihn
            erhöht</para>
          </listitem>

          <listitem>
            <para>und einen After Delete Trigger, der ihn wieder
            runterzählt.</para>
          </listitem>
        </itemizedlist></para>

      <para>Das funktioniert wunderbar und macht ein "volles" Durchzählen der
      Datensätze überflüssig - man fragt einfach den aktuellen Generatorwert
      ab. Die Betonung liegt hier auf <emphasis>theoretisch</emphasis>, denn
      das ganze geht den Bach runter, sobald Insert-Befehle schiefgehen, denn
      wie gesagt liegen Generatoren <emphasis>ausserhalb jeder
      Transaktionskontrolle</emphasis>. Insert-Befehle können durch
      Constraints (eindeutige Index-Verletzungen, NOT NULL-Felder enthalten
      NULL etc.) oder durch andere Metadaten-Einschränkungen schiefgehen, oder
      einfach weil die aufrufende Transaktion mit einem Rollback endet. Man
      hat keine Datensätze in der Tabelle und trotzdem steigt der
      Zähler-Generator.</para>

      <para>Es kommt also drauf an - wenn man den ungefähren Prozentsatz
      schieflaufender Inserts kennt (man kann dafür ein "Gefühl" entwickeln),
      und es nur um eine grobe <emphasis>Abschätzung</emphasis> der Anzahl der
      Datensätze geht, dann kann diese Methode hilfreich sein, obwohl sie
      nicht exakt ist. Von Zeit zu Zeit kann man ein "normales" Durchzählen
      der Sätze durchführen, um den Generator wieder auf den richtigen Wert zu
      setzen ("Re-Synchronisation" des Generators), so dass man den Fehler in
      Grenzen halten kann.</para>

      <para>Es gibt Situationen, wo Kunden glücklich leben können mit einer
      Aussage wie "es gibt <emphasis>ungefähr</emphasis> 2,3 Millionen
      Datensätze in der Tabelle", die sie sofort auf einen Mausklick hin
      erhalten, einen aber erschiessen würden, wenn sie 10 Minuten oder mehr
      warten müssen, um zu erfahren, dass es exakt 2.313.498.229 Datensätze
      sind...</para>
    </section>

    <section id="generatorguide-de-misc-progresscount">
      <title>Generatoren zum Überwachen und/oder Steuern lange laufender
      Stored Procedures</title>

      <para>Hat man Stored Procedures, die z.B. Auswertungen auf grossen
      Tabellen oder über komplexe Joins fahren, dann können diese ganz schön
      lange brauchen. Hier können Generatoren auf zweierlei Weise helfen: Sie
      können einen Fortschrittszähler liefern, den man zyklisch vom Client aus
      abfragen kann, und sie können benutzt werden, um die Ausführung
      abzubrechen:</para>

      <programlisting>CREATE GENERATOR gen_spTestProgress;
CREATE GENERATOR gen_spTestStop;

set term ^;

CREATE PROCEDURE spTest (...)
AS
BEGIN
  (...)
  for select &lt;viele Daten die lange zur Auswertung brauchen&gt;
  do begin
    GEN_ID(gen_spTestProgress,1);

    IF (GEN_ID(gen_spTestStop,0)&gt;0) THEN Exit;

    (...hier die normale Abarbeitung...)
  end
END^</programlisting>

      <para>Nur ein grober Entwurf, aber das Konzept sollte erkennbar sein.
      Von der Client-Seite aus kann man ein GEN_ID(gen_spTestProgress,0)
      asynchron zur Ausführung der SP aufrufen (z.B. in einem zweiten Thread),
      um zu sehen, wie viele Sätze bereits abgearbeitet sind, und diesen Wert
      in einem Fortschrittsbalken anzeigen. Und man kann mittels
      GEN_ID(gen_spTestStop,1) die SP jederzeit von "aussen" abbrechen.</para>

      <para>Auch wenn dies sehr hilfreich sein kann, hat es eine starke
      Einschränkung: <emphasis>Es ist nicht sicher im
      Mehrbenutzer-Betrieb</emphasis>. Würde die SP parallel von zwei
      Transaktionen aus aufgerufen, würde der Fortschrittszähler gestört -
      beide Aufrufe würden den gleichen Generator erhöhen, und das Resultat
      wäre unbrauchbar. Schlimmer noch, eine Inkrementierung des
      STOP-Generators würde die SP in <emphasis>beiden</emphasis>
      Transaktionen beenden. Aber für z.B. Monatsauswertungen, die von einem
      einzigen Modul im Batch-Betrieb gefahren werden, kann dies akzeptabel
      sein - wie üblich hängt es von den Randbedingungen ab.</para>

      <para>Will man diese Technik einsetzen, um vom Benutzer jederzeit
      aufrufbare SPs zu steuern, muss durch andere Mechanismen gewährleistet
      werden, dass die SP nicht zeitgleich mehrmals ausgeführt werden kann.
      Darüber sinnierend kam mir die Idee, dafür einen weiteren Generator
      einzusetzen: nennen wir ihn gen_spTestLocked (unter Annahme des
      Startwerts von 0 natürlich):</para>

      <programlisting>CREATE GENERATOR gen_spTestProgress;
CREATE GENERATOR gen_spTestStop;
CREATE GENERATOR gen_spTestLocked;

set term ^;

CREATE PROCEDURE spTest (...)
AS
DECLARE VARIABLE lockcount INTEGER;
BEGIN
  lockcount = GEN_ID(gen_spTestLocked,1); 
    /* allererster Schritt: Erhöhen des Blockade-Generators */

  if (lockcount=1) then /* _wir_ haben die Sperre, weitermachen */
  begin
    (..      .hierdernormaleProzedurrumpf...
  end

  lockcount = GEN_ID(gen_spTestLocked,-1); /* Erhöhung rückgängig machen */

  /* sicherstellen dass der Generator auch bei Ausnahmen (Exceptions) im 
     Prozedurrumpf jederzeit sauber zurückgesetz wird: */
     
  WHEN ANY DO
    lockcount = GEN_ID(spTestLocked,-1); /* s.o. */
  exit;
END^</programlisting>

      <para><emphasis role="bold">Hinweis:</emphasis> Ich bin mir nicht 100%ig
      sicher, ob dies im Mehrbenutzerbetrieb jederzeit sauber funktioniert,
      aber es sieht recht "schusssicher" aus - so lange kein EXIT im normalen
      Prozedurrumpf vorkommt, denn dann würde die Prozedur mittendrin
      verlassen werden und der Blockade-Generator würde inkrementiert
      stehenbleiben. Die WHEN ANY-Klausel behandelt Ausnahmen, aber keine
      normalen EXITs. Dann müsste man den Generator von Hand zurücksetzen -
      aber man könnte ihn auch im Prozedurrumpf direkt vor dem EXIT
      herunterzählen. Mit den geeigneten Sicherheitsvorkehrungen fällt mir
      keine Situation ein, wo dieser Mechanismus fehlschlagen würde - falls
      dir eine einfällt, lass es uns wissen!</para>
    </section>
  </section>

  <appendix id="generatorguide-de-dochist">
    <title>Dokumentenhistorie</title>

    <para>Die genaue Dokumentenhistorie wird fortgeschrieben im <filename
    class="directory">manual</filename> -Modul in unserem CVS-Baum; siehe
    <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>4 Apr 2006</date>

          <authorinitials>FI</authorinitials>

          <revdescription>
            <para>Erste Ausgabe.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>7 May 2006</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>SEQUENCE-Syntax und andere Firebird 2-Infos
            hinzugefügt.</para>

            <para>Informationen hinzugefügt über: Die Wichtigkeit des
            Client-Dialekts, den SHOW GENERATOR Befehl und Verwandte, das
            Löschen von Generatoren und die Wiedergewinnung des dadurch
            verlorenen Speichers.</para>

            <para>Folgende Kapitel mehr oder weniger heftig bearbeitet und
            erweitert: <citetitle>Wo werden Generatoren
            gespeichert?</citetitle>, <citetitle>Was ist der maximale Wert
            eines Generators?</citetitle>, <citetitle>Wie viele
            Generatoren...?</citetitle>, <citetitle>Verwendung der
            Generatorbefehle</citetitle>.</para>

            <para>Weitere Bearbeitung, Ergänzungen und Korrekturen in
            verschiedenen Kapiteln, größtenteils in der ersten Hälfte des
            Dokuments. Leichte Überarbeitung in der zweiten Hälfte (beginnend
            mit <citetitle>Generatoren zur Erzeugnug eineindeutiger
            Datensatz-IDs</citetitle>).</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2-de</revnumber>

          <date>4. Dezember 2006</date>

          <authorinitials>FI</authorinitials>

          <revdescription>
            <para>Deutsche Übersetzung basierend auf der englischen
            Dokumentenversion 0.2.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="generatorguide-de-license">
    <title>Lizenzhinweis</title>

    <para>Der Inhalt dieser Dokumentation unterliegt der "Public Documentation
    License Version 1.0" (der <quote>Lizenz</quote>); die Dokumentation darf
    nur unter Respektierung dieser Lizenz genutzt werden. Kopien der Lizenz
    sind verfügbar unter <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) und <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>Die Original-Dokumentation trägt den Titel <citetitle>Firebird
    Generator Guide</citetitle>.</para>

    <para>Der ursprünglich Autor der Original-Dokumentation ist: Frank
    Ingermann.</para>

    <para>Copyright (C) 2006. Alle Rechte vorbehalten. Kontakt zum
    Original-Autor: frank at fingerman dot de.</para>

    <para>Co-Autor: Paul Vinkenoog – siehe <link
    linkend="generatorguide-de-dochist">document history</link>.</para>

    <para>Von Paul Vinkenoog beigetragene Teile sind Copyright (C) 2006. Alle
    Rechte vorbehalten. Co-Autor Kontakt: paul at vinkenoog dot nl.</para>
  </appendix>
</article>