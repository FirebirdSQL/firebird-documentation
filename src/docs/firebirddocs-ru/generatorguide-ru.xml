<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
    "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<article id="generatorguide-ru" lang="ru">
  <articleinfo>
    <title>Использование генераторов в СУБД Firebird</title>

    <titleabbrev>Генераторы в Firebird</titleabbrev>

    <subtitle>Как и когда нужно использовать генераторы в СУБД Firebird</subtitle>

    <author>
      <firstname>Frank</firstname>

      <surname>Ingermann</surname>
    </author>

    <othercredit class="translator">
      <firstname>Сергей</firstname>

      <surname>Ковалёв</surname>

      <contrib>Перевод документа на русский язык</contrib>
    </othercredit>

    <edition>29 октября 2006 – Версия документа 0.2-ru</edition>
  </articleinfo>

  <section id="generatorguide-intro-ru">
    <title>Введение</title>

    <section id="generatorguide-intro-about-ru">
      <title>О чем эта статья?</title>

      <para>Эта статья объясняет, что такое генераторы в СУБД Firebird, как и
      почему вы должны использовать их. В этой статье предпринята попытка
      собрать всю информацию, относящуюся к генераторам, в одном месте.</para>
    </section>

    <section id="generatorguide-intro-forwhom-ru">
      <title>Кому нужно это прочитать?</title>

      <para>Прочтите эту статью, если вы:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para>не знакомы с концепцией генераторов;</para>
        </listitem>

        <listitem>
          <para>имеете вопросы по использованию генераторов;</para>
        </listitem>

        <listitem>
          <para>хотите создать поле типа Integer, наподобие поля с
          <quote>автоинкрементом</quote>, которые есть в других СУБД;</para>
        </listitem>

        <listitem>
          <para>ищите примеры того, как использовать генераторы для
          идентификаторов (ID) или для других задач;</para>
        </listitem>

        <listitem>
          <para>хотите узнать, что в СУБД Firebird является аналогом понятия
          <quote>sequence</quote> из СУБД Oracle.</para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="generatorguide-basics-ru">
    <title>Основные положения о генераторах</title>

    <section id="generatorguide-basics-whatis-ru">
      <title>Что такое генератор?</title>

      <para>Думайте о генераторе, как о
      <quote>потокобезопасном</quote> (<quote>thread-safe</quote>)
      целочисленном счетчике, который расположен внутри базы данных Firebird. Вы
      можете создать его, задав имя:</para>

      <programlisting>CREATE GENERATOR GenTest;</programlisting>

      <para>Затем вы можете получать его текущее значение, увеличивать его или
      уменьшать точно так же, как и переменную <quote>var i: integer</quote> в
      Delphi, однако не всегда можно просто установить определенное значение, а
      затем получить то же самое значение, как вы ожидаете, - генератор находится внутри
      базы данных, но <emphasis>вне механизма управления
      транзакциями</emphasis>.</para>
    </section>

    <section id="generatorguide-basics-sequence-ru">
      <title>Что такое последовательность (sequence)?</title>

      <para><quote>Последовательность</quote> (<quote>sequence</quote>) - это
      официальный термин SQL для обозначения того, что в СУБД Firebird называется генератором.
      Поскольку СУБД Firebird постоянно стремиться к большему соответствию
      стандарту SQL, то в СУБД Firebird 2 и более поздних версиях ключевое слово
      <database>SEQUENCE</database> может быть использован как синоним
      <database>GENERATOR</database>. Фактически, рекомендуется использовать
      синтаксис <database>SEQUENCE</database> во вновь создаваемом коде.</para>

      <para>Хотя слово <quote>последовательность</quote> подразумевает серию
      генерируемых значений, в то время как <quote>генератор</quote>
      подразумевает прямую ссылку на фабрику по производству значений,
      в СУБД Firebird <emphasis>нет никаких различий</emphasis> между
      генератором и последовательностью. Просто это два названия для одного и
      того же объекта базы данных. Вы можете создавать генератор и получать
      доступ к нему с помощью синтаксиса последовательности, и наоборот.</para>

      <para>Вот предпочтительный синтаксис для создания
      генератора/последовательности в СУБД Firebird 2:</para>

      <programlisting>CREATE SEQUENCE SeqTest;</programlisting>
    </section>

    <section id="generatorguide-basics-storage-ru">
      <title>Где хранятся генераторы?</title>

      <para><emphasis>Декларации</emphasis> генераторов хранятся в системной
      таблице <database>RDB$GENERATORS</database>. Однако, их
      <emphasis>значения</emphasis> хранятся на специальных зарезервированных
      страницах внутри базы данных. Вы никогда не получите доступ к этим
      значениям напрямую. Вы можете получить к ним доступ с помощью
      специальных встроенных функций, которые будут обсуждаться далее в этом
      руководстве.</para>

      <warning>
        <para>Приведенная в этом разделе информация предназначена только для
        общего ознакомления. Общее правило таково: вы не должны обращаться к
        системным таблицам напрямую. Не пытайтесь создавать или изменять
        генераторы путем изменения таблицы <database>RDB$GENERATORS</database>.
        (Хотя оператор <database>SELECT</database> и не наделает бед.)</para>
      </warning>

      <para>Структура системной таблицы <database>RDB$GENERATORS</database>
      следующая:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>RDB$GENERATOR_NAME</database>
          <database>CHAR(31)</database></para>
        </listitem>

        <listitem>
          <para><database>RDB$GENERATOR_ID</database>
          <database>SMALLINT</database></para>
        </listitem>

        <listitem>
          <para><database>RDB$SYSTEM_FLAG</database>
          <database>SMALLINT</database></para>
        </listitem>
      </itemizedlist>

      <para>И для СУБД Firebird 2.0 и более старших версий:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><database>RDB$DESCRIPTION</database> <database>BLOB subtype
          TEXT</database></para>
        </listitem>
      </itemizedlist>

      <para>Обратите внимание, что <database>GENERATOR_ID</database>
      является идентификатором для каждого генератора (о чем и говорит это имя), а
      <emphasis>не</emphasis> его значением. Также, не позволяйте вашему
      приложения хранить идентификатор для будущего использования в качестве маркера
      (handle) генератора. Это не имеет смысла (так как
      <emphasis>имя</emphasis> и является маркером), идентификатор может измениться после
      цикла резервного копирования/восстановления базы данных. Флаг
      <database>SYSTEM_FLAG</database> равен 1 для генераторов, используемых
      внутри СУБД, и <constant>NULL</constant> или 0 для всех, созданных
      вами.</para>

      <para>Теперь давайте взглянем на таблицу
      <database>RDB$GENERATORS</database>, когда определен единственный
      генератор:</para>

      <informaltable>
        <tgroup cols="3">
          <colspec colname="colGenName" colwidth="5*" />

          <colspec align="center" colname="colGenID" colwidth="4*" />

          <colspec align="center" colname="colSysFlag" colwidth="4*" />

          <thead>
            <row>
              <entry align="center">RDB$GENERATOR_NAME</entry>

              <entry align="center">RDB$GENERATOR_ID</entry>

              <entry align="center">RDB$SYSTEM_FLAG</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>RDB$SECURITY_CLASS</entry>

              <entry>1</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>SQL$DEFAULT</entry>

              <entry>2</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$PROCEDURES</entry>

              <entry>3</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$EXCEPTIONS</entry>

              <entry>4</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$CONSTRAINT_NAME</entry>

              <entry>5</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$FIELD_NAME</entry>

              <entry>6</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$INDEX_NAME</entry>

              <entry>7</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>RDB$TRIGGER_NAME</entry>

              <entry>8</entry>

              <entry>1</entry>
            </row>

            <row>
              <entry>MY_OWN_GENERATOR</entry>

              <entry>9</entry>

              <entry><constant>NULL</constant></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <note>
        <title>Примечание для СУБД Firebird 2</title>

        <itemizedlist>
          <listitem>
            <para>В СУБД Firebird 2 введен дополнительный системный генератор,
            называемый <database>RDB$BACKUP_HISTORY</database>. Он
            используется для новой утилиты NBackup.</para>
          </listitem>

          <listitem>
            <para>Несмотря на то, что синтаксис <database>SEQUENCE</database>
            предпочтителен, системная таблица
            <database>RDB$GENERATORS</database> и ее поля не были
            переименованы в СУБД Firebird 2.</para>
          </listitem>
        </itemizedlist>
      </note>
    </section>

    <section id="generatorguide-basics-maxval-ru">
      <title>Каково максимальное значение генератора?</title>

      <para>Генераторы хранят и возвращают 64-битные значения во всех версиях
      СУБД Firebird. Это дает диапазон значений:</para>

      <blockquote>
        <para>-2<superscript>63</superscript> .. 2<superscript>63</superscript>-1 или
        -9.223.372.036.854.775.808 .. 9.223.372.036.854.775.807</para>
      </blockquote>

      <para>Таким образом, если вы используете генератор с начальным значением
      0 для заполнения поля типа <database>NUMERIC(18)</database> или <database>BIGINT</database>
      (оба типа представлены 64-битным целым), и вы хотели бы добавлять
      1000 строк в секунду, то пройдет около 300 миллионов лет (!), прежде чем
      значения выйдут за указанный диапазон. Поскольку довольно маловероятно, что человечество
      еще будет существовать на планете в это время (и оно все еще будет
      использовать базы данных СУБД Firebird), то не следует об этом
      беспокоиться.</para>

      <para>Но хочу предупредить. СУБД Firebird понимает два
      <quote>диалекта</quote> SQL: диалект 1 и диалект 3. Новые базы данных должны
      всегда создаваться с диалектом 3, который является более мощным в ряде
      аспектов. Диалект 1 является диалектом совместимости, он используется
      только для полученных в наследство баз данных, которые были созданы в
      InterBase 5.6 или в более ранних версиях.</para>

      <para>Одним из различий этих двух диалектов является то, что диалект 1
      не имеет поддержки встроенных 64-битных целочисленных типов.
      Поля типа <database>NUMERIC(18)</database>, например, хранятся во
      внутреннем представлении как <database>DOUBLE PRECISION</database>,
      который является типом с плавающей точкой. Наибольший целочисленный тип
      в диалекте 1 - это 32-битный <database>INTEGER</database>.</para>

      <para>В диалекте 1, как и в диалекте 3, генераторы являются 64-битными. Но если
      вы присвоите сгенерированное значение полю типа INTEGER в базе
      данных диалекта 1, оно будет урезано до младших 32 бит, в результате давая
      диапазон:</para>

      <blockquote>
        <para>-2<superscript>31</superscript> .. 2<superscript>31</superscript>-1 или
        -2.147.483.648 .. 2.147.483.647</para>
      </blockquote>

      <para>Хотя сам генератор может давать значения и 2.147.483.647, и
      2.147.483.648, и так далее, урезанное значение вызовет повторение
      значений в этом месте, давая <emphasis>эффект</emphasis> 32-битного
      генератора.</para>

      <para>В описанной выше ситуации, при 1000 вставках в секунду,
      заполняемое генератором поле переберет все значения через 25
      <emphasis>дней</emphasis> (!!!), и за этим действительно нужно следить.
      2<superscript>31</superscript> - это очень много, но насколько это
      много, зависит от ситуации.</para>

      <note>
        <para>В диалекте 3, если вы присваиваете значение генератора полю типа
        <database>INTEGER</database>, то все идет хорошо, если значение
        умещается в 32-битный диапазон. Но, как только этот диапазон будет
        превышен, вы получите ошибку переполнения: диалект 3 более строг в
        проверке диапазона по сравнению с диалектом 1!</para>
      </note>

      <section>
        <title>Диалект клиентов и значения генераторов</title>

        <para>При общении с сервером СУБД Firebird клиент может установить как
        диалект 1, так и диалект 3, независимо от того, к какой базе данных он
        подключен. Именно диалект клиента, а <emphasis>не</emphasis> диалект базы
        данных, определяет как СУБД Firebird передает значение генератора
        клиенту:</para>

        <itemizedlist>
          <listitem>
            <para>Если диалект клиента 1, сервер возвращает клиенту значение
            генератора в виде урезанного 32-битного целого. Но внутри базы
            данных сгенерированные значения остаются 64-битными, и они не зацикливаются
            после достижения 2<superscript>31</superscript>-1 (даже
            если это так выглядит на стороне клиента). Это верно для баз
            данных и диалекта 1, и диалекта 3.</para>
          </listitem>

          <listitem>
            <para>Если диалект клиента 3, сервер передает полное 64-битное
            значение клиенту. Опять-таки, это верно для баз данных и
            диалекта 1, и диалекта 3.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="generatorguide-basics-howmany-ru">
      <title>Сколько генераторов доступно для одной базы данных?</title>

      <para>Начиная с СУБД Firebird версии 1.0, количество генераторов, которые вы
      можете создать в одной базе данных, ограничено только максимальным
      значением идентификатора (ID) в системной таблице <database>RDB$GENERATORS</database>.
      Так как это <database>SMALLINT</database>, то его максимальное значение равно
      2<superscript>15</superscript>-1 или 32767. Первое значение идентификатора всегда 1,
      так что полное количество генераторов не может превышать 32767. Как
      указывалось выше, в базе данных есть восемь или девять системных генераторов,
      таким образом остается, по крайней мере, 32758 для ваших собственных
      генераторов. Это должно быть достаточно для любого практического
      приложения. И так как количество декларируемых вами генераторов, не
      влияет на производительность, то вы можете чувствовать себя свободным и
      использовать столько генераторов, сколько хотите.</para>

      <section>
        <title>Старые версии InterBase и Firebird</title>

        <para>В ранних версия СУБД Firebird до версии 1.0, также, как и в СУБД InterBase, для
        хранения значений генераторов использовалась только одна страница базы
        данных. Поэтому, количество доступных генераторов было ограничено
        размером страницы базы данных. Следующая таблица перечисляет, сколько
        генераторов (включая системные) вы можете использовать в этих версиях
        СУБД InterBase и Firebird (спасибо Полу Ривзу [Paul Reeves] за предоставление
        оригинальной информации):</para>

        <informaltable>
          <tgroup cols="5">
            <colspec colname="colVersion" colwidth="2*" />

            <colspec align="center" colname="col1k" />

            <colspec align="center" colname="col2k" />

            <colspec align="center" colname="col4k" />

            <colspec align="center" colname="col8k" />

            <spanspec nameend="col8k" namest="col1k" spanname="spanpagesize" />

            <thead>
              <row>
                <entry align="center">Версия</entry>

                <entry align="center" spanname="spanpagesize">Размер
                страницы</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>&nbsp;</entry>

                <entry align="center"><emphasis>1K</emphasis></entry>

                <entry align="center"><emphasis>2K</emphasis></entry>

                <entry align="center"><emphasis>4K</emphasis></entry>

                <entry align="center"><emphasis>8K</emphasis></entry>
              </row>

              <row>
                <entry><emphasis>InterBase &lt; v.6</emphasis></entry>

                <entry>247</entry>

                <entry>503</entry>

                <entry>1015</entry>

                <entry>2039</entry>
              </row>

              <row>
                <entry><emphasis>IB 6 и версии Firebird до 1.0
                </emphasis></entry>

                <entry>123</entry>

                <entry>251</entry>

                <entry>507</entry>

                <entry>1019</entry>
              </row>

              <row>
                <entry><emphasis>Все последующие версии
                Firebird</emphasis></entry>

                <entry align="center" spanname="spanpagesize">32767</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>

        <para>В СУБД InterBase до версии 6 генераторы были только 32-битные. Это
        объясняет, почему в старых версиях можно хранить ровно в два раза
        больше генераторов при одном и том же размере страницы.</para>

        <warning>
          <para>СУБД InterBase, по крайней мере, до версии 6.01 включительно,
          успешно позволяет вам <quote>создавать</quote> генераторы до тех
          пор, пока их общее количество не достигнет 32767. Что произойдет,
          если вы обратитесь к генератору с идентификатором б<emphasis>о</emphasis>льшим, чем номер, указанный в
          приведенной выше таблице, зависит от версии:</para>

          <itemizedlist>
            <listitem>
              <para>InterBase 6 генерирует ошибку <quote>invalid block
              type</quote> (неверный тип блока), поскольку вычисляемое
              значение расположено вне страницы, которая зарезервирована под
              генераторы.</para>
            </listitem>

            <listitem>
              <para>В более ранних версиях, если вычисляемое место расположено вне
              страниц базы данных, возвращается ошибка. В противном случае, если
              генератор только <emphasis>читается</emphasis> (без инкремента),
              его значение представляет из себя то, что расположено по
              вычисленному месту (вычисленной странице базы данных). Если значение было
              <emphasis>записано</emphasis>, при этом перезапишутся данные,
              расположенные в вычисленном месте.
              Иногда это приводит к немедленной ошибке, но чаще всего это
              приводит к молчаливой порче вашей базы данных.</para>
            </listitem>
          </itemizedlist>
        </warning>
      </section>
    </section>

    <section id="generatorguide-basics-transactions-ru">
      <title>Генераторы и транзакции</title>

      <para>Как уже было сказано, генераторы находятся вне механизма управления
      транзакциями. Это означает, что вы не можете безопасно
      <quote>откатить</quote> генератор внутри транзакции. Одновременно с
      вашей транзакцией может существовать другая транзакция, выполняющая в то
      же самое время изменение значения генератора. Так что, если вы запросили
      значение генератора, думайте о нем, как об <quote>ушедшем
      навсегда</quote>.</para>

      <para>Когда вы запускаете транзакцию, а затем вызываете генератор и
      получаете значение (скажем, 5), генератор останется на том же самом
      значении, <emphasis role="bold">даже если вы выполните откат
      транзакции (!)</emphasis>. Даже <emphasis>не смейте думать</emphasis> так:
      <quote>Ну, хорошо, когда я выполню откат, я просто вместе с этим выполню
      <database>GEN_ID</database>(mygen,-1), чтобы снова установить
      генератор в значение 4</quote>. Чаще всего это может сработать, но это
      <emphasis>не безопасно</emphasis>, поскольку другая конкурентная
      транзакция может изменить значение генератора в период времи между вашим
      обращением к генератору и откатом транзакции. По этой же причине не
      имеет смысла получать текущее значение с помощью
      <database>GEN_ID</database>(mygen,0), а затем увеличивать это значение
      на стороне клиента.</para>
    </section>
  </section>

  <section id="generatorguide-sqlsyntax-ru">
    <title>Операторы SQL для генераторов</title>

    <section id="generatorguide-sqlsyntax-overview-ru">
      <title>Обзор операторов</title>

      <para>Имя генератора должно являться обычным идентификатором метаданных базы
      данных: максимум 31 символ, без специальных символов за исключением
      символа подчеркивания <quote>_</quote> (если вы не используете регистрозависимые
      идентификаторы в кавычках). Команды и операторы SQL, применяемые к
      генераторам, перечислены ниже. Их использование более подробно будет
      описано в разделе <citetitle><link
      linkend="generatorguide-sqlsyntax-use-ru">Использование операторов для
      генераторов</link></citetitle>.</para>

      <para>Операторы DDL (Data Definition Language - язык определения
      данных):</para>

      <programlisting>CREATE GENERATOR &lt;name&gt;;
SET GENERATOR &lt;name&gt; TO &lt;value&gt;;
DROP GENERATOR &lt;name&gt;;</programlisting>

      <para>Операторы DML (Data Manipulation Language - язык манипуляции данными)
      в клиентском SQL:</para>

      <programlisting>SELECT GEN_ID(&lt;GeneratorName&gt;, &lt;increment&gt;) FROM RDB$DATABASE;</programlisting>

      <para>Операторы DML в PSQL (Procedural SQL - процедурный SQL - расширение языка,
      используемое в хранимых процедурах и триггерах):</para>

      <programlisting>&lt;intvar&gt; = GEN_ID(&lt;GeneratorName&gt;, &lt;increment&gt;);</programlisting>

      <section>
        <title>Синтаксис, рекомендованный для Firebird 2</title>

        <para>Хотя в СУБД Firebird 2 все еще полностью поддерживается традиционный
        синтаксис, существует рекомендуемый DDL-эквивалент для СУБД Firebird
        2:</para>

        <programlisting>CREATE SEQUENCE &lt;name&gt;;
ALTER SEQUENCE &lt;name&gt; RESTART WITH &lt;value&gt;;
DROP SEQUENCE &lt;name&gt;;</programlisting>

        <para>А для операторов DML:</para>

        <programlisting>SELECT NEXT VALUE FOR &lt;SequenceName&gt; FROM RDB$DATABASE;</programlisting>

        <programlisting>&lt;intvar&gt; = NEXT VALUE FOR &lt;SequenceName&gt;;</programlisting>

        <para>В настоящее время рекомендуемый синтаксис не поддерживает шаг изменения
        (инкремент), отличный от 1. Это ограничение будет снято в будущих версиях.
        Пока используйте <database>GEN_ID</database>, если вы хотите
        использовать другое значение для шага изменения значения.</para>
      </section>
    </section>

    <section id="generatorguide-sqlsyntax-use-ru">
      <title>Использование операторов для генераторов</title>

      <para>Доступность операторов и функций зависит от того, где вы
      их используете:</para>

      <itemizedlist>
        <listitem>
          <para>Клиентский SQL – используемый вами язык, когда вы, в качестве
          клиента, общаетесь с сервером СУБД Firebird.</para>
        </listitem>

        <listitem>
          <para>PSQL – язык программирования на стороне сервера, используемый
          в хранимых процедурах и триггерах СУБД Firebird.</para>
        </listitem>
      </itemizedlist>

      <section id="generatorguide-sqlsyntax-create-ru">
        <title>Создание генератора (<quote>Insert</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Клиентский SQL</term>

            <listitem>
              <programlisting>CREATE GENERATOR &lt;GeneratorName&gt;;</programlisting>

              <para>Предпочтительно для СУБД Firebird 2 и старше:</para>

              <programlisting>CREATE SEQUENCE &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <para>Невозможно. Так как вы не можете изменять метаданные базы
              данных в хранимых процедурах (stored procedures) или триггерах, вы не можете
              создавать генераторы.</para>

              <note>
                <para>В СУБД Firebird 1.5 и старше вы можете обходить это ограничение с
                помощью оператора <database>EXECUTE STATEMENT</database>.</para>
              </note>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-getvalue-ru">
        <title>Получение текущего значения (<quote>Select</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Клиентский SQL</term>

            <listitem>
              <programlisting>SELECT GEN_ID(&lt;GeneratorName&gt;, 0) FROM RDB$DATABASE;</programlisting>

              <para>Этот синтаксис является единственной возможностью получить текущее
              значение генератора в СУБД Firebird 2.</para>

              <note>
                <para>В утилите для СУБД Firebird <emphasis>isql</emphasis>
                есть две дополнительные команды для получения
                текущего значения генератора:</para>

                <blockquote>
                  <programlisting>SHOW GENERATOR &lt;GeneratorName&gt;;
SHOW GENERATORS;</programlisting>
                </blockquote>

                <para>Первая показывает текущее значение конкретного
                генератора. Вторая команда делает то же самое для всех не
                системных генераторов базы данных.</para>

                <para>Предпочтительный для СУБД Firebird 2 эквивалент, как вы
                можете предположить:</para>

                <blockquote>
                  <programlisting>SHOW SEQUENCE &lt;SequenceName&gt;;
SHOW SEQUENCES;</programlisting>
                </blockquote>

                <para>Пожалуйста, обратите внимание, что команды
                <database>SHOW...</database> доступны только в инструменте
                <application>isql</application>. В отличие от
                <database>GEN_ID</database>, вы не можете использовать их из
                других клиентов (если эти клиенты не используют
                <application>isql</application> в качестве клиента).</para>
              </note>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>&lt;intvar&gt; = GEN_ID(&lt;GeneratorName&gt;, 0);</programlisting>

              <para>СУБД Firebird 2: тот же самый синтаксис.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-genvalue-ru">
        <title>Генерация следующего значения (<quote>Update</quote> +
        <quote>Select</quote>)</title>

        <para>Так же, как и в случае получения текущего значения, это
        выполняется с помощью <database>GEN_ID</database>, но в этом случае вы
        используете значение шага, равное 1. При этом СУБД Firebird:</para>

        <orderedlist spacing="compact">
          <listitem>
            <para>получает текущее значение генератора;</para>
          </listitem>

          <listitem>
            <para>увеличивает его на 1;</para>
          </listitem>

          <listitem>
            <para>возвращает измененное значение.</para>
          </listitem>
        </orderedlist>

        <variablelist>
          <varlistentry>
            <term>Клиентский SQL</term>

            <listitem>
              <programlisting>SELECT GEN_ID(&lt;GeneratorName&gt;, 1) FROM RDB$DATABASE;</programlisting>

              <para>Новый синтаксис, который предпочтителен для СУБД Firebird 2,
              полностью отличается:</para>

              <programlisting>SELECT NEXT VALUE FOR &lt;SequenceName&gt; FROM RDB$DATABASE;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>&lt;intvar&gt; = GEN_ID(&lt;GeneratorName&gt;, 1);</programlisting>

              <para>Предпочтительно для СУБД Firebird 2 и старше:</para>

              <programlisting>&lt;intvar&gt; = NEXT VALUE FOR &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-setvalue-ru">
        <title>Прямое указание определенного значения генератора
        (<quote>Update</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Клиентский SQL</term>

            <listitem>
              <programlisting>SET GENERATOR &lt;GeneratorName&gt; TO &lt;NewValue&gt;;</programlisting>

              <para>Это удобно для установки в генераторе значения, отличного
              от 0 (которое является значением по умолчанию после его
              создания), например, в скрипте для создания базы данных.
              Аналогично <database>CREATE GENERATOR</database>, это оператор DDL
              (не DML).</para>

              <para>Предпочтительный синтаксис для СУБД Firebird 2 и старше:</para>

              <programlisting>ALTER SEQUENCE &lt;SequenceName&gt; RESTART WITH &lt;NewValue&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <programlisting>GEN_ID(&lt;GeneratorName&gt;, &lt;NewValue&gt; - GEN_ID(&lt;GeneratorName&gt;, 0));</programlisting>

              <warning>
                <para>Это больше похоже на <quote>грязный трюк</quote> в
                попытке сделать то, что в обычных условиях сделать нельзя и не
                д<emphasis>о</emphasis>лжно в хранимых процедурах и триггерах:
                <emphasis>установка</emphasis> значений генераторов. В них
                можно <emphasis>получать</emphasis>, а не
                <emphasis>устанавливать</emphasis> значения.</para>

                <!--Также это кажется мне не безопасным, поскольку вся операция не атомарна!
А что, если другой поток (thread)/клиент изменит генератор после первого вызова GEN_ID?-->
              </warning>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section id="generatorguide-sqlsyntax-drop-ru">
        <title>Удаление генератора (<quote>Delete</quote>)</title>

        <variablelist>
          <varlistentry>
            <term>Клиентский SQL</term>

            <listitem>
              <programlisting>DROP GENERATOR &lt;GeneratorName&gt;;</programlisting>

              <para>Предпочтительно для СУБД Firebird 2 и старше:</para>

              <programlisting>DROP SEQUENCE &lt;SequenceName&gt;;</programlisting>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>PSQL</term>

            <listitem>
              <para>Невозможно, поскольку... (То же самое объяснение, что и для
              создания: вы не можете [или, скорее, не должны] изменять
              метаданные в PSQL.)</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Удаление генератора не освобождает место, которое он занимает,
        для использования нового генератора. На практике это редко приводит к проблемам,
        поскольку большинство баз данных не имеют десятков тысяч генераторов,
        которые позволяет создавать СУБД Firebird. Но если ваша база данных
        <emphasis>рискует</emphasis> превысить 32767 генераторов, вы можете
        освободить место неиспользуемых генераторов путем выполнения операции
        резервного копирования/восстановления базы данных (backup/restore). При этом
        аккуратно упаковывается таблица <database>RDB$GENERATORS</database>,
        переназначаются идентификаторы (ID), образуя непрерывную последовательность. В
        зависимости от ситуации, восстановленной базе данных может
        понадобиться меньше страниц для хранения значений генераторов.</para>

        <section>
          <title>Удаление генераторов в старых версиях IB и Firebird</title>

          <para>СУБД InterBase 6 и более ранние версии, точно так же, как и
          ранние версии СУБД Firebird, предшествующие версии 1.0, не имеют команды <database>DROP
          GENERATOR</database>. Единственным способом удалить генератор
          является оператор:</para>

          <programlisting>DELETE FROM RDB$GENERATORS WHERE RDB$GENERATOR_NAME = '&lt;GeneratorName&gt;';</programlisting>

          <para>...с последующим циклом резервирования/восстановления базы данных
          (backup/restore).</para>

          <para>Для этих версий СУБД с максимальным количеством генераторов
          около пары сотен гораздо более вероятно появление необходимости
          использованть место от удаленных генераторов.</para>
        </section>
      </section>
    </section>
  </section>

  <section id="generatorguide-rowids-ru">
    <title>Использование генераторов для создания уникальных идентификаторов
    строк</title>

    <titleabbrev>Генераторы для создания идентификаторов строк</titleabbrev>

    <section id="generatorguide-rowids-why-ru">
      <title>Зачем вообще нужны идентификаторы (ID)?</title>

      <para>Ответ на этот вопрос выходит далеко за пределы темы этой статьи.
      Если вы не видите необходимости иметь общий, уникальный
      <quote>маркер</quote> (handle) для каждой строки внутри таблицы, или вам
      вообще не нравится идея <quote>бессмысленных</quote> или
      <quote>суррогатных</quote> (искусственных) ключей, вам, вероятно, лучше пропустить этот
      раздел...</para>
    </section>

    <section id="generatorguide-rowids-howmanygens-ru">
      <title>Один для всего или один для каждого?</title>

      <para>Хорошо... Итак, вы хотите использовать идентификаторы. { примечание автора: мои
      поздравления! :-) }</para>

      <para>Основной, наиболее важный выбор, который вам нужно сделать, - это
      использовать единый генератор для всех таблиц или один генератор для
      каждой таблицы. Это только ваш выбор, но примите во внимание следующие
      размышления.</para>

      <para>В подходе <quote>один для всех</quote> вы: <itemizedlist spacing="compact">
          <listitem>
            <para>+ нуждаетесь только в одном генераторе для всех ваших
            ID;</para>
          </listitem>

          <listitem>
            <para>+ имеете одно целочисленное значение, которое не только
            однозначно идентифицирует строку внутри самой
            <emphasis>таблицы</emphasis>, но и внутри <emphasis>всей базы
            данных</emphasis>;</para>
          </listitem>

          <listitem>
            <para>- имеете меньшее количество значений ID на таблицу (на самом
            деле это не проблема для 64-битных генераторов...);</para>
          </listitem>

          <listitem>
            <para>- будете иметь дело с большими значениями ID, даже если,
            например, просматриваете таблицу с горсткой записей;</para>
          </listitem>

          <listitem>
            <para>- вероятно, будете видеть пробелы в последовательности ID
            каждой таблицы, так как значения генератора распределены между
            всеми таблицами.</para>
          </listitem>
        </itemizedlist></para>

      <para>В подходе <quote>один для каждой</quote> вы: <itemizedlist spacing="compact">
          <listitem>
            <para>- должны создавать генератор для каждого идентификатора
            таблицы вашей базы данных;</para>
          </listitem>

          <listitem>
            <para>- всегда должны комбинировать ID и имя таблицы для
            уникальной идентификации строки в таблице;</para>
          </listitem>

          <listitem>
            <para>+ имеете простой и надежный <quote>счетчик вставок</quote>
            для таблицы;</para>
          </listitem>

          <listitem>
            <para>+ имеете хронологическую последовательность для таблицы:
            если вы найдете пробелы в последовательности ID таблицы, то они
            появилась либо из-за удаления (<database>DELETE</database>), либо
            при неудачной вставке (<database>INSERT</database>).</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section id="generatorguide-rowids-reusevals-ru">
      <title>Можно ли использовать значения генератора повторно?</title>

      <para>В действительности – да, технически это
      <emphasis>возможно</emphasis>. В реальности – НЕТ, вы не должны.
      Никогда. Ни при каких условиях. Не только потому, что это может нарушить
      красоту хронологической последовательности (вы не сможете более судить о
      <quote>возрасте</quote> строки, взглянув на ее ID), а еще и потому, что повышается риск
      появления сильной головной боли, которую вы при этом получите. Более того, это
      абсолютно противоречит всей концепции уникального идентификатора
      строки.</para>

      <para>Так что если у вас нет веских причин для повторного использования
      значений генератора и хорошо продуманного механизма, который безопасно
      сделает эту работу в многопользовательской/многотранзакционной среде, НЕ
      ДЕЛАЙТЕ ЭТОГО!</para>
    </section>

    <section id="generatorguide-rowids-autoinc-ru">
      <title>Генераторы для идентификации, или автоинкрементные поля</title>

      <para>Указание ID для вновь вставляемой записи (в терминах уникальности
      - <quote>серийный номер</quote>) легче всего выполнить с помощью
      генератора и триггера <quote>перед вставкой</quote> (Before Insert trigger), как мы
      увидим в этом разделе. Предположим, что у нас есть таблица
      <database>TTEST</database> с колонкой ID, объявленной как Integer. Имя
      нашего генератора: <database>GIDTEST</database>.</para>

      <section>
        <title>Триггер Before Insert, версия 1</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V1 for TTEST
active before insert position 0
as
begin
  new.id = gen_id(gidTest, 1);
end</programlisting>

        <para>Проблемы этого триггера (версии 1):</para>

        <para>Он правильно делает свою работу, но он также
        <quote>тратит</quote> значение генератора в том случае, когда ID уже
        указан в операторе <database>INSERT</database>. Так что более
        эффективно было бы присваивать значение, когда ничего не было указано
        в <database>INSERT</database>:</para>
      </section>

      <section>
        <title>Триггер Before Insert, версия 2</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V2 for TTEST
active before insert position 0
as
begin
  if (new.id is null) then
  begin
    new.id = gen_id(gidTest, 1);
  end
end</programlisting>

        <para>Проблемы этого триггера (версии 2):</para>

        <para>Некоторые компоненты доступа имеют <quote>плохую
        привычку</quote> автоматического заполнения колонок при выполнении
        <database>INSERT</database>. Если вы явно не указали, они
        устанавливают значение по умолчанию - обычно это 0 для колонок
        целочисленного типа. В этом случае приведенный выше триггер не будет
        работать: он будет обнаруживать, что колонка ID не находится в
        <emphasis>состоянии</emphasis> <constant>NULL</constant>, а имеет
        <emphasis>значение</emphasis> 0, и поэтому не будет генерировать новое
        значение ID. Вы сможете вставить запись, но только одну: вставка
        второй записи окончится неудачей. В любом случае, хорошей идеей будет
        запрет значения 0 в качестве обычного значения ID, чтобы предотвратить любую
        неоднозначность между <constant>NULL</constant> и 0. Вы можете
        использовать, например, специальную строку с ID, равным 0, для хранения
        записи <quote>по умолчанию</quote> в каждой таблице.</para>
      </section>

      <section>
        <title>Триггер Before Insert, версия 3</title>

        <programlisting>CREATE TRIGGER trgTTEST_BI_V3 for TTEST
active before insert position 0
as
begin
  if ((new.id is null) or (new.id = 0)) then
  begin
    new.id = gen_id(gidTest, 1);
  end
end</programlisting>

        <para>Хотя теперь у нас есть понятный, работающий триггер для ID,
        следующие абзацы объяснят вам, почему вы чаще всего не захотите им
        пользоваться.</para>

        <para>Основная проблема с присваиванием ID в триггере <quote>перед вставкой</quote>
        состоит в том, что значение генерируется на стороне сервера,
        <emphasis>после того</emphasis>, как вы отправили оператор добавления
        с клиента. Очевидно, это означает, что нет безопасного способа для
        клиента узнать, какой ID был сгенерирован для только что вставленной
        вами строки.</para>

        <para>Вы можете попытаться получить значение генератора на стороне
        клиента после вставки, но в многопользовательской среде вы не можете
        быть уверены, что вы получили свой собственный ID строки (из-за
        вопросов с транзакциями).</para>

        <para>Но если вы <emphasis>сначала</emphasis> получите новое значение
        генератора и передадите его при вставке, вы можете просто получить эту
        новую запись с помощью <quote>Select ... where ID = &lt;genvalue&gt;</quote>,
        чтобы увидеть, какие умолчания были применены, или какие колонки были
        изменены триггерами при вставке. Это особенно хорошо работает,
        поскольку у вас обычно есть уникальный индекс для первичного ключа (Primary Key) по полю
        ID, а это наиболее быстрый индекс, который только может быть, - у него
        идеальная селективность и он гораздо меньше, чем индекс для колонки
        <database>CHAR(n)</database> (для n&gt;8, в зависимости от кодировки и
        порядка сортировки [collation]).</para>

        <para>Из этого получаем вывод:</para>

        <para>Вы должны создавать триггер <quote>перед вставкой</quote>, чтобы быть абсолютно
        уверенным, что каждая строка получит уникальный ID, даже если значение
        ID не указано на стороне клиента в операторе вставки.</para>

        <para>Если ваша база данных <quote>закрыта для SQL</quote> (то есть
        только ваше собственное приложение может стать источником вставки
        новых записей), то вы можете отказаться от триггеров, но при этом вы
        должны <emphasis>всегда</emphasis> получать новое значение генератора
        из базы данных прежде, чем выполните оператор вставки, и включать
        полученное значение в этот оператор. То же самое, конечно же,
        относится для вставок из триггеров и хранимых процедур.</para>
      </section>
    </section>
  </section>

  <section id="generatorguide-misc-ru">
    <title>Что еще делают с помощью генераторов</title>

    <para>Здесь вы можете найти некоторые идеи, как использовать генераторы не
    только для генерации уникальных идентификаторов для строк.</para>

    <section id="generatorguide-misc-uniquenums-ru">
      <title>Использование генераторов для получения, например, уникального
      номера передаваемого файла</title>

      <para><quote>Классическое</quote> использование генераторов должно
      гарантировать уникальность, последовательность чисел, скажем, для любого
      аспекта вашего приложения, отличного от идентификаторов строк,
      обсужденного ранее. Когда у вас есть приложение, которое передает данные
      в некоторую другую систему, вы можете использовать генераторы для
      безопасной идентификации одной сессии передачи, помечая ее
      сгенерированным значением. Это отлично помогает отследить проблемы в
      интерфейсе между двумя системами (и, в отличие от далее упомянутого, это
      работает безопасно и четко).</para>
    </section>

    <section id="generatorguide-misc-usagecount-ru">
      <title>Генераторы, как <quote>счетчик использований</quote> для SP,
      обеспечивающие основную статистику</title>

      <para>Представьте, что вы разработали в базе данных фантастическую новую
      возможность, которая реализована с помощью хранимой процедуры. Теперь вы обновили систему
      покупателя, и некоторое время спустя вы захотите узнать,
      <emphasis>пользуются ли</emphasis> клиенты этой возможностью и как
      часто. Это просто: создайте специальный генератор, который
      инкрементируется в этой хранимой процедуре и вы узнаете это (с учетом
      того ограничения, что вы не сможете узнать количество транзакций,
      которые были откачены после выполнения этой хранимой процедуры). Так что
      в этом случае вы, как минимум, узнаете как часто пользователи
      <emphasis>пробуют</emphasis> пользоваться вашей хранимой процедурой.
      :-)</para>

      <para>В будущем вы сможете усовершенствовать этот метод и использовать
      два генератора: первый изменяется при каждом запуске хранимой процедуры, а второй
      изменяется при окончании работы процедуры, сразу перед выходом из нее
      (<database>EXIT</database>). Таким образом вы сможете посчитать, сколько попыток
      использования процедуры завершилось успехом: если оба генератора имеют одно и
      то же значение, то ни один вызов хранимой процедуры не был неудачен. Конечно же, вы все
      еще не можете узнать, сколько раз транзакция (транзакции), в которой
      использовалась ваша процедура, была реально подтверждена (commit).</para>
    </section>

    <section id="generatorguide-misc-rowcount-ru">
      <title>Генераторы, эмулирующие <quote>Select count(*)
      from...</quote></title>

      <para>В СУБД InterBase и Firebird существует известная проблема, когда
      <database>SELECT COUNT(*)</database> (без выражения <database>Where</database>) для очень
      большой таблицы может очень долго выполняться, так как сервер должен
      посчитать <quote>вручную</quote>, сколько строк есть в таблице во время
      получения запроса. Теоретически, вы легко можете решить эту проблему с
      помощью генераторов:<itemizedlist spacing="compact">
          <listitem>
            <para>создайте специальный генератор для <quote>подсчета
            строк</quote>;</para>
          </listitem>

          <listitem>
            <para>создайте триггер <quote>перед вставкой</quote> (Before Insert),
            который увеличивает его;</para>
          </listitem>

          <listitem>
            <para>создайте триггер <quote>после удаления</quote> (After Delete),
            который уменьшает его.</para>
          </listitem>
        </itemizedlist></para>

      <para>Это прекрасно работает и отменяет необходимость в подсчете
      <quote>полного</quote> количества записей: мы просто получаем текущее
      значение генератора. Я специально подчеркну слово
      <quote><emphasis>теоретически</emphasis></quote>, поскольку в целом
      картина портится, когда какой-нибудь оператор Insert будет отменен, а
      генераторы не <emphasis>подчиняются механизму управления
      транзакциями</emphasis>. Вставка может провалиться из-за ограничений
      (по уникальному ключу, поля <database>NOT NULL</database>,
      указаного как <constant>NULL</constant>, и т. п.) или по другим
      ограничениями метаданных, или просто потому, что транзакция, выполнявшая
      вставку, будет откачена. У вас не будет строк в таблице, а ваш счетчик
      вставок увеличится.</para>

      <para>Так что, смотрите сами – когда вы хотите знать примерный процент
      вставок, завершившихся неудачей (вы можете частично
      <quote>оценить</quote> это), или вас интересует
      <emphasis>примерное</emphasis> количество записей, то этот метод может
      быть очень полезным, даже несмотря на то, что он и не точен. Время от
      времени вы можете выполнять <quote>нормальный</quote> подсчет записей и
      задавать генератору точное значение (<quote>синхронизировать</quote>
      генератор), так что величина ошибки будет достаточно мала.</para>

      <para>Существуют ситуации, когда клиенты достаточно счастливо живут с
      информацией, наподобие <quote>существует <emphasis>примерно</emphasis>
      2,3 миллиарда записей</quote>, появляющейся немедленно по щелчку мыши,
      но они готовы застрелить вас, если они ждут 10 минут или больше для
      того, чтобы увидеть, что существует ровно 2,313,498,229 строк...</para>
    </section>

    <section id="generatorguide-misc-progresscount-ru">
      <title>Генераторы для мониторинга и/или управления долго работающей
      SP</title>

      <para>Когда у вас есть хранимые процедуры, которые, например, генерируют отчет по
      большим таблицам и/или с помощью сложных соединений (join), они могут
      довольно долго выполняться. Генераторы могут быть полезны двумя
      способами: они могут предоставить вам <quote>счетчик прогресса</quote>,
      который вы можете периодически опрашивать на стороне клиента и следить
      за работой процедуры, и они могут быть использованы для остановки хранимой
      процедуры:</para>

      <programlisting>CREATE GENERATOR gen_spTestProgress;
CREATE GENERATOR gen_spTestStop;

set term ^;

CREATE PROCEDURE spTest (...)
AS
BEGIN
  (...)
  for select &lt;огромное количество данных с огромным временем обработки&gt;
  do begin
    GEN_ID(gen_spTestProgress, 1);

    IF (GEN_ID(gen_spTestStop, 0) &gt; 0) THEN Exit;

    (...нормальная обработка данных...)
  end
END^</programlisting>

      <para>Это просто набросок, но вы должны уловить идею. С клиента вы
      можете выполнять GEN_ID(gen_spTestProgress, 0) асинхронно с реальной
      обработкой записей (например, в другом потоке [thread]), чтобы посмотреть,
      сколько записей было обработано, и отображать полученное значение в
      некотором окне прогресса. Так же вы можете выполнить
      GEN_ID(gen_spTestStop, 1), чтобы прекратить работу процедуры в любое время
      <quote>извне</quote> процедуры.</para>

      <para>Хотя это может быть очень удобно, но здесь есть строгие
      ограничения: <emphasis>это не безопасно в многопользовательской
      среде</emphasis>. Если процедура будет запущена одновременно в двух
      транзакциях, они обе будут увеличивать
      один и тот же счетчик одновременно, так что результат
      будет бессмысленным. Хуже того, увеличение останавливающего
      генератора немедленно остановит процедуру в <emphasis>обеих</emphasis>
      транзакциях. Но, например, для месячных отчетов, которые генерируются
      единственным модулем в пакетном режиме, это может быть приемлемо -
      обычно, это зависит от ваших потребностей.</para>

      <para>Если вы хотите использовать эту технику и позволять
      <emphasis>пользователям</emphasis> вызывать процедуру в любое время, вы должны
      убедиться другими средствами, что хранимая процедура не может быть запущена дважды.
      Подумав об этом, я предлагаю использовать для этого другой генератор:
      давайте назовем его gen_spTestLocked (предполагается, конечно же, что
      начальное значение равно 0):</para>

      <programlisting>CREATE GENERATOR gen_spTestProgress;
CREATE GENERATOR gen_spTestStop;
CREATE GENERATOR gen_spTestLocked;

set term ^;

CREATE PROCEDURE spTest (...)
AS
DECLARE VARIABLE lockcount INTEGER;
BEGIN
  lockcount = GEN_ID(gen_spTestLocked, 1); 
    /* Самый первый шаг: инкремент блокирующего генератора */

  if (lockcount = 1) then /* _мы_ получили блокировку, продолжаем */
  begin
    (..."обычное" тело процедуры...)
  end

  lockcount = GEN_ID(gen_spTestLocked, -1); /* выполняем декремент */

  /* Убеждаемся, что генератор сброшен в самом конце, когда исключение было 
     выброшено внутри <quote>обычного</quote> тела процедуры: */
     
  WHEN ANY DO
    lockcount = GEN_ID(gen_spTestLocked, -1); /* декрементируем */
  exit;
END^</programlisting>

      <para><emphasis role="bold">Примечание.</emphasis> Я не уверен на 100%,
      что это абсолютно безопасно для многопользовательской среды, но это
      позволит выполнить блокировку до тех пор, пока не произойдет ВЫХОД из
      тела процедуры, после чего процедура завершит свою работу, а до этого генератор
      остается инкрементированным. Выражение <database>WHEN ANY</database>
      обрабатывает исключения, но это не нормальный <database>EXIT</database>.
      При этом вы декрементируете генератор вручную - но вы должны
      декрементировать генератор непосредственно перед выходом
      (<database>EXIT</database>). Принимайте все меры предосторожности, я не
      могу воссоздать ситуацию, когда бы этот механизм не сработал... Если вы
      можете, дайте нам знать!</para>
    </section>
  </section>

  <appendix id="generatorguide-dochist-ru">
    <title>История документа</title>

    <para>Полная история документа записана в модуле <filename
    class="directory">manual</filename> в нашем дереве CVS; смотрите <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>4 апр 2006</date>

          <authorinitials>FI</authorinitials>

          <revdescription>
            <para>Первая редакция.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>7 мая 2006</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Добавлен синтаксис SEQUENCE и другая информация относительно
            СУБД Firebird 2.</para>

            <para>Добавлена информация: важные замечания о клиентских
            диалектах; оператор SHOW GENERATOR и его коллеги; удаление
            генераторов и упаковка места хранения генераторов.</para>

            <para>Изменены и расширены следующие разделы:
            <citetitle>Где хранятся генераторы?</citetitle>, <citetitle>Каково
            максимальное значение генератора?</citetitle>, <citetitle>Сколько
            генераторов...?</citetitle>, <citetitle>Использование операторов для
            генераторов</citetitle>.</para>

            <para>Другие изменения, дополнения и корректировки различных
            разделов, в основном в первой половине документа. Небольшие
            изменения второй половины (начиная с <citetitle>Использование
            генераторов для создания уникальных идентификаторов
            строк</citetitle>).</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2-ru</revnumber>

          <date>23 окт 2006</date>

          <authorinitials>SK</authorinitials>

          <revdescription>
            <para>Документ переведен на русский язык.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2-ru</revnumber>

          <date>29 окт 2006</date>

          <authorinitials>PM</authorinitials>

          <revdescription>
            <para>Корректировка перевода на русский язык.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="generatorguide-license-ru">
    <title>Лицензионное соглашение</title>

    <para>Содержимое этой документации распространяется на условиях Public
    Documentation License Version 1.0 (<quote>Лицензия</quote>); вы можете
    использовать эту документацию, если вы выполняете условия Лицензии. Копия
    Лицензии доступна на <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) и <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>Оригинальное название документа: <citetitle>Firebird Generator
    Guide</citetitle>.</para>

    <para>Автор исходного документа: Frank Ingermann.</para>

    <para>Copyright (C) 2006. Все права защищены. Адрес электронной почты для
    контакта с автором: frank at fingerman dot de.</para>

    <para>Соавтор: Paul Vinkenoog – см. <link
    linkend="generatorguide-dochist-ru">историю документа</link>.</para>

    <para>Части документа, созданные Paul Vinkenoog: Copyright (C) 2006. Все
    права защищены. Контактный адрес электронной почты:
    paul at vinkenoog dot nl.</para>

    <para>Перевод на русский язык: Сергей Ковалёв.</para>

    <para>Copyright (C) 2006. Все права защищены. Контактный адрес электронной
    почты: mrKovalev at yandex dot ru.</para>

    <para>Корректор перевода: Павел Меньщиков.</para>

    <para>Copyright (C) 2006. Все права защищены. Контактный адрес электронной
    почты: developer at ls-software dot ru.</para>
  </appendix>
</article>
