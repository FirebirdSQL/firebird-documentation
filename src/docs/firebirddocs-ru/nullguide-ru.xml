<?xml version="1.0" encoding="UTF-8"?>
<!-- For standalone validation, uncomment the following DOCTYPE declaration. -->
<!--
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
-->
<article id="nullguide-ru" lang="ru">
  <articleinfo>
    <title>Помощь по Null в Firebird</title>

    <subtitle>Подводные камни и поведение <constant>NULL</constant> в СУБД
    Firebird</subtitle>

    <author>
      <firstname>Paul</firstname>
      <surname>Vinkenoog</surname>
    </author>

    <othercredit class="translator">
      <firstname>Сергей</firstname>
      <surname>Ковалёв</surname>
      <contrib>Перевод документа на русский язык</contrib>
    </othercredit>

    <edition>25 сентября 2006 - Версия документа 0.2.ru</edition>
  </articleinfo>

  <section id="nullguide-intro-ru">
    <title>Введение</title>

    <para>Время от времени в службу поддержки Firebird приходят вопросы,
    касающиеся <quote>странных вещей</quote>, происходящих с
    <constant>NULL</constant> в СУБД Firebird. Концепция кажется сложной
    для понимания - возможно, частично это вызвано названием, которое наводит
    на мысль, что ничего <quote>плохого</quote> не произойдет, если вы
    прибавите это к числу или добавите его в конец строки. На самом деле,
    выполнение этих операций приведет к тому, что все выражение окажется
    равным <constant>NULL</constant>.</para>

    <para>Эта статья исследует поведение <constant>NULL</constant> в СУБД Firebird,
    обозначая общие ошибки, и показывает вам, каким образом обезопасить
    выражения, которые содержат <constant>NULL</constant> или могут принимать
    значения <constant>NULL</constant>.</para>

    <para>Если вам нужна просто короткая справка, чтобы освежить
    свою память, перейдите к <link
    linkend="nullguide-summary-ru">заключению</link> (которое, действительно,
    является очень кратким).</para>

    <note>
      <para>Некоторые предложения и примеры в этом руководстве были
      позаимствованы из <citetitle>Firebird Quick Start Guide</citetitle>,
      которое впервые было опубликовано компанией IBPhoenix, теперь являющейся частью
      Firebird Project.</para>
    </note>
  </section>

  <section id="nullguide-whatisnull-ru">
    <title>Что такое <constant>NULL</constant>?</title>

    <para>В SQL <constant>NULL</constant> не является значением - это
    <emphasis>состояние</emphasis>, указывающее, что значение элемента
    неизвестно или не существует. Это не ноль, не пустота, не <quote>пустая
    строка</quote>, и оно не ведет себя как какое-то из этих значений.
    Некоторые вопросы SQL являются более запутанными, чем
    <constant>NULL</constant>, и его работа станет не сложна для понимания,
    как только вы запомните следующее простое определение:
    <constant>NULL</constant> - значит <emphasis>неизвестно</emphasis>.</para>

    <para>Позвольте мне повторить, что:</para>

    <blockquote>
      <para><emphasis role="bold"><constant>NULL</constant> означает
      НЕИЗВЕСТНО</emphasis></para>
    </blockquote>

    <para>Держите эту строку в уме во время чтения оставшейся части статьи, и
    большинство, на первый взгляд, нелогичных результатов, где вы получаете
    <constant>NULL</constant>, на практике объяснят сами себя.</para>
  </section>

  <section id="nullguide-null-in-exps-ru">
    <title><constant>NULL</constant> в выражениях</title>

    <para>Как многие из нас узнали, к своему огорчению,
    <constant>NULL</constant> - заразен: используйте его в числовых, строковых
    выражениях или в выражениях, содержащих дату/время, и в результате вы
    всегда получите <constant>NULL</constant>; используйте его в логических (булевых)
    выражениях, и результат будет зависеть от типа опрерации и других
    вовлеченных значений.</para>

    <para>Пожалуйста обратите внимание, что в СУБД Firebird версий до 2.0 чаще
    всего недопустимо прямое использование константы <constant>NULL</constant>
    в операциях и сравнениях. Если вы видите <constant>NULL</constant> в
    приведенных ниже выражениях, понимайте это как <quote>значение поля, переменной или
    другого выражения, результат вычисления которого есть
    <constant>NULL</constant></quote>.</para>

    <section id="nullguide-expr-returning-null-ru">
      <title>Выражения, возвращающие <constant>NULL</constant></title>

      <para>Выражения в этом списке <emphasis>всегда</emphasis> возвратят
      <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal>1 + 2 + 3 +
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>'Home ' || 'sweet ' ||
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>MyField = <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>MyField &lt;&gt;
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>not (<constant>NULL</constant>)</literal></para>
        </listitem>
      </itemizedlist>

      <para>Если вам трудно понять, почему, вспомните, что
      <constant>NULL</constant> - значит <quote>неизвестно</quote>. Также
      давайте взглянем на следующую таблицу, где приведено объяснение каждого
      случая. В таблице мы не пишем <constant>NULL</constant> в выражении (как
      уже упоминалось, часто это недопустимо); вместо этого мы используем две
      сущности - A и B - которые обе являются <constant>NULL</constant>. A и
      B могут быть значениями полей, переменных или целых выражений со своими
      собственными правилами - но если только они являются
      <constant>NULL</constant>, они ведут себя одинаково в приведенных
      выражениях.</para>

      <table>
        <title>Операции с <constant>NULL</constant>-сущностями A и B</title>

        <tgroup cols="3">
          <colspec colname="colExpr" colnum="1" colwidth="4*" />

          <colspec colname="colResult" colnum="2" colwidth="*" />

          <colspec align="left" colname="colReason" colnum="3" colwidth="6*" />

          <thead>
            <row>
              <entry align="center">Если A и B являются <constant>NULL</constant>,
              то:</entry>

              <entry align="center">Получаем:</entry>

              <entry align="center">Потому что:</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>1 + 2 + 3 + A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Если A незвестно, то 6 + A также неизвестно.</entry>
            </row>

            <row>
              <entry><literal>'Home ' || 'sweet ' || A </literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Если A неизвестно, 'Home sweet ' || A -
              неизвестно.</entry>
            </row>

            <row>
              <entry><literal>MyField = A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Если A неизвестно, вы не можете сказать, имеет ли MyField
              то же самое значение...</entry>
            </row>

            <row>
              <entry><literal>MyField &lt;&gt; A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>...но вы так же не можете сказать, имеет ли MyField
              <emphasis>отличающееся</emphasis> значение!</entry>
            </row>

            <row>
              <entry><literal>A = B</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Если A и B незивестны, невозможно знать равны ли
              они.</entry>
            </row>

            <row>
              <entry><literal>not (A)</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry>Если A неизвестно, инвертированное значение также
              неизвестно.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>

    <section id="nullguide-boolean-expressions-ru">
      <title><constant>NULL</constant> в логических выражениях</title>

      <para>Мы уже рассмотрели, что
      <literal>not(<constant>NULL</constant>)</literal> дает в результате
      <constant>NULL</constant>. Для операторов <literal>and</literal> (логическое
      <literal>И</literal>) и <literal>or</literal> (логическое <literal>ИЛИ</literal>)
      взаимодействие несколько сложнее:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal><constant>NULL</constant> or
          <constant>false</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> or
          <constant>true</constant> =
          <constant>true</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> or
          <constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> and
          <constant>false</constant> =
          <constant>false</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> and
          <constant>true</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> and
          <constant>NULL</constant> =
          <constant>NULL</constant></literal></para>
        </listitem>
      </itemizedlist>

      <para>В СУБД Firebird не существует логического (булева) типа данных, тем не менее
      существуют константы <constant>true</constant> (истина) и
      <constant>false</constant> (ложь). В левой колонке таблицы с объяснениями,
      которую вы видите ниже, <literal>(true)</literal> и
      <literal>(false)</literal> представляют собой вложенные выражения,
      возвращающие
      <constant>true</constant>/<constant>false</constant>.</para>

      <table>
        <title>Логические (булевые) операции с <constant>NULL</constant>-сущностью A</title>

        <tgroup cols="3">
          <colspec colname="colExpr" colnum="1" colwidth="4*" />

          <colspec colname="colResult" colnum="2" colwidth="*" />

          <colspec align="left" colname="colReason" colnum="3" colwidth="6*" />

          <thead>
            <row>
              <entry align="center">Если A является <constant>NULL</constant>,
              то:</entry>

              <entry align="center">Получаем:</entry>

              <entry align="center">Потому что:</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><literal>A or (false)</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A or
              <constant>false</constant></literal></quote> всегда имеет то же
              значение, что и A, которое неизвестно.</entry>
            </row>

            <row>
              <entry><literal>A or (true)</literal></entry>

              <entry><literal><constant>true</constant></literal></entry>

              <entry><quote><literal>A or
              <constant>true</constant></literal></quote> всегда
              <constant>true</constant> - содержимое A не важно.</entry>
            </row>

            <row>
              <entry><literal>A or A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A or A</literal></quote> всегда равно A,
              которое является <constant>NULL</constant>.</entry>
            </row>

            <row>
              <entry><literal>A and (false)</literal></entry>

              <entry><literal><constant>false</constant></literal></entry>

              <entry><quote><literal>A and
              <constant>false</constant></literal></quote> всегда
              <constant>false</constant> - содержимое A не важно.</entry>
            </row>

            <row>
              <entry><literal>A and (true)</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A and
              <constant>true</constant></literal></quote> всегда имеет то же
              значение, что и A, которое неизвестно.</entry>
            </row>

            <row>
              <entry><literal>A and A</literal></entry>

              <entry><literal><constant>NULL</constant></literal></entry>

              <entry><quote><literal>A and A</literal></quote> всегда равно A,
              которое является <constant>NULL</constant>.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Все эти результаты находятся в соответствии с булевой логикой.
      Факт состоит в том, что в порядке вычисления <quote><literal>X or
      <constant>true</constant></literal></quote> и <quote><literal>X and
      <constant>false</constant></literal></quote> вам просто нет
      <emphasis>необходимости</emphasis> знать значение X, что так же
      базируется на известной особенности, которую мы знаем в различных языках
      программирования под названием <quote>сокращенное (ускоренное) вычисление
      булевых выражений</quote>.</para>
    </section>

    <section id="nullguide-more-logic-ru">
      <title>Больше логики (или нет)</title>

      <para>Полученные выше результаты сокращенного вычисления могут привести вас
      к следующим идеям:</para>

      <itemizedlist>
        <listitem>
          <para>0 умноженное на <varname>x</varname> равно 0 для любого
          <varname>x</varname>. Поэтому, даже если значение
          <varname>x</varname> неизвестно, <literal>0 * x</literal> равно 0.
          (Обратите внимание: это верно только если <varname>x</varname> имеет
          числовой тип данных, а не <constant>NaN</constant> или
          бесконечность.)</para>
        </listitem>

        <listitem>
          <para>Пустая строка располагается лексикографически перед любой
          другой строкой. Поэтому, <literal>S &gt;= ''</literal> равно true не
          зависимо от значения S.</para>
        </listitem>

        <listitem>
          <para>Каждое значение равно самому себе, независимо от того,
          известно оно или нет. Таким образом, хотя <literal>A = B</literal>
          обоснованно вернет <constant>NULL</constant>, если A и B являются
          различными <constant>NULL</constant>-сущностями, <literal>A =
          A</literal> должно всегда возвращать <constant>true</constant>, даже
          если A является <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>

      <para>Как это реализовано в СУБД Firebird? Что ж, мне очень жаль, но я
      должен сообщить вам, что, несмотря на такую неотразимую логику и
      аналогию с результатами булевых операций, описанных выше, следующие
      выражения всегда дают в итоге <constant>NULL</constant>:</para>

      <itemizedlist spacing="compact">
        <listitem>
          <para><literal><constant>0 * NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal><constant>NULL</constant> &gt;= ''</literal></para>
        </listitem>

        <listitem>
          <para><literal>'' &lt;= <constant>NULL</constant></literal></para>
        </listitem>

        <listitem>
          <para><literal>A = A</literal> (если A является полем или переменной
          со значением <constant>NULL</constant>)</para>
        </listitem>
      </itemizedlist>

      <para>Это сделано, чтобы быть последовательными.</para>
    </section>

    <section id="nullguide-aggregate-functions-ru">
      <title><constant>NULL</constant> в агрегатных функциях</title>

      <para>В агрегатных функциях, таких как <function>COUNT</function>,
      <function>SUM</function>, <function>AVG</function>,
      <function>MAX</function> и <function>MIN</function>,
      <constant>NULL</constant> обрабатывается отличным образом: для
      вычисления результата принимаются в рассмотрение только значения полей,
      не содержащие <constant>NULL</constant>. То есть, если у вас есть такая
      таблица:</para>

      <segmentedlist>
        <title>MyTable</title>

        <segtitle>ID</segtitle>

        <segtitle>Name</segtitle>

        <segtitle>Amount</segtitle>

        <seglistitem>
          <seg>1</seg>

          <seg>John</seg>

          <seg>37</seg>
        </seglistitem>

        <seglistitem>
          <seg>2</seg>

          <seg>Jack</seg>

          <seg>&lt;<constant>NULL</constant>&gt;</seg>
        </seglistitem>

        <seglistitem>
          <seg>3</seg>

          <seg>Joe</seg>

          <seg>5</seg>
        </seglistitem>

        <seglistitem>
          <seg>4</seg>

          <seg>Josh</seg>

          <seg>12</seg>
        </seglistitem>

        <seglistitem>
          <seg>5</seg>

          <seg>Jay</seg>

          <seg>&lt;<constant>NULL</constant>&gt;</seg>
        </seglistitem>
      </segmentedlist>

      <para>...выражение <userinput>select sum(Amount) from
      MyTable</userinput> вернет 54, что получается из 37 + 5 + 12. Если бы все
      пять значений полей были просуммированы, в результате должен был бы получиться
      <constant>NULL</constant>. Для <function>AVG</function> суммируются значения полей,
      не содержащие <constant>NULL</constant>, а сумма делится на количество таких
      значений.</para>

      <para>Есть одно исключение из этого правила:
      <function>COUNT(*)</function> вернет количество всех записей, даже тех
      записей, значения всех полей которых являются <constant>NULL</constant>. Но
      <function>COUNT</function>(<parameter>ИмяПоля</parameter>) ведет себя
      как и остальные агрегатные функции, то есть считает записи, в
      которых значение указанного поля не является <constant>NULL</constant>.</para>

      <para>Еще одно свойство достойно упоминания.
      <function>COUNT(*)</function> и
      <function>COUNT(<parameter>ИмяПоля</parameter>)</function> никогда не
      вернут <constant>NULL</constant>: если нет записей в наборе данных, обе
      функции вернут 0. Также,
      <function>COUNT(<parameter>ИмяПоля</parameter>)</function> вернет 0,
      если все значения поля <parameter>ИмяПоля</parameter> в наборе данных являются
      <constant>NULL</constant>. Другие агрегатные функции вернут
      <constant>NULL</constant> в таком случае. Имейте в виду, что даже
      <function>SUM</function> вернет <constant>NULL</constant>, если
      использован пустой набор данных, что противоречит общей логике.</para>
    </section>
  </section>

  <section id="nullguide-udfs-ru">
    <title>Обработка <constant>NULL</constant> в UDF</title>

    <para><firstterm>UDF</firstterm> (<firstterm>User Defined
    Functions</firstterm> - функции, определяемые пользователем) - это
    функции, которые не являются внутренними функциями ядра, они определены в
    отдельных (внешних) модулях. СУБД Firebird сопровождается двумя библиотеками UDF:
    <systemitem class="library">ib_udf</systemitem> (унаследованная от СУБД
    <application>InterBase</application>) и <systemitem
    class="library">fbudf</systemitem>. Вы можете добавить другие библиотеки,
    например купив их, скачав их из Интерента, или написав самостоятельно. UDF не могут
    использоваться <quote>автоматически</quote>, как встроенные функции, - сначала их нужно
    <quote>декларировать</quote> в базе данных. Это так же верно и для UDF,
    которые поставляются в стандартных библиотеках с СУБД Firebird.</para>

    <section id="nullguide-udfs-conversions-ru">
      <title>Преобразование <constant>NULL</constant> &lt;-&gt;
      не-<constant>NULL</constant>, о котором вы не просите</title>

      <para>Рассказ о том, как объявлять, использовать и писать UDF выходит
      за пределы темы, рассматриваемой этим руководством. Однако, мы должны
      предупредить вас, что UDF порой выполняют неожиданное преобразование
      <constant>NULL</constant>. Иногда это приводит к тому, что
      входной <constant>NULL</constant> конвертируется в обыкновенное значение,
      а в других случаях происходит изменение верного входного значения, например,
      <literal>''</literal> (пустая строка), на <constant>NULL</constant>.</para>

      <para>Основной причиной этой проблемы является <quote>старый
      стиль</quote> вызова UDF, при котором невозможно передать
      <constant>NULL</constant> в качестве входного аргумента функции. Когда
      вызывается такая функция, как <function>LTRIM</function> (отсечение слева) с
      аргументом <constant>NULL</constant>, аргумент передается в функцию в
      виде пустой строки. Изнутри функции <emphasis>нет способа</emphasis>
      определить, является ли аргумент действительно пустой строкой или
      значением <constant>NULL</constant>. Что же в таком случае делать
      автору функции? У него есть выбор: либо брать аргумент по полученному
      значению, либо считать, что первоначально это был
      <constant>NULL</constant> и поступать с ним соответственно.</para>

      <para>В зависимости от типа результата, вернуть
      <constant>NULL</constant> может быть возможным, даже если получить
      <constant>NULL</constant> невозможно. Таким образом, могут произойти
      следующие неожиданные вещи:</para>

      <itemizedlist>
        <listitem>
          <para>Вы вызваете функцию с аргументом <constant>NULL</constant>. Он
          передается как значение, например, 0 или <literal>''</literal>.
          Внутри функции этот аргумент не изменяется назад на
          <constant>NULL</constant>, и возвращается не-<constant>NULL</constant>
          результат.</para>
        </listitem>

        <listitem>
          <para>Вы вызываете функцию с верным аргументом, таким как 0 или
          <literal>''</literal>. Он передается как есть (очевидно). Но код функции
          предполагает, что это значение на самом деле представляет собой
          <constant>NULL</constant>, и, ввиду отсутствия других ориентиров, трактует
          и возвращает его как <constant>NULL</constant>.</para>
        </listitem>
      </itemizedlist>

      <para>Оба преобразования являются не желательными, но второе, вероятно,
      более не желательно, чем первое (лучше предположить значение для
      <constant>NULL</constant>, чем утерять верное значение). Если вернуться
      к нашему примеру с <function>LTRIM</function>:
      до версии Firebird 1.0.3 (включительно) эта функция возвращала
      <constant>NULL</constant>, если вы передавали ей пустую строку; а начиная
      с версии 1.5 она больше не возвращает <constant>NULL</constant>. В этих
      последних версиях строка <constant>NULL</constant> <quote>обрезается</quote> до пустой
      строки. Это не правильно, но здесь выбрано меньшее из двух зол: в более
      ранней версии верные пустые строки безжалостно превращались в
      <constant>NULL</constant> - строки с неизвестным значением.</para>
    </section>

    <section id="nullguide-udfs-conversions-prepare-ru">
      <title>Быть готовым к нежелательным преобразованиям</title>

      <para>Нежелательные преобразования, описанные выше, обычно случаются
      только со старыми (давно существующими и не адаптировавшимися) библиотеками UDF, но их существует
      довольно много (чаще всего встречается в <systemitem class="library">ib_udf</systemitem>).
      Также, ничего не предостерегает небрежного разработчика от подобных ошибок в
      функциях нового стиля. Итак, если вы используете UDF и не знаете, как
      функция ведет себя с аргументами, содержащими <constant>NULL</constant>, то:</para>

      <procedure>
        <step>
          <para>Посмотрите на декларацию функции, чтобы увидеть, как передаются
          аргументы и возвращаются значения. Если там сказано <quote>by
          descriptor</quote>, это должно быть безопасно (хотя осуществить дополнительную
          проверку никогда не помешает). Во всех остальных случаях
          обратитесь к остальным пунктам.</para>
        </step>

        <step>
          <para>Если у вас есть исходный код и вы понимаете язык, на котором
          написана библиотека функций (например, C/C++),
          проверьте код функции.</para>
        </step>

        <step>
          <para>Проверьте функцию на корректность ее работы с входным параметром
          <constant>NULL</constant> и с обычным входным параметром, который может быть
          интерпретирован функцией как <constant>NULL</constant> (0 для числовых аргументов
          и/или <literal>''</literal> для строковых аргументов).</para>
        </step>

        <step>
          <para>Если функция выполняет нежелательное преобразование
          <constant>NULL</constant> &lt;-&gt; не-<constant>NULL</constant>, вы
          должны учитывать это в вашем коде прежде, чем будете вызывать UDF
          (смотрите также <link linkend="nullguide-testing-for-null-ru">Проверка
          на <constant>NULL</constant></link> где-то в этом
          руководстве).</para>
        </step>
      </procedure>

      <para>Декларации функций для сопровождающих библиотек UDF могут быть найдены в
      подкаталоге Firebird <filename class="directory">bin/examples</filename>
      (v. 1.0) или <filename class="directory">bin/UDF</filename> (v. 1.5 и
      старше). Смотрите файлы с расширением <filename
      class="extension">.sql</filename></para>
    </section>

    <section id="nullguide-udfs-links-ru">
      <title>Еще об UDF</title>

      <para>Чтобы больше узнать об UDF, обратитесь к <citetitle>InterBase 6.0
      Developer's Guide</citetitle> (скачать бесплатно на <ulink
      url="http://www.ibphoenix.com/downloads/60DevGuide.zip">http://www.ibphoenix.com/downloads/60DevGuide.zip</ulink>),
      <citetitle>Using Firebird</citetitle> и <citetitle>Firebird Reference
      Guide</citetitle> (оба на CD), или <citetitle>Firebird Book</citetitle>.
      CD и книга могут быть приобретены через <ulink
      url="http://www.ibphoenix.com/">http://www.ibphoenix.com/</ulink>.</para>
    </section>
  </section>

  <section id="nullguide-if-statements-ru">
    <title><constant>NULL</constant> в операторе <literal>if</literal></title>

    <titleabbrev><constant>NULL</constant> в операторе if</titleabbrev>

    <para>Если выражение оператора <literal>if</literal> вычисляется
    как <constant>NULL</constant>, то предложение <literal>then</literal>
    пропускается и выполняется предложение <literal>else</literal> (если оно
    есть). Но берегитесь! В этом случае значение выражения может <emphasis>вести
    себя</emphasis>, подобно <constant>false</constant>, но это
    не значит, что <emphasis>значение</emphasis> равно
    <constant>false</constant>. Это все еще <constant>NULL</constant>, могут
    произойти непонятные вещи, если вы забудете об этом. Следующие примеры
    рассматривают несколько ужасающее поведение <constant>NULL</constant> в
    операторе <literal>if</literal>:</para>

    <itemizedlist>
      <listitem>
        <para><programlisting>if (a = b) then
  MyVariable = 'Equal';
else
  MyVariable = 'Not equal';</programlisting></para>

        <para>Если <varname>a</varname> и <varname>b</varname> оба
        <constant>NULL</constant>, <varname>MyVariable</varname> станет равно
        <quote><literal>Not equal</literal></quote> после выполнения этого
        кода. Причина состоит в том, что выражение <quote><literal>a =
        b</literal></quote> дает в итоге <constant>NULL</constant>, если
        хотя бы один из аргументов <constant>NULL</constant>. Если значение тестового
        выражения <constant>NULL</constant>, то блок <literal>then</literal>
        пропускается, а исполняется блок <literal>else</literal>.</para>
      </listitem>

      <listitem>
        <para><programlisting>if (a &lt;&gt; b) then
  MyVariable = 'Not equal';
else
  MyVariable = 'Equal';</programlisting></para>

        <para>Здесь, <varname>MyVariable</varname> станет
        <quote><literal>Equal</literal></quote>, если <varname>a</varname>
        является <constant>NULL</constant>, а <varname>b</varname> - нет,
        или наоборот. Объяснение аналогчично приведенному в предыдущем
        примере.</para>
      </listitem>

      <listitem>
        <para><programlisting>if (not (a &lt;&gt; b)) then
  MyVariable = 'Equal';
else
  MyVariable = 'Not equal';</programlisting></para>

        <para>Это выглядит так, как будто здесь будет получен тот же самый
        результат, как и в предыдущем примере. Не так ли? После всего мы
        инвертируем тестовое выражение и меняем местами предложения
        <literal>then</literal> и <literal>else</literal>. И на самом деле,
        если ни одна из переменных не является <constant>NULL</constant>,
        оба фрагмента кода эквивалентны. Но как только <varname>a</varname>
        или <varname>b</varname> становятся <constant>NULL</constant>, то
        же получаем и для всего тестового выражения, и выполняется предложение
        <literal>else</literal>, а в результате получаем <quote><literal>Not
        equal</literal></quote>.</para>

        <note>
          <para>Конечно мы в курсе, что третий пример полностью эквивалентен
          первому. Мы просто привели его, чтобы еще раз подчеркнуть, что
          <literal>not(<constant>NULL</constant>)</literal> является
          <constant>NULL</constant>. Таким образом, в случае, когда
          тестовое выражение вычисляется, как <constant>NULL</constant>,
          <function>not()</function> не инвертирует его.</para>
        </note>
      </listitem>
    </itemizedlist>
  </section>

  <section id="nullguide-testing-for-null-ru">
    <title>Проверка на <constant>NULL</constant></title>

    <para>В свете того, какой беспорядок может навести <constant>NULL</constant>,
    вы часто захотите узнать, является ли что-либо
    <constant>NULL</constant> <emphasis>прежде</emphasis>, чем вы будете
    использовать это в выражении. Для некоторых очевидная проверка должна
    выглядеть так:</para>

    <blockquote>
      <para><literal>if (A = <constant>NULL</constant>)
      then...</literal></para>
    </blockquote>

    <para>И в самом деле, есть системы управления базами данных, которые
    поддерживают такой синтаксис проверки на <constant>NULL</constant>. Но
    стандарт SQL не допускает этого, не допускает этого и СУБД Firebird. В версиях
    до 2.0 такой синтаксис был даже недопустим. С версии 2.0 он разрешается,
    но сравнение всегда вернет <constant>NULL</constant>, независимо от
    состояния и значения A. Поэтому такой тест на <constant>NULL</constant>
    является бесполезным - нам нужен явный результат <constant>true</constant>
    или <constant>false</constant>.</para>

    <para>Корректный способ проверки на <constant>NULL</constant>
    такой:</para>

    <blockquote>
      <para><literal>...is null</literal> / <literal>...is not
      null</literal></para>
    </blockquote>

    <para>Эта проверка всегда вернет <constant>true</constant> или
    <constant>false</constant> - и никакой неразберихи. Примеры:</para>

    <itemizedlist>
      <listitem>
        <para><programlisting>if (MyField is null) then...</programlisting></para>
      </listitem>

      <listitem>
        <para><programlisting>select * from Pupils where PhoneNumber is not null</programlisting></para>
      </listitem>

      <listitem>
        <para><programlisting>select * from Pupils where not (PhoneNumber is null)
/* делает то же самое, что и предыдущий пример */</programlisting></para>
      </listitem>

      <listitem>
        <para><programlisting>update Numbers set Total = A + B + C where A + B + C is not null</programlisting></para>
      </listitem>
    </itemizedlist>

    <para>Можно сказать, что в то время как равенство <quote><emphasis
    role="bold"><literal>=</literal></emphasis></quote> (когда используется
    как оператор равенства) может сравнивать значения, <quote><emphasis
    role="bold"><literal>is</literal></emphasis></quote> проверяет
    состояние.</para>
  </section>

  <section id="nullguide-assigning-null-ru">
    <title>Установка значения поля или переменной в <constant>NULL</constant></title>

    <para>Поля и переменные могут быть установлены в <constant>NULL</constant>
    с помощью того же синтаксиса, что и для обычных значений:</para>

    <itemizedlist>
      <listitem>
        <para><programlisting>insert into MyTable values (1, 'teststring', NULL, '8-May-2004')</programlisting></para>
      </listitem>

      <listitem>
        <para><programlisting>update MyTable set MyField = null where YourField = -1</programlisting></para>
      </listitem>

      <listitem>
        <para><programlisting>if (Number = 0) then MyVariable = null;</programlisting></para>
      </listitem>
    </itemizedlist>

    <para>- <quote>Минуточку... но вы сказали, что <literal>MyField =
    NULL</literal> было недопустимо!</quote></para>

    <para>Это верно... для <emphasis>оператора сравнения</emphasis>
    <quote><literal>=</literal></quote> (по крайней мере для СУБД Firebird до
    версии 2.0). Но здесь мы говорим о знаке <quote><literal>=</literal></quote>,
    как об <emphasis>операторе присваивания</emphasis>. К сожалению, в SQL оба
    эти оператора имеют один и тот же символ. В случае присваивания, которое
    выполняется с помощью <quote><literal>=</literal></quote> или внутри
    списка вставки, вы можете трактовать <constant>NULL</constant>, как любое
    другое значение, - специальный синтаксис не требуется.</para>
  </section>

  <section id="nullguide-dealing-with-nulls-ru">
    <title>Взаимодействие с <constant>NULL</constant></title>

    <para>Этот раздел содержит некоторые практические советы и примеры,
    которые могут быть использованы вами в вашей повседневной работе с
    <constant>NULL</constant>.</para>

    <section id="nullguide-test-if-matters-ru">
      <title>Проверка на <constant>NULL</constant> - если это имеет
      значение</title>

      <para>Достаточно часто вам нет необходимости принимать специальные меры
      для полей или переменных, которые могут быть
      <constant>NULL</constant>. Например, если вы делаете так:</para>

      <blockquote>
        <para><programlisting>select * from Customers where Town = 'Ralston'</programlisting></para>
      </blockquote>

      <para>очевидно, что вы не хотите видеть клиентов, город которых не
      указан. Аналогично:</para>

      <blockquote>
        <para><programlisting>if (Age &gt;= 18) then CanVote = 'Yes'</programlisting></para>
      </blockquote>

      <para>не будут включены люди с неизвестным возрастом, что так же
      верно и безопасно. Но:</para>

      <blockquote>
        <para><programlisting>if (Age &gt;= 18) then CanVote = 'Yes';
else CanVote = 'No';</programlisting></para>
      </blockquote>

      <para>выглядит менее обоснованным: если вы не знаете возраст человека, вы
      не можете явно лишить его права голоса. Хуже того:</para>

      <blockquote>
        <para><programlisting>if (Age &lt; 18) then CanVote = 'No';
else CanVote = 'Yes';</programlisting></para>
      </blockquote>

      <para>не принесет ожидаемый результат, как и в предыдущем случае. Если кто-то с
      возрастом <constant>NULL</constant> имеет реальный возраст до 18, вы
      предоставите несовершеннолетнему право голоса!</para>

      <para>Правильным подходом является явная проверка на
      <constant>NULL</constant>:</para>

      <blockquote>
        <para><programlisting>if (Age is null) then CanVote = 'Unsure';
else 
  if (Age &gt;= 18) then CanVote = 'Yes';
  else CanVote = 'No';</programlisting><note>
            <para><literal>else</literal> всегда ссылается на последний
            <literal>if</literal> в этом же блоке. Но чаще всего лучше
            предотвращать путаницу, помещая ключевые слова
            <literal>begin...end</literal> вокруг группы строк. Я не сделал
            этого здесь, чтобы сократить количество строк. И поэтому я был
            вынужден добавить это примечание. ;-)</para>
          </note></para>
      </blockquote>
    </section>

    <section id="nullguide-equality-ru">
      <title>Определение, одинаковы ли значения полей</title>

      <para>Иногда вы хотите определить, являются ли значения двух полей или двух
      переменных одинаковыми, и вы будете считать их равными, если они оба
      <constant>NULL</constant>. Правильной проверкой для этого является следующая:</para>

      <blockquote>
        <para><programlisting>if (A = B or A is null and B is null) then...</programlisting></para>
      </blockquote>

      <para>или, если вы хотите убрать возможное недопонимание:</para>

      <blockquote>
        <para><programlisting>if ((A = B) or (A is null and B is null)) then...</programlisting></para>
      </blockquote>

      <para>Предупреждение. Если только одна из величин A и B является
      <constant>NULL</constant>, тестовое выражение станет
      <constant>NULL</constant>, а не false! Это нормально для оператора
      <literal>if</literal>, и мы даже можем добавить предложение
      <literal>else</literal>, которое будет выполнено, если A и B не равны
      (включая случай, когда одна из величин <constant>NULL</constant>, а другая -
      нет):</para>

      <blockquote>
        <para><programlisting>if (A = B or A is null and B is null) 
  then ...код для выполнения, если A равно B...
  else ...код для выполнения, если A и B различаются...</programlisting></para>
      </blockquote>

      <para>Однако откажитесь от идеи инвертирования выражения и
      использования его как проверки на неэквивалентность (как я это однажды
      сделал):</para>

      <blockquote>
        <para><programlisting>/* Не делайте так! */
if (not(A = B or A is null and B is null))
  then ...код для выполнения, если A отличается от B...</programlisting></para>
      </blockquote>

      <para>Приведенный выше код работает корректно, если оба A и B являются
      <constant>NULL</constant> или оба не являются
      <constant>NULL</constant>. Но в нем не выполняется предложение
      <literal>then</literal>, если только одна из частей (A или B) является
      <constant>NULL</constant>.</para>

      <para>Если вы хотите выполнять что-либо, когда A и B отличаются, вы
      должны либо использовать корректное выражение, приведенное выше, и
      поместить пустой оператор в предложение <literal>then</literal>, или
      использовать это более длинное выражение для проверки:</para>

      <!--В Fb 1.5 и старше, допускаются пустые блоки BEGIN END, так что нет необходимости в пустом операторе.-->

      <blockquote>
        <para><programlisting>/* Это корректный тест на неэквивалентность: */
if (A &lt;&gt; B
    or A is null and B is not null
    or A is not null and B is null) then...</programlisting></para>
      </blockquote>

      <section id="nullguide-field-changed-ru">
        <title>Определение изменения значения поля</title>

        <para>В триггерах часто бывает полезным знать, что значение определенного поля
        изменилось (включая переход от <constant>NULL</constant> к не-<constant>NULL</constant>
        значению и наоборот) или осталось тем же
        самым. Это не что иное, как особый случай использования проверки
        на (не)эквивалентность значений двух полей. Просто вместо A и B используйте
        New.ИмяПоля и Old.ИмяПоля:</para>

        <blockquote>
          <para><programlisting>if (New.Job = Old.Job or New.Job is null and Old.Job is null)
  then ...поле Job осталось тем же...
  else ...поле Job изменилось...</programlisting></para>
        </blockquote>
      </section>
    </section>

    <section id="nullguide-subst-with-value-ru">
      <title>Замещение <constant>NULL</constant> значением</title>

      <section id="nullguide-coalesce-ru">
        <title>Функция <function>COALESCE</function></title>

        <para>В Firebird 1.5 есть функция, которая может конвертировать
        <constant>NULL</constant> во что-то еще. Это позволит вам выполнять
        преобразование <quote>на лету</quote> и использовать результат в
        последующей обработке без необходимости использования конструкции
        <quote><literal>if (MyExpression is null) then</literal></quote>.
        Функция называется <function>COALESCE</function>, и вы можете вызвать
        ее так:</para>

        <blockquote>
          <para><literal>COALESCE(Expr1, Expr2, Expr3, ...)</literal></para>
        </blockquote>

        <para><function>COALESCE</function> возвращает первое не-<constant>NULL</constant>
        выражение из списка аргументов. Если все
        выражения являются <constant>NULL</constant>, она вернет
        <constant>NULL</constant>.</para>

        <para>Вот как вы можете сконструировать полное имя человека с помощью
        <function>COALESCE</function> из первого, среднего и последнего имени,
        предполагая, что среднее имя может иметь значение
        <constant>NULL</constant>:</para>

        <blockquote>
          <para><programlisting>select FirstName
       || coalesce(' ' || MiddleName, '')
       || ' ' || Lastname
from Persons</programlisting></para>
        </blockquote>

        <para>Или для создания наиболее информативного имени, насколько это
        возможно, из таблицы, которая содержит псевдонимы, и в предположении,
        что и псевдоним и первое имя могут быть
        <constant>NULL</constant>:</para>

        <blockquote>
          <para><programlisting>select coalesce (Nickname, FirstName, 'Mr./Mrs.')
       || ' ' || Lastname
from OtherPersons</programlisting></para>
        </blockquote>

        <para><function>COALESCE</function> поможет вам только в тех
        ситуациях, когда <constant>NULL</constant> можно трактовать одинаково,
        как некоторое допустимое значение для типа данных. Если для
        <constant>NULL</constant> необходима специальная обработка, как в
        примере с <quote>правом голоса</quote>, показанном ранее, вы можете
        использовать только выражение <quote><literal>if (MyExpression is
        null) then</literal></quote>.</para>
      </section>

      <section id="nullguide-nvl-ru">
        <title>Firebird 1.0: функции <function>*NVL</function></title>

        <para>В СУБД Firebird 1.0 не существует функции <function>COALESCE</function>.
        Однако, вы можете использовать четыре UDF, которые предоставляют
        бОльшую часть функциональности функции <function>COALESCE</function>.
        Эти UDF расположены в библиотеке
        <filename class="libraryfile">fbudf</filename> и называются</para>

        <itemizedlist spacing="compact">
          <listitem>
            <para><function>iNVL</function> для целочисленных
            аргументво</para>
          </listitem>

          <listitem>
            <para><function>i64NVL</function> для агрументов типа
            bigint</para>
          </listitem>

          <listitem>
            <para><function>dNVL</function> для агрументов типа double
            precision</para>
          </listitem>

          <listitem>
            <para><function>sNVL</function> для строк</para>
          </listitem>
        </itemizedlist>

        <para>Функции <function>*NVL</function> получают
        два аргумента. По аналогии с <function>COALESCE</function>, они
        возвращают первый аргумент, если он не является
        <constant>NULL</constant>; в противном случае они возвращают второй
        аргумент. Пожалуйста, обратите внимание, что это библиотека для
        Firebird 1.0 <filename class="libraryfile">fbudf</filename> - и
        поэтому функции <function>*NVL</function> доступны только для
        Windows.</para>
      </section>
    </section>
  </section>

  <section id="nullguide-summary-ru">
    <title>Заключение</title>

    <para><constant>NULL</constant> в двух словах:</para>

    <itemizedlist>
      <listitem>
        <para><constant>NULL</constant> - значит
        <emphasis>неизвестно</emphasis>.</para>
      </listitem>

      <listitem>
        <para>Если <constant>NULL</constant> фигурирует в выражении, чаще
        всего все выражение даст в результате
        <constant>NULL</constant>.</para>
      </listitem>

      <listitem>
        <para>В агрегатных функциях только не-<constant>NULL</constant> значения полей
        используются при вычислении. Исключение - функция
        <function>COUNT(*).</function></para>
      </listitem>

      <listitem>
        <para>UDF иногда конвертируют <constant>NULL</constant> &lt;-&gt;
        не-<constant>NULL</constant> как бы случайным
        образом.</para>
      </listitem>

      <listitem>
        <para>Если выражение оператора <literal>if</literal>
        вычисляется как <constant>NULL</constant>, то блок
        <literal>then</literal> пропускается, а блок <literal>else</literal>
        выполняется.</para>
      </listitem>

      <listitem>
        <para>Чтобы проверить, что A является <constant>NULL</constant>,
        используйте <quote><literal>A is (not) null</literal></quote>.</para>
      </listitem>

      <listitem>
        <para>Функции <function>COALESCE</function> (1.5) и
        <function>*NVL</function> (1.0) могут конвертировать
        <constant>NULL</constant> в значение.</para>
      </listitem>

      <listitem>
        <para>Присваивание <constant>NULL</constant> выполняется так же, как и
        присваивание значений - с помощью <quote><literal>A =
        NULL</literal></quote> или в списке вставки.</para>
      </listitem>
    </itemizedlist>

    <para>Помните, так работает <constant>NULL</constant> в <emphasis>СУБД
    Firebird</emphasis>. Могут быть (трудно уловимые) отличия в сравнении с другими
    СУБД.</para>
  </section>

  <appendix id="nullguide-dochist-ru">
    <title>История документа</title>

    <para>Точный файл истории записан в модуле <filename
    class="directory">manual</filename> в дереве CVS; смотрите <ulink
    url="http://sourceforge.net/cvs/?group_id=9028">http://sourceforge.net/cvs/?group_id=9028</ulink></para>

    <para><revhistory>
        <revision>
          <revnumber>0.1</revnumber>

          <date>8 Апреля 2005</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Первая редакция.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2</revnumber>

          <date>15 Апреля 2005</date>

          <authorinitials>PV</authorinitials>

          <revdescription>
            <para>Упоминается, что Fb 2.0 допускает сравнение
            <quote><literal>A = NULL</literal></quote>.</para>

            <para>Изменен текст в <quote>Тестирование, что что-то является
            <constant>NULL</constant>'ом</quote>.</para>

            <para>Немного изменен раздел <quote>Работа с
            <constant>NULL</constant>'ами</quote>.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2.ru</revnumber>

          <date>25 сен 2006</date>

          <authorinitials>SK</authorinitials>

          <revdescription>
            <para>Документ переведен на русский язык.</para>
          </revdescription>
        </revision>

        <revision>
          <revnumber>0.2.ru</revnumber>

          <date>19 окт 2006</date>

          <authorinitials>PM</authorinitials>

          <revdescription>
            <para>Корректировка перевода на русский язык.</para>
          </revdescription>
        </revision>
      </revhistory></para>
  </appendix>

  <appendix id="nullguide-license-ru">
    <title>Условия лицензии</title>

    <para>Содержимое этой документации распространяется на условиях Public
    Documentation License Version 1.0 (<quote>Лицензия</quote>); вы можете
    использовать эту документацию, если вы выполняете условия Лицензии. Копия
    Лицензии доступна на <ulink
    url="http://www.firebirdsql.org/pdfmanual/pdl.pdf">http://www.firebirdsql.org/pdfmanual/pdl.pdf</ulink>
    (PDF) и <ulink
    url="http://www.firebirdsql.org/manual/pdl.html">http://www.firebirdsql.org/manual/pdl.html</ulink>
    (HTML).</para>

    <para>Оригинальное название документа: <citetitle>Firebird Null
    Guide</citetitle>.</para>

    <para>Автор исходного документа: Paul Vinkenoog.</para>
    <para>Copyright (C) 2005. Все права защищены. Адрес электронной почты для
    контакта с автором: paulvink at users dot sourceforge dot
    net.</para>

    <para>Перевод на русский язык: Сергей Ковалёв.</para>
    <para>Copyright (C) 2006. Все права защищены. Контактный адрес электронной почты:
    mrKovalev at yandex dot ru.</para>

    <para>Корректор перевода: Павел Меньщиков.</para>
    <para>Copyright (C) 2006. Все права защищены. Контактный адрес электронной почты:
    developer at ls-software dot ru.</para>
  </appendix>
</article>